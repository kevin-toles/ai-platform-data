{
  "metadata": {
    "title": "enterprise-devops-playbook",
    "author": "Bill Ott, Jimmy Pham, and Haluk Saker",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 76,
    "conversion_date": "2025-12-19T18:45:30.463238",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "enterprise-devops-playbook.pdf",
    "extraction_method": "Unstructured"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 3-13)",
      "start_page": 3,
      "end_page": 13,
      "detection_method": "topic_boundary",
      "content": "Table of Contents\n\nForeword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . v\n\nEnterprise DevOps Playbook. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Introduction 1 Play 1: Develop the Team—Culture, Principles, and Roles 6 Play 2: Study the DevOps Practices 12 Play 3: Assess Your DevOps Maturity Level and Define a\n\nRoadmap 43 Play 4: Create a DevOps Pipeline 56 Play 5: Learn and Improve through Metrics and Visibility 58 Summary 65 Recommended Reading 66\n\niii\n\nForeword\n\nDevOps principles and practices are increasingly influencing how we plan, organize, and execute our technology programs. One of my areas of passion is learning about how large, complex organizations are embarking on DevOps transformations.\n\nPart of that journey has been hosting the DevOps Enterprise Sum‐ mit, where leaders of these transformations share their experiences. I’ve asked leaders to tell us about their organization and the industry in which they compete, their role and where they fit in the organiza‐ tion, the business problem they set out to solve, where they chose to start and why, what they did, what their outcomes were, what they learned, and what challenges remain.\n\nOver the past three years, these experience reports have given us ever-greater confidence that there are common adoption patterns and ways to answer important questions such as: Where do I start? Who do I need to involve? What architectures, technical practices, and cultural norms do we need to integrate into our daily work to get the DevOps outcomes we want? The team at Booz Allen Hamil‐ ton has published their model of guiding teams through DevOps programs, and it is clearly based on hard-won experience with their clients. I think it will be of interest to anyone to embarking on a DevOps transformation.\n\n— Gene Kim, coauthor of The DevOps Handbook and The Phoenix Project: A Novel About IT, DevOps, and Helping Your Business Win\n\nv\n\nEnterprise DevOps Playbook\n\nIntroduction If Agile software development (SD) had never been invented, we’d probably have little reason to talk about DevOps. However, there is an intriguing corollary worth pondering, as well: the rise of DevOps has made Agile SD viable.\n\nAgile is a development methodology based on principles that embrace collaboration and constant feedback as the pillars of its iterative process, allowing features to be developed faster and in alignment with what businesses and users need. However, opera‐ tions today are generally moving at a pace that’s still geared toward sequential waterfall processes. As Agile SD took off, new pressures and challenges began building to address delivering new code into test, quality assurance, and production environments as quickly as possible without losing visibility and quality.\n\nWe define DevOps simply as the culture, principles, and processes that automate and streamline the end-to-end flow from code devel‐ opment to delivering the features/changes to users in production. Without DevOps, Agile SD is a powerful tool but with a prominent limitation—it fails to address software delivery. As with other soft‐ ware development processes, Agile stops when production deploy‐ ment begins, opening a wide gap between users, developers, and the operations team because the features developed for a timeboxed sprint won’t be deployed to production until the scheduled release goes out, often times many months later. DevOps enhances Agile SD by filling this critical gap, bridging operations and development as a unified team and process.\n\n1\n\nAgile SD is based in part on short sprints—perhaps a week in dura‐ tion—during which a section of an application or a program feature is developed. Questions arise: “How do you deliver each new version of this software quickly, reliably, securely, and seamlessly to your entire user base? How do you meet the operational requirements to iterate frequent software development and upgrades without con‐ stant disruption and overhead? How do you ensure that continuous improvement in software development translates into continuous improvement throughout the organization? How do you ensure that there is continuous delivery of programs during a sprint as they are developed?” It is from such questions that DevOps has emerged—a natural evolution of the Agile mindset applied to the needs of opera‐ tions. The goals of a DevOps implementation are to fully realize the benefits that Agile SD aims to provide in reducing risk, increasing velocity, and improving quality.\n\nBy integrating software developers, quality control, security engi‐ neers, and IT operations, DevOps provides a platform for new soft‐ ware or for fixes to be deployed into production as quickly as it is coded and tested. That’s the idea, anyway—but it is a lot easier said than done. Although DevOps addresses a fundamental need, it is not a simple solution to master. To excel at DevOps, enterprises must do the following:\n\nTransform their cultures\n\nChange the way software is designed and built following a highly modular mindset\n\nAutomate legacy processes\n\nDesign contracts to enable the integration of operations and development\n\nCollaborate, and then collaborate more\n\nHonestly assess performance\n\nContinually reinvent software delivery strategies based on les‐ sons learned and project requirements.\n\nTo achieve the type of change described is a daunting task, especially with large enterprises that have processes and legacy technologies that are ingrained as part of their business. There are numerous pat‐ terns, techniques, and strategies for DevOps offered by well-known technology companies. However, these approaches tend to be too\n\n2\n\n|\n\nEnterprise DevOps Playbook\n\ngeneral and insufficient by themselves to address the many issues that arise in each DevOps implementation, which vary depending on the organization’s size, user base, resources, priorities, technology capabilities, development goals, and so on. Given these shortcom‐ ings, evident to us from our extended experience with DevOps implementations, Booz Allen has devised an approach for adopting DevOps that is comprehensive yet flexible. Think of this DevOps playbook as your user guide for implementing a practical style of DevOps that stresses teamwork and mission focus to achieve a sin‐ gle unyielding goal: deliver new value to users continually by deliver‐ ing software into production rapidly and efficiently on an ongoing basis.\n\nAs Adam Jacob, founder of Chef, described in his DevOps Kung Fu presentations (available on GitHub and YouTube), there can be dif‐ ferent styles of DevOps that are unique to each organization but fundamentally there are basic foundations, forms, and common principles that make up the elements of DevOps. This book repre‐ sents our perspective and style as we distill DevOps into seven key practice areas that can be adapted for different DevOps styles. The key takeaways are the shared principles, the common practice areas (“elements”), and the goal for each of the seven practice areas.\n\nHow to Use This Playbook This playbook is meant to serve as a guide for implementing DevOps in your organization—a practical roadmap that you can use to define your starting point, the steps, and the plan required to meet your DevOps goals. Based on Booz Allen’s experience and pat‐ terns implementing numerous DevOps initiatives, this playbook is intended to share our style of DevOps that you can use as a refer‐ ence implementation for a wide range of DevOps initiatives, no mat‐ ter their size, scope, or complexity. We have organized this playbook into five plays, as shown in Figure 1-1.\n\nIntroduction\n\n|\n\n3\n\nFigure 1-1. The 5 Plays of the Enterprise DevOps Playbook\n\nGene Kim, one of the top DevOps evangelists in the industry, described DevOps in 2014 as more of a philosophical movement than a set of practices. This is what makes it difficult for organiza‐ tions to embrace DevOps and determine how to begin. This report is intended for teams and organizations of all maturity levels that have been exposed to the benefits and need for DevOps. We do not dive into the economics and the ROI aspects: the goal of this report is to provide organizations with a clear guide, through the five plays that cover all the practice areas that encapsulate DevOps, to assess where you are, to determine what they mean to you and your spe‐ cific business requirements, and to get you started with an early adopter project.\n\nPlay 1: Develop the team—culture, principles, and roles\n\nSuccessful transformational change in an organization depends on the capabilities of its people and its culture. With DevOps, a collaborative effort that requires cross-functional cooperation and deep team engagement is critical. This play details the key DevOps principles and tenets and describes how the organiza‐ tional culture should be structured to achieve a top DevOps performance. You will be able to compare the structure of your organization to the principles in this play to drive the necessary culture change, especially for enterprises in which multiple functional groups (development, testing, and operations), ven‐ dors, and contractors might need to be restructured to enable\n\n4\n\n|\n\nEnterprise DevOps Playbook\n\nthe transparency and automation across the groups. Having the people, culture, and principles in place is essential to an endur‐ ing DevOps practice; the people and the culture will drive suc‐ cess and continual improvement.\n\nPlay 2: Study the DevOps practices\n\nThis play offers a deep dive into each of the seven DevOps prac‐ tices—what they are and how they should be implemented and measured. The objective is for the DevOps project team to gain a baseline understanding of the expectations for each tactical step in the DevOps practice. We include a set of workshop ques‐ tions to facilitate discussions among the DevOps team about the definition and scope of each practice as well as a checklist of key items that we believe are critical in implementing the practice’s activities.\n\nPlay 3: Assess your DevOps maturity level and define a roadmap\n\nAfter there is a common understanding within the DevOps team about each practice, this play enables you to assess your organization’s strengths and weaknesses pertaining to these practices. With that baseline knowledge, you can determine how to improve the practice areas where your organization needs improvement. As you go through this assessment and subsequent improvement efforts, you should refer back to Play 2 to review the definition of each practice area and to scan the checklist to ensure that the organization’s skills are in increasing alignment with DevOps requirements.\n\nPlay 4: Create a DevOps pipeline\n\nThe DevOps pipeline is the engine that puts your DevOps pro‐ cesses, practices, and philosophy into action. The pipeline is the end-to-end implementation of the DevOps workflow that estab‐ lishes the repeatable process for code development—from code check-in to automated testing, to required manual reviews prior to deployment. In this play, we include a DevOps pipeline refer‐ ence to illustrate DevOps workflow activities and tools.\n\nPlay 5: Learn and improve through metrics and visibility You can’t manage what you can’t measure.\n\n—Peter Drucker\n\nThe objective of this play is to define the metrics that you will use to measure the health of your DevOps efforts. Defining\n\nIntroduction\n\n|\n\n5\n\nmetrics is critical to learn how your DevOps efforts can be improved, modified, or extended. The metrics in this play pro‐ vide a holistic viewpoint—they help you know where you are, where you’re going, and how to get there.\n\nPlay 1: Develop the Team—Culture, Principles, and Roles All DevOps success stories—those for which teams are able to han‐ dle multiple workstreams while also supporting continuous deploy‐ ment of changes to production—have one thing in common: the attitudes and culture of the organization are rooted in a series of established DevOps principles and tenets. In this report, we do not explore the specific implementation strategies, because the solutions to achieve these are very unique to your organization; thus, our typi‐ cal DevOps adoption engagements begin with an assessment pro‐ cess during which we do a dive deep to understand the organizational construct, existing processes, gaps, and challenges. We then overlay a DevOps model to see how it would look and determine the steps needed to develop the team.\n\nIn the next section, we introduce a list of key DevOps principles and cultural concepts. Each organization might have a different approach for adopting these tenets, but no matter what techniques you use, integrating the ideas themselves is critical to the success of the DevOps project. In “New DevOps Roles” on page 9, we describe the new roles and responsibilities required for a successful DevOps project.\n\nPrinciples and Culture Many organizations have ambitious goals for adopting DevOps strategies, and an underlying need to do so. Their ability to effec‐ tively serve their customers and clients depends on nimble develop‐ ment and implementation practices. When such endeavors fail, it is often because the enterprise’s culture is not suited for a DevOps pro‐ gram. Following are principles and cultural landmarks that organi‐ zations with successful DevOps implementations exhibit.\n\n6\n\n|\n\nEnterprise DevOps Playbook\n\nTreat operations as first-class citizens\n\nWhen operation engineers are supporting a system in production, developers are working on future releases with their scope and tim‐ ing often determined by new feature requests from product owners and stakeholders. However, operational needs raised by the team during production can occur at any time, and the entire team, including developers, testers, and operations engineers, must treat such requests as priorities with equal weighting as other backlog items.\n\nDevelopers act as first responders to issues with the production system\n\nFor traditional SD, operations teams have their own engineers to address problems with applications as they occur. Even though these employees have the same basic skill sets as development team mem‐ bers, they were not the developers that wrote the code; thus, they are not familiar with how the code was built and probably unaware of the code’s idiosyncrasies. For this reason, developers and operations engineers should work as a team to troubleshoot and repair issues that arise. The actual code developer should be part of the diagnosis team, communicating with the help desk and accessing the logs to find a solution without waiting for the operations team to provide background data. This enforces more accountability on the develop‐ ment team, extending its involvement to even after the software is delivered into production—an essential DevOps principle. With this added responsibility in the latter phases of the project, the develop‐ ment team’s performance during the writing of the software improves because the group is no longer isolated from the mistakes discovered during production.\n\nShorten the time between identification of a production issue and its repair\n\nOften times, production support is reactionary. It is critical to change that mindset if the organization is to become more proactive in identifying potential needs. This could only be achieved if the developer is part of the operations support team. From a production issue perspective, there are many obstacles to communicating or integrating with the development team. Most times, the barrier is the structure of the development and sustainment contracts. For example, separate teams with separate contracts might have a delin‐ eation between their responsibilities, different Service-Level Agree‐ ments (SLAs), and varied processes. Even when separate contracts\n\nPlay 1: Develop the Team—Culture, Principles, and Roles\n\n|\n\n7\n\nare not a problem—that is, when there is only a single contract that covers development, operations, and sustainment—responsibilities and accountability might slow efforts to fix the production problem due to the separation of accountability and manual processes; for example, we often hear statements like, “This is a hosting problem, not an application problem; the sysadmins need to look into it,” or, “We checked everything, it’s over to the quality assurance (QA) team to validate and then the operations team to deploy.”\n\nShorten the time between code commit and code deploy\n\nThere are typically multiple gates that must be passed through before deploying software changes into production to ensure the integrity of the system. Most of these steps can be automated to reduce deployment time as well as to improve quality. However, to enable automation, the architecture of the system must be designed in a manner that is conducive to deploying discrete changes versus deploying the entire application every time.\n\nMinimize coordination to deploy releases\n\nIn traditional SD, there is a lot of inefficient coordination and com‐ munication overhead among teams. This is often necessary because each team has specific and siloed responsibilities and accountability for the project. If constant communication is not the norm, checks and balances will not occur, and quality suffers. Ironically, in a DevOps implementation, it is essential to minimize the formal com‐ munications channels between each group; instead, it is important to establish a culture of shared responsibilities, ongoing interaction, and shared knowledge of every aspect of the project and the auto‐ mated repeatable processes among all teams. Maximizing transpar‐ ency enhances efficiency and quality and reduces the need for constant forced communications.\n\nStop and fix potential defects identified by continuous flow and monitoring\n\nFrequently, defects and bugs in programs reported by users catch organizations by surprise, forcing them into a reactive mode to fix the issue. To avoid this inefficient and potentially harmful situation —which can impact organizational productivity and waste opera‐ tional resources—you should implement a DevOps culture that focuses on constant visibility into all programs and systems to mon‐\n\n8\n\n|\n\nEnterprise DevOps Playbook\n\nitor, identify, and resolve issues before they become so problematic that users are inconvenienced and critical workflow suffers.\n\nEnforce standardized processes to ensure predictable outcomes\n\nExceptions should not be the norm. Informal and diverse processes increase instability and the potential for unpredictable outcomes. Establishing and enforcing repeatable standardized processes is essential. Moreover, it is the cornerstone of automation, which itself is central to an efficient and unified DevOps process.\n\nBecome a learning organization through continual feedback and action\n\nEvery environment is different and all aspects of development and operations are subject to change. The goal is to constantly learn, assess, and analyze what works and what doesn’t. Organizational vis‐ ibility and a culture built on constant improvement is critical to DevOps success. Peter Senge, the founding chair of the Society for Organization Learning, explains in his book, The Fifth Discipline (Doubleday), the importance of having an environment in which “we must create a culture that rewards learning, which often comes from failure. Moreover, we must ensure that what we learn becomes embedded into our institutional memory so that future occurrences are prevented.”\n\nThe adoption of these principles and culture changes requires organizations to define new roles for development and operations teams. We describe several new roles and their associated responsi‐ bilities in a DevOps world in the next section.\n\nNew DevOps Roles Currently, there is a lack of clarity of the new roles and responsibili‐ ties required for DevOps. In this section, we identify the new DevOps roles for you to consider in augmenting your current team with the enhanced mix of talent to implement DevOps practices.\n\nIn an ideal situation, these responsibilities would exist in an autono‐ mous team that manages its own work and working practices and builds, deploys, operates, and maintains software functionality without any additional support from other parts of the organization.\n\nPlay 1: Develop the Team—Culture, Principles, and Roles\n\n|\n\n9",
      "page_number": 3
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 14-21)",
      "start_page": 14,
      "end_page": 21,
      "detection_method": "topic_boundary",
      "content": "The DevOps Team Antipattern We do not believe in the existence of DevOps standalone teams— DevOps responsibilities must exist within the Agile teams. Just like a software developer or tester, a DevOps engineer or an engineer with DevOps skills must take ownership of the feature on which the team is working and work to make the software better for the end user.\n\nThe DevOps architect\n\nThe DevOps architect uses automation to create efficient, effective processes and standards to continuously improve quality and esti‐ mation. The DevOps architect must have deep knowledge, hands-on experience, and a passion for making a difference in the DevOps space. The architect implements Agile practices and automation and has the technical depth necessary to provide advice for making appropriate technology choices, defending recommendations, and driving technical implementation. These technologies and methods include understanding containerization and the orchestration of containers across multiple Infrastructure as a Service (IaaS) vendors and deployment automation using IaaS providers. Roadmaps to support automation are an essential element of the architect’s role, which includes end-to-end test automation and tool strategies. An architect oversees tool analysis and selection and implements test automation frameworks and approaches.\n\nThe DevOps engineer\n\nA DevOps engineer performs in a hybrid technical role that compri‐ ses development and operations, and must be proficient in coding or scripting, process reengineering, and collaborating with multiple groups. The DevOps engineer also must be well-versed in multiple popular and commonly used operating systems and platforms. The DevOps engineer is responsible for implementing the automation vision of the DevOps architect’s development and deployment pipe‐ line. This includes the critical responsibilities for developing Infra‐ infrastructure, structure as Code repeatability, and automation of the entire infrastructure for each environment.\n\nthat enables\n\nimmutable\n\n10\n\n|\n\nEnterprise DevOps Playbook\n\nThe test automation engineer\n\nThe test automation engineer automates as many steps as possible to achieve the test coverage and confidence required to quickly push changes to production.. The test automation engineer should be well-versed in software testing processes and tools (such as unit test‐ ing, mock integration testing, and test automation tools like Sele‐ nium) and be proficient in the scripting needed to implement automated test processes for each DevOps pipeline step. These auto‐ mations include unit tests, static code tests, smoke tests, and more specific tests, such as Section 508 compliance checks, SLA valida‐ tions, and vulnerability scans. Test automation should not be solely the responsibility of the test automation engineer; it should also be the province of every developer and tester on the team. A developer must be able to add any type of automated test that integrates with the delivery pipeline defined by the DevOps engineer. Typically, QA is performed by a separate group. The test automation engineer pro‐ vides the framework and expertise to enable developers to embed test automation as part of the continuous process.\n\nThe site reliability engineer\n\nThe site reliability engineer is responsible for monitoring the appli‐ cations and/or services post-deployment. Site reliability engineering occurs when you ask a software developer to design an operations team. Using a variety of metrics (e.g., application performance mon‐ itoring [APM], SIEM, user metrics, and infrastructure health) aligned with the deployment strategies being used (e.g., canary releases, blue/green deployment), the site reliability engineer should be exceptional at troubleshooting and at metrics analysis to establish key thresholds for alert automation to baseline the different health levels for applications and services. Simply put, the primary respon‐ sibility of site reliability engineers is to automate themselves to be as efficient as possible.\n\nThe software engineer\n\nA frequently discussed topic with DevOps is the responsibility of software engineers (also called developers). To be successful in a DevOps world, a developer must embrace all the principles dis‐ cussed previously and have a complete team mindset, where tradi‐ tional responsibilities such as testing, infrastructure, and system\n\nPlay 1: Develop the Team—Culture, Principles, and Roles\n\n|\n\n11\n\nadministration are all part of the developer’s roles. This aligns with the mantra of “you build it, you run it, you fix it.”\n\nThe roles and responsibilities we covered are meant to provide insights and to generate healthy discussions among your organiza‐ tion with regard to how to assess resources within your team, and to identify any potential gaps. The important takeaways are the respon‐ sibilities that you need to cover versus the actual role titles because other organizations might call the roles different names such as “release engineer” or “ops lead.”\n\nPlay 2: Study the DevOps Practices As DevOps became an industry buzzword, the term lost some of its meaning. It’s obvious that DevOps is a collaboration between the development, testing, and operations teams, but where it fits within an organization and how teams adopt DevOps vary from enterprise to enterprise. For example, some say DevOps is primarily a by- product of culture; others say it is primarily a technological applica‐ tion. No matter through what lens you view DevOps, it is essential that the teams have a clear and common understanding of the fol‐ lowing seven core DevOps practices:\n\nPractice 1: Configuration management\n\nPractice 2: Continuous integration\n\nPractice 3: Automated testing\n\nPractice 4: Infrastructure as Code\n\nPractice 5: Continuous delivery\n\nPractice 6: Continuous deployment\n\nPractice 7: Continuous monitoring.\n\nThese practices encompass the full end-to-end cycle, from code commit to deployment to operations and maintenance.\n\n12\n\n|\n\nEnterprise DevOps Playbook\n\nHow to Read the Practices In the subsections that follow, we dive into each practice area by providing the following components:\n\nDefinition\n\nA common introductory reference point for how the practice can best be described and what it entails.\n\nWorkshop guiding questions\n\nThe basis for a dialogue and discussion with your team about the parameters and scope of your project. The intent of the guiding questions is for a thought exercise to help gauge where things are, what needs to be considered, and what’s actually important for your team.\n\nChecklist\n\nA number of items that may become tasks in your project backlog to implement or serve to improve your DevOps maturity.\n\nPractice 1: Configuration Management\n\nConfiguration management definition\n\nConfiguration management (CM) is a broad term, widely used as a synonym for version or source code control, but can also be used in the context of managing, deployment artifacts, or configurations of software/hardware. In our context here, we are talking about CM strictly from code management perspective. In the DevOps land‐ scape, CM focuses on having a clear and clean code repository man‐ agement strategy that helps maximize automation and standardize deployments.\n\nDevelopers often are frustrated by not being able to replicate a prob‐ lem that appears in different environments. You may hear develop‐ ers say, “It works in my environment. I cannot reproduce the glitch.” This is mainly because CM of the application throughout the pro‐ cess of development and deployment is controlled manually and there are definite differences between a program’s behavior in a deployed environment and on a developer’s computer. This results in configuration drift or “snowflake” environments, in which man‐\n\nPlay 2: Study the DevOps Practices\n\n|\n\n13\n\nagement of the various environments and code repositories become a heavy lift and a nightmare to manage. Although a software team might carefully document the evolving versions of the configuration of a server or a container, the need to manually execute the docu‐ mented process might still result in human errors because the server will be used in the development, code testing, user acceptance test‐ ing, and production environments.\n\nYou can achieve effective and less problematic version and source code control by using various automated CM workflows. The fol‐ lowing list of workflows is a compilation of common industry prac‐ tices that ranges from basic to advanced. In this playbook we use GitHub for CM implementations, but other source code control sys‐ tems, such as GitLab or Bit Bucket, are good alternatives, and you can follow similar workflow strategies for them as well.\n\nCentralized workflow\n\nIn a centralized workflow (Figure 1-2), a central repository serves as the single point of entry for all changes to the project. The develop‐ ment branch is called the “master” and all changes are made to this branch. A centralized workflow does not require any other branches. Developers have the complete copy of the central reposi‐ tory locally; they write their changes on their own equipment; and then synchronize with the master at agreed upon intervals. If there is a conflict among developers initiating changes, Git (for example) will stop the commit and force a manual merge. This workflow is usually used by teams to transition out of traditional source code control using Apache Subversion (SVN).\n\nFigure 1-2. Centralized flow\n\nFeature workflow\n\nFeature workflow (Figure 1-3) is for teams that are comfortable with centralized workflow. Isolated branches are added for each new fea‐ ture, which enables independent and loosely coupled design princi‐ ples without affecting other parts of the system. The main difference between feature workflow and centralized workflow is that in fea‐ ture workflow, feature development takes place in a dedicated\n\n14\n\n|\n\nEnterprise DevOps Playbook\n\nbranch instead of in the master. This enables various groups of developers to work on features without routinely disturbing the master codebase. Feature workflow also provides a foundation for continuous delivery and continuous deployment DevOps practices. For a microservices architecture, which treats each microservice as a separate product, feature workflow branches are an ideal configura‐ tion management mechanism because the code for each feature is isolated.\n\nFigure 1-3. Feature branch workflow\n\nGitflow workflow\n\nGitflow workflow is for established and advanced projects. It includes the attributes of centralized and feature workflows and also other capabilities. Based on Vincent Driessen’s Git Branching model, Gitflow workflow is a good foundation for many of the seven DevOps practices.\n\nGitflow workflow (Figure 1-4) is composed of a strict branching model designed around project releases and enhancements. Specific roles are assigned to each of five branches: Master, Hotfix, Release, Development, and Feature. The way the branches interact with one another as well as the availability of multiple branches coming off an individual branch, is carefully defined. For example, while new development is occurring in one feature branch, another feature branch can be created for changed requirements or to fix a defect for an update that will be deployed with a patch release.\n\nTable 1-1 explains each of the Gitflow branches.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n15\n\nTable 1-1. Gitflow branches\n\nBranch Master branch\n\nHotfix branch\n\nRelease branch\n\nDevelopment branch\n\nFeature branches\n\nDescription Stores the official release history; the code is merged to it only when a new release is deployed. All historical releases are tagged in the master branch. Supports maintenance or patch fixes that must be released quickly into production. This is the only branch that forks off of the master directly. After the fix is completed, the changes are merged back into the master, development, and/or release branches, as appropriate. Acts as the safeguard between the development branch and the public releases (master branch). Serves as the integration branch for features. Continuous integration deployments to development servers are performed from this branch. Developers code on a local copy of the development branch. When they are finished, the code is merged to the development branch. 100 percent code review Agile practice is used to check the code against the team’s development practices. Represent each feature just like the feature branch workflow. Instead of branching off from the master, feature branches use the development branch as the originator. When the feature is complete, it is merged back to the development branch for integration into the project. As the features are built, the developer local code and feature branch interaction could be automated using continuous integration. When that option is chosen, the feature branch is a separate module until the feature is complete.\n\nFigure 1-4. Gitflow workflow\n\n16\n\n|\n\nEnterprise DevOps Playbook\n\nCM workshop guiding questions\n\nHow do you manage source code versions?\n\nDo you have a production system that you are maintaining and improving or are you building a new system?\n\nHow many features are being built at the same time?\n\nWhat happens when you receive a defect from the operations team? How do you fix the defect and manage the source code change?\n\nWho is the owner of the source code control system—develop‐ ment team, maintenance team, operations team?\n\nWhat are the criteria you use to decide on your source code branching strategy?\n\nAre you building a monolithic system or a microservices-based distributed system?\n\nHow many code repositories do you have (or expect to have) for the project?\n\nAre you planning continuous delivery or continuous deploy‐ ment?\n\nCM checklist\n\nDocument your configuration management approach in a sim‐ ple, easy-to-read document accessible to the entire team.\n\nSelect a source code control system that allows all types of branching techniques even though you might not use advanced flow in the beginning.\n\nSelect your configuration workflow based on operations need and continuous delivery objectives. The most effective flow for delivering under all scenarios is Gitflow.\n\nDocument your branching strategy in a way that makes it easy for the entire team to understand.\n\nDefine the limitations of your configuration management and source code branching strategy.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n17",
      "page_number": 14
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 22-29)",
      "start_page": 22,
      "end_page": 29,
      "detection_method": "topic_boundary",
      "content": "Practice 2: Continuous Integration\n\nContinuous integration definition\n\nContinuous integration (CI) requires developers to integrate code into a centralized repository as they finish coding and successfully pass unit testing, several times per day. The end goal is to create small workable chunks of code that are validated and integrated back into the code repository as frequently as possible. CI is the foundation for both continuous delivery and continuous deploy‐ ment DevOps practices. There are two CI objectives:\n\nMinimize integration efforts throughout the development and deployment process\n\nHave the capability to deliver functions to the end-user commu‐ nity at any point in the development process (see “Practice 3: Automated Testing” on page 20)\n\nCI is also a key Agile SD practice that connects Agile development with DevOps. CI is certainly not a new concept; it has been around for a while, and without a well-established CI practice, a develop‐ ment team cannot expect to achieve DevOps success.\n\nTo facilitate advanced DevOps practices, such as continuous deliv‐ ery and continuous deployment, CI must be planned and imple‐ mented well. When a developer divides functionality into smaller chunks, it is critical to ensure that the software not only works and is integrated into the main code repository, but can be safely deployed to production if there is a business reason to do so before the rest of the application’s features are complete. CI forces the developer to think differently during planning; that is, she must view functionality in small, discrete bites that can be integrated into the rest of the code base as finished pieces of larger programs.\n\nBefore CI became a best practice, integration was a major and often difficult ordeal. Developers would code in their local environments and, when ready, collaborate to integrate their code into the larger project. More often than not, the working code had to be rewritten for successful handshakes among the disparate sections of code to occur.\n\nWith DevOps, the goal is to achieve continuous releases. When pro‐ gram enhancements or features are complete, they should be\n\n18\n\n|\n\nEnterprise DevOps Playbook\n\ndeployed or deployable; CI enables this unique aspect of DevOps. However, CI alone is not sufficient for the deployment of “done” code to production; full confidence from both comprehensive test coverage and immutable infrastructure is needed. In essence, CI is a prerequisite to achieving continuous deployment and works in con‐ junction with the other DevOps practices to build and ensure confi‐ dence throughout the process, which ultimately creates the level of trust required to automate deployments directly to production.\n\nCI workshop guiding questions\n\nHow ready are you for CI? Do you have your CI tool and exper‐ tise in automating builds?\n\nHow long does it take to build your code?\n\nWhat is your unit test coverage percentage? Are you confident that if a developer breaks another developer’s code, the unit tests will detect it?\n\nHow many Agile teams do you have on your project? If you have multiple teams, what is the definition of CI to you?\n\nCI checklist\n\nSelect a CI tool that is capable of achieving your automation objectives.\n\nConnect the CI tool to your code repository. Test check the code.\n\nIntegrate your build script to CI.\n\nManually trigger the build from your CI server.\n\nTest the build scheduler.\n\nDefine the build branch for each environment from your branch structure. The following steps are for Gitflow:\n\n1. Set up build for Dev environment from development branch\n\n2. Schedule Dev build for every check-in (core activity of CI begins with this build; ends if all automated tests pass)\n\n3. Set up build for test environment from the development branch\n\nPlay 2: Study the DevOps Practices\n\n|\n\n19\n\n4. Set up build for preproduction (or QA) from the release ranch\n\n5. Set up build for production from the release branch\n\n6. Set up auto commit to the master branch after production deployment.\n\nDefine automated tests for each commit to the development branch.\n\n— Perform unit tests (frontend, backend, API)\n\n— Perform vulnerability scan (use ZAP for the development\n\nbranch)\n\n— Perform code quality scan\n\nDefine alerting solution for developer commits.\n\nDefine criteria to accept or reject commits.\n\nDefine commit reject mechanisms when committed code is not acceptable (e.g., if there are vulnerability findings, or if a unit test fails). Do not ignore any test fail. Stop and fix.\n\nDefine automated tests for each commit to the release branch.\n\n— All tests run for development branch commits\n\n— Performance tests\n\n— Other security scans\n\n— Functional tests (e.g., Selenium tests and browser compati‐\n\nbility tests)\n\nPractice 3: Automated Testing\n\nAutomated testing definition\n\nAutomation is the very heart of DevOps. The more tests you can automate, the more likely that the quality of the program and the efficiency of the deployment will be production-ready. DevOps teams use the results of automated testing to determine their next steps. The end goal here is to shift testing and compliance to the left of the delivery process as much as possible, in essence ensuring that tests are conducted early and often in the development process. During CI, automated testing can identify defects early on so they can be addressed. During continuous delivery, automated testing\n\n20\n\n|\n\nEnterprise DevOps Playbook\n\ncan increase the team’s confidence level that it can deploy a new capability into production.\n\nIn DevOps, automated testing should be used during CI (on devel‐ opment), Infrastructure as Code (on development), continuous delivery (on test and QA), continuous deployment (on QA, accept‐ ance, and production), and continuous monitoring (on develop‐ ment, test, QA, and production).\n\nRecommended automated DevOps tests, by environment, are shown in Figure 1-5. We use a modified version of the Chef delivery pipeline terminology for each of the steps.\n\nFigure 1-5. Recommended automated tests\n\nLet’s take a quick look into each of the environments and the auto‐ mated testing activities for each one.\n\nLocal environment\n\nThis is local developers’ environment, whether it is their own machine or a VM. If any tests fail locally, the developer stops and fixes the issue.\n\nLint and static analysis test\n\nIdentifies potential bad source code (e.g., nonconforming code, bad practices, compilation errors, security flaws) by examining the code itself without executing the program. Although static code analysis is useful, it generates both false positives and false negatives. Ideally, all of the outcomes of static code analysis should be reviewed. The frequency of static code analysis can be\n\nPlay 2: Study the DevOps Practices\n\n|\n\n21\n\ndetermined by the team’s DevOps maturity on other automated tests.\n\nUnit test\n\nThe first line of defense in assuring quality, a unit test should be developed for both frontend and backend code. One hundred percent unit test coverage is necessary to have the confidence in the source code that is required for continuous deployment. Unit tests should be:\n\nSmall in scope\n\nDeveloped by the programmer based on acceptance criteria\n\nAble to run quickly so that developers use them routinely for every change\n\nMock integration test\n\nValidate the expected result of APIs, which are a facet of any modular architecture, such as microservices or component- based design. For simple parts of an application, API tests could be the same as unit tests. The intent is to simulate and provide test integration points through mock outputs.\n\nConsumer test\n\nValidate integration points with external services that are being used to ensure correctness on both sides.\n\nCI environment\n\nAfter local testing is passed and code review is completed and approved, CI environment testing begins with another quick round of checks with unit and mock integration testing.\n\nUnit test\n\nThe first line of defense in assuring quality, it should be devel‐ oped for both frontend and backend code. One hundred per‐ cent test coverage is necessary to have the confidence in the source code that is required for continuous deployment. Unit tests should be the following:\n\nSmall in scope\n\nDeveloped by the programmer\n\n22\n\n|\n\nEnterprise DevOps Playbook\n\nAble to run quickly so that developers use them routinely for every change.\n\nMock integration test\n\nIntegration testing is critical and is repeated in this environ‐ ment. We want to ensure and validate the expected result of the APIs.\n\nDevelopment environment\n\nAfter successful CI environment testing, we proceed to the develop‐ ment environment, in which a series of tests are run to ensure readi‐ ness for the test environment. If any of the tests are failed, the developer stops and fixes the issue.\n\nUnit test\n\nRerun the unit tests for all the components.\n\nMock integration (service and consumer) test Tests all the service integration points.\n\nUI test\n\nRuns over larger parts of the application and simulates user actions. All of the capabilities and features of a user interface (UI) must be tested by automated functional testing. Selenium is a common tool for this. The drawback of functional tests is that they are slow, which explains why they are not usually used in the development environment. The rule of thumb is this: no build should propagate to the QA environment before there is a functional test for all UI capabilities and before all of the func‐ tional tests run successfully.\n\n508 manual test\n\nFor applications that require Section 508 compliance, this is an important step. Section 508 testing is mostly manual, but tools such as CodeSniffer can check pages and detect conformance to the W3C’s Web Content Accessibility Guidelines (WCAG) 2.0 and Section 508 guidelines.\n\nTest environment\n\nUpon successful development testing and business approval (for sit‐ uations in which a manual business decision is required), the test environment follows. This is the environment that unites all the dif‐\n\nPlay 2: Study the DevOps Practices\n\n|\n\n23\n\nferent development streams and ensures comprehensive testing across all major areas.\n\nUnit test\n\nRerun the unit tests for all the components for all the develop‐ ment streams.\n\nIntegration test\n\nValidates the integration points (internal and external) and tests the expected inputs and outputs.\n\nEnd-to-end test\n\nRun tests across functional and nonfunctional areas (e.g., infra‐ structure, build scripts, and configurations).\n\nFunctional test\n\nRuns over larger parts of the application and simulates user actions. All of the capabilities and features of a UI must be tested by automated functional testing.\n\nBuild script test\n\nBecause DevOps automation relies on high-quality build scripts, build script testing is used to ensure that there are no errors during the build process and that the scripts are consistent across each environment.\n\nProperties file/configuration parameter test\n\nAll software development projects have configuration parameters that must be tested for target boundary condi‐ tions.\n\nInfrastructure code test\n\nSimilar to applications code, infrastructure code must be tested for every change. This is a critical for ensuring immutability and repeatability. We discuss this in detail in the next practice section (“Practice 4: Infrastructure as Code” on page 29).\n\nSecurity test\n\nEnsures the security posture of your applications and environ‐ ments by mitigating potential issues through automated detec‐ tion. In reality, not all items will be revealed, but security and compliance tests provide a strong baseline and confidence to move forward:\n\n24\n\n|\n\nEnterprise DevOps Playbook\n\nVulnerability test (or penetration test)\n\nNew code must pass a vulnerability scanner to validate that no critical application-level vulnerabilities are present. About 95 percent of reported software breaches in 2015 were the result of 1 out of 10 well-known vulnerabilities; 8 of them have been in the crosshairs of the software develop‐ ment sector for more than 10 years. Zed Attack Proxy (ZAP) is a common vulnerability test tool.\n\nFunctional security test\n\nVerifies security features, such as authorization, authentica‐ tion, field-level validation, and personally identifiable infor‐ mation (PII) compliance.\n\nSecurity scanning test\n\nTargets applications, containers, networks, firewalls, and operating systems for vulnerabilities.\n\nCompliance test\n\nMany systems are required to be compliant with specific sets of standards. The goal of compliance testing is to use tools like OpenSCAP and Chef Compliance to automate the process that will continuously validate the posture of your system as changes take place versus the tedious exercise of addressing these changes after a release candidate is established.\n\nResiliency test\n\nApplies a series of random simulations to assess the availability of your system in outage events. For example, using Netflix’s Simian Army (Chaos Monkey and Chaos Gorilla), resiliency is tested by taking down random AWS instances to an entire Amazon Web Services (AWS) availability zone to test the fault- tolerant architecture of your system.\n\nPerformance test\n\nMeasures the performance and scalability of an application. After the team defines SLAs for web page and API performance, these tests will alert the team if the applications/APIs are not performing as required. Some of these tests (e.g., soak tests) are used only for specific situations rather than running continu‐ ously for every change.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n25",
      "page_number": 22
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 30-37)",
      "start_page": 30,
      "end_page": 37,
      "detection_method": "topic_boundary",
      "content": "Load test\n\nAnalyzes the impact of load on an application. For example, if a performance issue is identified and subsequently addressed, only a load test can determine if the problem has been resolved.\n\nComponent load test\n\nApplies a load test to a single component (or microservice).\n\nSoak test\n\nIdentifies memory leaks. Some severe memory leak prob‐ lems do not surface during load testing. To uncover these issues, you must run soak tests over extended periods of time (at least overnight) with steady high loads.\n\nCapacity test\n\nDetermines how many simultaneous users a web applica‐ tion can handle before response time becomes an issue (or before the system performs below its SLA).\n\nStress test\n\nPushes a web application beyond normal workload to iden‐ tify which components or services will fail under extreme conditions and spikes in production.\n\nPreproduction environment\n\nThis environment serves as a test ground to simulate delivery to production. In live implementations, the tests here vary from orga‐ nization to organization, depending on how confident and comfort‐ able you are up to this point.\n\nSmoke test\n\nRun a comprehensive set of functional tests under low load to ensure major features of the applications work as expected.\n\nResiliency test\n\nPerform random simulations that are essential to test the availa‐ bility of the system in outage events and continuously validate the fault-tolerant architecture of the system.\n\nPerformance test\n\nAssess the expected performance of the new deployment. In “Practice 7: Continuous Monitoring” on page 40, we discuss the\n\n26\n\n|\n\nEnterprise DevOps Playbook\n\nmetrics and monitoring for expected performance levels and the health of the system.\n\nProduction environment\n\nAt this point, the tests and validation processes needed for produc‐ tion deployment are completed. In this section, we list tests that are recommended for the production environment. In “Practice 5: Con‐ tinuous Delivery” on page 32, we explore effective production deployment strategies, such as canary releases and blue/green deployment.\n\nPost-production test\n\nRun a series of tests on the application as well as infrastructure to ensure that the system is in a healthy state (should include subset of functional UI tests, configuration tests, and others) after deployment. The extent of the post-production tests depends on the size and maturity of the environment.\n\nResiliency test\n\nConduct random simulations that are essential to test the availa‐ bility of the system in outage events and continuously validate the fault-tolerant architecture of the system.\n\nPerformance test\n\nAssess the expected performance of the new deployment. In “Practice 7: Continuous Monitoring” on page 40, we discuss the metrics and monitoring for expected performance levels and the health of the system.\n\nSynthetic test\n\nSet up these tests to simulate real-world usage patterns by mim‐ icking the locations, devices, and patterns of users. Some appli‐ cation performance monitoring solutions, such as New Relic, offer synthetic testing programs as well. The intent is to proac‐ tively discover issues users are encountering and gain insight for troubleshooting.\n\nAlthough this is a comprehensive list of automated tests, manual tests are also an important part of system delivery. Some functional‐ ity may require manual validation. Types of manual tests include exploratory testing, user acceptance testing, Section 508 accessibility testing, and usability testing.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n27\n\nAutomated testing workshop guiding questions\n\nWhich tests are currently automated and which do you plan to automate?\n\nWhat percentage of your code base is automated?\n\nHow long does it take to run the automated test harness? If you have different harnesses for unit tests and functional tests, how long do they take to run separately, and how often do you run them?\n\nWhat test automation tools and frameworks do you use?\n\nWhat is the process for a developer to add a new unit test?\n\nHow many concurrent users are expected to use your system?\n\nDo you have browser page load requirements?\n\nHow do you test load, performance, and stress?\n\nWhat do you do when performance degrades? What is your scaling strategy?\n\nDo you have system availability requirements?\n\nAutomated testing checklist\n\nSet high unit-test coverage and add this coverage as a require‐ ment for developers to complete before a project can be final‐ ized.\n\nSelect unit test technologies for UI, middle-tier, and backend.\n\nImplement unit-test reference implementations and add them to developer practices.\n\nBuild mechanisms to measure the test coverage for unit tests.\n\nIntegrate your unit tests into test harnesses. Build mechanisms for integrating the unit tests into the harness.\n\nIntegrate the unit-test harness into the build script and CI.\n\nBuild mechanisms to take action when unit tests fail.\n\nAfter unit-test coverage is finished, identify which integration tests should be implemented. Integration tests should cover end-to-end paths in user stories.\n\nImplement and automate integration tests.\n\n28\n\n|\n\nEnterprise DevOps Playbook\n\nSelect technology for acceptance tests or end-to-end functional tests. Selenium is a possible option.\n\nOrder your functionality, from most critical to least critical, and build end-to-end automated functional tests starting with the most critical ones. (There will be fewer end-to-end tests than unit tests. The quality of the functional tests is more important than the quantity.)\n\nDefine actions when a functional test fails. Build an alerting tool so that the developer is notified.\n\nAfter you achieve the maturity you are targeting with unit tests, integration tests, and end-to-end functional tests, prioritize other types of tests defined in this section and integrate them into the aforementioned environments. Begin with the security tests.\n\nPractice 4: Infrastructure as Code\n\nInfrastructure as Code definition\n\nIt can be argued that the recent maturity and adoption of tools and technology enabling Infrastructure as Code (IaC) are among the pri‐ mary reasons DevOps has exploded onto the scene with true end- to-end automation. IaC goes beyond simply automating processes using scripts, as traditional systems administrators have been doing for years. Instead, IaC enables configuration and provisioning of infrastructure through applications using APIs. With IaC, configu‐ rations are treated just like application code with all the best soft‐ ware development practices of version control, unit tests, code review, gating, and so on. The barriers and walls between system administration and operations staff and developers are removed, with full transparency, automation, and shared responsibilities. IaC addresses configuration drifts by ensuring immutability of both the actual server configurations/instantiation and also standardizing how environments are built and deployed.\n\nThe ability to view IaC opens the possibility to control and automate configurations so that they are highly repeatable and consistent, no matter how many times the environment is torn down and brought back up. Not surprisingly, best practices for IaC are similar to those for software development, including the following:\n\nPlay 2: Study the DevOps Practices\n\n|\n\n29\n\nSource control\n\nCode version control and auditing\n\nPeer reviews\n\nCode review practices as application code processes\n\nTesting\n\nUnit testing, functional testing, and integration testing\n\nCode as documentation\n\nCode is developed in an easily readable manner as the IaC itself serves as living, always-up-to-date documentation\n\nCollaboration\n\nThe barrier between development and operations is broken down\n\nThere are two primary approaches for implementing IaC. It is important to assess the pros and cons of each and determine which model fits best with your team and environment:\n\nDeclarative model\n\nSimilar to the concept of declarative programming, code is writ‐ ten to describe what the code should do as opposed to how the code should do it. Puppet, for example, is declarative because it doesn’t run scripts or execute code on the infrastructure. You can use Puppet’s declarative language to model and describe the desired target server end state. You tell Puppet what you want the server to look like, not the steps to take to get there. The typical advantage here is a cleaner and more structured approach, as you are just modeling and describing what is needed. The downside is less flexibility in what you can control.\n\nImperative model\n\nCode is written that explicitly lays out the specific steps that must be executed to complete the desired task or, in this case, the desired target server end state. Instead of modeling the end state, you use the imperative approach to describe how to get to the end state. In this model the advantage is full control of what steps and actions you execute and the conditions around them. However, the code/scripts can get complicated. For example, Chef is imperative—users define commands and their execution order and logic. These instructions, called Chef Recipes, in turn can be organized in Cookbooks. To illustrate this, part of a\n\n30\n\n|\n\nEnterprise DevOps Playbook\n\nrecipe can be to check if a specific dependency is available on a target node. If the dependency exists, Chef will install it; other‐ wise, a warning is raised and/or other failed execution steps are run.\n\nNo matter which solution you decide on, having IaC in place will reduce and in most cases eliminate configuration drift/snowflake environments. In making your decision, you should consider the skillset of your team and how well it lines up with the various options, such as Chef, Ansible, or Puppet.\n\nIaC workshop guiding questions\n\nDoes your datacenter or IaaS provider have scripted provision‐ ing capability?\n\nCan you script the installation of every product in your system?\n\nWhat are the differences for installing components of your sys‐ tem when they are deployed on these distinct environments: developer computers, development, test, QA, and production?\n\nDo you perform version control on the configuration control parameters of your components? If yes, how?\n\nWho on your team knows the details of these configuration parameters?\n\nHave you heard this all-too-common complaint?: “I cannot reproduce this error in my environment.”\n\nIaC checklist\n\nSet the objectives of your infrastructure automation and plan your automation in an Agile way. You do not need to wait to complete everything before you use it. Start using the IaC as pieces are completed.\n\nDefine what you can automate and what you cannot. For exam‐ ple, most application servers can be automated, but network devices such as firewalls can be configured automatically if they have APIs to do that.\n\nWrite the code to automate the configuration of the container in which your main application is going to run.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n31\n\nIntegrate the IaC for your app servers/containers to CI. Ideally, re-create the servers and containers when there is a patch instead of just applying the patch. After you do this, you will have achieved an immutable infrastructure for your application servers.\n\nUse the same IaC you build for your app servers on your devel‐ opers’ computers and in your development, testing, quality, and production environments. There should not be any difference other than the IP, URL, and so on.\n\nWrite the code for building your database server and container and follow the same steps you used for the applications server.\n\nPractice 5: Continuous Delivery\n\nContinuous delivery definition\n\nContinuous delivery simply means that every change is ready to be deployed to production as soon as automated testing validates it. Figure 1-6 illustrates a reference pipeline flow (also discussed in “Practice 3: Automated Testing” on page 20). Note there are two manual checkpoints in this example. One is for a technical decision to approve the code before initiating activities in the CI environ‐ ment. The second is a business decision to accept the changes and continue with the automated steps to production deployment.\n\nThe goal of continuous delivery is to deliver incremental or small changes quickly and continually as they go through the pipeline. This not only helps distribute microfeatures more rapidly, but also reduces the risk of a large release failing. It is important to note that not all microfeatures that go to production will be seen by users. These features or fixes might be part of the production version, but potentially “turned off” for a period of time because you want to have specific changes validated as part of a build, even though the organization is not necessarily ready to install them on end-user sys‐ tems.\n\nDevOps is a reaction to features and releases being deployed slowly. Even using Agile SD principles, the mindset is to build programs incrementally and produce releasable software at the end of every sprint. In each sprint, the team develops features/changes for the software, but the completed story must wait for the other stories to\n\n32\n\n|\n\nEnterprise DevOps Playbook\n\nbe finished and grouped together to be deployed in a scheduled release. In contrast, continuous delivery gives power to the product owner, who is the gatekeeper in DevOps terms, to decide whether to deploy the new capabilities before the rest of the release is ready.\n\nFigure 1-6. Reference pipeline—continuous delivery\n\nContinuous delivery usually requires a change in organizational cul‐ ture. Team and customer expectations must shift from full-fledged deployment when all aspects of the project are finished and tested to incremental and iterative application distribution. Simply put, you can view the objectives of continuous delivery as follows:\n\nNew features, configuration changes, bug fixes, and experiments are sent into production safely and quickly in a sustainable way.\n\nForget about having to spend nights and weekends in the data‐ center to deploy releases; design the architecture to deploy pro‐ grams whenever the time is appropriate for the DevOps team and the user community.\n\nTo achieve these objectives, DevOps teams must develop maturity and capabilities in the four DevOps practices described previously, or continuous delivery is not viable. The four critical practices and the required capabilities are as follows:\n\nCM\n\n— Builds should be scripted. Developers should use the same\n\ndeployment scripts that are used for production.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n33",
      "page_number": 30
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 38-45)",
      "start_page": 38,
      "end_page": 45,
      "detection_method": "topic_boundary",
      "content": "— Environments should be automated and scripted. There should be no differences between the developer and produc‐ tion environments.\n\n— It should not be a lengthy task to bring a new developer onto\n\nthe team.\n\nCI\n\n— Automated builds are triggered for every check-in.\n\n— Developers check into the trunk (of the source code reposi‐\n\ntory) at least once per day.\n\n— When the build goes red (i.e., when an automated test fails), the team should fix it quickly, ideally within 10 minutes.\n\nAutomated testing\n\n— Unit tests for all public interfaces are in place to provide some level of confidence before exploratory testing (which is based on manual testing) and acceptance.\n\n— Acceptance tests are automated. The gatekeeper agrees that the capability is ready to push to production deployment.\n\nIaC\n\n— The instantiation and teardown of the infrastructure for every environment us managed, automated, and executed through scripts and code using tools such as Chef, Puppet, Ansible, and others.\n\n— The infrastructure is immutable and there are no differences between the developer, implementation, and user environ‐ ments.\n\nThese four DevOps practices cover the following two rules of con‐ tinuous delivery:\n\nThe software (trunk) should always be deployable\n\nTrunk software should be healthy at all times and ready to be deployed to production. It’s up to the gatekeeper to decide whether to deploy it once per day or multiple times per day— this is a business decision, not a technical decision.\n\n34\n\n|\n\nEnterprise DevOps Playbook\n\nEveryone checks into the trunk from feature branches at least once per day\n\nThis forces developers to divide user stories and features into meaningful, smaller pieces. Every check-in is performed to determine if the team’s “definition of done” has been achieved.\n\nIn deploying to production, there are several advanced strategies that you can adopt to achieve zero downtime and flexibility:\n\nCanary releases\n\nBy definition, continuous delivery deploys many builds to pro‐ duction. In “Practice 3: Automated Testing” on page 20, we dis‐ cuss the importance of having a sophisticated set of automated tests that provide a high level of confidence in the quality of the code. Canary is a technique that is used to further increase con‐ fidence levels before deploying new code to production. In a canary deployment, the new code is delivered only to a percent‐ age of the existing infrastructure. For example, if the system is running on 10 load-balanced virtual servers, you can define a canary cluster of one or two servers. This way, if the deployment is not successful due to an escaped defect, it can be caught before the build is deployed to all of the servers. Canary releases are also used for pilot features to determine performance and acceptance prior to a full rollout.\n\nBlue/green deployment\n\nThis is a zero-downtime deployment technique that involves a gradual release to ensure uninterrupted service. The blue/green approach is effective in virtualized environments, especially if IaaS is used. Although a blue/green deployment is a deep topic that deserves an entire chapter on its own, simply put, it includes maintaining two identical development environments —Blue and Green. One is a live environment for production traffic, whereas the other is used to deploy the new release. In our example, let’s say that Green is the current live production environment and Blue is the idle identical production environ‐ ment. After the code is deployed and tested in the Blue environ‐ ment, we can begin directing traffic of incoming requests from Green (current production) to Blue. You can do this gradually until the traffic redirect is 100 percent to the Blue environment. If unexpected issues occur during this gradual release, we can roll back. When it is completed, the Green environment\n\nPlay 2: Study the DevOps Practices\n\n|\n\n35\n\nbecomes idle and the Blue environment is now the live produc‐ tion environment.\n\nGetting to this point in continuous delivery is an incredible mile‐ stone, and means that your organization has enough confidence and automation from your implementations CI, CM, automated testing, and IaC that you are able to deploy any point into production.\n\nContinuous delivery workshop guiding questions\n\nDo you have CI in place?\n\nWhat is your confidence level in the coverage and quality of your automated testing?\n\nDo you have IaC for infrastructure? Have you heard developers complaining that they are unable to reproduce an error identi‐ fied by quality assurance?\n\nWhat is the “definition of done” for your code?\n\nDo you have 100 percent code review for each commit?\n\nDo you run code quality scans for committed code?\n\nHow does the product owner approve your definition of done?\n\nDoes your contract let you deploy to production, or is there another contractor in the middle?\n\nDo you run automated tests (continuously) in production for feedback?\n\nDo you have practices to revert the build?\n\nContinuous delivery checklist\n\nBefore attempting continuous delivery, assess your maturity level for the prerequisite practices described in this section. If you do not have sufficient maturity in these practices, make sure to first improve those practices.\n\nBuild your continuous delivery pipeline. Do not reinvent the wheel. Instead, use products such as Jenkins, Chef Delivery, and Spinnaker.\n\nIntegrate your test automation and CI server to the continuous delivery pipeline.\n\n36\n\n|\n\nEnterprise DevOps Playbook\n\nDecide whether to use canary or blue/green deployments. If you do, build the mechanisms and determine how the deployed build will be monitored.\n\nThere are two manual checkpoints for continuous delivery: code approval and delivery approval. Document these two approval points and communicate them: — Code approval\n\n— Define who will perform this approval. Usually, it is the\n\ntechnical lead.\n\n— Define the developer’s tasks to achieve the “definition of\n\ndone” and submit the code for approval.\n\n— Define the reviewer’s tasks and standardize these across\n\nAgile teams.\n\n— Configure the delivery pipeline to deploy builds to the proper target environments (development, testing, qual‐ ity assurance, or production).\n\n— Construct or configure the trigger that the person responsible for code approval will use to initiate the build automation for the delivery pipeline.\n\n— Build mechanisms to alert the team if any of the automa‐ ted tests fail. This mechanism must stop the pipeline when something is found to have gone wrong.\n\n— Delivery approval\n\n— Define who is accountable for this approval, which is the last step before deploying the code to production assum‐ ing all of the planned automated tests run successfully. Because the code is a candidate to be deployed to pro‐ duction, the product owner should be involved.\n\nBuild advanced deployment techniques (e.g., blue/green deploy‐ ment, canary release, and or A/B tests) to improve the success of continuous delivery.\n\nCreate mechanisms to monitor production and the success of the build.\n\nCreate mechanisms to revert the build in case of a failure.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n37\n\nPractice 6: Continuous Deployment\n\nContinuous deployment definition\n\nUnlike continuous delivery, which means that every change is deployable but might be held back because of business considera‐ tions or other manual steps, continuous deployment strives to auto‐ mate production deployment end to end. With this practice, confidence in the automated tests is extremely high, and as long as the code has passed all the tests, it will be deployed.\n\nFigure 1-7 shows our reference pipeline. We maintain a manual checkpoint for implementation of a business decision about deploy‐ ment prior to continuing the process to production. You can remove this step for full end-to-end automation of continuous and constant deployment of production changes. In a fully automated scenario, it is vital that you have high maturity levels in each of the DevOps practices and full visibility into the health of the systems at all times. If unexpected issues arise, it is critical to have the metrics, insight, and process to either quickly revert to a known stable state or to fix the issue immediately with a new build.\n\nFigure 1-7. Reference pipeline—continuous deployment\n\n38\n\n|\n\nEnterprise DevOps Playbook\n\nContinuous deployment is the ultimate goal for modern efficient organizations. However, this DevOps practice does not imply that all applications are deployed without any manual interaction. Here are some factors to examine when considering continuous deployment:\n\nAutomated test coverage\n\nAutomated test types, including unit, functional, accessibility, security, compliance, different types of performance, and acceptance tests\n\nRobust multilayer code review during developer commit for every change\n\nValidation of functionality by the product owner during devel‐ oper commit\n\nAdvance deployment mechanisms,\n\nincluding blue/green deployments, canary testing, post-production testing, and revert scripts.\n\nIn deciding which services can be deployed automatically and which need manual validation, most organizations use a hybrid mecha‐ nism early on before becoming fully confident as to whether the fea‐ ture is something that can be fully automated to production. For example, a change in a business rule that requires extensive scenario testing by a subject matter expert (SME) might be better suited for continuous delivery because it would require the SME (and the product owner) to give a thumbs up after going over all possible sce‐ narios. This is especially true in the government world in which there are policies in place that require individuals to give their approval prior to moving on to production.\n\nContinuous deployment workshop guiding questions\n\nDo you have continuous delivery in place? How successful are you with it?\n\nWhat are the driving factors to move to continuous deploy‐ ment?\n\nHow comfortable is your client with continuous deployment?\n\nHow will you ensure that the functionality you deploy still con‐ forms to the product owner’s preferences when you eliminate the manual delivery approval step?\n\nPlay 2: Study the DevOps Practices\n\n|\n\n39\n\nAssess whether you can use continuous delivery and continuous deployment together. What is ideal to be part of continuous deployment for your team? (This could be all components or perhaps just APIs and backend capabilities.)\n\nContinuous deployment checklist\n\nEnsure that you are successful with continuous delivery before pursuing continuous deployment.\n\nIntegrate delivery approval with code approval—that is, make the business decision about the deployment when you assess the readiness of the code right before CI.\n\nBuild mature centralized logging and continuous monitoring practices to ensure that you’re aware of the impact of every deployment.\n\nAdopt canary deployment mechanisms.\n\nEmbrace blue/green deployment mechanisms. For continuous deployment, the blue/green approach is a necessity. No matter how good your automated tests are, it is still possible to miss defects. Blue/green techniques help to minimize the chances of releasing defects to all users.\n\nIntegrate all of the chosen deployment techniques with your delivery pipeline. Some continuous delivery pipelines (e.g., Spinnaker) have advanced deployment techniques out of the box.\n\nPractice 7: Continuous Monitoring\n\nContinuous monitoring definition\n\nContinuous monitoring is the practice that connects operations back to development, providing visibility and relevant data through‐ out the development lifecycle including production monitoring. In traditional IT operations, an operations team composed of system administrators, various help desks, and analysts performs opera‐ tions. But with continuous monitoring, modern DevOps operations teams also include the developers who originally built the system and then are responsible for site reliability, overseeing the software, and acting as first responders for production problems. Simply put,\n\n40\n\n|\n\nEnterprise DevOps Playbook\n\ncontinuous monitoring aims to reduce the time between identifica‐ tion of a problem and deployment of the fix.\n\nThis practice should not be an afterthought. Monitoring begins with Sprint 1 and should be integrated into the development work. As the system is built, monitoring solutions are also designed. In this play‐ book, we focus on four different types of continuous monitoring:\n\nInfrastructure monitoring\n\nVisualize infrastructure events coming from all computing resources, storage and network, and measure the usage and health of infrastructure resources. AWS CloudWatch and CloudTrail are examples of infrastructure monitoring tools.\n\nApplication performance monitoring (APM)\n\nTarget bottlenecks in the application’s framework. Appdynamics and New Relic are industry-leading APM tools.\n\nLog management monitoring\n\nCollect performance logs in a standardized way and use analyt‐ ics to identify application and system problems. Splunk and ELK are two leading products in this area.\n\nSecurity monitoring\n\nReduce security and compliance risk through automation. Secu‐ rity configuration management, vulnerability management, and intelligence to detect attacks and breaches before they do seri‐ ous damage are achieved through continuous monitoring. For example, Netflix’s Security Monkey is a tool that checks the security configuration of your cloud implementation on AWS.\n\nWe can divide continuous monitoring into three major steps. First, the obvious one—monitoring. Second, an alert system to warn the team about a problem. The alert system should be capable of auto‐ matically elevating the alert if the team members who initially received notice of the issue take no action. The third step of contin‐ uous monitoring is actions to take when an alert occurs. No matter what the nature of the alert, all should be captured and reviewed. For example, there can be false negatives, but they should not be ignored. Instead, false negatives should be reported as such to the continuous monitoring tool so that if the same set of circumstances occurs again, the monitoring equipment will not trigger an alert. Similarly, if an alert is issued, but the software appears to be operat‐ ing satisfactorily, it should not be neglected. Rather, it should be\n\nPlay 2: Study the DevOps Practices\n\n|\n\n41",
      "page_number": 38
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 46-53)",
      "start_page": 46,
      "end_page": 53,
      "detection_method": "topic_boundary",
      "content": "investigated and the outcome of the investigation must become a part of the record that the monitoring tool can use in determining the severity of future similar incidents.\n\nContinuous monitoring workshop guiding questions\n\nHow and why is early detection of defects important to your project?\n\nWhat performance SLAs do you have and when do you plan to start achieving them?\n\nWhat is the system availability requirement and what is the plan to achieve it?\n\nWhen do you do performance testing as part of your continu‐ ous integration and automated testing practices? How do you know that the tests represent actual production conditions?\n\nWhat is the labor cost of your operations? How many systems engineers, system administrators, and database administrators do you have monitoring the production environments, and how do they react when there is an issue?\n\nHow many errors are there in your application? How do you trace the errors back in your code?\n\nHow do you forecast infrastructure utilization when your code changes?\n\nContinuous monitoring checklist\n\nImplement APM, log analytics, and security monitoring solu‐ tions for your system.\n\nDesign and start using these implementations as the system is built, not after it is deployed.\n\nDesign and implement alerting solutions composed of alert gen‐ eration, mitigation actions, verification, baseline calculations, and alarm setup. Build alerts for each try/catch in your code as the code is designed.\n\nKnow your monitoring coverage and identify what it should be.\n\nStart monitoring performance during CI. Define page-level SLAs, build automated performance tests for these SLAs, and define triggers.\n\n42\n\n|\n\nEnterprise DevOps Playbook\n\nDefine baselines during development to be able to identify later anomalies.\n\nAfter defining baselines, define quantitative forecasts for critical processes. For example, login page SLA is two seconds. Based on 95 percent of responses, the system can achieve a 2-second response time for up to 1,000 concurrent users.\n\nCollect data from servers. After aggregating and storing the data, present the data in graph format, prepared for time series analysis.\n\nAutomatically create issues when the monitoring solution cap‐ tures a problem and triggers an alert. Automatically group the created issues.\n\nAllocate developer resources to filter false positives and nega‐ tives.\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap DevOps is not a set of prescriptive procedures, but it is critical that organizations assess the maturity of their adherence to DevOps practices by measuring them against a standard model. Without this, it would be impossible to identify gaps or potential areas for improvement that could interfere with a successful DevOps imple‐ mentation.\n\nTo make this assessment, we created a Maturity Questionnaire that provides a series of questions related to each of the seven DevOps practices. Each answer has a point value. When you complete the questionnaire, add up the total points and use Table 1-2 to deter‐ mine your project’s DevOps maturity level.\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\n|\n\n43\n\nTable 1-2. The DevOps Maturity Questionnaire\n\nMaturity Level Base Beginner Intermediate Advanced\n\nExtreme\n\nAgile practices might be in use, but DevOps practices are limited Foundational use of DevOps practices Stabilized use of DevOps practices Continuous improvement in place Team has the competence and confidence to use DevOps practices Cultural barriers have been overcome No cultural barriers Role model DevOps implementation\n\nPoints 0–32 33–98 99–164 165–230\n\n231\n\nBooz Allen’s Maturity Questionnaire should be the first step toward achieving a more mature DevOps capability because it highlights the current state and provides a roadmap that indicates where to focus on increasing your organizational maturity. Some DevOps practices are more difficult to introduce than others and will require substan‐ tial changes in the fundamental management of software develop‐ ment. Over time, as an organization grows in DevOps maturity, improvements will bring tangible increases in both efficiency and quality of software development and implementation.\n\nTables 1-3 through 1-9 highlight our maturity assessment.\n\n44\n\n|\n\nEnterprise DevOps Playbook\n\nt n e m e g a n a m n o i t a r u g fi n o C\n\n.\n\n3 - 1 e l b a T\n\nE R O C S R U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nl e v e L\n\ny t i r u t a M\n\ne r o c s\n\nr u o Y\n\ns r e n i a t n o c d n a\n\ns d\n\nl i\n\nu B +\n\ne d o c\n\ne c r u o s\n\nt s e T +\n\nn o i t a r u g fi n o c\n\n,\n\nn o i t a r u g fi n o C +\n\ne d o c n o i t a c i l\n\np p a\n\nr o f\n\nM C S\n\nM C S o N\n\ne d o c e c r u o S\n\ne d o c\n\ne r u t c u r t s a r f n\n\ni\n\nd n a\n\n, s t p i r c s\n\n)\n\nM C S (\n\nt n e m e g a n a m\n\ne s u\n\ne r o c s\n\nr u o Y\n\n7\n\nw o fl k r o w w o fl t i G\n\ng n h c n a r b d e r u t c u r t s (\n\ni\n\nr o f\n\ns t n u o c c a\n\nt a h t\n\ny c i l\n\no p\n\nd n a\n\n, s e x fi t o h\n\n, s e r u t a e f\n\n) s e s a e l e r\n\n7\n\n5\n\nw o fl k r o w h c n a r b e r u t a e F\n\nh c a e\n\nr o f h c n a r b d e t a c i d e d (\n\na g n i s u s u s r e v\n\ne r u t a e f\n\n) n o i t a c o\n\nl\n\ne l g n i s d e z i l a r t n e c\n\n5\n\nl l a\n\nr o f\n\n3\n\nw o fl k r o w d e z i l a r t n e C\n\ny r t n e\n\nf o t n o p e l g n i s (\n\ni\n\n) s e g n a h c\n\n3\n\n1\n\ns e i r o t i s o p e r\n\ne l p i t l u M\n\n) e d o c\n\ne c r u o s\n\nf o s e i p o c (\n\ng n h c n a r b f o d a e t s n\n\ni\n\nd e s u\n\n1\n\n0\n\ng n h c n a r b o N\n\ni\n\ny g e t a r t s\n\n0\n\ns t n i o P\n\ne d o c - e c r u o S\n\ng n h c n a r b\n\ni\n\ns t n i o P\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\n|\n\n45\n\nn o i t a r g e t n i\n\ns u o u n i t n o C\n\n.\n\n4 - 1 e l b a T\n\n46\n\nR U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nl e v e L\n\ny t i r u t a M\n\n|\n\nE R O C S\n\nr u o Y\n\ne r o c s\n\nd n a\n\ns t p i r c s d\n\nl i\n\nu b d e t a m o t u A\n\nD N A t s i x e\n\ns s e c o r p t s e t\n\nt r o h s\n\nk c e h c h c a e r o f\n\ns n u r\n\nr e p o l e v e d\n\nn\n\n7\n\n) l a c o l (\n\nt n e m n o r i v n e\n\nr e p o l e v e D\n\nt s e t\n\ne l b a h s e r f e r o t\n\ns s e c c a\n\ns a h\n\n, s t p i r c s d\n\nl i\n\nu b n o i t a c i l\n\np p a\n\n, a t a d\n\nt n e m n o r i v n e d e z i d r a d n a t s\n\n) e s a b a t a d d n a p p a (\n\n5\n\nt s e t d e t a m o t u a\n\ne v i s n e h e r p m o C\n\ns t s i x e\n\ns s e n r a h\n\n3\n\nk c e h c r e p o l e v e d r a l u g e R\n\nh c n a r b t n e m p o l e v e d o t n\n\ni\n\n1\n\nI C\n\nr o f\n\ny d a e r\n\nt o N\n\n0\n\ns e t i s i u q e r e r p I C\n\ns t n i o P\n\nEnterprise DevOps Playbook\n\nr u o Y\n\ne g n a h c d e t a m o t u a h t i\n\nw\n\nl\n\no o t\n\nI C\n\nd e t a m o t u a h t i\n\nw\n\nl\n\no o t\n\nI C\n\nd e l u d e h c s h t i\n\nw\n\nl\n\no o t\n\nI C\n\nd\n\nl i\n\nu b\n\nl a u n a m h t i\n\nw\n\nl\n\no o t\n\nI C\n\no o t\n\nI C o N\n\ne s u\n\nl o o t\n\nI C\n\ne r o c s\n\nd e t a m o t u a d n a n o i t c e t e d\n\nd n a n o i t c e t e d e g n a h c\n\ns d\n\nl i\n\nu b d e t a m o t u a\n\ns l o r t n o c\n\ns e h c n a r b\n\nl l a m o r f\n\nt n e m y o p e d\n\nl\n\nm o r f\n\nt n e m y o p e d d e t a m o t u a\n\nl\n\ne h t\n\ne v a h t o n s e o d\n\nl\n\no o t (\n\n, e r u t a e f\n\n, t n e m p o l e v e d (\n\no t Y L N O h c n a r b t n e m p o l e v e d\n\ne c r u o s n\n\ni\n\ne g n a h c\n\nf o e g d e l w o n k\n\ns t n e m n o r i v n e\n\nl l a o t\n\n) e s a e l e r\n\nt n e m n o r i v n e\n\nt n e m p o l e v e d\n\n) h c n a r b e d o c\n\n) A Q\n\n, t s e t\n\n, v e D (\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nr u o Y\n\ns t s e t\n\ne c n a m r o f r e P +\n\ns t s e t\n\ny t i r u c e S +\n\ne h t\n\nf o s r e y a l\n\nl l a\n\nr o f\n\nt s e t\n\nt i n U +\n\nl l a o t n o i t a m o t u a d\n\nl i\n\nu B +\n\nd\n\nl i\n\nu b y l n O\n\nn o i t a m o t u A\n\ne r o c s\n\nn o i t a c i l\n\np p a\n\n, t s e t (\n\ns t n e m n o r i v n e\n\ne h t\n\nf o\n\no t n o i t a m o t u a\n\nI C y b d e l l o r t n o c\n\n) s r e h t o d n a\n\n,\n\nA Q\n\nt n e m p o l e v e d\n\nl o o t\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nR U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nl e v e L\n\ny t i r u t a M\n\nE R O C S\n\nr u o Y\n\nt s e l l a m\n\ns (\n\ns d o h t e m\n\ns a\n\ne t a r g e t n\n\nI\n\ng n n n u r\n\ni\n\nr e t f a\n\ny l i a d e t a r g e t n\n\nI\n\nt s e l l a m\n\ns (\n\ns d o h t e m\n\ns a\n\ne t a r g e t n\n\nI\n\nt i n u o n (\n\ny l i a d e t a r g e t n\n\nI\n\n,\n\nn i - k c e h c o N\n\nf o n o i t a r g e t n I\n\ne r o c s\n\ne t e l p m o c\n\ne r a\n\n) e d o c\n\ne l b a t u c e x e\n\n; s s a p s t s e t\n\nt i n u f i\n\n, s t s e t\n\nt i n u\n\nl l a\n\ne t e l p m o c\n\ne r a\n\n) e d o c\n\ne l b a t u c e x e\n\n) t i\n\nm m o c\n\ne r o f e b s n u r\n\nt s e t\n\ne h t\n\nl i t n u e t a r g e t n\n\ni\n\ne d o c\n\nr e p o l e v e d\n\nf i\n\n, s t s e t\n\nt i n u\n\nl l a g n n n u r\n\ni\n\nr e t f a\n\nP O T S\n\n, e s i w r e h t o\n\ne r o f e b s n u r\n\nt s e t\n\nt i n u o n (\n\ny t i l i\n\nb a p a c\n\ne l o h w\n\n, e s i w r e h t o ; s s a p s t s e t\n\nt i n u\n\n) t i\n\nm m o c\n\nr o e l u d o m\n\n, .\n\ng . e (\n\nr u o Y\n\ne r o c s\n\nP O T S\n\n7\n\nd\n\nl i\n\nu b e h t p o t s\n\ny l l a c i t a m o t u A\n\nd e t a m o t u a\n\nl l a\n\nl i t n u s s e c o r p\n\no n e r a\n\ne r e h t d n a\n\ns s a p s t s e t\n\ns r o r r e d\n\nl i\n\nu b\n\n7\n\n5\n\ne v a h\n\n,\n\nn o i t c a n a\n\ns i\n\ne r e h t n e h W\n\no t\n\ne c a l p n\n\ni\n\ns\n\nm\n\ns i n a h c e m\n\na o t\n\ne t a c i n u m m o c\n\nm a e t\n\nf o t e s\n\ne l b a r u g fi n o c\n\n, t c e f e d a\n\nr o f\n\n, .\n\ng . e (\n\ns r e b m e m\n\nl a c i n h c e t d n a\n\nr e p o l e v e d y f i t o n\n\n) d a e l\n\n5\n\n3\n\nk a e r b t o n s e o d d\n\nl i\n\nu b n e h W\n\nt s e t\n\nt i n u t u b\n\nn i - k c e h c h t i\n\nw\n\n, s l i a f\n\ne h t o t\n\nk c a b T R E V E R = N O I T C A\n\nn a c\n\ns r e p o l e v e d r e h t o t u b\n\n, e l fi\n\ne d o c\n\nr i e h t\n\nk c e h c o t\n\ne u n i t n o c\n\n3\n\n1\n\no t\n\ne u d s k a e r b d\n\nl i\n\nu b e h t\n\nf I\n\n= N O I T C A\n\nn i - k c e h c\n\na\n\nP O T S\n\ns s e c o r p d\n\nl i\n\nu b p o t s\n\n) a (\n\nk c e h c r e h t o t n e v e r p ) b (\n\ne d o c n e k o r b e h t o t\n\ns n\n\ni\n\n1\n\ne t e l p m o c\n\ns i\n\n) e r u t a e f\n\n0\n\nn e k a t\n\ns i\n\nN O I T C A o N\n\nI C\n\nf o s t l u s e r\n\nr o f\n\ns e i t i v i t c a\n\n0\n\ns t n i o P\n\n/ s t r e l A\n\nd n a s n o i t a c fi i t o n\n\nI C g n i r u d s n o i t c a\n\ns t n i o P\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\n|\n\n47\n\ng n i t s e t d e t a m o t u A\n\n.\n\n5 - 1 e l b a T\n\n48\n\nE R O C S R U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nr o t a c i d n I\n\ny t i r u t a M\n\n|\n\ne r o c s\n\ne r o c s\n\nr u o Y\n\nr u o Y\n\ne h t\n\ns t s e T\n\ne c n a m r o f r e P +\n\n7\n\nt s e t d e t a m o t u a\n\ny n a n e h W\n\ne g a i r t o t\n\ns p o t s\n\nm a e t\n\n, s l i a f\n\nm e l b o r p\n\ns t s e T\n\ny t i r u c e S +\n\n5\n\ny b d e w e i v e r\n\ne r a\n\ns\n\nm e l b o r P\n\ns n o i t c a d n a m a e t\n\nt n e m p o l e v e d\n\ns n a l p t n i r p s\n\ne h t o t n\n\ni\n\nd e n n a l p\n\no i r a n e c S\n\nl a n o i t c n u F +\n\ns t s e T\n\n3\n\nh c a e\n\nr o f n e k a t\n\ne r a\n\ns n o i t c A\n\nt n i r p s\n\ns t s e t\n\nt i n U\n\n1\n\nd e t n e m u c o d e r a\n\ns n o i t c A\n\no t p u t f e l\n\ns i\n\nt i\n\nd n a\n\ne h t\n\nx fi o t\n\ns r e p o l e v e d\n\ns t s e t d e t a m o t u a o N\n\nn e k a t n o i t c a o N\n\n0\n\ng n i t s e t d e t a m o t u A\n\ns t n i o P\n\nr o f\n\ns n o i t c A\n\nt s e t d e t a m o t u a\n\ns t l u s e r\n\nEnterprise DevOps Playbook\n\ns\n\nm e l b o r p\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\ne r o c s\n\nr u o Y\n\ne g a r e v o c\n\ne d o C\n\nr o f\n\nt n e m p o l e v e d n e v i r d - t s e T\n\ny t i l i\n\nb a t s e t\n\nr o f n g i s e D\n\ns t s e t\n\ne l p m\n\ni s w e F\n\ns t s e t\n\nt i n u o N\n\ns t s e t\n\nt i n U\n\ns I P A d n a\n\ns I U h t o b\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\ne r o c s\n\nr u o Y\n\n% 5 7 > e g a r e v o C\n\n% 5 7 < o t\n\n% 0 5 > e g a r e v o C\n\n% 0 5 < o t\n\n% 5 2 > e g a r e v o C\n\n% 5 2 < e g a r e v o C\n\nt s e t\n\nt i n u o N\n\ne g a r e v o c\n\nt s e t\n\nt i n U\n\nd e s u\n\no o t\n\ne g a r e v o c\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\ne r o c s\n\nr u o Y\n\nr o f\n\ns s e n r a h e h t\n\ns n u r\n\nl\n\no o t\n\nI C\n\nr o f\n\ns s e n r a h e h t\n\ns n u r\n\nl\n\no o t\n\nI C\n\ne r i t n e\n\ne h t n u r\n\ns r e p o l e v e D\n\nn w o r i e h t n u r\n\ns r e p o l e v e D\n\nt s e t\n\nt i n u o N\n\ny c n e u q e r f\n\nt s e t\n\nt i n U\n\ny r e v e n o d\n\nl i\n\nu b y r e v e\n\nd n a\n\nt n e m n o r i v n e\n\nt n e m p o l e v e d\n\nt i\n\nm m o c\n\nt a\n\ns s e n r a h\n\nn o h s a f\n\ni\n\nc o h d a n\n\ni\n\ns t s e t\n\nt n e m n o r i v n e\n\nd\n\nl i\n\nu b e r i t n e\n\ne h t\n\nr o f\n\ns d\n\nl i\n\nu b\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nE R O C S R U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nr o t a c i d n I\n\ny t i r u t a M\n\ne r o c s\n\nr u o Y\n\n% 5 7 > e g a r e v o c\n\ny r o t s\n\nr e s U\n\no t\n\n% 0 5 > e g a r e v o c\n\ny r o t s\n\nr e s U\n\n% 5 2 > e g a r e v o c\n\ny r o t s\n\nr e s U\n\n% 5 2 < e g a r e v o c\n\ny r o t s\n\nr e s U\n\nd e t a m o t u a o N\n\no i r a n e c S\n\n% 5 7 <\n\n% 0 5 < o t\n\nt s e t o i r a n e c s\n\nr o l a n o i t c n u f (\n\nt s e t\n\n) y r o t s\n\ne g a r e v o c\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\ne r o c s\n\ne r o c s\n\ne r o c s\n\ne r o c s\n\ne r o c s\n\nr u o Y\n\nr u o Y\n\nr u o Y\n\nr u o Y\n\nr u o Y\n\nt n e m e r u s a e m e c n a m r o f r e P\n\nn o i t c u d o r p n\n\ni\n\ns t s e t d n a\n\n7\n\ny l s u o u n i t n o C\n\n7\n\nt s e t (\n\nt s e t\n\ns s e r t S +\n\n) s t i\n\nm\n\ni l\n\ns ’ n o i t a c i l\n\np p a\n\n7\n\ng n i t s e t n o i t a r t e n e P +\n\n7\n\ny b\n\n, e l fi n i - d e k c e h c\n\ny r e v e\n\nr o F\n\ns A L S h t i\n\nw\n\nt s e t\n\ne c n a m r o f r e P\n\nd a o\n\nl\n\ne g a p\n\n,\n\nA L S n o i t c a s n a r t (\n\n) A L S\n\n5\n\nt n i r p s\n\ny r e v e\n\nr o F\n\n5\n\nt h g m n o i t a c i l\n\ni\n\np p a (\n\nt s e t\n\nk a o S +\n\ne m\n\ni t\n\nf o d o i r e p a\n\nr o f\n\nl l e w k r o w\n\n) l i a f n e h t d n a\n\n,\n\nd a o\n\nr e d n u\n\n5\n\ns i s y l a n a\n\ne d o c\n\nc i t a t S +\n\n5\n\ne h t\n\ny b\n\n, t n i r p s\n\ny r e v e\n\nr o F\n\nw e i v e r\n\ne h t\n\nt s e t\n\ne c n a m r o f r e P\n\ng n h t y r e v e\n\ni\n\n3\n\ne s a e l e r\n\ny r e v e\n\nr o F\n\n3\n\nt s e t d a o L +\n\n3\n\ne d o c d e t a m o t u A +\n\n3\n\ny b e s a e l e r\n\ny r e v e\n\nr o F\n\nd e t c e l e s\n\nt s e t\n\nt s e t\n\ng n n n a c s\n\ni\n\nr e h t o n a\n\ne c n a m r o f r e P\n\ny t i l a n o i t c n u f\n\n) s t s e t\n\ne k o m\n\ns (\n\n1\n\nc o h d A\n\n1\n\ne c n a m r o f r e P\n\n1\n\ny t i l i\n\nb a r e n u V\n\nl\n\n1\n\ny b d e m r o f r e P\n\nt s e t\n\nt s e t\n\ne c n a m r o f r e p o N\n\n0\n\ne c n a m r o f r e p o N\n\n0\n\ne c n a m r o f r e p o N\n\ns t s e t\n\n0\n\ns t s e t\n\ny t i r u c e s o N\n\n0\n\ny t i l i\n\nb a r e n u v o N\n\nl\n\ns t s e t e c n a m r o f r e P\n\ns t n i o P\n\nt s e t e c n a m r o f r e P\n\ny c n e u q e r f\n\ns t n i o P\n\nt s e t e c n a m r o f r e P\n\ns e p y t\n\ns t n i o P\n\ns e p y t\n\nt s e t y t i r u c e S\n\ns t n i o P\n\ny t i l i b a r e n u V\n\nl\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\nl\n\no o t\n\nI C\n\ne h t\n\nm a e t\n\nt n e m p o l e v e d\n\nm a e t\n\nt n e m p o l e v e d\n\ns i\n\ne s a e l e r\n\ne h t\n\nr e t f a m a e t\n\ng n n n a c s\n\ni\n\ny c n e u q e r f g n n n a c s\n\ni\n\ny d a e r\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\n|\n\n49",
      "page_number": 46
    },
    {
      "number": 7,
      "title": "Segment 7 (pages 54-61)",
      "start_page": 54,
      "end_page": 61,
      "detection_method": "topic_boundary",
      "content": "E R O C S R U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nr o t a c i d n I\n\ny t i r u t a M\n\n50\n\ne r o c s\n\nr u o Y\n\ny b\n\n, e l fi n\n\nd e k c e h c\n\ny r e v e\n\nr o F\n\ne h t\n\ny b\n\n, t n i r p s\n\ny r e v e\n\nr o F\n\ne h t\n\ny b e s a e l e r\n\ny r e v e\n\nr o F\n\nl a c i n h c e t\n\ny b d e m r o f r e P\n\ne d o c d e t a m o t u a o N\n\ne d o c d e t a m o t u A\n\n|\n\ne r o c s\n\nr u o Y\n\nl\n\no o t\n\nI C\n\ne h t\n\n7\n\nr e p o l e v e d e h t\n\ns e t a i t i n\n\ni\n\nI C\n\nr o f\n\nt n e m y o p e d y r e v e\n\nl\n\nt a\n\ne d o c\n\nt c e j o r p e h t d n a\n\ne s a b e d o c\n\ne h t\n\ny c n e u q e r f d e n fi e d r o f\n\nl\n\no o t\n\nm a e t\n\nt n e m p o l e v e d\n\n5\n\ns r e p o l e v e d\n\no o t\n\ne h t\n\ns e t a i t i n\n\nI C\n\nt n e m y o p e d e d o c\n\nl\n\ny r e v e\n\nt a\n\ne s u\n\nm a e t\n\nt n e m p o l e v e d\n\n3\n\nc i t a t s\n\ne s u s r e p o l e v e D\n\nr o f\n\ne l b a t i u s (\n\nl\n\no o t\n\ns i s y l a n a\n\nr o f\n\n) k c a t s\n\nl a c i n h c e t\n\ne h t\n\nt i\n\nm m o c\n\ne l fi h c a e\n\ne d o c\n\nm o d n a r\n\nt a d a e l\n\ns w e i v e r\n\n1\n\ns i s y l a n a\n\nc i t a t s\n\ny t u d - y v a e H\n\n) n a c S p p A M B\n\nI\n\n, .\n\ng . e (\n\nl\n\no o t\n\nl e v e l\n\nt c e j o r p t a d e s u\n\ng n n n a c s\n\ni\n\ny t i l a u q\n\n0\n\ns i s y l a n a\n\nc i t a t s o N\n\nd e s u\n\nl\n\no o t\n\nw e i v e r y t i l a u q\n\ny c n e u q e r f\n\ns t n i o P\n\ns i s y l a n a c i t a t S\n\nEnterprise DevOps Playbook\n\n) e s a e l e r\n\n, t n i r p s\n\ny r e v e\n\n, .\n\ng . e (\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\ne r o c s\n\nr u o Y\n\ny b\n\n, e l fi n\n\nd e k c e h c\n\ny r e v e\n\nr o F\n\nr o f\n\nm a e t\n\nr e h t o n a\n\ny b d e m r o f r e P\n\nr e h t o n a\n\ny b d e m r o f r e P\n\nr e h t o n a\n\ny b d e m r o f r e P\n\nn o i t a r t e n e p o N\n\nn o i t a r t e n e P\n\nl\n\no o t\n\nI C\n\ne h t\n\nt n i r p s\n\ny r e v e\n\ne s a e l e r\n\ny r e v e\n\nr o f\n\nm a e t\n\na\n\nf o e m\n\ni t\n\ne h t\n\nt a m a e t\n\ng n n n a c s\n\ni\n\ny c n e u q e r F g n i t s e T\n\nn o i t a t i d e r c c a\n\ny t i r u c e s\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nC a I\n\n.\n\n6 - 1 e l b a T\n\nR U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nr o t a c i d n I\n\ny t i r u t a M\n\nE R O C S\n\ne r o c s\n\nr u o Y\n\nd e n o i s i v o r p s i\n\ne r u t c u r t s a r f n\n\ng n n o i s i v o r p e r u t c u r t s a r f n\n\ni\n\nI\n\nd n a m e d n o ;\n\nd e s u s i\n\nS a a I\n\np u t e s\n\nr e t n e c\n\na t a D\n\nd e t a m o t u a o N\n\nd e t a m o t u A\n\ne s u e h t\n\ns a\n\ny l l a c i\n\nm a n y d\n\nt o n t u b\n\n, s I P A y b d e t a m o t u a\n\ns e c r u o s e r\n\ne r u t c u r t s a r f n\n\ni\n\ns r e v r e s\n\nl a c i s y h p\n\ne r u t c u r t s a r f n\n\ni\n\ne r u t c u r t s a r f n\n\ni\n\ne r o c s\n\nr u o Y\n\ns e s a e r c e d d n a\n\ns e s a e r c n\n\n7\n\ns e c i v r e s o r c i\n\nm d e z i r e n i a t n o C\n\nf o e l a c s o t u a d e t a r g e t n\n\nd n a\n\ng n i y l r e d n u d n a\n\ns r e n i a t n o c\n\ne r u t c u r t s a r f n\n\n7\n\ny t i l i\n\nb a l a c s n o i t a c i l\n\np p a o t d e i t\n\n5\n\ns e c i v r e s o r c i\n\nm d e z i r e n i a t n o C\n\nf o e l a c s o t u a d n a\n\ng n i t s i x e n o s e c i v r e s o r c i\n\nm\n\ne r u t c u r t s a r f n\n\ni\n\ne s u - o t – y d a e r\n\n5\n\ny l l a u n a m n e h w n o i t a e r c\n\nd e t s e u q e r\n\n3\n\nd n a\n\ns e l u d o m d e z i r e n i a t n o C\n\nf o g n n o i s i v o r p t n e d n e p e d n\n\ni\n\ni\n\ns e l u d o m d e z i r e n i a t n o c\n\ne h t\n\n3\n\nd e t a c o\n\nl l a d n a\n\n,\n\nd e z i l a u t r i v\n\ny l l a u n a m\n\ns n o i t a c i l\n\np p a o t\n\n1\n\nc i h t i l\n\no n o m d e z i r e n i a t n o C\n\nt n e m y o p e d n o i t a c i l\n\nl\n\np p a\n\n1\n\ng n n o i s i v o r p\n\ni\n\n0\n\nn o i t a z i r e n i a t n o c o N\n\n0\n\ng n n o i s i v o r p\n\ni\n\ns t n i o P\n\ne s u n o i t a z i r e n i a t n o C\n\ns t n i o P\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\n|\n\n51\n\ny r e v i l e d s u o u n i t n o C\n\n.\n\n7 - 1 e l b a T\n\n52\n\nR U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\ny t i r u t a M\n\n|\n\nE R O C S\n\nr u o Y\n\ne r o c s\n\ns t s e t\n\ne h t h t i\n\nn o s e i l e r\n\nr e n w o t c u d o r P\n\ne c n a t p e c c a d e t a m o t u a\n\nw e v i l\n\no g o t\n\ny l e t e l p m o c\n\nd\n\nl i\n\nu b\n\n7\n\ne h t\n\ns e s u r e n w o t c u d o r P\n\nl a u n a m\n\ns\n\nm r o f r e p t u b\n\n, s t l u s e r\n\ne v i l - o g e r o f e b\n\nl l e w s a\n\ns t s e t\n\nn o i s i c e d\n\n5\n\nh t i\n\nw e g a r e v o c\n\n% 0 0 1\n\ns t s e t\n\ne c n a t p e c c a d e t a m o t u a\n\nf o n o i t i n fi e d “\n\ne h t\n\ns a d e s u\n\nt n e m p o l e v e d e h t\n\nr o f\n\n” e n o d\n\nm a e t\n\n3\n\nt s e t o i r a n e c s d e t a m o t u A\n\ne h t o t d e d i v o r p s t l u s e r\n\nt o n o d s t l u s e r\n\ne h t\n\nt u b\n\n, t n e i l c\n\ne s u a c e b e c n a t p e c c a\n\nt c a p m\n\ni\n\n% 0 0 1 t o n s i\n\ne g a r e v o c\n\ne h t\n\n1\n\nd e t a m o t u a o N\n\ne t i u s\n\nt s e t\n\ne c n a t p e c c a\n\nn a m u h s i\n\ne r e h T\n\ne t a g d n a n o i t c a r e t n\n\ns w e i v e r\n\n0\n\nr o t a c i d n I\n\nd e t a m o t u A\n\ne c n a t p e c c a\n\ns t s e t\n\ns t n i o P\n\nEnterprise DevOps Playbook\n\nr u o Y\n\nT A U d n a A Q o t d e r e v i l e d s d\n\nl i\n\nu B\n\nT A U d n a A Q o t\n\ns d\n\nl i\n\nu B\n\nd e r e v i l e d d n a d e t s e t\n\ns d\n\nl i\n\nu B\n\ne n o d e c n a t p e c c a\n\nr o f g n i t s e T\n\nt o n s e o d t c a r t n o C\n\nt c a r t n o C\n\ne r o c s\n\ny n a\n\nt u o h t i\n\nw s t n e m n o r i v n e\n\nh g u o r h t\n\ns s a p s t n e m n o r i v n e\n\nt s e t d n a\n\nt n e m p o l e v e d o t\n\nr o (\n\nr o t c a r t n o c\n\nr e h t o n a\n\ny b\n\nf o s t l u s e r\n\nw o\n\nl l a\n\ns t n i a r t s n o c\n\n, a t a d\n\n, . e . i ( n o i t n e v r e t n\n\ni\n\nl a u n a m\n\ne t a g g n i t s e t\n\nl a u n a m\n\nt u o h t i\n\nw s t n e m n o r i v n e\n\n) y t r a p\n\ne b o t\n\ns t s e t d e t a m o t u a\n\n) g n i k r o w t e n\n\nn o i t a r u g fi n o c\n\ny l l\n\nu f ( n o i t n e v r e t n\n\nl a u n a m\n\ns i\n\nr o t c a r t n o c\n\nt n e m p o l e v e D\n\ny r e v i l e d r o f d e s u\n\n) d e t a m o t u a\n\ns i h t\n\nr o f\n\ne l b i s n o p s e r\n\nt o n\n\ne c n a t p e c c a\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nr u o Y\n\nt n e m y o p e d d e t a m o t u a\n\nl\n\ny l l\n\nu F\n\ns i\n\ne n\n\ni l e p p t n e m y o p e D\n\ni\n\nl\n\ns w o\n\nl l a\n\ne n\n\ni l e p p t n e m y o p e D\n\ni\n\nl\n\ns w o\n\nl l a\n\ne n\n\ni l e p p t n e m y o p e D\n\ni\n\nl\n\nd e t a m o t u a o N\n\nt n e m y o l p e D\n\ne r o c s\n\ns t s i x e\n\ne n\n\ni l e p p\n\ni\n\nl l\n\nu f\n\ne l b a n e o t\n\ne l b a r u g fi n o c\n\nA Q o t\n\nt n e m y o p e d d n a\n\nl\n\nI C\n\ns e i t i v i t c a\n\nI C\n\ny l n o\n\ne n\n\ni l e p p t n e m y o p e d\n\ni\n\nl\n\ne n\n\ni l e p p\n\ni\n\nl a u n a m a\n\nt r e s n\n\ni\n\no t\n\ne l b i s s o p s ’ t I\n\nm o r f n o i t a m o t u a\n\ns t n e m n o r i v n e\n\nt s e t d n a\n\nd e s u s i\n\nh c i h w\n\n,\n\np e t s\n\nl a v o r p p a\n\nn o i t c u d o r p o t\n\nt n e m p o l e v e d\n\nk c e h c\n\nl a u n a m a\n\nt u o h t i\n\nw\n\nr o h t i\n\nw\n\ne b t o n n a c\n\nt u b\n\n, t n e m y o p e d\n\nl\n\nt n e m y o p e d n o i t c u d o r p r o f\n\nl\n\ns e t a g\n\nl a u t c a r t n o c o t\n\ne u d d e s u\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nt n e m y o l p e d s u o u n i t n o C\n\n.\n\n8 - 1 e l b a T\n\nR U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\ny t i r u t a M\n\nE R O C S\n\nr o t a c i d n I\n\nr u o Y\n\ne s a e l e r\n\ne m\n\ni t n w o d o r e Z\n\ne n ffl o n e k a t\n\ni\n\ns i\n\nm e t s y S\n\ne n ffl o n e k a t\n\ni\n\ns i\n\nm e t s y S\n\ne n ffl o n e k a t\n\ni\n\ns i\n\nm e t s y S\n\nn e k a t\n\ns i\n\nm e t s y S\n\no t\n\nt n e m y o l p e D\n\ne r o c s\n\ne h t h t i\n\nw d e d a r g p u s i\n\nm e t s y S\n\ns i\n\nt n e m y o p e d k c i l c - e n O\n\nl\n\nL L A t u b\n\nn o i t a l l a t s n\n\ni\n\np e t s - y b - p e t S\n\np e t s - y b - p e t S\n\ne n ffl o\n\ni\n\nn o i t c u d o r p\n\nr u o Y\n\ne r o c s\n\nm e t s y s\n\ne h t g n i k a t\n\nt u o h t i\n\nw d\n\nl i\n\nu b\n\nn w o d\n\n7\n\nt n e m y o p e d n e e r g / e u B\n\nl\n\nl\n\nl a c i t n e d\n\no w\n\nt (\n\ne m\n\ni t n w o d o N\n\nd n a\n\ne u b\n\nl\n\n:\n\nn o i t c u d o r p f o s n o i s r e v\n\nd n a d e d a r g p u s i\n\ne n o ;\n\nn e e r g\n\ne h t\n\nt a\n\nr e h t o e h t h t i\n\nw d e c a l p e r\n\n) l e v e l\n\nS N D\n\n7\n\ne r o f e b d e t s e t d n a d e m r o f r e p\n\ne v i l\n\no g\n\n5\n\nd n a\n\ny r a n a c o t\n\ny o p e d t s r i F\n\nl\n\nt a\n\ne n o s r e v r e s\n\ne d a r g p u n e h t\n\nt n e m y o p e d e h t\n\nl\n\nl i t n u e m\n\ni t\n\na\n\ne t e l p m o c\n\ns i\n\ne m\n\ni t n w o d o N\n\n5\n\nd e t a m o t u a\n\ne d u l c n\n\ni\n\ns p e t s\n\ns n o i t a r u g fi n o c\n\n3\n\nd e y o p e d d\n\nl\n\nl i\n\nu b\n\ng n i s a e l e r\n\ny r a n a C\n\nt s r fi t n e m n o r i v n e\n\ny r a n a c o t\n\nn\n\ni\n\ny r a n a c\n\ne h t g n i t s e t\n\nr e t f A\n\ns i\n\nm e t s y s\n\ne h t\n\n,\n\nd\n\nl i\n\nu b n o i t c u d o r p\n\ns i\n\ne d a r g p u e h t d n a n w o d n e k a t\n\nd e m r o f r e p\n\n3\n\nE M O S\n\nt u b\n\n,\n\nn o i t a l l a t s n\n\ne d u l c n\n\ns p e t s\n\nd e t a m o t u a\n\ns n o i t a r u g fi n o c\n\n1\n\ns e c a l p e r\n\nt n e m y o p e D\n\nl\n\nd\n\nl i\n\nu b g n i t s i x e\n\ne h t\n\n1\n\nd e t c u d n o c\n\nl l\n\nA\n\ng n i s u y l l a u n a m\n\ng n i t a r e p o d r a d n a t s\n\np e t s d n a s e r u d e c o r p\n\nn o i t a l l a t s n\n\ni\n\np e t s - y b\n\ne d u g\n\ni\n\n0\n\nd e t a m o t u a o N\n\nt n e m y o p e d\n\nl\n\n0\n\ns t n o P\n\ni\n\nt n e m y o l p e D\n\ns e i t i l i b a p a c\n\ns t n i o P\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\n|\n\n53\n\ng n i r o t i n o m\n\ns u o u n i t n o C\n\n.\n\n9 - 1 e l b a T\n\n54\n\nR U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\ny t i r u t a M\n\n|\n\nE R O C S\n\nr u o Y\n\ne r o c s\n\n: s e p y t g n i r o t i n o m e s e h t\n\nf o\n\ne c n a m r o f r e p n o i t a c i l\n\np p A\n\ng n i r o t i n o m\n\ns i s y l a n a d n a g n i r o t i n o m g o L\n\ng n i r o t i n o m y t i r u c e S\n\nl l\n\nA\n\n\n\n\n\n\n\n: s e p y t g n i r o t i n o m e e r h T\n\ne c n a m r o f r e p n o i t a c i l\n\np p A\n\ng n i r o t i n o m\n\ns i s y l a n a d n a g n i r o t i n o m g o L\n\ng n i r o t i n o m y t i r u c e S\n\n\n\n\n\n\n\n: s e p y t g n i r o t i n o M\n\ne c n a m r o f r e p n o i t a c i l\n\np p A\n\ng n i r o t i n o m\n\nd n a g n i r o t i n o m g o L\n\ns i s y l a n a\n\n\n\n\n\ne h t\n\nf o d e s u d e t i\n\nm i L\n\ny b s l o o t g n i r o t i n o m\n\nm a e t\n\ns n o i t a r e p o\n\ng n i r o t i n o m o N\n\nn o i t u o s\n\nl\n\ns i\n\ng n i r o t i n o M\n\ny b d e m r o f r e p\n\nm a e t\n\ns n o i t a r e p o\n\nm e t s y s (\n\nr o t a c i d n I\n\ng n i r o t i n o M\n\nn o i t u l o s\n\nEnterprise DevOps Playbook\n\ng n i r o t i n o m y t i r u c e S\n\n\n\nd n a\n\ns r o t a r t s i n m d a\n\ni\n\n) s A B D\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nr u o Y\n\nk c a t s\n\ne r i t n e\n\ne h t\n\nw e i v o t\n\ny t i l i\n\nb A\n\nn\n\ns e u s s i\n\ne t a l o s i\n\no t\n\ny t i l i\n\nb A\n\ne m\n\ni t - l a e r o t\n\ns s e c c a\n\ny s a E\n\nn o i t a c i l\n\np p a\n\nl a u n a M\n\nn o i t a c i l\n\np p a o N\n\nn o i t a c i l p p A\n\ne r o c s\n\nm o r f\n\n,\n\nd e fi i t n e d\n\ni\n\ne u s s i\n\ny n a\n\nf o\n\ne h t o t n w o d n o i t c u d o r p\n\nn o i t a c i l\n\np p a n o s c i t s i t a t s\n\ng n i r o t i n o m e c n a m r o f r e p\n\ne c n a m r o f r e p\n\ne c n a m r o f r e p\n\ne h t o t n w o d t s e u q e r\n\nl a i t i n\n\n/\n\nM V / s r e v r e s\n\nl a u d i v i d n\n\nn o i t c u d o r p n\n\ne c n a m r o f r e p\n\ns l o o t\n\nS O g n i s u\n\ng n i r o t i n o m\n\ng n i r o t i n o m\n\ne s a b a t a d\n\ns e s s e c o r p d n a\n\ns r e n i a t n o c\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nr u o Y\n\nd n a d e x e d n\n\ni\n\ne r a\n\ns g o\n\nl\n\nl l\n\nA\n\nn\n\ni\n\nt u p d n a d e t a d\n\ni l\n\no s n o c\n\ns g o\n\nl l\n\nA\n\n,\n\nn o i t a c i l\n\np p a\n\n, . e . i (\n\ns g o\n\nl\n\nl l\n\nA\n\ng n i s u g n i r o t i n o m g o L\n\ng n i r o t i n o m g o\n\nl\n\no N\n\ng n i r o t i n o m g o L\n\ne r o c s\n\ne l b a h c r a e s\n\ny l k c i u q\n\nn o i t a c o\n\nl\n\nl a r t n e c\n\na\n\ny l i s a e\n\n) s s e c c a b e w\n\n, y t i r u c e s\n\ns l o o t\n\nS O\n\nw e i v e r\n\nr o f\n\ne l b i s s e c c a\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nR U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\ny t i r u t a M\n\nE R O C S\n\nr o t a c i d n I\n\nr u o Y\n\ne r a\n\nt a h t\n\ns d a o l y a p r o t i n o M\n\ng n i r o t i n o m k r o w t e n d e c n a v d A\n\n,\n\nn o i t a c fi i t n e d\n\ni\n\nt a e r h t\n\ne l p m i S\n\ng n i r o t i n o m y t i r u c e S\n\ny t i r u c e s o N\n\ny t i r u c e S\n\ne r o c s\n\nr o f\n\nm e t s y s\n\ne h t g n i t t i h\n\nr o s e i t i l i\n\nb a r e n u v d n fi y l e v i t c a o t\n\nl\n\ns k c a t t a\n\nS o D s u o i r a v\n\ns a h c u s\n\nd n a\n\nS O c i s a b g n i s u\n\ng n i r o t i n o m\n\ng n i r o t i n o m\n\ns k c a t t a\n\ne l b i s s o p g n i y f i t n e d\n\ns k c a t t a\n\ne v i t c a\n\ns l o o t\n\nk r o w t e n\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nr u o Y\n\ne r o c s\n\ne r a\n\ns d o h s e r h t g n i t r e l A\n\nl\n\ne l b a fi d o m\n\ni\n\n7\n\ns e d i v o r p n o i t u o s g n i t r e l A\n\nl\n\n, s t n e v e\n\ns u o i v e r p f o t s i l\n\nc i r o t s i h\n\ns l i a t e d t n e v e g n d u l c n\n\ni\n\n5\n\nd e l i a t e d e d i v o r p s t r e l A\n\ne r u t a n e h t\n\nt u o b a n o i t a m r o f n\n\nr e g g i r t g n i r o t i n o m\n\nf o\n\n3\n\ne r a\n\ns e i t r a p e l b i s n o p s e R\n\nm a e t\n\ny b d e t r e l a\n\n, s g o\n\nl\n\ng n i r o t i n o m\n\ny t i r u c e s d n a\n\n,\n\nn o i t a c i l\n\np p a\n\n1\n\ng n i t r e l a o N\n\n0\n\ng n i t r e l A\n\nn o i t u l o s\n\ns t n i o P\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\n|\n\n55\n\nPlay 4: Create a DevOps Pipeline So how do you put DevOps into action once you have a clear road‐ map and identify what DevOps means to your organization? We suggest you begin by defining and creating a DevOps delivery pipe‐ line. This is the set of tools and processes working together to pro‐ vide workflow automation that reflects your DevOps practices taking code changes all the way through into production. The shape of the pipeline, the activities inside each step, what steps are automa‐ ted versus manual, and code release and deployment strategies will reflect your DevOps practices, requirements, and philosophies. Every environment and pipeline is different, but the characteristics of a successful delivery pipeline are the same, providing the follow‐ ing:\n\nAutomation of building, testing, and deploying\n\nAutomation of infrastructure, which can be created and destroyed without impacting the health of the software\n\nReflective of your release DevOps philosophy and strategy\n\nRepeatable and expected results with immutable infrastructure and processes\n\nVisibility into the entire pipeline workflow steps.\n\nThere is a wide range and constantly evolving set of technology and tools for implementing your delivery pipeline. Key factors to con‐ sider when choosing your set of DevOps tools include team skillset, breadth of required hosting providers/infrastructure, availability of the tools’ APIs, and, ultimately, the tools’ ability to execute your DevOps practices’ requirements and philosophy.\n\nThe delivery pipeline you build should first satisfy the basic flow. With it, you should be able to do the following:\n\nCheck out code\n\nChange the code and integrate it into the repository\n\nRun validation and predeployment automated tests to ensure the code meets required needs, does not break other existing code, and runs as expected\n\nDeploy your builds on predefined infrastructure clusters\n\n56\n\n|\n\nEnterprise DevOps Playbook\n\nMove the build from development to testing, testing to QA, and finally to production.\n\nWhen the basic flow is perfected, you can begin exploring advanced concepts that can help you to safely and reliably deploy, easily scale, and roll back or forward. Among the advanced concepts, you should become familiar with these:\n\nSpin up or down virtual machines (or on IaaS platforms) based on user load\n\nContainerize (e.g., use Docker) your application and deploy it on a scalable server cluster\n\nProvision containers based on user load\n\nExplore microservices architecture. This is not easy to imple‐ ment and there are many considerations that must be addressed involving this approach, including service discovery, communi‐ cations, and orchestration. These aspects are beyond the scope of this playbook.\n\nIt is important to approach and look at your pipeline as an enter‐ prise change management workflow because handling one project (delivery pipeline) is not the same when you have multiple delivery streams that need to be validated and merged into a shared work‐ flow for handling dependencies. Simplh having automation and repeatability does not necessarily equate to an effective and scalable pipeline. You want to avoid creating a complex Rube Goldberg–type contraption and keep steps simple as appropriate and select tools for what they are good/meant for versus doing heavy customization and or using a large of amount of plug-ins.\n\nGuiding Questions\n\nAre there any steps that cannot be automated and will need manual review and/or acceptance?\n\nIs the goal to move to a microservices architecture?\n\nHow many builds to production do you want to target/require on a daily/weekly/monthly basis?\n\nWhat SLAs do you want to automate?\n\nWhat platforms and hosting providers do you need to support?\n\nPlay 4: Create a DevOps Pipeline\n\n|\n\n57",
      "page_number": 54
    },
    {
      "number": 8,
      "title": "Segment 8 (pages 62-69)",
      "start_page": 62,
      "end_page": 69,
      "detection_method": "topic_boundary",
      "content": "How many features are you anticipating?\n\nDo you currently use a canary release and or blue/green deploy‐ ment strategy when rolling features out to production?\n\nHow are production rollbacks typically handled?\n\nAre you planning to move to containerization architecture soon?\n\nChecklist\n\nDefined repeatable automated and manual steps that every code change will go through—the workflow does not change and provides expected steps and results every time.\n\nEstablished and verified full traceability for each step in the pipeline—the ablility to see where a change is in the pipeline at any time and its status.\n\nImplemented notification and resolution process for each suc‐ cess/fail action for each step—ensure that you clearly define responsibility groups for each action issue.\n\nVerified immutable infrastructure—your IaC is able to tear down and bring up each environment over and over again with the same expected state and results.\n\nEnsured metrics defined in continuous monitoring are cap‐ tured, visible, and integrated with your notification process.\n\nPlay 5: Learn and Improve through Metrics and Visibility Now that you have created a pipeline and have a delivery flow that’s running, you’ll need to know how effective it is and what you can improve. One of the key principles we highlighted earlier is being a learning organization, and that the mastery of DevOps requires con‐ stant feedback and an environment that fosters continuous learning. To learn, you need to have the metrics and visibility into the effec‐ tiveness of the processes, environments, and operations. In a DevOps project, metrics for monitoring project performance and capturing project data serve five critical purposes:\n\n58\n\n|\n\nEnterprise DevOps Playbook\n\nDetect failure\n\nDiagnose performance problems\n\nPlan capacity\n\nObtain insights about user interactions\n\nIdentify intrusions\n\nBecause systems are constantly increasing in complexity, breadth of distribution, scope, and size, measuring their activities and levels of efficacy—and logging the results in data banks—demands a new generation of infrastructure and services to support these efforts. Given with the right equipment in place, the value of metrics spans a broad swath of information, from systems health and performance to end-user habits.\n\nFor example, when applications or programs fail, metrics provide context to alerts, opening windows into what activities occurred and what interactions took place leading up to each failure. Equally important, metrics offer historical awareness of usage patterns, which is critical for anticipating potential failures, writing fixes that could shore up programs during oversubscribed periods, and deter‐ mining how robust future software must be. For this purpose, ques‐ tions that metrics can answer include the following:\n\nWhat are the peak hours of the day, days of the week, or months of the year for utilization?\n\nIs there a seasonal usage pattern, such as summertime lows, hol‐ iday highs, more activity when school is in session or when it isn’t, and so on?\n\nHow do maximum (peak) values compare against minimum (valley) values?\n\nDo peak and valley relationships change in different regions around the globe?\n\nIn a large-scale system, ubiquitous monitoring can generate data involving millions of events with countless numbers of log lines devoted to metrics measurements. This, in turn, can monopolize overhead and affect performance, transmission, and storage. The emergence of big data analytics and modern distributed logging alleviates this problem. Moreover, advanced machine learning algo‐ rithms can deal with noisy, inconsistent, and voluminous data.\n\nPlay 5: Learn and Improve through Metrics and Visibility\n\n|\n\n59\n\nWhen deciding how much data resolution to maintain for metrics, you need to think about the type and amount of information that you want to get from them. Will you be depending on metrics for insight into what is causing an outage or degradation? If so, you’ll most likely want to have a fine resolution, less than a minute. Or will you be using the data primarily for capacity planning on a three-, six-, or nine-month timeline? If so, you’ll want to ensure that you can retain the historical details about maximum and minimum over a long period of time.\n\nAt the very least, the metrics in place should effectively and continu‐ ously monitor the following four fundamental DevOps facets:\n\nDeployment frequency\n\nHow often does new code reach customers? DevOps practices make frequent or continuous program delivery possible, and large, high-traffic websites and cloud-based services make it a necessity. With fast feedback and small-batch development, updated software can be deployed every few days, or even sev‐ eral times per day. In a DevOps environment, delivery (i.e., deployment to production) frequency can be a direct or indirect measure of response time, team cohesiveness, developer capa‐ bilities, development tool effectiveness, and overall DevOps team efficiency.\n\nChange lead time (from development to production)\n\nHow long does it take, on average, to move code from develop‐ ment through a cycle of A/B testing to 100 percent deployed and upgraded in production? The time from the start of a devel‐ opment cycle (the first new code) to deployment is the change lead time. It is a measure of the efficiency of the development process, of the complexity of the code and the development sys‐ tems, and (like deployment frequency) of team and developer capabilities. If the change lead time is too long, it might be an indication that the development and deployment process is inefficient in certain stages or that it is subject to performance bottlenecks.\n\nChange failure rate (per week)\n\nWhat percentage of deployments to production failed or rever‐ ted back to be fixed with another patch? One of the main goals of DevOps is to turn rapid, frequent deployments into an every‐ day affair. For such deployments to have value, the failure rate\n\n60\n\n|\n\nEnterprise DevOps Playbook\n\nmust be low. In fact, the failure rate must decrease over time, as the experience and the capabilities of the DevOps teams increase. A rising failure rate, or a high failure rate that does not decline over time, is a good indication of problems in the over‐ all DevOps process.\n\nMean time to recovery (MTTR)\n\nWhat is the mean time to recover from a failed deployment— that is, the time from failure to recovery from that failure? This generally is a good measure of team capabilities and, like the failure rate, it should show an overall decrease over time (allow‐ ing for occasional longer recovery periods when the team encounters a technically unfamiliar problem). MTTR can also be affected by such things as code (or platform) complexity, the number of new features being implemented, and changes in the operating environment (e.g., migration to a new cloud server).\n\nIn addition to these essential four metrics, there are others that we recommend DevOps teams consider. The more information you have, the more successful your DevOps projects will be. Among the other benchmarks to assess are the following:\n\nDelivery frequency\n\nHow often is code deployed to the development and test envi‐ ronments?\n\nChange volume\n\nFor each deployment, how many user stories and new lines of code are making it to production?\n\nCustomer tickets (per week)\n\nHow many alerts are generated by customers to indicate service issues?\n\nPercentage change in user volume\n\nHow many new users are signing up and generating traffic?\n\nAvailability\n\nWhat is the overall service uptime and were any SLAs violated?\n\nResponse time\n\nDoes the application’s performance reach the predetermined thresholds?\n\nPlay 5: Learn and Improve through Metrics and Visibility\n\n|\n\n61\n\nIn addition to the nitty-gritty, day-to-day performance and usage patterns that DevOps metrics excel in providing, there are two other areas of organizational activities that well-designed standards can monitor for strengths and weaknesses: cultural metrics and process metrics. Let’s look more closely at each one.\n\nCultural Metrics DevOps is meant to include a set of efficiency and improvement principles that should minimize project development conflict and eliminate stress and burnout. In turn, team members will ideally be more healthy, loyal to the organization, and deeply engaged in workplace activities. It’s possible to measure across a number of key cultural indicators, including sentiment toward change, failure, and a typical day’s work. Among the most telling metrics to be sought in this regard are the following:\n\nCross-skilling\n\nHow much knowledge sharing and pairing exists among teams?\n\nFocus\n\nAre teams working in a fluid and focused manner toward ach‐ ieving common goals or objectives?\n\nMultidisciplinary teams\n\nDo teams comprise members with varied but complimentary experience, qualifications, and skills?\n\nProject-based teams\n\nAre teams organized around projects rather than solely skill‐ sets?\n\nBusiness demand\n\nAre the demands placed on development teams by the business side too onerous?\n\nExtra lines of code\n\nHow many extraneous lines of code exist in the project?\n\nAttitude\n\nAre team members receptive to and positive about continuous improvement?\n\nNumber of metrics\n\nIs the obsession with metrics perceived to be too high?\n\n62\n\n|\n\nEnterprise DevOps Playbook\n\nTechnological experimentation\n\nWhat is the degree of experimentation and innovation within the project?\n\nTeam autonomy\n\nHow successfully does the team manage its own work and working practices?\n\nRewards\n\nDo team members feel appreciated and rewarded for their work and successes?\n\nAs you can tell, many of these cultural metrics cannot be directly measured. That is why we have stressed the mindset of becoming a learning organization and having transparency and visibility into the end-to-end process. For example, with regard to cross-skilling, one way to assess that is to track to see if there’s a high variance in the velocity across Agile teams, especially knowing that team mem‐ bers are being shuffled. The takeaway here is that in order to gauge the impact and effectiveness of cultural changes, you need to estab‐ lish a means for constant feedback and dialogue with the team.\n\nProcess Metrics One goal of a typical DevOps project is to achieve continuous deployment. This occurs by linking software development processes and tools together to allow fully tested, production-ready, commit‐ ted code to proceed to a live environment without user interaction. This software infrastructure portion of a DevOps project is often termed the DevOps toolchain. It’s useful to measure the relative maturity of the component processes of the toolchain as a proxy for overall DevOps capabilities. Typically, we look at an organization’s skills in the following areas:\n\nProject requirements gathering and management\n\nAdherence to Agile development principles\n\nWhether the software build is generally defect-free\n\nFluidity of releases and deployment\n\nDegree to which units of code are tested to determine their suit‐ ability for use\n\nDegree of user acceptance testing\n\nPlay 5: Learn and Improve through Metrics and Visibility\n\n|\n\n63\n\nQuality assurance programs\n\nPerformance monitoring to ensure the program is reliable and can scale\n\nCloud testing to be certain that the application and its load can be supported\n\nAlso under the umbrella of process is sharing, which is another area that is often overlooked but should be encouraged—and measured. People from different parts of an organization often have different, but overlapping, skillsets. For example, this is true of staffers on the development side and the operations side, the disparate parts of the enterprise that DevOps is meant to link together. Given the impor‐ tance of sharing between these teams, and the benefits to be gained by an organization when there is a maximum amount of sharing, it’s useful to measure the frequency of sharing.\n\nExamples of workplace sharing that you can measure, and the aspects of a DevOps project that these collaborative efforts affect, include the following:\n\nShared Goal: Reliability and speed\n\nShared Problem Space: Deployment and delivery\n\nShared Priorities: Improvement decisions\n\nShared Location: Communications\n\nShared Communication: Chat, wiki, mailing list\n\nShared Codebase: Code and infracode\n\nShared Responsibility: Building and deployment\n\nShared Workflow: One-button deployment\n\nShared Reusable Environments: Reusable recipes\n\nShared Process: Standups and releases\n\nShared Knowledge: One ticketing system\n\nShared Success and Failure: Common experience and history\n\nMetrics Tools There are many monitoring and metrics systems and tools available, both from open source and commercial developers. Typical systems\n\n64\n\n|\n\nEnterprise DevOps Playbook\n\ninclude Nagios; Sensu and Icinga; Ganglia; and Graylog2, Logstash, and Splunk:\n\nNagios\n\nNagios is probably the most widely used monitoring tool due to its large number of plug-ins, which are basically agents that col‐ lect metrics in which you are interested. However, Nagios’ core is essentially an alerting system with limited features, and Nagios is weak in dealing with the frequent changes of servers and infrastructure encountered in cloud environments.\n\nSensu and Icinga\n\nSensu is a highly extensible and scalable system that works well in a cloud environment. Icinga is a fork of Nagios with a more scalable distributed monitoring architecture and easy exten‐ sions. Icinga also has stronger internal reporting systems than Nagios. Both Sensu and Icinga can run Nagios’s large plug-in pool.\n\nGanglia\n\nGanglia was originally designed to collect cluster metrics. It is designed to have node-level metrics replicated to nearby nodes to prevent data loss and over-chattiness to the central reposi‐ tory. Many IaaS providers support Ganglia.\n\nGraylog2, Logstash, Splunk\n\nThese distributed log management systems are tailored to process large amounts of text-based metrics logs. They have frontends for integrative exploration of logs and powerful search features.\n\nSummary There is plenty of information, excitement, value, promise, and con‐ fusion that comes with DevOps. The benefits are clear: improved quality, flexibility, speed to value, increased efficiency, and potential cost savings. Less clear, however, is the best approach to adopting DevOps practices. Adopting DevOps practices involves a mindset change that is built on the right mix of people and culture, an understanding of DevOps practices and how they relate to your projects, and, ultimately, choosing and implementing tools to put DevOps practices into action through a delivery pipeline.\n\nSummary\n\n|\n\n65",
      "page_number": 62
    },
    {
      "number": 9,
      "title": "Segment 9 (pages 70-76)",
      "start_page": 70,
      "end_page": 76,
      "detection_method": "topic_boundary",
      "content": "Selecting DevOps tools is a challenging task given the many tools available. We recommend aligning the tools with your organization’s skillsets, flexibility needs, and modularity bias. This technical land‐ scape is changing constantly, with updated versions, open source efforts, and new solutions. Make sure the tools you select do not require custom integration or a high level of consolidation, which might lead to a large effort to swap out the application down the road.\n\nMost organizations have trouble establishing appropriate require‐ ments and goals for a DevOps program. You will need initial targets to quantify your successes, and those targets will not be the same from one team to another. Consequently, every organization will implement DevOps to different levels of maturity. We hope this report has provided you with a solid foundation of what DevOps means, and more importantly, a framework for developing an effec‐ tive adoption plan or to incorporate/assess your current efforts:\n\nUnderstand each DevOps practice and how it conforms with your organization’s objectives and goals\n\nAssess the level of your organization’s DevOps capabilities\n\nDetermine how far you need to go and what you need to do to achieve the DevOps level of performance that you want.\n\nUnderstanding these three items will put you on the road to a suc‐ cessful and enduring DevOps practice. We look forward to hearing your success stories!\n\nRecommended Reading We recommend the following reading that dives deeper into each of the areas we touched upon in this report, from culture to technical details around continuous delivery and microservices:\n\nThe Phoenix Project: A Novel about IT, DevOps, and Helping Your Business Win, Gene Kim and Kevin Behr (IT Revolution Press).\n\nThe Fifth Discipline: The Art & Practice of The Learning Organi‐ zation, Peter M. Senge (Doubleday Business).\n\n66\n\n|\n\nEnterprise DevOps Playbook\n\nThe DevOps Handbook: How to Create World-Class Agility, Relia‐ bility, and Security in Technology Organizations, Gene Kim and Patrick Debois (IT Revolution Press).\n\nContinuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation, by Jez Humble and David Farley (Addison-Wesley Professional).\n\nBuilding a DevOps Culture, Mandi Wells (O’Reilly).\n\nThe DevOps 2.0 Toolkit: Automating the Continuous Deployment Pipeline with Containerized Microservices, Viktor Farcic (Create‐ Space Independent Publishing Platform).\n\nBuilding Microservices, Sam Newman (O’Reilly).\n\nRecommended Reading\n\n|\n\n67\n\nAbout the Authors\n\nBill Ott is a Vice President with Booz Allen Hamilton, where he leads a group of creative and technology professionals who are pas‐ sionate about integrating human-centered design, Agile develop‐ ment, DevOps, security, and advanced analytics to build digital services that users will use and enjoy, securely. His inspiration comes from his three boys who love technology—specifically Minecraft gaming/programming and creating and watching YouTube videos. Mr. Ott holds a BS in electrical engineering from Drexel University and an MBA from Emory University.\n\nJimmy Pham is an avid technologist who has designed, developed, and managed large software solutions for major private and public customers. He is currently a Chief Technologist focusing on modern software development. His interests and experience also span web acceleration/performance and cloud security. Prior to Booz Allen Hamilton, he worked at Akamai and ran a startup. He holds a degree in Computer Science (BSE) and minors in Mathematics and Psychology.\n\nHaluk Saker is a director with the Digital team and a 20-year vet‐ eran of Booz Allen. An experienced system/cloud architect, he leads Digital’s DevOps practice, microservices architecture, and numerous cloud platforms investments. He is also one of the coauthors of the Booz Allen Agile Playbook that is used by all software development teams at the firm. He has an extensive background in turnkey sys‐ tem and cloud implementations, modern technology stacks, and Continuous Deployment. Haluk holds a BS in Electrical Engineer‐ ing, an MS in Engineering Management, and an MS in Management Information Systems.",
      "page_number": 70
    }
  ],
  "pages": [
    {
      "page_number": 3,
      "content": "Enterprise DevOps Playbook A Guide to Delivering at Velocity\n\nBill Ott, Jimmy Pham, and Haluk Saker\n\nBeijing Beijing\n\nBoston Boston\n\nFarnham Sebastopol Farnham Sebastopol\n\nTokyo Tokyo",
      "content_length": 183,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 4,
      "content": "Enterprise DevOps Playbook by Bill Ott, Jimmy Pham, and Haluk Saker\n\nCopyright © 2017 Booz Allen Hamilton Inc. All rights reserved.\n\nPrinted in the United States of America.\n\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\n\nO’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles (http://www.oreilly.com/safari). For more sales department: 800-998-9938 or corporate@oreilly.com.\n\ninformation,\n\ncontact our\n\ncorporate/institutional\n\nEditors: Brian Anderson and Virginia Wilson Production Editor: Colleen Lobner Copyeditor: Octal Publishing Inc.\n\nInterior Designer: David Futato Cover Designer: Randy Comer Illustrator: Rebecca Demarest\n\nDecember 2016:\n\nFirst Edition\n\nRevision History for the First Edition 2016-12-12: First Release\n\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. Enterprise DevOps Playbook, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.\n\nWhile the publisher and the authors have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the authors disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work. Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is sub‐ ject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.\n\n978-1-491-97417-9\n\n[LSI]",
      "content_length": 1738,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 5,
      "content": "Table of Contents\n\nForeword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . v\n\nEnterprise DevOps Playbook. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Introduction 1 Play 1: Develop the Team—Culture, Principles, and Roles 6 Play 2: Study the DevOps Practices 12 Play 3: Assess Your DevOps Maturity Level and Define a\n\nRoadmap 43 Play 4: Create a DevOps Pipeline 56 Play 5: Learn and Improve through Metrics and Visibility 58 Summary 65 Recommended Reading 66\n\niii",
      "content_length": 554,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 7,
      "content": "Foreword\n\nDevOps principles and practices are increasingly influencing how we plan, organize, and execute our technology programs. One of my areas of passion is learning about how large, complex organizations are embarking on DevOps transformations.\n\nPart of that journey has been hosting the DevOps Enterprise Sum‐ mit, where leaders of these transformations share their experiences. I’ve asked leaders to tell us about their organization and the industry in which they compete, their role and where they fit in the organiza‐ tion, the business problem they set out to solve, where they chose to start and why, what they did, what their outcomes were, what they learned, and what challenges remain.\n\nOver the past three years, these experience reports have given us ever-greater confidence that there are common adoption patterns and ways to answer important questions such as: Where do I start? Who do I need to involve? What architectures, technical practices, and cultural norms do we need to integrate into our daily work to get the DevOps outcomes we want? The team at Booz Allen Hamil‐ ton has published their model of guiding teams through DevOps programs, and it is clearly based on hard-won experience with their clients. I think it will be of interest to anyone to embarking on a DevOps transformation.\n\n— Gene Kim, coauthor of The DevOps Handbook and The Phoenix Project: A Novel About IT, DevOps, and Helping Your Business Win\n\nv",
      "content_length": 1442,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 9,
      "content": "Enterprise DevOps Playbook\n\nIntroduction If Agile software development (SD) had never been invented, we’d probably have little reason to talk about DevOps. However, there is an intriguing corollary worth pondering, as well: the rise of DevOps has made Agile SD viable.\n\nAgile is a development methodology based on principles that embrace collaboration and constant feedback as the pillars of its iterative process, allowing features to be developed faster and in alignment with what businesses and users need. However, opera‐ tions today are generally moving at a pace that’s still geared toward sequential waterfall processes. As Agile SD took off, new pressures and challenges began building to address delivering new code into test, quality assurance, and production environments as quickly as possible without losing visibility and quality.\n\nWe define DevOps simply as the culture, principles, and processes that automate and streamline the end-to-end flow from code devel‐ opment to delivering the features/changes to users in production. Without DevOps, Agile SD is a powerful tool but with a prominent limitation—it fails to address software delivery. As with other soft‐ ware development processes, Agile stops when production deploy‐ ment begins, opening a wide gap between users, developers, and the operations team because the features developed for a timeboxed sprint won’t be deployed to production until the scheduled release goes out, often times many months later. DevOps enhances Agile SD by filling this critical gap, bridging operations and development as a unified team and process.\n\n1",
      "content_length": 1605,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 10,
      "content": "Agile SD is based in part on short sprints—perhaps a week in dura‐ tion—during which a section of an application or a program feature is developed. Questions arise: “How do you deliver each new version of this software quickly, reliably, securely, and seamlessly to your entire user base? How do you meet the operational requirements to iterate frequent software development and upgrades without con‐ stant disruption and overhead? How do you ensure that continuous improvement in software development translates into continuous improvement throughout the organization? How do you ensure that there is continuous delivery of programs during a sprint as they are developed?” It is from such questions that DevOps has emerged—a natural evolution of the Agile mindset applied to the needs of opera‐ tions. The goals of a DevOps implementation are to fully realize the benefits that Agile SD aims to provide in reducing risk, increasing velocity, and improving quality.\n\nBy integrating software developers, quality control, security engi‐ neers, and IT operations, DevOps provides a platform for new soft‐ ware or for fixes to be deployed into production as quickly as it is coded and tested. That’s the idea, anyway—but it is a lot easier said than done. Although DevOps addresses a fundamental need, it is not a simple solution to master. To excel at DevOps, enterprises must do the following:\n\nTransform their cultures\n\nChange the way software is designed and built following a highly modular mindset\n\nAutomate legacy processes\n\nDesign contracts to enable the integration of operations and development\n\nCollaborate, and then collaborate more\n\nHonestly assess performance\n\nContinually reinvent software delivery strategies based on les‐ sons learned and project requirements.\n\nTo achieve the type of change described is a daunting task, especially with large enterprises that have processes and legacy technologies that are ingrained as part of their business. There are numerous pat‐ terns, techniques, and strategies for DevOps offered by well-known technology companies. However, these approaches tend to be too\n\n2\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 2146,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 11,
      "content": "general and insufficient by themselves to address the many issues that arise in each DevOps implementation, which vary depending on the organization’s size, user base, resources, priorities, technology capabilities, development goals, and so on. Given these shortcom‐ ings, evident to us from our extended experience with DevOps implementations, Booz Allen has devised an approach for adopting DevOps that is comprehensive yet flexible. Think of this DevOps playbook as your user guide for implementing a practical style of DevOps that stresses teamwork and mission focus to achieve a sin‐ gle unyielding goal: deliver new value to users continually by deliver‐ ing software into production rapidly and efficiently on an ongoing basis.\n\nAs Adam Jacob, founder of Chef, described in his DevOps Kung Fu presentations (available on GitHub and YouTube), there can be dif‐ ferent styles of DevOps that are unique to each organization but fundamentally there are basic foundations, forms, and common principles that make up the elements of DevOps. This book repre‐ sents our perspective and style as we distill DevOps into seven key practice areas that can be adapted for different DevOps styles. The key takeaways are the shared principles, the common practice areas (“elements”), and the goal for each of the seven practice areas.\n\nHow to Use This Playbook This playbook is meant to serve as a guide for implementing DevOps in your organization—a practical roadmap that you can use to define your starting point, the steps, and the plan required to meet your DevOps goals. Based on Booz Allen’s experience and pat‐ terns implementing numerous DevOps initiatives, this playbook is intended to share our style of DevOps that you can use as a refer‐ ence implementation for a wide range of DevOps initiatives, no mat‐ ter their size, scope, or complexity. We have organized this playbook into five plays, as shown in Figure 1-1.\n\nIntroduction\n\n|\n\n3",
      "content_length": 1941,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 12,
      "content": "Figure 1-1. The 5 Plays of the Enterprise DevOps Playbook\n\nGene Kim, one of the top DevOps evangelists in the industry, described DevOps in 2014 as more of a philosophical movement than a set of practices. This is what makes it difficult for organiza‐ tions to embrace DevOps and determine how to begin. This report is intended for teams and organizations of all maturity levels that have been exposed to the benefits and need for DevOps. We do not dive into the economics and the ROI aspects: the goal of this report is to provide organizations with a clear guide, through the five plays that cover all the practice areas that encapsulate DevOps, to assess where you are, to determine what they mean to you and your spe‐ cific business requirements, and to get you started with an early adopter project.\n\nPlay 1: Develop the team—culture, principles, and roles\n\nSuccessful transformational change in an organization depends on the capabilities of its people and its culture. With DevOps, a collaborative effort that requires cross-functional cooperation and deep team engagement is critical. This play details the key DevOps principles and tenets and describes how the organiza‐ tional culture should be structured to achieve a top DevOps performance. You will be able to compare the structure of your organization to the principles in this play to drive the necessary culture change, especially for enterprises in which multiple functional groups (development, testing, and operations), ven‐ dors, and contractors might need to be restructured to enable\n\n4\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1589,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 13,
      "content": "the transparency and automation across the groups. Having the people, culture, and principles in place is essential to an endur‐ ing DevOps practice; the people and the culture will drive suc‐ cess and continual improvement.\n\nPlay 2: Study the DevOps practices\n\nThis play offers a deep dive into each of the seven DevOps prac‐ tices—what they are and how they should be implemented and measured. The objective is for the DevOps project team to gain a baseline understanding of the expectations for each tactical step in the DevOps practice. We include a set of workshop ques‐ tions to facilitate discussions among the DevOps team about the definition and scope of each practice as well as a checklist of key items that we believe are critical in implementing the practice’s activities.\n\nPlay 3: Assess your DevOps maturity level and define a roadmap\n\nAfter there is a common understanding within the DevOps team about each practice, this play enables you to assess your organization’s strengths and weaknesses pertaining to these practices. With that baseline knowledge, you can determine how to improve the practice areas where your organization needs improvement. As you go through this assessment and subsequent improvement efforts, you should refer back to Play 2 to review the definition of each practice area and to scan the checklist to ensure that the organization’s skills are in increasing alignment with DevOps requirements.\n\nPlay 4: Create a DevOps pipeline\n\nThe DevOps pipeline is the engine that puts your DevOps pro‐ cesses, practices, and philosophy into action. The pipeline is the end-to-end implementation of the DevOps workflow that estab‐ lishes the repeatable process for code development—from code check-in to automated testing, to required manual reviews prior to deployment. In this play, we include a DevOps pipeline refer‐ ence to illustrate DevOps workflow activities and tools.\n\nPlay 5: Learn and improve through metrics and visibility You can’t manage what you can’t measure.\n\n—Peter Drucker\n\nThe objective of this play is to define the metrics that you will use to measure the health of your DevOps efforts. Defining\n\nIntroduction\n\n|\n\n5",
      "content_length": 2167,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 14,
      "content": "metrics is critical to learn how your DevOps efforts can be improved, modified, or extended. The metrics in this play pro‐ vide a holistic viewpoint—they help you know where you are, where you’re going, and how to get there.\n\nPlay 1: Develop the Team—Culture, Principles, and Roles All DevOps success stories—those for which teams are able to han‐ dle multiple workstreams while also supporting continuous deploy‐ ment of changes to production—have one thing in common: the attitudes and culture of the organization are rooted in a series of established DevOps principles and tenets. In this report, we do not explore the specific implementation strategies, because the solutions to achieve these are very unique to your organization; thus, our typi‐ cal DevOps adoption engagements begin with an assessment pro‐ cess during which we do a dive deep to understand the organizational construct, existing processes, gaps, and challenges. We then overlay a DevOps model to see how it would look and determine the steps needed to develop the team.\n\nIn the next section, we introduce a list of key DevOps principles and cultural concepts. Each organization might have a different approach for adopting these tenets, but no matter what techniques you use, integrating the ideas themselves is critical to the success of the DevOps project. In “New DevOps Roles” on page 9, we describe the new roles and responsibilities required for a successful DevOps project.\n\nPrinciples and Culture Many organizations have ambitious goals for adopting DevOps strategies, and an underlying need to do so. Their ability to effec‐ tively serve their customers and clients depends on nimble develop‐ ment and implementation practices. When such endeavors fail, it is often because the enterprise’s culture is not suited for a DevOps pro‐ gram. Following are principles and cultural landmarks that organi‐ zations with successful DevOps implementations exhibit.\n\n6\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1969,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 15,
      "content": "Treat operations as first-class citizens\n\nWhen operation engineers are supporting a system in production, developers are working on future releases with their scope and tim‐ ing often determined by new feature requests from product owners and stakeholders. However, operational needs raised by the team during production can occur at any time, and the entire team, including developers, testers, and operations engineers, must treat such requests as priorities with equal weighting as other backlog items.\n\nDevelopers act as first responders to issues with the production system\n\nFor traditional SD, operations teams have their own engineers to address problems with applications as they occur. Even though these employees have the same basic skill sets as development team mem‐ bers, they were not the developers that wrote the code; thus, they are not familiar with how the code was built and probably unaware of the code’s idiosyncrasies. For this reason, developers and operations engineers should work as a team to troubleshoot and repair issues that arise. The actual code developer should be part of the diagnosis team, communicating with the help desk and accessing the logs to find a solution without waiting for the operations team to provide background data. This enforces more accountability on the develop‐ ment team, extending its involvement to even after the software is delivered into production—an essential DevOps principle. With this added responsibility in the latter phases of the project, the develop‐ ment team’s performance during the writing of the software improves because the group is no longer isolated from the mistakes discovered during production.\n\nShorten the time between identification of a production issue and its repair\n\nOften times, production support is reactionary. It is critical to change that mindset if the organization is to become more proactive in identifying potential needs. This could only be achieved if the developer is part of the operations support team. From a production issue perspective, there are many obstacles to communicating or integrating with the development team. Most times, the barrier is the structure of the development and sustainment contracts. For example, separate teams with separate contracts might have a delin‐ eation between their responsibilities, different Service-Level Agree‐ ments (SLAs), and varied processes. Even when separate contracts\n\nPlay 1: Develop the Team—Culture, Principles, and Roles\n\n|\n\n7",
      "content_length": 2488,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 16,
      "content": "are not a problem—that is, when there is only a single contract that covers development, operations, and sustainment—responsibilities and accountability might slow efforts to fix the production problem due to the separation of accountability and manual processes; for example, we often hear statements like, “This is a hosting problem, not an application problem; the sysadmins need to look into it,” or, “We checked everything, it’s over to the quality assurance (QA) team to validate and then the operations team to deploy.”\n\nShorten the time between code commit and code deploy\n\nThere are typically multiple gates that must be passed through before deploying software changes into production to ensure the integrity of the system. Most of these steps can be automated to reduce deployment time as well as to improve quality. However, to enable automation, the architecture of the system must be designed in a manner that is conducive to deploying discrete changes versus deploying the entire application every time.\n\nMinimize coordination to deploy releases\n\nIn traditional SD, there is a lot of inefficient coordination and com‐ munication overhead among teams. This is often necessary because each team has specific and siloed responsibilities and accountability for the project. If constant communication is not the norm, checks and balances will not occur, and quality suffers. Ironically, in a DevOps implementation, it is essential to minimize the formal com‐ munications channels between each group; instead, it is important to establish a culture of shared responsibilities, ongoing interaction, and shared knowledge of every aspect of the project and the auto‐ mated repeatable processes among all teams. Maximizing transpar‐ ency enhances efficiency and quality and reduces the need for constant forced communications.\n\nStop and fix potential defects identified by continuous flow and monitoring\n\nFrequently, defects and bugs in programs reported by users catch organizations by surprise, forcing them into a reactive mode to fix the issue. To avoid this inefficient and potentially harmful situation —which can impact organizational productivity and waste opera‐ tional resources—you should implement a DevOps culture that focuses on constant visibility into all programs and systems to mon‐\n\n8\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 2339,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 17,
      "content": "itor, identify, and resolve issues before they become so problematic that users are inconvenienced and critical workflow suffers.\n\nEnforce standardized processes to ensure predictable outcomes\n\nExceptions should not be the norm. Informal and diverse processes increase instability and the potential for unpredictable outcomes. Establishing and enforcing repeatable standardized processes is essential. Moreover, it is the cornerstone of automation, which itself is central to an efficient and unified DevOps process.\n\nBecome a learning organization through continual feedback and action\n\nEvery environment is different and all aspects of development and operations are subject to change. The goal is to constantly learn, assess, and analyze what works and what doesn’t. Organizational vis‐ ibility and a culture built on constant improvement is critical to DevOps success. Peter Senge, the founding chair of the Society for Organization Learning, explains in his book, The Fifth Discipline (Doubleday), the importance of having an environment in which “we must create a culture that rewards learning, which often comes from failure. Moreover, we must ensure that what we learn becomes embedded into our institutional memory so that future occurrences are prevented.”\n\nThe adoption of these principles and culture changes requires organizations to define new roles for development and operations teams. We describe several new roles and their associated responsi‐ bilities in a DevOps world in the next section.\n\nNew DevOps Roles Currently, there is a lack of clarity of the new roles and responsibili‐ ties required for DevOps. In this section, we identify the new DevOps roles for you to consider in augmenting your current team with the enhanced mix of talent to implement DevOps practices.\n\nIn an ideal situation, these responsibilities would exist in an autono‐ mous team that manages its own work and working practices and builds, deploys, operates, and maintains software functionality without any additional support from other parts of the organization.\n\nPlay 1: Develop the Team—Culture, Principles, and Roles\n\n|\n\n9",
      "content_length": 2123,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 18,
      "content": "The DevOps Team Antipattern We do not believe in the existence of DevOps standalone teams— DevOps responsibilities must exist within the Agile teams. Just like a software developer or tester, a DevOps engineer or an engineer with DevOps skills must take ownership of the feature on which the team is working and work to make the software better for the end user.\n\nThe DevOps architect\n\nThe DevOps architect uses automation to create efficient, effective processes and standards to continuously improve quality and esti‐ mation. The DevOps architect must have deep knowledge, hands-on experience, and a passion for making a difference in the DevOps space. The architect implements Agile practices and automation and has the technical depth necessary to provide advice for making appropriate technology choices, defending recommendations, and driving technical implementation. These technologies and methods include understanding containerization and the orchestration of containers across multiple Infrastructure as a Service (IaaS) vendors and deployment automation using IaaS providers. Roadmaps to support automation are an essential element of the architect’s role, which includes end-to-end test automation and tool strategies. An architect oversees tool analysis and selection and implements test automation frameworks and approaches.\n\nThe DevOps engineer\n\nA DevOps engineer performs in a hybrid technical role that compri‐ ses development and operations, and must be proficient in coding or scripting, process reengineering, and collaborating with multiple groups. The DevOps engineer also must be well-versed in multiple popular and commonly used operating systems and platforms. The DevOps engineer is responsible for implementing the automation vision of the DevOps architect’s development and deployment pipe‐ line. This includes the critical responsibilities for developing Infra‐ infrastructure, structure as Code repeatability, and automation of the entire infrastructure for each environment.\n\nthat enables\n\nimmutable\n\n10\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 2066,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 19,
      "content": "The test automation engineer\n\nThe test automation engineer automates as many steps as possible to achieve the test coverage and confidence required to quickly push changes to production.. The test automation engineer should be well-versed in software testing processes and tools (such as unit test‐ ing, mock integration testing, and test automation tools like Sele‐ nium) and be proficient in the scripting needed to implement automated test processes for each DevOps pipeline step. These auto‐ mations include unit tests, static code tests, smoke tests, and more specific tests, such as Section 508 compliance checks, SLA valida‐ tions, and vulnerability scans. Test automation should not be solely the responsibility of the test automation engineer; it should also be the province of every developer and tester on the team. A developer must be able to add any type of automated test that integrates with the delivery pipeline defined by the DevOps engineer. Typically, QA is performed by a separate group. The test automation engineer pro‐ vides the framework and expertise to enable developers to embed test automation as part of the continuous process.\n\nThe site reliability engineer\n\nThe site reliability engineer is responsible for monitoring the appli‐ cations and/or services post-deployment. Site reliability engineering occurs when you ask a software developer to design an operations team. Using a variety of metrics (e.g., application performance mon‐ itoring [APM], SIEM, user metrics, and infrastructure health) aligned with the deployment strategies being used (e.g., canary releases, blue/green deployment), the site reliability engineer should be exceptional at troubleshooting and at metrics analysis to establish key thresholds for alert automation to baseline the different health levels for applications and services. Simply put, the primary respon‐ sibility of site reliability engineers is to automate themselves to be as efficient as possible.\n\nThe software engineer\n\nA frequently discussed topic with DevOps is the responsibility of software engineers (also called developers). To be successful in a DevOps world, a developer must embrace all the principles dis‐ cussed previously and have a complete team mindset, where tradi‐ tional responsibilities such as testing, infrastructure, and system\n\nPlay 1: Develop the Team—Culture, Principles, and Roles\n\n|\n\n11",
      "content_length": 2385,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 20,
      "content": "administration are all part of the developer’s roles. This aligns with the mantra of “you build it, you run it, you fix it.”\n\nThe roles and responsibilities we covered are meant to provide insights and to generate healthy discussions among your organiza‐ tion with regard to how to assess resources within your team, and to identify any potential gaps. The important takeaways are the respon‐ sibilities that you need to cover versus the actual role titles because other organizations might call the roles different names such as “release engineer” or “ops lead.”\n\nPlay 2: Study the DevOps Practices As DevOps became an industry buzzword, the term lost some of its meaning. It’s obvious that DevOps is a collaboration between the development, testing, and operations teams, but where it fits within an organization and how teams adopt DevOps vary from enterprise to enterprise. For example, some say DevOps is primarily a by- product of culture; others say it is primarily a technological applica‐ tion. No matter through what lens you view DevOps, it is essential that the teams have a clear and common understanding of the fol‐ lowing seven core DevOps practices:\n\nPractice 1: Configuration management\n\nPractice 2: Continuous integration\n\nPractice 3: Automated testing\n\nPractice 4: Infrastructure as Code\n\nPractice 5: Continuous delivery\n\nPractice 6: Continuous deployment\n\nPractice 7: Continuous monitoring.\n\nThese practices encompass the full end-to-end cycle, from code commit to deployment to operations and maintenance.\n\n12\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1561,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 21,
      "content": "How to Read the Practices In the subsections that follow, we dive into each practice area by providing the following components:\n\nDefinition\n\nA common introductory reference point for how the practice can best be described and what it entails.\n\nWorkshop guiding questions\n\nThe basis for a dialogue and discussion with your team about the parameters and scope of your project. The intent of the guiding questions is for a thought exercise to help gauge where things are, what needs to be considered, and what’s actually important for your team.\n\nChecklist\n\nA number of items that may become tasks in your project backlog to implement or serve to improve your DevOps maturity.\n\nPractice 1: Configuration Management\n\nConfiguration management definition\n\nConfiguration management (CM) is a broad term, widely used as a synonym for version or source code control, but can also be used in the context of managing, deployment artifacts, or configurations of software/hardware. In our context here, we are talking about CM strictly from code management perspective. In the DevOps land‐ scape, CM focuses on having a clear and clean code repository man‐ agement strategy that helps maximize automation and standardize deployments.\n\nDevelopers often are frustrated by not being able to replicate a prob‐ lem that appears in different environments. You may hear develop‐ ers say, “It works in my environment. I cannot reproduce the glitch.” This is mainly because CM of the application throughout the pro‐ cess of development and deployment is controlled manually and there are definite differences between a program’s behavior in a deployed environment and on a developer’s computer. This results in configuration drift or “snowflake” environments, in which man‐\n\nPlay 2: Study the DevOps Practices\n\n|\n\n13",
      "content_length": 1795,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 22,
      "content": "agement of the various environments and code repositories become a heavy lift and a nightmare to manage. Although a software team might carefully document the evolving versions of the configuration of a server or a container, the need to manually execute the docu‐ mented process might still result in human errors because the server will be used in the development, code testing, user acceptance test‐ ing, and production environments.\n\nYou can achieve effective and less problematic version and source code control by using various automated CM workflows. The fol‐ lowing list of workflows is a compilation of common industry prac‐ tices that ranges from basic to advanced. In this playbook we use GitHub for CM implementations, but other source code control sys‐ tems, such as GitLab or Bit Bucket, are good alternatives, and you can follow similar workflow strategies for them as well.\n\nCentralized workflow\n\nIn a centralized workflow (Figure 1-2), a central repository serves as the single point of entry for all changes to the project. The develop‐ ment branch is called the “master” and all changes are made to this branch. A centralized workflow does not require any other branches. Developers have the complete copy of the central reposi‐ tory locally; they write their changes on their own equipment; and then synchronize with the master at agreed upon intervals. If there is a conflict among developers initiating changes, Git (for example) will stop the commit and force a manual merge. This workflow is usually used by teams to transition out of traditional source code control using Apache Subversion (SVN).\n\nFigure 1-2. Centralized flow\n\nFeature workflow\n\nFeature workflow (Figure 1-3) is for teams that are comfortable with centralized workflow. Isolated branches are added for each new fea‐ ture, which enables independent and loosely coupled design princi‐ ples without affecting other parts of the system. The main difference between feature workflow and centralized workflow is that in fea‐ ture workflow, feature development takes place in a dedicated\n\n14\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 2107,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 23,
      "content": "branch instead of in the master. This enables various groups of developers to work on features without routinely disturbing the master codebase. Feature workflow also provides a foundation for continuous delivery and continuous deployment DevOps practices. For a microservices architecture, which treats each microservice as a separate product, feature workflow branches are an ideal configura‐ tion management mechanism because the code for each feature is isolated.\n\nFigure 1-3. Feature branch workflow\n\nGitflow workflow\n\nGitflow workflow is for established and advanced projects. It includes the attributes of centralized and feature workflows and also other capabilities. Based on Vincent Driessen’s Git Branching model, Gitflow workflow is a good foundation for many of the seven DevOps practices.\n\nGitflow workflow (Figure 1-4) is composed of a strict branching model designed around project releases and enhancements. Specific roles are assigned to each of five branches: Master, Hotfix, Release, Development, and Feature. The way the branches interact with one another as well as the availability of multiple branches coming off an individual branch, is carefully defined. For example, while new development is occurring in one feature branch, another feature branch can be created for changed requirements or to fix a defect for an update that will be deployed with a patch release.\n\nTable 1-1 explains each of the Gitflow branches.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n15",
      "content_length": 1484,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 24,
      "content": "Table 1-1. Gitflow branches\n\nBranch Master branch\n\nHotfix branch\n\nRelease branch\n\nDevelopment branch\n\nFeature branches\n\nDescription Stores the official release history; the code is merged to it only when a new release is deployed. All historical releases are tagged in the master branch. Supports maintenance or patch fixes that must be released quickly into production. This is the only branch that forks off of the master directly. After the fix is completed, the changes are merged back into the master, development, and/or release branches, as appropriate. Acts as the safeguard between the development branch and the public releases (master branch). Serves as the integration branch for features. Continuous integration deployments to development servers are performed from this branch. Developers code on a local copy of the development branch. When they are finished, the code is merged to the development branch. 100 percent code review Agile practice is used to check the code against the team’s development practices. Represent each feature just like the feature branch workflow. Instead of branching off from the master, feature branches use the development branch as the originator. When the feature is complete, it is merged back to the development branch for integration into the project. As the features are built, the developer local code and feature branch interaction could be automated using continuous integration. When that option is chosen, the feature branch is a separate module until the feature is complete.\n\nFigure 1-4. Gitflow workflow\n\n16\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1598,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 25,
      "content": "CM workshop guiding questions\n\nHow do you manage source code versions?\n\nDo you have a production system that you are maintaining and improving or are you building a new system?\n\nHow many features are being built at the same time?\n\nWhat happens when you receive a defect from the operations team? How do you fix the defect and manage the source code change?\n\nWho is the owner of the source code control system—develop‐ ment team, maintenance team, operations team?\n\nWhat are the criteria you use to decide on your source code branching strategy?\n\nAre you building a monolithic system or a microservices-based distributed system?\n\nHow many code repositories do you have (or expect to have) for the project?\n\nAre you planning continuous delivery or continuous deploy‐ ment?\n\nCM checklist\n\nDocument your configuration management approach in a sim‐ ple, easy-to-read document accessible to the entire team.\n\nSelect a source code control system that allows all types of branching techniques even though you might not use advanced flow in the beginning.\n\nSelect your configuration workflow based on operations need and continuous delivery objectives. The most effective flow for delivering under all scenarios is Gitflow.\n\nDocument your branching strategy in a way that makes it easy for the entire team to understand.\n\nDefine the limitations of your configuration management and source code branching strategy.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n17",
      "content_length": 1447,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 26,
      "content": "Practice 2: Continuous Integration\n\nContinuous integration definition\n\nContinuous integration (CI) requires developers to integrate code into a centralized repository as they finish coding and successfully pass unit testing, several times per day. The end goal is to create small workable chunks of code that are validated and integrated back into the code repository as frequently as possible. CI is the foundation for both continuous delivery and continuous deploy‐ ment DevOps practices. There are two CI objectives:\n\nMinimize integration efforts throughout the development and deployment process\n\nHave the capability to deliver functions to the end-user commu‐ nity at any point in the development process (see “Practice 3: Automated Testing” on page 20)\n\nCI is also a key Agile SD practice that connects Agile development with DevOps. CI is certainly not a new concept; it has been around for a while, and without a well-established CI practice, a develop‐ ment team cannot expect to achieve DevOps success.\n\nTo facilitate advanced DevOps practices, such as continuous deliv‐ ery and continuous deployment, CI must be planned and imple‐ mented well. When a developer divides functionality into smaller chunks, it is critical to ensure that the software not only works and is integrated into the main code repository, but can be safely deployed to production if there is a business reason to do so before the rest of the application’s features are complete. CI forces the developer to think differently during planning; that is, she must view functionality in small, discrete bites that can be integrated into the rest of the code base as finished pieces of larger programs.\n\nBefore CI became a best practice, integration was a major and often difficult ordeal. Developers would code in their local environments and, when ready, collaborate to integrate their code into the larger project. More often than not, the working code had to be rewritten for successful handshakes among the disparate sections of code to occur.\n\nWith DevOps, the goal is to achieve continuous releases. When pro‐ gram enhancements or features are complete, they should be\n\n18\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 2186,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 27,
      "content": "deployed or deployable; CI enables this unique aspect of DevOps. However, CI alone is not sufficient for the deployment of “done” code to production; full confidence from both comprehensive test coverage and immutable infrastructure is needed. In essence, CI is a prerequisite to achieving continuous deployment and works in con‐ junction with the other DevOps practices to build and ensure confi‐ dence throughout the process, which ultimately creates the level of trust required to automate deployments directly to production.\n\nCI workshop guiding questions\n\nHow ready are you for CI? Do you have your CI tool and exper‐ tise in automating builds?\n\nHow long does it take to build your code?\n\nWhat is your unit test coverage percentage? Are you confident that if a developer breaks another developer’s code, the unit tests will detect it?\n\nHow many Agile teams do you have on your project? If you have multiple teams, what is the definition of CI to you?\n\nCI checklist\n\nSelect a CI tool that is capable of achieving your automation objectives.\n\nConnect the CI tool to your code repository. Test check the code.\n\nIntegrate your build script to CI.\n\nManually trigger the build from your CI server.\n\nTest the build scheduler.\n\nDefine the build branch for each environment from your branch structure. The following steps are for Gitflow:\n\n1. Set up build for Dev environment from development branch\n\n2. Schedule Dev build for every check-in (core activity of CI begins with this build; ends if all automated tests pass)\n\n3. Set up build for test environment from the development branch\n\nPlay 2: Study the DevOps Practices\n\n|\n\n19",
      "content_length": 1625,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 28,
      "content": "4. Set up build for preproduction (or QA) from the release ranch\n\n5. Set up build for production from the release branch\n\n6. Set up auto commit to the master branch after production deployment.\n\nDefine automated tests for each commit to the development branch.\n\n— Perform unit tests (frontend, backend, API)\n\n— Perform vulnerability scan (use ZAP for the development\n\nbranch)\n\n— Perform code quality scan\n\nDefine alerting solution for developer commits.\n\nDefine criteria to accept or reject commits.\n\nDefine commit reject mechanisms when committed code is not acceptable (e.g., if there are vulnerability findings, or if a unit test fails). Do not ignore any test fail. Stop and fix.\n\nDefine automated tests for each commit to the release branch.\n\n— All tests run for development branch commits\n\n— Performance tests\n\n— Other security scans\n\n— Functional tests (e.g., Selenium tests and browser compati‐\n\nbility tests)\n\nPractice 3: Automated Testing\n\nAutomated testing definition\n\nAutomation is the very heart of DevOps. The more tests you can automate, the more likely that the quality of the program and the efficiency of the deployment will be production-ready. DevOps teams use the results of automated testing to determine their next steps. The end goal here is to shift testing and compliance to the left of the delivery process as much as possible, in essence ensuring that tests are conducted early and often in the development process. During CI, automated testing can identify defects early on so they can be addressed. During continuous delivery, automated testing\n\n20\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1609,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 29,
      "content": "can increase the team’s confidence level that it can deploy a new capability into production.\n\nIn DevOps, automated testing should be used during CI (on devel‐ opment), Infrastructure as Code (on development), continuous delivery (on test and QA), continuous deployment (on QA, accept‐ ance, and production), and continuous monitoring (on develop‐ ment, test, QA, and production).\n\nRecommended automated DevOps tests, by environment, are shown in Figure 1-5. We use a modified version of the Chef delivery pipeline terminology for each of the steps.\n\nFigure 1-5. Recommended automated tests\n\nLet’s take a quick look into each of the environments and the auto‐ mated testing activities for each one.\n\nLocal environment\n\nThis is local developers’ environment, whether it is their own machine or a VM. If any tests fail locally, the developer stops and fixes the issue.\n\nLint and static analysis test\n\nIdentifies potential bad source code (e.g., nonconforming code, bad practices, compilation errors, security flaws) by examining the code itself without executing the program. Although static code analysis is useful, it generates both false positives and false negatives. Ideally, all of the outcomes of static code analysis should be reviewed. The frequency of static code analysis can be\n\nPlay 2: Study the DevOps Practices\n\n|\n\n21",
      "content_length": 1330,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 30,
      "content": "determined by the team’s DevOps maturity on other automated tests.\n\nUnit test\n\nThe first line of defense in assuring quality, a unit test should be developed for both frontend and backend code. One hundred percent unit test coverage is necessary to have the confidence in the source code that is required for continuous deployment. Unit tests should be:\n\nSmall in scope\n\nDeveloped by the programmer based on acceptance criteria\n\nAble to run quickly so that developers use them routinely for every change\n\nMock integration test\n\nValidate the expected result of APIs, which are a facet of any modular architecture, such as microservices or component- based design. For simple parts of an application, API tests could be the same as unit tests. The intent is to simulate and provide test integration points through mock outputs.\n\nConsumer test\n\nValidate integration points with external services that are being used to ensure correctness on both sides.\n\nCI environment\n\nAfter local testing is passed and code review is completed and approved, CI environment testing begins with another quick round of checks with unit and mock integration testing.\n\nUnit test\n\nThe first line of defense in assuring quality, it should be devel‐ oped for both frontend and backend code. One hundred per‐ cent test coverage is necessary to have the confidence in the source code that is required for continuous deployment. Unit tests should be the following:\n\nSmall in scope\n\nDeveloped by the programmer\n\n22\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1515,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 31,
      "content": "Able to run quickly so that developers use them routinely for every change.\n\nMock integration test\n\nIntegration testing is critical and is repeated in this environ‐ ment. We want to ensure and validate the expected result of the APIs.\n\nDevelopment environment\n\nAfter successful CI environment testing, we proceed to the develop‐ ment environment, in which a series of tests are run to ensure readi‐ ness for the test environment. If any of the tests are failed, the developer stops and fixes the issue.\n\nUnit test\n\nRerun the unit tests for all the components.\n\nMock integration (service and consumer) test Tests all the service integration points.\n\nUI test\n\nRuns over larger parts of the application and simulates user actions. All of the capabilities and features of a user interface (UI) must be tested by automated functional testing. Selenium is a common tool for this. The drawback of functional tests is that they are slow, which explains why they are not usually used in the development environment. The rule of thumb is this: no build should propagate to the QA environment before there is a functional test for all UI capabilities and before all of the func‐ tional tests run successfully.\n\n508 manual test\n\nFor applications that require Section 508 compliance, this is an important step. Section 508 testing is mostly manual, but tools such as CodeSniffer can check pages and detect conformance to the W3C’s Web Content Accessibility Guidelines (WCAG) 2.0 and Section 508 guidelines.\n\nTest environment\n\nUpon successful development testing and business approval (for sit‐ uations in which a manual business decision is required), the test environment follows. This is the environment that unites all the dif‐\n\nPlay 2: Study the DevOps Practices\n\n|\n\n23",
      "content_length": 1760,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 32,
      "content": "ferent development streams and ensures comprehensive testing across all major areas.\n\nUnit test\n\nRerun the unit tests for all the components for all the develop‐ ment streams.\n\nIntegration test\n\nValidates the integration points (internal and external) and tests the expected inputs and outputs.\n\nEnd-to-end test\n\nRun tests across functional and nonfunctional areas (e.g., infra‐ structure, build scripts, and configurations).\n\nFunctional test\n\nRuns over larger parts of the application and simulates user actions. All of the capabilities and features of a UI must be tested by automated functional testing.\n\nBuild script test\n\nBecause DevOps automation relies on high-quality build scripts, build script testing is used to ensure that there are no errors during the build process and that the scripts are consistent across each environment.\n\nProperties file/configuration parameter test\n\nAll software development projects have configuration parameters that must be tested for target boundary condi‐ tions.\n\nInfrastructure code test\n\nSimilar to applications code, infrastructure code must be tested for every change. This is a critical for ensuring immutability and repeatability. We discuss this in detail in the next practice section (“Practice 4: Infrastructure as Code” on page 29).\n\nSecurity test\n\nEnsures the security posture of your applications and environ‐ ments by mitigating potential issues through automated detec‐ tion. In reality, not all items will be revealed, but security and compliance tests provide a strong baseline and confidence to move forward:\n\n24\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1603,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 33,
      "content": "Vulnerability test (or penetration test)\n\nNew code must pass a vulnerability scanner to validate that no critical application-level vulnerabilities are present. About 95 percent of reported software breaches in 2015 were the result of 1 out of 10 well-known vulnerabilities; 8 of them have been in the crosshairs of the software develop‐ ment sector for more than 10 years. Zed Attack Proxy (ZAP) is a common vulnerability test tool.\n\nFunctional security test\n\nVerifies security features, such as authorization, authentica‐ tion, field-level validation, and personally identifiable infor‐ mation (PII) compliance.\n\nSecurity scanning test\n\nTargets applications, containers, networks, firewalls, and operating systems for vulnerabilities.\n\nCompliance test\n\nMany systems are required to be compliant with specific sets of standards. The goal of compliance testing is to use tools like OpenSCAP and Chef Compliance to automate the process that will continuously validate the posture of your system as changes take place versus the tedious exercise of addressing these changes after a release candidate is established.\n\nResiliency test\n\nApplies a series of random simulations to assess the availability of your system in outage events. For example, using Netflix’s Simian Army (Chaos Monkey and Chaos Gorilla), resiliency is tested by taking down random AWS instances to an entire Amazon Web Services (AWS) availability zone to test the fault- tolerant architecture of your system.\n\nPerformance test\n\nMeasures the performance and scalability of an application. After the team defines SLAs for web page and API performance, these tests will alert the team if the applications/APIs are not performing as required. Some of these tests (e.g., soak tests) are used only for specific situations rather than running continu‐ ously for every change.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n25",
      "content_length": 1879,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 34,
      "content": "Load test\n\nAnalyzes the impact of load on an application. For example, if a performance issue is identified and subsequently addressed, only a load test can determine if the problem has been resolved.\n\nComponent load test\n\nApplies a load test to a single component (or microservice).\n\nSoak test\n\nIdentifies memory leaks. Some severe memory leak prob‐ lems do not surface during load testing. To uncover these issues, you must run soak tests over extended periods of time (at least overnight) with steady high loads.\n\nCapacity test\n\nDetermines how many simultaneous users a web applica‐ tion can handle before response time becomes an issue (or before the system performs below its SLA).\n\nStress test\n\nPushes a web application beyond normal workload to iden‐ tify which components or services will fail under extreme conditions and spikes in production.\n\nPreproduction environment\n\nThis environment serves as a test ground to simulate delivery to production. In live implementations, the tests here vary from orga‐ nization to organization, depending on how confident and comfort‐ able you are up to this point.\n\nSmoke test\n\nRun a comprehensive set of functional tests under low load to ensure major features of the applications work as expected.\n\nResiliency test\n\nPerform random simulations that are essential to test the availa‐ bility of the system in outage events and continuously validate the fault-tolerant architecture of the system.\n\nPerformance test\n\nAssess the expected performance of the new deployment. In “Practice 7: Continuous Monitoring” on page 40, we discuss the\n\n26\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1615,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 35,
      "content": "metrics and monitoring for expected performance levels and the health of the system.\n\nProduction environment\n\nAt this point, the tests and validation processes needed for produc‐ tion deployment are completed. In this section, we list tests that are recommended for the production environment. In “Practice 5: Con‐ tinuous Delivery” on page 32, we explore effective production deployment strategies, such as canary releases and blue/green deployment.\n\nPost-production test\n\nRun a series of tests on the application as well as infrastructure to ensure that the system is in a healthy state (should include subset of functional UI tests, configuration tests, and others) after deployment. The extent of the post-production tests depends on the size and maturity of the environment.\n\nResiliency test\n\nConduct random simulations that are essential to test the availa‐ bility of the system in outage events and continuously validate the fault-tolerant architecture of the system.\n\nPerformance test\n\nAssess the expected performance of the new deployment. In “Practice 7: Continuous Monitoring” on page 40, we discuss the metrics and monitoring for expected performance levels and the health of the system.\n\nSynthetic test\n\nSet up these tests to simulate real-world usage patterns by mim‐ icking the locations, devices, and patterns of users. Some appli‐ cation performance monitoring solutions, such as New Relic, offer synthetic testing programs as well. The intent is to proac‐ tively discover issues users are encountering and gain insight for troubleshooting.\n\nAlthough this is a comprehensive list of automated tests, manual tests are also an important part of system delivery. Some functional‐ ity may require manual validation. Types of manual tests include exploratory testing, user acceptance testing, Section 508 accessibility testing, and usability testing.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n27",
      "content_length": 1905,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 36,
      "content": "Automated testing workshop guiding questions\n\nWhich tests are currently automated and which do you plan to automate?\n\nWhat percentage of your code base is automated?\n\nHow long does it take to run the automated test harness? If you have different harnesses for unit tests and functional tests, how long do they take to run separately, and how often do you run them?\n\nWhat test automation tools and frameworks do you use?\n\nWhat is the process for a developer to add a new unit test?\n\nHow many concurrent users are expected to use your system?\n\nDo you have browser page load requirements?\n\nHow do you test load, performance, and stress?\n\nWhat do you do when performance degrades? What is your scaling strategy?\n\nDo you have system availability requirements?\n\nAutomated testing checklist\n\nSet high unit-test coverage and add this coverage as a require‐ ment for developers to complete before a project can be final‐ ized.\n\nSelect unit test technologies for UI, middle-tier, and backend.\n\nImplement unit-test reference implementations and add them to developer practices.\n\nBuild mechanisms to measure the test coverage for unit tests.\n\nIntegrate your unit tests into test harnesses. Build mechanisms for integrating the unit tests into the harness.\n\nIntegrate the unit-test harness into the build script and CI.\n\nBuild mechanisms to take action when unit tests fail.\n\nAfter unit-test coverage is finished, identify which integration tests should be implemented. Integration tests should cover end-to-end paths in user stories.\n\nImplement and automate integration tests.\n\n28\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1599,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 37,
      "content": "Select technology for acceptance tests or end-to-end functional tests. Selenium is a possible option.\n\nOrder your functionality, from most critical to least critical, and build end-to-end automated functional tests starting with the most critical ones. (There will be fewer end-to-end tests than unit tests. The quality of the functional tests is more important than the quantity.)\n\nDefine actions when a functional test fails. Build an alerting tool so that the developer is notified.\n\nAfter you achieve the maturity you are targeting with unit tests, integration tests, and end-to-end functional tests, prioritize other types of tests defined in this section and integrate them into the aforementioned environments. Begin with the security tests.\n\nPractice 4: Infrastructure as Code\n\nInfrastructure as Code definition\n\nIt can be argued that the recent maturity and adoption of tools and technology enabling Infrastructure as Code (IaC) are among the pri‐ mary reasons DevOps has exploded onto the scene with true end- to-end automation. IaC goes beyond simply automating processes using scripts, as traditional systems administrators have been doing for years. Instead, IaC enables configuration and provisioning of infrastructure through applications using APIs. With IaC, configu‐ rations are treated just like application code with all the best soft‐ ware development practices of version control, unit tests, code review, gating, and so on. The barriers and walls between system administration and operations staff and developers are removed, with full transparency, automation, and shared responsibilities. IaC addresses configuration drifts by ensuring immutability of both the actual server configurations/instantiation and also standardizing how environments are built and deployed.\n\nThe ability to view IaC opens the possibility to control and automate configurations so that they are highly repeatable and consistent, no matter how many times the environment is torn down and brought back up. Not surprisingly, best practices for IaC are similar to those for software development, including the following:\n\nPlay 2: Study the DevOps Practices\n\n|\n\n29",
      "content_length": 2160,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 38,
      "content": "Source control\n\nCode version control and auditing\n\nPeer reviews\n\nCode review practices as application code processes\n\nTesting\n\nUnit testing, functional testing, and integration testing\n\nCode as documentation\n\nCode is developed in an easily readable manner as the IaC itself serves as living, always-up-to-date documentation\n\nCollaboration\n\nThe barrier between development and operations is broken down\n\nThere are two primary approaches for implementing IaC. It is important to assess the pros and cons of each and determine which model fits best with your team and environment:\n\nDeclarative model\n\nSimilar to the concept of declarative programming, code is writ‐ ten to describe what the code should do as opposed to how the code should do it. Puppet, for example, is declarative because it doesn’t run scripts or execute code on the infrastructure. You can use Puppet’s declarative language to model and describe the desired target server end state. You tell Puppet what you want the server to look like, not the steps to take to get there. The typical advantage here is a cleaner and more structured approach, as you are just modeling and describing what is needed. The downside is less flexibility in what you can control.\n\nImperative model\n\nCode is written that explicitly lays out the specific steps that must be executed to complete the desired task or, in this case, the desired target server end state. Instead of modeling the end state, you use the imperative approach to describe how to get to the end state. In this model the advantage is full control of what steps and actions you execute and the conditions around them. However, the code/scripts can get complicated. For example, Chef is imperative—users define commands and their execution order and logic. These instructions, called Chef Recipes, in turn can be organized in Cookbooks. To illustrate this, part of a\n\n30\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1915,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 39,
      "content": "recipe can be to check if a specific dependency is available on a target node. If the dependency exists, Chef will install it; other‐ wise, a warning is raised and/or other failed execution steps are run.\n\nNo matter which solution you decide on, having IaC in place will reduce and in most cases eliminate configuration drift/snowflake environments. In making your decision, you should consider the skillset of your team and how well it lines up with the various options, such as Chef, Ansible, or Puppet.\n\nIaC workshop guiding questions\n\nDoes your datacenter or IaaS provider have scripted provision‐ ing capability?\n\nCan you script the installation of every product in your system?\n\nWhat are the differences for installing components of your sys‐ tem when they are deployed on these distinct environments: developer computers, development, test, QA, and production?\n\nDo you perform version control on the configuration control parameters of your components? If yes, how?\n\nWho on your team knows the details of these configuration parameters?\n\nHave you heard this all-too-common complaint?: “I cannot reproduce this error in my environment.”\n\nIaC checklist\n\nSet the objectives of your infrastructure automation and plan your automation in an Agile way. You do not need to wait to complete everything before you use it. Start using the IaC as pieces are completed.\n\nDefine what you can automate and what you cannot. For exam‐ ple, most application servers can be automated, but network devices such as firewalls can be configured automatically if they have APIs to do that.\n\nWrite the code to automate the configuration of the container in which your main application is going to run.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n31",
      "content_length": 1727,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 40,
      "content": "Integrate the IaC for your app servers/containers to CI. Ideally, re-create the servers and containers when there is a patch instead of just applying the patch. After you do this, you will have achieved an immutable infrastructure for your application servers.\n\nUse the same IaC you build for your app servers on your devel‐ opers’ computers and in your development, testing, quality, and production environments. There should not be any difference other than the IP, URL, and so on.\n\nWrite the code for building your database server and container and follow the same steps you used for the applications server.\n\nPractice 5: Continuous Delivery\n\nContinuous delivery definition\n\nContinuous delivery simply means that every change is ready to be deployed to production as soon as automated testing validates it. Figure 1-6 illustrates a reference pipeline flow (also discussed in “Practice 3: Automated Testing” on page 20). Note there are two manual checkpoints in this example. One is for a technical decision to approve the code before initiating activities in the CI environ‐ ment. The second is a business decision to accept the changes and continue with the automated steps to production deployment.\n\nThe goal of continuous delivery is to deliver incremental or small changes quickly and continually as they go through the pipeline. This not only helps distribute microfeatures more rapidly, but also reduces the risk of a large release failing. It is important to note that not all microfeatures that go to production will be seen by users. These features or fixes might be part of the production version, but potentially “turned off” for a period of time because you want to have specific changes validated as part of a build, even though the organization is not necessarily ready to install them on end-user sys‐ tems.\n\nDevOps is a reaction to features and releases being deployed slowly. Even using Agile SD principles, the mindset is to build programs incrementally and produce releasable software at the end of every sprint. In each sprint, the team develops features/changes for the software, but the completed story must wait for the other stories to\n\n32\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 2197,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 41,
      "content": "be finished and grouped together to be deployed in a scheduled release. In contrast, continuous delivery gives power to the product owner, who is the gatekeeper in DevOps terms, to decide whether to deploy the new capabilities before the rest of the release is ready.\n\nFigure 1-6. Reference pipeline—continuous delivery\n\nContinuous delivery usually requires a change in organizational cul‐ ture. Team and customer expectations must shift from full-fledged deployment when all aspects of the project are finished and tested to incremental and iterative application distribution. Simply put, you can view the objectives of continuous delivery as follows:\n\nNew features, configuration changes, bug fixes, and experiments are sent into production safely and quickly in a sustainable way.\n\nForget about having to spend nights and weekends in the data‐ center to deploy releases; design the architecture to deploy pro‐ grams whenever the time is appropriate for the DevOps team and the user community.\n\nTo achieve these objectives, DevOps teams must develop maturity and capabilities in the four DevOps practices described previously, or continuous delivery is not viable. The four critical practices and the required capabilities are as follows:\n\nCM\n\n— Builds should be scripted. Developers should use the same\n\ndeployment scripts that are used for production.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n33",
      "content_length": 1398,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 42,
      "content": "— Environments should be automated and scripted. There should be no differences between the developer and produc‐ tion environments.\n\n— It should not be a lengthy task to bring a new developer onto\n\nthe team.\n\nCI\n\n— Automated builds are triggered for every check-in.\n\n— Developers check into the trunk (of the source code reposi‐\n\ntory) at least once per day.\n\n— When the build goes red (i.e., when an automated test fails), the team should fix it quickly, ideally within 10 minutes.\n\nAutomated testing\n\n— Unit tests for all public interfaces are in place to provide some level of confidence before exploratory testing (which is based on manual testing) and acceptance.\n\n— Acceptance tests are automated. The gatekeeper agrees that the capability is ready to push to production deployment.\n\nIaC\n\n— The instantiation and teardown of the infrastructure for every environment us managed, automated, and executed through scripts and code using tools such as Chef, Puppet, Ansible, and others.\n\n— The infrastructure is immutable and there are no differences between the developer, implementation, and user environ‐ ments.\n\nThese four DevOps practices cover the following two rules of con‐ tinuous delivery:\n\nThe software (trunk) should always be deployable\n\nTrunk software should be healthy at all times and ready to be deployed to production. It’s up to the gatekeeper to decide whether to deploy it once per day or multiple times per day— this is a business decision, not a technical decision.\n\n34\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1525,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 43,
      "content": "Everyone checks into the trunk from feature branches at least once per day\n\nThis forces developers to divide user stories and features into meaningful, smaller pieces. Every check-in is performed to determine if the team’s “definition of done” has been achieved.\n\nIn deploying to production, there are several advanced strategies that you can adopt to achieve zero downtime and flexibility:\n\nCanary releases\n\nBy definition, continuous delivery deploys many builds to pro‐ duction. In “Practice 3: Automated Testing” on page 20, we dis‐ cuss the importance of having a sophisticated set of automated tests that provide a high level of confidence in the quality of the code. Canary is a technique that is used to further increase con‐ fidence levels before deploying new code to production. In a canary deployment, the new code is delivered only to a percent‐ age of the existing infrastructure. For example, if the system is running on 10 load-balanced virtual servers, you can define a canary cluster of one or two servers. This way, if the deployment is not successful due to an escaped defect, it can be caught before the build is deployed to all of the servers. Canary releases are also used for pilot features to determine performance and acceptance prior to a full rollout.\n\nBlue/green deployment\n\nThis is a zero-downtime deployment technique that involves a gradual release to ensure uninterrupted service. The blue/green approach is effective in virtualized environments, especially if IaaS is used. Although a blue/green deployment is a deep topic that deserves an entire chapter on its own, simply put, it includes maintaining two identical development environments —Blue and Green. One is a live environment for production traffic, whereas the other is used to deploy the new release. In our example, let’s say that Green is the current live production environment and Blue is the idle identical production environ‐ ment. After the code is deployed and tested in the Blue environ‐ ment, we can begin directing traffic of incoming requests from Green (current production) to Blue. You can do this gradually until the traffic redirect is 100 percent to the Blue environment. If unexpected issues occur during this gradual release, we can roll back. When it is completed, the Green environment\n\nPlay 2: Study the DevOps Practices\n\n|\n\n35",
      "content_length": 2343,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 44,
      "content": "becomes idle and the Blue environment is now the live produc‐ tion environment.\n\nGetting to this point in continuous delivery is an incredible mile‐ stone, and means that your organization has enough confidence and automation from your implementations CI, CM, automated testing, and IaC that you are able to deploy any point into production.\n\nContinuous delivery workshop guiding questions\n\nDo you have CI in place?\n\nWhat is your confidence level in the coverage and quality of your automated testing?\n\nDo you have IaC for infrastructure? Have you heard developers complaining that they are unable to reproduce an error identi‐ fied by quality assurance?\n\nWhat is the “definition of done” for your code?\n\nDo you have 100 percent code review for each commit?\n\nDo you run code quality scans for committed code?\n\nHow does the product owner approve your definition of done?\n\nDoes your contract let you deploy to production, or is there another contractor in the middle?\n\nDo you run automated tests (continuously) in production for feedback?\n\nDo you have practices to revert the build?\n\nContinuous delivery checklist\n\nBefore attempting continuous delivery, assess your maturity level for the prerequisite practices described in this section. If you do not have sufficient maturity in these practices, make sure to first improve those practices.\n\nBuild your continuous delivery pipeline. Do not reinvent the wheel. Instead, use products such as Jenkins, Chef Delivery, and Spinnaker.\n\nIntegrate your test automation and CI server to the continuous delivery pipeline.\n\n36\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1595,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 45,
      "content": "Decide whether to use canary or blue/green deployments. If you do, build the mechanisms and determine how the deployed build will be monitored.\n\nThere are two manual checkpoints for continuous delivery: code approval and delivery approval. Document these two approval points and communicate them: — Code approval\n\n— Define who will perform this approval. Usually, it is the\n\ntechnical lead.\n\n— Define the developer’s tasks to achieve the “definition of\n\ndone” and submit the code for approval.\n\n— Define the reviewer’s tasks and standardize these across\n\nAgile teams.\n\n— Configure the delivery pipeline to deploy builds to the proper target environments (development, testing, qual‐ ity assurance, or production).\n\n— Construct or configure the trigger that the person responsible for code approval will use to initiate the build automation for the delivery pipeline.\n\n— Build mechanisms to alert the team if any of the automa‐ ted tests fail. This mechanism must stop the pipeline when something is found to have gone wrong.\n\n— Delivery approval\n\n— Define who is accountable for this approval, which is the last step before deploying the code to production assum‐ ing all of the planned automated tests run successfully. Because the code is a candidate to be deployed to pro‐ duction, the product owner should be involved.\n\nBuild advanced deployment techniques (e.g., blue/green deploy‐ ment, canary release, and or A/B tests) to improve the success of continuous delivery.\n\nCreate mechanisms to monitor production and the success of the build.\n\nCreate mechanisms to revert the build in case of a failure.\n\nPlay 2: Study the DevOps Practices\n\n|\n\n37",
      "content_length": 1648,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 46,
      "content": "Practice 6: Continuous Deployment\n\nContinuous deployment definition\n\nUnlike continuous delivery, which means that every change is deployable but might be held back because of business considera‐ tions or other manual steps, continuous deployment strives to auto‐ mate production deployment end to end. With this practice, confidence in the automated tests is extremely high, and as long as the code has passed all the tests, it will be deployed.\n\nFigure 1-7 shows our reference pipeline. We maintain a manual checkpoint for implementation of a business decision about deploy‐ ment prior to continuing the process to production. You can remove this step for full end-to-end automation of continuous and constant deployment of production changes. In a fully automated scenario, it is vital that you have high maturity levels in each of the DevOps practices and full visibility into the health of the systems at all times. If unexpected issues arise, it is critical to have the metrics, insight, and process to either quickly revert to a known stable state or to fix the issue immediately with a new build.\n\nFigure 1-7. Reference pipeline—continuous deployment\n\n38\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1192,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 47,
      "content": "Continuous deployment is the ultimate goal for modern efficient organizations. However, this DevOps practice does not imply that all applications are deployed without any manual interaction. Here are some factors to examine when considering continuous deployment:\n\nAutomated test coverage\n\nAutomated test types, including unit, functional, accessibility, security, compliance, different types of performance, and acceptance tests\n\nRobust multilayer code review during developer commit for every change\n\nValidation of functionality by the product owner during devel‐ oper commit\n\nAdvance deployment mechanisms,\n\nincluding blue/green deployments, canary testing, post-production testing, and revert scripts.\n\nIn deciding which services can be deployed automatically and which need manual validation, most organizations use a hybrid mecha‐ nism early on before becoming fully confident as to whether the fea‐ ture is something that can be fully automated to production. For example, a change in a business rule that requires extensive scenario testing by a subject matter expert (SME) might be better suited for continuous delivery because it would require the SME (and the product owner) to give a thumbs up after going over all possible sce‐ narios. This is especially true in the government world in which there are policies in place that require individuals to give their approval prior to moving on to production.\n\nContinuous deployment workshop guiding questions\n\nDo you have continuous delivery in place? How successful are you with it?\n\nWhat are the driving factors to move to continuous deploy‐ ment?\n\nHow comfortable is your client with continuous deployment?\n\nHow will you ensure that the functionality you deploy still con‐ forms to the product owner’s preferences when you eliminate the manual delivery approval step?\n\nPlay 2: Study the DevOps Practices\n\n|\n\n39",
      "content_length": 1870,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 48,
      "content": "Assess whether you can use continuous delivery and continuous deployment together. What is ideal to be part of continuous deployment for your team? (This could be all components or perhaps just APIs and backend capabilities.)\n\nContinuous deployment checklist\n\nEnsure that you are successful with continuous delivery before pursuing continuous deployment.\n\nIntegrate delivery approval with code approval—that is, make the business decision about the deployment when you assess the readiness of the code right before CI.\n\nBuild mature centralized logging and continuous monitoring practices to ensure that you’re aware of the impact of every deployment.\n\nAdopt canary deployment mechanisms.\n\nEmbrace blue/green deployment mechanisms. For continuous deployment, the blue/green approach is a necessity. No matter how good your automated tests are, it is still possible to miss defects. Blue/green techniques help to minimize the chances of releasing defects to all users.\n\nIntegrate all of the chosen deployment techniques with your delivery pipeline. Some continuous delivery pipelines (e.g., Spinnaker) have advanced deployment techniques out of the box.\n\nPractice 7: Continuous Monitoring\n\nContinuous monitoring definition\n\nContinuous monitoring is the practice that connects operations back to development, providing visibility and relevant data through‐ out the development lifecycle including production monitoring. In traditional IT operations, an operations team composed of system administrators, various help desks, and analysts performs opera‐ tions. But with continuous monitoring, modern DevOps operations teams also include the developers who originally built the system and then are responsible for site reliability, overseeing the software, and acting as first responders for production problems. Simply put,\n\n40\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1855,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 49,
      "content": "continuous monitoring aims to reduce the time between identifica‐ tion of a problem and deployment of the fix.\n\nThis practice should not be an afterthought. Monitoring begins with Sprint 1 and should be integrated into the development work. As the system is built, monitoring solutions are also designed. In this play‐ book, we focus on four different types of continuous monitoring:\n\nInfrastructure monitoring\n\nVisualize infrastructure events coming from all computing resources, storage and network, and measure the usage and health of infrastructure resources. AWS CloudWatch and CloudTrail are examples of infrastructure monitoring tools.\n\nApplication performance monitoring (APM)\n\nTarget bottlenecks in the application’s framework. Appdynamics and New Relic are industry-leading APM tools.\n\nLog management monitoring\n\nCollect performance logs in a standardized way and use analyt‐ ics to identify application and system problems. Splunk and ELK are two leading products in this area.\n\nSecurity monitoring\n\nReduce security and compliance risk through automation. Secu‐ rity configuration management, vulnerability management, and intelligence to detect attacks and breaches before they do seri‐ ous damage are achieved through continuous monitoring. For example, Netflix’s Security Monkey is a tool that checks the security configuration of your cloud implementation on AWS.\n\nWe can divide continuous monitoring into three major steps. First, the obvious one—monitoring. Second, an alert system to warn the team about a problem. The alert system should be capable of auto‐ matically elevating the alert if the team members who initially received notice of the issue take no action. The third step of contin‐ uous monitoring is actions to take when an alert occurs. No matter what the nature of the alert, all should be captured and reviewed. For example, there can be false negatives, but they should not be ignored. Instead, false negatives should be reported as such to the continuous monitoring tool so that if the same set of circumstances occurs again, the monitoring equipment will not trigger an alert. Similarly, if an alert is issued, but the software appears to be operat‐ ing satisfactorily, it should not be neglected. Rather, it should be\n\nPlay 2: Study the DevOps Practices\n\n|\n\n41",
      "content_length": 2298,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 50,
      "content": "investigated and the outcome of the investigation must become a part of the record that the monitoring tool can use in determining the severity of future similar incidents.\n\nContinuous monitoring workshop guiding questions\n\nHow and why is early detection of defects important to your project?\n\nWhat performance SLAs do you have and when do you plan to start achieving them?\n\nWhat is the system availability requirement and what is the plan to achieve it?\n\nWhen do you do performance testing as part of your continu‐ ous integration and automated testing practices? How do you know that the tests represent actual production conditions?\n\nWhat is the labor cost of your operations? How many systems engineers, system administrators, and database administrators do you have monitoring the production environments, and how do they react when there is an issue?\n\nHow many errors are there in your application? How do you trace the errors back in your code?\n\nHow do you forecast infrastructure utilization when your code changes?\n\nContinuous monitoring checklist\n\nImplement APM, log analytics, and security monitoring solu‐ tions for your system.\n\nDesign and start using these implementations as the system is built, not after it is deployed.\n\nDesign and implement alerting solutions composed of alert gen‐ eration, mitigation actions, verification, baseline calculations, and alarm setup. Build alerts for each try/catch in your code as the code is designed.\n\nKnow your monitoring coverage and identify what it should be.\n\nStart monitoring performance during CI. Define page-level SLAs, build automated performance tests for these SLAs, and define triggers.\n\n42\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1687,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 51,
      "content": "Define baselines during development to be able to identify later anomalies.\n\nAfter defining baselines, define quantitative forecasts for critical processes. For example, login page SLA is two seconds. Based on 95 percent of responses, the system can achieve a 2-second response time for up to 1,000 concurrent users.\n\nCollect data from servers. After aggregating and storing the data, present the data in graph format, prepared for time series analysis.\n\nAutomatically create issues when the monitoring solution cap‐ tures a problem and triggers an alert. Automatically group the created issues.\n\nAllocate developer resources to filter false positives and nega‐ tives.\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap DevOps is not a set of prescriptive procedures, but it is critical that organizations assess the maturity of their adherence to DevOps practices by measuring them against a standard model. Without this, it would be impossible to identify gaps or potential areas for improvement that could interfere with a successful DevOps imple‐ mentation.\n\nTo make this assessment, we created a Maturity Questionnaire that provides a series of questions related to each of the seven DevOps practices. Each answer has a point value. When you complete the questionnaire, add up the total points and use Table 1-2 to deter‐ mine your project’s DevOps maturity level.\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\n|\n\n43",
      "content_length": 1453,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 52,
      "content": "Table 1-2. The DevOps Maturity Questionnaire\n\nMaturity Level Base Beginner Intermediate Advanced\n\nExtreme\n\nAgile practices might be in use, but DevOps practices are limited Foundational use of DevOps practices Stabilized use of DevOps practices Continuous improvement in place Team has the competence and confidence to use DevOps practices Cultural barriers have been overcome No cultural barriers Role model DevOps implementation\n\nPoints 0–32 33–98 99–164 165–230\n\n231\n\nBooz Allen’s Maturity Questionnaire should be the first step toward achieving a more mature DevOps capability because it highlights the current state and provides a roadmap that indicates where to focus on increasing your organizational maturity. Some DevOps practices are more difficult to introduce than others and will require substan‐ tial changes in the fundamental management of software develop‐ ment. Over time, as an organization grows in DevOps maturity, improvements will bring tangible increases in both efficiency and quality of software development and implementation.\n\nTables 1-3 through 1-9 highlight our maturity assessment.\n\n44\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1147,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 53,
      "content": "t n e m e g a n a m n o i t a r u g fi n o C\n\n.\n\n3 - 1 e l b a T\n\nE R O C S R U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nl e v e L\n\ny t i r u t a M\n\ne r o c s\n\nr u o Y\n\ns r e n i a t n o c d n a\n\ns d\n\nl i\n\nu B +\n\ne d o c\n\ne c r u o s\n\nt s e T +\n\nn o i t a r u g fi n o c\n\n,\n\nn o i t a r u g fi n o C +\n\ne d o c n o i t a c i l\n\np p a\n\nr o f\n\nM C S\n\nM C S o N\n\ne d o c e c r u o S\n\ne d o c\n\ne r u t c u r t s a r f n\n\ni\n\nd n a\n\n, s t p i r c s\n\n)\n\nM C S (\n\nt n e m e g a n a m\n\ne s u\n\ne r o c s\n\nr u o Y\n\n7\n\nw o fl k r o w w o fl t i G\n\ng n h c n a r b d e r u t c u r t s (\n\ni\n\nr o f\n\ns t n u o c c a\n\nt a h t\n\ny c i l\n\no p\n\nd n a\n\n, s e x fi t o h\n\n, s e r u t a e f\n\n) s e s a e l e r\n\n7\n\n5\n\nw o fl k r o w h c n a r b e r u t a e F\n\nh c a e\n\nr o f h c n a r b d e t a c i d e d (\n\na g n i s u s u s r e v\n\ne r u t a e f\n\n) n o i t a c o\n\nl\n\ne l g n i s d e z i l a r t n e c\n\n5\n\nl l a\n\nr o f\n\n3\n\nw o fl k r o w d e z i l a r t n e C\n\ny r t n e\n\nf o t n o p e l g n i s (\n\ni\n\n) s e g n a h c\n\n3\n\n1\n\ns e i r o t i s o p e r\n\ne l p i t l u M\n\n) e d o c\n\ne c r u o s\n\nf o s e i p o c (\n\ng n h c n a r b f o d a e t s n\n\ni\n\nd e s u\n\n1\n\n0\n\ng n h c n a r b o N\n\ni\n\ny g e t a r t s\n\n0\n\ns t n i o P\n\ne d o c - e c r u o S\n\ng n h c n a r b\n\ni\n\ns t n i o P\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\n|\n\n45",
      "content_length": 1367,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 54,
      "content": "n o i t a r g e t n i\n\ns u o u n i t n o C\n\n.\n\n4 - 1 e l b a T\n\n46\n\nR U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nl e v e L\n\ny t i r u t a M\n\n|\n\nE R O C S\n\nr u o Y\n\ne r o c s\n\nd n a\n\ns t p i r c s d\n\nl i\n\nu b d e t a m o t u A\n\nD N A t s i x e\n\ns s e c o r p t s e t\n\nt r o h s\n\nk c e h c h c a e r o f\n\ns n u r\n\nr e p o l e v e d\n\nn\n\n7\n\n) l a c o l (\n\nt n e m n o r i v n e\n\nr e p o l e v e D\n\nt s e t\n\ne l b a h s e r f e r o t\n\ns s e c c a\n\ns a h\n\n, s t p i r c s d\n\nl i\n\nu b n o i t a c i l\n\np p a\n\n, a t a d\n\nt n e m n o r i v n e d e z i d r a d n a t s\n\n) e s a b a t a d d n a p p a (\n\n5\n\nt s e t d e t a m o t u a\n\ne v i s n e h e r p m o C\n\ns t s i x e\n\ns s e n r a h\n\n3\n\nk c e h c r e p o l e v e d r a l u g e R\n\nh c n a r b t n e m p o l e v e d o t n\n\ni\n\n1\n\nI C\n\nr o f\n\ny d a e r\n\nt o N\n\n0\n\ns e t i s i u q e r e r p I C\n\ns t n i o P\n\nEnterprise DevOps Playbook\n\nr u o Y\n\ne g n a h c d e t a m o t u a h t i\n\nw\n\nl\n\no o t\n\nI C\n\nd e t a m o t u a h t i\n\nw\n\nl\n\no o t\n\nI C\n\nd e l u d e h c s h t i\n\nw\n\nl\n\no o t\n\nI C\n\nd\n\nl i\n\nu b\n\nl a u n a m h t i\n\nw\n\nl\n\no o t\n\nI C\n\no o t\n\nI C o N\n\ne s u\n\nl o o t\n\nI C\n\ne r o c s\n\nd e t a m o t u a d n a n o i t c e t e d\n\nd n a n o i t c e t e d e g n a h c\n\ns d\n\nl i\n\nu b d e t a m o t u a\n\ns l o r t n o c\n\ns e h c n a r b\n\nl l a m o r f\n\nt n e m y o p e d\n\nl\n\nm o r f\n\nt n e m y o p e d d e t a m o t u a\n\nl\n\ne h t\n\ne v a h t o n s e o d\n\nl\n\no o t (\n\n, e r u t a e f\n\n, t n e m p o l e v e d (\n\no t Y L N O h c n a r b t n e m p o l e v e d\n\ne c r u o s n\n\ni\n\ne g n a h c\n\nf o e g d e l w o n k\n\ns t n e m n o r i v n e\n\nl l a o t\n\n) e s a e l e r\n\nt n e m n o r i v n e\n\nt n e m p o l e v e d\n\n) h c n a r b e d o c\n\n) A Q\n\n, t s e t\n\n, v e D (\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nr u o Y\n\ns t s e t\n\ne c n a m r o f r e P +\n\ns t s e t\n\ny t i r u c e S +\n\ne h t\n\nf o s r e y a l\n\nl l a\n\nr o f\n\nt s e t\n\nt i n U +\n\nl l a o t n o i t a m o t u a d\n\nl i\n\nu B +\n\nd\n\nl i\n\nu b y l n O\n\nn o i t a m o t u A\n\ne r o c s\n\nn o i t a c i l\n\np p a\n\n, t s e t (\n\ns t n e m n o r i v n e\n\ne h t\n\nf o\n\no t n o i t a m o t u a\n\nI C y b d e l l o r t n o c\n\n) s r e h t o d n a\n\n,\n\nA Q\n\nt n e m p o l e v e d\n\nl o o t\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P",
      "content_length": 2217,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 55,
      "content": "R U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nl e v e L\n\ny t i r u t a M\n\nE R O C S\n\nr u o Y\n\nt s e l l a m\n\ns (\n\ns d o h t e m\n\ns a\n\ne t a r g e t n\n\nI\n\ng n n n u r\n\ni\n\nr e t f a\n\ny l i a d e t a r g e t n\n\nI\n\nt s e l l a m\n\ns (\n\ns d o h t e m\n\ns a\n\ne t a r g e t n\n\nI\n\nt i n u o n (\n\ny l i a d e t a r g e t n\n\nI\n\n,\n\nn i - k c e h c o N\n\nf o n o i t a r g e t n I\n\ne r o c s\n\ne t e l p m o c\n\ne r a\n\n) e d o c\n\ne l b a t u c e x e\n\n; s s a p s t s e t\n\nt i n u f i\n\n, s t s e t\n\nt i n u\n\nl l a\n\ne t e l p m o c\n\ne r a\n\n) e d o c\n\ne l b a t u c e x e\n\n) t i\n\nm m o c\n\ne r o f e b s n u r\n\nt s e t\n\ne h t\n\nl i t n u e t a r g e t n\n\ni\n\ne d o c\n\nr e p o l e v e d\n\nf i\n\n, s t s e t\n\nt i n u\n\nl l a g n n n u r\n\ni\n\nr e t f a\n\nP O T S\n\n, e s i w r e h t o\n\ne r o f e b s n u r\n\nt s e t\n\nt i n u o n (\n\ny t i l i\n\nb a p a c\n\ne l o h w\n\n, e s i w r e h t o ; s s a p s t s e t\n\nt i n u\n\n) t i\n\nm m o c\n\nr o e l u d o m\n\n, .\n\ng . e (\n\nr u o Y\n\ne r o c s\n\nP O T S\n\n7\n\nd\n\nl i\n\nu b e h t p o t s\n\ny l l a c i t a m o t u A\n\nd e t a m o t u a\n\nl l a\n\nl i t n u s s e c o r p\n\no n e r a\n\ne r e h t d n a\n\ns s a p s t s e t\n\ns r o r r e d\n\nl i\n\nu b\n\n7\n\n5\n\ne v a h\n\n,\n\nn o i t c a n a\n\ns i\n\ne r e h t n e h W\n\no t\n\ne c a l p n\n\ni\n\ns\n\nm\n\ns i n a h c e m\n\na o t\n\ne t a c i n u m m o c\n\nm a e t\n\nf o t e s\n\ne l b a r u g fi n o c\n\n, t c e f e d a\n\nr o f\n\n, .\n\ng . e (\n\ns r e b m e m\n\nl a c i n h c e t d n a\n\nr e p o l e v e d y f i t o n\n\n) d a e l\n\n5\n\n3\n\nk a e r b t o n s e o d d\n\nl i\n\nu b n e h W\n\nt s e t\n\nt i n u t u b\n\nn i - k c e h c h t i\n\nw\n\n, s l i a f\n\ne h t o t\n\nk c a b T R E V E R = N O I T C A\n\nn a c\n\ns r e p o l e v e d r e h t o t u b\n\n, e l fi\n\ne d o c\n\nr i e h t\n\nk c e h c o t\n\ne u n i t n o c\n\n3\n\n1\n\no t\n\ne u d s k a e r b d\n\nl i\n\nu b e h t\n\nf I\n\n= N O I T C A\n\nn i - k c e h c\n\na\n\nP O T S\n\ns s e c o r p d\n\nl i\n\nu b p o t s\n\n) a (\n\nk c e h c r e h t o t n e v e r p ) b (\n\ne d o c n e k o r b e h t o t\n\ns n\n\ni\n\n1\n\ne t e l p m o c\n\ns i\n\n) e r u t a e f\n\n0\n\nn e k a t\n\ns i\n\nN O I T C A o N\n\nI C\n\nf o s t l u s e r\n\nr o f\n\ns e i t i v i t c a\n\n0\n\ns t n i o P\n\n/ s t r e l A\n\nd n a s n o i t a c fi i t o n\n\nI C g n i r u d s n o i t c a\n\ns t n i o P\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\n|\n\n47",
      "content_length": 2273,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 56,
      "content": "g n i t s e t d e t a m o t u A\n\n.\n\n5 - 1 e l b a T\n\n48\n\nE R O C S R U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nr o t a c i d n I\n\ny t i r u t a M\n\n|\n\ne r o c s\n\ne r o c s\n\nr u o Y\n\nr u o Y\n\ne h t\n\ns t s e T\n\ne c n a m r o f r e P +\n\n7\n\nt s e t d e t a m o t u a\n\ny n a n e h W\n\ne g a i r t o t\n\ns p o t s\n\nm a e t\n\n, s l i a f\n\nm e l b o r p\n\ns t s e T\n\ny t i r u c e S +\n\n5\n\ny b d e w e i v e r\n\ne r a\n\ns\n\nm e l b o r P\n\ns n o i t c a d n a m a e t\n\nt n e m p o l e v e d\n\ns n a l p t n i r p s\n\ne h t o t n\n\ni\n\nd e n n a l p\n\no i r a n e c S\n\nl a n o i t c n u F +\n\ns t s e T\n\n3\n\nh c a e\n\nr o f n e k a t\n\ne r a\n\ns n o i t c A\n\nt n i r p s\n\ns t s e t\n\nt i n U\n\n1\n\nd e t n e m u c o d e r a\n\ns n o i t c A\n\no t p u t f e l\n\ns i\n\nt i\n\nd n a\n\ne h t\n\nx fi o t\n\ns r e p o l e v e d\n\ns t s e t d e t a m o t u a o N\n\nn e k a t n o i t c a o N\n\n0\n\ng n i t s e t d e t a m o t u A\n\ns t n i o P\n\nr o f\n\ns n o i t c A\n\nt s e t d e t a m o t u a\n\ns t l u s e r\n\nEnterprise DevOps Playbook\n\ns\n\nm e l b o r p\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\ne r o c s\n\nr u o Y\n\ne g a r e v o c\n\ne d o C\n\nr o f\n\nt n e m p o l e v e d n e v i r d - t s e T\n\ny t i l i\n\nb a t s e t\n\nr o f n g i s e D\n\ns t s e t\n\ne l p m\n\ni s w e F\n\ns t s e t\n\nt i n u o N\n\ns t s e t\n\nt i n U\n\ns I P A d n a\n\ns I U h t o b\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\ne r o c s\n\nr u o Y\n\n% 5 7 > e g a r e v o C\n\n% 5 7 < o t\n\n% 0 5 > e g a r e v o C\n\n% 0 5 < o t\n\n% 5 2 > e g a r e v o C\n\n% 5 2 < e g a r e v o C\n\nt s e t\n\nt i n u o N\n\ne g a r e v o c\n\nt s e t\n\nt i n U\n\nd e s u\n\no o t\n\ne g a r e v o c\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\ne r o c s\n\nr u o Y\n\nr o f\n\ns s e n r a h e h t\n\ns n u r\n\nl\n\no o t\n\nI C\n\nr o f\n\ns s e n r a h e h t\n\ns n u r\n\nl\n\no o t\n\nI C\n\ne r i t n e\n\ne h t n u r\n\ns r e p o l e v e D\n\nn w o r i e h t n u r\n\ns r e p o l e v e D\n\nt s e t\n\nt i n u o N\n\ny c n e u q e r f\n\nt s e t\n\nt i n U\n\ny r e v e n o d\n\nl i\n\nu b y r e v e\n\nd n a\n\nt n e m n o r i v n e\n\nt n e m p o l e v e d\n\nt i\n\nm m o c\n\nt a\n\ns s e n r a h\n\nn o h s a f\n\ni\n\nc o h d a n\n\ni\n\ns t s e t\n\nt n e m n o r i v n e\n\nd\n\nl i\n\nu b e r i t n e\n\ne h t\n\nr o f\n\ns d\n\nl i\n\nu b\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P",
      "content_length": 2158,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 57,
      "content": "E R O C S R U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nr o t a c i d n I\n\ny t i r u t a M\n\ne r o c s\n\nr u o Y\n\n% 5 7 > e g a r e v o c\n\ny r o t s\n\nr e s U\n\no t\n\n% 0 5 > e g a r e v o c\n\ny r o t s\n\nr e s U\n\n% 5 2 > e g a r e v o c\n\ny r o t s\n\nr e s U\n\n% 5 2 < e g a r e v o c\n\ny r o t s\n\nr e s U\n\nd e t a m o t u a o N\n\no i r a n e c S\n\n% 5 7 <\n\n% 0 5 < o t\n\nt s e t o i r a n e c s\n\nr o l a n o i t c n u f (\n\nt s e t\n\n) y r o t s\n\ne g a r e v o c\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\ne r o c s\n\ne r o c s\n\ne r o c s\n\ne r o c s\n\ne r o c s\n\nr u o Y\n\nr u o Y\n\nr u o Y\n\nr u o Y\n\nr u o Y\n\nt n e m e r u s a e m e c n a m r o f r e P\n\nn o i t c u d o r p n\n\ni\n\ns t s e t d n a\n\n7\n\ny l s u o u n i t n o C\n\n7\n\nt s e t (\n\nt s e t\n\ns s e r t S +\n\n) s t i\n\nm\n\ni l\n\ns ’ n o i t a c i l\n\np p a\n\n7\n\ng n i t s e t n o i t a r t e n e P +\n\n7\n\ny b\n\n, e l fi n i - d e k c e h c\n\ny r e v e\n\nr o F\n\ns A L S h t i\n\nw\n\nt s e t\n\ne c n a m r o f r e P\n\nd a o\n\nl\n\ne g a p\n\n,\n\nA L S n o i t c a s n a r t (\n\n) A L S\n\n5\n\nt n i r p s\n\ny r e v e\n\nr o F\n\n5\n\nt h g m n o i t a c i l\n\ni\n\np p a (\n\nt s e t\n\nk a o S +\n\ne m\n\ni t\n\nf o d o i r e p a\n\nr o f\n\nl l e w k r o w\n\n) l i a f n e h t d n a\n\n,\n\nd a o\n\nr e d n u\n\n5\n\ns i s y l a n a\n\ne d o c\n\nc i t a t S +\n\n5\n\ne h t\n\ny b\n\n, t n i r p s\n\ny r e v e\n\nr o F\n\nw e i v e r\n\ne h t\n\nt s e t\n\ne c n a m r o f r e P\n\ng n h t y r e v e\n\ni\n\n3\n\ne s a e l e r\n\ny r e v e\n\nr o F\n\n3\n\nt s e t d a o L +\n\n3\n\ne d o c d e t a m o t u A +\n\n3\n\ny b e s a e l e r\n\ny r e v e\n\nr o F\n\nd e t c e l e s\n\nt s e t\n\nt s e t\n\ng n n n a c s\n\ni\n\nr e h t o n a\n\ne c n a m r o f r e P\n\ny t i l a n o i t c n u f\n\n) s t s e t\n\ne k o m\n\ns (\n\n1\n\nc o h d A\n\n1\n\ne c n a m r o f r e P\n\n1\n\ny t i l i\n\nb a r e n u V\n\nl\n\n1\n\ny b d e m r o f r e P\n\nt s e t\n\nt s e t\n\ne c n a m r o f r e p o N\n\n0\n\ne c n a m r o f r e p o N\n\n0\n\ne c n a m r o f r e p o N\n\ns t s e t\n\n0\n\ns t s e t\n\ny t i r u c e s o N\n\n0\n\ny t i l i\n\nb a r e n u v o N\n\nl\n\ns t s e t e c n a m r o f r e P\n\ns t n i o P\n\nt s e t e c n a m r o f r e P\n\ny c n e u q e r f\n\ns t n i o P\n\nt s e t e c n a m r o f r e P\n\ns e p y t\n\ns t n i o P\n\ns e p y t\n\nt s e t y t i r u c e S\n\ns t n i o P\n\ny t i l i b a r e n u V\n\nl\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\nl\n\no o t\n\nI C\n\ne h t\n\nm a e t\n\nt n e m p o l e v e d\n\nm a e t\n\nt n e m p o l e v e d\n\ns i\n\ne s a e l e r\n\ne h t\n\nr e t f a m a e t\n\ng n n n a c s\n\ni\n\ny c n e u q e r f g n n n a c s\n\ni\n\ny d a e r\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\n|\n\n49",
      "content_length": 2488,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 58,
      "content": "E R O C S R U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nr o t a c i d n I\n\ny t i r u t a M\n\n50\n\ne r o c s\n\nr u o Y\n\ny b\n\n, e l fi n\n\nd e k c e h c\n\ny r e v e\n\nr o F\n\ne h t\n\ny b\n\n, t n i r p s\n\ny r e v e\n\nr o F\n\ne h t\n\ny b e s a e l e r\n\ny r e v e\n\nr o F\n\nl a c i n h c e t\n\ny b d e m r o f r e P\n\ne d o c d e t a m o t u a o N\n\ne d o c d e t a m o t u A\n\n|\n\ne r o c s\n\nr u o Y\n\nl\n\no o t\n\nI C\n\ne h t\n\n7\n\nr e p o l e v e d e h t\n\ns e t a i t i n\n\ni\n\nI C\n\nr o f\n\nt n e m y o p e d y r e v e\n\nl\n\nt a\n\ne d o c\n\nt c e j o r p e h t d n a\n\ne s a b e d o c\n\ne h t\n\ny c n e u q e r f d e n fi e d r o f\n\nl\n\no o t\n\nm a e t\n\nt n e m p o l e v e d\n\n5\n\ns r e p o l e v e d\n\no o t\n\ne h t\n\ns e t a i t i n\n\nI C\n\nt n e m y o p e d e d o c\n\nl\n\ny r e v e\n\nt a\n\ne s u\n\nm a e t\n\nt n e m p o l e v e d\n\n3\n\nc i t a t s\n\ne s u s r e p o l e v e D\n\nr o f\n\ne l b a t i u s (\n\nl\n\no o t\n\ns i s y l a n a\n\nr o f\n\n) k c a t s\n\nl a c i n h c e t\n\ne h t\n\nt i\n\nm m o c\n\ne l fi h c a e\n\ne d o c\n\nm o d n a r\n\nt a d a e l\n\ns w e i v e r\n\n1\n\ns i s y l a n a\n\nc i t a t s\n\ny t u d - y v a e H\n\n) n a c S p p A M B\n\nI\n\n, .\n\ng . e (\n\nl\n\no o t\n\nl e v e l\n\nt c e j o r p t a d e s u\n\ng n n n a c s\n\ni\n\ny t i l a u q\n\n0\n\ns i s y l a n a\n\nc i t a t s o N\n\nd e s u\n\nl\n\no o t\n\nw e i v e r y t i l a u q\n\ny c n e u q e r f\n\ns t n i o P\n\ns i s y l a n a c i t a t S\n\nEnterprise DevOps Playbook\n\n) e s a e l e r\n\n, t n i r p s\n\ny r e v e\n\n, .\n\ng . e (\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\ne r o c s\n\nr u o Y\n\ny b\n\n, e l fi n\n\nd e k c e h c\n\ny r e v e\n\nr o F\n\nr o f\n\nm a e t\n\nr e h t o n a\n\ny b d e m r o f r e P\n\nr e h t o n a\n\ny b d e m r o f r e P\n\nr e h t o n a\n\ny b d e m r o f r e P\n\nn o i t a r t e n e p o N\n\nn o i t a r t e n e P\n\nl\n\no o t\n\nI C\n\ne h t\n\nt n i r p s\n\ny r e v e\n\ne s a e l e r\n\ny r e v e\n\nr o f\n\nm a e t\n\na\n\nf o e m\n\ni t\n\ne h t\n\nt a m a e t\n\ng n n n a c s\n\ni\n\ny c n e u q e r F g n i t s e T\n\nn o i t a t i d e r c c a\n\ny t i r u c e s\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P",
      "content_length": 1977,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 59,
      "content": "C a I\n\n.\n\n6 - 1 e l b a T\n\nR U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\nr o t a c i d n I\n\ny t i r u t a M\n\nE R O C S\n\ne r o c s\n\nr u o Y\n\nd e n o i s i v o r p s i\n\ne r u t c u r t s a r f n\n\ng n n o i s i v o r p e r u t c u r t s a r f n\n\ni\n\nI\n\nd n a m e d n o ;\n\nd e s u s i\n\nS a a I\n\np u t e s\n\nr e t n e c\n\na t a D\n\nd e t a m o t u a o N\n\nd e t a m o t u A\n\ne s u e h t\n\ns a\n\ny l l a c i\n\nm a n y d\n\nt o n t u b\n\n, s I P A y b d e t a m o t u a\n\ns e c r u o s e r\n\ne r u t c u r t s a r f n\n\ni\n\ns r e v r e s\n\nl a c i s y h p\n\ne r u t c u r t s a r f n\n\ni\n\ne r u t c u r t s a r f n\n\ni\n\ne r o c s\n\nr u o Y\n\ns e s a e r c e d d n a\n\ns e s a e r c n\n\n7\n\ns e c i v r e s o r c i\n\nm d e z i r e n i a t n o C\n\nf o e l a c s o t u a d e t a r g e t n\n\nd n a\n\ng n i y l r e d n u d n a\n\ns r e n i a t n o c\n\ne r u t c u r t s a r f n\n\n7\n\ny t i l i\n\nb a l a c s n o i t a c i l\n\np p a o t d e i t\n\n5\n\ns e c i v r e s o r c i\n\nm d e z i r e n i a t n o C\n\nf o e l a c s o t u a d n a\n\ng n i t s i x e n o s e c i v r e s o r c i\n\nm\n\ne r u t c u r t s a r f n\n\ni\n\ne s u - o t – y d a e r\n\n5\n\ny l l a u n a m n e h w n o i t a e r c\n\nd e t s e u q e r\n\n3\n\nd n a\n\ns e l u d o m d e z i r e n i a t n o C\n\nf o g n n o i s i v o r p t n e d n e p e d n\n\ni\n\ni\n\ns e l u d o m d e z i r e n i a t n o c\n\ne h t\n\n3\n\nd e t a c o\n\nl l a d n a\n\n,\n\nd e z i l a u t r i v\n\ny l l a u n a m\n\ns n o i t a c i l\n\np p a o t\n\n1\n\nc i h t i l\n\no n o m d e z i r e n i a t n o C\n\nt n e m y o p e d n o i t a c i l\n\nl\n\np p a\n\n1\n\ng n n o i s i v o r p\n\ni\n\n0\n\nn o i t a z i r e n i a t n o c o N\n\n0\n\ng n n o i s i v o r p\n\ni\n\ns t n i o P\n\ne s u n o i t a z i r e n i a t n o C\n\ns t n i o P\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\n|\n\n51",
      "content_length": 1779,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 60,
      "content": "y r e v i l e d s u o u n i t n o C\n\n.\n\n7 - 1 e l b a T\n\n52\n\nR U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\ny t i r u t a M\n\n|\n\nE R O C S\n\nr u o Y\n\ne r o c s\n\ns t s e t\n\ne h t h t i\n\nn o s e i l e r\n\nr e n w o t c u d o r P\n\ne c n a t p e c c a d e t a m o t u a\n\nw e v i l\n\no g o t\n\ny l e t e l p m o c\n\nd\n\nl i\n\nu b\n\n7\n\ne h t\n\ns e s u r e n w o t c u d o r P\n\nl a u n a m\n\ns\n\nm r o f r e p t u b\n\n, s t l u s e r\n\ne v i l - o g e r o f e b\n\nl l e w s a\n\ns t s e t\n\nn o i s i c e d\n\n5\n\nh t i\n\nw e g a r e v o c\n\n% 0 0 1\n\ns t s e t\n\ne c n a t p e c c a d e t a m o t u a\n\nf o n o i t i n fi e d “\n\ne h t\n\ns a d e s u\n\nt n e m p o l e v e d e h t\n\nr o f\n\n” e n o d\n\nm a e t\n\n3\n\nt s e t o i r a n e c s d e t a m o t u A\n\ne h t o t d e d i v o r p s t l u s e r\n\nt o n o d s t l u s e r\n\ne h t\n\nt u b\n\n, t n e i l c\n\ne s u a c e b e c n a t p e c c a\n\nt c a p m\n\ni\n\n% 0 0 1 t o n s i\n\ne g a r e v o c\n\ne h t\n\n1\n\nd e t a m o t u a o N\n\ne t i u s\n\nt s e t\n\ne c n a t p e c c a\n\nn a m u h s i\n\ne r e h T\n\ne t a g d n a n o i t c a r e t n\n\ns w e i v e r\n\n0\n\nr o t a c i d n I\n\nd e t a m o t u A\n\ne c n a t p e c c a\n\ns t s e t\n\ns t n i o P\n\nEnterprise DevOps Playbook\n\nr u o Y\n\nT A U d n a A Q o t d e r e v i l e d s d\n\nl i\n\nu B\n\nT A U d n a A Q o t\n\ns d\n\nl i\n\nu B\n\nd e r e v i l e d d n a d e t s e t\n\ns d\n\nl i\n\nu B\n\ne n o d e c n a t p e c c a\n\nr o f g n i t s e T\n\nt o n s e o d t c a r t n o C\n\nt c a r t n o C\n\ne r o c s\n\ny n a\n\nt u o h t i\n\nw s t n e m n o r i v n e\n\nh g u o r h t\n\ns s a p s t n e m n o r i v n e\n\nt s e t d n a\n\nt n e m p o l e v e d o t\n\nr o (\n\nr o t c a r t n o c\n\nr e h t o n a\n\ny b\n\nf o s t l u s e r\n\nw o\n\nl l a\n\ns t n i a r t s n o c\n\n, a t a d\n\n, . e . i ( n o i t n e v r e t n\n\ni\n\nl a u n a m\n\ne t a g g n i t s e t\n\nl a u n a m\n\nt u o h t i\n\nw s t n e m n o r i v n e\n\n) y t r a p\n\ne b o t\n\ns t s e t d e t a m o t u a\n\n) g n i k r o w t e n\n\nn o i t a r u g fi n o c\n\ny l l\n\nu f ( n o i t n e v r e t n\n\nl a u n a m\n\ns i\n\nr o t c a r t n o c\n\nt n e m p o l e v e D\n\ny r e v i l e d r o f d e s u\n\n) d e t a m o t u a\n\ns i h t\n\nr o f\n\ne l b i s n o p s e r\n\nt o n\n\ne c n a t p e c c a\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nr u o Y\n\nt n e m y o p e d d e t a m o t u a\n\nl\n\ny l l\n\nu F\n\ns i\n\ne n\n\ni l e p p t n e m y o p e D\n\ni\n\nl\n\ns w o\n\nl l a\n\ne n\n\ni l e p p t n e m y o p e D\n\ni\n\nl\n\ns w o\n\nl l a\n\ne n\n\ni l e p p t n e m y o p e D\n\ni\n\nl\n\nd e t a m o t u a o N\n\nt n e m y o l p e D\n\ne r o c s\n\ns t s i x e\n\ne n\n\ni l e p p\n\ni\n\nl l\n\nu f\n\ne l b a n e o t\n\ne l b a r u g fi n o c\n\nA Q o t\n\nt n e m y o p e d d n a\n\nl\n\nI C\n\ns e i t i v i t c a\n\nI C\n\ny l n o\n\ne n\n\ni l e p p t n e m y o p e d\n\ni\n\nl\n\ne n\n\ni l e p p\n\ni\n\nl a u n a m a\n\nt r e s n\n\ni\n\no t\n\ne l b i s s o p s ’ t I\n\nm o r f n o i t a m o t u a\n\ns t n e m n o r i v n e\n\nt s e t d n a\n\nd e s u s i\n\nh c i h w\n\n,\n\np e t s\n\nl a v o r p p a\n\nn o i t c u d o r p o t\n\nt n e m p o l e v e d\n\nk c e h c\n\nl a u n a m a\n\nt u o h t i\n\nw\n\nr o h t i\n\nw\n\ne b t o n n a c\n\nt u b\n\n, t n e m y o p e d\n\nl\n\nt n e m y o p e d n o i t c u d o r p r o f\n\nl\n\ns e t a g\n\nl a u t c a r t n o c o t\n\ne u d d e s u\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P",
      "content_length": 3138,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 61,
      "content": "t n e m y o l p e d s u o u n i t n o C\n\n.\n\n8 - 1 e l b a T\n\nR U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\ny t i r u t a M\n\nE R O C S\n\nr o t a c i d n I\n\nr u o Y\n\ne s a e l e r\n\ne m\n\ni t n w o d o r e Z\n\ne n ffl o n e k a t\n\ni\n\ns i\n\nm e t s y S\n\ne n ffl o n e k a t\n\ni\n\ns i\n\nm e t s y S\n\ne n ffl o n e k a t\n\ni\n\ns i\n\nm e t s y S\n\nn e k a t\n\ns i\n\nm e t s y S\n\no t\n\nt n e m y o l p e D\n\ne r o c s\n\ne h t h t i\n\nw d e d a r g p u s i\n\nm e t s y S\n\ns i\n\nt n e m y o p e d k c i l c - e n O\n\nl\n\nL L A t u b\n\nn o i t a l l a t s n\n\ni\n\np e t s - y b - p e t S\n\np e t s - y b - p e t S\n\ne n ffl o\n\ni\n\nn o i t c u d o r p\n\nr u o Y\n\ne r o c s\n\nm e t s y s\n\ne h t g n i k a t\n\nt u o h t i\n\nw d\n\nl i\n\nu b\n\nn w o d\n\n7\n\nt n e m y o p e d n e e r g / e u B\n\nl\n\nl\n\nl a c i t n e d\n\no w\n\nt (\n\ne m\n\ni t n w o d o N\n\nd n a\n\ne u b\n\nl\n\n:\n\nn o i t c u d o r p f o s n o i s r e v\n\nd n a d e d a r g p u s i\n\ne n o ;\n\nn e e r g\n\ne h t\n\nt a\n\nr e h t o e h t h t i\n\nw d e c a l p e r\n\n) l e v e l\n\nS N D\n\n7\n\ne r o f e b d e t s e t d n a d e m r o f r e p\n\ne v i l\n\no g\n\n5\n\nd n a\n\ny r a n a c o t\n\ny o p e d t s r i F\n\nl\n\nt a\n\ne n o s r e v r e s\n\ne d a r g p u n e h t\n\nt n e m y o p e d e h t\n\nl\n\nl i t n u e m\n\ni t\n\na\n\ne t e l p m o c\n\ns i\n\ne m\n\ni t n w o d o N\n\n5\n\nd e t a m o t u a\n\ne d u l c n\n\ni\n\ns p e t s\n\ns n o i t a r u g fi n o c\n\n3\n\nd e y o p e d d\n\nl\n\nl i\n\nu b\n\ng n i s a e l e r\n\ny r a n a C\n\nt s r fi t n e m n o r i v n e\n\ny r a n a c o t\n\nn\n\ni\n\ny r a n a c\n\ne h t g n i t s e t\n\nr e t f A\n\ns i\n\nm e t s y s\n\ne h t\n\n,\n\nd\n\nl i\n\nu b n o i t c u d o r p\n\ns i\n\ne d a r g p u e h t d n a n w o d n e k a t\n\nd e m r o f r e p\n\n3\n\nE M O S\n\nt u b\n\n,\n\nn o i t a l l a t s n\n\ne d u l c n\n\ns p e t s\n\nd e t a m o t u a\n\ns n o i t a r u g fi n o c\n\n1\n\ns e c a l p e r\n\nt n e m y o p e D\n\nl\n\nd\n\nl i\n\nu b g n i t s i x e\n\ne h t\n\n1\n\nd e t c u d n o c\n\nl l\n\nA\n\ng n i s u y l l a u n a m\n\ng n i t a r e p o d r a d n a t s\n\np e t s d n a s e r u d e c o r p\n\nn o i t a l l a t s n\n\ni\n\np e t s - y b\n\ne d u g\n\ni\n\n0\n\nd e t a m o t u a o N\n\nt n e m y o p e d\n\nl\n\n0\n\ns t n o P\n\ni\n\nt n e m y o l p e D\n\ns e i t i l i b a p a c\n\ns t n i o P\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\n|\n\n53",
      "content_length": 2227,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 62,
      "content": "g n i r o t i n o m\n\ns u o u n i t n o C\n\n.\n\n9 - 1 e l b a T\n\n54\n\nR U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\ny t i r u t a M\n\n|\n\nE R O C S\n\nr u o Y\n\ne r o c s\n\n: s e p y t g n i r o t i n o m e s e h t\n\nf o\n\ne c n a m r o f r e p n o i t a c i l\n\np p A\n\ng n i r o t i n o m\n\ns i s y l a n a d n a g n i r o t i n o m g o L\n\ng n i r o t i n o m y t i r u c e S\n\nl l\n\nA\n\n\n\n\n\n\n\n: s e p y t g n i r o t i n o m e e r h T\n\ne c n a m r o f r e p n o i t a c i l\n\np p A\n\ng n i r o t i n o m\n\ns i s y l a n a d n a g n i r o t i n o m g o L\n\ng n i r o t i n o m y t i r u c e S\n\n\n\n\n\n\n\n: s e p y t g n i r o t i n o M\n\ne c n a m r o f r e p n o i t a c i l\n\np p A\n\ng n i r o t i n o m\n\nd n a g n i r o t i n o m g o L\n\ns i s y l a n a\n\n\n\n\n\ne h t\n\nf o d e s u d e t i\n\nm i L\n\ny b s l o o t g n i r o t i n o m\n\nm a e t\n\ns n o i t a r e p o\n\ng n i r o t i n o m o N\n\nn o i t u o s\n\nl\n\ns i\n\ng n i r o t i n o M\n\ny b d e m r o f r e p\n\nm a e t\n\ns n o i t a r e p o\n\nm e t s y s (\n\nr o t a c i d n I\n\ng n i r o t i n o M\n\nn o i t u l o s\n\nEnterprise DevOps Playbook\n\ng n i r o t i n o m y t i r u c e S\n\n\n\nd n a\n\ns r o t a r t s i n m d a\n\ni\n\n) s A B D\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nr u o Y\n\nk c a t s\n\ne r i t n e\n\ne h t\n\nw e i v o t\n\ny t i l i\n\nb A\n\nn\n\ns e u s s i\n\ne t a l o s i\n\no t\n\ny t i l i\n\nb A\n\ne m\n\ni t - l a e r o t\n\ns s e c c a\n\ny s a E\n\nn o i t a c i l\n\np p a\n\nl a u n a M\n\nn o i t a c i l\n\np p a o N\n\nn o i t a c i l p p A\n\ne r o c s\n\nm o r f\n\n,\n\nd e fi i t n e d\n\ni\n\ne u s s i\n\ny n a\n\nf o\n\ne h t o t n w o d n o i t c u d o r p\n\nn o i t a c i l\n\np p a n o s c i t s i t a t s\n\ng n i r o t i n o m e c n a m r o f r e p\n\ne c n a m r o f r e p\n\ne c n a m r o f r e p\n\ne h t o t n w o d t s e u q e r\n\nl a i t i n\n\n/\n\nM V / s r e v r e s\n\nl a u d i v i d n\n\nn o i t c u d o r p n\n\ne c n a m r o f r e p\n\ns l o o t\n\nS O g n i s u\n\ng n i r o t i n o m\n\ng n i r o t i n o m\n\ne s a b a t a d\n\ns e s s e c o r p d n a\n\ns r e n i a t n o c\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nr u o Y\n\nd n a d e x e d n\n\ni\n\ne r a\n\ns g o\n\nl\n\nl l\n\nA\n\nn\n\ni\n\nt u p d n a d e t a d\n\ni l\n\no s n o c\n\ns g o\n\nl l\n\nA\n\n,\n\nn o i t a c i l\n\np p a\n\n, . e . i (\n\ns g o\n\nl\n\nl l\n\nA\n\ng n i s u g n i r o t i n o m g o L\n\ng n i r o t i n o m g o\n\nl\n\no N\n\ng n i r o t i n o m g o L\n\ne r o c s\n\ne l b a h c r a e s\n\ny l k c i u q\n\nn o i t a c o\n\nl\n\nl a r t n e c\n\na\n\ny l i s a e\n\n) s s e c c a b e w\n\n, y t i r u c e s\n\ns l o o t\n\nS O\n\nw e i v e r\n\nr o f\n\ne l b i s s e c c a\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P",
      "content_length": 2500,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 63,
      "content": "R U O Y\n\ne m e r t x E\n\nd e c n a v d A\n\ne t a i d e m r e t n I\n\nr e n n g e B\n\ni\n\ne s a B\n\ny t i r u t a M\n\nE R O C S\n\nr o t a c i d n I\n\nr u o Y\n\ne r a\n\nt a h t\n\ns d a o l y a p r o t i n o M\n\ng n i r o t i n o m k r o w t e n d e c n a v d A\n\n,\n\nn o i t a c fi i t n e d\n\ni\n\nt a e r h t\n\ne l p m i S\n\ng n i r o t i n o m y t i r u c e S\n\ny t i r u c e s o N\n\ny t i r u c e S\n\ne r o c s\n\nr o f\n\nm e t s y s\n\ne h t g n i t t i h\n\nr o s e i t i l i\n\nb a r e n u v d n fi y l e v i t c a o t\n\nl\n\ns k c a t t a\n\nS o D s u o i r a v\n\ns a h c u s\n\nd n a\n\nS O c i s a b g n i s u\n\ng n i r o t i n o m\n\ng n i r o t i n o m\n\ns k c a t t a\n\ne l b i s s o p g n i y f i t n e d\n\ns k c a t t a\n\ne v i t c a\n\ns l o o t\n\nk r o w t e n\n\n7\n\n5\n\n3\n\n1\n\n0\n\ns t n i o P\n\nr u o Y\n\ne r o c s\n\ne r a\n\ns d o h s e r h t g n i t r e l A\n\nl\n\ne l b a fi d o m\n\ni\n\n7\n\ns e d i v o r p n o i t u o s g n i t r e l A\n\nl\n\n, s t n e v e\n\ns u o i v e r p f o t s i l\n\nc i r o t s i h\n\ns l i a t e d t n e v e g n d u l c n\n\ni\n\n5\n\nd e l i a t e d e d i v o r p s t r e l A\n\ne r u t a n e h t\n\nt u o b a n o i t a m r o f n\n\nr e g g i r t g n i r o t i n o m\n\nf o\n\n3\n\ne r a\n\ns e i t r a p e l b i s n o p s e R\n\nm a e t\n\ny b d e t r e l a\n\n, s g o\n\nl\n\ng n i r o t i n o m\n\ny t i r u c e s d n a\n\n,\n\nn o i t a c i l\n\np p a\n\n1\n\ng n i t r e l a o N\n\n0\n\ng n i t r e l A\n\nn o i t u l o s\n\ns t n i o P\n\nPlay 3: Assess Your DevOps Maturity Level and Define a Roadmap\n\n|\n\n55",
      "content_length": 1432,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 64,
      "content": "Play 4: Create a DevOps Pipeline So how do you put DevOps into action once you have a clear road‐ map and identify what DevOps means to your organization? We suggest you begin by defining and creating a DevOps delivery pipe‐ line. This is the set of tools and processes working together to pro‐ vide workflow automation that reflects your DevOps practices taking code changes all the way through into production. The shape of the pipeline, the activities inside each step, what steps are automa‐ ted versus manual, and code release and deployment strategies will reflect your DevOps practices, requirements, and philosophies. Every environment and pipeline is different, but the characteristics of a successful delivery pipeline are the same, providing the follow‐ ing:\n\nAutomation of building, testing, and deploying\n\nAutomation of infrastructure, which can be created and destroyed without impacting the health of the software\n\nReflective of your release DevOps philosophy and strategy\n\nRepeatable and expected results with immutable infrastructure and processes\n\nVisibility into the entire pipeline workflow steps.\n\nThere is a wide range and constantly evolving set of technology and tools for implementing your delivery pipeline. Key factors to con‐ sider when choosing your set of DevOps tools include team skillset, breadth of required hosting providers/infrastructure, availability of the tools’ APIs, and, ultimately, the tools’ ability to execute your DevOps practices’ requirements and philosophy.\n\nThe delivery pipeline you build should first satisfy the basic flow. With it, you should be able to do the following:\n\nCheck out code\n\nChange the code and integrate it into the repository\n\nRun validation and predeployment automated tests to ensure the code meets required needs, does not break other existing code, and runs as expected\n\nDeploy your builds on predefined infrastructure clusters\n\n56\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1937,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 65,
      "content": "Move the build from development to testing, testing to QA, and finally to production.\n\nWhen the basic flow is perfected, you can begin exploring advanced concepts that can help you to safely and reliably deploy, easily scale, and roll back or forward. Among the advanced concepts, you should become familiar with these:\n\nSpin up or down virtual machines (or on IaaS platforms) based on user load\n\nContainerize (e.g., use Docker) your application and deploy it on a scalable server cluster\n\nProvision containers based on user load\n\nExplore microservices architecture. This is not easy to imple‐ ment and there are many considerations that must be addressed involving this approach, including service discovery, communi‐ cations, and orchestration. These aspects are beyond the scope of this playbook.\n\nIt is important to approach and look at your pipeline as an enter‐ prise change management workflow because handling one project (delivery pipeline) is not the same when you have multiple delivery streams that need to be validated and merged into a shared work‐ flow for handling dependencies. Simplh having automation and repeatability does not necessarily equate to an effective and scalable pipeline. You want to avoid creating a complex Rube Goldberg–type contraption and keep steps simple as appropriate and select tools for what they are good/meant for versus doing heavy customization and or using a large of amount of plug-ins.\n\nGuiding Questions\n\nAre there any steps that cannot be automated and will need manual review and/or acceptance?\n\nIs the goal to move to a microservices architecture?\n\nHow many builds to production do you want to target/require on a daily/weekly/monthly basis?\n\nWhat SLAs do you want to automate?\n\nWhat platforms and hosting providers do you need to support?\n\nPlay 4: Create a DevOps Pipeline\n\n|\n\n57",
      "content_length": 1835,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 66,
      "content": "How many features are you anticipating?\n\nDo you currently use a canary release and or blue/green deploy‐ ment strategy when rolling features out to production?\n\nHow are production rollbacks typically handled?\n\nAre you planning to move to containerization architecture soon?\n\nChecklist\n\nDefined repeatable automated and manual steps that every code change will go through—the workflow does not change and provides expected steps and results every time.\n\nEstablished and verified full traceability for each step in the pipeline—the ablility to see where a change is in the pipeline at any time and its status.\n\nImplemented notification and resolution process for each suc‐ cess/fail action for each step—ensure that you clearly define responsibility groups for each action issue.\n\nVerified immutable infrastructure—your IaC is able to tear down and bring up each environment over and over again with the same expected state and results.\n\nEnsured metrics defined in continuous monitoring are cap‐ tured, visible, and integrated with your notification process.\n\nPlay 5: Learn and Improve through Metrics and Visibility Now that you have created a pipeline and have a delivery flow that’s running, you’ll need to know how effective it is and what you can improve. One of the key principles we highlighted earlier is being a learning organization, and that the mastery of DevOps requires con‐ stant feedback and an environment that fosters continuous learning. To learn, you need to have the metrics and visibility into the effec‐ tiveness of the processes, environments, and operations. In a DevOps project, metrics for monitoring project performance and capturing project data serve five critical purposes:\n\n58\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1737,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 67,
      "content": "Detect failure\n\nDiagnose performance problems\n\nPlan capacity\n\nObtain insights about user interactions\n\nIdentify intrusions\n\nBecause systems are constantly increasing in complexity, breadth of distribution, scope, and size, measuring their activities and levels of efficacy—and logging the results in data banks—demands a new generation of infrastructure and services to support these efforts. Given with the right equipment in place, the value of metrics spans a broad swath of information, from systems health and performance to end-user habits.\n\nFor example, when applications or programs fail, metrics provide context to alerts, opening windows into what activities occurred and what interactions took place leading up to each failure. Equally important, metrics offer historical awareness of usage patterns, which is critical for anticipating potential failures, writing fixes that could shore up programs during oversubscribed periods, and deter‐ mining how robust future software must be. For this purpose, ques‐ tions that metrics can answer include the following:\n\nWhat are the peak hours of the day, days of the week, or months of the year for utilization?\n\nIs there a seasonal usage pattern, such as summertime lows, hol‐ iday highs, more activity when school is in session or when it isn’t, and so on?\n\nHow do maximum (peak) values compare against minimum (valley) values?\n\nDo peak and valley relationships change in different regions around the globe?\n\nIn a large-scale system, ubiquitous monitoring can generate data involving millions of events with countless numbers of log lines devoted to metrics measurements. This, in turn, can monopolize overhead and affect performance, transmission, and storage. The emergence of big data analytics and modern distributed logging alleviates this problem. Moreover, advanced machine learning algo‐ rithms can deal with noisy, inconsistent, and voluminous data.\n\nPlay 5: Learn and Improve through Metrics and Visibility\n\n|\n\n59",
      "content_length": 1979,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 68,
      "content": "When deciding how much data resolution to maintain for metrics, you need to think about the type and amount of information that you want to get from them. Will you be depending on metrics for insight into what is causing an outage or degradation? If so, you’ll most likely want to have a fine resolution, less than a minute. Or will you be using the data primarily for capacity planning on a three-, six-, or nine-month timeline? If so, you’ll want to ensure that you can retain the historical details about maximum and minimum over a long period of time.\n\nAt the very least, the metrics in place should effectively and continu‐ ously monitor the following four fundamental DevOps facets:\n\nDeployment frequency\n\nHow often does new code reach customers? DevOps practices make frequent or continuous program delivery possible, and large, high-traffic websites and cloud-based services make it a necessity. With fast feedback and small-batch development, updated software can be deployed every few days, or even sev‐ eral times per day. In a DevOps environment, delivery (i.e., deployment to production) frequency can be a direct or indirect measure of response time, team cohesiveness, developer capa‐ bilities, development tool effectiveness, and overall DevOps team efficiency.\n\nChange lead time (from development to production)\n\nHow long does it take, on average, to move code from develop‐ ment through a cycle of A/B testing to 100 percent deployed and upgraded in production? The time from the start of a devel‐ opment cycle (the first new code) to deployment is the change lead time. It is a measure of the efficiency of the development process, of the complexity of the code and the development sys‐ tems, and (like deployment frequency) of team and developer capabilities. If the change lead time is too long, it might be an indication that the development and deployment process is inefficient in certain stages or that it is subject to performance bottlenecks.\n\nChange failure rate (per week)\n\nWhat percentage of deployments to production failed or rever‐ ted back to be fixed with another patch? One of the main goals of DevOps is to turn rapid, frequent deployments into an every‐ day affair. For such deployments to have value, the failure rate\n\n60\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 2291,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 69,
      "content": "must be low. In fact, the failure rate must decrease over time, as the experience and the capabilities of the DevOps teams increase. A rising failure rate, or a high failure rate that does not decline over time, is a good indication of problems in the over‐ all DevOps process.\n\nMean time to recovery (MTTR)\n\nWhat is the mean time to recover from a failed deployment— that is, the time from failure to recovery from that failure? This generally is a good measure of team capabilities and, like the failure rate, it should show an overall decrease over time (allow‐ ing for occasional longer recovery periods when the team encounters a technically unfamiliar problem). MTTR can also be affected by such things as code (or platform) complexity, the number of new features being implemented, and changes in the operating environment (e.g., migration to a new cloud server).\n\nIn addition to these essential four metrics, there are others that we recommend DevOps teams consider. The more information you have, the more successful your DevOps projects will be. Among the other benchmarks to assess are the following:\n\nDelivery frequency\n\nHow often is code deployed to the development and test envi‐ ronments?\n\nChange volume\n\nFor each deployment, how many user stories and new lines of code are making it to production?\n\nCustomer tickets (per week)\n\nHow many alerts are generated by customers to indicate service issues?\n\nPercentage change in user volume\n\nHow many new users are signing up and generating traffic?\n\nAvailability\n\nWhat is the overall service uptime and were any SLAs violated?\n\nResponse time\n\nDoes the application’s performance reach the predetermined thresholds?\n\nPlay 5: Learn and Improve through Metrics and Visibility\n\n|\n\n61",
      "content_length": 1737,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 70,
      "content": "In addition to the nitty-gritty, day-to-day performance and usage patterns that DevOps metrics excel in providing, there are two other areas of organizational activities that well-designed standards can monitor for strengths and weaknesses: cultural metrics and process metrics. Let’s look more closely at each one.\n\nCultural Metrics DevOps is meant to include a set of efficiency and improvement principles that should minimize project development conflict and eliminate stress and burnout. In turn, team members will ideally be more healthy, loyal to the organization, and deeply engaged in workplace activities. It’s possible to measure across a number of key cultural indicators, including sentiment toward change, failure, and a typical day’s work. Among the most telling metrics to be sought in this regard are the following:\n\nCross-skilling\n\nHow much knowledge sharing and pairing exists among teams?\n\nFocus\n\nAre teams working in a fluid and focused manner toward ach‐ ieving common goals or objectives?\n\nMultidisciplinary teams\n\nDo teams comprise members with varied but complimentary experience, qualifications, and skills?\n\nProject-based teams\n\nAre teams organized around projects rather than solely skill‐ sets?\n\nBusiness demand\n\nAre the demands placed on development teams by the business side too onerous?\n\nExtra lines of code\n\nHow many extraneous lines of code exist in the project?\n\nAttitude\n\nAre team members receptive to and positive about continuous improvement?\n\nNumber of metrics\n\nIs the obsession with metrics perceived to be too high?\n\n62\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1591,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 71,
      "content": "Technological experimentation\n\nWhat is the degree of experimentation and innovation within the project?\n\nTeam autonomy\n\nHow successfully does the team manage its own work and working practices?\n\nRewards\n\nDo team members feel appreciated and rewarded for their work and successes?\n\nAs you can tell, many of these cultural metrics cannot be directly measured. That is why we have stressed the mindset of becoming a learning organization and having transparency and visibility into the end-to-end process. For example, with regard to cross-skilling, one way to assess that is to track to see if there’s a high variance in the velocity across Agile teams, especially knowing that team mem‐ bers are being shuffled. The takeaway here is that in order to gauge the impact and effectiveness of cultural changes, you need to estab‐ lish a means for constant feedback and dialogue with the team.\n\nProcess Metrics One goal of a typical DevOps project is to achieve continuous deployment. This occurs by linking software development processes and tools together to allow fully tested, production-ready, commit‐ ted code to proceed to a live environment without user interaction. This software infrastructure portion of a DevOps project is often termed the DevOps toolchain. It’s useful to measure the relative maturity of the component processes of the toolchain as a proxy for overall DevOps capabilities. Typically, we look at an organization’s skills in the following areas:\n\nProject requirements gathering and management\n\nAdherence to Agile development principles\n\nWhether the software build is generally defect-free\n\nFluidity of releases and deployment\n\nDegree to which units of code are tested to determine their suit‐ ability for use\n\nDegree of user acceptance testing\n\nPlay 5: Learn and Improve through Metrics and Visibility\n\n|\n\n63",
      "content_length": 1829,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 72,
      "content": "Quality assurance programs\n\nPerformance monitoring to ensure the program is reliable and can scale\n\nCloud testing to be certain that the application and its load can be supported\n\nAlso under the umbrella of process is sharing, which is another area that is often overlooked but should be encouraged—and measured. People from different parts of an organization often have different, but overlapping, skillsets. For example, this is true of staffers on the development side and the operations side, the disparate parts of the enterprise that DevOps is meant to link together. Given the impor‐ tance of sharing between these teams, and the benefits to be gained by an organization when there is a maximum amount of sharing, it’s useful to measure the frequency of sharing.\n\nExamples of workplace sharing that you can measure, and the aspects of a DevOps project that these collaborative efforts affect, include the following:\n\nShared Goal: Reliability and speed\n\nShared Problem Space: Deployment and delivery\n\nShared Priorities: Improvement decisions\n\nShared Location: Communications\n\nShared Communication: Chat, wiki, mailing list\n\nShared Codebase: Code and infracode\n\nShared Responsibility: Building and deployment\n\nShared Workflow: One-button deployment\n\nShared Reusable Environments: Reusable recipes\n\nShared Process: Standups and releases\n\nShared Knowledge: One ticketing system\n\nShared Success and Failure: Common experience and history\n\nMetrics Tools There are many monitoring and metrics systems and tools available, both from open source and commercial developers. Typical systems\n\n64\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1621,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 73,
      "content": "include Nagios; Sensu and Icinga; Ganglia; and Graylog2, Logstash, and Splunk:\n\nNagios\n\nNagios is probably the most widely used monitoring tool due to its large number of plug-ins, which are basically agents that col‐ lect metrics in which you are interested. However, Nagios’ core is essentially an alerting system with limited features, and Nagios is weak in dealing with the frequent changes of servers and infrastructure encountered in cloud environments.\n\nSensu and Icinga\n\nSensu is a highly extensible and scalable system that works well in a cloud environment. Icinga is a fork of Nagios with a more scalable distributed monitoring architecture and easy exten‐ sions. Icinga also has stronger internal reporting systems than Nagios. Both Sensu and Icinga can run Nagios’s large plug-in pool.\n\nGanglia\n\nGanglia was originally designed to collect cluster metrics. It is designed to have node-level metrics replicated to nearby nodes to prevent data loss and over-chattiness to the central reposi‐ tory. Many IaaS providers support Ganglia.\n\nGraylog2, Logstash, Splunk\n\nThese distributed log management systems are tailored to process large amounts of text-based metrics logs. They have frontends for integrative exploration of logs and powerful search features.\n\nSummary There is plenty of information, excitement, value, promise, and con‐ fusion that comes with DevOps. The benefits are clear: improved quality, flexibility, speed to value, increased efficiency, and potential cost savings. Less clear, however, is the best approach to adopting DevOps practices. Adopting DevOps practices involves a mindset change that is built on the right mix of people and culture, an understanding of DevOps practices and how they relate to your projects, and, ultimately, choosing and implementing tools to put DevOps practices into action through a delivery pipeline.\n\nSummary\n\n|\n\n65",
      "content_length": 1879,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 74,
      "content": "Selecting DevOps tools is a challenging task given the many tools available. We recommend aligning the tools with your organization’s skillsets, flexibility needs, and modularity bias. This technical land‐ scape is changing constantly, with updated versions, open source efforts, and new solutions. Make sure the tools you select do not require custom integration or a high level of consolidation, which might lead to a large effort to swap out the application down the road.\n\nMost organizations have trouble establishing appropriate require‐ ments and goals for a DevOps program. You will need initial targets to quantify your successes, and those targets will not be the same from one team to another. Consequently, every organization will implement DevOps to different levels of maturity. We hope this report has provided you with a solid foundation of what DevOps means, and more importantly, a framework for developing an effec‐ tive adoption plan or to incorporate/assess your current efforts:\n\nUnderstand each DevOps practice and how it conforms with your organization’s objectives and goals\n\nAssess the level of your organization’s DevOps capabilities\n\nDetermine how far you need to go and what you need to do to achieve the DevOps level of performance that you want.\n\nUnderstanding these three items will put you on the road to a suc‐ cessful and enduring DevOps practice. We look forward to hearing your success stories!\n\nRecommended Reading We recommend the following reading that dives deeper into each of the areas we touched upon in this report, from culture to technical details around continuous delivery and microservices:\n\nThe Phoenix Project: A Novel about IT, DevOps, and Helping Your Business Win, Gene Kim and Kevin Behr (IT Revolution Press).\n\nThe Fifth Discipline: The Art & Practice of The Learning Organi‐ zation, Peter M. Senge (Doubleday Business).\n\n66\n\n|\n\nEnterprise DevOps Playbook",
      "content_length": 1911,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 75,
      "content": "The DevOps Handbook: How to Create World-Class Agility, Relia‐ bility, and Security in Technology Organizations, Gene Kim and Patrick Debois (IT Revolution Press).\n\nContinuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation, by Jez Humble and David Farley (Addison-Wesley Professional).\n\nBuilding a DevOps Culture, Mandi Wells (O’Reilly).\n\nThe DevOps 2.0 Toolkit: Automating the Continuous Deployment Pipeline with Containerized Microservices, Viktor Farcic (Create‐ Space Independent Publishing Platform).\n\nBuilding Microservices, Sam Newman (O’Reilly).\n\nRecommended Reading\n\n|\n\n67",
      "content_length": 618,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 76,
      "content": "About the Authors\n\nBill Ott is a Vice President with Booz Allen Hamilton, where he leads a group of creative and technology professionals who are pas‐ sionate about integrating human-centered design, Agile develop‐ ment, DevOps, security, and advanced analytics to build digital services that users will use and enjoy, securely. His inspiration comes from his three boys who love technology—specifically Minecraft gaming/programming and creating and watching YouTube videos. Mr. Ott holds a BS in electrical engineering from Drexel University and an MBA from Emory University.\n\nJimmy Pham is an avid technologist who has designed, developed, and managed large software solutions for major private and public customers. He is currently a Chief Technologist focusing on modern software development. His interests and experience also span web acceleration/performance and cloud security. Prior to Booz Allen Hamilton, he worked at Akamai and ran a startup. He holds a degree in Computer Science (BSE) and minors in Mathematics and Psychology.\n\nHaluk Saker is a director with the Digital team and a 20-year vet‐ eran of Booz Allen. An experienced system/cloud architect, he leads Digital’s DevOps practice, microservices architecture, and numerous cloud platforms investments. He is also one of the coauthors of the Booz Allen Agile Playbook that is used by all software development teams at the firm. He has an extensive background in turnkey sys‐ tem and cloud implementations, modern technology stacks, and Continuous Deployment. Haluk holds a BS in Electrical Engineer‐ ing, an MS in Engineering Management, and an MS in Management Information Systems.",
      "content_length": 1652,
      "extraction_method": "Unstructured"
    }
  ]
}