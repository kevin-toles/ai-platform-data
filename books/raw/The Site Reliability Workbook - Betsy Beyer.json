{
  "metadata": {
    "title": "The Site Reliability Workbook - Betsy Beyer",
    "author": "Betsy Beyer, Niall Richard Murphy, David K. Rensin, Kent Kawahara and Stephen Thorne",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 508,
    "conversion_date": "2025-12-19T17:50:31.396399",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "The Site Reliability Workbook - Betsy Beyer.pdf",
    "extraction_method": "Unstructured"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 1-9)",
      "start_page": 1,
      "end_page": 9,
      "detection_method": "topic_boundary",
      "content": "Presented by Google Cloud Launch Day Edition Companion to the Bestselling SRE Book\n\nThe Site Reliability Workbook\n\nPractical Ways to Implement SRE\n\nEdited by Betsy Beyer, Niall Richard Murphy, David K. Rensin, Kent Kawahara & Stephen Thorne\n\nPraise for The Site Reliability Workbook\n\nThis new workbook will help people to take the sometimes theoretical and abstract concepts covered in Site Reliability Engineering out of the special context of the Googleplex and see how the same concepts work in other organizations. I’m especially excited to see more detail in the analysis of toil, how to apply SRE principles to data pipelines, and the case study reports discussing practical service level management.\n\n—Kurt Andersen, Site Reliability Engineer, LinkedIn\n\nThis practical hands-on guide to implementing SRE is valuable for engineers at companies of all sizes. It’s excellent to see this workbook being shared so that we can all move forward and build more reliable systems together. I was impressed with the level of detail shared; you can pick this book up and get started implementing SRE practices today.\n\n—Tammy Bütow, Principal SRE, Gremlin\n\nA timely reminder, from the team that made SRE a required practice for everyone operating at scale, that reliability is created by people. This book is full of practical examples of how to optimize for reliability by focusing on the interactions between users and engineers and between technology and tools, without losing sight of feature velocity. The result is a compelling, interesting, and thought-provoking companion to Site Reliability Engineering.\n\n—Casey Rosenthal, CTO, Backplane.io\n\nGoogle’s first book explained the what and why of SRE. This book shows you how to implement SRE at any company, startup or giant. Great work by the editorial team.\n\n—Jonah Horowitz, SRE at Stripe\n\nIn 2016, Google dropped Site Reliability Engineering on the operations world, and the operations world was never the same. For the first time people had access to over 500 pages of distilled information on what Google does to run its planet-wide infrastructure. Most people liked the book, a handful didn’t, but nobody ignored it. It became a seminal work and an important touchstone for how people thought about SRE (especially the Google implementation of it) from that point on. But it was missing something….\n\nNow in 2018, Google returns to fill in a crucial piece of the puzzle: in their first volume they described what they do, but that didn’t help those who couldn’t see themselves in Google’s story. This book aims to demonstrate how Google does SRE— and how you can do it, too.\n\n—David N. Blank-Edelman, editor of Seeking SRE: Conversations about Running Production Systems at Scale and cofounder of the global set of SREcon conferences\n\nThe Site Reliability Workbook Practical Ways to Implement SRE\n\nEdited by Betsy Beyer, Niall Richard Murphy, David K. Rensin, Kent Kawahara, and Stephen Thorne\n\nBeijing Beijing\n\nBoston Boston\n\nFarnham Sebastopol Farnham Sebastopol\n\nTokyo Tokyo\n\nThe Site Reliability Workbook edited by Betsy Beyer, Niall Richard Murphy, David K. Rensin, Kent Kawahara, and Stephen Thorne\n\nCopyright © 2018 Google LLC. All rights reserved.\n\nPrinted in the United States of America.\n\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\n\nO’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles (http://oreilly.com/safari). For more information, contact our corporate/insti‐ tutional sales department: 800-998-9938 or corporate@oreilly.com.\n\nAcquisitions Editor: Nikki McDonald Developmental Editor: Virginia Wilson Production Editor: Kristen Brown Copyeditor: Rachel Monaghan Proofreader: Kim Cofer\n\nIndexer: Ellen Troutman-Zaig Interior Designer: David Futato Cover Designer: Karen Montgomery Illustrator: Rebecca Demarest\n\nAugust 2018:\n\nFirst Edition\n\nRevision History for the First Edition 2018-06-08: First Release 2018-06-22: Second Release\n\nSee http://oreilly.com/catalog/errata.csp?isbn=9781492029502 for release details.\n\nThis work is part of a collaboration between O’Reilly and Google. See our statement of editorial independ‐ ence.\n\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. The Site Reliability Workbook, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.\n\nThe views expressed in this work are those of the authors, and do not represent the publisher’s views. While the publisher and the authors have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the authors disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work. Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.\n\n978-1-492-02950-2\n\n[LSCH]\n\nTable of Contents\n\nForeword I. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xvii\n\nForeword II. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xix\n\nPreface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxiii\n\n1. How SRE Relates to DevOps. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Background on DevOps 2 No More Silos 2 Accidents Are Normal 3 Change Should Be Gradual 3 Tooling and Culture Are Interrelated 3 Measurement Is Crucial 4 Background on SRE 4 Operations Is a Software Problem 4 Manage by Service Level Objectives (SLOs) 5 Work to Minimize Toil 5 Automate This Year’s Job Away 6 Move Fast by Reducing the Cost of Failure 6 Share Ownership with Developers 6 Use the Same Tooling, Regardless of Function or Job Title 7 Compare and Contrast 7 Organizational Context and Fostering Successful Adoption 9 Narrow, Rigid Incentives Narrow Your Success 9 It’s Better to Fix It Yourself; Don’t Blame Someone Else 10 Consider Reliability Work as a Specialized Role 10 When Can Substitute for Whether 11 Strive for Parity of Esteem: Career and Financial 12 v\n\nConclusion 12\n\nPart I.\n\nFoundations\n\n2.\n\nImplementing SLOs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 Why SREs Need SLOs 17 Getting Started 18 Reliability Targets and Error Budgets 19 What to Measure: Using SLIs 20 A Worked Example 23 Moving from SLI Specification to SLI Implementation 25 Measuring the SLIs 26 Using the SLIs to Calculate Starter SLOs 28 Choosing an Appropriate Time Window 29 Getting Stakeholder Agreement 30 Establishing an Error Budget Policy 31 Documenting the SLO and Error Budget Policy 32 Dashboards and Reports 33 Continuous Improvement of SLO Targets 34 Improving the Quality of Your SLO 35 Decision Making Using SLOs and Error Budgets 37 Advanced Topics 38 Modeling User Journeys 39 Grading Interaction Importance 39 Modeling Dependencies 40 Experimenting with Relaxing Your SLOs 41 Conclusion 42\n\n3. SLO Engineering Case Studies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 Evernote’s SLO Story 43 Why Did Evernote Adopt the SRE Model? 44 Introduction of SLOs: A Journey in Progress 45 Breaking Down the SLO Wall Between Customer and Cloud Provider 48 Current State 49 The Home Depot’s SLO Story 49 The SLO Culture Project 50 Our First Set of SLOs 52 Evangelizing SLOs 54 Automating VALET Data Collection 55 The Proliferation of SLOs 57 Applying VALET to Batch Applications 57 Table of Contents\n\n3. SLO Engineering Case Studies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 Evernote’s SLO Story 43 Why Did Evernote Adopt the SRE Model? 44 Introduction of SLOs: A Journey in Progress 45 Breaking Down the SLO Wall Between Customer and Cloud Provider 48 Current State 49 The Home Depot’s SLO Story 49 The SLO Culture Project 50 Our First Set of SLOs 52 Evangelizing SLOs 54 Automating VALET Data Collection 55 The Proliferation of SLOs 57 Applying VALET to Batch Applications 57 Table of Contents\n\nUsing VALET in Testing 58 Future Aspirations 58 Summary 59 Conclusion 60\n\n4. Monitoring. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 Desirable Features of a Monitoring Strategy 62 Speed 62 Calculations 62 Interfaces 63 Alerts 64 Sources of Monitoring Data 64 Examples 65 Managing Your Monitoring System 67 Treat Your Configuration as Code 67 Encourage Consistency 68 Prefer Loose Coupling 68 Metrics with Purpose 69 Intended Changes 70 Dependencies 70 Saturation 71 Status of Served Traffic 72 Implementing Purposeful Metrics 72 Testing Alerting Logic 72 Conclusion 73\n\n5. Alerting on SLOs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 Alerting Considerations 75 Ways to Alert on Significant Events 76 1: Target Error Rate ≥ SLO Threshold 76 2: Increased Alert Window 78 3: Incrementing Alert Duration 79 4: Alert on Burn Rate 80 5: Multiple Burn Rate Alerts 82 6: Multiwindow, Multi-Burn-Rate Alerts 84 Low-Traffic Services and Error Budget Alerting 86 Generating Artificial Traffic 87 Combining Services 87 Making Service and Infrastructure Changes 87 Lowering the SLO or Increasing the Window 88 Extreme Availability Goals 89 Alerting at Scale 89\n\nTable of Contents\n\n|\n\nvii\n\nConclusion 91\n\n6. Eliminating Toil. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 What Is Toil? 94 Measuring Toil 96 Toil Taxonomy 98 Business Processes 98 Production Interrupts 99 Release Shepherding 99 Migrations 99 Cost Engineering and Capacity Planning 100 Troubleshooting for Opaque Architectures 100 Toil Management Strategies 101 Identify and Measure Toil 101 Engineer Toil Out of the System 101 Reject the Toil 101 Use SLOs to Reduce Toil 102 Start with Human-Backed Interfaces 102 Provide Self-Service Methods 102 Get Support from Management and Colleagues 103 Promote Toil Reduction as a Feature 103 Start Small and Then Improve 103 Increase Uniformity 103 Assess Risk Within Automation 104 Automate Toil Response 104 Use Open Source and Third-Party Tools 105 Use Feedback to Improve 105 Case Studies 106 Case Study 1: Reducing Toil in the Datacenter with Automation 107 Background 107 Problem Statement 110 What We Decided to Do 110 Design First Effort: Saturn Line-Card Repair 110 Implementation 111 Design Second Effort: Saturn Line-Card Repair Versus Jupiter Line-Card Repair 113 Implementation 114 Lessons Learned 118 Case Study 2: Decommissioning Filer-Backed Home Directories 121 Background 121 Problem Statement 121 What We Decided to Do 122\n\n6. Eliminating Toil. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 What Is Toil? 94 Measuring Toil 96 Toil Taxonomy 98 Business Processes 98 Production Interrupts 99 Release Shepherding 99 Migrations 99 Cost Engineering and Capacity Planning 100 Troubleshooting for Opaque Architectures 100 Toil Management Strategies 101 Identify and Measure Toil 101 Engineer Toil Out of the System 101 Reject the Toil 101 Use SLOs to Reduce Toil 102 Start with Human-Backed Interfaces 102 Provide Self-Service Methods 102 Get Support from Management and Colleagues 103 Promote Toil Reduction as a Feature 103 Start Small and Then Improve 103 Increase Uniformity 103 Assess Risk Within Automation 104 Automate Toil Response 104 Use Open Source and Third-Party Tools 105 Use Feedback to Improve 105 Case Studies 106 Case Study 1: Reducing Toil in the Datacenter with Automation 107 Background 107 Problem Statement 110 What We Decided to Do 110 Design First Effort: Saturn Line-Card Repair 110 Implementation 111 Design Second Effort: Saturn Line-Card Repair Versus Jupiter Line-Card Table of Contents",
      "page_number": 1
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 10-17)",
      "start_page": 10,
      "end_page": 17,
      "detection_method": "topic_boundary",
      "content": "Design and Implementation 123 Key Components 124 Lessons Learned 127 Conclusion 129\n\n7. Simplicity. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131 Measuring Complexity 131 Simplicity Is End-to-End, and SREs Are Good for That 133 Case Study 1: End-to-End API Simplicity 134 Case Study 2: Project Lifecycle Complexity 134 Regaining Simplicity 135 Case Study 3: Simplification of the Display Ads Spiderweb 137 Case Study 4: Running Hundreds of Microservices on a Shared Platform 139 Case Study 5: pDNS No Longer Depends on Itself 140 Conclusion 141\n\nPart II. Practices\n\n8. On-Call. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147 Recap of “Being On-Call” Chapter of First SRE Book 148 Example On-Call Setups Within Google and Outside Google 149 Google: Forming a New Team 149 Evernote: Finding Our Feet in the Cloud 153 Practical Implementation Details 156 Anatomy of Pager Load 156 On-Call Flexibility 167 On-Call Team Dynamics 171 Conclusion 173\n\n9.\n\nIncident Response. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175 Incident Management at Google 176 Incident Command System 176 Main Roles in Incident Response 177 Case Studies 177\n\nCase Study 1: Software Bug—The Lights Are On but No One’s (Google)\n\nHome 177 Case Study 2: Service Fault—Cache Me If You Can 180 Case Study 3: Power Outage—Lightning Never Strikes Twice…\n\nUntil It Does 185 Case Study 4: Incident Response at PagerDuty 188 Putting Best Practices into Practice 191\n\nTable of Contents\n\n|\n\nix\n\nIncident Response Training 191 Prepare Beforehand 192 Drills 193 Conclusion 194\n\n10. Postmortem Culture: Learning from Failure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195 Case Study 196 Bad Postmortem 197 Why Is This Postmortem Bad? 199 Good Postmortem 203 Why Is This Postmortem Better? 212 Organizational Incentives 214 Model and Enforce Blameless Behavior 214 Reward Postmortem Outcomes 215 Share Postmortems Openly 217 Respond to Postmortem Culture Failures 218 Tools and Templates 220 Postmortem Templates 220 Postmortem Tooling 221 Conclusion 223\n\n11. Managing Load. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225 Google Cloud Load Balancing 225 Anycast 226 Maglev 227 Global Software Load Balancer 229 Google Front End 229 GCLB: Low Latency 230 GCLB: High Availability 231 Case Study 1: Pokémon GO on GCLB 231 Autoscaling 236 Handling Unhealthy Machines 236 Working with Stateful Systems 237 Configuring Conservatively 237 Setting Constraints 237 Including Kill Switches and Manual Overrides 238 Avoiding Overloading Backends 238 Avoiding Traffic Imbalance 239 Combining Strategies to Manage Load 239 Case Study 2: When Load Shedding Attacks 240 Conclusion 243 Table of Contents\n\n11. Managing Load. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225 Google Cloud Load Balancing 225 Anycast 226 Maglev 227 Global Software Load Balancer 229 Google Front End 229 GCLB: Low Latency 230 GCLB: High Availability 231 Case Study 1: Pokémon GO on GCLB 231 Autoscaling 236 Handling Unhealthy Machines 236 Working with Stateful Systems 237 Configuring Conservatively 237 Setting Constraints 237 Including Kill Switches and Manual Overrides 238 Avoiding Overloading Backends 238 Avoiding Traffic Imbalance 239 Combining Strategies to Manage Load 239 Case Study 2: When Load Shedding Attacks 240 Conclusion 243 Table of Contents\n\n12.\n\nIntroducing Non-Abstract Large System Design. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245 What Is NALSD? 245 Why “Non-Abstract”? 246 AdWords Example 246 Design Process 246 Initial Requirements 247 One Machine 248 Distributed System 251 Conclusion 260\n\n13. Data Processing Pipelines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263 Pipeline Applications 264 Event Processing/Data Transformation to Order or Structure Data 264 Data Analytics 265 Machine Learning 265 Pipeline Best Practices 268 Define and Measure Service Level Objectives 268 Plan for Dependency Failure 270 Create and Maintain Pipeline Documentation 271 Map Your Development Lifecycle 272 Reduce Hotspotting and Workload Patterns 275 Implement Autoscaling and Resource Planning 276 Adhere to Access Control and Security Policies 277 Plan Escalation Paths 277 Pipeline Requirements and Design 277 What Features Do You Need? 278 Idempotent and Two-Phase Mutations 279 Checkpointing 279 Code Patterns 280 Pipeline Production Readiness 281 Pipeline Failures: Prevention and Response 284 Potential Failure Modes 284 Potential Causes 286 Case Study: Spotify 287 Event Delivery 288 Event Delivery System Design and Architecture 289 Event Delivery System Operation 290 Customer Integration and Support 293 Summary 298 Conclusion 299 xi\n\n14. Configuration Design and Best Practices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301 What Is Configuration? 301 Configuration and Reliability 302 Separating Philosophy and Mechanics 303 Configuration Philosophy 303 Configuration Asks Users Questions 305 Questions Should Be Close to User Goals 305 Mandatory and Optional Questions 306 Escaping Simplicity 308 Mechanics of Configuration 308 Separate Configuration and Resulting Data 308 Importance of Tooling 310 Ownership and Change Tracking 312 Safe Configuration Change Application 312 Conclusion 313\n\n15. Configuration Specifics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315 Configuration-Induced Toil 315 Reducing Configuration-Induced Toil 316 Critical Properties and Pitfalls of Configuration Systems 317 Problem 317 Pitfall 2: Designing Accidental or Ad Hoc Language Features 318 Pitfall 3: Building Too Much Domain-Specific Optimization 318 Pitfall 4: Interleaving “Configuration Evaluation” with “Side Effects” 319 Pitfall 5: Using an Existing General-Purpose Scripting Language Like\n\nPython, Ruby, or Lua 319 Integrating a Configuration Language 320 Generating Config in Specific Formats 320 Driving Multiple Applications 321 Integrating an Existing Application: Kubernetes 322 What Kubernetes Provides 322 Example Kubernetes Config 322 Integrating the Configuration Language 323 Integrating Custom Applications (In-House Software) 326 Effectively Operating a Configuration System 329 Versioning 329 Source Control 330 Tooling 330 Testing 330 When to Evaluate Configuration 331 Very Early: Checking in the JSON 331\n\nxii\n\n|\n\nTable of Contents\n\nMiddle of the Road: Evaluate at Build Time 332 Late: Evaluate at Runtime 332 Guarding Against Abusive Configuration 333 Conclusion 334\n\n16. Canarying Releases. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 335 Release Engineering Principles 336 Balancing Release Velocity and Reliability 337 What Is Canarying? 338 Release Engineering and Canarying 338 Requirements of a Canary Process 339 Our Example Setup 339 A Roll Forward Deployment Versus a Simple Canary Deployment 340 Canary Implementation 342 Minimizing Risk to SLOs and the Error Budget 343 Choosing a Canary Population and Duration 343 Selecting and Evaluating Metrics 345 Metrics Should Indicate Problems 345 Metrics Should Be Representative and Attributable 346 Before/After Evaluation Is Risky 347 Use a Gradual Canary for Better Metric Selection 347 Dependencies and Isolation 348 Canarying in Noninteractive Systems 348 Requirements on Monitoring Data 349 Related Concepts 350 Blue/Green Deployment 350 Artificial Load Generation 350 Traffic Teeing 351 Conclusion 351 Identifying and Recovering from Overload. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355 From Load to Overload 356 Case Study 1: Work Overload When Half a Team Leaves 358 Background 358 Problem Statement 358 What We Decided to Do 359 Implementation 359 Lessons Learned 360\n\n16. Canarying Releases. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 335 Release Engineering Principles 336 Balancing Release Velocity and Reliability 337 What Is Canarying? 338 Release Engineering and Canarying 338 Requirements of a Canary Process 339 Our Example Setup 339 A Roll Forward Deployment Versus a Simple Canary Deployment 340 Canary Implementation 342 Minimizing Risk to SLOs and the Error Budget 343 Choosing a Canary Population and Duration 343 Selecting and Evaluating Metrics 345 Metrics Should Indicate Problems 345 Metrics Should Be Representative and Attributable 346 Before/After Evaluation Is Risky 347 Use a Gradual Canary for Better Metric Selection 347 Dependencies and Isolation 348 Canarying in Noninteractive Systems 348 Requirements on Monitoring Data 349 Related Concepts 350 Blue/Green Deployment 350 Artificial Load Generation 350 Traffic Teeing 351 Conclusion 351 Identifying and Recovering from Overload. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355 From Load to Overload 356 Case Study 1: Work Overload When Half a Team Leaves 358 Background 358 Problem Statement 358 What We Decided to Do 359 Implementation 359 Lessons Learned 360\n\nPart III. Processes\n\nTable of Contents\n\n|\n\nxiii\n\nCase Study 2: Perceived Overload After Organizational and Workload\n\nChanges 360 Background 360 Problem Statement 361 What We Decided to Do 362 Implementation 363 Effects 365 Lessons Learned 365 Strategies for Mitigating Overload 366 Recognizing the Symptoms of Overload 366 Reducing Overload and Restoring Team Health 367 Conclusion 369\n\n18. SRE Engagement Model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371 The Service Lifecycle 372 Phase 1: Architecture and Design 372 Phase 2: Active Development 373 Phase 3: Limited Availability 373 Phase 4: General Availability 374 Phase 5: Deprecation 374 Phase 6: Abandoned 374 Phase 7: Unsupported 374 Setting Up the Relationship 375 Communicating Business and Production Priorities 375 Identifying Risks 375 Aligning Goals 375 Setting Ground Rules 379 Planning and Executing 379 Sustaining an Effective Ongoing Relationship 380 Investing Time in Working Better Together 380 Maintaining an Open Line of Communication 380 Performing Regular Service Reviews 381 Reassessing When Ground Rules Start to Slip 381 Adjusting Priorities According to Your SLOs and Error Budget 381 Handling Mistakes Appropriately 382 Scaling SRE to Larger Environments 382 Supporting Multiple Services with a Single SRE Team 382 Structuring a Multiple SRE Team Environment 383 Adapting SRE Team Structures to Changing Circumstances 384 Running Cohesive Distributed SRE Teams 384 Ending the Relationship 385 Case Study 1: Ares 385 Table of Contents\n\n18. SRE Engagement Model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371 The Service Lifecycle 372 Phase 1: Architecture and Design 372 Phase 2: Active Development 373 Phase 3: Limited Availability 373 Phase 4: General Availability 374 Phase 5: Deprecation 374 Phase 6: Abandoned 374 Phase 7: Unsupported 374 Setting Up the Relationship 375 Communicating Business and Production Priorities 375 Identifying Risks 375 Aligning Goals 375 Setting Ground Rules 379 Planning and Executing 379 Sustaining an Effective Ongoing Relationship 380 Investing Time in Working Better Together 380 Maintaining an Open Line of Communication 380 Performing Regular Service Reviews 381 Reassessing When Ground Rules Start to Slip 381 Adjusting Priorities According to Your SLOs and Error Budget 381 Handling Mistakes Appropriately 382 Scaling SRE to Larger Environments 382 Supporting Multiple Services with a Single SRE Team 382 Structuring a Multiple SRE Team Environment 383 Adapting SRE Team Structures to Changing Circumstances 384 Running Cohesive Distributed SRE Teams 384 Ending the Relationship 385 Case Study 1: Ares 385 Table of Contents\n\nCase Study 2: Data Analysis Pipeline 387 Conclusion 389\n\n19. SRE: Reaching Beyond Your Walls. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 391 Truths We Hold to Be Self-Evident 391 Reliability Is the Most Important Feature 391 Your Users, Not Your Monitoring, Decide Your Reliability 392 If You Run a Platform, Then Reliability Is a Partnership 392 Everything Important Eventually Becomes a Platform 393 When Your Customers Have a Hard Time, You Have to Slow Down 393 You Will Need to Practice SRE with Your Customers 393 How to: SRE with Your Customers 394 Step 1: SLOs and SLIs Are How You Speak 394 Step 2: Audit the Monitoring and Build Shared Dashboards 395 Step 3: Measure and Renegotiate 396 Step 4: Design Reviews and Risk Analysis 396 Step 5: Practice, Practice, Practice 397 Be Thoughtful and Disciplined 397 Conclusion 398\n\n20. SRE Team Lifecycles. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399 SRE Practices Without SREs 399 Starting an SRE Role 400 Finding Your First SRE 400 Placing Your First SRE 401 Bootstrapping Your First SRE 402 Distributed SREs 403 Your First SRE Team 403 Forming 404 Storming 405 Norming 408 Performing 411 Making More SRE Teams 413 Service Complexity 413 SRE Rollout 414 Geographical Splits 414 Suggested Practices for Running Many Teams 418 Mission Control 418 SRE Exchange 419 Training 419 Horizontal Projects 419 SRE Mobility 419\n\nTable of Contents\n\n|\n\nxv\n\nTravel 420 Launch Coordination Engineering Teams 420 Production Excellence 421 SRE Funding and Hiring 421 Conclusion 421\n\n21. Organizational Change Management in SRE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423 SRE Embraces Change 423 Introduction to Change Management 424 Lewin’s Three-Stage Model 424 McKinsey’s 7-S Model 424 Kotter’s Eight-Step Process for Leading Change 425 The Prosci ADKAR Model 425 Emotion-Based Models 426 The Deming Cycle 426 How These Theories Apply to SRE 427 Case Study 1: Scaling Waze—From Ad Hoc to Planned Change 427 Background 427 The Messaging Queue: Replacing a System While Maintaining Reliability 427 The Next Cycle of Change: Improving the Deployment Process 429 Lessons Learned 431 Case Study 2: Common Tooling Adoption in SRE 432 Background 432 Problem Statement 433 What We Decided to Do 434 Design 434 Implementation: Monitoring 436 Lessons Learned 436 Conclusion 439 449\n\n21. Organizational Change Management in SRE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423 SRE Embraces Change 423 Introduction to Change Management 424 Lewin’s Three-Stage Model 424 McKinsey’s 7-S Model 424 Kotter’s Eight-Step Process for Leading Change 425 The Prosci ADKAR Model 425 Emotion-Based Models 426 The Deming Cycle 426 How These Theories Apply to SRE 427 Case Study 1: Scaling Waze—From Ad Hoc to Planned Change 427 Background 427 The Messaging Queue: Replacing a System While Maintaining Reliability 427 The Next Cycle of Change: Improving the Deployment Process 429 Lessons Learned 431 Case Study 2: Common Tooling Adoption in SRE 432 Background 432 Problem Statement 433 What We Decided to Do 434 Design 434 Implementation: Monitoring 436 Lessons Learned 436 Conclusion 439 445\n\n21. Organizational Change Management in SRE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423 SRE Embraces Change 423 Introduction to Change Management 424 Lewin’s Three-Stage Model 424 McKinsey’s 7-S Model 424 Kotter’s Eight-Step Process for Leading Change 425 The Prosci ADKAR Model 425 Emotion-Based Models 426 The Deming Cycle 426 How These Theories Apply to SRE 427 Case Study 1: Scaling Waze—From Ad Hoc to Planned Change 427 Background 427 The Messaging Queue: Replacing a System While Maintaining Reliability 427 The Next Cycle of Change: Improving the Deployment Process 429 Lessons Learned 431 Case Study 2: Common Tooling Adoption in SRE 432 Background 432 Problem Statement 433 What We Decided to Do 434 Design 434 Implementation: Monitoring 436 Lessons Learned 436 Conclusion 439 449\n\nConclusion. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441\n\nC. Results of Postmortem Analysis. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 453\n\nIndex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 455\n\nxvi\n\n|\n\nTable of Contents",
      "page_number": 10
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 18-27)",
      "start_page": 18,
      "end_page": 27,
      "detection_method": "topic_boundary",
      "content": "Foreword I\n\nMark Burgess\n\nHaving introduced the first SRE book for O’Reilly, I am honored to be invited back for the sequel. In this book, the writing team is leaving the history of the first book to speak for itself and reaching out to a broader audience, offering direct experiences, case studies, and informal guidance. The broad themes will be familiar to anyone in IT, perhaps relabeled and reprioritized, and with a modern sense of business aware‐ ness. In place of technical descriptions, here we have user-facing services and their promises or objectives. We see human-computer systems originate from within the evolving business, intrinsic to its purpose, rather than as foreign meteorites impact‐ ing an unsuspecting and pristine infrastructure. Cooperation of all human-computer parts is the focus. Indeed, the book might be summarized as follows:\n\nCommit to clear promises that set service objectives, expectations, and levels. • Assess those promises continuously, with metrics and budgetary limits. • React quickly to keep and repair promises, be on-call, and guard autonomy to avoid new gatekeepers.\n\nKeeping promises reliably (to all stakeholders) depends on the stability of all their dependencies, of intent, and of the lives of the people involved (e.g., see Thinking in Promises). Remarkably, the human aspects of human-computer systems only grow alongside the perceived menace of scale: it turns out that automation doesn’t elimi‐ nate humans, after all; rather, it challenges us to reassert human needs across all scales, from the genesis of an individual idea to the massive deployments on behalf of a global user base.\n\nTeaching these lessons is a service challenge in its own right—and, like any service, hard-won knowledge is an iterative process. We make these lessons our own by ques‐ tioning, trying, failing, rehearsing, and perfecting them. There’s a wealth of material to ponder and adapt in the book, so let’s go.\n\nForeword I\n\n|\n\nxvii\n\nForeword II\n\nAndrew Clay Shafer\n\nWhen I found out people were working on a second SRE book, I reached out and asked if I could write a few words. The principles from the first SRE book align so well with what I always imagined DevOps to be, and the practices are insightful, even when they aren’t 100% applicable outside of Google. After reading the principles from the first SRE book for the first time—embracing risk (Chapter 3), service level objectives (Chapter 4), and eliminating toil (Chapter 5)—I wanted to shout that mes‐ sage from the rooftops. “Embracing risk” resonated so much because I had used simi‐ lar language many times to help traditional organizations motivate change. Chapter 6 was always an implicit DevOps goal, both to allow humans more time for creative higher-order work and to allow them to be more human. But I really fell in love with “service level objectives.” I love that the language and the process create a dispassion‐ ate contract between operational considerations and delivering new functionality. The SRE, SWE (software engineer), and business all agree that the service has to be up to be valuable, and the SRE solution quantifies objectives to drive actions and pri‐ orities. The solution—make the service level a target, and when you are below the tar‐ get prioritize reliability over features—eliminates a classic conflict between operations and developers. This is a simple and elegant reframing that solves prob‐ lems by not having them. I give these three chapters as a homework assignment to almost everyone I’ve met since. They are that good. Everyone should know. Tell all your friends. I’ve told all mine.\n\nThe last decade of my career has been focused on helping people deliver software with better tools and process. Sometimes people say I contributed to inventing DevOps, but I was just in the position to borrow and steal successful patterns from across many different organizations and projects. I get embarrassed when people say “DevOps” was invented by anyone, but especially by me. I don’t consider myself an expert in anything but being inquisitive. My idealized DevOps always patterned off whatever information I could extract or infer from my friends, and my friends happened to be building the internet. I had the privilege of behind-the-scenes access\n\nForeword II\n\n|\n\nxix\n\nto people deploying and operating a representative sample of the world’s most incredible infrastructures and applications. DevOps symbolizes aspects of the emer‐ gent and existential optimizations required to rapidly deliver highly available soft‐ ware over the internet. The shift from software delivered on physical media to software delivered as a service forced an evolution of tools and processes. This evolu‐ tion elevated operations’ contribution to the value chain. If the systems are down, the software has no value. The good news is, you don’t have to wait for shipping the next shrink-wrapped box to change the software. For some, this is also the bad news. I simply had the opportunity and perspective to articulate the most successful patterns of the new way to a receptive audience.\n\nIn 2008, before we used the word DevOps like we do now, I’d been through the dot- com collapse, grad school, and a couple of venture-funded rollercoaster rides as a developer—searching Google for answers daily the whole time. I was working on Puppet full-time and I was fascinated by the potential for automation to transform IT organizations. Puppet thrust me into solving problems in the operations domain. At this time, Google used Puppet to manage their corporate Linux and OS X worksta‐ tions at a scale that pushed the capabilities of the Puppet server. We had a great working relationship with Google, but Google kept certain details of their internal operations secret as a matter of policy. I know this because I’m naturally curious and was constantly seeking more information. I always knew Google must have great internal tools and processes, but what these tools and processes were wasn’t always apparent. Eventually, I accepted that asking deep questions about Borg probably meant the current conversation wasn’t going very far. I would have loved to know more about how Google did everything, but this simply wasn’t allowed at the time. The significance of 2008 also includes the first O’Reilly Velocity conference and the year I met Patrick Debois. “DevOps” wasn’t a thing yet, but it was about to be. The time was right. The world was ready. DevOps symbolized a new way, a better way. If Site Reliability Engineering had been published then, I believe the community that formed would have rallied to fly the “eliminate toil” flag and the term DevOps might have never existed. Counterfactuals notwithstanding, I know the first SRE book per‐ sonally advanced my understanding of the possible, and I already helped many others just with the SRE principles.\n\nIn the early days of the DevOps movement, we consciously avoided codifying practi‐ ces because everything was evolving so rapidly and we didn’t want to set limits on what DevOps could become. Plus, we explicitly didn’t want anyone to “own” DevOps. When I wrote about DevOps in 2010, I made three distinct points. First, developers and operations can and should work together. Second, system administra‐ tion will become more and more like software development. Finally, sharing with a global community of practice accelerates and multiplies our collective capabilities. Around the same time, my friends Damon Edward and John Willis coined the acronym CAMS for Culture, Automation, Metrics, and Sharing. Jez Humble later\n\nxx\n\n|\n\nForeword II\n\nexpanded this acronym to CALMS by adding Lean continuous improvement. What each of these words might mean in context deserves to be a full book, but I mention them here because Site Reliability Engineering explicitly references Culture, Automa‐ tion, Metrics, and Sharing alongside anecdotes about Google’s journey to continu‐ ously improve. By publishing the first SRE book, Google shared their principles and practices with the global community. Now I define DevOps simply as “optimizing human performance and experience operating software, with software, and with humans.” I don’t want to put words in anyone’s mouth, but that seems like a great way to describe SRE as well.\n\nUltimately, I know DevOps when I see it and I see SRE at Google, in theory and prac‐ tice, as one of the most advanced implementations. Good IT operations has always depended on good engineering, and solving operations problems with software has always been central to DevOps. Site Reliability Engineering makes the engineering aspect even more explicit. I cringe when I hear someone say “SRE versus DevOps.” For me, they are inseparable in time and space, as labels describing the sociotechnical systems that deliver modern infrastructure with software. I consider DevOps a loose generic set of principles and SRE an advanced explicit implementation. A parallel analogy would be the relationship between Agile and Extreme Programming (XP). True, XP is Agile, arguably the best of Agile, but not all organizations are capable of or willing to adopt XP.\n\nSome say “software is eating the world,” and I understand why they do, but “soft‐ ware” alone is not the right framing. Without the ubiquity of computational hard‐ ware connected with high-speed networks, much of what we take for granted as “software” would not be possible. This is an undeniable truth. What I think many miss in this conversation about technology are the humans. Technology exists because of humans and hopefully for humans, but if you look a little deeper, you also realize that the software we rely on, and probably take for granted, is largely depen‐ dent on humans. We rely on software, but software also relies on us. This is a single interconnected system of imperfect hardware—software and humans relying on themselves to build the future. Reliability is eating the world. Reliability is not just about technology, though, but also about people. The people and the technology form a single technosocial system. One nice feature about having Google share SRE with the rest of the industry is that any excuses about what kind of processes work at scale became invalid. Google set the highest standard for both reliability and scale. There might be valid arguments about why someone can’t adopt Google SRE practi‐ ces directly, but the guiding principles should still apply. As I look at the landscape of possibilities to build the future and the ambition to transform human experience with software, I see a lot of ambitious projects to quite literally connect everything to the internet. My math says that the successful projects will find themselves ingesting and indexing incredible amounts of data. Few, if any, will surpass the scale of Google today, but some will be the same size Google was when they started SRE and will\n\nForeword II\n\n|\n\nxxi\n\nneed to solve the same reliability problems. I contend that in these cases, adopting tools and process that look suspiciously like SRE is not optional but existential— though there is no need to wait for that crisis because SRE principles and practices apply at any scale.\n\nSRE is usually framed as how Google does operations, but that misses the bigger pic‐ ture: SRE in practice enables software engineering, but also transforms architecture, security, governance, and compliance. When we leverage the SRE focus on providing a platform of services, all these other considerations get to have first-class emphasis, but where and how that happens may be quite different. Just like SRE (and hopefully DevOps) shifted more and more of the burden to software engineering, modern architecture and security practices evolve from slides, checklists, and hope to ena‐ bling the right behaviors with running code. Organizations adopting SRE principles and practices without revisiting these other aspects lose a huge opportunity to improve, and will also probably meet with internal resistance if the people who con‐ sider themselves responsible for those aspects are not converted into allies.\n\nI always enjoy learning. I read every word of the first SRE book straight through. I loved the language. I loved the anecdotes. I loved understanding more about how Google sees itself. But the question for me is always, “What behavior will I change?” Learning isn’t collecting information. Learning is changing behavior. This is easy to determine or even quantify in certain disciplines. You have learned to play a new song when you can play the song. You are better at chess when you win games against stronger players. Site Reliability Engineering, like DevOps, should not just be changing titles, but making definitive behavior changes, focusing on outcomes and obviously reliability. The Site Reliability Workbook promises to move forward from an enumeration of principles and practices by Google for Google toward more con‐ textual actions and behaviors. Site reliability is for everyone, but reliability doesn’t come from reading books. Here’s to embracing risk and eliminating toil.\n\nxxii\n\n|\n\nForeword II\n\nPreface\n\nWhen we wrote the original Site Reliability Engineering book, we had a goal: explain the philosophy and the principles of production engineering and operations at Goo‐ gle. The book was our attempt to share our teams’ best practices and lessons with the rest of the computing world. We assumed that the SRE book might appeal to a mod‐ est number of engineers working in large, reliability-conscious endeavors, and that both the quantity and the focus of the content would tend to limit the book’s appeal.\n\nAs it turned out, we were happily mistaken on both counts.\n\nTo our surprise and delight, the SRE book was a best-seller in computing for an exhilarating period after its release, and it was not just being sold or downloaded; it was being read. We received questions from around the world about the book, the team, the practices, and the outcomes. We were asked to speak about chapters, approaches, and incidents. We found ourselves in the unexpected position of having to turn down outside requests because we were out of cycles.\n\nLike most success disasters, the SRE book created an opportunity to respond with human effort (“Hire more people! Do more speaking engagements!”) or with some‐ thing more scalable. And being SREs, it will surprise few readers that we gravitated toward the latter approach. We decided to write a second SRE book—one that expan‐ ded on the content we were most frequently being asked to speak about, and that addressed the most common questions readers had about the first book.\n\nOut of the many different questions, requests, and comments we received about the first SRE book, two themes were particularly interesting to us; if left unaddressed, they were barriers to putting SRE’s lessons to productive use. These themes are collo‐ quially summarized as:\n\nPrinciples are interesting, but how do I turn them into practice in my project/ team/company?\n\nPreface\n\n|\n\nxxiii\n\nSRE’s approach would not work for me; it is feasible only in Google’s culture, and makes sense only at Google’s scale.\n\nThe purpose of this second SRE book is (a) to add more implementation detail to the principles outlined in the first volume, and (b) to dispel the idea that SRE is imple‐ mentable only at “Google scale” or in “Google culture.”\n\nThis volume is a companion to the previous work—not a new version. The two books should be taken together as a pair. You will get the most from this book if you’re already familiar with its predecessor. The first SRE book is available online for free.\n\nBy design, the structure of this book roughly follows the structure of the first volume. We want you to be able to read the chapters in tandem. Each chapter in this volume assumes you’re familiar with its counterpart from the previous work; our goal is to allow you to jump back and forth between principle and practice as you go. That way, you can use both volumes as ongoing references.\n\nNext, a word about ethos: We heard from some readers that while describing Goo‐ gle’s journey toward better operations we concentrated too much on just us. Some readers suggested that we were too removed from the practicalities of the world out‐ side Google, and failed to address the interaction of our ideas with the principles of DevOps. That’s an entirely fair criticism that we’ve tried to take to heart in this vol‐ ume.\n\nHowever, we do think that the highly opinionated nature of SRE contributes to its usefulness as a discipline. To us that’s a feature, not a bug. We do not advocate that SRE is the only way (or even universally the best way) to build and operate highly reliable systems. It’s just the way that has been most successful for us.\n\nWe’ll also spend a few words talking about how SRE and DevOps relate to each other. The important point to keep in mind is that they are not in conflict.\n\nWe’d like to acknowledge up front that this volume is necessarily incomplete. The SRE discipline is a broad field even inside the confines of Google, and it is evolving even faster now that it’s practiced widely outside of Google. Rather than go broad and superficial, we focused this volume to answer the most requested implementation details from the first volume.\n\nFinally, this volume and its predecessor are not intended to be gospel. Please don’t treat them that way. Even after all these years, we’re still finding conditions and cases that cause us to tweak (or in some cases, replace) previously firmly held beliefs. SRE is a journey as much as it is a discipline.\n\nWe hope that you enjoy what you read in these pages and find the book useful. Assembling it has been a labor of love. We’re delighted that there’s a growing and skilled community of SRE professionals with whom we can learn and improve.\n\nxxiv\n\n| Preface\n\nAs always, your direct feedback is much appreciated. It teaches us something valuable every time you contribute it.\n\nHow to Read This Book This book is the companion volume to Google’s first book, Site Reliability Engineer‐ ing. To get the most out of this volume, we recommend that you have read, or can refer to, the first SRE book (available to read online for free at google.com/sre). The two works complement each other in the following ways:\n\nThe previous work was an introduction to principles and philosophy. This vol‐ ume concentrates on how those principles are applied. (In a few areas—particu‐ larly configuration management and canarying—we also cover some new ground to provide background for the practical treatment of other subjects.)\n\nThe earlier volume concentrated exclusively on how SRE is practiced at Google. This work includes perspectives from a number of other firms—from traditional enterprises (including The Home Depot and the New York Times) to digital natives (Evernote, Spotify, and others).\n\nThe first book didn’t directly refer to the larger operations community—espe‐ cially DevOps—whereas this book speaks directly to how SRE and DevOps relate to each other.\n\nThis volume assumes that you will bounce between this volume and its predecessor. You might, for example, read Chapter 4, “Service Level Objectives” in the first book and then read its implementation complement (Chapter 2) in this volume.\n\nThis book assumes that every chapter is just the starting point for a longer discussion and journey. Accordingly, this book is intended to be a conversation starter rather than the last word.\n\n—The Editors\n\nConventions Used in This Book The following typographical conventions are used in this book:\n\nItalic\n\nIndicates new terms, URLs, email addresses, filenames, and file extensions.\n\nConstant width\n\nUsed for program listings, as well as within paragraphs to refer to program ele‐ ments such as variable or function names, databases, data types, environment variables, statements, and keywords.\n\nPreface\n\n|\n\nxxv\n\nConstant width bold\n\nShows commands or other text that should be typed literally by the user.\n\nConstant width italic\n\nShows text that should be replaced with user-supplied values or by values deter‐ mined by context.\n\nThis element signifies a tip or suggestion.\n\nThis element signifies a general note.\n\nThis element indicates a warning or caution.\n\nUsing Code Examples Supplemental material (code examples, exercises, etc.) is available for download at http://g.co/SiteReliabilityWorkbookMaterials.\n\nThis book is here to help you get your job done. In general, if example code is offered with this book, you may use it in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing a CD-ROM of examples from O’Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a signifi‐ cant amount of example code from this book into your product’s documentation does require permission.\n\nWe appreciate, but do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: “The Site Reliability Workbook, edi‐ ted by Betsy Beyer, Niall Richard Murphy, David K. Rensin, Kent Kawahara, and Ste‐ phen Thorne (O’Reilly). Copyright 2018 Google LLC, 978-1-492-02950-2.”\n\nxxvi\n\n| Preface\n\nIf you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at permissions@oreilly.com.\n\nO’Reilly Safari\n\nSafari (formerly Safari Books Online) is a membership-based training and reference platform for enterprise, government, educators, and individuals.\n\nMembers have access to thousands of books, training videos, Learning Paths, interac‐ tive tutorials, and curated playlists from over 250 publishers, including O’Reilly Media, Harvard Business Review, Prentice Hall Professional, Addison-Wesley Pro‐ fessional, Microsoft Press, Sams, Que, Peachpit Press, Adobe, Focal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones & Bartlett, and Course Technology, among others.\n\nFor more information, please visit http://oreilly.com/safari.\n\nHow to Contact Us Please address comments and questions concerning this book to the publisher:\n\nO’Reilly Media, Inc. 1005 Gravenstein Highway North Sebastopol, CA 95472 800-998-9938 (in the United States or Canada) 707-829-0515 (international or local) 707-829-0104 (fax)\n\nWe have a web page for this book, where we list errata, examples, and any additional information. You can access this page at http://bit.ly/siteReliabilityWkbk.\n\nTo comment or ask technical questions about this book, send email to bookquestions@oreilly.com.\n\nFor more information about our books, courses, conferences, and news, see our web‐ site at http://www.oreilly.com.\n\nFind us on Facebook: http://facebook.com/oreilly\n\nFollow us on Twitter: http://twitter.com/oreillymedia\n\nWatch us on YouTube: http://www.youtube.com/oreillymedia\n\nPreface\n\n|\n\nxxvii",
      "page_number": 18
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 28-35)",
      "start_page": 28,
      "end_page": 35,
      "detection_method": "topic_boundary",
      "content": "Acknowledgments This book is the product of the enthusiastic and generous contributions of more than 100 people, including authors, tech writers, and reviewers. Each chapter has a byline for the individual authors and tech writers. We’d also like to take a moment to thank everyone not listed there.\n\nWe would like to thank the following reviewers for providing valuable (and some‐ times pointed) feedback: Abe Hassan, Alex Perry, Cara Donnelly, Chris Jones, Cody Smith, Dermot Duffy, Jarrod Todd, Jay Judkowitz, John T. Reese, Liz Fong-Jones, Mike Danese, Murali Suriar, Narayan Desai, Niccolò Cascarano, Ralph Pearson, Salim Virji, Todd Underwood, Vivek Rau, and Zoltan Egyed.\n\nWe would like to express our deepest appreciation to the following people for serving as our overall quality bar for this volume. They made substantial contributions throughout the entire volume: Alex Matey, Max Luebbe, Matt Brown, and JC van Winkel.\n\nAs the leaders of Google SRE, Benjamin Treynor Sloss and Ben Lutch were this book’s primary executive sponsors within Google; their strong and unwavering belief in a follow-up project that was a worthy companion of the first SRE book was essen‐ tial to making this book happen.\n\nWhile the authors and technical writers are specifically acknowledged in each chap‐ ter, we’d like to recognize those that contributed to each chapter by providing thoughtful input, discussion, and review. In chapter order, they are:\n\nChapter 2: Javier Kohen, Patrick Eaton, Richard Bondi, Yaniv Aknin\n\nChapter 4: Alex Matey, Clint Pauline, Cody Smith, JC van Winkel, Ola Kłapciń‐ ska, Štěpán Davidovič\n\nChapter 5: Alex Matey, Clint Pauline, Cody Smith, Iain Cooke, JC van Winkel, Štěpán Davidovič\n\nChapter 6: Dermot Duffy, James O’Keeffe, Stephen Thorne\n\nChapter 7: Mark Brody\n\nChapter 8: Alex Perry, Alex Hidalgo, David Huska, Sebastian Kirsch, Sabrina Farmer, Steven Carstensen, Liz Fong-Jones, Nandu Shah (Evernote), Robert Hol‐ ley (Evernote)\n\nChapter 9: Alex Hidalgo, Alex Matey, Alex Perry, Dave Rensin, Matt Brown, Tor Gunnar Houeland, Trevor Strohman\n\nChapter 10: John T. Reese\n\nxxviii\n\n| Preface\n\nChapter 11: Daniel E. Eisenbud, Dave Rensin, Dmitry Nefedkin, Dževad Tru‐ mić, Edward Wu (Niantic), JC van Winkel, Lucas Pereira, Luke Stone, Matt Brown, Natalia Sakowska, Niall Richard Murphy, Phil Keslin (Niantic), Rita Sodt, Scott Devoid, Simon Donovan, Tomasz Kulczyński\n\nChapter 12: Ivo Krka, Matt Brown, Nicky Nicolosi, Tanya Reilly\n\nChapter 13: Bartosz Janota (Spotify), Cara Donnelly, Chris Farrar, Johannes Rußek (Spotify), Max Charas, Max Luebbe, Michelle Duffy, Nelson Arapé (Spo‐ tify), Riccardo Petrocco (Spotify), Rickard Zwahlen (Spotify), Robert Stephenson (Spotify), Steven Thurgood\n\nChapter 14: Charlene Perez, Dave Cunningham, Dave Rensin, JC van Winkel, John Reese, Stephen Thorne\n\nChapter 15: Alex Matey, Bo Shi, Charlene Perez, Dave Rensin, Eric Johnson, Juliette Benton, Lars Wander, Mike Danese, Narayan Desai, Niall Richard Mur‐ phy, Štěpán Davidovič, Stephen Thorne\n\nChapter 16: Alex Matey, Liz Fong-Jones, Max Luebbe\n\nChapter 17: Andrew Harvey, Aleksander Szymanek, Brad Kratochvil, Ed Wehr‐ wein, Duncan Sargeant, Jessika Reissland, Matt Brown, Piotr Sieklucki and Tho‐ mas Adamcik\n\nChapter 18: Brian Balser (New York Times), Deep Kapadia (New York Times), Michelle Duffy, Xavier Llorà\n\nChapter 19: Matt Brown\n\nChapter 20: Brian Balser (New York Times), Christophe Kalt, Daniel Rogers, Max Luebbe, Niall Richard Murphy, Ramón Medrano Llamas, Richard Bondi, Steven Carstensen, Stephen Thorne, Steven Thurgood, Thomas Wright\n\nChapter 21: Dave Rensin, JC Van Winkel, Max Luebbe, Ronen Louvton, Ste‐ phen Thorne, Tom Feiner, Tsiki Rosenman\n\nWe are also grateful to the following contributors, who supplied significant expertise or resources, or had some otherwise excellent effect on this work: Caleb Donaldson, Charlene Perez, Evan Leonard, Jennifer Petoff, Juliette Benton, and Lea Miller.\n\nWe very much appreciate the thoughtful and in-depth feedback that we received from industry reviewers: Mark Burgess, David Blank-Edelman, John Looney, Jennifer Davis, Björn Rabenstein, Susan Fowler, Thomas A. Limoncelli, James Meickle, Theo Schlossangle, Jez Humble, Alice Goldfuss, Arup Chakrabarti, John Allspaw, Angus Lees, Eric Liang, Brendan Gregg, and Bryan Liles.\n\nWe would like to extend a special thanks to Shylaja Nukala, who generously commit‐ ted the time and skills of the SRE Technical Writing Team. She enthusiastically sup‐ ported their necessary and valued efforts.\n\nPreface\n\n|\n\nxxix\n\nThanks also to the O’Reilly Media team—Virginia Wilson, Kristen Brown, Rachel Monaghan, Nikki McDonald, Melanie Yarbrough, and Gloria Lukos—for their help and support making the book a reality in our ambitious timeline.\n\nAnd an extra special thanks to Niall Richard Murphy: despite the fact that he moved on from Google before this book hit the shelves, his continual insights and dedication were crucial for getting a goodly portion of meaningful content over the finish line. His leadership, thoughtfulness, tenacity, and wit are nothing short of inspirational!\n\nFinally, the editors would also like to personally thank the following people:\n\nBetsy Beyer: To Grandmother, my go-to source for encouragement, inspiration, popcorn, pep, and puzzling. You made both this book and my everyday life bet‐ ter! To Duzzie, Hammer, Joan, Kiki, and Mini (note the alphabetical order—ha!) who helped shape me into the obsessive writer slash person I am today. And of course, Riba, for providing the DMD and other provisions necessary to fuel this effort.\n\nNiall Richard Murphy: To Léan, Oisín, Fiachra, and Kay, north stars. To some‐ one whose protestations of self-interest are entirely out of odds with how he acts. To Sharon, more influential than she knows. To Alex, in a light-filled sitting room, with a cup of tea, a book, a box of dice, and thou.\n\nStephen Thorne: To my mum and dad, who have always encouraged me to push myself. To my wife, Elspeth. To my colleagues who have given me more respect and encouragement than I think I deserve: Ola, Štěpán, Perry, and David.\n\nDave Rensin: After I wrote my first book, I swore I’d never write another. That was six books ago and I say exactly the same thing each time. To my wife, Lia, who gives me the space to do it and never says “I told you so.” (Even though she tells me so.) To my colleagues at Google—and particularly to the family of SRE— who have taught me more these last few years about production engineering at scale than I had learned in the previous 20. Finally, to Benjamin Treynor Sloss, who interviewed me and convinced me to come to Google in the first place.\n\nKent Kawahara: To my parents, Denby and Setsuko, and my Aunt Asako for helping me get to where I am. To my siblings, Randy and Patti, for their support over the years. To my wife, Angela, and my sons, Ryan, Ethan, and Brady, for their love and support. Finally, to the core team of Dave, Betsy, Niall, Juliette, and Stephen, I feel honored to have worked with you on this project.\n\nxxx\n\n| Preface\n\nCHAPTER 1 How SRE Relates to DevOps class SRE implements interface DevOps\n\nBy Niall Richard Murphy, Liz Fong-Jones, and Betsy Beyer, with Todd Underwood, Laura Nolan, and Dave Rensin\n\nOperations, as a discipline, is hard.1 Not only is there the generally unsolved question of how to run systems well, but the best practices that have been found to work are highly context-dependent and far from widely adopted. There is also the largely unaddressed question of how to run operations teams well. Detailed analysis of these topics is generally thought to originate with Operational Research devoted to improving processes and output in the Allied military during World War II, but in reality, we have been thinking about how to operate things better for millennia.\n\nYet, despite all this effort and thought, reliable production operations remains elusive —particularly in the domains of information technology and software operability. The enterprise world, for example, often treats operations as a cost center,2 which makes meaningful improvements in outcomes difficult if not impossible. The tre‐ mendous short-sightedness of this approach is not yet widely understood, but dissat‐ isfaction with it has given rise to a revolution in how to organize what we do in IT.\n\n1 Note that as this discussion appears in a book about SRE, some of this discussion is specific to software ser‐\n\nvice operations, as opposed to IT operations.\n\n2 Mary Poppendieck has an excellent article on this called “The Cost Center Trap.” Another way in which this approach fails is when a very large and improbable disaster completely wipes out the cost savings you made by moving to a low-grade operations model (c.f. the British Airways outage in May 2017).\n\n1\n\nThat revolution stemmed from trying to solve a common set of problems. The newest solutions to these problems are called by two separate names—DevOps and Site Reli‐ ability Engineering (SRE). Although we talk about them individually as if they are totally separate reactions to the enterprise mentality just described,3 we hope to per‐ suade you that in fact they are much more alike, and practitioners of each have much more in common, than you might assume.\n\nBut first, some background on the key tenets of each.\n\nBackground on DevOps DevOps is a loose set of practices, guidelines, and culture designed to break down silos in IT development, operations, networking, and security. Articulated by John Willis, Damon Edwards, and Jez Humble, CA(L)MS—which stands for Culture, Automation, Lean (as in Lean management; also see continuous delivery), Measure‐ ment, and Sharing—is a useful acronym for remembering the key points of DevOps philosophy. Sharing and collaboration are at the forefront of this movement. In a DevOps approach, you improve something (often by automating it), measure the results, and share those results with colleagues so the whole organization can improve. All of the CALMS principles are facilitated by a supportive culture.\n\nDevOps, Agile, and a variety of other business and software reengineering techniques are all examples of a general worldview on how best to do business in the modern world. None of the elements in the DevOps philosophy are easily separable from each other, and this is essentially by design. There are, however, a few key ideas that can be discussed in relative isolation.\n\nNo More Silos The first key idea is no more silos. This is a reaction to a couple ideas:\n\nThe historically popular but now increasingly old-fashioned arrangement of sep‐ arate operations and development teams\n\nThe fact that extreme siloization of knowledge, incentives for purely local opti‐ mization, and lack of collaboration have in many cases been actively bad for business4\n\n3 Of course, there are a number of other potential reactions. For example, ITIL® is another approach to IT man‐\n\nagement that advocates for better standardization.\n\n4 Note also that because this is a complicated world, there are also positive effects to partitioning, silos, and the\n\nlike, but the downsides seem to be particularly pernicious in the domain of operations.\n\n2\n\n|\n\nChapter 1: How SRE Relates to DevOps\n\nAccidents Are Normal The second key idea is that accidents are not just a result of the isolated actions of an individual, but rather result from missing safeguards for when things inevitably go wrong.5 For example, a bad interface inadvertently encourages the wrong action under pressure; a system misfeature makes failure inevitable if the (unarticulated) wrong circumstances occur; broken monitoring makes it impossible to know if some‐ thing is wrong, never mind what is wrong. Some more traditionally minded busi‐ nesses possess the cultural instinct to root out the mistake maker and punish them. But doing so has its own consequences: most obviously, it creates incentives to con‐ fuse issues, hide the truth, and blame others, all of which are ultimately unprofitable distractions. Therefore, it is more profitable to focus on speeding recovery than pre‐ venting accidents.\n\nChange Should Be Gradual The third key idea is that change is best when it is small and frequent. In environ‐ ments where change committees meet monthly to discuss thoroughly documented plans to make changes to the mainframe configuration, this is a radical idea. How‐ ever, this is not a new idea. The notion that all changes must be considered by experi‐ enced humans and batched for efficient consideration turns out to be more or less the opposite of best practice. Change is risky, true, but the correct response is to split up your changes into smaller subcomponents where possible. Then you build a steady pipeline of low-risk change out of regular output from product, design, and infra‐ structure changes.6 This strategy, coupled with automatic testing of smaller changes and reliable rollback of bad changes, leads to approaches to change management like continuous integration (CI) and continuous delivery or deployment (CD).\n\nTooling and Culture Are Interrelated Tooling is an important component of DevOps, particularly given the emphasis on managing change correctly—today, change management relies on highly specific tools. Overall, however, proponents of DevOps strongly emphasize organizational culture—rather than tooling—as the key to success in adopting a new way of work‐ ing. A good culture can work around broken tooling, but the opposite rarely holds true. As the saying goes, culture eats strategy for breakfast. Like operations, change itself is hard.\n\n5 See https://en.wikipedia.org/wiki/Normal_Accidents.\n\n6 Higher-risk changes, or those unvalidatable by automatic means, should obviously still be vetted by humans,\n\nif not enacted by them.\n\nBackground on DevOps\n\n|\n\n3\n\nMeasurement Is Crucial Finally, measurement is particularly crucial in the overall business context of, for example, breaking down silos and incident resolution. In each of these environments, you establish the reality of what’s happening by means of objective measurement, verify that you’re changing the situation as you expect, and create an objective foun‐ dation for conversations that different functions agree upon. (This applies in both business and other contexts, such as on-call.)\n\nBackground on SRE Site Reliability Engineering (SRE) is a term (and associated job role) coined by Ben Treynor Sloss, a VP of engineering at Google.7 As we can see in the previous section, DevOps is a broad set of principles about whole-lifecycle collaboration between oper‐ ations and product development. SRE is a job role, a set of practices (described next) we’ve found to work, and some beliefs that animate those practices. If you think of DevOps as a philosophy and an approach to working, you can argue that SRE imple‐ ments some of the philosophy that DevOps describes, and is somewhat closer to a concrete definition of a job or role than, say, “DevOps engineer.”8 So, in a way, class SRE implements interface DevOps.\n\nUnlike the DevOps movement, which originated from collaborations between leaders and practitioners at multiple companies, SRE at Google inherited much of its culture from the surrounding company before the term SRE became widely popularized across the industry. Given that trajectory, the discipline as a whole currently does not foreground cultural change by default quite as much as DevOps. (That doesn’t imply anything about whether cultural change is necessary to do SRE in an arbitrary orga‐ nization, of course.)\n\nSRE is defined by the following concrete principles.\n\nOperations Is a Software Problem The basic tenet of SRE is that doing operations well is a software problem. SRE should therefore use software engineering approaches to solve that problem. This is across a wide field of view, encompassing everything from process and business\n\n7 The history of SRE at Google is that it sprang from a precursor team, which was more operationally focused,\n\nand Ben provided the impetus for treating the problem from an engineering standpoint.\n\n8 This is a misnomer in a large number of ways, perhaps the most fundamental being that you can’t just hire\n\nsome people, call them “DevOps engineers,” and expect benefits immediately. You have to buy into the whole philosophy of changing how you work in order to benefit. As Andrew Clay Shafer says, “People sell DevOps, but you can’t buy it.” And, as Seth Vargo points out in “The 10 Myths of DevOps”, you can’t “hire a DevOp to fix your organization.”\n\n4\n\n|\n\nChapter 1: How SRE Relates to DevOps\n\nchange to similarly complicated but more traditional software problems, such as rewriting a stack to eliminate single points of failure in business logic.\n\nManage by Service Level Objectives (SLOs) SRE does not attempt to give everything 100% availability. As discussed in our first book, Site Reliability Engineering, this is the wrong target for a number of reasons. Instead, the product team and the SRE team select an appropriate availability target for the service and its user base, and the service is managed to that SLO.9 Deciding on such a target requires strong collaboration from the business. SLOs have cultural implications as well: as collaborative decisions among stakeholders, SLO violations bring teams back to the drawing board, blamelessly.\n\nWork to Minimize Toil For SRE, any manual, structurally mandated operational task is abhorrent. (That doesn’t mean we don’t have any such operations: we have plenty of them. We just don’t like them.) We believe that if a machine can perform a desired operation, then a machine often should. This is a distinction (and a value) not often seen in other organizations, where toil is the job, and that’s what you’re paying a person to do. For SRE in the Google context, toil is not the job—it can’t be. Any time spent on opera‐ tional tasks means time not spent on project work—and project work is how we make our services more reliable and scalable.\n\nPerforming operational tasks does, however, by “the wisdom of production,” provide vital input into decisions. This work keeps us grounded by providing real-time feed‐ back from a given system. Sources of toil need to be identifiable so you can minimize or eliminate them. However, if you find yourself in a position of operational under‐ load, you may need to push new features and changes more often so that engineers remain familiar with the workings of the service you support.\n\nThe Wisdom of Production A note on “the wisdom of production”: by this phrase, we mean the wisdom you get from something running in production—the messy details of how it actually behaves, and how software should actually be designed, rather than a whiteboarded view of a service isolated from the facts on the ground. All of the pages you get, the tickets the team gets, and so on, are a direct connection with reality that should inform better system design and behavior.\n\n9 A service level objective is a target for performance of a particular metric (e.g., available 99.9% of the time).\n\nBackground on SRE\n\n|\n\n5",
      "page_number": 28
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 36-44)",
      "start_page": 36,
      "end_page": 44,
      "detection_method": "topic_boundary",
      "content": "Automate This Year’s Job Away The real work in this area is determining what to automate, under what conditions, and how to automate it.\n\nSRE as practiced in Google has a hard limit of how much time a team member can spend on toil, as opposed to engineering that produces lasting value: 50%. Many peo‐ ple think of this limit as a cap. In fact, it’s much more useful to think of it as a guaran‐ tee—an explicit statement, and enabling mechanism, for taking an engineering-based approach to problems rather than just toiling at them over and over.\n\nThere is an unintuitive and interesting interaction between this benchmark and how it plays out when we think about automation and toil. Over time, an SRE team winds up automating all that it can for a service, leaving behind things that can’t be automa‐ ted (the Murphy-Beyer effect). Other things being equal, this comes to dominate what an SRE team does unless other actions are taken. In the Google environment, you tend to either add more services, up to some limit that still supports 50% engi‐ neering time, or you are so successful at your automation that you can go and do something else completely different instead.\n\nMove Fast by Reducing the Cost of Failure One of the main benefits of SRE engagement is not necessarily increased reliability, although obviously that does happen; it is actually improved product development output. Why? Well, a reduced mean time to repair (MTTR) for common faults results in increased product developer velocity, as engineers don’t have to waste time and focus cleaning up after these issues. This follows from the well-known fact that the later in the product lifecycle a problem is discovered, the more expensive it is to fix. SREs are specifically charged with improving undesirably late problem discovery, yielding benefits for the company as a whole.\n\nShare Ownership with Developers Rigid boundaries between “application development” and “production” (sometimes called programmers and operators) are counterproductive. This is especially true if the segregation of responsibilities and classification of ops as a cost center leads to power imbalances or discrepancies in esteem or pay.\n\nSREs tend to be inclined to focus on production problems rather than business logic problems, but as their approach brings software engineering tools to bear on the problem, they share skill sets with product development teams. In general, an SRE has particular expertise around the availability, latency, performance, efficiency, change management, monitoring, emergency response, and capacity planning of the service(s) they are looking after. Those specific (and usually well-defined) competen‐ cies are the bread-and-butter of what SRE does for a product and for the associated\n\n6\n\n|\n\nChapter 1: How SRE Relates to DevOps\n\nproduct development team.10 Ideally, both product development and SRE teams should have a holistic view of the stack—the frontend, backend, libraries, storage, kernels, and physical machine—and no team should jealously own single compo‐ nents. It turns out that you can get a lot more done if you “blur the lines”11 and have SREs instrument JavaScript, or product developers qualify kernels: knowledge of how to make changes and the authority to do so are much more widespread, and incen‐ tives to jealously guard any particular function are removed.\n\nIn Site Reliability Engineering, we did not make it sufficiently clear that product development teams in Google own their service by default. SRE is neither available nor warranted for the bulk of services, although SRE principles still inform how serv‐ ices are managed throughout Google.12 The ownership model when an SRE team works with a product development team is ultimately a shared model as well.\n\nUse the Same Tooling, Regardless of Function or Job Title Tooling is an incredibly important determinant of behavior, and it would be naive to assume that the efficacy of SRE in the Google context has nothing to do with the widely accessible unified codebase, the wide array of software and systems tooling, the highly optimized and proprietary production stack, and so on. Yet we share this absolute assumption with DevOps: teams minding a service13 should use the same tools, regardless of their role in the organization. There is no good way to manage a service that has one tool for the SREs and another for the product developers, behav‐ ing differently (and potentially catastrophically so) in different situations. The more divergence you have, the less your company benefits from each effort to improve each individual tool.\n\nCompare and Contrast Looking at the preceding principles, we immediately see quite a lot of commonality in the points outlined:\n\n10 Of course, not every team does everything, but those are the most common headings under which SRE works.\n\n11 Perform a layering violation, if you think of this as layered stacks.\n\n12 In fact, there’s a Production Readiness Review for onboarding anything; SRE won’t just onboard services\n\nfrom a standing start.\n\n13 A service is loosely defined as software running to perform some business need, generally with availability\n\nconstraints.\n\nCompare and Contrast\n\n|\n\n7\n\nDevOps and SRE are both contingent on an acceptance that change is necessary in order to improve. Without that, there’s not much room for maneuvering.14\n\nCollaboration is front and center for DevOps work. An effective shared owner‐ ship model and partner team relationships are necessary for SRE to function. Like DevOps, SRE also has strong values shared across the organization, which can make climbing out of team-based silos slightly easier.\n\nChange management is best pursued as small, continual actions, the majority of which are ideally both automatically tested and applied. The critical interaction between change and reliability makes this especially important for SRE.\n\nThe right tooling is critically important, and tooling to a certain extent deter‐ mines the scope of your acts. Yet we must not focus too hard on whether some‐ thing is achieved using some specific set of tools; at the end of the day, API orientation for system management is a more important philosophy that will outlast any particular implementation of it.\n\nMeasurement is absolutely key to how both DevOps and SRE work. For SRE, SLOs are dominant in determining the actions taken to improve the service. Of course, you can’t have SLOs without measurement (as well as cross-team debate —ideally among product, infrastructure/SRE, and the business). For DevOps, the act of measurement is often used to understand what the outputs of a process are, what the duration of feedback loops is, and so on. Both DevOps and SRE are data-oriented things, whether they are professions or philosophies.\n\nThe brute reality of managing production services means that bad things happen occasionally, and you have to talk about why. SRE and DevOps both practice blameless postmortems in order to offset unhelpful, adrenaline-laden reactions.\n\nUltimately, implementing DevOps or SRE is a holistic act; both hope to make the whole of the team (or unit, or organization) better, as a function of working together in a highly specific way. For both DevOps and SRE, better velocity should be the outcome.15\n\nAs you can see, there are many areas of commonality between DevOps and SRE.\n\nYet there are significant differences as well. DevOps is in some sense a wider philoso‐ phy and culture. Because it effects wider change than does SRE, DevOps is more context-sensitive. DevOps is relatively silent on how to run operations at a detailed\n\n14 Within Google, that question is largely settled, and services change state, configuration, ownership, direction, and so on, all the time. To a certain extent, SRE at Google is the beneficiary of the “change is necessary” argu‐ ment having been fought and won a number of times in the past. But not completely evenly distributed, as William Gibson might say.\n\n15 See relevant research at https://devops-research.com/research.html.\n\n8\n\n|\n\nChapter 1: How SRE Relates to DevOps\n\nlevel. For example, it is not prescriptive around the precise management of services. It chooses instead to concentrate on breaking down barriers in the wider organiza‐ tion. This has much value.\n\nSRE, on the other hand, has relatively narrowly defined responsibilities and its remit is generally service-oriented (and end-user-oriented) rather than whole-business- oriented. As a result, it brings an opinionated intellectual framework (including con‐ cepts like error budgets) to the problem of how to run systems effectively. Although SRE is, as a profession, highly aware of incentives and their effects, it in turn is rela‐ tively silent on topics like siloization and information barriers. It would support CI and CD not necessarily because of the business case, but because of the improved operational practices involved. Or, to put it another way, SRE believes in the same things as DevOps but for slightly different reasons.\n\nOrganizational Context and Fostering Successful Adoption DevOps and SRE have a very large conceptual overlap in how they operate. As you might expect, they also have a similar set of conditions that have to be true within the organization in order for them to a) be implementable in the first place, and b) obtain the maximum benefit from that implementation. As Tolstoy almost but never quite said, effective operations approaches are all alike, whereas broken approaches are all broken in their own way. Incentives can in part explain why that is.\n\nIf an organization’s culture values the benefits of a DevOps approach and is willing to bear those costs—typically expressed as difficulties in hiring, the energy required to maintain fluidity in teams and responsibilities, and increased financial resources dedicated to compensating a skill set that is necessarily more rare—then that organi‐ zation must also make sure the incentives are correct in order to achieve the full bene‐ fit of this approach.\n\nSpecifically, the following should hold true in the context of both DevOps and SRE.\n\nNarrow, Rigid Incentives Narrow Your Success Many companies accidentally define formal incentives that undermine collective per‐ formance. To avoid this mistake, don’t structure incentives to be narrowly tied to launch-related or reliability-related outcomes. As any economist can tell you, if there is a numeric measure, people will find a way to game it to bad effect, sometimes even in a completely well-intentioned way.16 Instead, you should allow your people the freedom to find the right tradeoffs. As discussed earlier, DevOps or SRE can act as an accelerant for your product team in general, allowing the rest of the software org to\n\n16 See http://en.wikipedia.org/wiki/Goodhart%27s_law and https://skybrary.aero/bookshelf/books/2336.pdf.\n\nOrganizational Context and Fostering Successful Adoption\n\n|\n\n9\n\nship features to customers in a continuous and reliable fashion. Such a dynamic also fixes one persistent problem with the traditional and divergent systems/software group approach: the lack of a feedback loop between design and production. A sys‐ tem with early SRE engagement (ideally, at design time) typically works better in pro‐ duction after deployment, regardless of who is responsible for managing the service. (Nothing slows down feature development like losing user data.)\n\nIt’s Better to Fix It Yourself; Don’t Blame Someone Else Furthermore, avoid any incentives to pass off the blame for production incidents or system failures onto other groups. In many ways, the dynamics of passing off blame is the core problem with the traditional model for engineering operations, as separat‐ ing operations and software teams allows separate incentives to emerge. Instead, con‐ sider adopting the following practices to combat blame passing at an organizational level:\n\nDon’t just allow, but actively encourage, engineers to change code and configura‐ tion when required for the product. Also allow these teams the authority to be radical within the limits of their mission, thereby eliminating incentives to pro‐ ceed more slowly.\n\nSupport blameless postmortems.17 Doing so eliminates incentives to downplay or cover up a problem. This step is crucial in fully understanding the product and actually optimizing its performance and functionality, and relies on the wisdom of production mentioned previously.\n\nAllow support to move away from products that are irredeemably operationally diffi‐ cult. The threat of support withdrawal motivates product development to fix issues both in the run-up to support and once the product is itself supported, saving every‐ one time. What it means to be “irredeemably operationally difficult” may differ depending on your context—the dynamic here should be one of mutually understood responsibilities. Pushback to other orgs might be a softer, “We think there are higher- value uses of the time of people with this skill set,” or framed within the limit of, “These people will quit if they’re tasked with too much operational work and aren’t given the opportunity to use their engineering skill set.” At Google, the practice of outright withdrawing support from such products has become institutional.\n\nConsider Reliability Work as a Specialized Role At Google, SRE and product development are separate organizations. Each group has its own focus, priorities, and management, and does not have to do the bidding of the\n\n17 See, for example, https://codeascraft.com/2012/05/22/blameless-postmortems/.\n\n10\n\n|\n\nChapter 1: How SRE Relates to DevOps\n\nother. However, the product development teams effectively fund the growth of SRE with new hires when a product is successful. In this way, product development has a stake in the success of SRE teams, just as SREs have a stake in the success of the prod‐ uct development teams. SRE is also fortunate to receive high-level support from man‐ agement, which ensures that engineering teams’ objections to supporting services “the SRE way” are generally short-lived. You don’t need to have an org chart to do things differently, though—you just need a different community of practice to emerge.\n\nRegardless of whether you fork your organizational chart or use more informal mechanisms, it’s important to recognize that specialization creates challenges. Practi‐ tioners of DevOps and SRE benefit from having a community of peers for support and career development, and job ladders that reward them18 for the unique skills and perspectives they bring to the table.\n\nIt’s important to note that the organizational structure employed by Google, as well as some of the aforementioned incentives, is somewhat reliant on a sizeable organiza‐ tion. For example, if your 20-person startup has only one (comparatively small) product, there’s not much sense in allowing withdrawal of operational support. It’s still possible to take a DevOps-style approach,19 but the ability to improve an opera‐ tionally poor product is undermined if literally all you can do is help it grow. Usually, though, people have more choice than they imagine about how to fulfill those growth needs versus the rate at which technical debt accumulates.20\n\nWhen Can Substitute for Whether However, when your organization or product grows beyond a certain size, you can exercise more latitude in what products to support, or how to prioritize that support. If it’s clear that support for system X is going to happen much sooner than support for system Y, the implicit conditionality can play much the same role as the choice to not support services in the SRE world.\n\nAt Google, SRE’s strong partnership with product development has proven to be crit‐ ically important: if such a relationship exists at your organization, then the decision to withdraw (or supply) support can be based on objective data about comparative operational characteristics, thereby avoiding otherwise nonproductive conversations.\n\n18 In orgs that have well-developed cultures of either. Early-stage companies likely do not have established ways\n\nto reward these job roles.\n\n19 Indeed, arguably, that’s your only choice unless you outsource operations.\n\n20 For a discussion of how to apply SRE principles in different contexts, see Chapter 20.\n\nOrganizational Context and Fostering Successful Adoption\n\n|\n\n11\n\nA productive relationship between SRE and product development also helps in avoiding the organizational anti-pattern in which a product development team has to ship a product or feature before it’s quite ready. Instead, SRE can work with a devel‐ opment team to improve the product before the burden of maintenance shifts away from the people with the most expertise to fix it.\n\nStrive for Parity of Esteem: Career and Financial Finally, make sure that the career incentives to do the right thing are in place: we want our DevOps/SRE organization to be held in the same esteem as their product development counterparts. Therefore, members of each team should be rated by roughly the same methods and have the same financial incentives.\n\nConclusion In many ways, DevOps and SRE sit, in both practice and philosophy, very close to each other in the overall landscape of IT operations.\n\nBoth DevOps and SRE require discussion, management support, and buy-in from the people actually doing the work to make serious progress. Implementing either of them is a journey and not a quick fix: the practice of rename-and-shame21 is a hollow one, unlikely to yield benefit. Given that it is a more opinionated implementation of how to perform operations, SRE has more concrete suggestions on how to change your work practices earlier on in that journey, albeit requiring specific adaptation. DevOps, having a wider focus, is somewhat more difficult to reason about and trans‐ late into concrete steps, but precisely because of that wider focus, is likely to meet with weaker initial resistance.\n\nBut practitioners of each use many of the same tools, the same approaches to change management, and the same data-based decision-making mindset. At the end of the day, we all face the same persistent problem: production, and making it better—no matter what we’re called.\n\nFor those interested in further reading, the following suggestions should help you develop a wider understanding of the cultural, business, and technical underpinnings of the operations revolution taking place right now:\n\nSite Reliability Engineering\n\nEffective DevOps\n\nThe Phoenix Project\n\n21 In other words, simply retitling a group DevOps or SRE with no other change in their organizational posi‐ tioning, resulting in inevitable shaming of the team when promised improvement is not forthcoming.\n\n12\n\n|\n\nChapter 1: How SRE Relates to DevOps\n\nThe Practice of Cloud System Administration: DevOps and SRE Practices for Web Services, Volume 2\n\nAccelerate: The Science of Lean Software and DevOps\n\nConclusion\n\n|\n\n13\n\nPART I Foundations\n\nEvery implementation guide needs to start with a common base from which to build. In this case, the basic foundations of SRE include SLOs, monitoring, alerting, toil reduction, and simplicity. Getting these basics right will set you up well to succeed on your SRE journey.\n\nThe following chapters explore techniques for turning these core principles into con‐ crete practices for your organization.",
      "page_number": 36
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 45-54)",
      "start_page": 45,
      "end_page": 54,
      "detection_method": "topic_boundary",
      "content": "CHAPTER 2 Implementing SLOs\n\nBy Steven Thurgood and David Ferguson with Alex Hidalgo and Betsy Beyer\n\nService level objectives (SLOs) specify a target level for the reliability of your service. Because SLOs are key to making data-driven decisions about reliability, they’re at the core of SRE practices. In many ways, this is the most important chapter in this book.\n\nOnce you’re equipped with a few guidelines, setting up initial SLOs and a process for refining them can be straightforward. Chapter 4 in our first book introduced the topic of SLOs and SLIs (service level indicators), and gave some advice on how to use them.\n\nAfter discussing the motivation behind SLOs and error budgets, this chapter provides a step-by-step recipe to get you started thinking about SLOs, and also some advice about how to iterate from there. We’ll then cover how to use SLOs to make effective business decisions, and explore some advanced topics. Finally, we’ll give you some examples of SLOs for different types of services and some pointers on how to create more sophisticated SLOs in specific situations.1\n\nWhy SREs Need SLOs Engineers are a scarce resource at even the largest organizations. Engineering time should be invested in the most important characteristics of the most important serv‐ ices. Striking the right balance between investing in functionality that will win new customers or retain current ones, versus investing in the reliability and scalability that\n\n1 A note on terminology: throughout this chapter, we use the word reliability to talk about how a service is performing with regard to all of its SLIs. This could be indicative of many things, such as availability or latency.\n\n17\n\nwill keep those customers happy, is difficult. At Google, we’ve learned that a well- thought-out and adopted SLO is key to making data-informed decisions about the opportunity cost of reliability work, and to determining how to appropriately priori‐ tize that work.\n\nSREs’ core responsibilities aren’t merely to automate “all the things” and hold the pager. Their day-to-day tasks and projects are driven by SLOs: ensuring that SLOs are defended in the short term and that they can be maintained in the medium to long term. One could even claim that without SLOs, there is no need for SREs.\n\nSLOs are a tool to help determine what engineering work to prioritize. For example, consider the engineering tradeoffs for two reliability projects: automating rollbacks and moving to a replicated data store. By calculating the estimated impact on our error budget, we can determine which project is most beneficial to our users. See the section “Decision Making Using SLOs and Error Budgets” on page 37 for more detail on this, and “Managing Risk” in Site Reliability Engineering.\n\nGetting Started As a starting point for establishing a basic set of SLOs, let’s assume that your service is some form of code that has been compiled and released and is running on net‐ worked infrastructure that users access via the web. Your system’s maturity level might be one of the following:\n\nA greenfield development, with nothing currently deployed\n\nA system in production with some monitoring to notify you when things go awry, but no formal objectives, no concept of an error budget, and an unspoken goal of 100% uptime\n\nA running deployment with an SLO below 100%, but without a common under‐ standing about its importance or how to leverage it to make continuous improvement choices—in other words, an SLO without teeth\n\nIn order to adopt an error budget-based approach to Site Reliability Engineering, you need to reach a state where the following hold true:\n\nThere are SLOs that all stakeholders in the organization have approved as being fit for the product.\n\nThe people responsible for ensuring that the service meets its SLO have agreed that it is possible to meet this SLO under normal circumstances.\n\nThe organization has committed to using the error budget for decision making and prioritizing. This commitment is formalized in an error budget policy.\n\nThere is a process in place for refining the SLO.\n\n18\n\n|\n\nChapter 2: Implementing SLOs\n\nOtherwise, you won’t be able to adopt an error budget–based approach to reliability. SLO compliance will simply be another KPI (key performance indicator) or reporting metric, rather than a decision-making tool.\n\nReliability Targets and Error Budgets The first step in formulating appropriate SLOs is to talk about what an SLO should be, and what it should cover.\n\nAn SLO sets a target level of reliability for the service’s customers. Above this thres‐ hold, almost all users should be happy with your service (assuming they are otherwise happy with the utility of the service).2 Below this threshold, users are likely to start complaining or to stop using the service. Ultimately, user happiness is what matters —happy users use the service, generate revenue for your organization, place low demands on your customer support teams, and recommend the service to their friends. We keep our services reliable to keep our customers happy.\n\nCustomer happiness is a rather fuzzy concept; we can’t measure it precisely. Often we have very little visibility into it at all, so how do we begin? What do we use for our first SLO?\n\nOur experience has shown that 100% reliability is the wrong target:\n\nIf your SLO is aligned with customer satisfaction, 100% is not a reasonable goal. Even with redundant components, automated health checking, and fast failover, there is a nonzero probability that one or more components will fail simultane‐ ously, resulting in less than 100% availability.\n\nEven if you could achieve 100% reliability within your system, your customers would not experience 100% reliability. The chain of systems between you and your customers is often long and complex, and any of these components can fail.3 This also means that as you go from 99% to 99.9% to 99.99% reliability, each extra nine comes at an increased cost, but the marginal utility to your customers steadily approaches zero.\n\nIf you do manage to create an experience that is 100% reliable for your custom‐ ers, and want to maintain that level of reliability, you can never update or improve your service. The number one source of outages is change: pushing new features, applying security patches, deploying new hardware, and scaling up to\n\n2 This is distinct from a service level agreement (SLA), which is a business contract that comes into effect when\n\nyour users are so unhappy you have to compensate them in some fashion.\n\n3 For more details about factoring dependencies into your service’s reliability, see Ben Treynor, Mike Dahlin, Vivek Rau, and Betsy Beyer, “The Calculus of Service Availability,” ACM Queue 15, no. 2 (2017), https:// queue.acm.org/detail.cfm?id=3096459.\n\nGetting Started\n\n|\n\n19\n\nmeet customer demand will impact that 100% target. Sooner or later, your ser‐ vice will stagnate and your customers will go elsewhere, which is not great for anyone’s bottom line.\n\nAn SLO of 100% means you only have time to be reactive. You literally cannot do anything other than react to < 100% availability, which is guaranteed to happen. Reliability of 100% is not an engineering culture SLO—it’s an operations team SLO.\n\nOnce you have an SLO target below 100%, it needs to be owned by someone in the organization who is empowered to make tradeoffs between feature velocity and relia‐ bility. In a small organization, this may be the CTO; in larger organizations, this is normally the product owner (or product manager).\n\nWhat to Measure: Using SLIs Once you agree that 100% is the wrong number, how do you determine the right number? And what are you measuring, anyway? Here, service level indicators come into play: an SLI is an indicator of the level of service that you are providing.\n\nWhile many numbers can function as an SLI, we generally recommend treating the SLI as the ratio of two numbers: the number of good events divided by the total num‐ ber of events. For example:\n\nNumber of successful HTTP requests / total HTTP requests (success rate)\n\nNumber of gRPC calls that completed successfully in < 100 ms / total gRPC requests\n\nNumber of search results that used the entire corpus / total number of search results, including those that degraded gracefully\n\nNumber of “stock check count” requests from product searches that used stock data fresher than 10 minutes / total number of stock check requests\n\nNumber of “good user minutes” according to some extended list of criteria for that metric / total number of user minutes\n\nSLIs of this form have a couple of particularly useful properties. The SLI ranges from 0% to 100%, where 0% means nothing works, and 100% means nothing is broken. We have found this scale intuitive, and this style lends itself easily to the concept of an error budget: the SLO is a target percentage and the error budget is 100% minus the SLO. For example, if you have a 99.9% success ratio SLO, then a service that receives 3 million requests over a four-week period had a budget of 3,000 (0.1%)\n\n20\n\n|\n\nChapter 2: Implementing SLOs\n\nerrors over that period. If a single outage is responsible for 1,500 errors, that error costs 50% of the error budget.4\n\nIn addition, making all of your SLIs follow a consistent style allows you to take better advantage of tooling: you can write alerting logic, SLO analysis tools, error budget calculation, and reports to expect the same inputs: numerator, denominator, and threshold. Simplification is a bonus here.\n\nWhen attempting to formulate SLIs for the first time, you might find it useful to fur‐ ther divide SLIs into SLI specification and SLI implementation:\n\nSLI specification\n\nThe assessment of service outcome that you think matters to users, independent of how it is measured.\n\nFor example: Ratio of home page requests that loaded in < 100 ms\n\nSLI implementation\n\nThe SLI specification and a way to measure it.\n\nFor example:\n\nRatio of home page requests that loaded in < 100 ms, as measured from the Latency column of the server log. This measurement will miss requests that fail to reach the backend.\n\nRatio of home page requests that loaded in < 100 ms, as measured by probers that execute JavaScript in a browser running in a virtual machine. This measurement will catch errors when requests cannot reach our network, but may miss issues that affect only a subset of users.\n\nRatio of home page requests that loaded in < 100 ms, as measured by instru‐ mentation in the JavaScript on the home page itself, and reported back to a dedicated telemetry recording service. This measurement will more accu‐ rately capture the user experience, although we now need to modify the code to capture this information and build the infrastructure to record it—a speci‐ fication that has its own reliability requirements.\n\nAs you can see, a single SLI specification might have multiple SLI implementations, each with its own set of pros and cons in terms of quality (how accurately they cap‐ ture the experience of a customer), coverage (how well they capture the experience of all customers), and cost.\n\n4 If you measure your SLO over a calendar period, such as a quarter-year, then you may not know how big your budget will be at the end of the quarter if it’s based upon unpredictable metrics such as traffic. See “Choosing an Appropriate Time Window” on page 29 for more discussion about reporting periods.\n\nGetting Started\n\n|\n\n21\n\nYour first attempt at an SLI and SLO doesn’t have to be correct; the most important goal is to get something in place and measured, and to set up a feedback loop so you can improve. (We dive deeper into this topic in “Continuous Improvement of SLO Targets” on page 34.)\n\nIn our first book, we advise against picking an SLO based upon current performance, because this can commit you to unnecessarily strict SLOs. While that advice is true, your current performance can be a good place to start if you don’t have any other information, and if you have a good process for iterating in place (which we’ll cover later). However, don’t let current performance limit you as you refine your SLO: your customers will also come to expect your service to perform at its SLO, so if your ser‐ vice returns successful requests 99.999% of the time in less than 10 ms, any signifi‐ cant regression from that baseline may make them unhappy.\n\nTo create your first set of SLOs, you need to decide upon a few key SLI specifications that matter to your service. Availability and latency SLOs are pretty common; fresh‐ ness, durability, correctness, quality, and coverage SLOs also have their place (we’ll talk more about those later).\n\nIf you are having trouble figuring out what sort of SLIs to start with, it helps to start simple:\n\nChoose one application for which you want to define SLOs. If your product com‐ prises many applications, you can add those later.\n\nDecide clearly who the “users” are in this situation. These are the people whose happiness you are optimizing.\n\nConsider the common ways your users interact with your system—common tasks and critical activities.\n\nDraw a high-level architecture diagram of your system; show the key compo‐ nents, the request flow, the data flow, and the critical dependencies. Group these components into categories listed in the following section (there may be some overlap and ambiguity; use your intuition and don’t let perfect be the enemy of the good).\n\nYou should think carefully about exactly what you select as your SLIs, but you also shouldn’t overcomplicate things. Especially if you’re just starting your SLI journey, pick an aspect of your system that’s relevant but easy to measure—you can always iterate and refine later.\n\nTypes of components\n\nThe easiest way to get started with setting SLIs is to abstract your system into a few common types of components. You can then use our list of suggested SLIs for each component to choose the ones most relevant to your service:\n\n22\n\n|\n\nChapter 2: Implementing SLOs\n\nRequest-driven\n\nThe user creates some type of event and expects a response. For example, this could be an HTTP service where the user interacts with a browser or an API for a mobile application.\n\nPipeline\n\nA system that takes records as input, mutates them, and places the output some‐ where else. This might be a simple process that runs on a single instance in real time, or a multistage batch process that takes many hours. Examples include:\n\nA system that periodically reads data from a relational database and writes it into a distributed hash table for optimized serving\n\nA video processing service that converts video from one format to another\n\nA system that reads in log files from many sources to generate reports\n\nA monitoring system that pulls metrics from remote servers and generates time series and alerts\n\nStorage\n\nA system that accepts data (e.g., bytes, records, files, videos) and makes it avail‐ able to be retrieved at a later date.\n\nA Worked Example Consider a simplified architecture for a mobile phone game, shown in Figure 2-1.\n\nFigure 2-1. Architecture for an example mobile phone game\n\nA Worked Example\n\n|\n\n23\n\nThe app running on the user’s phone interacts with an HTTP API running in the cloud. The API writes state changes to a permanent storage system. A pipeline peri‐ odically runs over this data to generate league tables that provide high scores for today, this week, and all time. This data is written to a separate league table data store, and the results are available via the mobile app (for in-game scores) and a web‐ site. Users can upload custom avatars, which are used both in-game via the API and in the high score website, to the User Data table.\n\nGiven this setup, we can start thinking about how users interact with the system, and what sort of SLIs would measure the various aspects of a user’s experience.\n\nSome of these SLIs may overlap: a request-driven service may have a correctness SLI, a pipeline may have an availability SLI, and durability SLIs might be viewed as a var‐ iant on correctness SLIs. We recommend choosing a small number (five or fewer) of SLI types that represent the most critical functionality to your customers.\n\nIn order to capture both the typical user experience and the long tail, we also recom‐ mend using multiple grades of SLOs for some types of SLIs. For example, if 90% of users’ requests return within 100 ms, but the remaining 10% take 10 seconds, many users will be unhappy. A latency SLO can capture this user base by setting multiple thresholds: 90% of requests are faster than 100 ms, and 99% of requests are faster than 400 ms. This principle applies to all SLIs with parameters that measure user unhappiness.\n\nTable 2-1 provides some common SLIs for different types of services.\n\nTable 2-1. Potential SLIs for different types of components\n\nType of service Request- driven Request- driven Request- driven\n\nPipeline\n\nPipeline\n\nPipeline\n\nType of SLI Description\n\nAvailability\n\nThe proportion of requests that resulted in a successful response.\n\nLatency\n\nThe proportion of requests that were faster than some threshold.\n\nQuality\n\nFreshness\n\nCorrectness\n\nCoverage\n\nIf the service degrades gracefully when overloaded or when backends are unavailable, you need to measure the proportion of responses that were served in an undegraded state. For example, if the User Data store is unavailable, the game is still playable but uses generic imagery. The proportion of the data that was updated more recently than some time threshold. Ideally this metric counts how many times a user accessed the data, so that it most accurately reflects the user experience. The proportion of records coming into the pipeline that resulted in the correct value coming out. For batch processing, the proportion of jobs that processed above some target amount of data. For streaming processing, the proportion of incoming records that were successfully processed within some time window.\n\n24\n\n|\n\nChapter 2: Implementing SLOs\n\nType of service Storage\n\nType of SLI Description\n\nDurability\n\nThe proportion of records written that can be successfully read. Take particular care with durability SLIs: the data that the user wants may be only a small portion of the data that is stored. For example, if you have 1 billion records for the previous 10 years, but the user wants only the records from today (which are unavailable), then they will be unhappy even though almost all of their data is readable.\n\nMoving from SLI Specification to SLI Implementation Now that we know our SLI specifications, we need to start thinking about how to implement them.\n\nFor your first SLIs, choose something that requires a minimum of engineering work. If your web server logs are already available, but setting up probes would take weeks and instrumenting your JavaScript would take months, use the logs.\n\nYou need enough information to measure the SLI: for availability, you need the suc‐ cess/failure status; for slow requests, you need the time taken to serve the request. You may need to reconfigure your web server to record this information. If you’re using a cloud-based service, some of this information may already be available in a monitoring dashboard.\n\nThere are various options for SLI implementations for our example architecture, each with its own pros and cons. The following sections detail SLIs for the three types of components in our system.\n\nAPI and HTTP server availability and latency\n\nFor all of the considered SLI implementations, we base the response success on the HTTP status code. 5XX responses count against SLO, while all other requests are considered successful. Our availability SLI is the proportion of successful requests, and our latency SLIs are the proportion of requests that are faster than defined thresholds.\n\nYour SLIs should be specific and measurable. To summarize the list of potential can‐ didates provided in “What to Measure: Using SLIs” on page 20, your SLIs can use one or more of the following sources:\n\nApplication server logs\n\nLoad balancer monitoring\n\nBlack-box monitoring\n\nClient-side instrumentation\n\nA Worked Example\n\n|\n\n25\n\nOur example uses the load balancer monitoring, as the metrics are already available and provide SLIs that are closer to the user’s experience than those from the applica‐ tion server’s logs.\n\nPipeline freshness, coverage, and correctness\n\nWhen our pipeline updates the league table, it records a watermark containing the timestamp of when the data was updated. Some example SLI implementations:\n\nRun a periodic query across the league table, counting the total number of fresh records and the total number of records. This will treat each stale record as equally important, regardless of how many users saw the data.\n\nMake all clients of the league table check the watermark when they request fresh data and increment a metric counter saying that data was requested. Increment another counter if the data was fresher than a predefined threshold.\n\nFrom these two options, our example uses the client-side implementation, as it gives SLIs that are much more closely correlated with user experience and are straightfor‐ ward to add.\n\nTo calculate our coverage SLI, our pipeline exports the number of records that it should have processed and the number of records that it successfully processed. This metric may miss records that our pipeline did not know about due to misconfigura‐ tion.\n\nWe have a couple potential approaches to measure correctness:\n\nInject data with known outputs into the system, and count the proportion of times that the output matches our expectations.\n\nUse a method to calculate correct output based on input that is distinct from our pipeline itself (and likely more expensive, and therefore not suitable for our pipe‐ line). Use this to sample input/output pairs, and count the proportion of correct output records. This methodology assumes that creating such a system is both possible and practical.\n\nOur example bases its correctness SLI on some manually curated data in the game state database, with known good outputs that are tested every time the pipeline runs. Our SLI is the proportion of correct entries for our test data. In order for this SLI to be representative of the actual user experience, we need to make sure that our man‐ ually curated data is representative of real-world data.\n\nMeasuring the SLIs Figure 2-2 shows how our white-box monitoring system collects metrics from the various components of the example application.\n\n26\n\n|\n\nChapter 2: Implementing SLOs",
      "page_number": 45
    },
    {
      "number": 7,
      "title": "Segment 7 (pages 55-67)",
      "start_page": 55,
      "end_page": 67,
      "detection_method": "topic_boundary",
      "content": "Figure 2-2. How our monitoring system collects SLI metrics\n\nLet’s walk through an example of using metrics from our monitoring system to calcu‐ late our starter SLOs. While our example uses availability and latency metrics, the same principles apply to all other potential SLOs. For a full list of the metrics that our system uses, see Appendix A. All of our examples use Prometheus notation.\n\nLoad balancer metrics\n\nTotal requests by backend (\"api\" or \"web\") and response code:\n\nhttp_requests_total{host=\"api\", status=\"500\"}\n\nTotal latency, as a cumulative histogram; each bucket counts the number of requests that took less than or equal to that time:\n\nhttp_request_duration_seconds{host=\"api\", le=\"0.1\"} http_request_duration_seconds{host=\"api\", le=\"0.2\"} http_request_duration_seconds{host=\"api\", le=\"0.4\"}\n\nGenerally speaking, it is better to count the slow requests than to approximate them with a histogram. But, because that information isn’t available, we use the histogram provided by our monitoring system. Another approach would be to base explicit slow\n\nA Worked Example\n\n|\n\n27\n\nrequest counts on the various slowness thresholds in the load balancer’s configura‐ tion (e.g., for thresholds of 100 ms and 500 ms). This strategy would provide more accurate numbers but require more configuration, which makes changing the thresh‐ olds retroactively harder.\n\nhttp_request_duration_seconds{host=\"api\", le=\"0.1\"} http_request_duration_seconds{host=\"api\", le=\"0.5\"}\n\nCalculating the SLIs\n\nUsing the preceding metrics, we can calculate our current SLIs over the previous seven days, as shown in Table 2-2.\n\nTable 2-2. Calculations for SLIs over the previous seven days\n\nAvailability sum(rate(http_requests_total{host=\"api\", status!~\"5..\"}[7d]))\n\n/ sum(rate(http_requests_total{host=\"api\"}[7d])\n\nLatency\n\nhistogram_quantile(0.9, rate(http_request_duration_seconds_bucket[7d])) histogram_quantile(0.99, rate(http_request_duration_seconds_bucket[7d]))\n\nUsing the SLIs to Calculate Starter SLOs We can round down these SLIs to manageable numbers (e.g., two significant figures of availability, or up to 50 ms5 of latency) to obtain our starting SLOs.\n\nFor example, over four weeks, the API metrics show:\n\nTotal requests: 3,663,253\n\nTotal successful requests: 3,557,865 (97.123%)\n\n90th percentile latency: 432 ms\n\n99th percentile latency: 891 ms\n\nWe repeat this process for the other SLIs, and create a proposed SLO for the API, shown in Table 2-3.\n\n5 50 ms because users are unlikely to perceive a 50 ms change in latency, but the appropriate window obviously\n\ndepends on the service and the users. A reporting service will be different from a real-time game.\n\n28\n\n|\n\nChapter 2: Implementing SLOs\n\nTable 2-3. Proposed SLOs for the API\n\nSLO type Availability Latency Latency\n\nObjective 97% 90% of requests < 450 ms 99% of requests < 900 ms\n\nAppendix A provides a full example of an SLO document. This document includes SLI implementations, which we omitted here for brevity.\n\nBased upon this proposed SLI, we can calculate our error budget over those four weeks, as shown in Table 2-4.\n\nTable 2-4. Error budget over four weeks\n\nSLO 97% availability 90% of requests faster than 450 ms 99% of requests faster than 900 ms\n\nAllowed failures 109,897 366,325 36,632\n\nChoosing an Appropriate Time Window SLOs can be defined over various time intervals, and can use either a rolling window or a calendar-aligned window (e.g., a month). There are several factors you need to account for when choosing the window.\n\nRolling windows are more closely aligned with user experience: if you have a large outage on the final day of a month, your user doesn’t suddenly forget about it on the first day of the following month. We recommend defining this period as an integral number of weeks so it always contains the same number of weekends. For example, if you use a 30-day window, some periods might include four weekends while others include five weekends. If weekend traffic differs significantly from weekday traffic, your SLIs may vary for uninteresting reasons.\n\nCalendar windows are more closely aligned with business planning and project work. For example, you might evaluate your SLOs every quarter to determine where to focus the next quarter’s project headcount. Calendar windows also introduce some element of uncertainty: in the middle of the quarter, it is impossible to know how many requests you will receive for the rest of the quarter. Therefore, decisions made mid-quarter must speculate as to how much error budget you’ll spend in the remain‐ der of the quarter.\n\nShorter time windows allow you to make decisions more quickly: if you missed your SLO for the previous week, then small course corrections—prioritizing relevant bugs, for example—can help avoid SLO violations in future weeks.\n\nChoosing an Appropriate Time Window\n\n|\n\n29\n\nLonger time periods are better for more strategic decisions: for example, if you could choose only one of three large projects, would you be better off moving to a high- availability distributed database, automating your rollout and rollback procedure, or deploying a duplicate stack in another zone? You need more than a week’s worth of data to evaluate large multiquarter projects; the amount of data required is roughly commensurate with the amount of engineering work being proposed to fix it.\n\nWe have found a four-week rolling window to be a good general-purpose interval. We complement this time frame with weekly summaries for task prioritization and quarterly summarized reports for project planning.\n\nIf the data source allows, you can then use this proposed SLO to calculate your actual SLO performance over that interval: if you set your initial SLO based on actual meas‐ urements, by design, you met your SLO. But we can also gather interesting informa‐ tion about the distribution. Were there any days during the past four weeks when our service did not meet its SLO? Do these days correlate with actual incidents? Was there (or should there have been) some action taken on those days in response to incidents?\n\nIf you do not have logs, metrics, or any other source of historical performance, you need to configure a data source. For example, as a low-fidelity solution for HTTP services, you can set up a remote monitoring service that performs some kind of peri‐ odic health check on the service (a ping or an HTTP GET) and reports back the num‐ ber of successful requests. A number of online services can easily implement this solution.\n\nGetting Stakeholder Agreement In order for a proposed SLO to be useful and effective, you will need to get all stake‐ holders to agree to it:\n\nThe product managers have to agree that this threshold is good enough for users —performance below this value is unacceptably low and worth spending engi‐ neering time to fix.\n\nThe product developers need to agree that if the error budget has been exhaus‐ ted, they will take some steps to reduce risk to users until the service is back in budget (as discussed in “Establishing an Error Budget Policy” on page 31).\n\nThe team responsible for the production environment who are tasked with defending this SLO have agreed that it is defensible without Herculean effort, excessive toil, and burnout—all of which are damaging to the long-term health of the team and service.\n\n30\n\n|\n\nChapter 2: Implementing SLOs\n\nOnce all of these points are agreed upon, the hard part is done.6 You have started your SLO journey, and the remaining steps entail iterating from this starting point.\n\nTo defend your SLO you will need to set up monitoring and alerting (see Chapter 5) so that engineers receive timely notifications of threats to the error budget before those threats become deficits.\n\nEstablishing an Error Budget Policy Once you have an SLO, you can use the SLO to derive an error budget. In order to use this error budget, you need a policy outlining what to do when your service runs out of budget.\n\nGetting the error budget policy approved by all key stakeholders—the product man‐ ager, the development team, and the SREs—is a good test for whether the SLOs are fit for purpose:\n\nIf the SREs feel that the SLO is not defensible without undue amounts of toil, they can make a case for relaxing some of the objectives.\n\nIf the development team and product manager feel that the increased resources they’ll have to devote to fixing reliability will cause feature release velocity to fall below acceptable levels, then they can also argue for relaxing objectives. Remem‐ ber that lowering the SLOs also lowers the number of situations to which the SREs will respond; the product manager needs to understand this tradeoff.\n\nIf the product manager feels that the SLO will result in a bad experience for a significant number of users before the error budget policy prompts anyone to address an issue, the SLOs are likely not tight enough.\n\nIf all three parties do not agree to enforce the error budget policy, you need to iterate on the SLIs and SLOs until all stakeholders are happy. Decide how to move forward and what you need to make the decision: more data, more resources, or a change to the SLI or SLO?\n\nWhen we talk about enforcing an error budget, we mean that once you exhaust your error budget (or come close to exhausting it), you should do something in order to restore stability to your system.\n\nTo make error budget enforcement decisions, you need to start with a written policy. This policy should cover the specific actions that must be taken when a service has consumed its entire error budget for a given period of time, and specify who will take them. Common owners and actions might include:\n\n6 Disclaimer: there may be more difficult tasks in your future.\n\nGetting Stakeholder Agreement\n\n|\n\n31\n\nThe development team gives top priority to bugs relating to reliability issues over the past four weeks.\n\nThe development team focuses exclusively on reliability issues until the system is within SLO. This responsibility comes with high-level approval to push back on external feature requests and mandates.\n\nTo reduce the risk of more outages, a production freeze halts certain changes to the system until there is sufficient error budget to resume changes.\n\nSometimes a service consumes the entirety of its error budget, but not all stakehold‐ ers agree that enacting the error budget policy is appropriate. If this happens, you need to return to the error budget policy approval stage.\n\nDocumenting the SLO and Error Budget Policy An appropriately defined SLO should be documented in a prominent location where other teams and stakeholders can review it. This documentation should include the following information:\n\nThe authors of the SLO, the reviewers (who checked it for technical accuracy), and the approvers (who made the business decision about whether it is the right SLO).\n\nThe date on which it was approved, and the date when it should next be reviewed.\n\nA brief description of the service to give the reader context.\n\nThe details of the SLO: the objectives and the SLI implementations.\n\nThe details of how the error budget is calculated and consumed.\n\nThe rationale behind the numbers, and whether they were derived from experi‐ mental or observational data. Even if the SLOs are totally ad hoc, this fact should be documented so that future engineers reading the document don’t make bad decisions based upon ad hoc data.\n\nHow often you review an SLO document depends on the maturity of your SLO cul‐ ture. When starting out, you should probably review the SLO frequently—perhaps every month. Once the appropriateness of the SLO becomes more established, you can likely reduce reviews to happen quarterly or even less frequently.\n\nThe error budget policy should also be documented, and should include the follow‐ ing information:\n\nThe policy authors, reviewers, and approvers\n\nThe date on which it was approved, and the date when it should next be reviewed\n\n32\n\n|\n\nChapter 2: Implementing SLOs\n\nA brief description of the service to give the reader context\n\nThe actions to be taken in response to budget exhaustion\n\nA clear escalation path to follow if there is disagreement on the calculation or whether the agreed-upon actions are appropriate in the circumstances\n\nDepending upon the audience’s level of error budget experience and expertise, it may be beneficial to include an overview of error budgets.\n\nSee Appendix A for an example of an SLO document and an error budget policy.\n\nDashboards and Reports In addition to the published SLO and error budget policy documents, it is useful to have reports and dashboards that provide in-time snapshots of the SLO compliance of your services, for communicating with other teams and for spotting problematic areas.\n\nThe report in Figure 2-3 shows the overall compliance of several services: whether they met all of their quarterly SLOs for the previous year (the numbers in parentheses indicate the number of objectives that were met, and the total number of objectives), and whether their SLIs were trending upward or downward in relation to the previ‐ ous quarter and the same quarter last year.\n\nFigure 2-3. SLO compliance report\n\nIt is also useful to have dashboards showing SLI trends. These dashboards indicate if you are consuming budget at a higher-than-usual rate, or if there are patterns or trends you need to be aware of.\n\nGetting Stakeholder Agreement\n\n|\n\n33\n\nThe dashboard in Figure 2-4 shows the error budget for a single quarter, midway through that quarter. Here we see that a single event consumed around 15% of the error budget over the course of two days.\n\nFigure 2-4. Error budget dashboard\n\nError budgets can be useful for quantifying these events—for example, “this outage consumed 30% of my quarterly error budget,” or “these are the top three incidents this quarter, ordered by how much error budget they consumed.”\n\nContinuous Improvement of SLO Targets Every service can benefit from continuous improvement. This is one of the central service goals in ITIL, for example.\n\nBefore you can improve your SLO targets, you need a source of information about user satisfaction with your service. There are a huge range of options:\n\nYou can count outages that were discovered manually, posts on public forums, support tickets, and calls to customer service.\n\nYou can attempt to measure user sentiment on social media.\n\nYou can add code to your system to periodically sample user happiness.\n\nYou can conduct face-to-face user surveys and samples.\n\n34\n\n|\n\nChapter 2: Implementing SLOs\n\nThe possibilities are endless, and the optimal method depends on your service. We recommend starting with a measurement that’s cheap to collect and iterating from that starting point. Asking your product manager to include reliability into their existing discussions with customers about pricing and functionality is an excellent place to start.\n\nImproving the Quality of Your SLO Count your manually detected outages. If you have support tickets, count those too. Look at periods when you had a known outage or incident. Check that these periods correlate with steep drops in error budget. Likewise, look at times when your SLIs indicate an issue, or your service fell out of SLO. Do these time periods correlate with known outages or an increase in support tickets? If you are familiar with statistical analysis, Spearman’s rank correlation coefficient can be a useful way to quantify this relationship.\n\nFigure 2-5 shows a graph of the number of support tickets raised per day versus the measured loss in our error budget on that day. While not all tickets are related to reli‐ ability issues, there is a correlation between tickets and error budget loss. We see two outliers: one day with only 5 tickets, where we lost 10% of our error budget, and one day with 40 tickets, on which we lost no error budget. Both warrant closer investiga‐ tion.\n\nFigure 2-5. Graph showing the number of support tickets per day versus the budget loss on that day\n\nIf some of your outages and ticket spikes are not captured in any SLI or SLO, or if you have SLI dips and SLO misses that don’t map to user-facing issues, this is a strong sign that your SLO lacks coverage. This situation is totally normal and should\n\nContinuous Improvement of SLO Targets\n\n|\n\n35\n\nbe expected. Your SLIs and SLOs should change over time as realities about the ser‐ vice they represent change. Don’t be afraid to examine and refine them over time!\n\nThere are several courses of action you can take if your SLO lacks coverage:\n\nChange your SLO\n\nIf your SLIs indicated a problem, but your SLOs didn’t prompt anyone to notice or respond, you may need to tighten your SLO.\n\nIf the incident on that date was large enough that it needs to be addressed, look at the SLI values during the periods of interest. Calculate what SLO would have resulted in a notification on those dates. Apply that SLO to your historic SLIs, and see what other events this adjustment would have cap‐ tured. It’s pointless to improve the recall of your system if you lower the pre‐ cision such that the team must constantly respond to unimportant events.7\n\nLikewise, for false-positive days, consider relaxing the SLO.\n\nIf changing the SLO in either direction results in too many false positives or false negatives, then you also need to improve the SLI implementation.\n\nChange your SLI implementation\n\nThere are two ways to change your SLI implementation: either move the meas‐ urement closer to the user to improve the quality of the metric, or improve cov‐ erage so you capture a higher percentage of user interactions. For example:\n\nInstead of measuring success/latency at the server, measure it at the load bal‐ ancer or on the client.\n\nInstead of measuring availability with a simple HTTP GET request, use a health-checking handler that exercises more functionality of the system, or a test that executes all of the client-side JavaScript.\n\nInstitute an aspirational SLO\n\nSometimes you determine that you need a tighter SLO to make your users happy, but improving your product to meet that SLO will take some time. If you imple‐ ment the tighter SLO, you’ll be permanently out of SLO and subject to your error budget policy. In this situation, you can make the refined SLO an aspirational SLO—measured and tracked alongside your current SLO, but explicitly called out in your error budget policy as not requiring action. This way you can track your progress toward meeting the aspirational SLO, but you won’t be in a perpet‐ ual state of emergency.\n\n7 Recall is the proportion of significantly user-impacting events that the SLI captures. Precision is the propor‐\n\ntion of events captured by the SLI that were significantly user-impacting.\n\n36\n\n|\n\nChapter 2: Implementing SLOs\n\nIterate\n\nThere are many different ways to iterate, and your review sessions will identify many potential improvements. Pick the option that’s most likely to give the high‐ est return on investment. Especially during the first few iterations, err on the side of quicker and cheaper; doing so reduces the uncertainty in your metrics and helps you determine if you need more expensive metrics. Iterate as many times as you need to.\n\nDecision Making Using SLOs and Error Budgets Once you have SLOs, you can start using them for decision making.\n\nThe obvious decisions start from what to do when you’re not meeting your SLO— that is, when you’ve exhausted your error budget. As already discussed, the appropri‐ ate course of action when you exhaust your error budget should be covered by the error budget policy. Common policies include stopping feature launches until the service is once again within SLO or devoting some or all engineering time to working on reliability-related bugs.\n\nIn extreme circumstances, a team can declare an emergency with high-level approval to deprioritize all external demands (requests from other teams, for example) until the service meets exit criteria—typically that the service is within SLO and that you’ve taken steps to decrease the chances of a subsequent SLO miss. These steps may include improving monitoring, improving testing, removing dangerous dependen‐ cies, or rearchitecting the system to remove known failure types.\n\nYou can determine the scale of the incident according to the proportion of the error budget it consumed, and use this data to identify the most critical incidents that merit closer investigation.\n\nFor example, imagine a release of a new API version causes 100% NullPointerExcep tions until the system can be reverted four hours later.8 Inspecting the raw server logs indicates that the issue caused 14,066 errors. Using the numbers from our 97% SLO earlier, and our budget of 109,897 errors, this single event used 13% of our error budget.\n\nOr perhaps the server on which our singly homed state database is stored fails, and restoring from backups takes 20 hours. We estimate (based upon historical traffic over that period) that this outage caused us 72,000 errors, or 65% of our error budget.\n\n8 It is worth reiterating here that an error budget is an approximation of user satisfaction. A four-hour outage every 30 days would probably result in fewer unhappy users than four separate one-hour outages every 30 days, which in turn would cause fewer unhappy users than a constant error rate of 0.5%, but our error budget treats them the same. These thresholds will vary between services.\n\nDecision Making Using SLOs and Error Budgets\n\n|\n\n37\n\nImagine that our example company had only one server failure in five years, but typi‐ cally experiences two or three bad releases that require rollbacks per year. We can estimate that, on average, bad pushes cost twice as much error budget as database failures. The numbers prove that addressing the release problem provides much more benefit than investing resources in investigating the server failure.\n\nIf the service is running flawlessly and needs little oversight, then it may be time to move the service to a less hands-on tier of support. You might continue to provide incident response management and high-level oversight, but you no longer need to be as closely involved with the product on a day-to-day basis. Therefore, you can focus your efforts on other systems that need more SRE support.\n\nTable 2-5 provides suggested courses of action based on three key dimensions:\n\nPerformance against SLO\n\nThe amount of toil required to operate the service\n\nThe level of customer satisfaction with the service\n\nTable 2-5. SLO decision matrix\n\nSLOs\n\nToil\n\nCustomer satisfaction\n\nAction\n\nMet\n\nLow High\n\nMet Met\n\nLow Low High High\n\nHigh Low Met Low High Missed Missed Low Low Missed High High Missed High Low\n\nChoose to (a) relax release and deployment processes and increase velocity, or (b) step back from the engagement and focus engineering time on services that need more reliability. Tighten SLO. If alerting is generating false positives, reduce sensitivity. Otherwise, temporarily loosen the SLOs (or offload toil) and fix product and/or improve automated fault mitigation. Tighten SLO. Loosen SLO. Increase alerting sensitivity. Loosen SLO. Offload toil and fix product and/or improve automated fault mitigation.\n\nAdvanced Topics Once you have a healthy and mature SLO and error budget culture, you can continue to improve and refine how you measure and discuss the reliability of your services.\n\n38\n\n|\n\nChapter 2: Implementing SLOs\n\nModeling User Journeys While all of the techniques discussed in this chapter will be beneficial to your organi‐ zation, ultimately SLOs should center on improving the customer experience. There‐ fore, you should write SLOs in terms of user-centric actions.\n\nYou can use critical user journeys to help capture the experience of your customers. A critical user journey is a sequence of tasks that is a core part of a given user’s experi‐ ence and an essential aspect of the service. For example, for an online shopping expe‐ rience, critical user journeys might include:\n\nSearching for a product\n\nAdding a product to a shopping cart\n\nCompleting a purchase\n\nThese tasks will almost certainly not map well to your existing SLIs; each task requires multiple complex steps that can fail at any point, and inferring the success (or failure) of these actions from logs can be extremely difficult. (For example, how do you determine if the user failed at the third step, or if they simply got distracted by cat videos in another tab?) However, we need to identify what matters to the user before we can start making sure that aspect of the service is reliable.\n\nOnce you identify user-centric events, you can solve the problem of measuring them. You might measure them by joining distinct log events together, using advanced JavaScript probing, using client-side instrumentation, or using some other process. Once you can measure an event, it becomes just another SLI, which you can track alongside your existing SLIs and SLOs. Critical user journeys can improve your recall without affecting your precision.\n\nGrading Interaction Importance Not all requests are considered equal. The HTTP request from a mobile app that checks for account notifications (where notifications are generated by a daily pipe‐ line) is important to your user, but is not as important as a billing-related request by your advertiser.\n\nWe need a way to distinguish certain classes of requests from others. You can use bucketing to accomplish this—that is, adding more labels to your SLIs, and then applying different SLOs to those different labels. Table 2-6 shows an example.\n\nTable 2-6. Bucketing by tier\n\nCustomer tier Availability SLO Premium Free\n\n99.99% 99.9%\n\nAdvanced Topics\n\n|\n\n39",
      "page_number": 55
    },
    {
      "number": 8,
      "title": "Segment 8 (pages 68-75)",
      "start_page": 68,
      "end_page": 75,
      "detection_method": "topic_boundary",
      "content": "You can split requests by expected responsiveness, as shown in Table 2-7.\n\nTable 2-7. Bucketing by expected responsiveness\n\nResponsiveness Interactive (i.e., requests that block page load) CSV download\n\nLatency SLO 90% of requests complete in 100 ms 90% of downloads start within 5 s\n\nIf you have the data available to apply your SLO to each customer independently, you can track the number of customers who are in SLO at any given time. Note that this number can be highly variable—customers who send a very low number of requests will have either 100% availability (because they were lucky enough to experience no failures) or very low availability (because the one failure they experienced was a sig‐ nificant percentage of their requests). Individual customers can fail to meet their SLO for uninteresting reasons, but in aggregate, tracking problems that affect a wide num‐ ber of customers’ SLO compliance can be a useful signal.\n\nModeling Dependencies Large systems have many components. A single system may have a presentation layer, an application layer, a business logic layer, and a data persistence layer. Each of these layers may consist of many services or microservices.\n\nWhile your prime concern is implementing a user-centric SLO that covers the entire stack, SLOs can also be a useful way to coordinate and implement reliability require‐ ments between different components in the stack.\n\nFor example, if a single component is a critical dependency9 for a particularly high- value interaction, its reliability guarantee should be at least as high as the reliability guarantee of the dependent action. The team that runs that particular component needs to own and manage its service’s SLO in the same way as the overarching prod‐ uct SLO.\n\nIf a particular component has inherent reliability limitations, the SLO can communi‐ cate that limitation. If the user journey that depends upon it needs a higher level of availability than that component can reasonably provide, you need to engineer around that condition. You can either use a different component or add sufficient defenses (caching, offline store-and-forward processing, graceful degradation, etc.) to handle failures in that component.\n\nIt can be tempting to try to math your way out of these problems. If you have a ser‐ vice that offers 99.9% availability in a single zone, and you need 99.95% availability,\n\n9 A dependency is critical if its unavailability means that your service is also unavailable.\n\n40\n\n|\n\nChapter 2: Implementing SLOs\n\nsimply deploying the service in two zones should solve that requirement. The proba‐ bility that both services will experience an outage at the same time is so low that two zones should provide 99.9999% availability. However, this reasoning assumes that both services are wholly independent, which is almost never the case. The two instan‐ ces of your app will have common dependencies, common failure domains, shared fate, and global control planes—all of which can cause an outage in both systems, no matter how carefully it is designed and managed. Unless each of these dependencies and failure patterns is carefully enumerated and accounted for, any such calculations will be deceptive.\n\nThere are two schools of thought regarding how an error budget policy should address a missed SLO when the failure is caused by a dependency that’s handled by another team:\n\nYour team should not halt releases or devote more time to reliability, as your sys‐ tem didn’t cause the issue.\n\nYou should enact a change freeze in order to minimize the chances of future out‐ ages, regardless of the cause of that outage.\n\nThe second approach will make your users happier. You have some flexibility in how you apply this principle. Depending on the nature of the outage and dependency, freezing changes may not be practical. Decide what is most appropriate for your ser‐ vice and its dependencies, and record that decision for posterity in your documented error budget. For an example of how this might work in practice, see the example error budget policy in Appendix B.\n\nExperimenting with Relaxing Your SLOs You may want to experiment with the reliability of your application and measure which changes in reliability (e.g., adding latency into page load times) have a measur‐ ably adverse impact on user behavior (e.g., percentage of users completing a pur‐ chase). We recommend performing this sort of analysis only if you are confident that you have error budget to burn. There are many subtle interactions between latency, availability, customers, business domains, and competition (or lack thereof). To make a choice to deliberately lower the perceived customer experience is a Rubicon to be crossed extremely thoughtfully, if at all.\n\nWhile this exercise might seem scary (nobody wants to lose sales!), the knowledge you can gain by performing such experiments will allow you to improve your service in ways that could lead to even better performance (and higher sales!) in the future. This process may allow you to mathematically identify a relationship between a key business metric (e.g., sales) and a measurable technical metric (e.g., latency). If it does, you have gained a very valuable piece of data you can use to make important engineering decisions for your service going forward.\n\nAdvanced Topics\n\n|\n\n41\n\nThis exercise should not be a one-time activity. As your service evolves, so will your customers’ expectations. Make sure you regularly review the ongoing validity of the relationship.\n\nThis sort of analysis is also risky because you can misinterpret the data you get. For example, if you artificially slow your pages down by 50 ms and notice that no corre‐ sponding loss in conversions occurs, you might conclude that your latency SLO is too strict. However, your users might be unhappy, but simply lacking an alternative to your service at the moment. As soon as a competitor comes along, your users will leave. Be sure you are measuring the correct indicators, and take appropriate precautions.\n\nConclusion Every topic covered in this book can be tied back to SLOs. Now that you’ve read this chapter, we hope you’ll agree that even partly formalized SLOs (which clearly state your promises to users) offer a framework to discuss system behavior with greater clarity, and can help with pinpointing actionable remedies when services fail to meet expectations.\n\nTo summarize:\n\nSLOs are the tool by which you measure your service’s reliability.\n\nError budgets are a tool for balancing reliability with other engineering work, and a great way to decide which projects will have the most impact.\n\nYou should start using SLOs and error budgets today.\n\nFor an example SLO document and an example error budget policy, see Appendixes A and B.\n\n42\n\n|\n\nChapter 2: Implementing SLOs\n\nCHAPTER 3 SLO Engineering Case Studies\n\nBy Ben McCormack (Evernote) and William Bonnell (The Home Depot) with Garrett Plasky (Evernote), Alex Hidalgo, Betsy Beyer, and Dave Rensin\n\nWhile many tenets of SRE were shaped within the walls of Google, its principles have long lived outside our gates. Many standard Google SRE practices have been discov‐ ered in parallel or otherwise been adopted by many other organizations across the industry.\n\nSLOs are fundamental to the SRE model. Since we launched the Customer Reliability Engineering (CRE) team—a group of experienced SREs who help Google Cloud Plat‐ form (GCP) customers build more reliable services—almost every customer interac‐ tion starts and ends with SLOs.\n\nHere we present two stories, told by two very different companies, that outline their journeys toward adopting an SLO and error budget–based approach while working with the Google CRE team. For a more general discussion about SLOs and error budgets, see Chapter 2 in this book, and Chapter 3 in our first book.\n\nEvernote’s SLO Story by Ben McCormack, Evernote\n\nEvernote is a cross-platform app that helps individuals and teams create, assemble, and share information. With more than 220 million users worldwide, we store over 12 billion pieces of information—a mix of text-based notes, files, and attachments/ images—within the platform. Behind the scenes, the Evernote service is supported by 750+ MySQL instances.\n\n43\n\nWe introduced the concept of SLOs to Evernote as part of a much wider technology revamp aimed at increasing engineering velocity while maintaining quality of service. Our goals included:\n\nMove engineering focus away from undifferentiated heavy lifting in datacenters and toward product engineering work that customers actually cared about. To that end, we stopped running our physical datacenters and moved to a public cloud.\n\nRevise the working model of operations and software engineers to support an increase in feature velocity while maintaining overall quality of service.\n\nRevamp how we look at SLAs to ensure that we increase focus on how failures impact our large global customer base.\n\nThese goals may look familiar to organizations across many industries. While no sin‐ gle approach to making these types of changes will work across the board, we hope that sharing our experience will provide valuable insights for others facing similar challenges.\n\nWhy Did Evernote Adopt the SRE Model? At the outset of this transition, Evernote was characterized by a traditional ops/dev split: an operations team protected the sanctity of the production environment, while a development team was tasked with developing new product features for customers. These objectives were usually in conflict: the dev team felt constrained by lengthy operational requirements, while the ops team became frustrated when new code introduced new issues in production. As we swung wildly between these two goals, the ops and dev teams developed a frustrated and strained relationship. We wanted to reach a happier medium that better balanced the varying needs of the teams involved.\n\nWe attempted to address the gaps in this traditional dichotomy in various ways over the course of five-plus years. After trying out a “You wrote it, you run it” (develop‐ ment) model, and a “You wrote it, we run it for you” (operations) model, we moved toward an SLO-centric SRE approach.\n\nSo what motivated Evernote to move in this direction?\n\nAt Evernote, we view the core disciplines of operations and development as separate professional tracks in which engineers can specialize. One track is concerned with the nearly 24/7 ongoing delivery of a service to customers. The other is concerned with the extension and evolution of that service to meet customer needs in the future. These two disciplines have moved toward each other in recent years as movements like SRE and DevOps emphasize software development as applied to operations. (This convergence has been furthered by advances in datacenter automation and the\n\n44\n\n|\n\nChapter 3: SLO Engineering Case Studies\n\ngrowth of public clouds, both of which give us a datacenter that can be fully con‐ trolled by software.) On the other side of the spectrum, full-stack ownership and con‐ tinuous deployment are increasingly applied to software development.\n\nWe were drawn to the SRE model because it fully embraces and accepts the differ‐ ences between operations and development while encouraging teams to work toward a common goal. It does not try to transform operations engineers into application developers, or vice versa. Instead, it gives both a common frame of reference. In our experience, an error budget/SLO approach has led both teams to make similar deci‐ sions when presented with the same facts, as it removes a good deal of subjectivity from the conversation.\n\nIntroduction of SLOs: A Journey in Progress The first part of our journey was the move from physical datacenters to Google Cloud Platform.1 Once the Evernote service was up and running on GCP and stabi‐ lized, we introduced SLOs. Our objectives here were twofold:\n\nAlign teams internally around Evernote SLOs, ensuring that all teams were work‐ ing within the new framework.\n\nIncorporate Evernote’s SLO into how we work with the Google Cloud team, who now had responsibility for our underlying infrastructure. Since we now had a new partner within the overall model, we needed to ensure the move to GCP did not dilute or mask our commitment to our users.\n\nAfter actively using SLOs for about nine months, Evernote is already on version 3 of its SLO practice!\n\nBefore getting into the technical details of an SLO, it is important to start the conver‐ sation from your customers’ point of view: what promises are you trying to uphold? Similar to most services, Evernote has many features and options that our users put to use in a variety of creative ways. We wanted to ensure we initially focused on the most important and common customer need: the availability of the Evernote service for users to access and sync their content across multiple clients. Our SLO journey started from that goal. We kept our first pass simple by focusing on uptime. Using this simple first approach, we could clearly articulate what we were measuring, and how.\n\n1 But that’s a story for another book—see more details at http://bit.ly/2spqgcl.\n\nEvernote’s SLO Story\n\n|\n\n45\n\nOur first SLOs document contained the following:\n\nA definition of the SLOs\n\nThis was an uptime measure: 99.95% uptime measured over a monthly window, set for certain services and methods. We chose this number based upon discus‐ sions with our internal customer support and product teams and—more impor‐ tantly—user feedback. We deliberately chose to bind our SLOs to a calendar month versus a rolling period to keep us focused and organized when running service reviews.\n\nWhat to measure, and how to measure it\n\nWhat to measure\n\nWe specified a service endpoint we could call to test whether the service was functioning as expected. In our case, we have a status page built into our ser‐ vice that exercises most of our stack and returns a 200 status code if all is well.\n\nHow to measure\n\nWe wanted a prober that called the status page periodically. We wanted that prober to be located completely outside of and independent from our envi‐ ronment so we could test all our components, including our load balancing stack. Our goal here was to make sure that we were measuring any and all failures of both the GCP service and the Evernote application. However, we did not want random internet issues to trigger false positives. We chose to use a third-party company that specializes in building and running such probers. We selected Pingdom, but there are many others in the market. We conduct our measurements as follows:\n\nFrequency of probe: We poll our frontend nodes every minute.\n\nLocation of probers: This setting is configurable; we currently use mul‐ tiple probes in North America and Europe.\n\nDefinition of “down”: If a prober check fails, the node is marked as Unconfirmed Down and then a second geographically separate prober performs a check. If the second check fails, the node is marked down for SLO calculation purposes. The node will continue to be marked as down as long as consecutive probe requests register errors.\n\nHow to calculate SLOs from monitoring data\n\nFinally, we carefully documented how we calculate the SLO from the raw data we received from Pingdom. For example, we specified how to account for mainte‐ nance windows: we could not assume that all of our hundreds of millions of users knew about our published maintenance windows. Uninformed users would\n\n46\n\n|\n\nChapter 3: SLO Engineering Case Studies\n\ntherefore experience these windows as generic and unexplained downtime, so our SLO calculations treated maintenance as downtime.\n\nOnce we defined our SLOs, we had to do something with them. We wanted the SLOs to drive software and operations changes that would make our customers happier and keep them happy. How best to do this?\n\nWe use the SLO/error budget concept as a method to allocate resources going for‐ ward. For example, if we missed the SLO for last month, that behavior helps us pri‐ oritize relevant fixes, improvements, and bug fixes. We keep it simple: teams from both Evernote and Google conduct a monthly review of SLO performance. At this meeting, we review the SLO performance from the previous month and perform a deep dive on any outages. Based on this analysis of the past month, we set action items for improvements that may not have been captured through the regular root- cause-analysis process.\n\nThroughout this process, our guiding principle has been “Perfect is the enemy of good.” Even when SLOs aren’t perfect, they’re good enough to guide improvements over time. A “perfect” SLO would be one that measures every possible user interac‐ tion with our service and accounts for all edge cases. While this is a great idea on paper, it would take many months to achieve (if achieving perfection were even pos‐ sible)—time which we could use to improve the service. Instead, we selected an initial SLO that covered most, but not all, user interactions, which was a good proxy for quality of service.\n\nSince we began, we have revised our SLOs twice, according to signals from both our internal service reviews and in response to customer-impacting outages. Because we weren’t aiming for perfect SLOs at the outset, we were comfortable with making changes to better align with the business. In addition to our monthly Evernote/ Google review of SLO performance, we’ve settled on a six-month SLO review cycle, which strikes the right balance between changing SLOs too often and letting them become stale. In revising our SLOs, we’ve also learned that it’s important to balance what you would like to measure with what’s possible to measure.\n\nSince introducing SLOs, the relationship between our operations and development teams has subtly but markedly improved. The teams now have a common measure of success: removing the human interpretation of quality of service (QoS) has allowed both teams to maintain the same view and standards. To provide just one example, SLOs provided a common ground when we had to facilitate multiple releases in a compressed timeline in 2017. While we chased down a complex bug, product devel‐ opment requested that we apportion our normal weekly release over multiple sepa‐ rate windows, each of which would potentially impact customers. By applying an SLO calculation to the problem and removing human subjectivity from the scenario, we were able to better quantify customer impact and reduce our release windows from five to two to minimize customer pain.\n\nEvernote’s SLO Story\n\n|\n\n47",
      "page_number": 68
    },
    {
      "number": 9,
      "title": "Segment 9 (pages 76-83)",
      "start_page": 76,
      "end_page": 83,
      "detection_method": "topic_boundary",
      "content": "Breaking Down the SLO Wall Between Customer and Cloud Provider A virtual wall between customer and cloud provider concerns might seem natural or inevitable. While Google has SLOs and SLAs (service level agreements) for the GCP platforms we run Evernote on, Evernote has its own SLOs and SLAs. It’s not always expected that two such engineering teams would be informed about each other’s SLAs.\n\nEvernote never wanted such a wall. Of course, we could have engineered to a dividing wall, basing our SLOs and SLAs on the underlying GCP metrics. Instead, from the beginning, we wanted Google to understand which performance characteristics were most important to us, and why. We wanted to align Google’s objectives with ours, and for both companies to view Evernote’s reliability successes and failures as shared responsibilities. To achieve this, we needed a way to:\n\nAlign objectives\n\nEnsure our partner (in this case, Google) really understood what’s important to us\n\nShare both successes and failures\n\nMost service providers manage to the published SLO/SLAs for their cloud services. Working within this context is important, but it can’t holistically represent how well our service is running within the cloud provider’s environment.\n\nFor example, a given cloud provider probably runs hundreds of thousands of virtual machines globally, which they manage for uptime and availability. GCP promises 99.95% availability for Compute Engine (i.e., its virtual machines). Even when GCP SLO graphs are green (i.e., above 99.95%), Evernote’s view of the same SLO might be very different: because our virtual machine footprint is only a small percentage of the global GCP number, outages isolated to our region (or isolated for other reasons) may be “lost” in the overall rollup to a global level.\n\nTo correct for scenarios like this, we share our SLO and real-time performance against SLO with Google. As a result, both the Google CRE team and Evernote work with same performance dashboards. This may seem like a very simple point, but has proven a rather powerful way to drive truly customer-focused behavior. As a result, rather than receiving generic “Service X is running slow”–type notifications, Google provides us with notifications that are more specific to our environment. For exam‐ ple, in addition to a generic “GCP load balancing environment is running slow today,” we’ll also be informed that this issue is causing a 5% impact to Evernote’s SLO. This relationship also helps teams within Google, who can see how their actions and decisions impact customers.\n\n48\n\n|\n\nChapter 3: SLO Engineering Case Studies\n\nThis two-way relationship has also given us a very effective framework to support major incidents. Most of the time, the usual model of P1–P5 tickets and regular sup‐ port channels works well and allows us to maintain good service and a good relation‐ ship with Google. But we all know there are times when a P1 ticket (“major impact to our business”) is not enough—the times when your whole service is on the line and you face extended business impact.\n\nAt times like these, our shared SLOs and relationship with the CRE team come to fru‐ ition. We have a common understanding that if the SLO impact is high enough, both parties will treat the issue as a P1 ticket with special handling. Quite often, this means that Evernote and Google’s CRE Team rapidly mobilize on a shared conference bridge. The Google CRE team monitors the SLO we jointly defined and agreed upon, allowing us to remain in sync in terms of prioritization and appropriate responses.\n\nCurrent State After actively using SLOs for about nine months, Evernote is already on version 3 of its SLO practice. The next version of SLOs will progress from our simple uptime SLO. We plan to start probing individual API calls and accounting for the in-client view of metrics/performance so we can represent user QoS even better.\n\nBy providing a standard and defined way of measuring QoS, SLOs have allowed Ever‐ note to better focus on how our service is running. We can now have data-driven conversations—both internally, and with Google—about the impact of outages, which enables us to drive service improvements, ultimately making for more effective support teams and happier customers.\n\nThe Home Depot’s SLO Story by William Bonnell, The Home Depot\n\nThe Home Depot (THD) is the world’s largest home improvement retailer: we have more than 2,200 stores across North America, each filled with more than 35,000 unique products (and supplemented with over 1.5 million products online). Our infrastructure hosts a variety of software applications that support nearly 400,000 associates and process more than 1.5 billion customer transactions per year. The stores are deeply integrated with a global supply chain and an ecommerce website that receives more than 2 billion visits per year.\n\nIn a recent refresh to our operations approach aimed at increasing the velocity and quality of our software development, THD both pivoted to Agile software develop‐ ment and changed how we design and manage our software. We moved from cen‐ tralized support teams that supported large, monolithic software packages to a microservices architecture led by small, independently operated software develop‐\n\nThe Home Depot’s SLO Story\n\n|\n\n49\n\nment teams. As a result, our system now had smaller chunks of constantly changing software, which also needed to be integrated across the stack.\n\nOur move to microservices was complemented by a move to a new “freedom and responsibility culture” of full-stack ownership. This approach gives developers free‐ dom to push code when they want, but also makes them jointly responsible for the operations of their service. For this model of joint ownership to work, operations and development teams need to speak a common language that promotes accountability and cuts across complexity: service level objectives. Services that depend upon each other need to know information like:\n\nHow reliable is your service? Is it built for three 9s, three and a half 9s, or four 9s (or better)? Is there planned downtime?\n\nWhat kind of latency can I expect at the upper bounds?\n\nCan you handle the volume of requests I am going to send? How do you handle overload? Has your service achieved its SLOs over time?\n\nIf every service could provide transparent and consistent answers to these questions, teams would have a clear view into their dependencies, which allows for better com‐ munication and increased trust and accountability between teams.\n\nThe SLO Culture Project Before we began this shift in our service model, The Home Depot didn’t have a cul‐ ture of SLOs. Monitoring tools and dashboards were plentiful, but were scattered everywhere and didn’t track data over time. We weren’t always able to pinpoint the service at the root of a given outage. Often, we began troubleshooting at the user- facing service and worked backward until we found the problem, wasting countless hours. If a service required planned downtime, its dependent services were surprised. If a team needed to build a three and a half 9s service, they wouldn’t know if the ser‐ vice they had a hard dependency on could support them with even better uptime (four 9s). These disconnects caused confusion and disappointment between our soft‐ ware development and operations teams.\n\nWe needed to address these disconnects by building a common culture of SLOs. Doing so required an overarching strategy to influence people, process, and technol‐ ogy. Our efforts spanned four general areas:\n\nCommon vernacular\n\nDefine SLOs in the context of THD. Define how to measure them in a consistent way.\n\n50\n\n|\n\nChapter 3: SLO Engineering Case Studies\n\nEvangelism\n\nSpread the word across the company.\n\nCreate training material to sell why SLOs matter, road shows across the com‐ pany, internal blogs, and promotional materials like t-shirts and stickers.\n\nEnlist a few early adopters to implement SLOs and demonstrate the value to others.\n\nEstablish a catchy acronym (VALET; as discussed later) to help the idea spread.\n\nCreate a training program (FiRE Academy: Fundamentals in Reliability Engineering) to train developers on SLOs and other reliability concepts.2\n\nAutomation\n\nTo reduce the friction of adoption, implement a metric collection platform to automatically collect service level indicators for any service deployed to produc‐ tion. These SLIs can later be more easily turned into SLOs.\n\nIncentive\n\nEstablish annual goals for all development managers to set and measure SLOs for their services.\n\nEstablishing a common vernacular was critical to getting everybody on the same page. We also wanted to keep this framework as simple as possible to help the idea spread faster. To get started, we took a critical look at the metrics we monitored across our various services and discovered some patterns. Every service monitored some form of its traffic volume, latency, errors, and utilization—metrics that map closely to Google SRE’s Four Golden Signals. In addition, many services monitored uptime or availability distinctly from errors. Unfortunately, across the board, all cat‐ egories of metrics were inconsistently monitored, were named differently, or had insufficient data.\n\nNone of our services had SLOs. The closest metric our production systems had to a customer-facing SLO was support tickets. The primary (and often only) way we measured the reliability of the applications deployed to our stores was by tracking the number of support calls our internal support desk receives.\n\n2 Training options range from a one-hour primer to half-day workshops to intense four-week immersion with\n\na mature SRE team, complete with a graduation ceremony and a FiRE badge.\n\nThe Home Depot’s SLO Story\n\n|\n\n51\n\nOur First Set of SLOs We couldn’t create SLOs for every aspect of our systems that could be measured, so we had to decide which metrics or SLIs should also have SLOs.\n\nAvailability and latency for API calls\n\nWe decided that each microservice had to have availability and latency SLOs for its API calls that were called by other microservices. For example, the Cart microservice called the Inventory microservice. For those API calls, the Inventory microservice published SLOs that the Cart microservice (and other microservices that needed Inventory) could consult to determine if the Inventory microservice could meet its reliability requirements\n\nInfrastructure utilization\n\nTeams at THD measure infrastructure utilization in different ways, but the most typi‐ cal measurement is real-time infrastructure utilization at one minute granularity. We decided against setting utilization SLOs for a few reasons. To begin with, microservi‐ ces aren’t overly concerned with this metric—your users don’t really care about uti‐ lization as long as you can handle the traffic volume, your microservice is up, it’s responding quickly, it’s not throwing errors, and you’re not in danger of running out of capacity. Additionally, our impending move to the cloud meant that utilization would be less of a concern, so cost planning would overshadow capacity planning. (We’d still need to monitor utilization and perform capacity planning, but we didn’t need to include it in our SLO framework.)\n\nTraffic volume\n\nBecause THD didn’t already have a culture of capacity planning, we needed a mecha‐ nism for software and operations teams to communicate how much volume their ser‐ vice could handle. Traffic was easy to define as requests to a service, but we needed to decide if we should track average requests per second, peak requests per second, or the volume of requests over the reporting time period. We decided to track all three and let each service select the most appropriate metric. We debated whether or not to set an SLO for traffic volume because this metric is determined by user behavior, rather than internal factors that we can control. Ultimately, we decided that as a retailer we needed to size our service for peaks like Black Friday, so we set an SLO according to expected peak capacity.\n\nLatency\n\nWe let each service define its SLO for latency and determine where to best measure it. Our only request was that a service should supplement our common white-box per‐ formance monitoring with black-box monitoring to catch issues caused by the\n\n52\n\n|\n\nChapter 3: SLO Engineering Case Studies\n\nnetwork or other layers like caches and proxies that fail outside the microservice. We also decided that percentiles were more appropriate than arithmetic averages. At minimum, services needed to hit a 90th percentile target; user-facing services had a preferred target of 95th and/or 99th percentile.\n\nErrors\n\nErrors were somewhat complicated to account for. Since we were primarily dealing with web services, we had to standardize what constitutes an error and how to return errors. If a web service encountered an error, we naturally standardized on HTTP response codes:\n\nA service should not indicate an error in the body of a 2xx response; rather, it should throw either a 4xx or a 5xx.\n\nAn error caused by a problem with the service (for example, out of memory) should throw a 5xx error.\n\nAn error caused by the client (for example, sending a malformed request) should throw a 4xx error.\n\nAfter much deliberation, we decided to track both 4xx and 5xx errors, but used 5xx errors only to set SLOs. Similar to our approach for other SLO-related elements, we kept this dimension generic so that different applications could leverage it for differ‐ ent contexts. For example, in addition to HTTP errors, errors for a batch processing service might be the number of records that failed to process.\n\nTickets\n\nAs previously mentioned, tickets were originally the primary way we evaluated most of our production software. For historical reasons, we decided to continue to track tickets alongside our other SLOs. You can consider this metric as analogous to some‐ thing like “software operation level.”\n\nVALET\n\nWe summed up our new SLOs into a handy acronym: VALET.\n\nVolume (traffic)\n\nHow much business volume can my service handle?\n\nAvailability\n\nIs the service up when I need it?\n\nLatency\n\nDoes the service respond fast when I use it?\n\nThe Home Depot’s SLO Story\n\n|\n\n53\n\nErrors\n\nDoes the service throw an error when I use it?\n\nTickets\n\nDoes the service require manual intervention to complete my request?\n\nEvangelizing SLOs Armed with an easy-to-remember acronym, we set out to evangelize SLOs to the enterprise:\n\nWhy SLOs are important\n\nHow SLOs support our “freedom and responsibility” culture\n\nWhat should be measured\n\nWhat to do with the results\n\nSince developers were now responsible for the operation of their software, they needed to establish SLOs to demonstrate their ability to build and support reliable software, and also to communicate with the consumers of their services and product managers for customer-facing services. However, most of this audience was unfami‐ liar with concepts like SLAs and SLOs, so they needed to be educated on this new VALET framework.\n\nAs we needed to secure executive backing for our move to SLOs, our education cam‐ paign started with senior leadership. We then met with development teams one by one to espouse the values of SLOs. We encouraged teams to move from their custom metric-tracking mechanisms (which were often manual) to the VALET framework. To keep the momentum going, we sent a weekly SLO report in VALET format, which we paired with commentary around general reliability concepts and lessons learned from internal events, to senior leadership. This also helped frame business metrics like purchase orders created (Volume) or purchase orders that failed to process (Errors) in terms of VALET.\n\nWe also scaled our evangelism in a number of ways:\n\nWe set up an internal WordPress site to host blogs about VALET and reliability, outlinking to useful resources.\n\nWe conducted internal Tech Talks (including a Google SRE guest speaker) to discuss general reliability concepts and how to measure with VALET.\n\nWe conducted a series of VALET training workshops (which would later evolve into FiRE Academy), and opened the invite to whomever wanted to attend. The attendance for these workshops stayed strong for several months.\n\n54\n\n|\n\nChapter 3: SLO Engineering Case Studies\n\nWe even created VALET laptop stickers and t-shirts to support a comprehensive internal marketing campaign.\n\nSoon everybody in the company knew VALET, and our new culture of SLOs began to take hold. SLO implementation even began to officially factor into THD’s annual performance reviews for development managers. While roughly 50 services were reg‐ ularly capturing and reporting on their SLOs on a weekly basis, we were storing the metrics ad hoc in a spreadsheet. Although the idea of VALET had caught on like wildfire, we needed to automate data collection to foster widespread adoption.\n\nAutomating VALET Data Collection While our culture of SLOs now had a strong foothold, automating VALET data col‐ lection would accelerate SLO adoption.\n\nTPS Reports\n\nWe built a framework to automatically capture VALET data for any service that was deployed to our new GCP environment. We called this framework TPS Reports, a play on the term we used for volume and performance testing (transactions per sec‐ ond), and, of course, to poke fun3 at the idea that multiple managers might want to review this data. We built the TPS Reports framework on top of GCP’s BigQuery database platform. All of the logs generated by our web-serving frontend were fed into BigQuery for processing by TPS Reports. We eventually also included metrics from a variety of other monitoring systems such as Stackdriver’s probe for availabil‐ ity.\n\nTPS Reports transformed this data into hourly VALET metrics that anyone could query. Newly created services were automatically registered into TPS Reports and therefore could be immediately queried. Since the data was all stored in BigQuery, we could efficiently report on VALET metrics across time frames. We used this data to build a variety of automated reports and alerts. The most interesting integration was a chatbot that let us directly report on the VALET of services in a commercial chat platform. For example, any service could display VALET for the last hour, VALET versus previous week, services out of SLO, and a variety of other interesting data right inside the chat channel.\n\nVALET service\n\nOur next step was to create a VALET application to store and report on SLO data. Because SLOs are best leveraged as a trending tool, the service tracks SLOs at daily, weekly, and monthly granularity. Note that our SLOs are a trending tool that we can\n\n3 As made famous in the 1999 film Office Space.\n\nThe Home Depot’s SLO Story\n\n|\n\n55",
      "page_number": 76
    },
    {
      "number": 10,
      "title": "Segment 10 (pages 84-91)",
      "start_page": 84,
      "end_page": 91,
      "detection_method": "topic_boundary",
      "content": "use for error budgets, but aren’t directly connected to our monitoring systems. Instead, we have a variety of disparate monitoring platforms, each with its own alert‐ ing. Those monitoring systems aggregate their SLOs on a daily basis and publish to the VALET service for trending. The downside of this setup is that alerting thresh‐ olds set in the monitoring systems aren’t integrated with SLOs; however, we have the flexibility to change out monitoring systems as needed.\n\nAnticipating the need to integrate VALET with other applications not running in GCP, we created a VALET integration layer that provides an API to collect aggrega‐ ted VALET data for a service daily. TPS Reports was the first system to integrate with the VALET service, and we eventually integrated with a variety of on-premises appli‐ cation platforms (more than half of the services registered in VALET).\n\nVALET Dashboard\n\nThe VALET Dashboard (shown in Figure 3-1) is our UI to visualize and report on this data and is relatively straightforward. It allows users to:\n\nRegister a new service. This typically means assigning the service to one or more URLs, which may already have VALET data collected.\n\nSet SLO objectives for any of the five VALET categories.\n\nAdd new metrics types under each of the VALET categories. For example, one service may track latency at the 99th percentile, while another tracks latency at the 90th percentile (or both). Or, a backend processing system may track volume at a daily level (purchase orders created in a day), whereas a customer-serving frontend may track peak transactions per second.\n\nThe VALET Dashboard lets users report on SLOs for many services at once, and to slice and dice the data in a variety of ways. For example, a team can view stats for all of their services that missed SLO in the past week. A team seeking to review service performance can view latency across all of their services and the services they depend upon. The VALET Dashboard stores the data in a simple Cloud SQL database, and developers use a popular commercial reporting tool to build reports.\n\nThese reports became the foundation for a new best practice with developers: regular SLO reviews of their services (typically, either weekly or monthly). Based upon these reviews, developers can create action items to return a service to its SLO, or perhaps decide that an unrealistic SLO needs to be adjusted.\n\n56\n\n|\n\nChapter 3: SLO Engineering Case Studies\n\nFigure 3-1. The VALET Dashboard\n\nThe Proliferation of SLOs Once SLOs were firmly cemented in the organization’s collective mind and effective automation and reporting were in place, new SLOs proliferated quickly. After track‐ ing SLOs for about 50 services at the beginning of the year, by the end of the year we were tracking SLOs for 800 services, with about 50 new services per month being reg‐ istered with VALET.\n\nBecause VALET allowed us to scale SLO adoption across THD, the time effort required to develop automation was well worth it. However, other companies shouldn’t be scared away from adopting an SLO-based approach if they can’t develop similarly complex automation. While automation provided THD extra benefits, there are benefits to just writing SLOs in the first place.\n\nApplying VALET to Batch Applications As we developed robust reporting around SLOs, we discovered some additional uses for VALET. With a little adjusting, batch applications can fit into this framework as follows:\n\nThe Home Depot’s SLO Story\n\n|\n\n57\n\nVolume\n\nThe volume of records processed\n\nAvailability\n\nHow often (as a percentage) the job completed by a certain time\n\nLatency\n\nThe amount of time it takes for the job to run\n\nErrors\n\nThe records that failed to process\n\nTickets\n\nThe number of times an operator has to manually fix data and reprocess a job\n\nUsing VALET in Testing Since we were developing an SRE culture at the same time, we found that VALET supported our destructive testing (chaos engineering) automation in our staging environments. With the TPS Reports framework in place, we could automatically run destructive tests and record the impact (or hopefully lack of impact) to the service’s VALET data.\n\nFuture Aspirations With 800 services (and growing) collecting VALET data, we have a lot of useful operational data at our disposal. We have several aspirations for the future.\n\nNow that we are effectively collecting SLOs, we want to use this data to take action. Our next step is an error budget culture similar to Google, whereby a team stops pushing new features (other than improvements to reliability) when a service is out of SLO. To protect the velocity demands of our business, we’ll have to strive to find a good balance between the SLO reporting time frame (weekly or monthly) and the fre‐ quency of SLOs being breached. Like many companies adopting error budgets, we’re weighing the pros and cons of rolling windows versus fixed windows.\n\nWe want to further refine VALET to track detailed endpoints and the consumers of a service. Currently, even if a particular service has multiple endpoints, we track VALET only across the entire service. As a result, it’s difficult to distinguish between different operations (for example, a write to the catalog versus a read to the catalog; while we monitor and alert on these operations separately, we don’t track SLOs). Similarly, we’d also like to differentiate VALET results for different consumers of a service.\n\nAlthough we currently track latency SLOs at the web-serving layer, we’d also like to track a latency SLO for end users. This measurement would capture how factors like\n\n58\n\n|\n\nChapter 3: SLO Engineering Case Studies\n\nthird-party tags, internet latency, and CDN caching affect how long it takes a page to start rendering and to complete rendering.\n\nWe’d also like to extend VALET data to application deployments. Specifically, we’d like to use automation to verify that VALET is within tolerance before rolling out a change to the next server, zone, or region.\n\nWe’ve started to collect information about service dependencies, and have prototy‐ ped a visual graph that shows where we’re not hitting VALET metrics along a call tree. This type of analysis will become even easier with emerging service mesh plat‐ forms.\n\nFinally, we strongly believe that the SLOs for a service should be set by the business owner of the service (often called a product manager) based on its criticality to the business. At the very least, we want the business owners to set the requirement for a service’s uptime and use that SLO as a shared objective between product manage‐ ment and development. Although technologists found VALET intuitive, the concept wasn’t so intuitive for product managers. We are striving to simplify the concepts of VALET using terminology relevant to them: we’ve both simplified the number of choices for uptime and provided example metrics. We also emphasize the significant investment required to move from one level to another. Here’s an example of simpli‐ fied VALET metrics we might provide:\n\n99.5%: Applications that are not used by store associates or an MVP of a new service\n\n99.9%: Adequate for the majority of nonselling systems at THD\n\n99.95%: Selling systems (or services that support selling systems)\n\n99.99%: Shared infrastructure services\n\nCasting metrics in business terms and sharing a visible goal (an SLO!) between prod‐ uct and development will reduce a lot of misaligned expectations about reliability often seen in large companies.\n\nSummary Introducing a new process, let alone a new culture, to a large company takes a good strategy, executive buy-in, strong evangelism, easy adoption patterns, and—most of all—patience. It might take years for a significant change like SLOs to become firmly established at a company. We’d like to emphasize that The Home Depot is a tradi‐ tional enterprise; if we can introduce such a large change successfully, you can too. You also don’t have to approach this task all at once. While we implemented SLOs piece by piece, developing a comprehensive evangelism strategy and clear incentive structure facilitated a quick transformation: we went from 0 to 800 SLO-supported services in less than a year.\n\nThe Home Depot’s SLO Story\n\n|\n\n59\n\nConclusion SLOs and error budgets are powerful concepts that help address many different prob‐ lem sets. These case studies from Evernote and The Home Depot present very real examples of how implementing an SLO culture can bring product development and operations closer together. Doing so can facilitate communication and better inform development decisions. It will ultimately result in better experiences for your custom‐ ers—whether those customers are internal, external, humans, or other services.\n\nThese two case studies highlight that SLO culture is an ongoing process and not a one-time fix or solution. While they share philosophical underpinnings, THD’s and Evernote’s measurement styles, SLIs, SLOs, and implementation details are markedly different. Both stories complement Google’s own take on SLOs by demonstrating that SLO implementation need not be Google-specific. Just as these companies tail‐ ored SLOs to their own unique environments, so can other companies and organizations.\n\n60\n\n|\n\nChapter 3: SLO Engineering Case Studies\n\nCHAPTER 4 Monitoring\n\nBy Jess Frame, Anthony Lenton, Steven Thurgood, Anton Tolchanov, and Nejc Trdin with Carmela Quinito\n\nMonitoring can include many types of data, including metrics, text logging, struc‐ tured event logging, distributed tracing, and event introspection. While all of these approaches are useful in their own right, this chapter mostly addresses metrics and structured logging. In our experience, these two data sources are best suited to SRE’s fundamental monitoring needs.\n\nAt the most basic level, monitoring allows you to gain visibility into a system, which is a core requirement for judging service health and diagnosing your service when things go wrong. Chapter 6 in the first SRE book provides some basic monitoring definitions and explains that SREs monitor their systems in order to:\n\nAlert on conditions that require attention.\n\nInvestigate and diagnose those issues.\n\nDisplay information about the system visually.\n\nGain insight into trends in resource usage or service health for long-term planning.\n\nCompare the behavior of the system before and after a change, or between two groups in an experiment.\n\nThe relative importance of these use cases might lead you to make tradeoffs when selecting or building a monitoring system.\n\n61\n\nThis chapter talks about how Google manages monitoring systems and provides some guidelines for questions that may arise when you’re choosing and running a monitoring system.\n\nDesirable Features of a Monitoring Strategy When choosing a monitoring system, it is important to understand and prioritize the features that matter to you. If you’re evaluating different monitoring systems, the attributes in this section can help guide your thinking about which solution(s) best suits your needs. If you already have a monitoring strategy, you might consider using some additional capabilities of your current solution. Depending on your needs, one monitoring system may address all of your use cases, or you may want to use a com‐ bination of systems.\n\nSpeed Different organizations will have different needs when it comes to the freshness of data and the speed of data retrieval.\n\nData should be available when you need it: freshness impacts how long it will take your monitoring system to page you when something goes wrong. Additionally, slow data might lead you to accidentally act on incorrect data. For example, during inci‐ dent response, if the time between cause (taking an action) and effect (seeing that action reflected in your monitoring) is too long, you might assume a change had no effect or deduce a false correlation between cause and effect. Data more than four to five minutes stale might significantly impact how quickly you can respond to an incident.\n\nIf you’re selecting a monitoring system based upon this criteria, you need to figure out your speed requirements ahead of time. Speed of data retrieval is mostly a prob‐ lem when you’re querying vast amounts of data. It might take some time for a graph to load if it has to tally up a lot of data from many monitored systems. To speed up your slower graphs, it’s helpful if the monitoring system can create and store new time series based on incoming data; then it can precompute answers to common queries.\n\nCalculations Support for calculations can span a variety of use cases, across a range of complexi‐ ties. At a minimum, you’ll probably want your system to retain data over a multi‐ month time frame. Without a long-term view of your data, you cannot analyze long- term trends like system growth. In terms of granularity, summary data (i.e., aggregated data that you can’t drill down into) is sufficient to facilitate growth plan‐ ning. Retaining all detailed individual metrics may help with answering questions\n\n62\n\n|\n\nChapter 4: Monitoring\n\nlike, “Has this unusual behavior happened before?” However, the data might be expensive to store or impractical to retrieve.\n\nThe metrics you retain about events or resource consumption should ideally be monotonically incrementing counters. Using counters, your monitoring system can calculate windowed functions over time—for example, to report the rate of requests per second from that counter. Computing these rates over a longer window (up to a month) allows you to implement the building blocks for SLO burn-based alerting (see Chapter 5).\n\nFinally, support for a more complete range of statistical functions can be useful because trivial operations may mask bad behavior. A monitoring system that sup‐ ports computing percentiles (i.e., 50th, 95th, 99th percentiles) when recording latency will let you see if 50%, 5%, or 1% of your requests are too slow, whereas the arith‐ metic mean can only tell you—without specifics—that the request time is slower. Alternatively, if your system doesn’t support computing percentiles directly, you can achieve this by:\n\nObtaining a mean value by summing the seconds spent in requests and dividing by the number of requests\n\nLogging every request and computing the percentile values by scanning or sam‐ pling the log entries\n\nYou might want to record your raw metric data in a separate system for offline analy‐ sis—for example, to use in weekly or monthly reports, or to perform more intricate calculations that are too difficult to compute in your monitoring system.\n\nInterfaces A robust monitoring system should allow you to concisely display time-series data in graphs, and also to structure data in tables or a range of chart styles. Your dashboards will be primary interfaces for displaying monitoring, so it’s important that you choose formats that most clearly display the data you care about. Some options include heatmaps, histograms, and logarithmic scale graphs.\n\nYou’ll likely need to offer different views of the same data based upon audience; high- level management may want to view quite different information than SREs. Be spe‐ cific about creating dashboards that make sense to the people consuming the content. For each set of dashboards, displaying the same types of data consistently is valuable for communication.\n\nYou might need to graph information across different aggregations of a metric—such as machine type, server version, or request type—in real time. It’s a good idea for your team to be comfortable with performing ad hoc drill-downs on your data. By\n\nDesirable Features of a Monitoring Strategy\n\n|\n\n63",
      "page_number": 84
    },
    {
      "number": 11,
      "title": "Segment 11 (pages 92-99)",
      "start_page": 92,
      "end_page": 99,
      "detection_method": "topic_boundary",
      "content": "slicing your data according to a variety of metrics, you can look for correlations and patterns in the data when you need it.\n\nAlerts It’s helpful to be able to classify alerts: multiple categories of alerts allow for propor‐ tional responses. The ability to set different severity levels for different alerts is also useful: you might file a ticket to investigate a low rate of errors that lasts more than an hour, while a 100% error rate is an emergency that deserves immediate response.\n\nAlert suppression functionality lets you avoid unnecessary noise from distracting on- call engineers. For example:\n\nWhen all nodes are experiencing the same high rate of errors, you can alert just once for the global error rate instead of sending an individual alert for every sin‐ gle node.\n\nWhen one of your service dependencies has a firing alert (e.g., a slow backend), you don’t need to alert for error rates of your service.\n\nYou also need to be able to ensure alerts are no longer suppressed once the event is over.\n\nThe level of control you require over your system will dictate whether you use a third-party monitoring service or deploy and run your own monitoring system. Goo‐ gle developed its own monitoring system in-house, but there are plenty of open source and commercial monitoring systems available.\n\nSources of Monitoring Data Your choice of monitoring system(s) will be informed by the specific sources of mon‐ itoring data you’ll use. This section discusses two common sources of monitoring data: logs and metrics. There are other valuable monitoring sources that we won’t cover here, like distributed tracing and runtime introspection.\n\nMetrics are numerical measurements representing attributes and events, typically harvested via many data points at regular time intervals. Logs are an append-only record of events. This chapter’s discussion focuses on structured logs that enable rich query and aggregation tools as opposed to plain-text logs.\n\nGoogle’s logs-based systems process large volumes of highly granular data. There’s some inherent delay between when an event occurs and when it is visible in logs. For analysis that’s not time-sensitive, these logs can be processed with a batch system, interrogated with ad hoc queries, and visualized with dashboards. An example of this workflow would be using Cloud Dataflow to process logs, BigQuery for ad hoc quer‐ ies, and Data Studio for the dashboards.\n\n64\n\n|\n\nChapter 4: Monitoring\n\nBy contrast, our metrics-based monitoring system, which collects a large number of metrics from every service at Google, provides much less granular information, but in near real time. These characteristics are fairly typical of other logs- and metrics- based monitoring systems, although there are exceptions, such as real-time logs sys‐ tems or high-cardinality metrics.\n\nOur alerts and dashboards typically use metrics. The real-time nature of our metrics- based monitoring system means that engineers can be notified of problems very rap‐ idly. We tend to use logs to find the root cause of an issue, as the information we need is often not available as a metric.\n\nWhen reporting isn’t time-sensitive, we often generate detailed reports using logs processing systems because logs will nearly always produce more accurate data than metrics.\n\nIf you’re alerting based on metrics, it might be tempting to add more alerting based on logs—for example, if you need to be notified when even a single exceptional event happens. We still recommend metrics-based alerting in such cases: you can incre‐ ment a counter metric when a particular event happens, and configure an alert based on that metric’s value. This strategy keeps all alert configuration in one place, making it easier to manage (see “Managing Your Monitoring System” on page 67).\n\nExamples The following real-world examples illustrate how to reason through the process of choosing between monitoring systems.\n\nMove information from logs to metrics\n\nProblem. The HTTP status code is an important signal to App Engine customers debugging their errors. This information was available in logs, but not in metrics. The metrics dashboard could provide only a global rate of all errors, and did not include any information about the exact error code or the cause of the error. As a result, the workflow to debug an issue involved:\n\n1. Looking at the global error graph to find a time when an error occurred.\n\n2. Reading log files to look for lines containing an error.\n\n3. Attempting to correlate errors in the log file to the graph.\n\nThe logging tools did not give a sense of scale, making it hard to know if an error seen in one log line was occurring frequently. The logs also contained many other irrelevant lines, making it hard to track down the root cause.\n\nSources of Monitoring Data\n\n|\n\n65\n\nProposed solution. The App Engine dev team chose to export the HTTP status code as a label on the metric (e.g., requests_total{status=404} versus requests_total {status=500}). Because the number of different HTTP status codes is relatively limi‐ ted, this did not increase the volume of metric data to an impractical size, but did make the most pertinent data available for graphing and alerting.\n\nOutcome. This new label meant the team could upgrade the graphs to show separate lines for different error categories and types. Customers could now quickly form con‐ jectures about possible problems based on the exposed error codes. We could now also set different alerting thresholds for client and server errors, making the alerts trigger more accurately.\n\nImprove both logs and metrics\n\nProblem. One Ads SRE team maintained ~50 services, which were written in a num‐ ber of different languages and frameworks. The team used logs as the canonical source of truth for SLO compliance. To calculate the error budget, each service used a logs processing script with many service-specific special cases. Here’s an example script to process a log entry for a single service:\n\nIf the HTTP status code was in the range (500, 599) AND the 'SERVER ERROR' field of the log is populated AND DEBUG cookie was not set as part of the request AND the url did not contain '/reports' AND the 'exception' field did not contain 'com.google.ads.PasswordException' THEN increment the error counter by 1\n\nThese scripts were hard to maintain and also used data that wasn’t available to the metrics-based monitoring system. Because metrics drove alerts, sometimes the alerts would not correspond to user-facing errors. Every alert required an explicit triage step to determine if it was user-facing, which slowed down response time.\n\nProposed solution. The team created a library that hooked into the logic of the frame‐ work languages of each application. The library decided if the error was impacting users at request time. The instrumentation wrote this decision in logs and exported it as a metric at the same time, improving consistency. If the metric showed that the service had returned an error, the logs contained the exact error, along with request- related data to help reproduce and debug the issue. Correspondingly, any SLO- impacting error that manifested in the logs also changed the SLI metrics, which the team could then alert on.\n\nOutcome. By introducing a uniform control surface across multiple services, the team reused tooling and alerting logic instead of implementing multiple custom solutions. logs All services benefited from removing the complicated, service-specific\n\n66\n\n|\n\nChapter 4: Monitoring\n\nprocessing code, which resulted in increased scalability. Once alerts were directly tied to SLOs, they were more clearly actionable, so the false-positive rate decreased significantly.\n\nKeep logs as the data source\n\nProblem. While investigating production issues, one SRE team would often look at the affected entity IDs to determine user impact and root cause. As with the earlier App Engine example, this investigation required data that was available only in logs. The team had to perform one-off log queries for this while they were responding to incidents. This step added time to incident recovery: a few minutes to correctly put together the query, plus the time to query the logs.\n\nProposed solution. The team initially debated whether a metric should replace their log tools. Unlike in the App Engine example, the entity ID could take on millions of different values, so it would not be practical as a metric label.\n\nUltimately, the team decided to write a script to perform the one-off log queries they needed, and documented which script to run in the alert emails. They could then copy the command directly into a terminal if necessary.\n\nOutcome. The team no longer had the cognitive load of managing the correct one-off log query. Accordingly, they could get the results they needed faster (although not as quickly as a metrics-based approach). They also had a backup plan: they could run the script automatically as soon as an alert triggered, and use a small server to query the logs at regular intervals to constantly retrieve semifresh data.\n\nManaging Your Monitoring System Your monitoring system is as important as any other service you run. As such, it should be treated with the appropriate level of care and attention.\n\nTreat Your Configuration as Code Treating system configuration as code and storing it in the revision control system are common practices that provide some obvious benefits: change history, links from specific changes to your task tracking system, easier rollbacks and linting checks,1 and enforced code review procedures.\n\nWe strongly recommend also treating monitoring configuration as code (for more on configuration, see Chapter 14). A monitoring system that supports intent-based\n\n1 For example, using promtool to verify that your Prometheus config is syntactically correct.\n\nManaging Your Monitoring System\n\n|\n\n67\n\nconfiguration is preferable to systems that only provide web UIs or CRUD-style APIs. This configuration approach is standard for many open source binaries that only read a configuration file. Some third-party solutions like grafanalib enable this approach for components that are traditionally configured with a UI.\n\nEncourage Consistency Large companies with multiple engineering teams who use monitoring need to strike a fine balance: a centralized approach provides consistency, but on the other hand, individual teams may want full control over the design of their configuration.\n\nThe right solution depends on your organization. Google’s approach has evolved over time toward convergence on a single framework run centrally as a service. This solution works well for us for a few reasons. A single framework enables engineers to ramp up faster when they switch teams, and makes collaboration during debugging easier. We also have a centralized dashboarding service, where each team’s dash‐ boards are discoverable and accessible. If you easily understand another team’s dash‐ board, you can debug both your issues and theirs more quickly.\n\nIf possible, make basic monitoring coverage effortless. If all your services2 export a consistent set of basic metrics, you can automatically collect those metrics across your entire organization and provide a consistent set of dashboards. This approach means that any new component you launch automatically has basic monitoring. Many teams across your company—even nonengineering teams—can use this moni‐ toring data.\n\nPrefer Loose Coupling Business requirements change, and your production system will look different a year from now. Similarly, your monitoring system needs to evolve over time as the serv‐ ices it monitors evolve through different patterns of failure.\n\nWe recommend keeping the components of your monitoring system loosely coupled. You should have stable interfaces for configuring each component and passing moni‐ toring data. Separate components should be in charge of collecting, storing, alerting, and visualizing your monitoring. Stable interfaces make it easier to swap out any given component for a better alternative.\n\nSplitting functionality into individual components is becoming popular in the open source world. A decade ago, monitoring systems like Zabbix combined all functions into a single component. Modern design usually involves separating collection and\n\n2 You can export basic metrics via a common library: an instrumentation framework like OpenCensus, or a\n\nservice mesh like Istio.\n\n68\n\n|\n\nChapter 4: Monitoring\n\nrule evaluation (with a solution like Prometheus server), long-term time series stor‐ age (InfluxDB), alert aggregation (Alertmanager), and dashboarding (Grafana).\n\nAs of this writing, there are at least two popular open standards for instrumenting your software and exposing metrics:\n\nstatsd\n\nThe metric aggregation daemon initially written by Etsy and now ported to a majority of programming languages.\n\nPrometheus\n\nAn open source monitoring solution with a flexible data model, support for met‐ ric labels, and robust histogram functionality. Other systems are now adopting the Prometheus format, and it is being standardized as OpenMetrics.\n\nA separate dashboarding system that can use multiple data sources provides a central and unified overview of your service. Google recently saw this benefit in practice: our legacy monitoring system (Borgmon3) combined dashboards in the same configura‐ tion as alerting rules. While migrating to a new system (Monarch), we decided to move dashboarding into a separate service (Viceroy). Because Viceroy was not a component of Borgmon or Monarch, Monarch had fewer functional requirements. Since users could use Viceroy to display graphs based on data from both monitoring systems, they could gradually migrate from Borgmon to Monarch.\n\nMetrics with Purpose Chapter 5 covers how to monitor and alert using SLI metrics when a system’s error budget is under threat. SLI metrics are the first metrics you want to check when SLO- based alerts trigger. These metrics should appear prominently in your service’s dash‐ board, ideally on its landing page.\n\nWhen investigating the cause of an SLO violation, you will most likely not get enough information from the SLO dashboards. These dashboards show that you are violating the SLO, but not necessarily why. What other data should the monitoring dashboards display?\n\nWe’ve found the following guidelines helpful in implementing metrics. These metrics should provide reasonable monitoring that allows you to investigate production issues and also provide a broad range of information about your service.\n\n3 See Chapter 10 of Site Reliability Engineering for Borgmon’s concepts and structure.\n\nMetrics with Purpose\n\n|\n\n69\n\nIntended Changes When diagnosing an SLO-based alert, you need to be able to move from alerting met‐ rics that notify you of user-impacting issues to metrics that tell you what is causing these issues. Recent intended changes to your service might be at fault. Add monitor‐ ing that informs you of any changes in production.4 To determine the trigger, we rec‐ ommend the following:\n\nMonitor the version of the binary.\n\nMonitor the command-line flags, especially when you use these flags to enable and disable features of the service.\n\nIf configuration data is pushed to your service dynamically, monitor the version of this dynamic configuration.\n\nIf any of these pieces of the system aren’t versioned, you should be able to monitor the timestamp at which it was last built or packaged.\n\nWhen you’re trying to correlate an outage with a rollout, it’s much easier to look at a graph/dashboard linked from your alert than to trawl through your CI/CD (continu‐ ous integration/continuous delivery) system logs after the fact.\n\nDependencies Even if your service didn’t change, any of its dependencies might change or have problems, so you should also monitor responses coming from direct dependencies.\n\nIt’s reasonable to export the request and response size in bytes, latency, and response codes for each dependency. When choosing the metrics to graph, keep the four golden signals in mind. You can use additional labels on the metrics to break them down by response code, RPC (remote procedure call) method name, and peer job name.\n\nIdeally, you can instrument the lower-level RPC client library to export these metrics once, instead of asking each RPC client library to export them.5 Instrumenting the client library provides more consistency and allows you to monitor new dependen‐ cies for free.\n\nYou will sometimes come across dependencies that offer a very narrow API, where all functionality is available via a single RPC called Get, Query, or something equally\n\n4 This is one case where monitoring via logs is appealing, particularly because production changes are relatively infrequent. Whether you use logs or metrics, these changes should be surfaced in your dashboards so they’re easily accessible for debugging production issues.\n\n5 See https://opencensus.io/ for a set of libraries that provides this.\n\n70\n\n|\n\nChapter 4: Monitoring\n\nunhelpful, and the actual command is specified as arguments to this RPC. A single instrumentation point in the client library falls short with this type of dependency: you will observe a high variance in latency and some percentage of errors that may or may not indicate that some part of this opaque API is failing entirely. If this depend‐ ency is critical, you have a couple of options to monitor it well:\n\nExport separate metrics to tailor for the dependency, so that the metrics can unpack requests they receive to get at the actual signal.\n\nAsk the dependency owners to perform a rewrite to export a broader API that supports separate functionality split across separate RPC services and methods.\n\nSaturation Aim to monitor and track the usage of every resource the service relies upon. Some resources have hard limits you cannot exceed, like RAM, disk, or CPU quota alloca‐ ted to your application. Other resources—like open file descriptors, active threads in any thread pools, waiting times in queues, or the volume of written logs—may not have a clear hard limit but still require management.\n\nDepending on the programming language in use, you should monitor additional resources:\n\nIn Java: The heap and metaspace size, and more specific metrics depending on what type of garbage collection you’re using\n\nIn Go: The number of goroutines\n\nThe languages themselves provide varying support to track these resources.\n\nIn addition to alerting on significant events as described in Chapter 5 you might also need to set up alerting that fires when you approach exhaustion for specific resources, such as:\n\nWhen the resource has a hard limit\n\nWhen crossing a usage threshold causes performance degradation\n\nYou should have monitoring metrics to track all resources—even resources that the service manages well. These metrics are vital in capacity and resource planning.\n\nMetrics with Purpose\n\n|\n\n71",
      "page_number": 92
    },
    {
      "number": 12,
      "title": "Segment 12 (pages 100-111)",
      "start_page": 100,
      "end_page": 111,
      "detection_method": "topic_boundary",
      "content": "Status of Served Traffic It’s a good idea to add metrics or metric labels that allow the dashboards to break down served traffic by status code (unless the metrics your service uses for SLI pur‐ poses already include this information). Here are some recommendations:\n\nFor HTTP traffic, monitor all response codes, even if they don’t provide enough signal for alerting, because some can be triggered by incorrect client behavior.\n\nIf you apply rate limits or quota limits to your users, monitor aggregates of how many requests were denied due to lack of quota.\n\nGraphs of this data can help you identify when the volume of errors changes noticea‐ bly during a production change.\n\nImplementing Purposeful Metrics Each exposed metric should serve a purpose. Resist the temptation of exporting a handful of metrics just because they are easy to generate. Instead, think about how these metrics will be used. Metric design, or lack thereof, has implications.\n\nIdeally, metric values used for alerting change dramatically only when the system enters a problem state, and don’t change when a system is operating normally. On the other hand, metrics for debugging don’t have these requirements—they’re intended to provide insight about what is happening when alerts are triggered. Good debugging metrics will point at some aspect of the system that’s potentially causing the issues. When you write a postmortem, think about which additional metrics would have allowed you to diagnose the issue faster.\n\nTesting Alerting Logic In an ideal world, monitoring and alerting code should be subject to the same testing standards as code development. While Prometheus developers are discussing devel‐ oping unit tests for monitoring, there is currently no broadly adopted system that allows you to do this.\n\nAt Google, we test our monitoring and alerting using a domain-specific language that allows us to create synthetic time series. We then write assertions based upon the val‐ ues in a derived time series, or the firing status and label presence of specific alerts.\n\nMonitoring and alerting is often a multistage process, which therefore calls for multi‐ ple families of unit tests. While this area remains largely underdeveloped, should you want to implement monitoring testing at some point, we recommend a three-tiered approach, as shown in Figure 4-1.\n\n72\n\n|\n\nChapter 4: Monitoring\n\nFigure 4-1. Monitoring testing environment tiers\n\n1. Binary reporting: Check that the exported metric variables change in value under certain conditions as expected.\n\n2. Monitoring configurations: Make sure that rule evaluation produces expected results, and that specific conditions produce the expected alerts.\n\n3. Alerting configurations: Test that generated alerts are routed to a predeter‐ mined destination, based on alert label values.\n\nIf you can’t test your monitoring via synthetic means, or there’s a stage of your moni‐ toring you simply can’t test, consider creating a running system that exports well- known metrics, like number of requests and errors. You can use this system to validate derived time series and alerts. It’s very likely that your alerting rules will not fire for months or years after you configure them, and you need to have confidence that when the metric passes a certain threshold, the correct engineers will be alerted with notifications that make sense.\n\nConclusion Because the SRE role is responsible for the reliability of systems in production, SREs are often required to be intimately familiar with a service’s monitoring system and its features. Without this knowledge, SREs might not know where to look, how to iden‐ tify abnormal behavior, or how to find the information they need during an emergency.\n\nWe hope that by pointing out monitoring system features we find useful and why, we can help you evaluate how well your monitoring strategy fits your needs, explore some additional features you might be able to leverage, and consider changes you might want to make. You’ll probably find it useful to combine some source of metrics and logging in your monitoring strategy; the exact mix you need is highly context- dependent. Make sure to collect metrics that serve a particular purpose. That purpose may be to enable better capacity planning, assist in debugging, or directly notify you about problems.\n\nConclusion\n\n|\n\n73\n\nOnce you have monitoring in place, it needs to be visible and useful. To this end, we also recommend testing your monitoring setup. A good monitoring system pays divi‐ dends. It is well worth the investment to put substantial thought into what solutions best meet your needs, and to iterate until you get it right.\n\n74\n\n|\n\nChapter 4: Monitoring\n\nCHAPTER 5 Alerting on SLOs\n\nBy Steven Thurgood with Jess Frame, Anthony Lenton, Carmela Quinito, Anton Tolchanov, and Nejc Trdin\n\nThis chapter explains how to turn your SLOs into actionable alerts on significant events. Both our first SRE book and this book talk about implementing SLOs. We believe that having good SLOs that measure the reliability of your platform, as experi‐ enced by your customers, provides the highest-quality indication for when an on-call engineer should respond. Here we give specific guidance on how to turn those SLOs into alerting rules so that you can respond to problems before you consume too much of your error budget.\n\nOur examples present a series of increasingly complex implementations for alerting metrics and logic; we discuss the utility and shortcomings of each. While our exam‐ ples use a simple request-driven service and Prometheus syntax, you can apply this approach in any alerting framework.\n\nAlerting Considerations In order to generate alerts from service level indicators (SLIs) and an error budget, you need a way to combine these two elements into a specific rule. Your goal is to be notified for a significant event: an event that consumes a large fraction of the error budget.\n\nConsider the following attributes when evaluating an alerting strategy:\n\n75\n\nPrecision\n\nThe proportion of events detected that were significant. Precision is 100% if every alert corresponds to a significant event. Note that alerting can become par‐ ticularly sensitive to nonsignificant events during low-traffic periods (discussed in “Low-Traffic Services and Error Budget Alerting” on page 86).\n\nRecall\n\nThe proportion of significant events detected. Recall is 100% if every significant event results in an alert.\n\nDetection time\n\nHow long it takes to send notifications in various conditions. Long detection times can negatively impact the error budget.\n\nReset time\n\nHow long alerts fire after an issue is resolved. Long reset times can lead to confu‐ sion or to issues being ignored.\n\nWays to Alert on Significant Events Constructing alert rules for your SLOs can become quite complex. Here we present six ways to configure alerting on significant events, in order of increasing fidelity, to arrive at an option that offers good control over the four parameters of precision, recall, detection time, and reset time simultaneously. Each of the following approaches addresses a different problem, and some eventually solve multiple prob‐ lems at the same time. The first three nonviable attempts work toward the latter three viable alerting strategies, with approach 6 being the most viable and most highly rec‐ ommended option. The first method is simple to implement but inadequate, while the optimal method provides a complete solution to defend an SLO over both the long and the short term.\n\nFor the purposes of this discussion, “error budgets” and “error rates” apply to all SLIs, not just those with “error” in their name. In the section “What to Measure: Using SLIs” on page 20, we recommend using SLIs that capture the ratio of good events to total events. The error budget gives the number of allowed bad events, and the error rate is the ratio of bad events to total events.\n\n1: Target Error Rate ≥ SLO Threshold For the most trivial solution, you can choose a small time window (for example, 10 minutes) and alert if the error rate over that window exceeds the SLO.\n\nFor example, if the SLO is 99.9% over 30 days, alert if the error rate over the previous 10 minutes is ≥ 0.1%:\n\n76\n\n|\n\nChapter 5: Alerting on SLOs\n\nalert: HighErrorRate expr: job:slo_errors_per_request:ratio_rate10m{job=\"myjob\"} >= 0.001\n\nThis 10-minute average is calculated in Prometheus with a Record‐ ing rule:\n\nrecord: job:slo_errors_per_request:ratio_rate10m expr: sum(rate(slo_errors[10m])) by (job) / sum(rate(slo_requests[10m])) by (job)\n\nIf you don’t export slo_errors and slo_requests from your job, you can create the time series by renaming a metric:\n\nrecord: slo_errors expr: http_errors\n\nAlerting when the recent error rate is equal to the SLO means that the system detects a budget spend of:\n\nalerting window size reporting period\n\nFigure 5-1 shows the relationship between detection time and error rate for an exam‐ ple service with an alert window of 10 minutes and a 99.9% SLO.\n\nFigure 5-1. Detection time for an example service with an alert window of 10 minutes and a 99.9% SLO\n\nTable 5-1 shows the benefits and disadvantages of alerting when the immediate error rate is too high.\n\nWays to Alert on Significant Events\n\n|\n\n77\n\nTable 5-1. Pros and cons of alerting when the immediate error rate is too high\n\nPros Detection time is good: 0.6 seconds for a total outage. This alert fires on any event that threatens the SLO, exhibiting good recall.\n\nCons Precision is low: The alert fires on many events that do not threaten the SLO. A 0.1% error rate for 10 minutes would alert, while consuming only 0.02% of the monthly error budget. Taking this example to an extreme, you could receive up to 144 alerts per day every day, not act upon any alerts, and still meet the SLO.\n\n2: Increased Alert Window We can build upon the preceding example by changing the size of the alert window to improve precision. By increasing the window size, you spend a higher budget amount before triggering an alert.\n\nTo keep the rate of alerts manageable, you decide to be notified only if an event con‐ sumes 5% of the 30-day error budget—a 36-hour window:\n\nalert: HighErrorRate expr: job:slo_errors_per_request:ratio_rate36h{job=\"myjob\"} > 0.001\n\nNow, the detection time is:\n\n1 − SLO error ratio × alerting window size\n\nTable 5-2 shows the benefits and disadvantages of alerting when the error rate is too high over a larger window of time.\n\nTable 5-2. Pros and cons of alerting when the error rate is too high over a larger window of time\n\nPros Detection time is still good: 2 minutes and 10 seconds for a complete outage. Better precision than the previous example: by ensuring that the error rate is sustained for longer, an alert will likely represent a significant threat to the error budget.\n\nCons Very poor reset time: In the case of 100% outage, an alert will fire shortly after 2 minutes, and continue to fire for the next 36 hours. Calculating rates over longer windows can be expensive in terms of memory or I/O operations, due to the large number of data points.\n\nFigure 5-2 shows that while the error rate over a 36-hour period has fallen to a negli‐ gible level, the 36-hour average error rate remains above the threshold.\n\n78\n\n|\n\nChapter 5: Alerting on SLOs\n\nFigure 5-2. Error rate over a 36-hour period\n\n3: Incrementing Alert Duration Most monitoring systems allow you to add a duration parameter to the alert criteria so the alert won’t fire unless the value remains above the threshold for some time. You may be tempted to use this parameter as a relatively inexpensive way to add longer windows:\n\nalert: HighErrorRate expr: job:slo_errors_per_request:ratio_rate1m{job=\"myjob\"} > 0.001 for: 1h\n\nTable 5-3 shows the benefits and disadvantages of using a duration parameter for alerts.\n\nTable 5-3. Pros and cons of using a duration parameter for alerts\n\nPros Alerts can be higher precision. Requiring a sustained error rate before firing means that alerts are more likely to correspond to a significant event.\n\nCons Poor recall and poor detection time: Because the duration does not scale with the severity of the incident, a 100% outage alerts after one hour, the same detection time as a 0.2% outage. The 100% outage would consume 140% of the 30-day budget in that hour. If the metric even momentarily returns to a level within SLO, the duration timer resets. An SLI that fluctuates between missing SLO and passing SLO may never alert.\n\nFor the reasons listed in Table 5-3, we do not recommend using durations as part of your SLO-based alerting criteria.1\n\n1 Duration clauses can occasionally be useful when you are filtering out ephemeral noise over very short dura‐\n\ntions. However, you still need to be aware of the cons listed in this section.\n\nWays to Alert on Significant Events\n\n|\n\n79\n\nFigure 5-3 shows the average error rate over a 5-minute window of a service with a 10-minute duration before the alert fires. A series of 100% error spikes lasting 5 minutes every 10 minutes never triggers an alert, despite consuming 35% of the error budget.\n\nFigure 5-3. A service with 100% error spikes every 10 minutes\n\nEach spike consumed almost 12% of the 30-day budget, yet the alert never triggered.\n\n4: Alert on Burn Rate To improve upon the previous solution, you want to create an alert with good detec‐ tion time and high precision. To this end, you can introduce a burn rate to reduce the size of the window while keeping the alert budget spend constant.\n\nBurn rate is how fast, relative to the SLO, the service consumes the error budget. Figure 5-4 shows the relationship between burn rates and error budgets.\n\nThe example service uses a burn rate of 1, which means that it’s consuming error budget at a rate that leaves you with exactly 0 budget at the end of the SLO’s time window (see Chapter 4 in our first book). With an SLO of 99.9% over a time window of 30 days, a constant 0.1% error rate uses exactly all of the error budget: a burn rate of 1.\n\n80\n\n|\n\nChapter 5: Alerting on SLOs\n\nFigure 5-4. Error budgets relative to burn rates\n\nTable 5-4 shows burn rates, their corresponding error rates, and the time it takes to exhaust the SLO budget.\n\nTable 5-4. Burn rates and time to complete budget exhaustion\n\nBurn rate 1 2 10 1,000\n\nError rate for a 99.9% SLO Time to exhaustion 0.1% 0.2% 1% 100%\n\n30 days 15 days 3 days 43 minutes\n\nBy keeping the alert window fixed at one hour and deciding that a 5% error budget spend is significant enough to notify someone, you can derive the burn rate to use for the alert.\n\nFor burn rate–based alerts, the time taken for an alert to fire is:\n\n1 − SLO error ratio × alerting window size × burn rate\n\nThe error budget consumed by the time the alert fires is:\n\nburn rate × alerting window size period\n\nWays to Alert on Significant Events\n\n|\n\n81\n\nFive percent of a 30-day error budget spend over one hour requires a burn rate of 36. The alerting rule now becomes:\n\nalert: HighErrorRate expr: job:slo_errors_per_request:ratio_rate1h{job=\"myjob\"} > 36 * 0.001\n\nTable 5-5 shows the benefits and limitations of alerting based on burn rate.\n\nTable 5-5. Pros and cons of alerting based on burn rate\n\nPros Good precision: This strategy chooses a significant portion of error budget spend upon which to alert. Shorter time window, which is cheaper to calculate. Good detection time. Better reset time: 58 minutes.\n\nCons Low recall: A 35x burn rate never alerts, but consumes all of the 30-day error budget in 20.5 hours. Reset time: 58 minutes is still too long.\n\n5: Multiple Burn Rate Alerts Your alerting logic can use multiple burn rates and time windows, and fire alerts when burn rates surpass a specified threshold. This option retains the benefits of alerting on burn rates and ensures that you don’t overlook lower (but still significant) error rates.\n\nIt’s also a good idea to set up ticket notifications for incidents that typically go unno‐ ticed but can exhaust your error budget if left unchecked—for example, a 10% budget consumption in three days. This rate of errors catches significant events, but since the rate of budget consumption provides adequate time to address the event, you don’t need to page someone.\n\nWe recommend 2% budget consumption in one hour and 5% budget consumption in six hours as reasonable starting numbers for paging, and 10% budget consumption in three days as a good baseline for ticket alerts. The appropriate numbers depend on the service and the baseline page load. For busier services, and depending on on-call responsibilities over weekends and holidays, you may want ticket alerts for the six- hour window.\n\nTable 5-6 shows the corresponding burn rates and time windows for percentages of SLO budget consumed.\n\nTable 5-6. Recommended time windows and burn rates for percentages of SLO budget consumed\n\nSLO budget consumption Time window Burn rate Notification 2% 5% 10%\n\n1 hour 6 hours 3 days\n\n14.4 6 1\n\nPage Page Ticket\n\n82\n\n|\n\nChapter 5: Alerting on SLOs\n\nThe alerting configuration may look like something like:\n\nexpr: ( job:slo_errors_per_request:ratio_rate1h{job=\"myjob\"} > (14.4*0.001) or job:slo_errors_per_request:ratio_rate6h{job=\"myjob\"} > (6*0.001) ) severity: page\n\nexpr: job:slo_errors_per_request:ratio_rate3d{job=\"myjob\"} > 0.001 severity: ticket\n\nFigure 5-5 shows the detection time and alert type according to the error rate.\n\nFigure 5-5. Error rate, detection time, and alert notification\n\nMultiple burn rates allow you to adjust the alert to give appropriate priority based on how quickly you have to respond. If an issue will exhaust the error budget within hours or a few days, sending an active notification is appropriate. Otherwise, a ticket- based notification to address the alert the next working day is more appropriate.2\n\nTable 5-7 lists the benefits and disadvantages of using multiple burn rates.\n\n2 As described in the introduction to Site Reliability Engineering, pages and tickets are the only valid ways to get\n\na human to take action.\n\nWays to Alert on Significant Events\n\n|\n\n83",
      "page_number": 100
    },
    {
      "number": 13,
      "title": "Segment 13 (pages 112-120)",
      "start_page": 112,
      "end_page": 120,
      "detection_method": "topic_boundary",
      "content": "Table 5-7. Pros and cons of using multiple burn rates\n\nPros Ability to adapt the monitoring configuration to many situations according to criticality: alert quickly if the error rate is high; alert eventually if the error rate is low but sustained. Good precision, as with all fixed-budget portion alert approaches. Good recall, because of the three-day window. Ability to choose the most appropriate alert type based upon how quickly someone has to react to defend the SLO.\n\nCons More numbers, window sizes, and thresholds to manage and reason about. An even longer reset time, as a result of the three-day window. To avoid multiple alerts from firing if all conditions are true, you need to implement alert suppression. For example: 10% budget spend in five minutes also means that 5% of the budget was spent in six hours, and 2% of the budget was spent in one hour. This scenario will trigger three notifications unless the monitoring system is smart enough to prevent it from doing so.\n\n6: Multiwindow, Multi-Burn-Rate Alerts We can enhance the multi-burn-rate alerts in iteration 5 to notify us only when we’re still actively burning through the budget—thereby reducing the number of false posi‐ tives. To do this, we need to add another parameter: a shorter window to check if the error budget is still being consumed as we trigger the alert.\n\nA good guideline is to make the short window 1/12 the duration of the long window, as shown in Figure 5-6. The graph shows both alerting threshold. After experiencing 15% errors for 10 minutes, the short window average goes over the alerting threshold immediately, and the long window average goes over the threshold after 5 minutes, at which point the alert starts firing. The short window average drops below the thres‐ hold 5 minutes after the errors stop, at which point the alert stops firing. The long window average drops below the threshold 60 minutes after the errors stop.\n\nFigure 5-6. Short and long windows for alerting\n\n84\n\n|\n\nChapter 5: Alerting on SLOs\n\nFor example, you can send a page-level alert when you exceed the 14.4x burn rate over both the previous one hour and the previous five minutes. This alert fires only once you’ve consumed 2% of the budget, but exhibits a better reset time by ceasing to fire five minutes later, rather than one hour later:\n\nexpr: ( job:slo_errors_per_request:ratio_rate1h{job=\"myjob\"} > (14.4*0.001) and job:slo_errors_per_request:ratio_rate5m{job=\"myjob\"} > (14.4*0.001) ) or ( job:slo_errors_per_request:ratio_rate6h{job=\"myjob\"} > (6*0.001) and job:slo_errors_per_request:ratio_rate30m{job=\"myjob\"} > (6*0.001) ) severity: page\n\nexpr: ( job:slo_errors_per_request:ratio_rate24h{job=\"myjob\"} > (3*0.001) and job:slo_errors_per_request:ratio_rate2h{job=\"myjob\"} > (3*0.001) ) or ( job:slo_errors_per_request:ratio_rate3d{job=\"myjob\"} > 0.001 and job:slo_errors_per_request:ratio_rate6h{job=\"myjob\"} > 0.001 ) severity: ticket\n\nWe recommend the parameters listed in Table 5-8 as the starting point for your SLO- based alerting configuration.\n\nTable 5-8. Recommended parameters for a 99.9% SLO alerting configuration\n\nSeverity Page Page Ticket\n\nLong window Short window Burn rate 5 minutes 1 hour 30 minutes 6 hours 6 hours 3 days\n\n14.4 6 1\n\nError budget consumed 2% 5% 10%\n\nWe have found that alerting based on multiple burn rates is a powerful way to imple‐ ment SLO-based alerting.\n\nTable 5-9 shows the benefits and limitations of using multiple burn rates and window sizes.\n\nWays to Alert on Significant Events\n\n|\n\n85\n\nTable 5-9. Pros and cons of using multiple burn rates and window sizes\n\nPros A flexible alerting framework that allows you to control the type of alert according to the severity of the incident and the requirements of the organization. Good precision, as with all fixed-budget portion alert approaches. Good recall, because of the three-day window.\n\nCons Lots of parameters to specify, which can make alerting rules hard to manage. For more on managing alerting rules, see “Alerting at Scale” on page 89.\n\nLow-Traffic Services and Error Budget Alerting The multiwindow, multi-burn-rate approach just detailed works well when a suffi‐ ciently high rate of incoming requests provides a meaningful signal when an issue arises. However, these approaches can cause problems for systems that receive a low rate of requests. If a system has either a low number of users or natural low-traffic periods (such as nights and weekends), you may need to alter your approach.\n\nIt’s harder to automatically distinguish unimportant events in low-traffic services. For example, if a system receives 10 requests per hour, then a single failed request results in an hourly error rate of 10%. For a 99.9% SLO, this request constitutes a 1,000x burn rate and would page immediately, as it consumed 13.9% of the 30-day error budget. This scenario allows for only seven failed requests in 30 days. Single requests can fail for a large number of ephemeral and uninteresting reasons that aren’t necessarily cost-effective to solve in the same way as large systematic outages.\n\nThe best solution depends on the nature of the service: what is the impact3 of a single failed request? A high-availability target may be appropriate if failed requests are one- off, high-value requests that aren’t retried. It may make sense from a business per‐ spective to investigate every single failed request. However, in this case, the alerting system notifies you of an error too late.\n\nWe recommend a few key options to handle a low-traffic service:\n\nGenerate artificial traffic to compensate for the lack of signal from real users.\n\nCombine smaller services into a larger service for monitoring purposes.\n\nModify the product so that either:\n\n— It takes more requests to qualify a single incident as a failure.\n\n— The impact of a single failure is lower.\n\n3 The section “What to Measure: Using SLIs” on page 20 recommends a style of SLI that scales according to the\n\nimpact on the user.\n\n86\n\n|\n\nChapter 5: Alerting on SLOs\n\nGenerating Artificial Traffic A system can synthesize user activity to check for potential errors and high-latency requests. In the absence of real users, your monitoring system can detect synthetic errors and requests, so your on-call engineers can respond to issues before they impact too many actual users.\n\nArtificial traffic provides more signals to work with, and allows you to reuse your existing monitoring logic and SLO values. You may even already have most of the necessary traffic-generating components, such as black-box probers and integration tests.\n\nGenerating artificial load does have some downsides. Most services that warrant SRE support are complex, and have a large system control surface. Ideally, the system should be designed and built for monitoring using artificial traffic. Even for a non‐ trivial service, you can synthesize only a small portion of the total number of user request types. For a stateful service, the greater number of states exacerbates this problem.\n\nAdditionally, if an issue affects real users but doesn’t affect artificial traffic, the suc‐ cessful artificial requests hide the real user signal, so you aren’t notified that users see errors.\n\nCombining Services If multiple low-traffic services contribute to one overall function, combining their requests into a single higher-level group can detect significant events more precisely and with fewer false positives. For this approach to work, the services must be related in some way—you can combine microservices that form part of the same product, or multiple request types handled by the same binary.\n\nA downside to combining services is that a complete failure of an individual service may not count as a significant event. You can increase the likelihood that a failure will affect the group as a whole by choosing services with a shared failure domain, such as a common backend database. You can still use longer-period alerts that even‐ tually catch these 100% failures for individual services.\n\nMaking Service and Infrastructure Changes Alerting on significant events aims to provide sufficient notice to mitigate problems before they exhaust the entire error budget. If you can’t adjust the monitoring to be less sensitive to ephemeral events, and generating synthetic traffic is impractical, you might instead consider changing the service to reduce the user impact of a single failed request. For example, you might:\n\nLow-Traffic Services and Error Budget Alerting\n\n|\n\n87\n\nModify the client to retry, with exponential backoff and jitter.4\n\nSet up fallback paths that capture the request for eventual execution, which can take place on the server or on the client.\n\nThese changes are useful for high-traffic systems, but even more so for low-traffic systems: they allow for more failed events in the error budget, more signal from mon‐ itoring, and more time to respond to an incident before it becomes significant.\n\nLowering the SLO or Increasing the Window You might also want to reconsider if the impact of a single failure on the error budget accurately reflects its impact on users. If a small number of errors causes you to lose error budget, do you really need to page an engineer to fix the issue immediately? If not, users would be equally happy with a lower SLO. With a lower SLO, an engineer is notified only of a larger sustained outage.\n\nOnce you have negotiated lowering the SLO with the service’s stakeholders (for example, lowering the SLO from 99.9% to 99%), implementing the change is very simple: if you already have systems in place for reporting, monitoring, and alerting based upon an SLO threshold, simply add the new SLO value to the relevant systems.\n\nLowering the SLO does have a downside: it involves a product decision. Changing the SLO affects other aspects of the system, such as expectations around system behavior and when to enact the error budget policy. These other requirements may be more important to the product than avoiding some number of low-signal alerts.\n\nIn a similar manner, increasing the time window used for the alerting logic ensures alerts that trigger pages are more significant and worthy of attention.\n\nIn practice, we use some combination of the following methods to alert for low-traffic services:\n\nGenerating fake traffic, when doing so is possible and can achieve good coverage\n\nModifying clients so that ephemeral failures are less likely to cause user harm\n\nAggregating smaller services that share some failure mode\n\nSetting SLO thresholds commensurate with the actual impact of a failed request\n\n4 See “Overloads and Failure” in Site Reliability Engineering.\n\n88\n\n|\n\nChapter 5: Alerting on SLOs\n\nExtreme Availability Goals Services with an extremely low or an extremely high availability goal may require special consideration. For example, consider a service that has a 90% availability tar‐ get. Table 5-8 says to page when 2% of the error budget in a single hour is consumed. Because a 100% outage consumes only 1.4% of the budget in that hour, this alert could never fire. If your error budgets are set over long time periods, you may need to tune your alerting parameters.\n\nFor services with an extremely high availability goal, the time to exhaustion for a 100% outage is extremely small. A 100% outage for a service with a target monthly availability of 99.999% would exhaust its budget in 26 seconds—which is smaller than the metric collection interval of many monitoring services, let alone the end-to-end time to generate an alert and pass it through notification systems like email and SMS. Even if the alert goes straight to an automated resolution system, the issue may entirely consume the error budget before you can mitigate it.\n\nReceiving notifications that you have only 26 seconds of budget left isn’t necessarily a bad strategy; it’s just not useful for defending the SLO. The only way to defend this level of reliability is to design the system so that the chance of a 100% outage is extremely low. That way, you can fix issues before consuming the budget. For exam‐ ple, if you initially roll out that change to only 1% of your users, and burn your error budget at the same rate of 1%, you now have 43 minutes before you exhaust your error budget. See Chapter 16 for tactics on designing such a system.\n\nAlerting at Scale When you scale your service, make sure that your alerting strategy is likewise scala‐ ble. You might be tempted to specify custom alerting parameters for individual serv‐ ices. If your service comprises 100 microservices (or equivalently, a single service with 100 different request types), this scenario very quickly accumulates toil and cog‐ nitive load that does not scale.\n\nIn this case, we strongly advise against specifying the alert window and burn rate parameters independently for each service, because doing so quickly becomes over‐ whelming.5 Once you decide on your alerting parameters, apply them to all your services.\n\nOne technique for managing a large number of SLOs is to group request types into buckets of approximately similar availability requirements. For example, for a service\n\n5 With the exception of temporary changes to alerting parameters, which are necessary when you’re fixing an\n\nongoing outage and you don’t need to receive notifications during that period.\n\nExtreme Availability Goals\n\n|\n\n89\n\nwith availability and latency SLOs, you can group its request types into the following buckets:\n\nCRITICAL\n\nFor request types that are the most important, such as a request when a user logs in to the service.\n\nHIGH_FAST\n\nFor requests with high availability and low latency requirements. These requests involve core interactive functionality, such as when a user clicks a button to see how much money their advertising inventory has made this month.\n\nHIGH_SLOW\n\nFor important but less latency-sensitive functionality, such as when a user clicks a button to generate a report of all advertising campaigns over the past few years, and does not expect the data to return instantly.\n\nLOW\n\nFor requests that must have some availability, but for which outages are mostly invisible to users—for example, polling handlers for account notifications that can fail for long periods of time with no user impact.\n\nNO_SLO\n\nFor functionality that is completely invisible to the user—for example, dark launches or alpha functionality that is explicitly outside of any SLO.\n\nBy grouping requests rather than placing unique availability and latency objectives on all request types, you can group requests into five buckets, like the example in Table 5-10.\n\nTable 5-10. Request class buckets according to similar availability requirements and thresholds\n\nLatency @ 90%a 100 ms 100 ms 1,000 ms None None\n\nLatency @ 99% 200 ms 200 ms 5,000 ms None NO_SLO None a Ninety percent of requests are faster than this threshold.\n\nRequest class Availability CRITICAL\n\n99.99% 99.9% 99.9% 99% None\n\nHIGH_FAST\n\nHIGH_SLOW\n\nLOW\n\nThese buckets provide sufficient fidelity for protecting user happiness, but entail less toil than a system that is more complicated and expensive to manage that probably maps more precisely to the user experience.\n\n90\n\n|\n\nChapter 5: Alerting on SLOs\n\nConclusion If you set SLOs that are meaningful, understood, and represented in metrics, you can configure alerting to notify an on-caller only when there are actionable, specific threats to the error budget.\n\nThe techniques for alerting on significant events range from alerting when your error rate goes above your SLO threshold to using multiple levels of burn rate and window sizes. In most cases, we believe that the multiwindow, multi-burn-rate alerting tech‐ nique is the most appropriate approach to defending your application’s SLOs.\n\nWe hope we have given you the context and tools required to make the right configu‐ ration decisions for your own application and organization.\n\nConclusion\n\n|\n\n91\n\nCHAPTER 6 Eliminating Toil\n\nBy David Challoner, Joanna Wijntjes, David Huska, Matthew Sartwell, Chris Coykendall, Chris Schrier, John Looney, and Vivek Rau with Betsy Beyer, Max Luebbe, Alex Perry, and Murali Suriar\n\nGoogle SREs spend much of their time optimizing—squeezing every bit of perfor‐ mance from a system through project work and developer collaboration. But the scope of optimization isn’t limited to compute resources: it’s also important that SREs optimize how they spend their time. Primarily, we want to avoid performing tasks classified as toil. For a comprehensive discussion of toil, see Chapter 5 in Site Reliability Engineering. For the purposes of this chapter, we’ll define toil as the repeti‐ tive, predictable, constant stream of tasks related to maintaining a service.\n\nToil is seemingly unavoidable for any team that manages a production service. Sys‐ tem maintenance inevitably demands a certain amount of rollouts, upgrades, restarts, alert triaging, and so forth. These activities can quickly consume a team if left unchecked and unaccounted for. Google limits the time SRE teams spend on opera‐ tional work (including both toil- and non-toil-intensive work) at 50% (for more con‐ text on why, see Chapter 5 in our first book). While this target may not be appropriate for your organization, there’s still an advantage to placing an upper bound on toil, as identifying and quantifying toil is the first step toward optimizing your team’s time.\n\n93",
      "page_number": 112
    },
    {
      "number": 14,
      "title": "Segment 14 (pages 121-129)",
      "start_page": 121,
      "end_page": 129,
      "detection_method": "topic_boundary",
      "content": "What Is Toil? Toil tends to fall on a spectrum measured by the following characteristics, which are described in our first book. Here, we provide a concrete example for each toil characteristic:\n\nManual\n\nWhen the tmp directory on a web server reaches 95% utilization, engineer Anne logs in to the server and scours the filesystem for extraneous log files to delete.\n\nRepetitive\n\nA full tmp directory is unlikely to be a one-time event, so the task of fixing it is repetitive.\n\nAutomatable1\n\nIf your team has remediation documents with content like “log in to X, execute this command, check the output, restart Y if you see…,” these instructions are essentially pseudocode to someone with software development skills! In the tmp directory example, the solution has been partially automated. It would be even better to fully automate the problem detection and remediation by not requiring a human to run the script. Better still, submit a patch so that the software no longer breaks in this way.\n\nNontactical/reactive\n\nWhen you receive too many alerts along the lines of “disk full” and “server down,” they distract engineers from higher-value engineering and potentially mask other, higher-severity alerts. As a result, the health of the service suffers.\n\nLacks enduring value\n\nCompleting a task often brings a satisfying sense of accomplishment, but this repetitive satisfaction isn’t a positive in the long run. For example, closing that alert-generated ticket ensured that the user queries continued to flow and HTTP requests continued to serve with status codes < 400, which is good. However, resolving the ticket today won’t prevent the issue in the future, so the payback has a short duration.\n\nGrows at least as fast as its source\n\nMany classes of operational work grow as fast as (or faster than) the size of the underlying infrastructure. For example, you can expect time spent performing\n\n1 Whether something is automatable is the most subjective characteristic listed here; your perspective will\n\nevolve as you gain experience by automating away toil. A problem space that once seemed intractable (or too risky) will become feasible once you get comfortable with “letting the robots do the work.”\n\n94\n\n|\n\nChapter 6: Eliminating Toil\n\nhardware repairs to increase in lock-step fashion with the size of a server fleet. Physical repair work may unavoidably scale with the number of machines, but ancillary tasks (for example, making software/configuration changes) doesn’t necessarily have to.\n\nSources of toil may not always meet all of these criteria, but remember that toil comes in many forms. In addition to the preceding traits, consider the effect a particular piece of work has on team morale. Do people enjoy doing a task and find it reward‐ ing, or is it the type of work that’s often neglected because it’s viewed as boring or unrewarding?2 Toil can slowly deflate team morale. Time spent working on toil is generally time not spent thinking critically or expressing creativity; reducing toil is an acknowledgment that an engineer’s effort is better utilized in areas where human judgment and expression are possible.\n\nExample: Manual Response to Toil\n\nby John Looney, Production Engineering Manager at Facebook, and always an SRE at heart\n\nIt’s not always clear that a certain chunk of work is toil. Sometimes, a “creative” solu‐ tion—writing a workaround—is not the right call. Ideally, your organization should reward root-cause fixes over fixes that simply mask a problem.\n\nMy first assignment after joining Google (April 2005) was to log in to broken machines, investigate why they were broken, then fix them or send them to a hard‐ ware technician. This task seemed simple until I realized there were over 20,000 bro‐ ken machines at any given time!\n\nThe first broken machine I investigated had a root filesystem that was completely full with gigabytes of nonsense logs from a Google-patched network driver. I found another thousand broken machines with the same problem. I shared my plan to address the issue with my teammate: I’d write a script to ssh into all broken machines and check if the root filesystem was full. If the filesystem was full, the script would truncate any logs larger than a megabyte in /var/log and restart syslog.\n\nMy teammate’s less-than-enthusiastic reaction to my plan gave me pause. He pointed out that it’s better to fix root causes when possible. In the medium to long term, writ‐ ing a script that masked the severity of the problem would waste time (by not fixing the actual problem) and potentially cause more problems later.\n\n2 Some engineers do not mind working on toil for a prolonged period—not everyone’s tolerance threshold for toil is the same. Over the longer term, toil causes career stagnation while promoting burnout-induced turn‐ over. A certain level of toil is unavoidable, but we recommend reducing it where feasible—for the health of the team, the service, and individuals alike.\n\nWhat Is Toil?\n\n|\n\n95\n\nAnalysis demonstrated that each server probably cost $1 per hour. According to my train of thought, shouldn’t cost be the most important metric? I hadn’t considered that if I fixed the symptom, there would be no incentive to fix the root cause: the ker‐ nel team’s release test suite didn’t check the volume of logs these machines produced.\n\nThe senior engineer directed me at the kernel source so I could find the offensive line of code and log a bug against the kernel team to improve their test suite. My objective cost/benefit analysis showing that the problem was costing Google $1,000 per hour convinced the devs to fix the problem with my patch.\n\nMy patch was turned into a new kernel release that evening, and the next day I rolled it out to the affected machines. The kernel team updated their test suite later the fol‐ lowing week. Instead of the short-term endorphin hit of fixing those machines every morning, I now had the more cerebral pleasure of knowing that I’d fixed the problem properly.\n\nMeasuring Toil How do you know how much of your operational work is toil? And once you’ve deci‐ ded to take action to reduce toil, how do you know if your efforts were successful or justified? Many SRE teams answer these questions with a combination of experience and intuition. While such tactics might produce results, we can improve upon them.\n\nExperience and intuition are not repeatable, objective, or transferable. Members of the same team or organization often arrive at different conclusions regarding the magni‐ tude of engineering effort lost to toil, and therefore prioritize remediation efforts dif‐ ferently. Furthermore, toil reduction efforts can span quarters or even years (as demonstrated by some of the case studies in this chapter), during which time team priorities and personnel can change. To maintain focus and justify cost over the long term, you need an objective measure of progress. Usually, teams must choose a toil- reduction project from several candidates. An objective measure of toil allows your team to evaluate the severity of the problems and prioritize them to achieve maxi‐ mum return on engineering investment.\n\nBefore beginning toil reduction projects, it’s important to analyze cost versus benefit and to confirm that the time saved through eliminating toil will (at minimum) be proportional to the time invested in first developing and then maintaining an auto‐ mated solution (Figure 6-1). Projects that look “unprofitable” from a simplistic com‐ parison of hours saved versus hours invested might still be well worth undertaking because of the many indirect or intangible benefits of automation. Potential benefits could include:\n\nGrowth in engineering project work over time, some of which will further reduce toil\n\n96\n\n|\n\nChapter 6: Eliminating Toil\n\nIncreased team morale and decreased team attrition and burnout\n\nLess context switching for interrupts, which raises team productivity\n\nIncreased process clarity and standardization\n\nEnhanced technical skills and career growth for team members\n\nReduced training time\n\nFewer outages attributable to human errors\n\nImproved security\n\nShorter response times for user requests\n\nFigure 6-1. Estimate the amount of time you’ll spend on toil reduction efforts, and make sure that the benefits outweigh the cost (source: xkcd.com/1319/)\n\nMeasuring Toil\n\n|\n\n97\n\nSo how do we recommend you measure toil?\n\n1. Identify it. Chapter 5 of the first SRE book offers guidelines for identifying the toil in your operations. The people best positioned to identify toil depend upon your organization. Ideally, they will be stakeholders, including those who will perform the actual work.\n\n2. Select an appropriate unit of measure that expresses the amount of human effort applied to this toil. Minutes and hours are a natural choice because they are objective and universally understood. Be sure to account for the cost of context switching. For efforts that are distributed or fragmented, a different well- understood bucket of human effort may be more appropriate. Some examples of units of measure include an applied patch, a completed ticket, a manual produc‐ tion change, a predictable email exchange, or a hardware operation. As long as the unit is objective, consistent, and well understood, it can serve as a measure‐ ment of toil.\n\n3. Track these measurements continuously before, during, and after toil reduction efforts. Streamline the measurement process using tools or scripts so that collect‐ ing these measurements doesn’t create additional toil!\n\nToil Taxonomy Toil, like a crumbling bridge or a leaky dam, hides in the banal day to day. The cate‐ gories in this section aren’t exhaustive, but represent some common categories of toil. Many of these categories seem like “normal” engineering work, and they are. It’s helpful to think of toil as a spectrum rather than a binary classification.\n\nBusiness Processes This is probably the most common source of toil. Maybe your team manages some computing resource—compute, storage, network, load balancers, databases, and so on—along with the hardware that supplies that resource. You deal with onboarding users, configuring and securing their machines, performing software updates, and adding and removing servers to moderate capacity. You also work to minimize cost or waste of that resource. Your team is the human interface to the machine, typically interacting with internal customers who file tickets for their needs. Your organization may even have multiple ticketing systems and work intake systems.\n\nTicket toil is a bit insidious because ticket-driven business processes usually accom‐ plish their goal. Users get what they want, and because the toil is typically dispersed evenly across the team, the toil doesn’t loudly and obviously call for remediation. Wherever a ticket-driven process exists, there’s a chance that toil is quietly accumu‐ lating nearby. Even if you’re not explicitly planning to automate a process, you can\n\n98\n\n|\n\nChapter 6: Eliminating Toil\n\nstill perform process improvement work such as simplification and streamlining— the processes will be easier to automate later, and easier to manage in the meantime.\n\nProduction Interrupts Interrupts are a general class of time-sensitive janitorial tasks that keep systems run‐ ning. For example, you may need to fix an acute shortage of some resource (disk, memory, I/O) by manually freeing up disk space or restarting applications that are leaking memory. You may be filing requests to replace hard drives, “kicking” unre‐ sponsive systems, or manually tweaking capacity to meet current or expected loads. Generally, interrupts take attention away from more important work.\n\nRelease Shepherding In many organizations, deployment tools automatically shepherd releases from development to production. Even with automation, thorough code coverage, code reviews, and numerous forms of automated testing, this process doesn’t always go smoothly. Depending on the tooling and release cadence, release requests, rollbacks, emergency patches, and repetitive or manual configuration changes, releases may still generate toil.\n\nMigrations You may find yourself frequently migrating from one technology to another. You perform this work manually or with limited scripting because, hopefully, you’re only going to move from X to Y once. Migrations come in many forms, but some exam‐ ples include changes of data stores, cloud vendors, source code control systems, application libraries, and tooling.\n\nIf you approach a large-scale migration manually, the migration quite likely involves toil. You may be inclined to execute the migration manually because it’s a one-time effort. While you might even be tempted to view it as “project work” rather than “toil,” migration work can also meet many of the criteria of toil. Technically, modify‐ ing backup tooling for one database to work with another is software development, but this work is basically just refactoring code to replace one interface with another. This work is repetitive, and to a large extent, the business value of the backup tooling is the same as before.\n\nToil Taxonomy\n\n|\n\n99\n\nCost Engineering and Capacity Planning Whether you own hardware or use an infrastructure provider (cloud), cost engineer‐ ing and capacity planning usually entail some associated toil. For example:\n\nEnsuring a cost-effective baseline or burstable capability for future needs across resources like compute, memory, or IOPS (input/output operations per second). This may translate into purchase orders, AWS Reserved Instances, or Cloud/ Infrastructure as a Service contract negotiation.\n\nPreparing for (and recovering from) critical high-traffic events like a product launch or holiday.\n\nReviewing downstream and upstream service levels/limits.\n\nOptimizing workload against different footprint configurations. (Do you want to buy one big box, or four smaller boxes?)\n\nOptimizing applications against the billing specifics of proprietary cloud service offerings (DynamoDB for AWS or Cloud Datastore for GCP).\n\nRefactoring tooling to make better use of cheaper “spot” or “preemptable” resources.\n\nDealing with oversubscribed resources, either upstream with your infrastructure provider or with your downstream customers.\n\nTroubleshooting for Opaque Architectures Distributed microservice architectures are now common, and as systems become more distributed, new failure modes arise. An organization may not have the resour‐ ces to build sophisticated distributed tracing, high-fidelity monitoring, or detailed dashboards. Even if the business does have these tools, they might not work with all systems. Troubleshooting may even require logging in to individual systems and writing ad hoc log analytics queries with scripting tools.\n\nTroubleshooting itself isn’t inherently bad, but you should aim to focus your energy on novel failure modes—not the same type of failure every week caused by brittle sys‐ tem architecture. With each new critical upstream dependency of availability P, avail‐ ability decreases by 1 – P due to the combined chance of failure. A four 9s service that adds nine critical four 9s dependencies is now a three 9s service.3\n\n3 In other words, if a service and its nine dependencies each have 99.99% availability, the aggregate availability of the service will be 0.999910 = 99.9%. For further reading on how dependencies factor into service availabil‐ ity, see “The Calculus of Service Availability”.\n\n100\n\n|\n\nChapter 6: Eliminating Toil\n\nToil Management Strategies We’ve found that performing toil management is critical if you’re operating a pro‐ duction system of any scale. Once you identify and quantify toil, you need a plan for eliminating it. These efforts may take weeks or quarters to accomplish, so it’s impor‐ tant to have a solid overarching strategy.\n\nEliminating toil at its source is the optimal solution, but if doing so isn’t possible, then you must handle the toil by other means. Before we dive into the specifics of two in-depth case studies, this section provides some general strategies to consider when you’re planning a toil reduction effort. As you’ll observe across the two stories, the nuances of toil vary from team to team (and from company to company), but regard‐ less of specificity, some common tactics ring true for organizations of any size or fla‐ vor. Each of the following patterns is illustrated in a concrete way in at least one of the subsequent case studies.\n\nIdentify and Measure Toil We recommend that you adopt a data-driven approach to identify and compare sources of toil, make objective remedial decisions, and quantify the time saved (return on investment) by toil reduction projects. If your team is experiencing toil overload, treat toil reduction as its own project. Google SRE teams often track toil in bugs and rank toil according to the cost to fix it and the time saved by doing so. See the section “Measuring Toil” on page 96 for techniques and guidance.\n\nEngineer Toil Out of the System The optimal strategy for handling toil is to eliminate it at the source. Before investing effort in managing the toil generated by your existing systems and processes, examine whether you can reduce or eliminate that toil by changing the system.\n\nA team that runs a system in production has invaluable experience with how that sys‐ tem works. They know the quirks and tedious bits that cause the most amount of toil. An SRE team should apply this knowledge by working with product development teams to develop operationally friendly software that is not only less toilsome, but also more scalable, secure, and resilient.\n\nReject the Toil A toil-laden team should make data-driven decisions about how best to spend their time and engineering effort. In our experience, while it may seem counterproductive, rejecting a toil-intensive task should be the first option you consider. For a given set of toil, analyze the cost of responding to the toil versus not doing so. Another tactic is to intentionally delay the toil so that tasks accumulate for batch or parallelized\n\nToil Management Strategies\n\n|\n\n101\n\nprocessing. Working with toil in larger aggregates reduces interrupts and helps you identify patterns of toil, which you can then target for elimination.\n\nUse SLOs to Reduce Toil As discussed in Chapter 2, services should have a documented service level objective (SLO). A well-defined SLO enables engineers to make informed decisions. For exam‐ ple, you might ignore certain operational tasks if doing so does not consume or exceed the service’s error budget. An SLO that focuses on overall service health, rather than individual devices, is more flexible and sustainable as the service grows. See Chapter 2 for guidance on writing effective SLOs.\n\nStart with Human-Backed Interfaces If you have a particularly complex business problem with many edge cases or types of requests, consider a partially automated approach as an interim step toward full auto‐ mation. In this approach, your service receives structured data—usually via a defined API—but engineers may still handle some of the resulting operations. Even if some manual effort remains, this “engineer behind the curtain” approach allows you to incrementally move toward full automation. Use customer input to progress toward a more uniform way of collecting this data; by decreasing free-form requests, you can move closer to handling all requests programmatically. This approach can save back and forth with customers (who now have clear indicators of the information you need) and save you from overengineering a big-bang solution before you’ve fully mapped and understood the domain.\n\nProvide Self-Service Methods Once you’ve defined your service offering via a typed interface (see “Start with Human-Backed Interfaces” on page 102), move to providing self-service methods for users. You can provide a web form, binary or script, API, or even just documentation that tells users how to issue pull requests to your service’s configuration files. For example, rather than asking engineers to file a ticket to provision a new virtual machine for their development work, give them a simple web form or script that trig‐ gers the provisioning. Allow the script to gracefully degrade to a ticket for specialized requests or if a failure occurs.4 Human-backed interfaces are a good start in the war against toil, but service owners should always aim to make their offerings self-service where possible.\n\n4 Of course, you won’t be able to handle some one-off cases via self-service (“you want a VM with how much RAM?”), but aim to cover the majority of use cases. Moving 80–90% of requests to self-service is still a huge reduction in workload!\n\n102\n\n|\n\nChapter 6: Eliminating Toil",
      "page_number": 121
    },
    {
      "number": 15,
      "title": "Segment 15 (pages 130-137)",
      "start_page": 130,
      "end_page": 137,
      "detection_method": "topic_boundary",
      "content": "Get Support from Management and Colleagues In the short term, toil reduction projects reduce the staff available to address feature requests, performance improvements, and other operational tasks. But if the toil reduction is successful, in the long term the team will be healthier and happier, and have more time for engineering improvements.\n\nIt is important for everyone in the organization to agree that toil reduction is a worthwhile goal. Manager support is crucial in defending staff from new demands. Use objective metrics about toil to make the case for pushback.\n\nPromote Toil Reduction as a Feature To create strong business cases for toil reduction, look for opportunities to couple your strategy with other desirable features or business goals. If a complementary goal —for example, security, scalability, or reliability—is compelling to your customers, they’ll be more willing to give up their current toil-generating systems for shiny new ones that aren’t as toil intentive. Then, reducing toil is just a nice side effect of help‐ ing users!\n\nStart Small and Then Improve Don’t try to design the perfect system that eliminates all toil. Automate a few high- priority items first, and then improve your solution using the time you gained by eliminating that toil, applying the lessons learned along the way. Pick clear metrics such as MTTR (Mean Time to Repair) to measure your success.\n\nIncrease Uniformity At scale, a diverse production environment becomes exponentially harder to manage. Special devices require time-consuming and error-prone ongoing management and incident response. You can use the “pets versus cattle” approach5 to add redundancy and enforce consistency in your environment. Choosing what to consider cattle depends on the needs and scale of an organization. It may be reasonable to evaluate network links, switches, machines, racks of machines, or even entire clusters as inter‐ changeable units.\n\nShifting devices to a cattle philosophy may have a high initial cost, but can reduce the cost of maintenance, disaster recovery, and resource utilization in the medium to long term. Equipping multiple devices with the same interface implies that they have\n\n5 In short, moving away from individual specialized devices toward a fleet of devices with a common interface.\n\nSee “Case Study 1: Reducing Toil in the Datacenter with Automation” on page 107 for a detailed explanation of this analogy.\n\nToil Management Strategies\n\n|\n\n103\n\nconsistent configuration, are interchangeable, and require less maintenance. A con‐ sistent interface (to divert traffic, restore traffic, perform a shutdown, etc.) for a vari‐ ety of devices allows for more flexible and scalable automation.\n\nGoogle aligns business incentives to encourage engineering teams to unify across our ever-evolving toolkit of internal technologies and tools. Teams are free to choose their own approaches, but they have to own the toil generated by unsupported tools or legacy systems.\n\nAssess Risk Within Automation Automation can save countless hours in human labor, but in the wrong circumstan‐ ces, it can also trigger outages. In general, defensive software is always a good idea; when automation wields admin-level powers, defensive software is crucial. Every action should be assessed for its safety before execution. This includes changes that might reduce serving capacity or redundancy. When you’re implementing automa‐ tion, we recommend the following practices:\n\nHandle user input defensively, even if that input is flowing from upstream sys‐ tems—that is, be sure to validate the input carefully in context.\n\nBuild in safeguards that are equivalent to the types of indirect alerts that a human operator might receive. Safeguards might be as simple as command timeouts, or might be more sophisticated checks of current system metrics or the number of current outages. For this reason, monitoring, alerting, and instrumentation sys‐ tems should be consumable by both machine and human operators.\n\nBe aware that even read operations, naively implemented, can spike device load and trigger outages. As automation scales, these safety checks can eventually dominate workload.\n\nMinimize the impact of outages caused by incomplete safety checks of automa‐ tion. Automation should default to human operators if it runs into an unsafe condition.\n\nAutomate Toil Response Once you identify a piece of toil as automatable, it’s worthwhile to consider how to best mirror the human workflow in software. You rarely want to literally transcribe a human workflow into a machine workflow. Also note that automation shouldn’t eliminate human understanding of what’s going wrong.\n\nOnce your process is thoroughly documented, try to break down the manual work into components that can be implemented separately and used to create a composa‐ ble software library that other automation projects can reuse later. As the upcoming\n\n104\n\n|\n\nChapter 6: Eliminating Toil\n\ndatacenter repair case study illustrates, automation often provides the opportunity to reevaluate and simplify human workflows.\n\nUse Open Source and Third-Party Tools Sometimes you don’t have to do all of the work to reduce toil yourself. Many efforts like one-off migrations may not justify building their own bespoke tooling, but you’re probably not the first organization to tread this path. Look for opportunities to use or extend third-party or open source libraries to reduce development costs, or at least to help you transition to partial automation.\n\nUse Feedback to Improve It’s important to actively seek feedback from other people who interact with your tools, workflows, and automation. Your users will make different assumptions about your tools depending on their understanding of the underlying systems. The less familiar your users are with these systems, the more important it is to actively seek feedback from users. Leverage surveys, user experience (UX) studies, and other mechanisms to understand how your tools are used, and integrate this feedback to produce more effective automation in the future.\n\nHuman input is only one dimension of feedback you should consider. Also measure the effectiveness of automated tasks according to metrics like latency, error rate, rework rate, and human time saved (across all groups involved in the process). Ide‐ ally, find high-level measures you can compare before and after any automation or toil reduction efforts.\n\nLegacy Systems Most engineers with SRE-like responsibilities have encountered at least one legacy system in their work. These older systems often introduce problems with respect to user experience, security, reliability, or scalability. They tend to operate like a magical black box in that they “mostly work,” but few people understand how they work. They’re scary and expensive to modify, and keeping them running often requires a good deal of toilsome operational ritual.\n\nThe journey away from a legacy system usually follows this path:\n\n1. Avoidance: There are many reasons to not tackle this problem head on: you may not have the resources to replace this system. You judge the cost and risk to your business as not worth the cost of a replacement. There may not be any substan‐ tially better solutions commercially available. Avoidance is effectively choosing to accept technical debt and to move away from SRE principles and toward sys‐ tem administration.\n\nToil Management Strategies\n\n|\n\n105\n\n2. Encapsulation/augmentation: You can bring SREs on board to build a shell of abstracted APIs, automation, configuration management, monitoring, and test‐ ing around these legacy systems that will offload work from SAs. The legacy sys‐ tem remains brittle to change, but now you can at least reliably identify misbehavior and roll back when appropriate. This tactic is still avoidance, but is a bit like refinancing high-interest technical debt into low-interest technical debt. It’s usually a stopgap measure to prepare for an incremental replacement.\n\n3. Replacement/refactoring: Replacing a legacy system can require a vast amount of determination, patience, communication, and documentation. It’s best under‐ taken incrementally. One approach is to define a common interface that sits in front of and abstracts a legacy system. This strategy helps you slowly and safely migrate users to alternatives using release engineering techniques like canarying or blue-green deployments. Often, the “specification” of a legacy system is really defined only by its historical usage, so it’s helpful to build production-sized data sets of historical expected inputs and outputs to build confidence that new sys‐ tems aren’t diverging from expected behavior (or are diverging in an expected way).\n\n4. Retirement/custodial ownership: Eventually the majority of customers or func‐ tionality is migrated to one or more alternatives. To align business incentives, stragglers who haven’t migrated can assume custodial ownership of remnants of the legacy system.\n\nCase Studies The following case studies illustrate the strategies for toil reduction just discussed. Each story describes an important area of Google’s infrastructure that reached a point at which it could no longer scale sublinearly with human effort; over time, an increas‐ ing number of engineer hours resulted in smaller returns on that investment. Much of that effort you’ll now recognize as toil. For each case study, we detail how the engi‐ neers identified, assessed, and mitigated that toil. We also discuss the results and the lessons we learned along the way.\n\nIn the first case study, Google’s datacenter networking had a scaling problem: we had a massive number of Google-designed components and links to monitor, mitigate, and repair. We needed a strategy to minimize the toilsome nature of this work for datacenter technicians.\n\nThe second case study focuses on a team running their own “outlier” specialized hardware to support toil-intensive business processes that had become deeply entrenched within Google. This case study illustrates benefits of reevaluating and replacing operationally expensive business processes. It demonstrates that with a little persistence and perseverance, it’s possible to move to alternatives even when con‐ strained by the institutional inertia of a large organization.\n\n106\n\n|\n\nChapter 6: Eliminating Toil\n\nTaken together, these case studies provide a concrete example of each toil reduction strategy covered earlier. Each case study begins with a list of relevant toil reduction strategies.\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\nToil reduction strategies highlighted in Case Study 1:\n\nEngineer toil out of the system\n\nStart small and then improve\n\nIncrease uniformity\n\nUse SLOs to reduce toil\n\nAssess risk within automation\n\nUse feedback to improve\n\nAutomate toil response\n\nBackground This case study takes place in Google’s datacenters. Similar to all datacenters, Goo‐ gle’s machines are connected to switches, which are connected to routers. Traffic flows in and out from these routers via links that in turn connect to other routers on the internet. As Google’s requirements for handling internet traffic grew, the number of machines required to serve that traffic increased dramatically. Our datacenters grew in scope and complexity as we figured out how to serve a large amount of traffic efficiently and economically. This growth changed the nature of datacenter manual repairs from occasional and interesting to frequent and rote—two signals of toil.\n\nWhen Google first began running its own datacenters, each datacenter’s network top‐ ology featured a small number of network devices that managed traffic to a large number of machines. A single network device failure could significantly impact net‐ work performance, but a relatively small team of engineers could handle trouble‐ shooting the small number of devices. At this early stage, engineers debugged problems and shifted traffic away from failed components manually.\n\nOur next-generation datacenter had significantly more machines and introduced software-defined networking (SDN) with a folded Clos topology, which greatly increased the number of switches. Figure 6-2 shows the complexity of traffic flow for a small datacenter Clos switch network. This proportionately larger number of devi‐ ces meant that a larger number of components could now fail. While each individual\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n107\n\nfailure had less impact on network performance than before, the sheer volume of issues began to overwhelm the engineering staff.\n\nIn addition to introducing a heavy load of new problems to debug, the complex lay‐ out was confusing to technicians: Which exact links needed to be checked? Which line card6 did they need to replace? What was a Stage 2 switch, versus a Stage 1 or Stage 3 switch? Would shutting down a switch create problems for users?\n\nFigure 6-2. A small Clos network, which supports 480 machines attached below Stage 1\n\nRepairing failed datacenter line cards was one obvious growing work backlog, so we targeted this task as our first stage of creating datacenter network repair automation. This case study describes how we introduced repair automation for our first genera‐ tion of line cards (named Saturn). We then discuss the improvements we introduced with the next generation of line cards for Jupiter fabrics.\n\nAs shown in Figure 6-3, before the automation project, each fix in the datacenter line-card repair workflow required an engineer to do the following:\n\n1. Check that it was safe to move traffic from the affected switch.\n\n2. Shift traffic away from the failed device (a “drain” operation).\n\n6 A line card is a modular component that usually provides multiple interfaces to the network. It is seated in\n\nthe backplane of a chassis along with other line cards and components. Modular network switches consist of a chassis that includes a backplane, power entry modules, control card module, and one or more line cards. Each line card supports network connections either to machines or other line cards (in other switches). As with a USB network interface adapter, you can replace any line card without powering down the whole switch, provided the line card has been “drained,” meaning that the other interfaces have been told to stop sending traffic to it.\n\n108\n\n|\n\nChapter 6: Eliminating Toil\n\n3. Perform a reboot or repair (such as replacing a line card).\n\n4. Shift traffic back to the device (an “undrain” operation).\n\nThis unvarying and repetitive work of draining, undraining, and repairing devices is a textbook example of toil. The repetitive nature of the work introduced problems of its own—for example, engineers might multitask by working on a line card while also debugging more challenging problems. As a result, the distracted engineer might accidentally introduce an unconfigured switch back to the network.\n\nFigure 6-3. Datacenter (Saturn) line-card repair workflow before automation: all steps require manual work\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n109\n\nProblem Statement The datacenter repairs problem space had the following dimensions:\n\nWe couldn’t grow the team fast enough to keep up with the volume of failures, and we couldn’t fix problems fast enough to prevent negative impact to the fabric.\n\nPerforming the same steps repeatedly and frequently introduced too many human errors.\n\nNot all line-card failures had the same impact. We didn’t have a way to prioritize more serious failures.\n\nSome failures were transient. We wanted the option to restart the line card or reinstall the switch as a first pass at repair. Ideally, we could then programmati‐ cally capture the problem if it happened again and flag the device for replace‐ ment.\n\nThe new topology required us to manually assess the risk of isolating capacity before we could take action. Every manual risk assessment was an opportunity for human error that could result in an outage. Engineers and technicians on the floor didn’t have a good way to gauge how many devices and links would be impacted by their planned repair.\n\nWhat We Decided to Do Instead of assigning every issue to an engineer for risk assessment, drain, undrain, and validation, we decided to create a framework for automation that, when coupled with an on-site technician where appropriate, could support these operations programmatically.\n\nDesign First Effort: Saturn Line-Card Repair Our high-level goal was to build a system that would respond to problems detected on network devices, rather than relying on an engineer to triage and fix these prob‐ lems. Instead of sending a “line card down” alert to an engineer, we wrote the soft‐ ware to request a drain (to remove traffic) and create a case for a technician. The new system had a few notable features:\n\nWe leveraged existing tools where possible. As shown in Figure 6-3, our alerting could already detect problems on the fabric line cards; we repurposed that alert‐ ing to trigger an automated repair. The new workflow also repurposed our tick‐ eting system to support network repairs.\n\n110\n\n|\n\nChapter 6: Eliminating Toil",
      "page_number": 130
    },
    {
      "number": 16,
      "title": "Segment 16 (pages 138-147)",
      "start_page": 138,
      "end_page": 147,
      "detection_method": "topic_boundary",
      "content": "We built in automated risk assessment to prevent accidental isolation of devices during a drain and to trigger safety mechanisms where required. This eliminated a huge source of human errors.\n\nWe adopted a strike policy that was tracked by software: the first failure (or strike) only rebooted the card and reinstalled the software. A second failure trig‐ gered card replacement and full return to the vendor.\n\nImplementation The new automated workflow (shown in Figure 6-4) proceeded as follows:\n\n1. The problematic line card is detected and a symptom is added to a specific com‐ ponent in the database.\n\n2. The repair service picks up the problem and enables repairs on the switch. The service performs a risk assessment to confirm that no capacity will be isolated by the operation, and then: a. Drains traffic from the entire switch.\n\nb. Shuts down the line card.\n\nc. If this is a first failure, reboots the card and undrains the switch, restoring ser‐\n\nvice to the switch. At this point, the workflow is complete.\n\nd. If this is the second failure, the workflow proceeds to step 3.\n\n3. The workflow manager detects the new case and sends it to a pool of repair cases for a technician to claim.\n\n4. The technician claims the case, sees a red “stop” in the UI (indicating that the switch needs to be drained before repairs are started), and executes the repair in three steps: a. Initiates the chassis drain via a “Prep component” button in the technician\n\nUI.\n\nb. Waits for the red “stop” to clear, indicating that the drain is complete and the\n\ncase is actionable.\n\nc. Replaces the card and closes the case.\n\n5. The automated repair system brings the line card up again. After a pause to give the card time to initialize, the workflow manager triggers an operation to restore traffic to the switch and close the repair case.\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n111\n\nFigure 6-4. Saturn line-card repair workflow with automation: manual work required only to push a button and replace the line card\n\nThe new system freed the engineering team from a large volume of toilsome work, giving them more time to pursue productive projects elsewhere: working on Jupiter, the next-generation Clos topology.\n\n112\n\n|\n\nChapter 6: Eliminating Toil\n\nDesign Second Effort: Saturn Line-Card Repair Versus Jupiter Line- Card Repair Capacity requirements in the datacenter continued to double almost every 12 months. As a result, our next-generation datacenter fabric, Jupiter, was more than six times larger than any previous Google fabric. The volume of problems was also six times larger. Jupiter presented scaling challenges for repair automation because thou‐ sands of fiber links and hundreds of line cards could fail in each layer. Fortunately, the increase in potential failure points was accompanied by far greater redundancy, which meant we could implement more ambitious automation. As shown in Figure 6-5, we preserved some of the general workflow from Saturn and added a few important modifications:\n\nAfter an automated drain/reboot cycle determined that we wanted to replace hardware, we sent the hardware to a technician. However, instead of requiring a technician to initiate the drain with the “Push prep button to drain switch,” we automatically drained the entire switch when it failed.\n\nWe added automation for installing and pushing the configuration that engages after component replacement.\n\nWe enabled automation for verifying that the repair was successful before undraining the switch.\n\nWe focused attention on recovering the switch without involving a technician unless absolutely necessary.\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n113\n\nFigure 6-5. Saturn line-card down automation (left) versus Jupiter automation (right)\n\nImplementation We adopted a simple and uniform workflow for every line-card problem on Jupiter switches: declare the switch down, drain it, and begin a repair.\n\n114\n\n|\n\nChapter 6: Eliminating Toil\n\nThe automation carried out the following:\n\n1. The problem switch-down is detected and a symptom is added to the database.\n\n2. The repair service picks up the problem and enables repairs on the switch: drain the entire switch, and add a drain reason.\n\na. If this is the second failure within six months, proceed to step 4.\n\nb. Otherwise, proceed to step 3.\n\n3. Attempt (via two distinct methods) to power-cycle the switch.\n\na. If the power-cycle is successful, run automated verification, then install and configure the switch. Remove the repair reason, clear the problem from the database, and undrain the switch.\n\nb. If preceding sanity-checking operations fail, send the case to a technician with\n\nan instruction message.\n\n4. If this was the second failure, send the case directly to the technician, requesting new hardware. After the hardware change occurs, run automated verification and then install and configure the switch. Remove the repair reason, clear the problem from the database, and undrain the switch.\n\nThis new workflow management was a complete rewrite of the previous repair sys‐ tem. Again, we leveraged existing tools when possible:\n\nThe operations for configuring new switches (install and verify) were the same operations we needed to verify that a switch that had been replaced.\n\nDeploying new fabrics quickly required the ability to BERT7 and cable-audit8 programmatically. Before restoring traffic, we reused that capability to automati‐ cally run test patterns on links that had fallen into repairs. These tests further improved performance by identifying faulty links.\n\nThe next logical improvement was to automate mitigation and repair of memory errors on Jupiter switch line cards. As shown in Figure 6-6, prior to automation, this workflow depended heavily on an engineer to determine if the failure was hardware- or software-related, and then to drain and reboot the switch or arrange a repair if appropriate.\n\n7 Bit error rate test: check for unhealthy links before restoring service.\n\n8 Check for miscabled ports.\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n115\n\nFigure 6-6. Jupiter memory error repair workflow before automation\n\nOur automation simplified the repair workflow by no longer attempting to trouble‐ shoot memory errors (see “Sometimes imperfect automation is good enough” on page 119 for why this made sense). Instead, we treated memory errors the same way we handled failed line cards. To extend automation to memory errors, we simply had to add another symptom to a config file to make it act on the new problem type. Figure 6-7 depicts the automated workflow for memory errors.\n\n116\n\n|\n\nChapter 6: Eliminating Toil\n\nFigure 6-7. Jupiter memory error repair workflow with automation\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n117\n\nLessons Learned During the several years we worked to automate network repair, we learned a lot of general lessons about how to effectively reduce toil.\n\nUIs should not introduce overhead or complexity\n\nFor Saturn-based line cards, replacing a line card required draining the entire switch. Draining the entire switch early in the repair process meant losing the working capacity of all line cards on the switch while waiting for replacement parts and a tech‐ nician. We introduced a button in the UI called “Prep component” that allowed a technician to drain traffic from the entire switch right before they were ready to replace the card, thereby eliminating unnecessary downtime for the rest of the switch (see “Push prep button to drain switch” in Figure 6-5).\n\nThis aspect of the UI and repair workflow introduced a number of unexpected problems:\n\nAfter pressing the button, the technician did not get feedback on drain progress but instead simply had to wait for permission to proceed.\n\nThe button didn’t reliably sync with the actual state of the switch. As a result, sometimes a drained switch did not get repaired, or a technician interrupted traf‐ fic by acting upon an undrained switch.\n\nComponents that did not have automation enabled returned a generic “contact engineering” message when a problem arose. Newer technicians did not know the best way to reach someone who could help. Engineers who were contacted were not always immediately available.\n\nIn response to user reports and problems with regressions caused by the complexity of the feature, we designed future workflows to ensure the switch was safe and ready for repair before the technician arrived at the switch.\n\nDon’t rely on human expertise\n\nWe leaned too heavily on experienced datacenter technicians to identify errors in our system (for example, when the software indicated it was safe to proceed with repairs, but the switch was actually undrained). These technicians also had to perform several tasks manually, without being prompted by automation.\n\nExperience is difficult to replicate. In one particularly high-impact episode, a techni‐ cian decided to expedite the “press button and wait for results” experience by initiat‐ ing concurrent drains on every line card waiting for repairs at the datacenter, resulting in network congestion and user-visible packet loss. Our software didn’t anticipate and prevent this action because we didn’t test the automation with new technicians.\n\n118\n\n|\n\nChapter 6: Eliminating Toil\n\nDesign reusable components\n\nWhere possible, avoid monolithic designs. Build complex automation workflows from separable components, each of which handles a distinct and well-defined task. We could easily reuse or adapt key components of our early Jupiter automation for each successive generation of fabric, and it was easier to add new features when we could build on automation that already existed. Successive variations on Jupiter-type fabrics could leverage work done in earlier iterations.\n\nDon’t overthink the problem\n\nWe overanalyzed the memory error problem for Jupiter line cards. In our attempts at precise diagnosis, we sought to distinguish software errors (fixable by reboots) from hardware errors (which required card replacement), and also to identify errors that impacted traffic versus errors that did not. We spent nearly three years (2012–2015) collecting data on over 650 discrete memory error problems before realizing this exercise was probably overkill, or at least shouldn’t block our repair automation project.\n\nOnce we decided to act upon any error we detected, it was straightforward to use our existing repair automation to implement a simple policy of draining, rebooting, and reinstalling switches in response to memory errors. If the problem recurred, we con‐ cluded that the failure was likely hardware-based and requested component replace‐ ment. We gathered data over the course of a quarter and discovered that most of the errors were transient—most switches recovered after being rebooted and reinstalled. We didn’t need additional data to perform the repair, so the three-year delay in implementing the automation was unnecessary.\n\nSometimes imperfect automation is good enough\n\nWhile the ability to verify links with BERT before undraining them was handy, BERT tooling didn’t support network management links. We added these links into the existing link repair automation with a check that allowed them to skip verification. We were comfortable bypassing verification because the links didn’t carry customer traffic, and we could add this functionality later if verification turned out to be important.\n\nRepair automation is not fire and forget\n\nAutomation can have a very long lifetime, so make sure to plan for project continuity as people leave and join the team. New engineers should be trained on legacy systems so they can fix bugs. Due to parts shortages for Jupiter fabrics, Saturn-based fabrics lived on long after the originally targeted end-of-life date, requiring us to introduce some improvements quite late in Saturn’s overall lifespan.\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n119\n\nOnce adopted, automation may become entrenched for a long time, with positive and negative consequences. When possible, design your automation to evolve in a flexible way. Relying on inflexible automation makes systems brittle to change. Policy-based automation can help by clearly separating intent from a generic implementation engine, allowing automation to evolve more transparently.\n\nBuild in risk assessment and defense in depth\n\nAfter building new tools for Jupiter that determined the risk of a drain operation before executing it, the complexity we encountered led us to introduce a secondary check for defense in depth. The second check established an upper limit for the num‐ ber of impacted links, and another limit for impacted devices. If we exceeded either threshold, a tracking bug to request further investigation opened automatically. We tuned these limits over time to reduce false positives. While we originally considered this a temporary measure until the primary risk assessment stabilized, the secondary check has proven useful for identifying atypical repair rates due to power outages and software bugs (for one example, see “Automation: Enabling Failure at Scale” in Site Reliability Engineering).\n\nGet a failure budget and manager support\n\nRepair automation can sometimes fail, especially when first introduced. Management support is crucial in preserving the project and empowering the team to persevere. We recommend establishing an error budget for antitoil automation. You should also explain to external stakeholders that automation is essential despite the risk of fail‐ ures, and that it enables continuous improvement in reliability and efficiency.\n\nThink holistically\n\nUltimately, the complexity of scenarios to be automated is the real hurdle to over‐ come. Reexamine the system before you work on automating it—can you simplify the system or workflow first?\n\nPay attention to all aspects of the workflow you are automating, not just the aspects that create toil for you personally. Conduct testing with the people directly involved in the work and actively seek their feedback and assistance. If they make mistakes, find out how your UI could be clearer, or what additional safety checks you need. Make sure your automation doesn’t create new toil—for example, by opening unnec‐ essary tickets that need human attention. Creating problems for other teams will increase resistance to future automation endeavors.\n\n120\n\n|\n\nChapter 6: Eliminating Toil",
      "page_number": 138
    },
    {
      "number": 17,
      "title": "Segment 17 (pages 148-155)",
      "start_page": 148,
      "end_page": 155,
      "detection_method": "topic_boundary",
      "content": "Case Study 2: Decommissioning Filer-Backed Home Directories\n\nToil reduction strategies highlighted in Case Study 2:\n\nConsider decommissioning legacy systems\n\nPromote toil reduction as a feature\n\nGet support from management and colleagues\n\nReject the toil\n\nStart with human-backed interfaces\n\nProvide self-service methods\n\nStart small and then improve\n\nUse feedback to improve\n\nBackground In the early days of Google, the Corp Data Storage (CDS) SRE team provided home directories to all Googlers. Similar to Active Directory’s Roaming Profiles, common in Enterprise IT, Googlers could use the same home directories across workstations and platforms. The CDS team also offered “Team Shares” for cross-team collabora‐ tion in a shared storage space. We provided home directories and Team Shares via a fleet of Netapp Storage Appliances over NFS/CIFS (or “filers”). This storage was operationally expensive but provided a much-needed service to Googlers.\n\nProblem Statement As years passed, these filer solutions were mostly deprecated by other, better, storage solutions: our version control systems (Piper9/Git-on-borg10), Google Drive, Google Team Drive, Google Cloud Storage, and an internal, shared, globally distributed file‐ system called x20. These alternatives were superior for a number of reasons:\n\n9 Piper is Google’s internal version control system. For more information, see Rachel Potvin and Josh Leven‐ berg, “Why Google Stores Billions of Lines of Code in a Single Repository,” Communications of the ACM 59, no. 7 (2016): 78–87, http://bit.ly/2J4jgMi.\n\n10 Google also has scalable self-service Git hosting for code that doesn’t live in Piper.\n\nCase Study 2: Decommissioning Filer-Backed Home Directories\n\n|\n\n121\n\nNFS/CIFS protocols were never designed to operate over a WAN, so user experi‐ ence rapidly degraded with even a few tens of milliseconds of latency. This cre‐ ated problems for remote workers or globally distributed teams, as the data could live only in one location.\n\nCompared to alternatives, these appliances were expensive to run and scale.\n\nIt would have taken significant work to make NFS/CIFS protocols compatible with Google’s Beyond Corp11 network security model.\n\nMost relevant to this chapter, home directories and Team Shares were toil-intensive. Many facets of storage provisioning were ticket-driven. Although these workflows were often partially scripted, they represented a sizable amount of the CDS team’s toil. We spent a lot of time creating and configuring shares, modifying access, troubleshooting end user issues, and performing turnups and turndowns to manage capacity. CDS also managed the provisioning, racking, and cabling processes for this specialized hardware, in addition to their configuration, updates, and backups. Due to latency requirements, we often had to deploy in remote offices instead of Google datacenters—which sometimes required a team member to travel a substantial dis‐ tance to manage a deployment.\n\nWhat We Decided to Do First, we gathered data: CDS created a tool called Moonwalk to analyze how employ‐ ees used our services. We collected traditional business intelligence metrics like daily active users (DAU) and monthly active users (MAU), and asked questions like, “Which job families actually use their home directories?” and “Of the users who use filers every day, what kind of files do they access the most?” Moonwalk, combined with user surveys, validated that the business needs currently served by filers could be better served by alternative solutions that had lower operational overhead and cost. Another compelling business reason led us to move away from filers: if we could migrate most of our filer use cases to G Suite/GCP, then we could use the lessons we learned to improve these products, thereby enabling other large enterprises to migrate to G Suite/GCP.\n\nNo single alternative could meet all of the current filer use cases. However, by break‐ ing the problem into smaller addressable components, we found that in aggregate, a handful of alternatives could cover all of our use cases. The alternative solutions were\n\n11 Beyond Corp is an initiative to move from a traditional perimeter-based security model to a cryptographic\n\nidentity-based model. When a Google laptop connects to an internal Google service, the service verifies trust through a combination of a cryptographic certificate identifying the laptop, a second factor owned by the user (such as a USB security key), the client device config/state, and the user’s credentials.\n\n122\n\n|\n\nChapter 6: Eliminating Toil\n\nmore specialized, but each provided a better user experience than a generalized filer- powered solution. For example:\n\nx2012\n\nWas a great way for teams to globally share static artifacts like binaries\n\nG Suite Team Drive\n\nWorked well for office document collaboration, and was much more tolerant of user latency than NFS\n\nGoogle’s Colossus File System\n\nAllowed teams to share large data files more securely and scalably than NFS\n\nPiper/Git-on-Borg\n\nCould better sync dotfiles (engineers’ personalized tool preferences)\n\nA new history-as-a-service tool\n\nCould host cross-workstation command-line history\n\nAs we catalogued use cases and found alternatives, the decommissioning plan took shape.\n\nDesign and Implementation Moving away from filers was an ongoing, iterative, multiyear effort that entailed mul‐ tiple internal projects:\n\nMoira\n\nHome directory decommissioning\n\nTekmor\n\nMigrating the long tail of home directory users\n\nMigra\n\nTeam Share decommissioning\n\nAzog\n\nRetiring home directory/share infrastructure and associated hardware\n\nThis case study focuses on the first project, Moira. The subsequent projects built upon what we learned from and created for Moira.\n\nAs shown in Figure 6-8, Moira consisted of four phases.\n\n12 x20 is an internal globally shared, highly available filesystem with POSIX-like filesystem semantics.\n\nCase Study 2: Decommissioning Filer-Backed Home Directories\n\n|\n\n123\n\nFigure 6-8. The four stages of Project Moira\n\nThe first step to retiring a legacy system is to stop or (often more realistically) to slow or discourage new adoption. It’s much more painful to take something away from users than never offer it in the first place. Moonwalk data showed that nonengineer‐ ing Googlers used their shared home directories the least, so our initial phase targe‐ ted these users. As the phases grew in scope, so did our confidence in the alternative storage solutions and our migration processes and tooling. Each phase of the project had an associated design document that examined the proposal along dimensions like security, scalability, testing, and launch. We also paid special attention to user experience, expectations, and communication. Our goal was making sure that users affected by each phase understood the reasons for the decommissioning project and the easiest way to archive or migrate their data.\n\nKey Components\n\nMoonwalk\n\nWhile we had basic statistics about our users’ shares (share sizes, for example), we needed to understand our users’ workflows to help drive business decisions around the deprecation. We set up a system called Moonwalk to gather and report this infor‐ mation.\n\nMoonwalk stored the data about who was accessing what files and when in BigQuery, which allowed us to create reports and perform ad hoc queries to understand our users better. Using BigQuery, we summarized access patterns across 2.5 billion files using 300 terabytes of disk space. This data was owned by 60,000 POSIX users in 400 disk volumes on 124 NAS appliances in 60 geographic sites around the world.\n\n124\n\n|\n\nChapter 6: Eliminating Toil\n\nMoira Portal\n\nOur large user base made managing the home directory decommissioning effort with a manual ticket-based process untenable. We needed to make the entire process— surveying users, communicating the reasons for the decommissioning project, and walking through either archiving their data or migrating to an alternative—as low- touch as possible. Our final requirements were:\n\nA landing page describing the project\n\nA continually updated FAQ\n\nThe status and usage information associated with the current user’s share\n\nOptions to request, deactivate, archive, delete, extend, or reactivate a share\n\nOur business logic became fairly complicated because we had to account for a num‐ ber of user scenarios. For example, a user might leave Google, go on a temporary leave, or have data under a litigation hold. Figure 6-9 provides a sample design doc state diagram illustrating this complexity.\n\nFigure 6-9. Business logic based upon user scenarios\n\nCase Study 2: Decommissioning Filer-Backed Home Directories\n\n|\n\n125\n\nThe technology powering the portal was relatively simple. Written in Python with the Flask framework, it read and wrote to a Bigtable, and used a number of background jobs and schedulers to manage its work.\n\nArchiving and migration automation\n\nWe needed a lot of ancillary tooling to glue the portal and configuration management together, and to query and communicate with users. We also needed to be sure we identified the right users for the right communications. False positives (erroneously reporting action required) or false negatives (failing to notify a user that you were taking something away) were both unacceptable, and errors here would mean extra work in the form of lost credibility and customer service.\n\nWe worked with alternative storage system owners to add features to their roadmaps. As a result, less mature alternatives became more suitable for filer use cases as the project progressed. We could also use and extend tooling from other teams. For example, we used another team’s internally developed tool to migrate data from Goo‐ gle Cloud Storage to Google Drive as part of the Portal’s auto-archiving functionality.\n\nThe effort required substantial software development over the life of the project. We built and iterated upon each component—the Moonwalk reporting pipeline, the por‐ tal, and the automation to better manage retiring and archiving shares—in response to the next phase’s requirements and user feedback. We approached a feature- complete state only in phase three (almost two years in); and even then, we needed additional tooling to handle a “long tail” of around 800 users. This low and slow approach had definite benefits. It allowed us to:\n\nMaintain a lean team (averaging three CDS team members)\n\nReduce the disruption to user workflows\n\nLimit toil for Techstop (Google’s internal technical support organization)\n\nBuild tools on an as-needed basis to avoid wasted engineering effort\n\nAs with all engineering decisions, there were tradeoffs: the project would be long- lived, so the team had to endure filer-related operational toil while engineering these solutions.\n\nThe program officially completed in 2016. We’ve reduced home directories from 65,000 to around 50 at the time of writing. (The current Azog Project aims to retire these last users and fully decommission the filer hardware.) Our users’ experience has improved, and CDS has retired operationally expensive hardware and processes.\n\n126\n\n|\n\nChapter 6: Eliminating Toil\n\nLessons Learned While no one alternative could replace the filer-backed storage that Googlers had used for 14+ years, we didn’t necessarily need a wholesale replacement. By effectively moving up the stack from a generalized but limited filesystem-level solution to multi‐ ple application-specific solutions, we traded flexibility for improved scalability, latency tolerance, and security. The Moira team had to anticipate a variety of user journeys and consider alternatives in various stages of maturity. We had to manage expectations around these alternatives: in aggregate, they could provide a better user experience, but getting there wouldn’t be painless. We learned the following lessons about effectively reducing toil along the way.\n\nChallenge assumptions and retire expensive business processes\n\nBusiness requirements drift and new solutions continuously emerge, so it’s worth‐ while to periodically question toil-intensive business processes. As we discussed in “Toil Management Strategies” on page 101, rejecting toil (deciding not to perform toilsome tasks) is often the simplest way to eliminate it, even though this approach isn’t always quick or easy. Shore up your case with user analytics and business justifi‐ cations beyond mere toil reduction. The primary business justification for filer decommissioning came down to the benefits of a Beyond Corp security model. So, while Moira was a great way to reduce the CDS team’s toil, emphasizing the many security benefits of decommissioning filers made for a more compelling business case.\n\nBuild self-service interfaces\n\nWe built a custom portal for Moira (which was relatively expensive), but there are often easier alternatives. Many teams at Google manage and configure their services using version control, and process organizational requests in the form of pull requests (called changelists, or CLs). This approach requires little or no involvement from the service’s team, but gives us the benefits of code review and continuous deployment processes to validate, test, and deploy internal service configuration changes.\n\nStart with human-backed interfaces\n\nAt several points, the Moira team used an “engineer behind the curtain” approach that married automation with manual work by engineers. For example, share requests opened tracking bugs, which our automation updated as we processed the requests. The system also assigned end users bugs to remind them to address their shares. Tickets can serve as a quick and dirty GUI for automation: they keep a log of work, update stakeholders, and provide a simple human fallback mechanism if auto‐ mation goes awry. In our case, if a user needed help with their migration or if auto‐\n\nCase Study 2: Decommissioning Filer-Backed Home Directories\n\n|\n\n127\n\nmation couldn’t process their request, the bug was automatically routed to a queue that SREs handled manually.\n\nMelt snowflakes\n\nAutomation craves conformity. Moira’s engineers chose to retool our automation to either handle share edge cases specifically, or to delete/modify nonconforming shares to match expectations of tooling. This allowed us to approach zero-touch automation for much of the migration processes.\n\nFun Fact: At Google, this practice of changing reality to fit the code rather than the other way around is called “buying the gnome.” This phrase references a legend about Froogle, a shopping search engine from the very early days of the company.\n\nEarly in Froogle’s life, a serious search quality bug caused a search for [running shoes] to return a garden gnome (wearing running shoes) as a high-ranking result. After several unsuccessful attempts to fix the bug, someone noticed that the gnome was not a mass- produced item, but a single eBay listing with a Buy It Now option. They purchased the gnome (Figure 6-10).\n\nFigure 6-10. The garden gnome that wouldn’t go away\n\n128\n\n|\n\nChapter 6: Eliminating Toil",
      "page_number": 148
    },
    {
      "number": 18,
      "title": "Segment 18 (pages 156-164)",
      "start_page": 156,
      "end_page": 164,
      "detection_method": "topic_boundary",
      "content": "Employ organizational nudges\n\nLook for ways to nudge new users to adopt better (and hopefully less toil-intensive) alternatives. In this vein, Moira required escalations for new share or quota requests and recognized users who retired their shares. It’s also important to provide good documentation around service setup, best practices, and when to use your service. Google teams frequently employ codelabs or cookbooks that teach users how to set up and use their service for common use cases. As a result, most user onboarding doesn’t require help from the team that owns the service.\n\nConclusion At minimum, the amount of toil associated with running a production service grows linearly with its complexity and scale. Automation is often the gold standard of toil elimination, and can be combined with a number of other tactics. Even when toil isn’t worth the effort of full automation, you can decrease engineering and operations workloads through strategies like partial automation or changing business processes.\n\nThe patterns and methods for eliminating toil described in this chapter can be gener‐ alized to work for a variety of other large-scale production services. Eliminating toil frees up engineering time to focus on the more enduring aspects of services, and allows teams to keep manual tasks at a minimum as the complexity and scale of modern service architectures continue to increase.\n\nIt’s important to note that eliminating toil isn’t always the best solution. As men‐ tioned throughout this chapter, you should consider the measurable costs associated with identifying, designing, and implementing processes or automation solutions around toil. Once you identify toil, it’s crucial to determine when toil reduction makes sense, using metrics, return on investment (ROI) analysis, risk assessment, and iterative development.\n\nToil usually starts small, and can rapidly grow to consume an entire team. SRE teams must be relentless in eliminating toil, because even if the task seems daunting, the benefits usually exceed the costs. Each of the projects we described required persever‐ ance and dedication from its respective teams, who sometimes battled skepticism or institutional resistance, and who always faced competing high priorities. We hope these stories encourage you to identify your toil, quantify it, and then work toward eliminating it. Even if you can’t invest in a big project today, you can start with a small proof of concept that can help change your team’s willingness to deal with toil.\n\nConclusion\n\n|\n\n129\n\nCHAPTER 7 Simplicity\n\nBy John Lunney, Robert van Gent, and Scott Ritchie with Diane Bates and Niall Richard Murphy\n\nA complex system that works is invariably found to have evolved from a simple system that worked.\n\n—Gall’s Law\n\nSimplicity is an important goal for SREs, as it strongly correlates with reliability: sim‐ ple software breaks less often and is easier and faster to fix when it does break. Simple systems are easier to understand, easier to maintain, and easier to test.\n\nFor SREs, simplicity is an end-to-end goal: it should extend beyond the code itself to the system architecture and the tools and processes used to manage the software life‐ cycle. This chapter explores some examples that demonstrate how SREs can measure, think about, and encourage simplicity.\n\nMeasuring Complexity Measuring the complexity of software systems is not an absolute science. There are a number of ways to measure software code complexity, most of which are quite objec‐ tive.1 Perhaps the best-known and most widely available standard is cyclomatic code complexity, which measures the number of distinct code paths through a specific set of statements. For example, a block of code with no loops or conditionals has a cyclo‐ matic complexity number (CCN) of 1. The software community is actually quite good at measuring code complexity, and there are measurement tools for a number of integrated development environments (including Visual Studio, Eclipse, and\n\n1 If you’re interested in learning more, read this recent review of trends in software complexity, or read Horst\n\nZuse, Software Complexity: Measures and Methods (Berlin: Walter de Gruyter, 1991).\n\n131\n\nIntelliJ). We’re less adept at understanding whether the resulting measured complex‐ ity is necessary or accidental, how the complexity of one method might influence a larger system, and which approaches are best for refactoring.\n\nOn the other hand, formal methodologies for measuring system complexity are rare.2 You might be tempted to try a CCN-type approach of counting the number of dis‐ tinct entities (e.g., microservices) and possible communication paths between them. However, for most sizable systems, that number can grow hopelessly large very quickly.\n\nSome more practical proxies for systems-level complexity include:\n\nTraining time\n\nHow long does it take a new team member to go on-call? Poor or missing docu‐ mentation can be a significant source of subjective complexity.\n\nExplanation time\n\nHow long does it take to explain a comprehensive high-level view of the service to a new team member (e.g., diagram the system architecture on a whiteboard and explain the functionality and dependencies of each component)?\n\nAdministrative diversity\n\nHow many ways are there to configure similar settings in different parts of the system? Is configuration stored in a centralized place, or in multiple locations?\n\nDiversity of deployed configurations\n\nHow many unique configurations are deployed in production (including binar‐ ies, binary versions, flags, and environments)?\n\nAge\n\nHow old is the system? Hyrum’s Law states that over time, the users of an API depend on every aspect of its implementation, resulting in fragile and unpredict‐ able behaviors.\n\nWhile measuring complexity is occasionally worthwhile, it’s difficult. However, there seems to be no serious opposition to the observations that:\n\nIn general, complexity will increase in living software systems unless there is a countervailing effort.\n\nProviding that effort is a worthwhile thing to do.\n\n2 Although there are examples of it—for example, “Automated Formal Reasoning about AWS Systems”.\n\n132\n\n|\n\nChapter 7: Simplicity\n\nSimplicity Is End-to-End, and SREs Are Good for That Generally, production systems are not designed in a holistic fashion; rather, they grow organically. They accumulate components and connections over time as teams add new features and launch new products. While a single change might be relatively simple, every change impacts the components around it. Therefore, overall complex‐ ity can quickly become overwhelming. For example, adding retries in one component might overload a database and destabilize the whole system, or make it harder to rea‐ son about the path a given query follows through the system.\n\nFrequently, the cost of complexity does not directly affect the individual, team, or role that introduces it—in economic terms, complexity is an externality. Instead, complexity impacts those who continue to work in and around it. Thus, it is impor‐ tant to have a champion for end-to-end system simplicity.\n\nSREs are a natural fit for this role because their work requires them to treat the sys‐ tem as a whole.3 In addition to supporting their own services, SREs must also have insight into the systems their service interacts with. Google’s product development teams often don’t have visibility on production-wide issues, so they find it valuable to consult SREs for advice on the design and operation of their systems.\n\nReader action: Before an engineer goes on-call for the first time, encourage them to draw (and redraw) system diagrams. Keep a canonical set of diagrams in your documentation: they’re useful to new engineers and help more experienced engineers keep up with changes.\n\nIn our experience, product developers usually end up working in a narrow subsystem or component. As a result, they don’t have a mental model for the overall system, and their teams don’t create system-level architecture diagrams. These diagrams are use‐ ful because they help team members visualize system interactions and articulate issues using a common vocabulary. More often than not, we find the SRE team for the service draws the system-level architecture diagrams.\n\nReader action: Ensure that an SRE reviews all major design docs, and that the team documents show how the new design affects the system architecture. If a design adds complexity, the SRE might be able to suggest alternatives that simplify the system.\n\n3 As a result, SRE may be a useful investment for product development leads who wish to attack complexity as\n\na proxy for technical debt, but find it hard to justify that work within the scope of their existing team.\n\nSimplicity Is End-to-End, and SREs Are Good for That\n\n|\n\n133\n\nCase Study 1: End-to-End API Simplicity\n\nBackground\n\nIn a previous role, one of the chapter authors worked at a startup that used a key/ value bag data structure in its core libraries. RPCs (remote procedure calls) took a bag and returned a bag; actual parameters were stored as key/value pairs inside the bag. The core libraries supported common operations on bags, such as serialization, encryption, and logging. All of the core libraries and APIs were extremely simple and flexible—success, right?\n\nSadly, no: the clients of the libraries ended up paying a penalty for the abstract nature of the core APIs. The set of keys and values (and value types) needed to be carefully documented for each service, but usually weren’t. In addition, maintaining back‐ ward/forward compatibility became difficult as parameters were added, removed, or changed over time.\n\nLessons learned\n\nStructured data types like Google’s Protocol Buffers or Apache Thrift might seem more complex than their abstract general-purpose alternatives, but they result in sim‐ pler end-to-end solutions because they force upfront design decisions and documen‐ tation.\n\nCase Study 2: Project Lifecycle Complexity When you review the tangled spaghetti of your existing system, it might be tempting to replace it wholesale with a new, clean, simple system that solves the same problem. Unfortunately, the cost of creating a new system while maintaining the current one might not be worthwhile.\n\nBackground\n\nBorg is Google’s internal container management system. It runs huge numbers of Linux containers and has a wide variety of usage patterns: batch versus production, pipelines versus servers, and more. Over the years, Borg and its surrounding ecosys‐ tem grew as hardware changed, features were added, and its scale increased.\n\nOmega was intended to be a more principled, cleaner version of Borg that supported the same use cases. However, the planned switch from Borg to Omega had a few seri‐ ous problems:\n\n134\n\n|\n\nChapter 7: Simplicity\n\nBorg continued to evolve as Omega was developed, so Omega was always chasing a moving target.\n\nEarly estimates of the difficulty of improving Borg proved overly pessimistic, while the expectations for Omega proved overly optimistic (in practice, the grass isn’t always greener).\n\nWe didn’t fully appreciate how difficult it would be to migrate from Borg to Omega. Millions of lines of configuration code across thousands of services and many SRE teams meant that the migration would be extremely costly in terms of engineering and calendar time. During the migration period, which would likely take years, we’d have to support and maintain both systems.\n\nWhat we decided to do\n\nEventually, we fed some of the ideas that emerged while designing Omega back into Borg. We also used many of Omega’s concepts to jump-start Kubernetes, an open source container management system.\n\nLessons learned\n\nWhen considering a rewrite, think about the full project lifecycle, including develop‐ ment toward a moving target, a full migration plan, and extra costs you might incur during the migration time window. Wide APIs with lots of users are very hard to migrate. Don’t compare the expected result to your current system. Instead, compare the expected result to what your current system would look like if you invested the same effort in improving it. Sometimes a rewrite is the best way forward, but make sure you’ve weighed the costs and benefits and that you don’t underestimate the costs.\n\nRegaining Simplicity Most simplification work consists of removing elements from a system. Sometimes simplification is direct (e.g., removing a dependency on an unused piece of data fetched from a remote system). Other times, simplification requires redesign. For example, two parts of a system might need access to the same remote data. Rather than fetch it twice, a simpler system might fetch the data once and forward the result.\n\nWhatever the work, leadership must ensure that simplification efforts are celebrated and explicitly prioritized. Simplification is efficiency—instead of saving compute or network resources, it saves engineering time and cognitive load. Treat successful sim‐ plification projects just as you treat useful feature launches, and measure and cele‐\n\nRegaining Simplicity\n\n|\n\n135\n\nbrate code addition and removal equally.4 For example, Google’s intranet displays a “Zombie Code Slayer” badge for engineers that delete significant amounts of code.\n\nSimplification is a feature. You need to prioritize and staff simplification projects and reserve time for SREs to work on them. If product developers and SREs do not see simplification projects as beneficial to their careers, they won’t undertake these projects. Consider making simplicity an explicit goal for particularly complex sys‐ tems or overloaded teams. Create a separate bucket of time to do this work. For example, reserve 10% of engineering project time for “simplicity” projects.5\n\nReader action: Have engineers brainstorm known complexities in the system and discuss ideas to reduce them.\n\nAs a system grows in complexity, there is a temptation to split SRE teams, focusing each new team on smaller parts of the system. While this is sometimes necessary, the reduced scope of the new teams might lessen their motivation or ability to drive larger simplification projects. Consider designating a small rotating group of SREs who maintain working knowledge of the entire stack (likely with less depth), and can push for conformity and simplification across it.\n\nAs previously mentioned, the act of diagramming your system can help you identify deeper design problems that hinder your ability to understand the system and predict its behavior. For example, when diagramming your system, you might look for the following:\n\nAmplification\n\nWhen a call returns an error or times out and is retried on several levels, it causes the total number of RPCs to multiply.\n\nCyclic dependencies\n\nWhen a component depends on itself (often indirectly), system integrity can be gravely compromised—in particular, a cold start of the whole system might become impossible.\n\n4 As Dijkstra said, “If we wish to count lines of code, we should not regard them as ‘lines produced’ but as ‘lines\n\nspent.’”\n\n5 Reserving some portion of time for simplicity projects (10%, for example) doesn’t mean the team has a green light to introduce complexity with the other 90%. It just means you are setting aside some effort with the specific goal of simplification.\n\n136\n\n|\n\nChapter 7: Simplicity\n\nCase Study 3: Simplification of the Display Ads Spiderweb\n\nBackground\n\nGoogle’s Display Ads business has many related products, including some that origi‐ nated from acquisitions (DoubleClick, AdMob, Invite Media, etc.). These products had to be adapted to work with Google infrastructure and existing products. For example, we wanted a website using DoubleClick for Publishers to be able to show ads chosen by Google’s AdSense; similarly, we wanted bidders using DoubleClick Bid Manager to have access to the real-time auctions run on Google’s Ad Exchange.\n\nThese independently developed products formed a system of interconnected back‐ ends that was difficult to reason about. Observing what happened to traffic as it passed through components was difficult, and provisioning the right amount of capacity for each piece was inconvenient and imprecise. At one point, we added tests to make sure we had removed all infinite loops in the query flow.\n\nWhat we decided to do\n\nAds serving SREs were the natural drivers for standardization: while each component had a specific developer team, SREs were on-call for the entire stack. One of our first undertakings was to draft uniformity standards and work with developer teams to incrementally adopt them. These standards:\n\nEstablished a single way to copy large data sets\n\nEstablished a single way to perform external data lookups\n\nProvided common templates for monitoring, provisioning, and configuration\n\nBefore this initiative, separate programs provided frontend and auction functionality for each product. As shown in Figure 7-1, when an ad request might hit two targeting systems, we rewrote the request to meet the expectations of the second system. This required additional code and processing, and it also opened the possibility of unde‐ sirable loops.\n\nRegaining Simplicity\n\n|\n\n137\n\nFigure 7-1. Previously, an ad request might hit both the AdMob and AdSense systems\n\nTo simplify the system, we added logic to common programs that satisfied all of our use cases, along with flags to guard the programs. Over time, we removed the flags and consolidated the functionality into fewer server backends.\n\nOnce the servers were unified, the auction server could talk to both targeting servers directly. As shown in Figure 7-2, when multiple targeting servers needed data look‐ ups, the lookup needed to happen only once in the unified auction server.\n\nFigure 7-2. The unified auction server now performs a data lookup only once\n\n138\n\n|\n\nChapter 7: Simplicity",
      "page_number": 156
    },
    {
      "number": 19,
      "title": "Segment 19 (pages 165-174)",
      "start_page": 165,
      "end_page": 174,
      "detection_method": "topic_boundary",
      "content": "Lessons learned\n\nIt’s best to integrate an already running system into your own infrastructure incre‐ mentally.\n\nJust as the presence of very similar functions in a single program represents a “code smell” that indicates deeper design problems, redundant lookups in a single request represent a “system smell.”\n\nWhen you create well-defined standards with buy-in from SRE and developers, you can provide a clear blueprint for removing complexity that managers are more likely to endorse and reward.\n\nCase Study 4: Running Hundreds of Microservices on a Shared Platform by Mike Curtis\n\nBackground\n\nOver the past 15 years, Google has developed multiple successful product verticals (Search, Ads, and Gmail, to name a few) and produced a steady stream of new and refactored systems. Many of these systems have a dedicated SRE team and a corre‐ sponding domain-specific production stack that includes a bespoke development workflow, continuous integration and continuous delivery (CI/CD) software cycles, and monitoring. These unique production stacks incur significant overhead in terms of maintenance, development costs, and independent SRE engagement. They also make it harder to move services (or engineers!) between teams, or to add new serv‐ ices.\n\nWhat we decided to do\n\nA set of SRE teams in the social networking space worked to converge the production stacks for their services into a single managed microservices platform, managed by a single group of SREs. The shared platform is compliant with best practices, and it bundles and automatically configures many previously underused features that improve reliability and facilitate debugging. Regardless of their SRE engagement level, new services within the scope of the SRE team were required to use the com‐ mon platform, and legacy services had to either migrate to the new platform or be phased out.\n\nAfter its success in the social network space, the shared platform is gaining adoption with other SRE and non-SRE teams across Google.\n\nRegaining Simplicity\n\n|\n\n139\n\nDesign\n\nWe used microservices so we could quickly update and deploy features—a single monolithic service changes slowly. Services are managed, not hosted: rather than removing control and responsibility from individual teams, we empower them to manage their services effectively themselves. We provide workflow tools that service teams can use to release, monitor, and more.\n\nThe tools we provide include a UI, API, and a command-line interface that SREs and developers use to interact with their stack. The tools make the developer experience feel unified, even when it involves many underlying systems.\n\nOutcomes\n\nThe platform’s high quality and feature set had an unexpected benefit: developer teams can run hundreds of services without any deep SRE engagement.\n\nThe common platform also changed the SRE-developer relationship. As a result, tiered SRE engagement is becoming common at Google. Tiered engagement includes a spectrum of SRE involvement, ranging from light consulting and design reviews to deep engagement (i.e., SREs share on-call duties).\n\nLessons learned\n\nShifting from sparse or ill-defined standards to a highly standardized platform is a long-term investment. Each step might feel incremental, but ultimately, these steps reduce overhead and make running services at scale possible.\n\nIt’s important that developers see the value in such a transition. Aim for incremental productivity wins that are unlocked at each stage of development. Don’t try to con‐ vince people to perform a huge refactor that pays off only at the very end.\n\nCase Study 5: pDNS No Longer Depends on Itself\n\nBackground\n\nWhen a client in Google production wants to look up the IP address for a service, it often uses a lookup service called Svelte. In the past, to find the IP address for Svelte, the client used a Google naming service called pDNS (Production DNS). The pDNS service is accessed through a load balancer, which looks up the IP addresses for the actual pDNS servers…using Svelte.\n\nProblem statement\n\npDNS had a transitive dependency on itself, which was unintentionally introduced at some point and only later identified as a reliability concern. Lookups normally didn’t run into issues because the pDNS service is replicated, and the data needed to break\n\n140\n\n|\n\nChapter 7: Simplicity\n\nout of the dependency loop was always available somewhere in Google production. However, a cold start would have been impossible. In the words of one SRE, “We were like cave dwellers who could only light fires by running with a torch lit from the last campfire.”\n\nWhat we decided to do\n\nWe modified a low-level component in Google production to maintain a list of cur‐ rent IP addresses for nearby Svelte servers in local storage for all Google production machines. In addition to breaking the circular dependency described earlier, this change also eliminated an implicit dependency on pDNS for most other Google serv‐ ices.\n\nTo avoid similar issues, we also introduced a method for whitelisting the set of serv‐ ices allowed to communicate with pDNS, and slowly worked to reduce that set. As a result, each service lookup in production now has a simpler and more reliable path through the system.\n\nLessons learned\n\nBe careful about your service’s dependencies—use an explicit whitelist to prevent accidental additions. Also, be on the lookout for circular dependencies.\n\nConclusion Simplicity is a natural goal for SREs because simple systems tend to be reliable and easy to run. It’s not easy to quantitatively measure simplicity (or its inverse, complex‐ ity) for distributed systems, but there are reasonable proxies, and it’s worth picking some and working to improve them.\n\nBecause of their end-to-end understanding of a system, SREs are in an excellent posi‐ tion to identify, prevent, and fix sources of complexity, whether they are found in software design, system architecture, configuration, deployment processes, or else‐ where. SREs should be involved in design discussions early on to provide their unique perspective about the costs and benefits of alternatives, with a particular eye toward simplicity. SREs can also proactively develop standards to homogenize pro‐ duction.\n\nAs an SRE, pushing for simplicity is an important part of your job description. We strongly recommend that SRE leadership empower SRE teams to push for simplicity, and to explicitly reward these efforts. Systems inevitably creep toward complexity as they evolve, so the fight for simplicity requires continuous attention and commit‐ ment—but it is very much worth pursuing.\n\nConclusion\n\n|\n\n141\n\nPART II Practices\n\nBuilding upon the solid foundation of SRE principles covered in Part I, Part II dives deep into how to conduct SRE-related activities that Google has found important for operating at scale.\n\nSome of these topics, such as data processing pipelines and managing load, won’t apply to all organizations. Other topics, such as safely handling changes with configu‐ ration and canarying, on-call practices, and what to do when things go wrong, con‐ tain valuable lessons for any SRE team.\n\nThis part also introduces an important SRE skill—Non-Abstract Large System Design (NALSD)—and presents a detailed example of how to practice this design process.\n\nAs we move from SRE foundations to practices, we wanted to provide a bit more context on the relationship between operational duties and project work, and the engineering it takes to accomplish both strategically.\n\nDefining Operational Work (Versus Project Work and Overhead) Before we move from foundations to practices, we wanted to touch on the difference between operational and project work, and how these two types of work inform each other. The topic is an area of philosophical debate in the SRE community, so this interlude presents how we define the two types of work in the context of this book.\n\nSRE practices apply software engineering solutions to operational problems. Because our SRE teams are responsible for the day-to-day functioning of the systems we sup‐ port, our engineering work often focuses on tasks that might be operations elsewhere: we automate release processes instead of performing them manually; we implement sharding to make our services more reliable and less demanding of human attention; we utilize algorithmic approaches to capacity planning so that engineers don’t have to perform error-prone manual calculations.\n\nWhile engineering and operational work do inform each other, we can conceptualize the work any given SRE team performs as two separate categories, as shown in Figure II-1. Over the years, we’ve worked toward ways to maximize the efficiency and scalability of each bucket of work.\n\nFigure II-1. The two categories of SRE work\n\nWe can break down operational work into four general categories:\n\nOn-call work\n\nCustomer requests (most commonly, tickets)\n\nIncident response\n\nPostmortems\n\nEach of these categories receives its own detailed treatment in both our first book (Chapter 11; Chapter 14; Chapter 15) and this one (Chapter 6; Chapter 8; Chapter 9; Chapter 10). Here, we show how all four are interconnected, and why it’s important to consider these types of work as closely related.\n\nWhat types of work are not included in operational work? As shown in Figure II-1, project work is the other main bucket of SRE work. When a team’s interrupt work is well managed, they have time for longer-term engineering work to achieve stability, reliability, and availability goals. This might include software engineering projects aimed at improving the reliability of a service, or systems engineering projects like safely rolling out a new feature to a globally replicated service.\n\nAlso shown in Figure II-1, overhead is the administrivia necessary to working at a company: meetings, training, responding to emails, tracking your accomplishments, filling out paperwork, and so on. Overhead isn’t immediately important to the discus‐ sion at hand, but all team members spend time on it.\n\nYou might notice that we don’t specifically call out documentation as a separate activity. This is because we believe that healthy documentation procedures embed themselves into all of your work. You don’t need to think about documenting code, playbooks, and service features—or even making sure that tickets and bugs contain all of the information they should—as separate from your project or operational tasks. It’s simply another facet of those tasks.\n\nAt Google, we specify that SREs should spend at least 50% of their time on project work; anything less makes for unsustainable engineering and burned-out, unhealthy teams. While every team and organization needs to find its own healthy balance, we’ve found that about one-third of time spent on operational tasks and two-thirds of time spent on project work is just about right (this ratio also informs an ideal on-call rotation size, where your engineers are only on-call one-third of the time).\n\nWe encourage teams to conduct periodic reviews to track whether you’re striking the appropriate balance between types of work. At Google, we conduct regular Produc‐ tion Excellence (ProdEx) Reviews, which allow senior SRE leadership a view into the state of every SRE team using a clearly defined rubric. You’ll need to determine the appropriate time intervals and rubric according to your own constraints and organi‐ zational maturity, but the key here is to generate metrics about team health that you can track over time.\n\nRemember one caveat when finding your ideal balance: a team that spends too little of its time on operational tasks risks operational underload. In this situation, engi‐ neers might start to forget crucial aspects of the service they are responsible for. You can counter operational underload by taking more risks and moving faster—for example, shorten your release cycles, push more features per release, or perform more disaster recovery testing. If your team is perpetually underloaded, consider onboard‐ ing related services or handing back a service that no longer needs SRE support to the development team (for more discussion of team size, see Chapter 8).\n\nThe Relationship Between Operational Work and Project Work\n\nWhile they are different classes of work, operational and project work aren’t entirely separate concerns. In fact, the issues raised in the former should feed into the latter: SRE project work should be strategic initiatives that make the system more efficient, scalable, and reliable, and/or that reduce operational load and toil. As shown in Figure II-1, there should be a continuous feedback loop between the sources of opera‐ tional load and the project work that systematically improves production. This longer-term work might involve moving to more robust storage systems, redesigning frameworks to reduce brittleness or maintenance load, or addressing systemic sources of outages and incidents. These initiatives are developed and implemented via projects, defined as temporary endeavors (with a clear beginning and end) that deliver a specified objective or deliverable.\n\nCHAPTER 8 On-Call\n\nBy Ollie Cook, Sara Smollett, Andrea Spadaccini, Cara Donnelly, Jian Ma, and Garrett Plasky (Evernote) with Stephen Thorne and Jessie Yang\n\nBeing on-call means being available during a set period of time, and being ready to respond to production incidents during that time with appropriate urgency. Site Reli‐ ability Engineers (SREs) are often required to take part in on-call rotations. During on-call shifts, SREs diagnose, mitigate, fix, or escalate incidents as needed. In addi‐ tion, SREs are regularly responsible for nonurgent production duties.\n\nAt Google, being on-call is one of the defining characteristics of SRE. SRE teams miti‐ gate incidents, repair production problems, and automate operational tasks. Since most of our SRE teams have not yet fully automated all their operational tasks, escala‐ tions need human points of contact—on-call engineers. Depending on how critical the supported systems are, or the state of development the systems are in, not all SRE teams may need to be on-call. In our experience, most SRE teams staff on-call shifts.\n\nOn-call is a large and complex topic, saddled with many constraints and a limited margin for trial and error. Chapter 11 of our first book (Site Reliability Engineering), “Being On-Call,” already explored this topic. This chapter addresses specific feedback and questions we received about that chapter. These include the following:\n\n“We are not Google; we’re much smaller. We don’t have as many people in the rotation, and we don’t have sites in different time zones. What you described in your first book is irrelevant to me.”\n\n“We have a mixture of developers and DevOps for on-call rotation. What’s the best way to organize them? Split the responsibilities?”\n\n147\n\n“Our on-call engineer gets paged about a hundred times in a typical 24-hour shift. A lot of pages get ignored, while the real problems are buried under the pile. Where should we start?”\n\n“We have a high turnover rate for on-call rotations. How do you address the knowledge gap within the team?”\n\n“We want to reorg our DevOps team into SRE.1 What’s the difference between SRE on-call, DevOps on-call, and developers on-call? Please be specific, because the DevOps team is very concerned about this.”\n\nWe offer practical advice for these situations. Google is a large company with a mature SRE organization, but much of what we’ve learned over the years can be applied to any company or organization, regardless of size or maturity. Google has hundreds of on-call rotations across services of all sizes, and various on-call setups from simple to complicated. On-call is not exclusively an SRE function: many devel‐ oper teams are directly on-call for their service. Each on-call setup meets the need of a particular service.\n\nThis chapter describes on-call setups both within Google and outside of Google. While your setup and situation will likely differ from our specific examples, the essential concepts we cover are widely applicable.\n\nWe then delve into the anatomy of pager load, explaining what causes pager load. We suggest strategies to optimize on-call setup and minimize that load.\n\nFinally, we share two examples of practices inside Google: on-call flexibility and on- call team dynamics. These practices show that no matter how mathematically sound an on-call setup is, you cannot solely rely on logistics of the on-call setup. Incentives and human nature play an important role, and should also be taken into account.\n\nRecap of “Being On-Call” Chapter of First SRE Book Site Reliability Engineering, in “Being On-Call”, explains the principles behind on-call rotations at Google. This section discusses the main points of that chapter.\n\nAt Google, the overall goal of being on-call is to provide coverage for critical services, while making sure that we never achieve reliability at the expense of an on-call engi‐ neer’s health. As a result, SRE teams strive for balance. SRE work should be a healthy mix of duties: on-call and project work. Specifying that SREs spend at least 50% of their time on project work means that teams have time to tackle the projects required\n\n1 Note that this example is often a red flag situation for organizations that aren’t actually practicing DevOps, in\n\nwhich case, a name change won’t fix more structural problems.\n\n148\n\n|\n\nChapter 8: On-Call\n\nto strategically address any problems found in production. Team staffing must be adequate to ensure time for project work.\n\nWe target a maximum of two incidents per on-call shift,2 to ensure adequate time for follow-up. If the pager load gets too high, corrective action is warranted. (We explore pager load later in this chapter.)\n\nPsychological safety3 is vital for effective on-call rotations. Since being on-call can be daunting and highly stressful, on-call engineers should be fully supported by a series of procedures and escalation paths to make their lives easier.\n\nOn-call usually implies some amount of out-of-hours work. We believe this work should be compensated. While different companies may choose to handle this in dif‐ ferent ways, Google offers time-off-in-lieu or cash compensation, capped at some proportion of the overall salary. The compensation scheme provides an incentive for being part of on-call, and ensures that engineers do not take on too many on-call shifts for economic reasons.\n\nExample On-Call Setups Within Google and Outside Google This section describes real-world examples of on-call setups at Google and Evernote, a California company that develops a cross-platform app that helps individuals and teams create, assemble, and share information. For each company, we explore the reasoning behind on-call setups, general on-call philosophy, and on-call practices.\n\nGoogle: Forming a New Team\n\nInitial scenario\n\nA few years ago, Sara, an SRE at Google Mountain View, started a new SRE team that needed to be on-call within three months. To put this in perspective, most SRE teams at Google do not expect new hires to be ready for on-call before three to nine months. The new Mountain View SRE team would support three Google Apps serv‐ ices that were previously supported by an SRE team in Kirkland, Washington (a two- hour flight from Mountain View). The Kirkland team had a sister SRE team in London, which would continue to support these services alongside the new Moun‐ tain View SRE team, and distributed product development teams.4\n\n2 One “incident” is defined as one “problem,” no matter how many alerts have been fired for the same “prob‐\n\nlem.” One shift is 12 hours.\n\n3 There is more on this topic in Seeking SRE by David Blank-Edelman (O’Reilly).\n\n4 SRE teams at Google are paired across time zones for service continuity.\n\nExample On-Call Setups Within Google and Outside Google\n\n|\n\n149",
      "page_number": 165
    },
    {
      "number": 20,
      "title": "Segment 20 (pages 175-184)",
      "start_page": 175,
      "end_page": 184,
      "detection_method": "topic_boundary",
      "content": "The new Mountain View SRE team came together quickly, assembling seven people:\n\nSara, an SRE tech lead\n\nMike, an experienced SRE from another SRE team\n\nA transfer from a product development team who was new to SRE\n\nFour new hires (“Nooglers”)\n\nEven when a team is mature, going on-call for new services is always challenging, and the new Mountain View SRE team was a relatively junior team. Nonetheless, the new team was able to onboard the services without sacrificing service quality or project velocity. They made immediate improvements to the services, including lowering machine costs by 40%, and fully automating release rollouts with canarying and other safety checks. The new team also continued to deliver reliable services, targeting 99.98% availability, or roughly 26 minutes of downtime per quarter.\n\nHow did the new SRE team bootstrap themselves to accomplish so much? Through starter projects, mentoring, and training.\n\nTraining roadmap\n\nAlthough the new SRE team didn’t know much about their services, Sara and Mike were familiar with Google’s production environment and SRE. As the four Nooglers completed company orientation, Sara and Mike compiled a checklist of two dozen focus areas for people to practice before going on-call, such as:\n\nAdministering production jobs\n\nUnderstanding debugging info\n\n“Draining” traffic away from a cluster\n\nRolling back a bad software push\n\nBlocking or rate-limiting unwanted traffic\n\nBringing up additional serving capacity\n\nUsing the monitoring systems (for alerting and dashboards)\n\nDescribing the architecture, various components, and dependencies of the services\n\nThe Nooglers found some of this information on their own by researching existing documentation and codelabs (guided, hands-on coding tutorials) and gained under‐ standing on relevant topics by working on their starter projects. When a team mem‐ ber learned about specific topics relevant to the Nooglers’ starter projects, that person led a short, impromptu session to share that information with the rest of the team. Sara and Mike covered the remaining topics. The team also held lab sessions to\n\n150\n\n|\n\nChapter 8: On-Call\n\nperform common debugging and mitigation tasks to help everyone build muscle memory and gain confidence in their abilities.\n\nIn addition to the checklist, the new SRE team ran a series of “deep dives” to dig into their services. The team browsed monitoring consoles, identified running jobs, and tried debugging recent pages. Sara and Mike explained that an engineer didn’t need years of expertise with each of the services to become reasonably proficient. They coached the team to explore a service from first principles, and encouraged Nooglers to become familiar with the services. They were open about the limits of their knowl‐ edge, and taught others when to ask for help.\n\nThroughout the ramp-up, the new SRE team wasn’t alone. Sara and Mike traveled to meet the other SRE teams and product developers and learn from them. The new SRE team met with the Kirkland and London teams by holding video conferences, exchanging email, and chatting over IRC. In addition, the team attended weekly pro‐ duction meetings, read daily on-call handoffs and postmortems, and browsed exist‐ ing service documentation. A Kirkland SRE visited to give talks and answer questions. A London SRE put together a thorough set of disaster scenarios and ran them during Google’s disaster recovery training week (see the section “Preparedness and Disaster Testing” in Site Reliability Engineering, Chapter 33).\n\nThe team also practiced being on-call through “Wheel of Misfortune” training exerci‐ ses (see the section “Disaster Role Playing” in Site Reliability Engineering, Chapter 28), where they role-played recent incidents to practice debugging production prob‐ lems. During these sessions, all SREs were encouraged to offer suggestions on how to resolve mock production failures. After everyone ramped up, the team still held these sessions, rotating through each team member as the session leader. The team recor‐ ded these for future reference.\n\nBefore going on-call, the team reviewed precise guidelines about the responsibilities of on-call engineers. For example:\n\nAt the start of each shift, the on-call engineer reads the handoff from the previ‐ ous shift.\n\nThe on-call engineer minimizes user impact first, then makes sure the issues are fully addressed.\n\nAt the end of the shift, the on-call engineer sends a handoff email to the next engineer on-call.\n\nThe guidelines also specified when to escalate to others, and how to write postmor‐ tems for large incidents.\n\nFinally, the team read and updated on-call playbooks. Playbooks contain high-level instructions on how to respond to automated alerts. They explain the severity and impact of the alert, and include debugging suggestions and possible actions to take to\n\nExample On-Call Setups Within Google and Outside Google\n\n|\n\n151\n\nmitigate impact and fully resolve the alert. In SRE, whenever an alert is created, a cor‐ responding playbook entry is usually created. These guides reduce stress, the mean time to repair (MTTR), and the risk of human error.\n\nMaintaining Playbooks Details in playbooks go out of date at the same rate as production environment changes. For daily releases, playbooks might need an update on any given day. Writ‐ ing good documentation, like any form of communication, is hard. So how do you maintain playbooks?\n\nSome SREs at Google advocate keeping playbook entries general so they change slowly. For example, they may have just one entry for all “RPC Errors High” alerts, for a trained on-call engineer to read, in conjunction with an architecture diagram for the currently alerting service. Other SREs advocate for step-by-step playbooks to reduce human variability and drive down MTTR. If your team has conflicting views about playbook content, the playbooks might get pulled in many directions.\n\nThis is a contentious topic. If you agree on nothing else, at least decide with your team what minimal, structured details your playbooks must have, and try to notice when your playbooks have accumulated a lot of information beyond these structured details. Pencil in a project to turn new, hard-won, production knowledge into auto‐ mation or monitoring consoles. If your playbooks are a deterministic list of com‐ mands that the on-call engineer runs every time a particular alert fires, we recommend implementing automation.\n\nAfter two months, Sara, Mike, and the SRE transfer shadowed the on-call shifts of the outgoing Kirkland SRE team. At three months, they became the primary on-call, with the Kirkland SREs as backup. That way, they could easily escalate to the Kirkland SREs if needed. Next, the Nooglers shadowed the more experienced, local SREs and joined the rotation.\n\nGood documentation and the various strategies discussed earlier all helped the team form a solid foundation and ramp up quickly. Although on-call can be stressful, the teams’ confidence grew enough to take action without second-guessing themselves. There was psychological safety in knowing that their responses were based on the team’s collective knowledge, and that even when they escalated, the on-call engineers were still regarded as competent engineers.\n\nAfterword\n\nWhile the Mountain View SREs were ramping up, they learned that their experi‐ enced, sister SRE team in London would be moving on to a new project, and a new team was being formed in Zürich to support the services previously supported by the\n\n152\n\n|\n\nChapter 8: On-Call\n\nLondon SRE team. For this second transition, the same basic approach the Mountain View SREs used proved successful. The previous investment by Mountain View SREs in developing onboarding and training materials helped the new Zürich SRE team ramp up.\n\nWhile the approach used by the Mountain View SREs made sense when a cohort of SREs were becoming a team, they needed a more lightweight approach when only one person joined the team at a given time. In anticipation of future turnover, the SREs created service architecture diagrams and formalized the basic training check‐ list into a series of exercises that could be completed semi-independently with mini‐ mal involvement from a mentor. These exercises included describing the storage layer, performing capacity increases, and reviewing how HTTP requests are routed.\n\nEvernote: Finding Our Feet in the Cloud\n\nMoving our on-prem infrastructure to the cloud\n\nWe didn’t set out to reengineer our on-call process, but as with many things in life, necessity is the mother of invention. Prior to December 2016, Evernote ran only on on-prem datacenters, built to support our monolithic application. Our network and servers were designed with a specific architecture and data flow in mind. This, com‐ bined with a host of other constraints, meant we lacked the flexibility needed to sup‐ port a horizontal architecture. Google Cloud Platform (GCP) provided a concrete solution to our problem. However, we still had one major hurdle to surmount: migrating all our production and supporting infrastructure to GCP. Fast-forward 70 days. Through a Herculean effort and many remarkable feats (for example, moving thousands of servers and 3.5 PB of data), we were happily settled in our new home. At this point, though, our job still wasn’t done: how were we going to monitor, alert, and—most importantly—respond to issues in our new environment?\n\nAdjusting our on-call policies and processes\n\nThe move to the cloud unleashed the potential for our infrastructure to grow rapidly, but our on-call policies and processes were not yet set up to handle such growth. Once the migration wrapped up, we set out to remedy the problem. In our previous physical datacenter, we built redundancy into nearly every component. This meant that while component failure was common given our size, generally no individual component was capable of negatively impacting users. The infrastructure was very stable because we controlled it—any small bump would inevitably be due to a failure somewhere in the system. Our alerting policies were structured with that in mind: a few dropped packets, resulting in a JDBC (Java Database Connectivity) connection exception, invariably meant that a VM (virtual machine) host was on the verge of failing, or that the control plane on one of our switches was on the fritz. Even before our first day in the cloud, we realized that this type of alert/response system was not\n\nExample On-Call Setups Within Google and Outside Google\n\n|\n\n153\n\ntenable going forward. In a world of live migrations and network latency, we needed to take a much more holistic approach to monitoring.\n\nReframing paging events in terms of first principles, and writing these principles down as our explicit SLOs (service level objectives), helped give the team clarity regarding what was important to alert on and allowed us to trim the fat from our monitoring infrastructure. Our focus on higher-level indicators such as API respon‐ siveness, rather than lower-level infrastructure such as InnoDB row lock waits in MySQL, meant we could focus more time on the real pain our users experience dur‐ ing an outage. For our team, this meant less time spent chasing transient problems. This translated into more sleep, effectiveness, and ultimately, job satisfaction.\n\nRestructuring our monitoring and metrics\n\nOur primary on-call rotation is staffed by a small but scrappy team of engineers who are responsible for our production infrastructure and a handful of other business sys‐ tems (for example, staging and build pipeline infrastructure). We have a weekly, 24/7 schedule with a well-oiled handoff procedure, alongside a morning review of inci‐ dents at a daily stand-up. Our small team size and comparatively large scope of responsibility necessitates that we make every effort to keep the process burden light, and focus on closing the alert/triage/remediation/analysis loop as quickly as possible. One of the ways we achieve this is to keep our signal-to-noise ratio low by maintain‐ ing simple but effective alerting SLAs (service level agreements). We classify any event generated by our metrics or monitoring infrastructure into three categories:\n\nP1: Deal with immediately\n\nShould be immediately actionable\n\nPages the on-call\n\nLeads to event triage\n\nIs SLO-impacting\n\nP2: Deal with the next business day\n\nGenerally is not customer-facing, or is very limited in scope\n\nSends an email to team and notifies event stream channel\n\nP3: Event is informational only\n\nInformation is gathered in dashboards, passive email, and the like\n\nIncludes capacity planning–related information\n\n154\n\n|\n\nChapter 8: On-Call\n\nAny P1 or P2 event has an incident ticket attached to it. The ticket is used for obvious tasks like event triage and tracking remediation actions, as well as for SLO impact, number of occurrences, and postmortem doc links, where applicable.\n\nWhen an event pages (category P1), the on-call is tasked with assessing the impact to users. Incidents are triaged into severities from 1 to 3. For severity 1 (Sev 1) incidents, we maintain a finite set of criteria to make the escalation decision as straightforward as possible for the responder. Once the event is escalated, we assemble an incident team and begin our incident management process. The incident manager is paged, a scribe and communications lead is elected, and our communication channels open. After the incident is resolved, we conduct an automatic postmortem and share the results far and wide within the company. For events rating Sev 2 or Sev 3, the on-call responder handles the incident lifecycle, including an abbreviated postmortem for incident review.\n\nOne of the benefits of keeping our process lightweight is that we can explicitly free the on-call from any expectations of project work. This empowers and encourages the on-call to take immediate follow-up action, and also to identify any major gaps in tooling or process after completing the post-incident review. In this way, we achieve a constant cycle of improvement and flexibility during every on-call shift, keeping pace with the rapid rate of change in our environment. The goal is to make every on-call shift better than the last.\n\nTracking our performance over time\n\nWith the introduction of SLOs, we wanted to track performance over time, and share that information with stakeholders within the company. We implemented a monthly service review meeting, open to anyone who’s interested, to review and discuss the previous month of the service. We have also used this forum to review our on-call burden as a barometer of team health, and discuss remediation actions when we exceed our pager budget. This forum has the dual purpose of spreading the impor‐ tance of SLOs within the company and keeping the technical organization accounta‐ ble for maintaining the health and wellness of our service and team.\n\nEngaging with CRE\n\nExpressing our objectives in terms of SLOs provides a basis for engaging with Goo‐ gle’s Customer Reliability Engineering (CRE) team. After we discussed our SLOs with CRE to see if they were realistic and measurable, both teams decided CRE would be paged alongside our own engineers for SLO-impacting events. It can be difficult to pinpoint root causes that are hidden behind layers of cloud abstraction, so having a Googler at our side take the guesswork out of black-box event triaging was helpful. More importantly, this exercise further reduced our MTTR, which is ultimately what our users care about.\n\nExample On-Call Setups Within Google and Outside Google\n\n|\n\n155\n\nSustaining a self-perpetuating cycle\n\nRather than spending all our time in the triage/root-cause analysis/postmortem cycle, we now have more time as a team to think about how we move the business forward. Specifically, this translates into projects such as improving our microservices plat‐ form and establishing production readiness criteria for our product development teams. The latter includes many of the principles we followed in restructuring our on-call, which is particularly helpful for teams in their first “carry the pager” rodeo. Thus, we perpetuate the cycle of improving on-call for everyone.\n\nPractical Implementation Details So far, we’ve discussed details about on-call setups, both within Google and outside of Google. But what about specific considerations of being on-call? The following sections discuss these implementation details in more depth:\n\nPager load—what it is, how it works, and how to manage it\n\nHow to factor flexibility into on-call scheduling to create a healthier work/life balance for SREs\n\nStrategies for improving team dynamics, both within a given SRE team, and with partner teams\n\nAnatomy of Pager Load Your pager is noisy and it’s making your team unhappy. You’ve read through Chap‐ ter 31 in Site Reliability Engineering, and run regular production meetings, both with your team and the developer teams you support. Now everyone knows that your on- call engineers are unhappy. What next?\n\nPager load is the number of paging incidents that an on-call engineer receives over a typical shift length (such as per day or per week). An incident may involve more than one page. Here, we’ll walk through the impact of various factors on pager load, and suggest techniques for minimizing future pager load.\n\nAppropriate Response Times Engineers shouldn’t have to be at a computer and working on a problem within minutes of receiving a page unless there is a very good reason to do so. While a com‐ plete outage of a customer-facing, revenue-generating service typically requires an immediate response, you can deal with less severe issues (for example, failing back‐ ups) within a few hours.\n\n156\n\n|\n\nChapter 8: On-Call\n\nWe recommend checking your current paging setup to see if you actually should be paged for everything that currently triggers a page. You may be paging for issues that would be better served by automated repair (as it’s generally better for a computer to fix a problem than requiring a human to fix it) or a ticket (if it’s not actually high priority). Table 8-1 shows some sample events and appropriate responses.\n\nTable 8-1. Examples of realistic response times\n\nIncident description Revenue-impacting network outage\n\nCustomer order batch processing system stuck Backups of a database for a pre- launch service are failing\n\nResponse time 5 minutes\n\n30 minutes\n\nTicket (response during work hours)\n\nSRE impact SRE needs to be within arm’s reach of a charged and authenticated laptop with network access at all times; cannot travel; must heavily coordinate with secondary at all times SRE can leave their home for a quick errand or short commute; secondary does not need to provide coverage during this time None\n\nScenario: A team in overload\n\nThe (hypothetical) Connection SRE Team, responsible for frontend load balancing and terminating end-user connections, found itself in a position of high pager load. They had an established pager budget of two paging incidents per shift, but for the past year they had regularly been receiving five paging incidents per shift. Analysis revealed that fully one-third of shifts were exceeding their pager budget. Members of the team heroically responded to the daily onslaught of pages but couldn’t keep up; there simply was not enough time in the day to find the root cause and properly fix the incoming issues. Some engineers left the team to join less operationally burdened teams. High-quality incident follow-up was rare, since on-call engineers only had time to mitigate immediate problems.\n\nThe team’s horizon wasn’t entirely bleak: they had a mature monitoring infrastruc‐ ture that followed SRE best practices. Alerting thresholds were set to align with their SLO, and paging alerts were symptom-based in nature, meaning they fired only when customers were impacted. When senior management were approached with all of this information, they agreed that the team was in operational overload and reviewed the project plan to bring the team back to a healthy state.\n\nIn less positive news, over time the Connection team had taken ownership of soft‐ ware components from more than 10 developer teams and had hard dependencies on Google’s customer-facing edge and backbone networks. The large number of inter‐ group relationships was complex and had quietly grown difficult to manage.\n\nDespite the team following best practices in structuring their monitoring, many of the pages that they faced were outside their direct control. For example, a black-box probe may have failed due to congestion in the network, causing packet loss. The\n\nPractical Implementation Details\n\n|\n\n157\n\nonly action the team could take to mitigate congestion in the backbone was to esca‐ late to the team directly responsible for that network.\n\nOn top of their operational burden, the team needed to deliver new features to the frontend systems, which would be used by all Google services. To make matters worse, their infrastructure was being migrated from a 10-year-old legacy framework and cluster management system to a better-supported replacement. The team’s serv‐ ices were subject to an unprecedented rate of change, and the changes themselves caused a significant portion of the on-call load.\n\nThe team clearly needed to combat this excessive pager load using a variety of techni‐ ques. The technical program manager and the people manager of the team approached senior management with a project proposal, which senior management reviewed and approved. The team turned their full attention to reducing their pager load, and learned some valuable lessons along the way.\n\nPager load inputs\n\nThe first step in tackling high pager load is to determine what is causing it. Pager load is influenced by three main factors: bugs5 in production, alerting, and human pro‐ cesses. Each of these factors has several inputs, some of which we discuss in more detail in this section.\n\nFor production:\n\nThe number of existing bugs in production\n\nThe introduction of new bugs into production\n\nThe speed with which newly introduced bugs are identified\n\nThe speed with which bugs are mitigated and removed from production\n\nFor alerting:\n\nThe alerting thresholds that trigger a paging alert\n\nThe introduction of new paging alerts\n\nThe alignment of a service’s SLO with the SLOs of the services upon which it depends\n\n5 A “bug” in this context is any undesirable system behavior resulting from software or configuration error.\n\nLogic errors in code, incorrect configuration of a binary, incorrect capacity planning, misconfigured load bal‐ ancers, or newly discovered vulnerabilities are all valid examples of “production bugs” that contribute to pager load.\n\n158\n\n|\n\nChapter 8: On-Call\n\nFor human processes:\n\nThe rigor of fixes and follow-up on bugs\n\nThe quality of data collected about paging alerts\n\nThe attention paid to pager load trends\n\nHuman-actuated changes to production\n\nPreexisting bugs. No system is perfect. There will always be bugs in production: in your own code, the software and libraries that you build upon, or the interfaces between them. The bugs may not be causing paging alerts right now, but they are def‐ initely present. You can use a few techniques to identify or prevent bugs that haven’t yet caused paging alerts:\n\nEnsure systems are as complicated as they need to be, and no more (see Chap‐ ter 7).\n\nRegularly update the software or libraries that your system is built upon to take advantage of bug fixes (however, see the next section about new bugs).\n\nPerform regular destructive testing or fuzzing (for example, using Netflix’s Chaos Monkey).\n\nPerform regular load testing in addition to integration and unit testing.\n\nNew bugs. Ideally, the SRE team and its partner developer teams should detect new bugs before they even make it into production. In reality, automated testing misses many bugs, which are then launched to production.\n\nSoftware testing is a large topic well covered elsewhere (e.g., Martin Fowler on Test‐ ing). However, software testing techniques are particularly useful in reducing the number of bugs that reach production, and the amount of time they remain in pro‐ duction:\n\nImprove testing over time. In particular, for each bug you discover in produc‐ tion, ask “How could we have detected this bug preproduction?” Make sure the necessary engineering follow-up occurs (see “Rigor of follow-up” on page 164).\n\nDon’t ignore load testing, which is often treated as lower priority than functional testing. Many bugs manifest only under particular load conditions or with a par‐ ticular mix of requests.\n\nRun staging (testing with production-like but synthetic traffic) in a production- like environment. We briefly discuss generating synthetic traffic in Chapter 5 of this book.\n\nPerform canarying (Chapter 16) in a production environment.\n\nPractical Implementation Details\n\n|\n\n159",
      "page_number": 175
    },
    {
      "number": 21,
      "title": "Segment 21 (pages 185-193)",
      "start_page": 185,
      "end_page": 193,
      "detection_method": "topic_boundary",
      "content": "Have a low tolerance to new bugs. Follow a “detect, roll back, fix, and roll for‐ ward” strategy rather than a “detect, continue to roll forward despite identifying the bug, fix, and roll forward again” strategy. (See “Mitigation delay” on page 162 for more details.)\n\nThis kind of rollback strategy requires predictable and frequent releases so that the cost of rolling back any one release is small. We discuss this and related topics in Site Reliability Engineering, in “Release Engineering”.\n\nSome bugs may manifest only as the result of changing client behavior. For example:\n\nBugs that manifest only under specific levels of load—for example, September back-to-school traffic, Black Friday, Cyber Monday, or that week of the year when Daylight Saving Time means Europe and North America are one hour closer, meaning more of your users are awake and online simultaneously.\n\nBugs that manifest only with a particular mix of requests—for example, servers closer to Asia experiencing a more expensive traffic mix due to language encod‐ ings for Asian character sets.\n\nBugs that manifest only when users exercise the system in unexpected ways—for example, Calendar being used by an airline reservation system! Therefore, it is important to expand your testing regimen to test behaviors that do not occur every day.\n\nWhen a production system is plagued by several concurrent bugs, it’s much more dif‐ ficult to identify if a given page is for an existing or new bug. Minimizing the number of bugs in production not only reduces pager load, it also makes identifying and clas‐ sifying new bugs easier. Therefore, it is critical to remove production bugs from your systems as quickly as possible. Prioritize fixing existing bugs above delivering new features; if this requires cross-team collaboration, see Chapter 18.\n\nArchitectural or procedural problems, such as automated health checking, self- healing, and load shedding, may need significant engineering work to resolve. Remember, for simplicity’s sake we’ll consider these problems “bugs,” even if their size, their complexity, or the effort required to resolve them is significant.\n\nChapter 3 of Site Reliability Engineering describes how error budgets are a useful way to manage the rate at which new bugs are released to production. For example, when a service’s SLO violations exceed a certain fraction of its total quarterly error budget —typically agreed in advance between the developer and SRE teams—new feature development and feature-related rollouts can be halted temporarily to focus on stabi‐ lizing the system and reducing the frequency of pages.\n\nThe Connection team from our example adopted a strict policy requiring every out‐ age to have a tracking bug. This enabled the team’s technical program manager to\n\n160\n\n|\n\nChapter 8: On-Call\n\nexamine the root cause of their new bugs in aggregate. This data revealed that human error was the second most common cause of new bugs in production.\n\nBecause humans are error-prone, it’s better if all changes made to production systems are made by automation informed by (human-developed) intent configuration. Before you make a change to production, automation can perform additional testing that humans cannot. The Connection team was making complex changes to produc‐ tion semimanually. Not surprisingly, the team’s manual changes went wrong some‐ times; the team introduced new bugs, which caused pages. Automated systems making the same changes would have determined that the changes were not safe before they entered production and became paging events. The technical program manager took this data to the team and convinced them to prioritize automation projects.\n\nIdentification delay. It’s important to promptly identify the cause(s) of alerts because the longer it takes to identify the root cause of a page, the more opportunity it has to recur and page again. For example, given a page that manifests only under high load, say at daily peak, if the problematic code or configuration is not identified before the next daily peak, it is likely that the problem will happen again. There are several tech‐ niques you might use to reduce identification delays:\n\nUse good alerts and consoles\n\nEnsure pages link to relevant monitoring consoles, and that consoles highlight where the system is operating out of specification. In the console, correlate black- box and white-box paging alerts together, and do the same with their associated graphs. Make sure playbooks are up to date with advice on responding to each type of alert. On-call engineers should update the playbook with fresh informa‐ tion when the corresponding page fires.\n\nPractice emergency response\n\nRun “Wheel of Misfortune” exercises (described in Site Reliability Engineering) to share general and service-specific debugging techniques with your colleagues.\n\nPerform small releases\n\nIf you perform frequent, smaller releases instead of infrequent monolithic changes, correlating bugs with the corresponding change that introduced them is easier. Canarying releases, described in Chapter 16 gives a strong signal about whether a new bug is due to a new release.\n\nLog changes\n\nAggregating change information into a searchable timeline makes it simpler (and hopefully quicker) to correlate new bugs with the corresponding change that introduced them. Tools like the Slack plug-in for Jenkins can be helpful.\n\nPractical Implementation Details\n\n|\n\n161\n\nAsk for help\n\nIn Site Reliability Engineering, “Managing Incidents”, we talked about working together to manage large outages. The on-call engineer is never alone; encourage your team to feel safe when asking for help.\n\nMitigation delay. The longer it takes to mitigate a bug once it’s identified, the more opportunity it has to recur and page again. Consider these techniques for reducing mitigation delays:\n\nRoll back changes\n\nIf the bug was introduced in a recent code or configuration rollout, promptly remove the bug from production with a rollback, if safe and appropriate (a roll‐ back alone may be necessary but is not sufficient if the bug caused data corrup‐ tion, for example). Remember that even a “quick fix” needs time to be tested, built, and rolled out. Testing is vital to making sure the quick fix actually fixes the bug, and that it doesn’t introduce additional bugs or other unintended conse‐ quences. Generally, it is better to “roll back, fix, and roll forward” rather than “roll forward, fix, and roll forward again.”\n\nIf you aim for 99.99% availability, you have approximately 15 minutes of error budget per quarter. The build step of rolling forward may take much longer than 15 minutes, so rolling back impacts your users much less. (99.999% availability affords an error budget of 80 seconds per quarter. At this point, systems may need self-healing properties, which is out of scope for this chapter.)\n\nIf at all possible, avoid changes that can’t be rolled back, such as API- incompatible changes and lockstep releases.\n\nUse feature isolation\n\nDesign your system so that if feature X goes wrong, you can disable it via, for example, a feature flag without affecting feature Y. This strategy also improves release velocity, and makes disabling feature X a much simpler decision—you don’t need to check that your product managers are comfortable with also disa‐ bling feature Y.\n\nDrain requests away\n\nDrain requests (i.e., redirect customer requests) away from the elements of your system that exhibit the bug. For example, if the bug is the result of a code or con‐ fig rollout, and you roll out to production gradually, you may have the opportu‐ nity to drain the elements of your infrastructure that have received the update. This allows you to mitigate the customer impact in seconds, rather than rolling back, which may take minutes or longer.\n\n162\n\n|\n\nChapter 8: On-Call\n\nAlerting. Google SRE’s maximum of two distinct incidents per 12-hour shift encour‐ ages us to be thoughtful and cautious about how we configure paging alerts and how we introduce new ones. Site Reliability Engineering, “Monitoring Distributed Sys‐ tems”, describes Google’s approach to defining the thresholds for paging alerts. Strictly observing these guidelines is critical to maintaining a healthy on-call rotation.\n\nIt is worth highlighting some key elements discussed in that chapter:\n\nAll alerts should be immediately actionable. There should be an action we expect a human to take immediately after they receive the page that the system is unable to take itself. The signal-to-noise ratio should be high to ensure few false posi‐ tives; a low signal-to-noise ratio raises the risk for on-call engineers to develop alert fatigue.\n\nIf a team fully subscribes to SLO-based alerting, or paging only when error budget is burned (see the section “Black-Box Versus White-Box” in Site Reliabil‐ ity Engineering), it is critical that all teams involved in developing and maintain‐ ing the service agree about the importance of meeting the SLO and prioritize their work accordingly.\n\nIf a team fully subscribes to SLO-based and symptom-based alerting, relaxing alert thresholds is rarely an appropriate response to being paged.\n\nJust like new code, new alerts should be thoroughly and thoughtfully reviewed. Each alert should have a corresponding playbook entry.\n\nReceiving a page creates a negative psychological impact. To minimize that impact, only introduce new paging alerts when you really need them. Anyone on the team can write a new alert, but the whole team reviews proposed alert additions and can suggest alternatives. Thoroughly test new alerts in production to vet false positives before they are upgraded to paging alerts. For example, you might email the alert’s author when the alert fires, rather than paging the on-call engineer.\n\nNew alerts may find problems in production that you weren’t aware of. After you address these production bugs, alerting will only page on new bugs, effectively func‐ tioning like regression tests.\n\nBe sure to run the new alerts in test mode long enough to experience typical periodic production conditions, such as regular software rollouts, maintenance events by your Cloud provider, weekly load peaks, and so on. A week of testing is probably about right. However, this appropriate window depends on the alert and the system.\n\nFinally, use the alert’s trigger rate during the testing period to predict the expected consumption of your pager budget as a result of the new alert. Explicitly approve or disallow the new alert as a team. If introducing a new paging alert causes your service to exceed its paging budget, the stability of the system needs additional attention.\n\nPractical Implementation Details\n\n|\n\n163\n\nRigor of follow-up. Aim to identify the root cause of every page. “Root causes” extend out of the machine and into the team’s processes. Was an outage caused by a bug that would have been caught by a unit test? The root cause might not be a bug in the code, but rather a bug in the team’s processes around code review.\n\nIf you know the root cause, you can fix and prevent it from ever bothering you or your colleagues again. If your team cannot figure out the root cause, add monitoring and/or logging that will help you find the root cause of the page the next time it occurs. If you don’t have enough information to identify the bug, you can always do something to help debug the page further next time. You should rarely conclude that a page is triggered by “cause unknown.” Remember that as an on-call engineer, you are never alone, so ask a colleague to review your findings and see if there’s anything you missed. Typically, it’s easiest to find the root cause of an alert soon after the alert has triggered and fresh evidence is available.\n\nExplaining away a page as “transient,” or taking no action because the system “fixed itself” or the bug inexplicably “went away,” invites the bug to happen again and cause another page, which causes trouble for the next on-call engineer.\n\nSimply fixing the immediate bug (or making a “point” fix) misses a golden opportu‐ nity to prevent similar alerts in the future. Use the paging alert as an chance to sur‐ face engineering work that improves the system and obviates an entire class of possible future bugs. Do this by filing a project bug in your team’s production com‐ ponent, and advocate to prioritize its implementation by gathering data about how many individual bugs and pages this project would remove. If your proposal will take 3 working weeks or 120 working hours to implement, and a page costs on average 4 working hours to properly handle, there’s a clear break-even point after 30 pages.\n\nFor example, imagine a situation where there are too many servers on the same fail‐ ure domain, such as a switch in a datacenter, causing regular multiple simultaneous failures:\n\nPoint fix\n\nRebalance your current footprint across more failure domains and stop there.\n\nSystemic fix\n\nUse automation to ensure that this type of server, and all other similar servers, are always spread across sufficient failure domains, and that they rebalance auto‐ matically when necessary.\n\nMonitoring (or prevention) fix\n\nAlert preemptively when the failure domain diversity is below the expected level, but not yet service-impacting. Ideally, the alert would be a ticket alert, not a page, since it doesn’t require an immediate response. The system is still serving hap‐ pily, albeit at a lower level of redundancy.\n\n164\n\n|\n\nChapter 8: On-Call\n\nTo make sure you’re thorough in your follow-up to paging alerts, consider the fol‐ lowing questions:\n\nHow can I prevent this specific bug from happening again?\n\nHow can I prevent bugs like this from happening again, both for this system and other systems I’m responsible for?\n\nWhat tests could have prevented this bug from being released to production?\n\nWhat ticket alerts could have triggered action to prevent the bug from becoming critical before it paged?\n\nWhat informational alerts could have surfaced the bug on a console before it became critical?\n\nHave I maximized the impact of the fixes I’m making?\n\nOf course, it’s not enough for an on-call engineer to just file bugs related to the pages that occur on their shift. It’s incredibly important that bugs identified by the SRE team are dealt with swiftly, to reduce the possibility of them recurring. Make sure resource planning for both the SRE and developer teams consider the effort required to respond to bugs.\n\nWe recommend reserving a fraction of SRE and developer team time for responding to production bugs as they arise. For example, a Google on-caller typically doesn’t work on projects during their on-call shift. Instead, they work on bugs that improve the health of the system. Make sure that your team routinely prioritizes production bugs above other project work. SRE managers and tech leads should make sure that production bugs are promptly dealt with, and escalate to the developer team decision makers when necessary.\n\nWhen a paging event is serious enough to warrant a postmortem, it’s even more important to follow this methodology to catalog and track follow-up action items. (See Chapter 10 for more details.)\n\nData quality. Once you identify bugs in your system that caused pages, a number of questions naturally arise:\n\nHow do you know which bug to fix first?\n\nHow do you know which component in your system caused most of your pages?\n\nHow do you determine what repetitive, manual action on-call engineers are tak‐ ing to resolve the pages?\n\nHow do you tell how many alerts with unidentified root causes remain?\n\nHow do you tell which bugs are truly, not just anecdotally, the worst?\n\nPractical Implementation Details\n\n|\n\n165\n\nThe answer is simple: collect data!\n\nWhen building up your data collection processes, you might track and monitor the patterns in on-call load, but this effort doesn’t scale. It’s far more sustainable to file a placeholder bug for each paging alert in your bug tracking system (e.g., Jira, Issue‐ Tracker), and for the on-call engineer to create a link between the paging alerts from your monitoring system and the relevant bug in the bug tracking system, as and when they realize that each alert is symptomatic of a preexisting issue. You will end up with a list of as-yet-not-understood bugs in one column, and a list of all of the pages that each bug is believed to have caused in the next.\n\nOnce you have structured data about the causes of the pages, you can begin to ana‐ lyze that data and produce reports. Those reports can answer questions such as:\n\nWhich bugs cause the most pages? Ideally we’d roll back and fix bugs immedi‐ ately, but sometimes, finding the root cause and deploying the fix takes a long time, and sometimes silencing key alerts isn’t a reasonable option. For example, the aforementioned Connection SRE Team might experience ongoing network congestion that isn’t immediately resolvable but still needs to be tracked. Collect‐ ing data on which production issues are causing the most pages and stress to the team supports data-driven conversations about prioritizing your engineering effort systematically.\n\nWhich component of the system is the cause of most pages (payments gateway, authentication microservice, etc.)?\n\nWhen correlated with your other monitoring data, do particular pages corre‐ spond to other signals (peaks in request rate, number of concurrent customer sessions, number of signups, number of withdrawals, etc.)?\n\nTying structured data to bugs and the root causes of your pages has other benefits:\n\nYou can automatically populate a list of existing bugs (that is, known issues), which may be useful for your support team.\n\nYou can automatically prioritize fixing bugs based on the number of pages each bug causes.\n\nThe quality of the data you collect will determine the quality of the decisions either humans or automata can make. To ensure high-quality data, consider the following techniques:\n\nDefine and document your team’s policy and expectations on data collection for pages.\n\n166\n\n|\n\nChapter 8: On-Call\n\nSet up nonpaging alerts from the monitoring system to highlight where pages were not handled according to those expectations. Managers and tech leads should make sure that the expectations are met.\n\nTeammates should follow up with each other when handoffs don’t adhere to expectations. Positive comments such as, “Maybe this could be related to bug 123,” “I’ve filed a bug with your findings so we can follow up in more detail,” or “This looks a lot like what happened on my shift last Wednesday: <link to page, bug>” powerfully reinforce the expected behaviors and ensure that you maximize opportunities for improvement. No one wants to be paged for the same issue that paged their teammate in the previous shift.\n\nVigilance. All too often, teams fall into operational overload by a thousand cuts. To avoid boiling the frog, it is important to pay attention to the health of on-call engi‐ neers over time, and ensure that production health is consistently and continuously prioritized by both SRE and developer teams.\n\nThe following techniques can help a team keep a watchful eye on pager load:\n\nAt production meetings (see the section “Communications: Production Meet‐ ings” in Site Reliability Engineering, Chapter 31), regularly talk about trends in pager load based on the structured data collected. We’ve found a 21-day trailing average to be useful.\n\nSet up ticket alerts, possibly targeted at tech leads or managers, for when pager load crosses a “warning” threshold that your team agrees on beforehand.\n\nHold regular meetings between the SRE team and developer team to discuss the current state of production and the outstanding production bugs that are paging SRE.\n\nOn-Call Flexibility\n\nShift Length An on-call rotation that has to handle one or more pages per day must be structured in a sustainable way: we recommend limiting shift lengths to 12 hours. Shorter shifts are better for the mental health of your engineers. Team members run the risk of exhaustion when shifts run long, and when people are tired, they make mistakes. Most humans simply can’t produce high-quality work if they’re on-call continuously. Many countries have laws about maximum working hours, breaks, and working con‐ ditions.\n\nPractical Implementation Details\n\n|\n\n167\n\nWhile spreading on-call shifts across a team’s daylight hours is ideal, a 12-hour shift system doesn’t necessitate a globally distributed team. Being on-call overnight for 12 hours is preferable to being on-call for 24 hours or more. You can make 12-hour shifts work even in a single location. For example, instead of asking a single engineer to be on-call for 24 hours a day across an entire week-long shift, it would be better for two engineers to split a week of on-call, with one person on-call during the day and one on-call overnight.\n\nIn our experience, 24 hours of on-call duty without reprieve isn’t a sustainable setup. While not ideal, occasional overnight 12-hour shifts at least ensure breaks for your engineers. Another option is to shorten shifts to last less than a week—something like 3 days on, 4 days off.\n\nScenario: A change in personal circumstances\n\nImagine you are a member of an on-call team for a large service that has a 24/7 follow-the-sun model split across two sites. The arrangement works well for you. While you’re not thrilled about the possibility of a 6 a.m. page, you are happy with the work you and the team are doing to keep the operational load manageable while improving the reliability of the service.\n\nAll is well…until one day you realize that the on-call schedule and the demands of your personal life are starting to clash. There are many potential reasons why—for example, becoming a parent, needing to travel on short notice and take a leave from work, or illness.\n\nYou need your on-call duties to coexist with your new personal schedule.\n\nMany teams and organizations face this challenge as they mature. People’s needs change over time, and maintaining a healthy balance of diverse teammate back‐ grounds leads to an on-call rotation characterized by diverse needs. The key to keep‐ ing a healthy, fair, and equitable balance of on-call work and personal life is flexibility.\n\nThere are a number of ways that you can apply flexibility to on-call rotations to meet the needs of team members while still ensuring coverage for your services or prod‐ ucts. It is impossible to write down a comprehensive, one-size-fits-all set of guide‐ lines. We encourage embracing flexibility as a principle rather than simply adopting the examples listed here.\n\nAutomate on-call scheduling. As teams grow, accounting for scheduling constraints— vacation plans, distribution of on-call weekdays versus weekends, individual prefer‐ ences, religious requirements, and so on—becomes increasingly difficult. You can’t manage this task manually; it’s hard to find any solution at all, much less a fair one.\n\n168\n\n|\n\nChapter 8: On-Call",
      "page_number": 185
    },
    {
      "number": 22,
      "title": "Segment 22 (pages 194-201)",
      "start_page": 194,
      "end_page": 201,
      "detection_method": "topic_boundary",
      "content": "“Fairness” doesn’t mean a completely uniform distribution of each type of shift across team members. Different people have different needs and different preferen‐ ces. Therefore, it’s important for the team to share those preferences and try to meet them in an intelligent way. Team composition and preferences dictate whether your team prefers a uniform distribution, or a more customized way of meeting schedul‐ ing preferences.\n\nUsing an automated tool to schedule on-call shifts makes this task much easier. This tool should have a few basic characteristics:\n\nIt should rearrange on-call shifts to accommodate the changing needs of team members.\n\nIt should automatically rebalance on-call load in response to any changes.\n\nIt should do its best to ensure fairness by factoring in personal preferences such as “no primary during weekends in April,” as well as historical information such as recent on-call load per engineer.\n\nSo that on-call engineers can plan around their on-call shifts, it must never change an already generated schedule.\n\nSchedule generation can be either fully automated or scheduled by a human. Like‐ wise, some teams prefer to have members explicitly sign off on the schedule, while others are comfortable with a fully automated process. You might opt to develop your own tool in-house if your needs are complex, but there are a number of commercial and open source software packages that can aid in automating on-call scheduling.\n\nPlan for short-term swaps. Requests for short-term changes in the on-call schedule happen frequently. No one can promise on Monday that they won’t have the flu on Thursday. Or you might need to run an unforeseen urgent errand in the middle of your on-call shift.\n\nYou may also want to facilitate on-call swaps for nonurgent reasons—for example, to allow on-callers to attend sports training sessions. In this situation, team members can swap a subset of the on-call day (for example, half of Sunday). Nonurgent swaps are typically best-effort.\n\nTeams with a strict pager response SLO need to take commute coverage into account. If your pager response SLO is 5 minutes, and your commute is 30 minutes, you need to make sure that someone else can respond to emergencies while you get to work.\n\nTo achieve these goals in flexibility, we recommend giving team members the ability to update the on-call rotation. Also, have a documented policy in place describing how swaps should work. Decentralization options range from a fully centralized pol‐ icy, where only the manager can change the schedule, to a fully decentralized one,\n\nPractical Implementation Details\n\n|\n\n169\n\nwhere any team member can change the policy independently. In our experience, instituting peer review of changes provides a good tradeoff between safety and flexibility.\n\nPlan for long-term breaks. Sometimes team members need to stop serving in the on- call rotation because of changes in personal circumstances or burnout. It’s important that teams are structured to allow on-callers to temporarily leave the rotation.\n\nIdeally, team size should allow for a (temporary) staff reduction without causing the rest of the team to suffer too much operational load. In our experience, you need a bare minimum of five people per site to sustain on-call in a multisite, 24/7 configura‐ tion, and eight people in a single-site, 24/7 configuration. Therefore, it is safe to assume each site will need one extra engineer as protection against staff reduction, bringing the minimum staffing to six engineers per site (multisite) or nine per site (single-site).\n\nPlan for part-time work schedules. Being on-call with part-time working schedules may seem incompatible, but we’ve found that on-call and part-time work arrangements are compatible if you take certain precautions. The following discussion assumes that if a member of your on-call rotation works part-time, they’ll be unavailable for on- call shifts outside of their part-time working week.\n\nThere are two main models of part-time working:\n\nWorking a reduced amount of full days per week—for example, four 8-hour days a week, instead of five\n\nWorking a reduced amount of time each day—for example, 6 hours a day, instead of 8 hours a day\n\nBoth models are compatible with on-call work, but require different adjustments to on-call scheduling.\n\nThe first model easily coexists with on-call work, especially if the nonworking day(s) are constant over time. In response, you can adopt an on-call shift length of fewer than seven days a week (for example, Monday through Thursday, or Friday through Sunday) and configure the automated scheduler not to schedule the part-time engi‐ neer(s) to be on-call on the days they don’t work.\n\nThe second model is possible in a couple ways:\n\nSplit on-call hours with another engineer, so that no one is on-call when they are not supposed to be. For example, if an on-call engineer needs to work from 9 a.m. to 4 p.m., you can assign the first half of the shift (9 a.m. to 3 p.m.) to them. Rotate the second half (3 p.m. to 9 p.m.) within the team the same way you rotate other on-call shifts.\n\n170\n\n|\n\nChapter 8: On-Call\n\nThe part-time engineer can work full hours on their on-call days, which may be feasible if the on-call shift is not too frequent.\n\nAs mentioned in Chapter 11 of Site Reliability Engineering, Google SRE compensates support outside of regular hours with a reduced hourly rate of pay or time off, according to local labor law and regulations. Take a part-time engineer’s reduced schedule into account when determining on-call compensation.\n\nIn order to maintain a proper balance between project time and on-call time, engi‐ neers working reduced hours should receive a proportionately smaller amount of on- call work. Larger teams absorb this additional on-call load more easily than smaller teams.\n\nOn-Call Team Dynamics Our first book touched upon how stress factors like high pager load and time pres‐ sure can force on-call engineers to adopt decision strategies based on intuition and heuristics rather than reason and data (see the section “Feeling Safe” in Chapter 11 of that book). Working from this discussion of team psychology, how do you go about building a team with positive dynamics? Consider an on-call team with the following set of hypothetical problems.\n\nScenario: A culture of “survive the week”\n\nA company begins with a couple of founders and a handful of employees, all feature developers. Everyone knows everyone else, and everyone takes pagers.\n\nThe company grows bigger. On-call duty is limited to a smaller set of more experi‐ enced feature developers who know the system better.\n\nThe company grows even bigger. They add an ops role to tackle reliability. This team is responsible for production health, and the job role is focused on operations, not coding. The on-call becomes a joint rotation between feature developers and ops. Feature developers have the final say in maintaining the service, and ops input is limited to operational tasks. By this time, there are 30 engineers in the on-call rota‐ tion: 25 feature developers and 5 ops, all located at the same site.\n\nThe team is plagued by high pager volume. Despite following the recommendations described earlier in this chapter to minimize pager load, the team is suffering from low morale. Because the feature developers prioritize developing new features, on-call follow-up takes a long time to implement.\n\nTo make matters worse, the feature developers are concerned about their own sub‐ system’s health. One feature developer insists on paging by error rate rather than error ratio for their mission-critical module, despite complaints from others on the team. These alerts are noisy, and return many false positives or unactionable pages.\n\nPractical Implementation Details\n\n|\n\n171\n\nOther members of the on-call rotation aren’t especially bothered by the high pager volume. Sure, there are a lot of pages, but most of them don’t take much time to resolve. As one on-call engineer puts it: “I take a quick look at the page subject and know they are duplicates. So I just ignore them.”\n\nSound familiar?\n\nSome Google teams experienced similar problems during their earlier days of matur‐ ity. If not handled carefully, these problems have the potential to tear the feature developer and ops teams apart and hinder on-call operation. There’s no silver bullet to solve these problems, but we found a couple of approaches particularly helpful. While your methodology may differ, your overall goal should be the same: build pos‐ itive team dynamics, and carefully avoid tailspin.\n\nProposal one: Empower your ops engineers. You can remodel the operations organiza‐ tion according to the guidelines outlined in this book and Site Reliability Engineering, perhaps even including a change of name (SRE, or similar) to indicate the change of role. Simply retitling your ops organization is not a panacea, but it can be helpful in communicating an actual change in responsibilities away from the old ops-centric model. Make it clear to the team and the entire company that SREs own the site oper‐ ation. This includes defining a shared roadmap for reliability, driving the full resolu‐ tion of issues, maintaining monitoring rules, and so on. Feature developers are necessary collaborators but don’t own these endeavors.\n\nTo return to our hypothetical team, this announcement ushered in the following operational changes:\n\nAction items are assigned only to the five DevOps engineers—who are now SREs. SREs work with subject experts—many of them feature developers—to accomplish these tasks. SREs take on the previously mentioned “error rate versus error ratio” debate by negotiating a change in alerting with the feature develop‐ ers.\n\nSREs are encouraged to dive into the code to make the changes themselves, if possible. They send code reviews to the subject experts. This has the benefit of building a sense of ownership among SREs, as well as upgrading their skills and authority for future occasions.\n\nWith this arrangement, feature developers are explicit collaborators on reliability fea‐ tures, and SREs are given the responsibility to own and improve the site.\n\nProposal two: Improve team relations. Another possible solution is to build stronger team bonds between team members. Google designates a “fun budget” specifically for organizing offsite activities to strengthen team bonds.\n\n172\n\n|\n\nChapter 8: On-Call\n\nWe’ve found that more robust team relationships create a spirit of increased under‐ standing and collaboration among teammates. As a result, engineers are more likely to fix bugs, finish action items, and help out their colleagues. For example, say you turned off a nightly pipeline job, but forgot to turn off the monitoring that checked if the pipeline ran successfully. As a result, you accidentally page a colleague at 3 a.m. If you’ve spent a little time with that colleague, you’d feel much worse about what hap‐ pened, and strive to be considerate by being more careful in the future. The mentality of “I protect my colleagues” translates to a more productive work atmosphere.\n\nWe’ve also found that making all members of the on-call rotation sit together, regardless of job title and function area, helps improve team relations tremendously. Encourage teams to eat lunch with each other. Don’t underestimate the power of rel‐ atively straightforward changes like these. It plays directly into team dynamics.\n\nConclusion SRE on-call is different than traditional ops roles. Rather than focusing solely on day- to-day operations, SRE fully owns the production environment, and seeks to better it through defining appropriate reliability thresholds, developing automation, and undertaking strategic engineering projects. On-call is critical for site operations, and handling it right is crucial to the company’s bottom line.\n\nOn-call is a source of much tension, both individually and collectively. But if you’ve stared into the eyes of the monster long enough, there is wisdom to be found. This chapter illustrates some of the lessons about on-call that we learned the hard way; we hope that our experience can help others avoid or tackle similar issues.\n\nIf your on-call team is drowning in endless alerts, we recommend taking a step back to observe the situation from a higher level. Compare notes with other SRE and part‐ ner teams. Once you’ve gathered the necessary information, address the problems in a systematic way. Thoughtfully structuring on-call is time well spent for on-call engi‐ neers, on-call teams, and the whole company.\n\nConclusion\n\n|\n\n173\n\nCHAPTER 9 Incident Response\n\nBy Jennifer Mace, Jelena Oertel, Stephen Thorne, and Arup Chakrabarti (PagerDuty) with Jian Ma and Jessie Yang\n\nEveryone wants their services to run smoothly all the time, but we live in an imper‐ fect world in which outages do occur. What happens when a not-so-ordinary, urgent problem requires multiple individuals or teams to resolve it? You are suddenly faced with simultaneously managing the incident response and resolving the problem.\n\nResolving an incident means mitigating the impact and/or restoring the service to its previous condition. Managing an incident means coordinating the efforts of respond‐ ing teams in an efficient manner and ensuring that communication flows both between the responders and to those interested in the incident’s progress. Many tech companies, including Google, have adopted and adapted best practices for managing incidents from emergency response organizations, which have been using these prac‐ tices for many years.\n\nThe basic premise of incident management is to respond to an incident in a struc‐ tured way. Large-scale incidents can be confusing; a structure that teams agree on beforehand can reduce chaos. Formulating rules about how to communicate and coordinate your efforts before disaster strikes allows your team to concentrate on resolving an incident when it occurs. If your team has already practiced and familiar‐ ized themselves with communication and coordination, they don’t need to worry about these factors during an incident.\n\nSetting up an incident response process doesn’t need to be a daunting task. There are a number of widely available resources that can provide some guidance, such as Man‐ aging Incidents in the first SRE Book. The basic principles of incident response include the following:\n\n175\n\nMaintain a clear line of command.\n\nDesignate clearly defined roles.\n\nKeep a working record of debugging and mitigation as you go.\n\nDeclare incidents early and often.\n\nThis chapter shows how incident management is set up at Google and PagerDuty, and gives examples of where we got this process right and where we didn’t. The sim‐ ple checklist in “Putting Best Practices into Practice” on page 191 can help you get started on creating your own incident response practice, if you don’t already have one.\n\nIncident Management at Google Incident response provides a system for responding to and managing an incident. A framework and set of defined procedures allow a team to respond to an incident effectively and scale up their response. Google’s incident response system is based on the Incident Command System (ICS).\n\nIncident Command System ICS was established in 1968 by firefighters as a way to manage wildfires. This frame‐ work provides standardized ways to communicate and fill clearly specified roles dur‐ ing an incident. Based upon the success of the model, companies later adapted ICS to respond to computer and system failures. This chapter explores two such frame‐ works: PagerDuty’s Incident Response process and Incident Management At Google (IMAG).\n\nIncident response frameworks have three common goals, also known as the “three Cs” (3Cs) of incident management:\n\nCoordinate response effort.\n\nCommunicate between incident responders, within the organization, and to the outside world.\n\nMaintain control over the incident response.\n\nWhen something goes wrong with incident response, the culprit is likely in one of these areas. Mastering the 3Cs is essential for effective incident response.\n\n176\n\n|\n\nChapter 9: Incident Response\n\nMain Roles in Incident Response The main roles in incident response are the Incident Commander (IC), Communica‐ tions Lead (CL), and Operations or Ops Lead (OL). IMAG organizes these roles into a hierarchy: the IC leads the incident response, and the CL and OL report to the IC.\n\nWhen disaster strikes, the person who declares the incident typically steps into the IC role and directs the high-level state of the incident. The IC concentrates on the 3Cs and does the following:\n\nCommands and coordinates the incident response, delegating roles as needed. By default, the IC assumes all roles that have not been delegated yet.\n\nCommunicates effectively.\n\nStays in control of the incident response.\n\nWorks with other responders to resolve the incident.\n\nThe IC may either hand off their role to someone else and assume the OL role, or assign the OL role to someone else. The OL works to respond to the incident by applying operational tools to mitigate or resolve the incident.\n\nWhile the IC and OL work on mitigating and resolving the incident, the CL is the public face of the incident response team. The CL’s main duties include providing periodic updates to the incident response team and stakeholders, and managing inquiries about the incident.\n\nBoth the CL and OL may lead a team of people to help manage their specific areas of incident response. These teams can expand or contract as needed. If the incident becomes small enough, the CL role can be subsumed back into the IC role.\n\nCase Studies The following four large-scale incidents illustrate how incident response works in practice. Three of these case studies are from Google, and the last is a case study from PagerDuty, which provides perspective on how other organizations use ICS-derived frameworks. The Google examples start with an incident that wasn’t managed effec‐ tively, and progress to incidents that were managed well.\n\nCase Study 1: Software Bug—The Lights Are On but No One’s (Google) Home This example shows how failing to declare an incident early on can leave a team without the tools to respond to an incident quickly and efficiently. While this inci‐ dent was resolved without major calamity, early escalation would have produced a quicker, more organized response, and a better outcome.\n\nCase Studies\n\n|\n\n177",
      "page_number": 194
    },
    {
      "number": 23,
      "title": "Segment 23 (pages 202-211)",
      "start_page": 202,
      "end_page": 211,
      "detection_method": "topic_boundary",
      "content": "Context\n\nGoogle Home is a smart speaker and home assistant that responds to voice com‐ mands. The voice commands interact with Google Home’s software, which is called Google Assistant.\n\nInteracting with Google Home starts when a user says a hotword, a given phrase that triggers Google Assistant. Multiple users can use the same Google Home device by training the assistant to listen for a given hotword. The hotword model that identifies speakers is trained on the client, but the training data (i.e., the speaker recognition files) is stored on the server. The server handles bidirectional streaming of data. To handle overload during busy times, the server has a quota policy for Google Assis‐ tant. In order to protect servers from overly large request values, the quota limit is significantly higher than the baseline usage for Google Assistant on a given device.\n\nA bug in Google Assistant version 1.88 caused speaker recognition files to be fetched 50 times more often than expected, exceeding this quota. Initially, Google Home users in the central United States experienced only small traffic losses. As the rollout increased progressively to all Google Home devices, however, users lost half of their requests during the weekend of June 3, 2017.\n\nIncident\n\nAt 11:48 a.m. PST on Monday, May 22, Jasper, the developer on-call for Google Home, happened to be looking at the queries per second (QPS) graphs and noticed something strange: Google Assistant had been pinging training data every 30 minutes, instead of once per day as expected. He stopped the release of version 1.88, which had rolled out to 25% of users. He raised a bug—let’s call it bug 12345—with Google’s bug tracking system to explore why this was happening. On the bug, he noted that Google Assistant was pinging data 48 times a day, causing it to exceed its QPS capacity.\n\nAnother developer, Melinda, linked the issue to a previously reported bug, which we’ll call bug 67890: any time an app refreshed the device authentication and enroll‐ ment state, the speech processor restarted. This bug was slated to be fixed after the version 1.88 release, so the team requested a temporary increase in quota for the model to mitigate the overload from extra queries.\n\nThe version 1.88 release was started again and continued to roll out, reaching 50% of users by Wednesday, May 31. Unfortunately, the team later learned that bug 67890, while responsible for some extra traffic, was not the actual root cause of the more fre‐ quent fetches that Jasper had noticed.\n\nThat same morning, customers started reporting an issue to Google’s support team: any time someone said “OK Google” (or any other hotword to activate Google Home), the device responded with an error message. This issue prevented users from\n\n178\n\n|\n\nChapter 9: Incident Response\n\ngiving commands to Google Assistant. The team began to investigate what could be causing the errors that users reported. They suspected quota issues, so they requested another increase to the quota, which seemed to mitigate the problem.\n\nMeanwhile, the team continued to investigate bug 12345 to see what was triggering the errors. Although the quota connection was established early in the debugging process, miscommunication between the client and server developers had led devel‐ opers down the wrong path during troubleshooting, and the full solution remained out of reach.\n\nThe team also puzzled over why Google Assistant’s traffic kept hitting quota limits. The client and server developers were confused by client-side errors that didn’t seem to be triggered by any problems on the server side. The developers added logging to the next release to help the team understand the errors better, and hopefully make progress in resolving the incident.\n\nBy Thursday, June 1, users reported that the issue had been resolved. No new issues were reported, so the version 1.88 release continued to roll out. However, the root cause of the original issue had not yet been identified.\n\nBy early Saturday morning, June 3, the version 1.88 release rollout surpassed 50%. The rollout was happening on a weekend, when developers were not readily available. The team had not followed the best practice of performing rollouts only during busi‐ ness days to ensure developers are around in case something goes wrong.\n\nWhen the version 1.88 release rollout reached 100% on Saturday, June 3, the client once more hit server limits for Google Assistant traffic. New reports from customers started coming in. Google employees reported that their Google Home devices were throwing errors. The Google Home support team received numerous customer phone calls, tweets, and Reddit posts about the issue, and Google Home’s help forum displayed a growing thread discussing the issue. Despite all the user reports and feed‐ back, the bug wasn’t escalated to a higher priority.\n\nOn Sunday, June 4, as the number of customer reports continued to increase, the support team finally raised the bug priority to the highest level. The team did not declare an incident, but continued to troubleshoot the issue via “normal” methods, using the bug tracking system for communication. The on-call developer noticed error rates in one of the datacenter clusters and pinged SRE, asking them to drain it. At the same time, the team submitted another request for a quota increase. After‐ ward, an engineer on the developer team noticed the drain had pushed errors into other cells, which provided additional evidence of quota issues. At 3:33 p.m., the developer team manager increased the quota for Google Assistant once again, and the impact on users stopped. The incident was over. The team identified the root cause (see the previous “Context” section) shortly thereafter.\n\nCase Studies\n\n|\n\n179\n\nReview\n\nSome aspects of incident handling went really well, while others had room for improvement.\n\nFirst, the developers rallied on the weekend and provided valuable input to resolve the issue. This was both good and bad. While the team valued the time and effort these individuals contributed over the weekend, successful incident management shouldn’t rely on heroic efforts of individuals. What if the developers had been unreachable? At the end of the day, Google supports a good work-life balance—engi‐ neers shouldn’t be tapped during their free time to fix work-related problems. Instead, we should have conducted rollouts during business hours or organized an on-call rotation that provided paid coverage outside of business hours.\n\nNext, the team worked to mitigate the issue. Google always aims to first stop the impact of an incident, and then find the root cause (unless the root cause just hap‐ pens to be identified early on). Once the issue is mitigated, it’s just as important to understand the root cause in order to prevent the issue from happening again. In this case, mitigation successfully stopped the impact on three separate occasions, but the team could only prevent the issue from recurring when they discovered the root cause. After the first mitigation, it would have been better to postpone the rollout until the root cause was fully determined, avoiding the major disruption that hap‐ pened over the weekend.\n\nFinally, the team did not declare an incident when problems first appeared. Our experience shows that managed incidents are resolved faster. Declaring an incident early ensures that:\n\nMiscommunication between the client and server developers is prevented.\n\nRoot-cause identification and incident resolution occur sooner.\n\nRelevant teams are looped in earlier, making external communications faster and smoother.\n\nCentralized communication is an important principle of the IMAG protocol. For example, when disaster strikes, SREs typically gather in a “war room.” The war room can be a physical location like a conference room, or it can be virtual: teams might gather on an IRC channel or Hangout. The key here is to gather all the incident res‐ ponders in one place and to communicate in real time to manage—and ultimately resolve—an incident.\n\nCase Study 2: Service Fault—Cache Me If You Can The following incident illustrates what happens when a team of experts tries to debug a system with so many interactions that no single person can grasp all the details. Sound familiar?\n\n180\n\n|\n\nChapter 9: Incident Response\n\nContext\n\nKubernetes is an open source container management system built collaboratively by many companies and individual contributors. Google Kubernetes Engine, or GKE, is a Google-managed system that creates, hosts, and runs Kubernetes clusters for users. This hosted version operates the control plane, while users upload and manage work‐ loads in the way that suits them best.\n\nWhen a user first creates a new cluster, GKE fetches and initializes the Docker images their cluster requires. Ideally, these components are fetched and built internally so we can validate them. But because Kubernetes is an open source system, new dependen‐ cies sometimes slip in through the cracks.\n\nIncident\n\nOne Thursday at 6:41 a.m. PST, London’s on-call SRE for GKE, Zara, was paged for CreateCluster prober failures across several zones. No new clusters were being suc‐ cessfully created. Zara checked the prober dashboard and saw that failures were above 60% for two zones. She verified this issue was affecting user attempts to create new clusters, though traffic to existing clusters was not affected. Zara followed GKE’s documented procedure and declared an incident at 7:06 a.m.\n\nInitially, four people were involved in the incident:\n\nZara, who first noticed the problem, and was therefore the designated default Incident Commander\n\nTwo of Zara’s teammates\n\nRohit, the customer support engineer paged by the incident procedure\n\nSince Rohit was based in Zurich, Zara (the IC) opened a GKE Panic IRC channel where the team could debug together. While the other two SREs dug into monitoring and error messages, Zara explained the outage and its impact to Rohit. By 7:24 a.m., Rohit posted a notice to users that CreateCluster was failing in the Europe-West region. This was turning into a large incident.\n\nBetween 7 a.m. and 8:20 a.m., Zara, Rohit, and the others worked on troubleshooting the issue. They examined cluster startup logs, which revealed an error:\n\nerror: failed to run Kubelet: cannot create certificate signing request: Post https://192.0.2.53/apis/certificates.k8s.io/v1beta1/certificatesigningrequests\n\nThey needed to determine which part of the certificate creation failed. The SREs investigated the network, resource availability, and the certificate signing process. All seemed to work fine separately. At 8:22 a.m., Zara posted a summary of the investiga‐ tion to the incident management system, and looked for a developer who could help her.\n\nCase Studies\n\n|\n\n181\n\nThankfully, GKE had a developer on-call who could be paged for emergencies. The developer, Victoria, joined the channel. She asked for a tracking bug and requested that the team escalate the issue to the infrastructure on-call team.\n\nIt was now 8:45 a.m. The first Seattle SRE, Il-Seong, arrived at the office, lightly caf‐ feinated and ready for the day. Il-Seong was a senior SRE with many years of experi‐ ence in incident response. When he was informed about the ongoing incident, he jumped in to help. First, Il-Seong checked the day’s release against the timing of the alerts, and determined that the day’s release did not cause the incident. He then started a working document1 to collect notes. He suggested that Zara escalate the incident to the infrastructure, cloud networking, and compute engine teams to possi‐ bly eliminate those areas as root causes. As a result of Zara’s escalation, additional people joined the incident response:\n\nThe developer lead for GKE nodes\n\nCloud Networking on-call\n\nCompute Engine on-call\n\nHerais, another Seattle SRE\n\nAt 9:10 a.m., the incident channel had a dozen participants. The incident was 2.5 hours old, with no root cause and no mitigation. Communication was becoming a challenge. Normally, on-call handover from London to Seattle occurred at 10 a.m., but Zara decided to hand over incident command to Il-Seong before 10 a.m., since he had more experience with IMAG.\n\nAs Incident Commander, Il-Seong set up a formal structure to address the incident. He then designated Zara as Ops Lead and Herais as Communications (Comms) Lead. Rohit remained the External Communications Lead. Herais immediately sent an “all hands on deck” email to several GKE lists, including all developer leads, and asked experts to join the incident response.\n\nSo far, the incident responders knew the following:\n\nCluster creation failed where nodes attempted to register with the master.\n\nThe error message indicated the certificate signing module as the culprit.\n\nAll cluster creation in Europe was failing; all other continents were fine.\n\nNo other GCP services in Europe were seeing network or quota problems.\n\n1 When three or more people work on an incident, it’s useful to start a collaborative document that lists work‐ ing theories, eliminated causes, and useful debugging information, such as error logs and suspect graphs. The document preserves this information so it doesn’t get lost in the conversation.\n\n182\n\n|\n\nChapter 9: Incident Response\n\nThanks to the call for all hands on deck, Puanani, a GKE Security team member, joined the effort. She noticed the certificate signer was not starting. The certificate signer was trying to pull an image from DockerHub, and the image appeared to be corrupted. Victoria (the on-call GKE developer) ran Docker’s pull command for the image in two geographic locations. It failed when it ran on a cluster in Europe and succeeded on a cluster in the US. This indicated that the European cluster was the problem. At 9:56 a.m., the team had identified a plausible root cause.\n\nBecause DockerHub was an external dependency, mitigation and root causing would be especially challenging. The first option for mitigation was for someone at Docker to quickly fix the image. The second option was to reconfigure the clusters to fetch the image from a different location, such as Google Container Registry (GCR), Goo‐ gle’s secure image hosting system. All the other dependencies, including other refer‐ ences to the image, were located in GCR.\n\nIl-Seong assigned owners to pursue both options. He then delegated a team to inves‐ tigate fixing the broken cluster. Discussion became too dense for IRC, so detailed debugging moved to the shared document, and IRC became the hub for decision making.\n\nFor the second option, pushing a new configuration meant rebuilding binaries, which took about an hour. At 10:59 a.m., when the team was 90% done rebuilding, they dis‐ covered another location that was using the bad image fetch path. In response, they had to restart the build.\n\nWhile the engineers on IRC worked on the two mitigation options, Tugay, an SRE, had an idea. Instead of rebuilding the configuration and pushing it out (a cumber‐ some and risky process), what if they intercepted Docker’s pull requests and substi‐ tuted the response from Docker with an internal cached image? GCR had a mirror for doing precisely this. Tugay reached out to contacts on GCR’s SRE team, and they confirmed that the team could set --registry-mirror=https://mirror.gcr.io on the Docker configuration. Tugay started setting up this functionality and discovered that the mirror was already in place!\n\nAt 11:29 a.m., Tugay reported to IRC that these images were being pulled from the GCR mirror, not DockerHub. At 11:37 a.m., the Incident Commander paged GCR on- call. At 11:59 a.m., GCR on-call purged the corrupt image from their European stor‐ age layer. By 12:11 p.m., all European zones had fallen to 0% error.\n\nThe outage was over. All that remained was cleanup, and writing a truly epic post‐ mortem.\n\nCreateCluster had failed in Europe for 6 hours and 40 minutes before it was fixed. In IRC, 41 unique users appeared throughout the incident, and IRC logs stretched to 26,000 words. The effort spun up seven IMAG task forces at various times, and as many as four worked simultaneously at any given time. On-calls were summoned\n\nCase Studies\n\n|\n\n183\n\nfrom six teams, not including those from the “all hands on deck” call. The postmor‐ tem contained 28 action items.\n\nReview\n\nThe GKE CreateCluster outage was a large incident by anyone’s standards. Let’s explore what went well, and what could have been handled better.\n\nWhat went well? The team had several documented escalation paths and was familiar with incident response tactics. Zara, the GKE on-call, quickly verified that the impact was affecting actual customers. She then used an incident management system pre‐ pared beforehand to bring in Rohit, who communicated the outage to customers.\n\nWhat could have been handled better? The service itself had some areas of concern. Complexity and dependence on specialists were problematic. Logging was insuffi‐ cient for diagnosis, and the team was distracted by the corruption on DockerHub, which was not the real issue.\n\nAt the beginning of the incident, the Incident Commander didn’t put a formal inci‐ dent response structure in place. While Zara assumed this role and moved the con‐ versation to IRC, she could have been much more proactive in coordinating information and making decisions. As a result, a handful of first responders pursued their own investigations without coordination. Il-Seong put a formal incident response structure in place two hours after the first page.\n\nFinally, the incident revealed a gap in GKE’s disaster readiness: the service didn’t have any early generic mitigations that would reduce user pain. Generic mitigations are actions that first responders take to alleviate pain, even before the root cause is fully understood. For example, responders could roll back a recent release when an outage is correlated with the release cycle, or reconfigure load balancers to avoid a region when errors are localized. It’s important to note that generic mitigations are blunt instruments and may cause other disruptions to the service. However, while they may have broader impact than a precise solution, they can be put in place quickly to stop the bleeding while the team discovers and addresses the root cause.\n\nLet’s look at the timeline of this incident again to see where a generic mitigation might have been effective:\n\n7 a.m. (Assessed impact). Zara confirmed that users were affected by the outage.\n\n9:56 a.m. (Found possible cause). Puanani and Victoria identified a rogue image.\n\n10:59 a.m. (Bespoke mitigation). Several team members worked on rebuilding binaries to push a new configuration that would fetch images from a different location.\n\n184\n\n|\n\nChapter 9: Incident Response\n\n11:59 a.m. (Found root cause and fixed the issue). Tugay and GCR on-call dis‐ abled GCR caching and purged a corrupt image from their European storage layer.\n\nA generic mitigation after step 2 (found possible cause) would have been very useful here. If the responders had rolled back all images to a known good state once they discovered the issue’s general location, the incident would have been mitigated by 10 a.m. To mitigate an incident, you don’t have to fully understand the details—you only need to know the location of the root cause. Having the ability to mitigate an outage before its cause is fully understood is crucial for running robust services with high availability.\n\nIn this case, the responders would have benefited from some sort of tool that facilita‐ ted rollbacks. Mitigation tools do take engineering time to develop. The right time to create general-purpose mitigation tools is before an incident occurs, not when you are responding to an emergency. Browsing postmortems is a great way to discover mitigations and/or tools that would have been useful in retrospect, and build them into services so that you can better manage incidents in the future.\n\nIt’s important to remember that first responders must prioritize mitigation above all else, or time to resolution suffers. Having a generic mitigation in place, such as roll‐ back and drain, speeds recovery and leads to happier customers. Ultimately, custom‐ ers do not care whether or not you fully understand what caused an outage. What they want is to stop receiving errors.\n\nWith mitigation as top priority, an active incident should be addressed as follows:\n\n1. Assess the impact of the incident.\n\n2. Mitigate the impact.\n\n3. Perform a root-cause analysis of the incident.\n\n4. After the incident is over, fix what caused the incident and write a postmortem.\n\nAfterward, you can run incident response drills to exercise the vulnerabilities in the system, and engineers can work on projects to address these vulnerabilities.\n\nCase Study 3: Power Outage—Lightning Never Strikes Twice… Until It Does The previous examples showed what can go wrong when you don’t have good inci‐ dent response strategies in place. The next example illustrates an incident that was successfully managed. When you follow a well-defined and clear response protocol, you can handle even rare or unusual incidents with ease.\n\nCase Studies\n\n|\n\n185\n\nContext\n\nPower grid events, such as lightning strikes, cause the power coming into a datacen‐ ter facility to vary wildly. Lightning strikes affecting the power grid are rare, but not unexpected. Google protects against sudden, unexpected power outages with backup generators and batteries, which are well tested and known to work in these scenarios.\n\nMany of Google’s servers have a large number of disks attached to them, with the disks located on a separate tray above or below the server. These trays have their own uninterruptible power supply (UPS) battery. When a power outage occurs, the backup generators activate but take a few minutes to start. During this period, the backup batteries attached to the servers and disk trays provide power until the backup generators are fully running, thereby preventing power grid events from impacting datacenter operation.\n\nIncident\n\nIn mid-2015, lightning struck the power grid near a Google datacenter in Belgium four times within two minutes. The datacenter’s backup generators activated to sup‐ ply power to all the machines. While the backup generators were starting up, most of the servers ran on backup batteries for a few minutes.\n\nThe UPS batteries in the disk trays did not swap power usage to the backup batteries on the third and fourth lightning strikes because the strikes were too closely spaced. As a result, the disk trays lost power until the backup generators kicked in. The servers did not lose power, but were unable to access the disks that had power cycled.\n\nLosing a large number of disk trays on persistent disk storage resulted in read and write errors for many virtual machine (VM) instances running on Google Compute Engine (GCE). The Persistent Disk SRE on-call was immediately notified of these errors. Once the Persistent Disk SRE team established the impact, a major incident was declared and announced to all affected parties. The Persistent Disk SRE on-call assumed the role of Incident Commander.\n\nAfter an initial investigation and communication between stakeholders, we estab‐ lished that:\n\nEach machine that lost a disk tray because of the temporary power outage needed to be rebooted.\n\nWhile waiting for the reboot, some customer VMs had trouble reading and writ‐ ing to their disks.\n\nAny host that had both a disk tray and customer VMs could not simply be “rebooted” without losing the customer VMs that hadn’t been affected. Persistent Disk SRE asked GCE SRE to migrate unaffected VMs to other hosts.\n\n186\n\n|\n\nChapter 9: Incident Response\n\nThe Persistent Disk SRE’s primary on-call retained the IC role, since that team had the best visibility into customer impact.\n\nOperations team members were tasked with the following objectives:\n\nSafely restore power to use grid power instead of backup generators.\n\nRestart all machines that were not hosting VMs.\n\nCoordinate between Persistent Disk SRE and GCE SRE to safely move VMs away from the affected machines before restarting them.\n\nThe first two objectives were clearly defined, well understood, and documented. The datacenter ops on-call immediately started working to safely restore power, providing regular status reports to the IC. Persistent Disk SRE had defined procedures for restarting all machines not hosting virtual machines. A team member began restart‐ ing those machines.\n\nThe third objective was more vague and wasn’t covered by any existing procedures. The Incident Commander assigned a dedicated operations team member to coordi‐ nate with GCE SRE and Persistent Disk SRE. These teams collaborated to safely move VMs away from the affected machines so the affected machines could be rebooted. The IC closely monitored their progress and realized that this work called for new tools to be written quickly. The IC organized more engineers to report to the opera‐ tions team so they could create the necessary tools.\n\nThe Communications Lead observed and asked questions about all incident-related activities, and was responsible for reporting accurate information to multiple audiences:\n\nCompany leaders needed information about the extent of the problem, and assurance that the problem was being addressed.\n\nTeams with storage concerns needed to know when their storage would be fully available again.\n\nExternal customers needed to be proactively informed about the problem with their disks in this cloud region.\n\nSpecific customers who had filed support tickets needed more information about the problems they were seeing, and advice on workarounds and timelines.\n\nAfter we mitigated the initial customer impact, we needed to do some follow-up, such as:\n\nDiagnosing why the UPS used by the disk trays failed, and making sure that it doesn’t happen again.\n\nReplacing the batteries in the datacenter that failed.\n\nCase Studies\n\n|\n\n187",
      "page_number": 202
    },
    {
      "number": 24,
      "title": "Segment 24 (pages 212-219)",
      "start_page": 212,
      "end_page": 219,
      "detection_method": "topic_boundary",
      "content": "Manually clearing “stuck” operations caused by losing so many storage systems simultaneously.\n\nPost-incident analysis revealed that only a small number of writes—the writes pend‐ ing on the machines that lost power during the incident—weren’t ever written to disk. Since Persistent Disk snapshots and all Cloud Storage data are stored in multi‐ ple datacenters for redundancy, only 0.000001% of data from running GCE machines was lost, and only data from running instances was at risk.\n\nReview\n\nBy declaring the incident early and organizing a response with clear leadership, a carefully managed group of people handled this complex incident effectively.\n\nThe Incident Commander delegated the normal problems of restoring power and rebooting servers to the appropriate Operations Lead. Engineers worked on fixing the issue and reported their progress back to the Operations Lead.\n\nThe more complex problem of meeting the needs of both GCE and Persistent Disk required coordinated decision making and interaction among multiple teams. The Incident Commander made sure to assign appropriate operations team members from both teams to the incident, and worked directly with them to drive toward a solution. The Incident Commander wisely focused on the most important aspect of the incident: addressing the needs of the impacted customers as quickly as possible.\n\nCase Study 4: Incident Response at PagerDuty by Arup Chakrabarti of PagerDuty\n\nPagerDuty has developed and refined our internal incident response practices over the course of several years. Initially, we staffed a permanent, company-wide Incident Commander and dedicated specific engineers per service to take part in incident response. As PagerDuty grew to over 400 employees and dozens of engineering teams, our Incident Response processes also changed. Every few months, we take a hard look at our processes, and update them to reflect business needs. Nearly every‐ thing we have learned is documented at https://response.pagerduty.com. Our Incident Response processes are purposefully not static; they change and evolve just as our business does.\n\nMajor incident response at PagerDuty\n\nTypically, small incidents require only a single on-call engineer to respond. When it comes to larger incidents, we place heavy emphasis on teamwork. An engineer shouldn’t feel alone in high-stress and high-impact scenarios. We use the following techniques to help promote teamwork:\n\n188\n\n|\n\nChapter 9: Incident Response\n\nParticipating in simulation exercises\n\nOne way we teach teamwork is by participating in Failure Friday. PagerDuty drew inspiration from Netflix’s Simian Army to create this program. Originally, Failure Friday was a manual failure injection exercise aimed at learning more about the ways our systems could break. Today, we also use this weekly exercise to recreate common problems in production and incident response scenarios.\n\nBefore Failure Friday starts, we nominate an Incident Commander (typically, a person training to become an IC). They are expected to behave and act like a real IC while conducting failure injection exercises. Throughout the drill, subject- matter experts use the same processes and vernacular they would use during an actual incident. This practice both familiarizes new on-call engineers with inci‐ dent response language and processes and provides more seasoned on-call engi‐ neers with a refresher.\n\nPlaying time-bound simulation games\n\nWhile Failure Friday exercises go a long way toward training engineers on differ‐ ent roles and processes, they can’t fully replicate the urgency of actual major inci‐ dents. We use simulation games with a time-bound urgency to capture that aspect of incident response.\n\n“Keep Talking and Nobody Explodes” is one game we’ve leveraged heavily. It requires players to work together to defuse bombs within time limits. The stress‐ ful and communication-intensive nature of the game forces players to cooperate and work together effectively.\n\nLearning from previous incidents\n\nLearning from previous incidents helps us respond better to major incidents in the future. To this end, we conduct and regularly review postmortems.\n\nPagerDuty’s postmortem process involves open meetings and thorough docu‐ mentation. By making this information easily accessible and discoverable, we aim to reduce the resolution time of future incidents, or prevent a future incident from happening altogether.\n\nWe also record all of the phone calls involved in a major incident so we can learn from the real-time communication feed.\n\nLet’s look at a recent incident in which PagerDuty had to leverage our incident response process. The incident occurred on October 6, 2017, and lasted more than 10 hours, but had very minimal customer impact.\n\n7:53 p.m. A member of the PagerDuty SRE team was alerted that PagerDuty internal NTP servers were exhibiting clock drift. The on-call SRE validated that all automated recovery actions had been executed, and completed the mitigation\n\nCase Studies\n\n|\n\n189\n\nsteps in relevant runbooks. This work was documented in the SRE team’s dedica‐ ted Slack channel.\n\n8:20 p.m. A member of PagerDuty Software Team A received an automated alert about clock drift errors in their services. Software Team A and the SRE team worked toward resolving the problem.\n\n9:17 p.m. A member of PagerDuty Software Team B received an automated alert about clock drift errors on their services. The engineer from Team B joined the Slack channel where the issue was already being triaged and debugged.\n\n9:49 p.m. The SRE on-call declared a major incident and alerted the Incident Commander on-call.\n\n9:55 p.m. The IC assembled the response team, which included every on-call engineer that had a service dependent on NTP, and PagerDuty’s customer sup‐ port on-call. The IC had the response team join the dedicated conference call and Slack channel. For the next eight hours, the response team worked on addressing and mitigating the issue. When the procedures in our runbooks didn’t resolve the issue, the response team started trying new recovery options in a methodical manner.\n\nDuring this time, we rotated on-call engineers and the IC every four hours. Doing so encouraged engineers to get rest and brought new ideas into the response team.\n\n5:33 a.m. The on-call SRE made a configuration change to the NTP servers.\n\n6:13 a.m. The IC validated that all services had recovered with their respective on-call engineers. Once validation was complete, the IC shut off the conference call and Slack channel and declared the incident complete. Given the wide impact of the NTP service, a postmortem was warranted. Before closing out the incident, the IC assigned the postmortem analysis to the SRE team on-call for the service.\n\nTools used for incident response\n\nOur Incident Response processes leverage three main tools:\n\nPagerDuty\n\nWe store all of our on-call information, service ownership, postmortems, inci‐ dent metadata, and the like, in PagerDuty. This allows us to rapidly assemble the right team when something goes wrong.\n\nSlack\n\nWe maintain a dedicated channel (#incident-war-room) as a gathering place for all subject-matter experts and Incident Commanders. The channel is used mostly\n\n190\n\n|\n\nChapter 9: Incident Response\n\nas an information ledger for the scribe, who captures actions, owners, and time‐ stamps.\n\nConference calls\n\nWhen asked to join any incident response, on-call engineers are required to dial in to a static conference call number. We prefer that all coordination decisions are made in the conference call, and that decision outcomes are recorded in Slack. We found this was the fastest way to make decisions. We also record every call to make sure that we can recreate any timeline in case the scribe misses important details.\n\nWhile Slack and conference calls are our communication channels of choice, you should use the communication method that works best for your company and its engineers.\n\nAt PagerDuty, how we handle incident response relates directly to the success of the company. Rather than facing such events unprepared, we purposefully prepare for incidents by conducting simulation exercises, reviewing previous incidents, and choosing the right tools to help us be resilient to any major incident that may come our way.\n\nPutting Best Practices into Practice We’ve seen examples of incidents that were handled well, and some that were not. By the time a pager alerts you to a problem, it’s too late to think about how to manage the incident. The time to start thinking about an incident management process is before an incident occurs. So how do you prepare and put theory into practice before disaster strikes? This section provides some recommendations.\n\nIncident Response Training We highly recommend training responders to organize an incident so they have a pattern to follow in a real emergency. Knowing how to organize an incident, having a common language to use throughout the incident, and sharing the same expectations reduce the chance of miscommunication.\n\nThe full Incident Command System approach may be more than you need, but you can develop a framework for handling incidents by selecting the parts of the incident management process that are important to your organization. For example:\n\nLet on-calls know they can delegate and escalate during an incident.\n\nEncourage a mitigation-first response.\n\nDefine Incident Commander, Communications Lead, and Operations Lead roles.\n\nPutting Best Practices into Practice\n\n|\n\n191\n\nYou can adapt and summarize your incident response framework, and create a slide deck to present to new team members. We’ve learned that people are more receptive to incident response training when they can connect the theory of incident response to actual scenarios and concrete actions. Therefore, be sure to include hands-on exer‐ cises and share what happened in past incidents, analyzing what went well and what didn’t go so well. You might also consider using external agencies that specialize in incident response classes and training.\n\nPrepare Beforehand In addition to incident response training, it helps to prepare for an incident before‐ hand. Use the following tips and strategies to be better prepared.\n\nDecide on a communication channel\n\nDecide and agree on a communication channel (Slack, a phone bridge, IRC, HipChat, etc.) beforehand—no Incident Commander wants to make this decision during an incident. Practice using it so there are no surprises. If possible, pick a communica‐ tions channel the team is already familiar with so that everyone on the team feels comfortable using it.\n\nKeep your audience informed\n\nUnless you acknowledge that an incident is happening and actively being addressed, people will automatically assume nothing is being done to resolve the issue. Similarly, if you forget to call off the response once the issue has been mitigated or resolved, people will assume the incident is ongoing. You can preempt this dynamic by keep‐ ing your audience informed throughout the incident with regular status updates. Having a prepared list of contacts (see the next tip) saves valuable time and ensures you don’t miss anyone.\n\nThink ahead about how you’ll draft, review, approve, and release public blog posts or press releases. At Google, teams seek guidance from the PR team. Also, prepare two or three ready-to-use templates for sharing information, making sure the on-call knows how to send them. No one wants to write these announcements under extreme stress with no guidelines. The templates make sharing information with the public easy and minimally stressful.\n\nPrepare a list of contacts\n\nHaving a list of people to email or page prepared beforehand saves critical time and effort. In “Case Study 2: Service Fault—Cache Me If You Can” on page 180, the Comms Lead made an “all hands on deck” call by sending an email to several GKE lists that were prepared beforehand.\n\n192\n\n|\n\nChapter 9: Incident Response\n\nEstablish criteria for an incident\n\nSometimes it’s clear that a paging issue is truly an incident. Other times, it’s not so clear. It’s helpful to have an established list of criteria for determining if an issue is indeed an incident. A team can come up with a solid list of criteria by looking at past outages, taking known high-risk areas into consideration.\n\nIn summary, it’s important to establish common ground for coordination and com‐ munication when responding to incidents. Decide on ways to communicate the inci‐ dent, who your audience is, and who is responsible for what during an incident. These guidelines are easy to set up and have high impact on shortening the resolution time of an incident.\n\nDrills The final step in the incident management process is practicing your incident man‐ agement skills. By practicing during less critical situations, your team develops good habits and patterns of behavior for when lightning strikes—figuratively and literally. After introducing the theory of incident response through training, practice ensures that your incident response skills stay fresh.\n\nThere are several ways to conduct incident management drills. Google runs company-wide resilience testing (called Disaster Recovery Testing, or DiRT; see Kripa Krishnan’s article “Weathering the Unexpected”2), in which we create a con‐ trolled emergency that doesn’t actually impact customers. Teams respond to the con‐ trolled emergency as if it were a real emergency. Afterward, the teams review the emergency response procedures and discuss what happened. Accepting failure as a means of learning, finding value in gaps identified, and getting our leadership on board were key to successfully establishing the DiRT program at Google. On a smaller scale, we practice responding to specific incidents using exercises like Wheel of Misfortune (see “Disaster Role Playing” in Site Reliability Engineering).\n\nYou can also practice incident response by intentionally treating minor problems as major ones requiring a large-scale response. This lets your team practice with the procedures and tools in a real-world situation with lower stakes.\n\nDrills are a friendly way of trying out new incident response skills. Anyone on your team who could get swept into incident response—SREs, developers, and even cus‐ tomer support and marketing partners—should feel comfortable with these tactics.\n\nTo stage a drill, you can invent an outage and allow your team to respond to the inci‐ dent. You can also create outages from postmortems, which contain plenty of ideas\n\n2 Kripa Krishan, “Weathering the Unexpected,” Communications of the ACM 10, no. 9 (2012), https://\n\nqueue.acm.org/detail.cfm?id=2371516.\n\nPutting Best Practices into Practice\n\n|\n\n193\n\nfor incident management drills. Use real tools as much as possible to manage the incident. Consider breaking your test environment so the team can perform real troubleshooting using existing tools.\n\nAll these drills are far more useful if they’re run periodically. You can make drills impactful by following up each exercise with a report detailing what went well, what didn’t go well, and how things could have been handled better. The most valuable part of running a drill is examining their outcomes, which can reveal a lot about any gaps in incident management. Once you know what they are, you can work toward closing them.\n\nConclusion Be prepared for when disaster strikes. If your team practices and refreshes your inci‐ dent response procedures regularly, you won’t panic when the inevitable outage occurs.\n\nThe circle of people you need to collaborate with during an incident expands with the size of the incident. When you’re working with people you don’t know, procedures help create the structure you need to quickly move toward a resolution. We strongly recommend establishing these procedures ahead of time when the world is not on fire. Regularly review and iterate on your incident management plans and playbooks.\n\nThe Incident Command System is a simple concept that is easily understood. It scales up or down according to the size of the company and the incident. Although it’s sim‐ ple to understand, it isn’t easy to implement, especially in the middle of an incident when panic suddenly overtakes you. Staying calm and following the response struc‐ ture during an emergency takes practice, and practice builds “muscle memory.” This gives you the confidence you’ll need for a real emergency.\n\nWe strongly recommend carving out some time in your team’s busy schedule to practice incident management on a regular basis. Secure support from leadership for dedicated practice time, and make sure they understand how incident response works in case you need to involve them in a real incident. Disaster preparedness can shave off valuable minutes or hours from response time and gives you a competitive edge. No company gets it right all the time—learn from your mistakes, move on, and do better the next time.\n\n194\n\n|\n\nChapter 9: Incident Response\n\nCHAPTER 10 Postmortem Culture: Learning from Failure\n\nBy Daniel Rogers, Murali Suriar, Sue Lueder, Pranjal Deo, and Divya Sudhakar with Gary O’Connor and Dave Rensin\n\nOur experience shows that a truly blameless postmortem culture results in more reli‐ able systems—which is why we believe this practice is important to creating and maintaining a successful SRE organization.\n\nIntroducing postmortems into an organization is as much a cultural change as it is a technical one. Making such a shift can seem daunting. The key takeaway from this chapter is that making this change is possible, and needn’t seem like an insurmounta‐ ble challenge. Don’t emerge from an incident hoping that your systems will eventu‐ ally remedy themselves. You can start small by introducing a very basic postmortem procedure, and then reflect and tune your process to best suit your organization—as with many things, there is no one size that fits all.\n\nWhen written well, acted upon, and widely shared, postmortems can be a very effec‐ tive tool for driving positive organizational change and preventing repeat outages. To illustrate the principles of good postmortem writing, this chapter presents a case study of an actual outage that happened at Google. An example of a poorly written postmortem highlights the reasons why “bad” postmortem practices are damaging to an organization that’s trying to create a healthy postmortem culture. We then com‐ pare the bad postmortem with the actual postmortem that was written after the inci‐ dent, highlighting the principles and best practices of a high-quality postmortem.\n\nThe second part of this chapter shares what we’ve learned about creating incentives for nurturing of a robust postmortem culture and how to recognize (and remedy) the early signs that the culture is breaking down.\n\n195",
      "page_number": 212
    },
    {
      "number": 25,
      "title": "Segment 25 (pages 220-227)",
      "start_page": 220,
      "end_page": 227,
      "detection_method": "topic_boundary",
      "content": "Finally, we provide tools and templates that you can use to bootstrap a postmortem culture.\n\nFor a comprehensive discussion on blameless postmortem philosophy, see Chapter 15 in our first book, Site Reliability Engineering.\n\nCase Study This case study features a routine rack decommission that led to an increase in ser‐ vice latency for our users. A bug in our maintenance automation, combined with insufficient rate limits, caused thousands of servers carrying production traffic to simultaneously go offline.\n\nWhile the majority of Google’s servers are located in our proprietary datacenters, we also have racks of proxy/cache machines in colocation facilities (or “colos”). Racks in colos that contain our proxy machines are called satellites. Because satellites undergo regular maintenance and upgrades, a number of satellite racks are being installed or decommissioned at any point in time. At Google, these maintenance processes are largely automated.\n\nThe decommission process overwrites the full content of all drives in the rack using a process we call diskerase. Once a machine is sent to diskerase, the data it once stored is no longer retrievable. The steps for a typical rack decommission are as follows:\n\n# Get all active machines in \"satellite\" machines = GetMachines(satellite)\n\n# Send all candidate machines matching \"filter\" to decom SendToDecom(candidates=GetAllSatelliteMachines(), filter=machines)\n\nOur case study begins with a satellite rack that was marked for decommissioning. The diskerase step of the decommission process finished successfully, but the auto‐ mation responsible for the remainder of the machine decommission failed. To debug the failure, we retried the decommission process. The second decommission ran as follows:\n\n# Get all active machines in \"satellite\" machines = GetMachines(satellite)\n\n# \"machines\" is an empty list, because the decom flow has already run. # API bug: an empty list is treated as \"no filter\", rather than \"act on no # machines\"\n\n# Send all candidate machines matching \"filter\" to decom SendToDecom(candidates=GetAllSatelliteMachines(), filter=machines)\n\n# Send all machines in \"candidates\" to diskerase.\n\n196\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\nWithin minutes, the disks of all satellite machines, globally, were erased. The machines were rendered inert and could no longer accept connections from users, so subsequent user connections were routed directly to our datacenters. As a result, users experienced a slight increase in latency. Thanks to good capacity planning, very few of our users noticed the issue during the two days it took us to reinstall machines in the affected colo racks. Following the incident, we spent several weeks auditing and adding more sanity checks to our automation to make our decommission work‐ flow idempotent.\n\nThree years after this outage, we experienced a similar incident: a number of satellites were drained, resulting in increased user latency. The action items implemented from the original postmortem dramatically reduced the blast radius and rate of the second incident.\n\nSuppose you were the person responsible for writing the postmortem for this case study. What would you want to know, and what actions would you propose to pre‐ vent this outage from happening again?\n\nLet’s start with a not-so-great postmortem for this incident.\n\nBad Postmortem\n\nPostmortem: All Satellite Machines Sent to Diskerase\n\n2014-August-11\n\nOwner: Shared with: Status: Incident date: Published:\n\nmaxone@, logantwo@, sydneythree@, dylanfour@ satellite-infra-team@ Final 2014-August-11 2014-December-30\n\nExecutive Summary\n\nImpact: Root cause:\n\nAll Satellite machines are sent to diskerase, which practically wiped out Google Edge. dylanfour@ ignored the automation setup and ran the cluster turnup logic manually, which triggered an existing bug.\n\nProblem Summary\n\nDuration of problem: Product(s) affected:\n\n40min satellite-infra-team\n\nBad Postmortem\n\n|\n\n197\n\n% of product affected: All satellite clusters. User impact:\n\nAll queries that normally go to satellites were served from the core instead, causing increased latency. Some ads were not served due to the lost queries. Exact revenue impact unknown at this time. Monitoring alert. Diverting traffic to core followed by manual repair of edge clusters.\n\nRevenue impact:\n\nDetection: Resolution:\n\nBackground (optional)\n\nImpact\n\nUser impact\n\nAll queries that normally go to satellites were instead served from the core, caus‐ ing increased latency to user traffic.\n\nRevenue impact\n\nSome ads were not served due to the lost queries.\n\nRoot Causes and Trigger\n\nCluster turnup/turndown automation is not meant to be idempotent. The tool has safeguards to ensure that certain steps cannot be run more than once. Unfortunately, there is nothing to stop someone from running the code manually as many times as they want. None of the documentation mentioned this gotcha. As a result, most team members think it’s okay to run the process multiple times if it doesn’t work.\n\nThis is exactly what happened during a routine decommissioning of a rack. The rack was being replaced with a new Iota-based satellite. dylanfour@ completely ignored the fact that the turnup had already executed once and was stuck in the first attempt. Due to careless ignorance, they triggered a bad interaction that assigned all the satel‐ lite machines to the diskerase team.\n\nRecovery Efforts\n\nLessons Learned\n\nThings that went well\n\nAlerting caught the issue immediately.\n\nIncident management went well.\n\n198\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\nThings that went poorly\n\nThe team (especially maxone@, logantwo@) never wrote any documentation to tell SREs not to run the automation multiple times, which is ridiculous.\n\nOn-call did not act soon enough to prevent most satellite machines from being erased. This is not the first time that on-call failed to react in time.\n\nWhere we got lucky\n\nCore was able to serve all the traffic that normally would have gone to the Edge. I can’t believe we survived this one!!!\n\nAction Items\n\nAction item Make automation better. Improve paging and alerting. sydneythree@ needs to learn proper cross-site handoff protocol so nobody has to work on duplicate issues. Train humans not to run unsafe commands.\n\nType mitigate detect mitigate\n\nprevent\n\nPriority Owner P2 P2 P2\n\nlogantwo@\n\nP2\n\nTracking bug\n\nBUG6789\n\nGlossary\n\nWhy Is This Postmortem Bad? The example “bad” postmortem contains a number of common failure modes that we try to avoid. The following sections explain how to improve upon this postmortem.\n\nMissing context\n\nFrom the outset, our example postmortem introduces terminology that’s specific to traffic serving (e.g., “satellites”) and lower layers of machine management automa‐ tion at Google (e.g., “diskerase”). If you need to provide additional context as part of the postmortem, use the Background and/or Glossary sections (which can link to longer documents). In this case, both sections were blank.\n\nIf you don’t properly contextualize content when writing a postmortem, the docu‐ ment might be misunderstood or even ignored. It’s important to remember that your audience extends beyond the immediate team.\n\nBad Postmortem\n\n|\n\n199\n\nKey details omitted\n\nMultiple sections contain high-level summaries but lacked important details. For example:\n\nProblem summary\n\nFor outages affecting multiple services, you should present numbers to give a consistent representation of impact. The only numerical data our example pro‐ vides is the duration of the problem. We don’t have enough details to estimate the size or impact of the outage. Even if there is no concrete data, a well- informed estimate is better than no data at all. After all, if you don’t know how to measure it, then you can’t know it’s fixed!\n\nRoot causes and trigger\n\nIdentifying the root causes and trigger is one of the most important reasons to write a postmortem. Our example contains a small paragraph that describes the root causes and trigger, but it doesn’t explore the lower-level details of the issue.\n\nRecovery efforts\n\nA postmortem acts as the record of an incident for its readers. A good postmor‐ tem will let readers know what happened, how the issue was mitigated, and how users were impacted. The answers to many of these questions are typically found in the Recovery Efforts section, which was left empty in our example.\n\nIf an outage merits a postmortem, you should also take the time to accurately capture and document the necessary details. The reader should get a complete view of the outage and, more importantly, learn something new.\n\nKey action item characteristics missing\n\nThe Action Items (AIs) section of our example is missing the core aspects of an actionable plan to prevent recurrence. For example:\n\nThe action items are mostly mitigative. To minimize the likelihood of the outage recurring, you should include some preventative action items and fixes. The one “preventative” action item suggests we “make humans less error-prone.” In gen‐ eral, trying to change human behavior is less reliable than changing automated systems and processes. (Or as Dan Milstein once quipped: “Let’s plan for a future where we’re all as stupid as we are today.”)\n\nAll of the action items have been tagged with an equal priority. There’s no way to determine which action to tackle first.\n\nThe first two action items in the list use ambiguous phrases like “Improve” and “Make better.” These terms are vague and open to interpretation. Using unclear language makes it difficult to measure and understand success criteria.\n\n200\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\nOnly one action item was assigned a tracking bug. Without a formal tracking process, action items from postmortems are often forgotten, resulting in outages.\n\nIn the words of Ben Treynor Sloss, Google’s VP for 24/7 Opera‐ tions: “To our users, a postmortem without subsequent action is indistinguishable from no postmortem. Therefore, all postmortems which follow a user-affecting outage must have at least one P[01] bug associated with them. I personally review exceptions. There are very few exceptions.”\n\nCounterproductive finger pointing\n\nEvery postmortem has the potential to lapse into a blameful narrative. Let’s take a look at some examples:\n\nThings that went poorly\n\nThe entire team is blamed for the outage, while two members (maxone@ and logantwo@) are specifically called out.\n\nAction items\n\nThe last item in the list targets sydneythree@ for succumbing to pressure and mismanaging the cross-site handoff.\n\nRoot causes and trigger\n\ndylanfour@ is held solely responsible for the outage.\n\nIt may seem like a good idea to highlight individuals in a postmortem. Instead, this practice leads team members to become risk-averse because they’re afraid of being publicly shamed. They may be motivated to cover up facts critical to understanding and preventing recurrence.\n\nAnimated language\n\nA postmortem is a factual artifact that should be free from personal judgments and subjective language. It should consider multiple perspectives and be respectful of oth‐ ers. Our example postmortem contains multiple examples of undesirable language:\n\nRoot causes and trigger\n\nSuperfluous language (e.g., “careless ignorance”)\n\nThings that went poorly\n\nAnimated text (e.g., “which is ridiculous”)\n\nWhere we got lucky\n\nAn exclamation of disbelief (e.g., “I can’t believe we survived this one!!!”)\n\nBad Postmortem\n\n|\n\n201\n\nAnimated language and dramatic descriptions of events distract from the key mes‐ sage and erode psychological safety. Instead, provide verifiable data to justify the severity of a statement.\n\nMissing ownership\n\nDeclaring official ownership results in accountability, which leads to action. Our example postmortem contains several examples of missing ownership:\n\nThe postmortem lists four owners. Ideally, an owner is a single point of contact who is responsible for the postmortem, follow-up, and completion.\n\nThe Action Items section has little or no ownership for its entries. Actions items without clear owners are less likely to be resolved.\n\nIt’s better to have a single owner and multiple collaborators.\n\nLimited audience\n\nOur example postmortem was shared only among members of the team. By default, the document should have been accessible to everyone at the company. We recom‐ mend proactively sharing your postmortem as widely as possible—perhaps even with your customers. The value of a postmortem is proportional to the learning it creates. The more people that can learn from past incidents, the less likely they are to be repeated. A thoughtful and honest postmortem is also a key tool in restoring shaken trust.\n\nAs your experience and comfort grows, you will also likely expand your “audience” to nonhumans. Mature postmortem cultures often add machine-readable tags (and other metadata) to enable downstream analytics.\n\nDelayed publication\n\nOur example postmortem was published four months after the incident. In the interim, had the incident recurred (which in reality, did happen), team members likely would have forgotten key details that a timely postmortem would have cap‐ tured.\n\n202\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\nGood Postmortem\n\nThis is an actual postmortem. In some cases, we fictionalized names of individuals and teams. We also replaced actual values with placeholders to protect sensitive capacity information. In the postmortems that you create for your internal consumption, you should absolutely include specific numbers!\n\nPostmortem: All Satellite Machines Sent to Diskerase\n\n2014-August-11\n\nOwner:\n\nPostmortem: maxone@, logantwo@ Datacenter Automation: sydneythree@ Network: dylanfour@ Server Management: finfive@ all_engineering_employees@google.com Final\n\nShared with: Status: Incident date: Mon, August 11, 2014, 17:10 to 17:50 PST8PDT Published:\n\nFri, August 15, 2014\n\nExecutive Summary\n\nImpact:\n\nRoot cause:\n\nFrontend queries dropped Some ads were not served There was a latency increase for all services normally served from satellite for nearly two days A bug in turndown automation caused all satellite machines, instead of just one rack of satellite machines, to be sent to diskerase. This resulted in all satellite machines entering the decom workflow, which wiped their disks. The result was a global satellite frontend outage.\n\nProblem Summary\n\nDuration of problem:\n\nProduct(s) affected: % of product affected:\n\nMain outage: Mon, August 11, 17:10 to 17:50 PST8PDT Reconstruction work and residual pains through Wed, August 13, 07:46 PST8PDT, then the incident was closed. Frontend Infrastructure, specifically all satellite locations.\n\nGlobal—all traffic normally served from satellites (typically 60% of global queries).\n\nGood Postmortem\n\n|\n\n203",
      "page_number": 220
    },
    {
      "number": 26,
      "title": "Segment 26 (pages 228-235)",
      "start_page": 228,
      "end_page": 235,
      "detection_method": "topic_boundary",
      "content": "User impact:\n\nRevenue impact: Detection:\n\nResolution:\n\n[Value redacted] frontend queries dropped over a period of 40 minutes ([value redacted] QPS averaged over the period, [value redacted] % of global traffic). Latency increase for all services normally served from satellite for nearly two days. The exact revenue impact unknown at this time. Blackbox alerting: traffic-team was paged with “satellite a12bcd34 failing too many HTTP requests” for ~every satellite in the world. The outage itself was rapidly mitigated by moving all of Google’s frontend traffic to core clusters, at the cost of additional latency for user traffic.\n\nBackground (optional)\n\nIf you’re unfamiliar with frontend traffic serving and the lower layers of serving auto‐ mation at Google, read the glossary before you continue.\n\nImpact\n\nUser impact\n\n[Value redacted] frontend queries dropped over a period of [value redacted] minutes. [Value redacted] QPS averaged over the period, [value redacted] % of global traffic. Our monitoring suggests a much larger crater; however, the data was unreliable as it ceased monitoring satellites that were still serving, thinking they were turned down. The appendix describes how the above numbers were estimated.\n\nThere was a latency increase for all services normally served from satellite for nearly two days:\n\n— [Value redacted] ms RTT spikes for countries near core clusters\n\n— Up to+[value redacted] ms for locations relying more heavily on satellites\n\n(e.g., Australia, New Zealand, India)\n\nRevenue impact\n\nSome ads were not served due to the lost queries. The exact revenue impact is unknown at this time:\n\nDisplay and video: The data has very wide error bars due to day-on-day fluctua‐ tions, but we estimate between [value redacted] % and [value redacted] % of rev‐ enue loss on the day of the outage.\n\nSearch: [Value redacted] % to [value redacted] % loss between 17:00 to 18:00, again with wide error bars.\n\n204\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\nTeam impact\n\nThe Traffic team spent ~48 hours with all hands on deck rebuilding satellites.\n\nNST had a higher-than-normal interrupt/pager load because they needed to traffic-engineer overloaded peering links.\n\nSome services may have seen increased responses served at their frontends due to reduced cache hit rate in the GFEs.\n\n— For example, see this thread [link] about [cache-dependent service].\n\n— [Cache-dependent service] saw their cache hit rate at the GFEs drop from\n\n[value redacted ] % to [value redacted] % before slowly recovering.\n\nIncident document\n\n[The link to our incident tracking document has been redacted.]\n\nRoot Causes and Trigger\n\nA longstanding input validation bug in the Traffic Admin server was triggered by the manual reexecution of a workflow to decommission the a12bcd34 satellite. The bug removed the machine constraint on the decom action, sending all satellite machines to decommission.\n\nFrom there, datacenter automation executed the decom workflow, wiping the hard drives of the majority of satellite machines before this action could be stopped.\n\nThe Traffic Admin server provides a ReleaseSatelliteMachines RPC. This handler initiates satellite decommission using three MDB API calls:\n\nLook up the rack name associated with the edge node (e.g., a12bcd34 -> <rack name>).\n\nLook up the machine names associated with the rack (<rack> -> <machine 1>, <machine 2>, etc.).\n\nReassign those machines to diskerase, which indirectly triggers the decommis‐ sion workflow.\n\nThis procedure is not idempotent, due to a known behavior of the MDB API com‐ bined with a missing safety check. If a satellite node was previously successfully sent to decom, step 2 above returns an empty list, which is interpreted in step 3 as the absence of a constraint on a machine hostname.\n\nThis dangerous behavior has been around for a while, but was hidden by the work‐ flow that invokes the unsafe operation: the workflow step invoking the RPC is marked “run once,” meaning that the workflow engine will not reexecute the RPC once it has succeeded.\n\nGood Postmortem\n\n|\n\n205\n\nHowever, “run once” semantics don’t apply across multiple instances of a workflow. When the Cluster Turnup team manually started another run of the workflow for a12bcd34, this action triggered the admin_server bug.\n\nTimeline/Recovery Efforts\n\n[The link to our Timeline log has been elided for book publication. In a real postmor‐ tem, this information would always be included.]\n\nLessons Learned\n\nThings that went well\n\nEvacuating the edge. GFEs in core are explicitly capacity-planned to allow this to happen, as is the production backbone (aside from peering links; see the Outage list in the next section). This edge evacuation allowed the Traffic team to mitigate promptly without fear.\n\nAutomatic mitigation of catastrophic satellite failure. Cover routes automatically pull traffic from failing satellites back to core clusters, and satellites drain them‐ selves when abnormal churn is detected.\n\nSatellite decom/diskerase worked very effectively and rapidly, albeit as a con‐ fused deputy.\n\nThe outage triggered a quick IMAG response via OMG and the tool proved use‐ ful for ongoing incident tracking. The cross-team response was excellent, and OMG further helped keep everyone talking to each other.\n\nThings that went poorly\n\nOutage\n\nThe Traffic Admin server lacked the appropriate sanity checks on the commands it sent to MDB. All commands should be idempotent, or at least fail-safe on repeat invocations.\n\nMDB did not object to the missing hostname constraint in the ownership change request.\n\nThe decom workflow doesn’t cross-check decom requests with other data sour‐ ces (e.g., planned rack decoms). As a result, there were no objections to the request to trash (many) geographically diverse machines.\n\nThe decom workflow is not rate-limited. Once the machines entered decom, disk erase and other decom steps proceeded at maximum speed.\n\nSome peering links between Google and the world were overloaded as a result of the egress traffic shifting to different locations when satellites stopped serving, and their queries were instead served from core. This resulted in short bursts of\n\n206\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\ncongestion to select peers until satellites were restored, and mitigation work by NST to match.\n\nRecovery\n\nReinstalls of satellite machines were slow and unreliable. Reinstallations use TFTP to transmit data, which works poorly when transmitting to satellites at the end of high-latency links.\n\nThe Autoreplacer infrastructure was not able to handle the simultaneous setup of [value redacted] of GFEs at the time of the outage. Matching the velocity of auto‐ mated setups required the labor of many SREs working in parallel performing manual setups. The factors below contributed to the initial slowness of the auto‐ mation: — Overly strict SSH timeouts prevented reliable Autoreplacer operation on very\n\nremote satellites.\n\n— A slow kernel upgrade process was executed regardless of whether the\n\nmachine already had the correct version.\n\n— A concurrency regression in Autoreplacer prevented running more than two\n\nmachine setup tasks per worker machine.\n\n— Confusion about the behavior of the Autoreplacer wasted time and effort.\n\nThe monitoring configuration delta safety checks (25% change) did not trigger when 23% of the targets were removed, but did trigger when the same contents (29% of what remained) were readded. This caused a 30-minute delay in reena‐ bling monitoring of the satellites.\n\n“The installer” has limited staffing. As a result, making changes is difficult and slow.\n\nUse of superuser powers to claw machines back from diskerase left a lot of zom‐ bie state, causing ongoing cleanup pain.\n\nWhere we got lucky\n\nGFEs in core clusters are managed very differently from satellite GFEs. As a result, they were not affected by the decom rampage.\n\nSimilarly, YouTube’s CDN is run as a distinct piece of infrastructure, so You‐ Tube video serving was not affected. Had this failed, the outage would have been much more severe and prolonged.\n\nAction Items\n\nDue to the wide-reaching nature of this incident, we split action items into five themes:\n\nGood Postmortem\n\n|\n\n207\n\n1. Prevention/risk education\n\n2. Emergency response\n\n3. Monitoring/alerting\n\n4. Satellite/edge provisioning\n\n5. Cleanup/miscellaneous\n\nTable 10-1. Prevention/risk education\n\nAction items\n\nType\n\nPriority Owner\n\nTracking bug\n\nAudit all systems capable of turning live servers into paperweights (i.e., not just repairs and diskerase workflow). File bugs to track implementation of bad input rejection to all systems identified in BUG1234. Disallow any single operation from affecting servers spanning namespace/class boundaries. Traffic admin server needs a safety check to not operate on more than [value redacted] number of nodes. Traffic admin server should ask <safety check service> to approve destructive work. MDB should reject operations that do not provide values for an expected-present constraint.\n\ninvestigate\n\nprevent\n\nmitigate\n\nmitigate\n\nprevent\n\nprevent\n\nP1\n\nP1\n\nP1\n\nP1\n\nP0\n\nP0\n\nsydneythree@ BUG1234\n\nsydneythree@ BUG1235\n\nmaxone@\n\nBUG1236\n\ndylanfour@\n\nBUG1237\n\nlogantwo@\n\nBUG1238\n\nlouseven@\n\nBUG1239\n\nTable 10-2. Emergency response\n\nAction items Ensure that serving from core does not overload egress network links. Ensure decom workflow problems are noted under [the link to our emergency stop doc has been redacted] and [the link to our escalations contact page has been redacted]. Add a big-red-buttona disable approach to decom workflows. a A general term for a shut-down switch (e.g., an emergency power-off button) to be used in catastrophic circumstances to avert further damage.\n\nType repair\n\nPriority Owner P2\n\nTracking bug BUG1240\n\nrileysix@\n\nmitigate\n\nP2\n\nlogantwo@ BUG1241\n\nmitigate\n\nP0\n\nmaxone@\n\nBUG1242\n\n208\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\nTable 10-3. Monitoring/alerting\n\nAction items\n\nType\n\nPriority Owner\n\nTracking bug\n\nMonitoring target safety checks should not allow you to push a change that cannot be rolled back. Add an alert when more than [value redacted] % of our machines have been taken away from us. Machines were taken from satellites at 16:38 while the world started paging only at around 17:10.\n\nmitigate\n\ndetect\n\nP2\n\nP1\n\ndylanfour@ BUG1243\n\nrileysix@\n\nBUG1244\n\nTable 10-4. Satellite/edge provisioning\n\nAction items Use iPXE to use HTTPS to make reinstalls more reliable/ faster.\n\nType mitigate\n\nPriority Owner P2\n\nTracking bug\n\ndylanfour@ BUG1245\n\nTable 10-5. Cleanup/miscellaneous\n\nAction items Review MDB-related code in our tools and bring the admin server backup to unwedge turnups/turndowns. Schedule DiRT tests:\n\nType repair\n\nmitigate\n\nPriority Owner P2\n\nrileysix@\n\nTracking bug BUG1246\n\nP2\n\nlouseven@ BUG1247\n\nBring back satellite after diskerase.\n\nDo the same for YouTube CDN.\n\nGlossary\n\nAdmin server\n\nAn RPC server that enables automation to execute privileged operations for frontend serving infrastructure. The automation server is most visibly involved in the implementation of PCRs and cluster turnups/turndowns.\n\nAutoreplacer\n\nA system that moves non-Borgified servers from machine to machine. It’s used to keep services running in the face of machine failures, and also to support fork‐ lifts and colo reconfigs.\n\nBorg\n\nA cluster management system designed to manage tasks and machine resources on a massive scale. Borg owns all of the machines in a Borg cell, and assigns tasks to machines that have resources available.\n\nGood Postmortem\n\n|\n\n209\n\nDecom\n\nAn abbreviation of decommissioning. Decom of equipment is a process that is relevant to many operational teams.\n\nDiskerase\n\nA process (and associated hardware/software systems) to securely wipe produc‐ tion hard drives before they leave Google datacenters. Diskerase is a step in the decom workflow.\n\nGFE (Google Front End)\n\nThe server that the outside world connects to for (almost) all Google services.\n\nIMAG (Incident Management at Google)\n\nA program that establishes a standard, consistent way to handle all types of inci‐ dents—from system outages to natural disasters—and organize an effective response.\n\nMDB (Machine Database)\n\nA system that stores all sorts of information about the state of Google machine inventory.\n\nOMG (Outage Management at Google)\n\nAn incident management dashboard/tool that serves as a central place for track‐ ing and managing all ongoing incidents at Google.\n\nSatellites\n\nSmall, inexpensive racks of machine that serve only nonvideo, frontend traffic from the edge of Google’s network. Almost none of the traditional production cluster infrastructure is available for satellites. Satellites are distinct from the CDN that serves YouTube video content from the edge of Google’s network, and from other places on the wider internet. YouTube CDN was not affected by this incident.\n\nAppendix\n\nWhy is ReleaseSatelliteMachines not idempotent? [The response to this question has been elided.]\n\nWhat happened after the Admin Server assigned all satellites to the diskerase-team?\n\n[The response to this question has been elided.]\n\nWhat was the true QPS loss during the outage?\n\n[The response to this question has been elided.]\n\nIRC logs\n\n[The IRC logs have been elided.]\n\n210\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\nGraphs\n\nFaster latency statistics—what have satellites ever done for us?\n\nEmpirically from this outage, satellites shave [value redacted] ms latency off many locations near core clusters, and up to [value redacted] ms off locations further from our backbone:\n\n[The explanation of the graphs has been elided.]\n\nCore vs. Edge serving load\n\nA nice illustration of the reconstruction effort. Being able to once again serve 50% of traffic from the edge took about 36 hours, and returning to the normal traffic balance took an additional 12 hours (see Figure 10-1 and Figure 10-2).\n\nPeering strain from traffic shifts\n\n[Graph elided.]\n\nThe graph shows packet loss aggregated by network region. There were a few short spikes during the event itself, but the majority of the loss occurred as vari‐ ous regions entered peak with little/no satellite coverage.\n\nPerson vs. Machine, the GFE edition\n\n[Graph explanation of human vs. automated machine setup rates elided.]\n\nFigure 10-1. Core vs. Edge QPS breakdown\n\nGood Postmortem\n\n|\n\n211",
      "page_number": 228
    },
    {
      "number": 27,
      "title": "Segment 27 (pages 236-243)",
      "start_page": 236,
      "end_page": 243,
      "detection_method": "topic_boundary",
      "content": "Figure 10-2. Core vs. Edge QPS breakdown (alternate representation)\n\nWhy Is This Postmortem Better? This postmortem exemplifies several good writing practices.\n\nClarity\n\nThe postmortem is well organized and explains key terms in sufficient detail. For example:\n\nGlossary\n\nA well-written glossary makes the postmortem accessible and comprehensible to a broad audience.\n\nAction items\n\nThis was a large incident with many action items. Grouping action items by theme makes it easier to assign owners and priorities.\n\n212\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\nQuantifiable metrics\n\nThe postmortem presents useful data on the incident, such as cache hit ratios, traffic levels, and duration of the impact. Relevant sections of the data are pre‐ sented with links back to the original sources. This data transparency removes ambiguity and provides context for the reader.\n\nConcrete action items\n\nA postmortem with no action items is ineffective. These action items have a few nota‐ ble characteristics:\n\nOwnership\n\nAll action items have both an owner and a tracking number.\n\nPrioritization\n\nAll action items are assigned a priority level.\n\nMeasurability\n\nThe action items have a verifiable end state (e.g., “Add an alert when more than X% of our machines have been taken away from us”).\n\nPreventative action\n\nEach action item “theme” has Prevent/Mitigate action items that help avoid out‐ age recurrence (for example, “Disallow any single operation from affecting servers spanning namespace/class boundaries”).\n\nBlamelessness\n\nThe authors focused on the gaps in system design that permitted undesirable failure modes. For example:\n\nThings that went poorly\n\nNo individual or team is blamed for the incident.\n\nRoot cause and trigger\n\nFocuses on “what” went wrong, not “who” caused the incident.\n\nAction items\n\nAre aimed at improving the system instead of improving people.\n\nDepth\n\nRather than only investigating the proximate area of the system failure, the postmor‐ tem explores the impact and system flaws across multiple teams. Specifically:\n\nGood Postmortem\n\n|\n\n213\n\nImpact\n\nThis section contains lots of details from various perspectives, making it bal‐ anced and objective.\n\nRoot cause and trigger\n\nThis section performs a deep dive on the incident and arrives at a root cause and trigger.\n\nData-driven conclusions\n\nAll of the conclusions presented are based on facts and data. Any data used to arrive at a conclusion is linked from the document.\n\nAdditional resources\n\nThese present further useful information in the form of graphs. Graphs are explained to give context to readers who aren’t familiar with the system.\n\nPromptness\n\nThe postmortem was written and circulated less than a week after the incident was closed. A prompt postmortem tends to be more accurate because information is fresh in the contributors’ minds. The people who were affected by the outage are waiting for an explanation and some demonstration that you have things under control. The longer you wait, the more they will fill the gap with the products of their imagination. That seldom works in your favor!\n\nConciseness\n\nThe incident was a global one, impacting multiple systems. As a result, the postmor‐ tem recorded and subsequently parsed a lot of data. Lengthy data sources, such as chat transcripts and system logs, were abstracted, with the unedited versions linked from the main document. Overall, the postmortem strikes a balance between verbo‐ sity and readability.\n\nOrganizational Incentives Ideally, senior leadership should support and encourage effective postmortems. This section describes how an organization can incentivize a healthy postmortem culture. We highlight warning signs that the culture is failing and offer some solutions. We also provide tools and templates to streamline and automate the postmortem process.\n\nModel and Enforce Blameless Behavior To properly support postmortem culture, engineering leaders should consistently exemplify blameless behavior and encourage blamelessness in every aspect of post‐\n\n214\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\nmortem discussion. You can use a few concrete strategies to enforce blameless behav‐ ior in an organization.\n\nUse blameless language\n\nBlameful language stifles collaboration between teams. Consider the following sce‐ nario:\n\nSandy missed a service Foo training and wasn’t sure how to run a particular update command. The delay ultimately prolonged an outage.\n\nSRE Jesse [to Sandy’s manager]: “You’re the manager; why aren’t you making sure that everyone finishes the training?”\n\nThe exchange includes a leading question that will instantly put the recipient on the defensive. A more balanced response would be:\n\nSRE Jesse [to Sandy’s manager]: “Reading the postmortem, I see that the on-caller missed an important training that would have allowed them to resolve the outage more quickly. Maybe team members should be required to complete this training before joining the on-call rotation? Or we could remind them that if they get stuck to please quickly escalate. After all, escalation is not a sin—especially if it helps lower customer pain! Long term, we shouldn’t really rely so much on training, as it’s easy to forget in the heat of the moment.”\n\nInclude all incident participants in postmortem authoring\n\nIt can be easy to overlook key contributing factors to an outage when the postmortem is written in isolation or by a single team.\n\nGather feedback\n\nA clear review process and communication plan for postmortems can help prevent blameful language and perspectives from propagating within an organization. For a suggested structured review process, see the section “Postmortem checklist” on page 221.\n\nReward Postmortem Outcomes When well written, acted upon, and widely shared, postmortems are an effective vehicle for driving positive organizational change and preventing repeat outages. Consider the following strategies to incentivize postmortem culture.\n\nReward action item closeout\n\nIf you reward engineers for writing postmortems, but not for closing the associated action items, you risk an unvirtuous cycle of unclosed postmortems. Ensure that incentives are balanced between writing the postmortem and successfully implement‐ ing its action plan.\n\nOrganizational Incentives\n\n|\n\n215\n\nReward positive organizational change\n\nYou can incentivize widespread implementation of postmortem lessons by present‐ ing postmortems as an opportunity to expand impact across an organization. Reward this level of impact with peer bonuses, positive performance reviews, promotion, and the like.\n\nHighlight improved reliability\n\nOver time, an effective postmortem culture leads to fewer outages and more reliable systems. As a result, teams can focus on feature velocity instead of infrastructure patching. It’s intrinsically motivating to highlight these improvements in reports, presentations, and performance reviews.\n\nHold up postmortem owners as leaders\n\nCelebrating postmortems through emails or meetings, or by giving the authors an opportunity to present lessons learned to an audience, can appeal to individuals that appreciate public accolades. Setting up the owner as an “expert” on a type of failure and its avoidance can be rewarding for many engineers who seek peer acknowledg‐ ment. For example, you might hear someone say, “Talk to Sara, she’s an expert now. She just coauthored a postmortem where she figured out how to fix that gap!”\n\nGamification\n\nSome individuals are incentivized by a sense of accomplishment and progress toward a larger goal, such as fixing system weaknesses and increasing reliability. For these individuals, a scoreboard or burndown of postmortem action items can be an incen‐ tive. At Google, we hold “FixIt” weeks twice a year. SREs who close the most post‐ mortem action items receive small tokens of appreciation and (of course) bragging rights. Figure 10-3 shows an example of a postmortem leaderboard.\n\n216\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\nFigure 10-3. Postmortem leaderboard\n\nShare Postmortems Openly In order to maintain a healthy postmortem culture within an organization, it’s important to share postmortems as widely as possible. Implementing even one of the following tactics can help.\n\nShare announcements across the organization\n\nAnnounce the availability of the postmortem draft on your internal communication channels, email, Slack, and the like. If you have a regular company all-hands, make it a practice to share a recent postmortem of interest.\n\nOrganizational Incentives\n\n|\n\n217\n\nConduct cross-team reviews\n\nConduct cross-team reviews of postmortems. In these reviews, a team walks though their incident while other teams ask questions and learn vicariously. At Google, sev‐ eral offices have informal Postmortem Reading Clubs that are open to all employees.\n\nIn addition, a cross-functional group of developers, SREs, and organizational leaders reviews the overall postmortem process. These folks meet monthly to review the effectiveness of the postmortem process and template.\n\nHold training exercises\n\nUse the Wheel of Misfortune when training new engineers: a cast of engineers reenacts a previous postmortem, assuming roles laid out in the postmortem. The original Incident Commander attends to help make the experience as “real” as possi‐ ble.\n\nReport incidents and outages weekly\n\nCreate a weekly outage report containing the incidents and outages from the past seven days. Share the report with as wide an audience as possible. From the weekly outages, compile and share a periodic greatest hits report.\n\nRespond to Postmortem Culture Failures The breakdown of postmortem culture may not always be obvious. The following are some common failure patterns and recommended solutions.\n\nAvoiding association\n\nDisengaging from the postmortem process is a sign that postmortem culture at an organization is failing. For example, suppose SRE Director Parker overhears the fol‐ lowing conversation:\n\nSWE Sam: Wow, did you hear about that huge blow-up?\n\nSWE Riley: Yeah, it was terrible. They’ll have to write a postmortem now.\n\nSWE Sam: Oh no! I’m so glad I’m not involved with that.\n\nSWE Riley: Yeah, I really wouldn’t want to be in the meeting where that one is discussed.\n\nEnsuring that high-visibility postmortems are reviewed for blameful prose can help prevent this kind of avoidance. In addition, sharing high-quality examples and dis‐ cussing how those involved were rewarded can help reengage individuals.\n\n218\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\nFailing to reinforce the culture\n\nResponding when a senior executive uses blameful language can be challenging. Con‐ sider the following statement made by senior leadership at a meeting about an outage:\n\nVP Ash: I know we are supposed to be blameless, but this is a safe space. Someone must have known beforehand this was a bad idea, so why didn’t you listen to that person?\n\nMitigate the damage by moving the narrative in a more constructive direction. For example:\n\nSRE Dana: Hmmm, I’m sure everyone had the best intent, so to keep it blameless, maybe we ask generically if there were any warning signs we could have heeded, and why we might have dismissed them.\n\nIndividuals act in good faith and make decisions based on the best information avail‐ able. Investigating the source of misleading information is much more beneficial to the organization than assigning blame. (If you have encountered Agile principles, this should be familiar to you.)\n\nLacking time to write postmortems\n\nQuality postmortems take time to write. When a team is overloaded with other tasks, the quality of postmortems suffers. Subpar postmortems with incomplete action items make a recurrence far more likely. Postmortems are letters you write to future team members: it’s very important to keep a consistent quality bar, lest you acciden‐ tally teach future teammates a bad lesson. Prioritize postmortem work, track the postmortem completion and review, and allow teams adequate time to implement the associated action plan. The tooling we discuss in the section “Tools and Tem‐ plates” on page 220 can help with these activities.\n\nRepeating incidents\n\nIf teams are experiencing failures that mirror previous incidents, it’s time to dig deeper. Consider asking questions like:\n\nAre action items taking too long to close?\n\nIs feature velocity trumping reliability fixes?\n\nAre the right action items being captured in the first place?\n\nIs the faulty service overdue for a refactor?\n\nAre people putting Band-Aids on a more serious problem?\n\nOrganizational Incentives\n\n|\n\n219",
      "page_number": 236
    },
    {
      "number": 28,
      "title": "Segment 28 (pages 244-251)",
      "start_page": 244,
      "end_page": 251,
      "detection_method": "topic_boundary",
      "content": "If you uncovered a systemic process or technical problem, it’s time to take a step back and consider the overall service health. Bring the postmortem collaborators from each similar incident together to discuss the best course of action to prevent repeats.\n\nTools and Templates A set of tools and templates can bootstrap a postmortem culture by making writing postmortems and managing the associated data easier. There are a number of resour‐ ces from Google and other companies that you can leverage in this space.\n\nPostmortem Templates Templates make it easier to write complete postmortems and share them across an organization. Using a standard format makes postmortems more accessible for read‐ ers outside the domain. You can customize the template to fit your needs. For exam‐ ple, it may be useful to capture team-specific metadata like hardware make/model for a datacenter team, or Android versions affected for a mobile team. You can then add customizations as the team matures and performs more sophisticated postmortems.\n\nGoogle’s template\n\nGoogle has shared a version of our postmortem template in Google Docs format at http://g.co/SiteReliabilityWorkbookMaterials. Internally, we primarily use Docs to write postmortems because it facilitates collaboration via shared editing rights and comments. Some of our internal tools prepopulate this template with metadata to make the postmortem easier to write. We leverage Google Apps Script to automate parts of the authoring, and capture a lot of the data into specific sections and tables to make it easier for our postmortem repository to parse out data for analysis.\n\nOther industry templates\n\nSeveral other companies and individuals have shared their postmortem templates:\n\nPager Duty\n\nAn adaptation of the original Google Site Reliability Engineering book template\n\nA list of four templates hosted on GitHub\n\nGitHub user Julian Dunn\n\nServer Fault\n\n220\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\nPostmortem Tooling As of this writing, Google’s postmortem management tooling is not available for external use (check our blog for the latest updates). We can, however, explain how our tools facilitate postmortem culture.\n\nPostmortem creation\n\nOur incident management tooling collects and stores a lot of useful data about an incident and pushes that data automatically into the postmortem. Examples of data we push includes:\n\nIncident Commander and other roles\n\nDetailed incident timeline and IRC logs\n\nServices affected and root-cause services\n\nIncident severity\n\nIncident detection mechanisms\n\nPostmortem checklist\n\nTo help authors ensure a postmortem is properly completed, we provide a postmor‐ tem checklist that walks the owner through key steps. Here are just a few example checks on the list:\n\nPerform a complete assessment of incident impact.\n\nConduct sufficiently detailed root-cause analysis to drive action item planning.\n\nEnsure action items are vetted and approved by the technical leads of the service.\n\nShare the postmortem with the wider organization.\n\nThe full checklist is available at http://g.co/SiteReliabilityWorkbookMaterials.\n\nPostmortem storage\n\nWe store postmortems in a tool called Requiem so it’s easy for any Googler to find them. Our incident management tool automatically pushes all postmortems to Requiem, and anyone in the organization can post their postmortem for all to see. We have thousands of postmortems stored, dating back to 2009. Requiem parses out metadata from individual postmortems and makes it available for searching, analysis, and reporting.\n\nTools and Templates\n\n|\n\n221\n\nPostmortem follow-up\n\nOur postmortems are stored in Requiem’s database. Any resulting action items are filed as bugs in our centralized bug tracking system. Consequently, we can monitor the closure of action items from each postmortem. With this level of tracking, we can ensure that action items don’t slip through the cracks, leading to increasingly unsta‐ ble services. Figure 10-4 shows a mockup of postmortem action item monitoring enabled by our tooling.\n\nFigure 10-4. Postmortem action item monitoring\n\nPostmortem analysis\n\nOur postmortem management tool stores its information in a database for analysis. Teams can use the data to write reports about their postmortem trends and identify their most vulnerable systems. This helps us uncover underlying sources of instability or incident management dysfunctions that may otherwise go unnoticed. For exam‐ ple, Figure 10-5 shows charts that were built with our analysis tooling. These charts show us trends like how many postmortems we have per month per organization, incident mean duration, time to detect, time to resolve, and blast radius.\n\n222\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure\n\nFigure 10-5. Postmortem analysis\n\nOther industry tools\n\nHere are some third-party tools that can help you create, organize, and analyze postmortems:\n\nPager Duty Postmortems\n\nMorgue by Etsy\n\nVictorOps\n\nAlthough it’s impossible to fully automate every step of writing postmortems, we’ve found that postmortem templates and tooling make the process run more smoothly. These tools free up time, allowing authors to focus on the critical aspects of the post‐ mortem, such as root-cause analysis and action item planning.\n\nConclusion Ongoing investment in cultivating a postmortem culture pays dividends in the form of fewer outages, a better overall experience for users, and more trust from the people that depend on you. Consistent application of these practices results in better system design, less downtime, and more effective and happier engineers. If the worst does happen and an incident recurs, you will suffer less damage and recover faster and have even more data to continue reinforcing production.\n\nConclusion\n\n|\n\n223\n\nCHAPTER 11 Managing Load\n\nBy Cooper Bethea, Gráinne Sheerin, Jennifer Mace, and Ruth King with Gary Luo and Gary O’Connor\n\nNo service is 100% available 100% of the time: clients can be inconsiderate, demand can grow fifty-fold, a service might crash in response to a traffic spike, or an anchor might pull up a transatlantic cable. There are people who depend upon your service, and as service owners, we care about our users. When faced with these chains of out‐ age triggers, how can we make our infrastructure as adaptive and reliable as possible?\n\nThis chapter describes Google’s approach to traffic management with the hope that you can use these best practices to improve the efficiency, reliability, and availability of your services. Over the years, we have discovered that there’s no single solution for equalizing and stabilizing network load. Instead, we use a combination of tools, tech‐ nologies, and strategies that work in harmony to help keep our services reliable.\n\nBefore we dive in to this chapter, we recommend reading the philosophies discussed in Chapters 19 (“Load Balancing at the Frontend”) and 20 (“Load Balancing in the Datacenter”) of our first SRE book.\n\nGoogle Cloud Load Balancing These days, most companies don’t develop and maintain their own global load bal‐ ancing solutions, instead opting to use load balancing services from a larger public cloud provider. We’ll discuss Google Cloud Load Balancer (GCLB) as a concrete example of large-scale load balancing, but nearly all of the best practices we describe also apply to other cloud providers’ load balancers.\n\nGoogle has spent the past 18 years building infrastructure to make our services fast and reliable. Today we use these systems to serve YouTube, Maps, Gmail, Search, and many other products and services. GCLB is our publicly consumable global load\n\n225\n\nbalancing solution, and is the externalization of one of our internally developed global load balancing systems.\n\nThis section describes the components of GCLB and how they work together to serve user requests. We trace a typical user request from its creation to delivery at its desti‐ nation. The Niantic Pokémon GO case study provides a concrete implementation of GCLB in the real world.\n\nChapter 19 of our first SRE book described how DNS-based load balancing is the simplest and most effective way to balance load before the user’s connection even starts. We also discussed an endemic problem of this approach: it relies on client cooperation to properly expire and refetch DNS records. For this reason, GCLB does not use DNS load balancing.\n\nInstead, we use anycast, a method for sending clients to the closest cluster without relying on DNS geolocation. Google’s global load balancer knows where the clients are located and directs packets to the closest web service, providing low latency to users while using a single virtual IP (VIP). Using a single VIP means we can increase the time to live (TTL) of our DNS records, which further reduces latency.\n\nAnycast Anycast is a network addressing and routing methodology. It routes datagrams from a single sender to the topologically nearest node in a group of potential receivers, which are all identified by the same destination IP address. Google announces IPs via Border Gateway Protocol (BGP) from multiple points in our network. We rely on the BGP routing mesh to deliver packets from a user to the closest frontend location that can terminate a transmission control protocol (TCP) session. This deployment elimi‐ nates the problems of unicast IP proliferation and finding the closest frontend for a user. Two main issues remain:\n\nToo many nearby users can overwhelm a frontend site.\n\nBGP route calculation might reset connections.\n\nConsider an ISP that frequently recalculates its BGP routes such that one of its users prefers either of two frontend sites. Each time the BGP route “flaps,” all in-progress TCP streams are reset as the unfortunate user’s packets are directed to a new front‐ end with no TCP session state. To address these problems, we have leveraged our connection-level load balancer, Maglev (described shortly), to cohere TCP streams even when routes flap. We refer to this technique as stabilized anycast.\n\nStabilized anycast\n\nAs shown in Figure 11-1, Google implements stabilized anycast using Maglev, our custom load balancer. To stabilize anycast, we provide each Maglev machine with a\n\n226\n\n|\n\nChapter 11: Managing Load\n\nway to map client IPs to the closest Google frontend site. Sometimes Maglev pro‐ cesses a packet destined for an anycast VIP for a client that is closer to another front‐ end site. In this case, Maglev forwards that packet to another Maglev on a machine located at the closest frontend site for delivery. The Maglev machines at the closest frontend site then simply treat the packet as they would any other packet, and route it to a local backend.\n\nFigure 11-1. Stabilized anycast\n\nMaglev Maglev, shown in Figure 11-2, is Google’s custom distributed packet-level load bal‐ ancer. An integral part of our cloud architecture, Maglev machines manage incoming traffic to a cluster. They provide stateful TCP-level load balancing across our front‐ end servers. Maglev differs from other traditional hardware load balancers in a few key ways:\n\nAll packets destined for a given IP address can be evenly spread across a pool of Maglev machines via Equal-Cost Multi-Path (ECMP) forwarding. This enables us to boost Maglev capacity by simply adding servers to a pool. Spreading pack‐ ets evenly also enables Maglev redundancy to be modeled as N + 1, enhancing availability and reliability over traditional load balancing systems (which typi‐ cally rely on active/passive pairs to give 1 + 1 redundancy).\n\nMaglev is a Google custom solution. We control the system end-to-end, which allows us to experiment and iterate quickly.\n\nGoogle Cloud Load Balancing\n\n|\n\n227\n\nMaglev runs on commodity hardware in our datacenters, which greatly simplifies deployment.\n\nFigure 11-2. Maglev\n\nMaglev packet delivery uses consistent hashing and connection tracking. These techni‐ ques coalesce TCP streams at our HTTP reverse proxies (also known as Google Front Ends, or GFEs), which terminate TCP sessions. Consistent hashing and connection tracking are key to Maglev’s ability to scale by packet rather than by number of con‐ nections. When a router receives a packet destined for a VIP hosted by Maglev, the router forwards the packet to any Maglev machine in the cluster through ECMP. When a Maglev receives a packet, it computes the packet’s 5-tuple hash1 and looks up the hash value in its connection tracking table, which contains routing results for recent connections. If Maglev finds a match and the selected backend service is still healthy, it reuses the connection. Otherwise, Maglev falls back to consistent hashing to choose a backend. The combination of these techniques eliminates the need to share connection state among individual Maglev machines.\n\n1 5-tuple includes the following: source address, destination address, source port, destination port, and the\n\ntransport protocol type.\n\n228\n\n|\n\nChapter 11: Managing Load",
      "page_number": 244
    },
    {
      "number": 29,
      "title": "Segment 29 (pages 252-260)",
      "start_page": 252,
      "end_page": 260,
      "detection_method": "topic_boundary",
      "content": "Global Software Load Balancer GSLB is Google’s Global Software Load Balancer. It allows us to balance live user traf‐ fic between clusters so that we can match user demand to available service capacity, and so we can handle service failures in a way that’s transparent to users. As shown in Figure 11-3, GSLB controls both the distribution of connections to GFEs and the dis‐ tribution of requests to backend services. GSLB allows us to serve users from back‐ ends and GFEs running in different clusters. In addition to load balancing between frontends and backends, GSLB understands the health of backend services and can automatically drain traffic away from failed clusters.\n\nFigure 11-3. GSLB\n\nGoogle Front End As shown in Figure 11-4, the GFE sits between the outside world and various Google services (web search, image search, Gmail, etc.) and is frequently the first Google server a client HTTP(S) request encounters. The GFE terminates the client’s TCP and SSL sessions and inspects the HTTP header and URL path to determine which back‐ end service should handle the request. Once the GFE decides where to send the request, it reencrypts the data and forwards the request. For more information on how this encryption process works, see our whitepaper “Encryption in Transit in Google Cloud”.\n\nThe GFE is also responsible for health-checking its backends. If a backend server returns a negative acknowledgment (“NACKs” the request) or times out health checks, GFEs stop sending traffic to the failed backend. We use this signal to update GFE backends without impacting uptime. By putting GFE backends into a mode in which they fail health checks while continuing to respond to in-flight requests, we can gracefully remove GFE backends from service without disrupting any user\n\nGoogle Cloud Load Balancing\n\n|\n\n229\n\nrequests. We call this “lame duck” mode and we discuss it in more detail in Chapter 20 of the first SRE book.\n\nFigure 11-4. GFE\n\nThe GFEs also maintain persistent sessions to all their recently active backends so that a connection is ready to use as soon as a request arrives. This strategy helps reduce latency for our users, particularly in scenarios when we use SSL to secure the connection between GFE and the backend.\n\nGCLB: Low Latency Our network provisioning strategy aims to reduce end-user latency to our services. Because negotiating a secure connection via HTTPS requires two network round trips between client and server, it’s particularly important that we minimize the latency of this leg of the request time. To this end, we extended the edge of our net‐ work to host Maglev and GFE. These components terminate SSL as close to the user as possible, then forward requests to backend services deeper within our network over long-lived encrypted connections.\n\nWe built GCLB atop this combined Maglev/GFE-augmented edge network. When customers create a load balancer, we provision an anycast VIP and program Maglev\n\n230\n\n|\n\nChapter 11: Managing Load\n\nto load-balance it globally across GFEs at the edge of our network. GFE’s role is to terminate SSL, accept and buffer HTTP requests, forward those requests to the cus‐ tomer’s backend services, and then proxy the responses back to users. GSLB provides the glue between each layer: it enables Maglev to find the nearest GFE location with available capacity, and enables GFE to route requests to the nearest VM instance group with available capacity.\n\nGCLB: High Availability In the interest of providing high availability to our customers, GCLB offers an availa‐ bility SLA2 of 99.99%. In addition, GCLB provides support tools that enable our cus‐ tomers to improve and manage the availability of their own applications. It’s useful to think of the load balancing system as a sort of traffic manager. During normal opera‐ tion, GCLB routes traffic to the nearest backend with available capacity. When one instance of your service fails, GCLB detects the failure on your behalf and routes traf‐ fic to healthy instances.\n\nCanarying and gradual rollouts help GCLB maintain high availability. Canarying is one of our standard release procedures. As described in Chapter 16 this process involves deploying a new application to a very small number of servers, then gradu‐ ally increasing traffic and carefully observing system behavior to verify that there are no regressions. This practice reduces the impact of any regressions by catching them early in the canary phase. If the new version crashes or otherwise fails health checks, the load balancer routes around it. If you detect a nonfatal regression, you can administratively remove the instance group from the load balancer without touching the main version of the application.\n\nCase Study 1: Pokémon GO on GCLB Niantic launched Pokémon GO in the summer of 2016. It was the first new Pokémon game in years, the first official Pokémon smartphone game, and Niantic’s first project in concert with a major entertainment company. The game was a runaway hit and more popular than anyone expected—that summer you’d regularly see players gath‐ ering to duel around landmarks that were Pokémon Gyms in the virtual world.\n\nPokémon GO’s success greatly exceeded the expectations of the Niantic engineering team. Prior to launch, they load-tested their software stack to process up to 5x their most optimistic traffic estimates. The actual launch requests per second (RPS) rate was nearly 50x that estimate—enough to present a scaling challenge for nearly any software stack. To further complicate the matter, the world of Pokémon GO is highly\n\n2 See the Google Cloud Platform blog post “SLOs, SLIs, SLAs, Oh My—CRE Life Lessons” for an explanation of\n\nthe difference between SLOs and SLAs.\n\nGoogle Cloud Load Balancing\n\n|\n\n231\n\ninteractive and globally shared among its users. All players in a given area see the same view of the game world and interact with each other inside that world. This requires that the game produce and distribute near-real-time updates to a state shared by all participants.\n\nScaling the game to 50x more users required a truly impressive effort from the Nian‐ tic engineering team. In addition, many engineers across Google provided their assis‐ tance in scaling the service for a successful launch. Within two days of migrating to GCLB, the Pokemon GO app became the single largest GCLB service, easily on par with the other top 10 GCLB services.\n\nAs shown in Figure 11-5, when it launched, Pokémon GO used Google’s regional Network Load Balancer (NLB) to load-balance ingress traffic across a Kubernetes cluster. Each cluster contained pods of Nginx instances, which served as Layer 7 reverse proxies that terminated SSL, buffered HTTP requests, and performed routing and load balancing across pods of application server backends.\n\nFigure 11-5. Pokémon GO (pre-GCLB)\n\nNLB is responsible for load balancing at the IP layer, so a service that uses NLB effec‐ tively becomes a backend of Maglev. In this case, relying on NLB had the following implications for Niantic:\n\n232\n\n|\n\nChapter 11: Managing Load\n\nThe Nginx backends were responsible for terminating SSL for clients, which required two round trips from a client device to Niantic’s frontend proxies.\n\nThe need to buffer HTTP requests from clients led to resource exhaustion on the proxy tier, particularly when clients were only able to send bytes slowly.\n\nLow-level network attacks such as SYN flood could not be effectively ameliorated by a packet-level proxy.\n\nIn order to scale appropriately, Niantic needed a high-level proxy operating on a large edge network. This solution wasn’t possible with NLB.\n\nMigrating to GCLB\n\nA large SYN flood attack made migrating Pokémon GO to GCLB a priority. This migration was a joint effort between Niantic and the Google Customer Reliability Engineering (CRE) and SRE teams. The initial transition took place during a traffic trough and, at the time, was unremarkable. However, unforeseen problems emerged for both Niantic and Google as traffic ramped up to peak. Both Google and Niantic discovered that the true client demand for Pokémon GO traffic was 200% higher than previously observed. The Niantic frontend proxies received so many requests that they weren’t able to keep pace with all inbound connections. Any connection refused in this way wasn’t surfaced in the monitoring for inbound requests. The backends never had a chance.\n\nThis traffic surge caused a classic cascading failure scenario. Numerous backing serv‐ ices for the API—Cloud Datastore, Pokémon GO backends and API servers, and the load balancing system itself—exceeded the capacity available to Niantic’s cloud project. The overload caused Niantic’s backends to become extremely slow (rather than refuse requests), manifesting as requests timing out to the load balancing layer. Under this circumstance, the load balancer retried GET requests, adding to the sys‐ tem load. The combination of extremely high request volume and added retries stressed the SSL client code in the GFE at an unprecedented level, as it tried to recon‐ nect to unresponsive backends. This induced a severe performance regression in GFE such that GCLB’s worldwide capacity was effectively reduced by 50%.\n\nAs backends failed, the Pokémon GO app attempted to retry failed requests on behalf of users. At the time, the app’s retry strategy was a single immediate retry, followed by constant backoff. As the outage continued, the service sometimes returned a large number of quick errors—for example, when a shared backend restarted. These error responses served to effectively synchronize client retries, producing a “thundering herd” problem, in which many client requests were issued at essentially the same time. As shown in Figure 11-6, these synchronized request spikes ramped up enor‐ mously to 20× the previous global RPS peak.\n\nGoogle Cloud Load Balancing\n\n|\n\n233\n\nFigure 11-6. Traffic spikes caused by synchronous client retries\n\nResolving the issue\n\nThese request spikes, combined with the GFE capacity regression, resulted in queu‐ ing and high latency for all GCLB services. Google’s on-call Traffic SREs acted to reduce collateral damage to other GCLB users by doing the following:\n\n1. Isolating GFEs that could serve Pokémon GO traffic from the main pool of load balancers.\n\n2. Enlarging the isolated Pokémon GO pool until it could handle peak traffic despite the performance regression. This action moved the capacity bottleneck from GFE to the Niantic stack, where servers were still timing out, particularly when client retries started to synchronize and spike.\n\n3. With Niantic’s blessing, Traffic SRE implemented administrative overrides to limit the rate of traffic the load balancers would accept on behalf of Pokémon GO. This strategy contained client demand enough to allow Niantic to reestab‐ lish normal operation and commence scaling upward.\n\nFigure 11-7 shows the final network configuration.\n\n234\n\n|\n\nChapter 11: Managing Load\n\nFigure 11-7. Pokémon GO GCLB\n\nFuture-proofing\n\nIn the wake of this incident, Google and Niantic both made significant changes to their systems. Niantic introduced jitter and truncated exponential backoff3 to their clients, which curbed the massive synchronized retry spikes experienced during cas‐ cading failure. Google learned to consider GFE backends as a potentially significant source of load, and instituted qualification and load testing practices to detect GFE performance degradation caused by slow or otherwise misbehaving backends. Finally, both companies realized they should measure load as close to the client as possible. Had Niantic and Google CRE been able to accurately predict client RPS demand, we would have preemptively scaled up the resources allocated to Niantic even more than we did before conducting the switch to GCLB.\n\n3 For more information on this topic, see Chapter 22 of the first SRE book.\n\nGoogle Cloud Load Balancing\n\n|\n\n235\n\nAutoscaling Tools like GCLB can help you balance load efficiently across your fleet, making your service more stable and reliable. Sometimes you simply don’t have enough resources reserved to manage your existing traffic. You can use autoscaling to scale your fleet strategically. Whether you increase the resources per machine (vertical scaling) or increase the total number of machines in the pool (horizontal scaling), autoscaling is a powerful tool and, when used correctly, can enhance your service availability and utilization. Conversely, if misconfigured or misused, autoscaling can negatively impact your service. This section describes some best practices, common failure modes, and current limitations of autoscaling.\n\nHandling Unhealthy Machines Autoscaling normally averages utilization over all instances regardless of their state, and assumes that instances are homogeneous in terms of request processing effi‐ ciency. Autoscaling runs into problems when machines are not serving (known as unhealthy instances) but are still counted toward the utilization average. In this sce‐ nario, autoscaling simply won’t occur. A variety of issues can trigger this failure mode, including:\n\nInstances taking a long time to get ready to serve (e.g., when loading a binary or warming up)\n\nInstances stuck in a nonserving state (i.e., zombies)\n\nWe can improve this situation using a variety of tactics. You can make the following improvements in combination or individually:\n\nLoad balancing\n\nAutoscale using a capacity metric as observed by the load balancer. This will automatically discount unhealthy instances from the average.\n\nWait for new instances to stabilize before collecting metrics\n\nYou can configure autoscaler to collect information about new instances only once new instances become healthy (GCE refers to this period of inactivity as a cool-down period).\n\nAutoscale and autoheal\n\nAutohealing monitors your instances and attempts to restart them if they are unhealthy. Typically, you configure your autohealer to monitor a health metric exposed by your instances. If autohealer detects that an instance is down or unhealthy, it will attempt a restart. When configuring your autohealer, it’s\n\n236\n\n|\n\nChapter 11: Managing Load\n\nimportant to ensure you leave sufficient time for your instances to become healthy after a restart.\n\nUsing a mix of these solutions, you can optimize horizontal autoscaling to keep track only of healthy machines. Remember that when running your service, autoscaler will continuously adjust the size of your fleet. Creating new instances is never instant.\n\nWorking with Stateful Systems A stateful system sends all requests in a user session consistently to the same backend server. If these pathways are overburdened, adding more instances (i.e., horizontal scaling) won’t help. Intelligent, task-level routing that spreads the load around (e.g., using consistent hashing4) is a better strategy for stateful systems.\n\nVertical autoscaling can be useful in stateful systems. When used in combination with task-level balancing to even out load on your system, vertical autoscaling can help absorb short-term hotspots. Use this strategy with caution: because vertical autoscaling is typically uniform across all instances, your low-traffic instances may grow unnecessarily large.\n\nConfiguring Conservatively Using autoscaling to scale up is more important and less risky than using it to scale down since a failure to scale up can result in overload and dropped traffic. By design, most autoscaler implementations are intentionally more sensitive to jumps in traffic than to drops in traffic. When scaling up, autoscalers are inclined to add extra serving capacity quickly. When scaling down, they are more cautious and wait longer for their scaling condition to hold true before slowly reducing resources.\n\nThe load spikes you can absorb increase as your service moves further away from a bottleneck. We recommend configuring your autoscaler to keep your service far from key system bottlenecks (such as CPU). Autoscaler also needs adequate time to react, particularly when new instances cannot turn up and serve instantly. We recommend that user-facing services reserve enough spare capacity for both overload protection and redundancy.5\n\nSetting Constraints Autoscaler is a powerful tool; if misconfigured, it can scale out of control. You might inadvertently trigger serious consequences by introducing a bug or changing a set‐ ting. For example, consider the following scenarios:\n\n4 See Site Reliability Engineering, Chapter 19.\n\n5 For more info about redundancy in capacity planning, see Site Reliability Engineering, Appendix B.\n\nAutoscaling\n\n|\n\n237",
      "page_number": 252
    },
    {
      "number": 30,
      "title": "Segment 30 (pages 261-270)",
      "start_page": 261,
      "end_page": 270,
      "detection_method": "topic_boundary",
      "content": "You configured autoscaling to scale based on CPU utilization. You release a new version of your system, which contains a bug causing the server to consume CPU without doing any work. Autoscaler reacts by upsizing this job again and again until all available quota is wasted.\n\nNothing has changed in your service, but a dependency is failing. This failure causes all requests to get stuck on your servers and never finish, consuming resources all the while. Autoscaler will scale up the jobs, causing more and more traffic to get stuck. The increased load on your failing dependency can prevent the dependency from recovering.\n\nIt’s useful to constrain the work that your autoscaler is allowed to perform. Set a min‐ imum and maximum bound for scaling, making sure that you have enough quota to scale to the set limits. Doing so prevents you from depleting your quota and helps with capacity planning.\n\nIncluding Kill Switches and Manual Overrides It’s a good idea to have a kill switch in case something goes wrong with your autoscaling. Make sure your on-call engineers understand how to disable autoscaling and how to manually scale if necessary. Your autoscaling kill switch functionality should be easy, obvious, fast, and well documented.\n\nAvoiding Overloading Backends A correctly configured autoscaler will scale up in response to an increase in traffic. An increase in traffic will have consequences down the stack. Backend services, such as databases, need to absorb any additional load your servers might create. Therefore, it’s a good idea to perform a detailed dependency analysis on your backend services before deploying your autoscaler, particularly as some services may scale more line‐ arly than others. Ensure your backends have enough extra capacity to serve increased traffic and are able to degrade gracefully when overloaded. Use the data from your analysis to inform the limits of your autoscaler configuration.\n\nService deployments commonly run a variety of microservices that share quota. If a microservice scales up in response to a traffic spike, it might use most of the quota. If increased traffic on a single microservice means increased traffic on other microservi‐ ces, there will be no available quota for the remaining microservices to grow. In this scenario, a dependency analysis can help guide you toward preemptively implement‐ ing limited scaling. Alternatively, you can implement separate quotas per microser‐ vice (which may entail splitting your service into separate projects).\n\n238\n\n|\n\nChapter 11: Managing Load\n\nAvoiding Traffic Imbalance Some autoscalers (e.g., AWS EC2, GCP) can balance instances across regional groups of instances (RMiGs). In addition to regular autoscaling, these autoscalers run a sepa‐ rate job that constantly attempts to even out the size of each zone across the region. Rebalancing traffic in this way avoids having one large zone. If the system you’re using allocates quota per zone, this strategy evens out your quota usage. In addition, autoscaling across regions provides more diversity for failure domains.\n\nCombining Strategies to Manage Load If your system becomes sufficiently complex, you may need to use more than one kind of load management. For example, you might run several managed instance groups that scale with load but are cloned across multiple regions for capacity; there‐ fore, you also need to balance traffic between regions. In this case, your system needs to use both load balancing and load-based autoscaling.\n\nOr maybe you run a website across three colocated facilities around the world. You’d like to serve locally for latency, but since it takes weeks to deploy more machines, overflow capacity needs to spill over to other locations. If your site gets popular on social media and suddenly experiences a five-fold increase in traffic, you’d prefer to serve what requests you can. Therefore, you implement load shedding to drop excess traffic. In this case, your system needs to use both load balancing and load shedding.\n\nOr perhaps your data processing pipeline lives in a Kubernetes cluster in one cloud region. When data processing slows significantly, it provisions more pods to handle the work. However, when data comes in so fast that reading it causes you to run out of memory, or slows down garbage collection, your pods may need to shed that load temporarily or permanently. In this case, your system needs to use both load-based autoscaling and load shedding techniques.\n\nLoad balancing, load shedding, and autoscaling are all systems designed for the same goal: to equalize and stabilize the system load. Since the three systems are often implemented, installed, and configured separately, they seem independent. However, as shown in Figure 11-8, they’re not entirely independent. The following case study illustrates how these systems can interact.\n\nCombining Strategies to Manage Load\n\n|\n\n239\n\nFigure 11-8. A full traffic management system\n\nCase Study 2: When Load Shedding Attacks Imagine a fictional company, Dressy, that sells dresses online via an app. As this is a traffic-driven service, the development team at Dressy deployed their app across three regions. This deployment allows their app to respond quickly to user requests and weather single-zone failures—or so they thought.\n\nThe customer service team at Dressy starts receiving complaints that customers can’t access the app. Dressy’s development teams investigate and notice a problem: their load balancing is inexplicably drawing all user traffic into region A, even though that region is full-to-overflowing and both B and C are empty (and equally large). The timeline of events (see Figure 11-9) is as follows:\n\n1. At the beginning of the day, the traffic graphs showed all three clusters steady at 90 RPS.\n\n2. At 10:46 a.m., traffic started to rise in all three regions as eager shoppers began hunting for bargains.\n\n3. At 11:00 a.m., region A reached 120 RPS just before regions B and C.\n\n4. At 11:10 a.m., region A continued to grow to 400 RPS, while B and C dipped to 40 RPS.\n\n5. The load balancer settled at this state.\n\n6. The majority of requests hitting region A were returning 503 errors.\n\n7. Users whose requests hit this cluster started to complain.\n\n240\n\n|\n\nChapter 11: Managing Load\n\nFigure 11-9. Regional traffic\n\nIf the development team had consulted their load balancer’s fullness graphs, they would have seen something very strange. The load balancer was utilization-aware: it was reading CPU utilization from Dressy’s containers and using this information to estimate fullness. As far as it could tell, per-request CPU utilization was 10 times lower in region A than either B or C. The load balancer determined that all regions were equally loaded, and its job was done.\n\nWhat was happening?\n\nEarlier in the week, to protect against cascading overload, the team enabled load shedding. Whenever CPU utilization reached a certain threshold, a server would return an error for any new requests it received rather than attempting to process them. On this particular day, region A reached this threshold slightly ahead of the other regions. Each server began rejecting 10% of requests it received, then 20% of requests, then 50%. During this time frame, CPU usage remained constant.\n\nAs far as the load balancer system was concerned, each successive dropped request was a reduction in the per-request CPU cost. Region A was far more efficient than regions B and C. It was serving 240 RPS at 80% CPU (the shedding cap), while B and C were managing only 120 RPS. Logically, it decided to send more requests to A.\n\nCombining Strategies to Manage Load\n\n|\n\n241\n\nWhat went wrong?\n\nIn brief, the load balancer didn’t know that the “efficient” requests were errors because the load shedding and load balancing systems weren’t communicating. Each system was added and enabled separately, likely by different engineers. No one had examined them as one unified load management system.\n\nLessons learned\n\nTo effectively manage system load, we need to be deliberate—both in the configura‐ tion of our individual load management tools and in the management of their inter‐ actions. For example, in the Dressy case study, adding error handling to the load balancer logic would have fixed the problem. Let’s say each “error” request counts as 120% CPU utilization (any number over 100 will work). Now region A looks overloa‐ ded. Requests will spread to B and C, and the system will equalize.\n\nYou can use similar logic to extrapolate this example to any combination of load management tactics. When adopting a new load management tool, carefully examine how it interacts with other tools your system is already using and instrument their intersection. Add monitoring to detect feedback loops. Make sure your emergency shutdown triggers can be coordinated across your load management systems, and consider adding automatic shutdown triggers if these systems are behaving wildly out of control. If you don’t take appropriate precautions up front, you’ll likely have to do so in the wake of a postmortem.\n\nIt is easy to say “take precautions.” More specifically, here are some precautions you might consider, depending on the kind of load management you deploy:\n\nLoad balancing\n\nLoad balancing minimizes latency by routing to the location closest to the user. Autoscaling can work together with load balancing to increase the size of loca‐ tions close to the user and then route more traffic there, creating a positive feed‐ back loop.\n\nIf demand is primarily closest to one location, that location will grow in size until all serving capacity is in one spot. If this location goes down, the remaining loca‐ tions will become overloaded and traffic may be dropped. Scaling these locations up will not be instant. You can avoid this situation by setting a minimum num‐ ber of instances per location to keep spare capacity for failover.\n\nLoad shedding\n\nIt’s a good idea to set your thresholds such that your system autoscales before load shedding kicks in. Otherwise, your system might start shedding traffic it could have served had it scaled up first.\n\n242\n\n|\n\nChapter 11: Managing Load\n\nManaging load with RPC\n\nHandling the right requests is important for efficiency: you don’t want to auto‐ scale up to serve requests that won’t benefit users, or shed load unnecessarily because you’re processing unimportant requests. When using both autoscaling and load shedding, it’s important that you set deadlines on your RPC requests.\n\nProcesses hold resources for all in-flight requests, and release those resources when the requests are completed. In the absence of a specific deadline, the system will hold resources for all in-progress requests, up to the maximum possible limit. By default, this deadline is a very large number (which depends on the lan‐ guage implementation—some language APIs work in terms of a fixed point in time, and others with a duration of time). This behavior causes clients, and ulti‐ mately users, to experience higher latency. The service is also at risk of running out of resources (like memory) and crashing.\n\nTo handle this scenario gracefully, we recommend that the server terminates requests that take too long, and that clients cancel requests that are no longer useful to them. For example, a server shouldn’t start an expensive search opera‐ tion if the client already returned an error to the user. To set behavior expecta‐ tions for a service, you could simply provide a comment in the API’s .proto file to suggest a default deadline. Also, set deliberate deadlines for the client (for exam‐ ples, see our blog post “gRPC and Deadlines”).\n\nConclusion In Google’s experience, there are no perfect traffic management configurations. Autoscaling is a powerful tool, but it’s easy to get wrong. Unless carefully configured, autoscaling can result in disastrous consequences—for example, potentially cata‐ strophic feedback cycles between load balancing, load shedding, and autoscaling when these tools are configured in isolation. As the Pokémon GO case study illus‐ trates, traffic management works best when it’s based upon a holistic view of the interactions between systems.\n\nTime and time again, we’ve seen that no amount of load shedding, autoscaling, or throttling will save our services when they all fail in sync. For example, in the Poké‐ mon GO case study, we had a “thundering herd” of synchronized client retries com‐ bined with load balancers that waited for unresponsive backend servers. To fail your services gracefully, you need to plan ahead to mitigate potential problems. Your miti‐ gation strategy might involve setting flags, changing default behaviors, enabling expensive logging, or exposing the current value of parameters the traffic manage‐ ment system uses for decisions.\n\nWe hope the strategies and insights provided in this chapter can help you manage traffic for your own services and keep your users happy.\n\nConclusion\n\n|\n\n243\n\nCHAPTER 12 Introducing Non-Abstract Large System Design\n\nBy Salim Virji, James Youngman, Henry Robertson, Stephen Thorne, Dave Rensin, and Zoltan Egyed with Richard Bondi\n\nWith responsibilities that span production operations and product engineering, SRE is in a unique position to align business case requirements and operational costs. Product engineering teams may not be aware of the maintenance cost of systems they design, especially if that product team is building a single component that factors into a greater production ecosystem.\n\nBased on Google’s experience developing systems, we consider reliability to be the most critical feature of any production system. We find that deferring reliability issues during design is akin to accepting fewer features at higher costs. By following an iterative style of system design and implementation, we arrive at robust and scala‐ ble designs with low operational costs. We call this style Non-Abstract Large System Design (NALSD).\n\nWhat Is NALSD? This chapter presents a NALSD approach: we begin with the problem statement, gather requirements, and iterate through designs that become increasingly sophisti‐ cated until we reach a viable solution. Ultimately, we arrive at a system that defends against many failure modes and satisfies both the initial requirements and additional details that emerged as we iterated.\n\nNALSD describes a skill critical to SRE: the ability to assess, design, and evaluate large systems. Practically, NALSD combines elements of capacity planning, compo‐\n\n245\n\nnent isolation, and graceful system degradation that are crucial to highly available production systems. Google SREs are expected to be able to start resource planning with a basic whiteboard diagram of a system, think through the various scaling and failure domains, and focus their design into a concrete proposal for resources. Because these systems change over time, it’s vitally important that an SRE is able to analyze and evaluate the key aspects of the system design.\n\nWhy “Non-Abstract”? All systems will eventually have to run on real computers in real datacenters using real networks. Google has learned (the hard way) that the people designing dis‐ tributed systems need to develop and continuously exercise the muscle of turning a whiteboard design into concrete estimates of resources at multiple steps in the pro‐ cess. Without this rigor, it’s too tempting to create systems that don’t quite translate in the real world.\n\nThis extra bit of work up front typically leads to fewer last-minute system design changes to account for some unforeseen physical constraint.\n\nPlease note that while we drive these exercises to discrete results (e.g., number of machines), examples of sound reasoning and assumption making are more impor‐ tant than any final values. Early assumptions heavily influence calculation results, and making perfect assumptions isn’t a requirement for NALSD. The value of this exercise is in combining many imperfect-but-reasonable results into a better under‐ standing of the design.\n\nAdWords Example The Google AdWords service displays text advertisements on Google Web Search. The click-through rate (CTR) metric tells advertisers how well their ads are perform‐ ing. CTR is the ratio of times the ad is clicked versus the number of times the ad is shown.\n\nThis AdWords example aims to design a system capable of measuring and reporting an accurate CTR for every AdWords ad. The data we need to calculate CTR is recor‐ ded in logs of the search and ad serving systems. These logs record the ads that are shown for each search query and the ads that are clicked, respectively.\n\nDesign Process Google uses an iterative approach to design systems that meet our goals. Each itera‐ tion defines a potential design and examines its strengths and weaknesses. This anal‐ ysis either feeds into the next iteration or indicates when the design is good enough to recommend.\n\n246\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design\n\nIn broad strokes, the NALSD process has two phases, each with two to three questions.\n\nIn the basic design phase, we try to invent a design that works in principle. We ask two questions:\n\nIs it possible?\n\nIs the design even possible? If we didn’t have to worry about enough RAM, CPU, network bandwidth, and so on, what would we design to satisfy the require‐ ments?\n\nCan we do better?\n\nFor any such design, we ask, “Can we do better?” For example, can we make the system meaningfully faster, smaller, more efficient? If the design solves the prob‐ lem in O(N) time, can we solve it more quickly—say, O(ln(N))?\n\nIn the next phase, we try to scale up our basic design—for example, by dramatically increasing a requirement. We ask three questions:\n\nIs it feasible?\n\nIs it possible to scale this design, given constraints on money, hardware, and so on? If necessary, what distributed design would satisfy the requirements?\n\nIs it resilient?\n\nCan the design fail gracefully? What happens when this component fails? How does the system work when an entire datacenter fails?\n\nCan we do better?\n\nWhile we generally cover these phases and questions in this approximate order, in practice, we bounce around between the questions and phases. For example, during the basic design phase, we often have growth and scaling in the back of our minds.\n\nThen we iterate. One design may successfully pass most of the phases, only to flounder later. When that happens, we start again, modifying or replacing compo‐ nents. The final design is the end of a story of twists and turns.\n\nWith these concepts in mind, let’s walk through the iterative NALSD process.\n\nInitial Requirements Each advertiser may have multiple advertisements. Each ad is keyed by ad_id and is associated with a list of search terms selected by the advertiser.\n\nWhen displaying a dashboard to an advertiser, we need to know the following for each ad and search term:\n\nAdWords Example\n\n|\n\n247\n\nHow often this search term triggered this ad to be shown\n\nHow many times the ad was clicked by someone who saw the ad\n\nWith this information, we can calculate the CTR: the number of clicks divided by the number of impressions.\n\nWe know our advertisers care about two things: that the dashboard displays quickly, and that the data is recent. Therefore, when iterating on the design, we will consider our requirements in terms of SLOs (see Chapter 2 for more details):\n\n99.9% of dashboard queries complete in < 1 second.\n\n99.9% of the time, the CTR data displayed is less than 5 minutes old.\n\nThese SLOs provide a reasonable goal that we should be able to consistently meet. They also provide an error budget (see Chapter 4 in Site Reliability Engineering), which we will compare our solution against in each iteration of the design.\n\nWe aim to create a system that can meet our SLOs and also support millions of advertisers who want to see their CTRs on a dashboard. For transaction rates, let’s assume 500,000 search queries per second and 10,000 ad clicks per second.\n\nOne Machine The simplest starting point is to consider running our entire application on a single computer.\n\nFor every web search query, we log:\n\ntime\n\nThe time the query occurred\n\nquery_id\n\nA unique query identifier (query ID)\n\nsearch_term\n\nThe query content\n\nad_id\n\nThe ad IDs of all the AdWords advertisements shown for the search\n\nTogether, this information forms the query log. Every time a user clicks an ad, we log the time of the click, the query ID, and the ad ID in the click log.\n\nYou may be wondering why we don’t simply add the search_term to the click log to reduce complexity. In the arbitrarily reduced scope of our example, this could be feasible. However, in practice, CTR is actually only one of many insights calculated\n\n248\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design",
      "page_number": 261
    },
    {
      "number": 31,
      "title": "Segment 31 (pages 271-279)",
      "start_page": 271,
      "end_page": 279,
      "detection_method": "topic_boundary",
      "content": "from these logs. Click logs are derived from URLs, which have inherent size limita‐ tions, making the separate query log a more scalable solution. Instead of proving this point by adding extra CTR-like requirements to the exercise, we will simply acknowl‐ edge this assumption and move forward.\n\nDisplaying a dashboard requires the data from both logs. We need to be able to show that we can achieve our SLO of displaying fresh data on the dashboard in under a second. Achieving this SLO requires that the speed of calculating a CTR remains con‐ stant as the system handles large amounts of clicks and queries.\n\nTo meet our SLO of displaying our dashboard in under one second, we need quick lookups of the number of clicked and shown query_ids per search_term for a given ad_id. We can extract the breakdown of shown query_ids per search_term and ad_id from the query log. A CTR dashboard needs all records from both the query log and the click log for the ad_ids.\n\nIf we have more than a few advertisers, scanning through the query log and the click log to generate the dashboard will be very inefficient. Therefore, our design calls for our one machine to create an appropriate data structure to allow fast CTR calcula‐ tions as it receives the logs. On a single machine, using an SQL database with indexes on query_id and search_term should be able to provide answers in under a second. By joining these logs on query_id and grouping by search_term, we can report the CTR for each search.\n\nCalculations\n\nWe need to calculate how many resources we need to parse all these logs. To deter‐ mine our scaling limits, we need to make some assumptions, starting with the size of the query log:\n\ntime\n\n64-bit integer, 8 bytes\n\nquery_id\n\n64-bit integer, 8 bytes\n\nad_id\n\nThree 64-bit integers, 8 bytes\n\nsearch_term\n\nA long string, up to 500 bytes\n\nOther metadata\n\n500–1,000 bytes of information, such as which machine served the ads, which language the search was in, and how many results the search term returned\n\nAdWords Example\n\n|\n\n249\n\nTo make sure we don’t prematurely hit a limit, we aggressively round up to treat each query log entry as 2 KB. Click log volume should be considerably smaller than query log volume: because the average CTR is 2% (10,000 clicks / 500,000 queries), the click log will have 2% as many records as the query log. Remember that we chose big num‐ bers to illustrate that these principles scale to arbitrarily large implementations. These estimations seem large because they’re supposed to be.\n\nFinally, we can use scientific notation to limit errors caused by arithmetic on incon‐ sistent units. The volume of query logs generated in a 24-hour period will be:\n\n(5 × 105 queries/sec) × (8.64 × 104 seconds/day) × (2 × 103 bytes) = 86.4 TB/day\n\nBecause we receive 2% as many clicks as queries, and we know that our database indexes will add some reasonable amount of overhead, we can round our 86.4 TB/day up to 100 TB of space required to store one day’s worth of log data.\n\nWith an aggregate storage requirement of ~100 TB, we have some new assumptions to make. Does this design still work with a single machine? While it is possible to attach 100 TB of disks to a single machine, we’ll likely be limited by the machine’s ability to read from and write to disk.\n\nFor example, a common 4 TB HDD might be able to sustain 200 input/output opera‐ tions per second (IOPS). If every log entry can be stored and indexed in an average of one disk write per log entry, we see that IOPS is a limiting factor for our query logs:\n\n(5 × 105 queries/sec) / (200 IOPS/disk) = 2.5 × 103 disks or 2,500 disks\n\nEven if we can batch our queries in a 10:1 ratio to limit the operations, in a best-case scenario we’d need several hundred HDDs. Considering that query log writes are only one component of the design’s IO requirements, we need to use a solution that handles high IOPS better than traditional HDDs.\n\nFor simplicity’s sake, we’ll move straight to evaluating RAM and skip the evaluation of other storage media, such as solid state disk (SSD). A single machine can’t handle a 100 TB footprint entirely in RAM: assuming we have a standard machine footprint of 16 cores, 64 GB RAM, and 1 Gbps network throughput available, we’ll need:\n\n(100 TB) / (64 GB RAM/machine) = 1,563 machines\n\nEvaluation\n\nIgnoring our calculations for a moment and imagining we could fit this design in a single machine, would we actually want to? If we test our design by asking what hap‐ pens when this component fails, we identify a long list of single points of failure (e.g.,\n\n250\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design\n\nCPU, memory, storage, power, network, cooling). Can we reasonably support our SLOs if one of these components fails? Almost certainly not—even a simple power cycle would significantly impact our users.\n\nReturning to our calculations, our one-machine design once again looks unfeasible, but this step hasn’t been a waste of time. We’ve discovered valuable information about how to reason about the constraints of the system and its initial requirements. We need to evolve our design to use more than one machine.\n\nDistributed System The search_terms we need are in the query log, and the ad_ids are in the click log. Now that we know we’ll need multiple machines, what’s the best design to join them?\n\nMapReduce\n\nWe can process and join the logs with a MapReduce. We can periodically grab the accumulated query logs and click logs, and the MapReduce will produce a data set organized by ad_id that displays the number of clicks each search_term received.\n\nMapReduce works as a batch processor: its inputs are a large data set, and it can use many machines to process that data via workers and produce a result. Once all machines have processed their data, their output can be combined—the MapReduce can directly create summaries of every CTR for every AdWords ad and search term. We can use this data to create the dashboards we need.\n\nEvaluation. MapReduce is a widely used model of computation that we are confident will scale horizontally. No matter how big our query log and click log inputs are, adding more machines will always allow the process to complete successfully without running out of disk space or RAM.\n\nUnfortunately, this type of batch process can’t meet our SLO of joined log availability within 5 minutes of logs being received. To serve results within 5 minutes, we’d need to run MapReduce jobs in small batches—just a few minutes of logs at a time.\n\nThe arbitrary and nonoverlapping nature of the batches makes small batches imprac‐ tical. If a logged query is in batch 1, and its click is in batch 2, the click and query will never be joined. While MapReduce handles self-contained batches well, it’s not opti‐ mized for this kind of problem. At this point, we could try to figure out potential workarounds using MapReduce. For simplicity’s sake, however, we’ll move on to examine another solution.\n\nAdWords Example\n\n|\n\n251\n\nLogJoiner\n\nThe number of ads that users click is significantly smaller than the number of ads served. Intuitively, we need to focus on scaling the larger of the two: query logs. We do this by introducing a new distributed system component.\n\nRather than looking for the query_id in small batches, as in our MapReduce design, what if we created a store of all queries that we can look up by query_id on demand? We’ll call it the QueryStore. It holds the full content of the query logs, keyed by query_id. To avoid repetition, we’ll assume that our calculations from the one- machine design will apply to the QueryStore and we’ll limit the review of QueryStore to what we’ve already covered. For a deeper discussion on how a component like this might work, we recommend reading about Bigtable.1\n\nBecause click logs also have the query_id, the scale of our processing loop is now much smaller: it only needs to loop over the click logs and pull in the specific queries referenced. We’ll call this component the LogJoiner.\n\nLogJoiner takes a continuous stream of data from the click logs, joins it with the data in QueryStore, and then stores that information, organized by ad_id. Once the quer‐ ies that were clicked on are stored and indexed by ad_id, we have half the data required to generate the CTR dashboard. We will call this the ClickMap, because it maps from ad_id to the clicks.\n\nIf we don’t find a query for a click (there may be a slowdown in receiving the query logs), we put it aside for some time and retry, up to a time limit. If we can’t find a query for it by that time limit, we discard that click.\n\nThe CTR dashboard needs two components for each ad_id and search_term pair: the number of impressions, and the number of ads clicked on. ClickMap needs a partner to hold the queries, organized by ad_id. We’ll call this QueryMap. QueryMap is directly fed all the data from the query log, and also indexes entries by ad_id.\n\nFigure 12-1 depicts how data flows through the system.\n\nThe LogJoiner design introduces several new components: LogJoiner, QueryStore, ClickMap, and QueryMap. We need to make sure these components can scale.\n\n1 Fay Chang et al., “Bigtable: A Distributed Storage System for Structured Data,” ACM Transactions on Com‐\n\nputer Systems (TOCS) 26, no. 2 (2008), http://bit.ly/2J22BZv.\n\n252\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design\n\nFigure 12-1. Basic LogJoiner design; the click data is processed and stored so the dash‐ board can retrieve it\n\nCalculations. From the calculations we performed in previous iterations, we know the QueryStore will be around 100 TB of data for a day of logs. We can delete data that’s too old to be of value.\n\nThe LogJoiner should process clicks as they come in and retrieve the corresponding query logs from the QueryStore.\n\nThe amount of network throughput LogJoiner needs to process the logs is based on how many clicks per second we have in our logs, multiplied by the 2 KB record size:\n\n(104 clicks/sec) × (2 × 103 bytes) = 2 × 107 = 20 MB/sec = 160 Mbps\n\nThe QueryStore lookups incur additional network usage. For each click log record, we look up the query_id and return a full log record:\n\n(104 clicks/sec) × (8 bytes) = 8 × 104 = 80 KB/sec = 640 Kbps • (104 clicks/sec) * (2 × 103 bytes) = 2 × 107 = 20 MB/sec = 160 Mbps\n\nAdWords Example\n\n|\n\n253\n\nLogJoiner will also send results to ClickMap. We need to store the query_id, ad_id, and time. search_term. time and query_id are both 64-bit integers, so that data will be less than 1 KB:\n\n(104 clicks/sec) × (103 bytes) = 107 = 10 MB/sec = 80 Mbps\n\nAn aggregate of ~400 Mbps is a manageable rate of data transfer for our machines.\n\nThe ClickMap has to store the time and the query_id for each click, but does not need any additional metadata. We’ll ignore ad_id and search_term because they are a small linear factor (e.g., number of advertisers × number of ads × 8 bytes). Even 10 million advertisers with 10 ads each is only ~800 MB. A day’s worth of ClickMap is:\n\n(104 clicks/sec) × (8.64 × 104 seconds/day) × (8 bytes + 8 bytes) = 1.4 × 1010 = 14 GB/day for ClickMap\n\nWe’ll round ClickMap up to 20 GB/day to account for any overhead and our ad_ids.\n\nAs we fill out the QueryMap, we need to store the query_id for each ad that is shown. Our storage need increases because there are potentially three ad_ids that could be clicked on for each search query, so we’ll need to record the query_id in up to three entries:\n\n3 × (5 × 105 queries/sec) × (8.64 × 104 seconds/day) × (8 bytes + 8 bytes) = 2 × 1012 = 2 TB/day for QueryMap\n\n2 TB is small enough to be hosted on a single machine using HDDs, but we know from our one-machine iteration that the individual small writes are too frequent to store on a hard drive. While we could calculate the impact of using higher IOPS drives (e.g., SSD), our exercise is focused on demonstrating that the system can scale to an arbitrarily large size. In this case, we need to design around a single machine’s IO limitations. Therefore, the next step in scaling the design is to shard the inputs and outputs: to divide the incoming query logs and click logs into multiple streams.\n\nSharded LogJoiner\n\nOur goal in this iteration is to run multiple LogJoiner instances, each on a different shard of the data.2 To this end, we need to think about several factors:\n\n2 This section is based on Rajagopal Ananthanarayanan et al., “Photon: Fault-tolerant and Scalable Joining of\n\nContinuous Data Streams,” in SIGMOD ’13: Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data (New York: ACM, 2013), http://bit.ly/2Jse3Ns.\n\n254\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design\n\nData management\n\nTo join the query logs and click logs, we must match each click log record with its corresponding query log record on the query_id. The design should prevent network and disk throughput from constraining our design as we scale.\n\nReliability\n\nWe know a machine can fail at any time. When a machine running LogJoiner fails, how do we make sure we don’t lose the work that was in progress?\n\nEfficiency\n\nCan we scale up without being wasteful? We need to use the minimum resources that meet our data management and reliability concerns.\n\nOur LogJoiner design showed that we can join our query logs and click logs, but the resulting volume of data is very large. If we divide the work into shards based on query_id, we can run multiple LogJoiners in parallel.\n\nProvided a reasonable number of LogJoiner instances, if we distribute the logs evenly, each instance receives only a trickle of information over the network. As the flow of clicks increases, we scale horizontally by adding more LogJoiner instances, instead of scaling vertically by using more CPU and RAM.\n\nAs shown in Figure 12-2, so that the LogJoiners receive the right messages, we intro‐ duce a component called a log sharder, which will direct each log entry to the correct destination. For every record, our click log sharders do the following:\n\n1. Hash the record’s query_id.\n\n2. Modulo the result with N (the number of shards) and add 1 to arrive at a number between 1 and N.\n\n3. Send the record to the shard number in step 2.\n\nFigure 12-2. How should sharding work?\n\nAdWords Example\n\n|\n\n255\n\nNow each LogJoiner will get a consistent subset of the incoming logs broken up by query_id, instead of the full click log.\n\nThe QueryMap needs to be sharded as well. We know that it will take many hard drives to sustain the IOPS required of QueryMap, and that the size of one day’s Quer‐ yMap (2 TB) is too large for our 64 GB machines to store in RAM. However, instead of sharding by query_id like the LogJoiner, we will shard on ad_id. The ad_id is known before any read or write, so using the same hashing approach as the LogJoiner and CTR dashboard will provide a consistent view of the data.\n\nTo keep implementations consistent, we can reuse the same log sharder design for the ClickMap as the QueryMap, since the ClickMap is smaller than the QueryMap.\n\nNow that we know our system will scale, we can move on to address the system’s reli‐ ability. Our design must be resilient to LogJoiner failures. If a LogJoiner fails after receiving log messages but before joining them, all its work must be redone. This delays the arrival of accurate data to the dashboard, which will affect our SLO.\n\nIf our log sharder process sends duplicate log entries to two shards, the system can continue to perform at full speed and process accurate results even when a LogJoiner fails (likely because the machine it is on fails).\n\nBy replicating the work in this way, we reduce (but do not eliminate) the chance of losing those joined logs. Two shards might break at the same time and lose the joined logs. By distributing the workload to ensure no duplicate shards land on the same machine, we can mitigate much of that risk. If two machines fail concurrently and we lose both copies of the shard, the system’s error budget (see Chapter 4 from the first SRE book) can cover the remaining risk. When a disaster does occur, we can reproc‐ ess the logs. The dashboard will show only data that’s a bit older than 5 minutes for a brief window of time.\n\nFigure 12-3 shows our design for a shard and its replica, where the LogJoiner, Click‐ Map, and QueryMap are built on both shards.\n\nFrom the joined logs, we can construct a ClickMap on each of the LogJoiner machines. To display our user dashboards, all ClickMaps need to be combined and queried.\n\nEvaluation. Hosting the sharded components in one datacenter creates a single point of failure: if either the right unlucky pair of machines or the datacenter is disconnec‐ ted, we lose all the ClickMap work, and user dashboards stop working entirely! We need to evolve our design to use more than one datacenter.\n\n256\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design\n\nFigure 12-3. Sharding of logs with same query_id to duplicate shards\n\nMultidatacenter\n\nDuplicating data across datacenters in different geographic locations allows our serv‐ ing infrastructure to withstand catastrophic failures. If one datacenter is down (e.g., because of a multiday power or network outage), we can fail over to another datacen‐ ter. For failover to work, ClickMap data must be available in all datacenters where the system is deployed.\n\nIs such a ClickMap even possible? We don’t want to multiply our compute require‐ ments by the number of datacenters, but how can we efficiently synchronize work between sites to ensure sufficient replication without creating unnecessary duplica‐ tion?\n\nWe’ve just described an example of the well-known consensus problem in distributed systems engineering. There are a number of complex algorithms for solving this problem, but the basic idea is:\n\n1. Make three or five replicas of the service you want to share (like ClickMap).\n\n2. Have the replicas use a consensus algorithm such as Paxos to ensure that we can reliably store the state of the calculations if a datacenter-sized failure occurs.\n\n3. Implement at least one network round-trip time between the participating nodes to accept a write operation. This requirement places a limit on the sequential throughput for the system. We can still parallelize some of the writes to the dis‐ tributed consensus-based map.\n\nAdWords Example\n\n|\n\n257",
      "page_number": 271
    },
    {
      "number": 32,
      "title": "Segment 32 (pages 280-288)",
      "start_page": 280,
      "end_page": 288,
      "detection_method": "topic_boundary",
      "content": "Following the steps just listed, the multidatacenter design now seems workable in principle. Will it also work in practice? What types of resources do we need, and how many of them do we need?\n\nCalculations. The latency of executing the Paxos algorithm with fault-isolated data‐ centers means that each operation needs roughly 25 milliseconds to complete. This latency assumption is based upon datacenters at least a few hundred kilometers apart. Therefore, in terms of sequential processes, we can only perform one operation per 25 milliseconds or 40 operations per second. If we need to perform sequential pro‐ cesses 104 times per second (click logs), we need at least 250 processes per datacenter, sharded by ad_id, for the Paxos operations. In practice, we’d want to add more pro‐ cesses to increase parallelism—to handle accumulated backlog after any downtime or traffic spikes.\n\nBuilding on our previous calculations for ClickMap and QueryMap, and using the estimate of 40 sequential operations per second, how many new machines do we need for our multidatacenter design?\n\nBecause our sharded LogJoiner design introduces a replica for each log record, we’ve doubled the number of transactions per second to create the ClickMap and Query‐ Map: 20,000 clicks/second and 1,000,000 queries/second.\n\nWe can calculate the minimum number of processes, or tasks, required by dividing the total queries per second by our maximum operations per second:\n\n(1.02 × 106 queries/sec) / (40 operations/sec) = 25,500 tasks\n\nThe amount of memory for each task (two copies of 2 TB QueryMap):\n\n(4 × 1012 bytes) / (25,500 tasks) = 157 MB/task\n\nTasks per machine:\n\n(6.4 × 1010 bytes) / (1.57 × 108 bytes) = 408 tasks/machine\n\nWe know we can fit many tasks on a single machine, but we need to ensure that we won’t be bottlenecked by IO. The total network throughput for ClickMap and Query‐ Map (using a high estimate of 2 KB per entry):\n\n(1.02 × 106 queries/sec) × (2 × 103 bytes) = 2.04 GB/sec = 16 Gbps\n\nThroughput per task:\n\n16 Gbps / 25,500 tasks = 80 KB/sec = 640 Kbps/task\n\n258\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design\n\nThroughput per machine:\n\n408 tasks × 640 Kbps/task = 256 Mbps\n\nOur combination of 157 MB memory and 640 Kbps per task is manageable. We need approximately 4 TB of RAM in each datacenter to host the sharded ClickMap and QueryMap. If we have 64 GB of RAM per machine, we can serve the data from just 64 machines, and will use only 25% of each machine’s network bandwidth.\n\nEvaluation. Now that we’ve designed a multidatacenter system, let’s review if the dataflow makes sense.\n\nFigure 12-4 shows the entire system design. You can see how each search query and ad click is communicated to the servers, and how the logs are collected and pushed into each component.\n\nWe can check this system against our requirements:\n\n10,000 ad clicks per second\n\nThe LogJoiner can scale horizontally to process all log clicks, and store the result in the ClickMap.\n\n500,000 search queries per second\n\nThe QueryStore and QueryMap have been designed to handle storing a full day of data at this rate.\n\n99.9% of dashboard queries complete in < 1 second\n\nThe CTR dashboard fetches data from QueryMap and ClickMap, which are keyed by ad_id, making this transaction fast and simple.\n\n99.9% of the time, the CTR data displayed is less than 5 minutes old\n\nEach component is designed to scale horizontally, meaning that if the pipeline is too slow, adding more machines will decrease the end-to-end pipeline latency.\n\nWe believe this system architecture scales to meet our requirements for throughput, performance, and reliability.\n\nAdWords Example\n\n|\n\n259\n\nFigure 12-4. Multidatacenter design\n\nConclusion NALSD describes the iterative process of system design that Google uses for produc‐ tion systems. By breaking down software into logical components and placing these components into a production ecosystem with reliable infrastructure, we arrive at systems that provide reasonable and appropriate targets for data consistency, system availability, and resource efficiency. The practice of NALSD allows us to improve our design without starting anew for each iteration. While various design iterations\n\n260\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design\n\npresented in this chapter satisfied our original problem statement, each iteration revealed new requirements, which we could meet by extending our previous work.\n\nThroughout this process, we separated software components based on how we expected the system to grow. This strategy allowed us to scale different parts of the system independently and removed dependencies on single pieces of hardware or single instances of software, thereby producing a more reliable system.\n\nThroughout the design process, we continued to improve upon each iteration by ask‐ ing the four key NALSD questions:\n\nIs it possible?\n\nCan we build it without “magic”?\n\nCan we do better?\n\nIs it as simple as we can reasonably make it?\n\nIs it feasible?\n\nDoes it fit within our practical constraints (budget, time, etc.)?\n\nIs it resilient?\n\nWill it survive occasional but inevitable disruptions?\n\nNALSD is a learned skill. As with any skill, you need to practice it regularly to main‐ tain your proficiency. Google’s experience has shown that the ability to reason from an abstract requirement to a concrete approximation of resources is critical to build‐ ing healthy and long-lived systems.\n\nConclusion\n\n|\n\n261\n\nCHAPTER 13 Data Processing Pipelines\n\nBy Rita Sodt and Igor Maravić (Spotify) with Gary Luo, Gary O’Connor, and Kate Ward\n\nData processing is a complex field that’s constantly evolving to meet the demands of larger data sets, intensive data transformations, and a desire for fast, reliable, and inexpensive results. The current landscape features data sets that are generated and collected from a variety of sources—from mobile usage statistics to integrated sensor networks to web application logs, and more. Data processing pipelines can turn these often unbounded, unordered, global-scale data sets into structured, indexed storage that can help inform crucial business decisions or unlock new product features. In addition to providing insight into system and user behavior, data processing is often business-critical. Delayed or incorrect data in your pipeline can manifest in user- facing issues that are expensive, labor-intensive, and time-consuming to fix.\n\nThis chapter starts by using product examples to examine some common types of applications of big data processing pipelines. We then explore how to identify pipe‐ line requirements and design patterns, and enumerate some best practices of manag‐ ing data processing pipelines throughout the development lifecycle. We cover tradeoffs you can make to optimize your pipeline and techniques for measuring the important signals of pipeline health. For a service to remain healthy and reliable once it’s deployed, SREs (as well as developers) should be able to navigate all of these tasks. Ideally, SREs should be involved in this work from its early stages: Google’s SRE teams regularly consult with teams developing a data processing pipeline to ensure that the pipeline can be easily released, modified, and run without causing issues for customers.\n\n263\n\nFinally, the Spotify case study provides an overview of their event delivery processing pipeline, which uses a combination of in-house, Google Cloud, and other third-party solutions to manage a complex, business-critical data processing pipeline. Whether you own a pipeline directly, or own another service that depends on the data that a pipeline produces, we hope you can use the information in this chapter to help make your pipelines (and services) more reliable.\n\nFor a comprehensive discussion of Google’s philosophies on data processing pipe‐ lines, see Chapter 25 of our first SRE book.\n\nPipeline Applications There is a wide variety of pipeline applications, each with its own strengths and use cases. A pipeline can involve multiple stages; each stage is a separate process with dependencies on other stages. One pipeline might contain multiple stages, which are abstracted away with a high-level specification. An example of this is in Cloud Data‐ flow: a user writes the business logic with a relatively high-level API, and the pipeline technology itself translates this data into a series of steps or stages where one’s output is the input of another. To give you an idea of the breadth of pipeline applications, next we describe several pipeline applications and their recommended uses. We use two example companies with different pipeline and implementation requirements to demonstrate different ways of meeting their respective data needs. These examples illustrate how your specific use case defines your project goals, and how you can use these goals to make an informed decision on what data pipeline works best for you.\n\nEvent Processing/Data Transformation to Order or Structure Data The Extract Transform Load (ETL) model is a common paradigm in data processing: data is extracted from a source, transformed, and possibly denormalized, and then “reloaded” into a specialized format. In more modern applications, this might look like a cognitive process: data acquisition from some kind of sensor (live or playback) and a selection and marshalling phase, followed by “training” of a specialized data structure (like a machine learning network).\n\nETL pipelines work in a similar way. Data is extracted from a single (or multiple) sources, transformed, and then loaded (or written) into another data source. The transformation phase can serve a variety of use cases, such as:\n\nMaking changes to the data format to add or remove a field\n\nAggregating computing functions across data sources\n\nApplying an index to the data so it has better characteristics for serving jobs that consume the data\n\n264\n\n|\n\nChapter 13: Data Processing Pipelines\n\nTypically, an ETL pipeline prepares your data for further analysis or serving. When used correctly, ETL pipelines can perform complex data manipulations and ulti‐ mately increase the efficiency of your system. Some examples of ETL pipelines include:\n\nPreprocessing steps for machine learning or business intelligence use cases\n\nComputations, such as counting how many times a given event type occurs within a specific time interval\n\nCalculating and preparing billing reports\n\nIndexing pipelines like the ones that power Google’s web search\n\nData Analytics Business intelligence refers to technologies, tools, and practices for collecting, inte‐ grating, analyzing, and presenting large volumes of information to enable better deci‐ sion making.1 Whether you have a retail product, a mobile game, or Internet of Things–connected sensors, aggregating data across multiple users or devices can help you identify where things are broken or working well.\n\nTo illustrate the data analytics use case, let’s examine a fictional company and their recently launched mobile and web game, Shave the Yak. The owners want to know how their users interact with the game, both on their mobile devices and on the web. As a first step, they produce a data analytics report of the game that processes data about player events. The company’s business leaders have requested monthly reports on the most used features of the game so they can plan new feature development and perform market analysis. The mobile and web analytics for the game are stored in Google Cloud BigQuery tables that are updated three times a day by Google Analyt‐ ics. The team set up a job that runs whenever new data is added to these tables. On completion, the job makes an entry in the company’s daily aggregate table.\n\nMachine Learning Machine learning (ML) applications are used for a variety of purposes, like helping predict cancer, classifying spam, and personalizing product recommendations for users. Typically, an ML system has the following stages:\n\n1 See Umeshwar Dayal et al., “Data Integration Flows for Business Intelligence,” in Proceedings of the 12th\n\nInternational Conference on Extending Database Technology: Advances in Database Technology (New York: ACM, 2000), 1–11.\n\nPipeline Applications\n\n|\n\n265\n\n1. Data features and their labels are extracted from a larger data set.\n\n2. An ML algorithm trains a model on the extracted features.\n\n3. The model is evaluated on a test set of data.\n\n4. The model is made available (served) to other services.\n\n5. Other systems make decisions using the responses served by the model.\n\nTo demonstrate an ML pipeline in action, let’s consider an example of a fictional company, Dressy, that sells dresses online. The company wants to increase their reve‐ nue by offering targeted recommendations to their users. When a new product is uploaded to the site, Dressy wants their system to start incorporating that product into user recommendations within 12 hours. Ultimately, Dressy would like to present users with near-real-time recommendations as they interact with the site and rate dresses. As a first step in their recommender system, Dressy investigates the follow‐ ing approaches:\n\nCollaborative\n\nShow products that are similar to each other.\n\nClustering\n\nShow products that have been liked by a similar user.\n\nContent-based\n\nShow products that are similar to other products that the user has viewed or liked.\n\nAs an online shop, Dressy has a data set of user profile information and reviews, so they opt to use a clustering filter. New products that are uploaded to their system don’t have structured data or consistent labels (e.g., some vendors may include extra information about color, size, and features of the dress using different categories and formats). Consequently, they need to implement a pipeline to preprocess the data into a format compatible with TensorFlow that joins both the product information and user profile data. The ML system includes pipelines to preprocess data from mul‐ tiple sources needed to train the model. Using the training data, Dressy’s develop‐ ment team creates a TensorFlow model to serve the appropriate recommendations to customers. Figure 13-1 shows the full ML solution. We detail each step afterward.\n\n266\n\n|\n\nChapter 13: Data Processing Pipelines\n\nFigure 13-1. ML data processing pipeline\n\n1. The development team elects to use a streaming dataflow pipeline, Google Cloud Dataflow, to preprocess the data into a format of labeled dresses by sending images to an image classification service that returns a list of characteristics.\n\n2. The team preprocesses data from multiple sources that will be used to train a model that returns the top five most similar dresses. Their workflow generates an ML model from the dress product data and purchase history from customer pro‐ files stored in BigQuery.\n\n3. They choose to use a streaming Dataflow pipeline to preprocess the data into a format of customer personalization profiles. These profiles are used as input to train a TensorFlow model. The trained TensorFlow model binary is stored in a Google Cloud Storage (GCS) bucket. Before being promoted to production, the team ensures the model passes accuracy checks when evaluated against a test set of the preprocessed data used for model evaluation.\n\n4. A service provides the recommendations for a given customer, which the web and mobile frontends use. The team uses TensorFlow with the Cloud ML online prediction service.\n\nPipeline Applications\n\n|\n\n267",
      "page_number": 280
    },
    {
      "number": 33,
      "title": "Segment 33 (pages 289-297)",
      "start_page": 289,
      "end_page": 297,
      "detection_method": "topic_boundary",
      "content": "5. A customer-facing, frontend service for making purchases serves the user data based on the up-to-date dress recommendations from the prediction service.\n\nDressy has noticed that occasionally a new model doesn’t get published for over 24 hours, and the recommendations trigger intermittent errors. This is a common issue when a new model is deployed for the first time; however, there are some simple steps you can take to resolve this problem. If you start to notice that decisions, classi‐ fications, or recommendations either aren’t being surfaced or are stale or incorrect, ask yourself:\n\nIs data stuck coming into the pipeline before it can be preprocessed to train the model?\n\nDo we have a poor ML model caused by a software bug? Is there a lot of spam? Are the features used to train the model poorly chosen?\n\nHas a new version of the ML model been recently generated, or is a stale version of the model running in production?\n\nLuckily, Dressy has a set of tools to monitor and detect an issue before their custom‐ ers experience any problems. If and when an outage occurs, these tools can help them to quickly repair or roll back any offending code. For more details on implementing monitoring and alerting, see Chapter 4.\n\nPipeline Best Practices The following pipeline best practices apply to pipelines that are run as a service (i.e., pipelines that are responsible for correctly processing data in a timely manner for consumption by other systems). Multiple steps are required to properly deploy a pipeline as a service. These steps range from defining and measuring your customer needs with an SLO, to gracefully responding to degradations and failures, to writing documentation and creating a development lifecycle that catches issues before they reach production.\n\nDefine and Measure Service Level Objectives It’s important to automatically detect when your pipeline is unhealthy and if you are failing to meet your customer’s needs. Receiving notifications when you’re in danger of exceeding your error budget (for more details on error budget, see Chapter 2) helps to minimize customer impact. At the same time, it’s important to strike a com‐ fortable balance between reliability and feature launches—your customers care about both. The remainder of this section provides examples of pipeline SLOs and how to maintain them.\n\n268\n\n|\n\nChapter 13: Data Processing Pipelines\n\nData freshness\n\nMost pipeline data freshness SLOs are in one of the following formats:\n\nX% of data processed in Y [seconds, days, minutes].\n\nThe oldest data is no older than Y [seconds, days, minutes].\n\nThe pipeline job has completed successfully within Y [seconds, days, minutes].\n\nFor example, the Shave the Yak mobile game could choose to target an SLO requiring 99% of all user actions that impact the user score to be reflected in the scoreboard within 30 minutes.\n\nData correctness\n\nCreating SLOs for data correctness ensures that you are alerted about potential data errors in your pipeline. For example, a correctness error in a billing pipeline could result in customers being charged too much or too little. A correctness target can be difficult to measure, especially if there is no predefined correct output. If you don’t have access to such data, you can generate it. For example, use test accounts to calcu‐ late the expected output. Once you have this “golden data,” you can compare expected and actual output. From there, you can create monitoring for errors/ discrepancies and implement threshold-based alerting as test data flows through a real production system.\n\nAnother data correctness SLO involves backward-looking analysis. For example, you might set a target that no more than 0.1% of your invoices are incorrect per quarter. You might set another SLO target for the number of hours/days that bad data or errors are served from the pipeline output data. The notion of data correctness varies by product and application.\n\nData isolation/load balancing\n\nSometimes you will have segments of data that are higher in priority or that require more resources to process. If you promise a tighter SLO on high-priority data, it’s important to know that this data will be processed before lower-priority data if your resources become constrained. The implementation of this support varies from pipe‐ line to pipeline, but often manifests as different queues in task-based systems or dif‐ ferent jobs. Pipeline workers can be configured to take the highest available priority task. There could be multiple pipeline applications or pipeline worker jobs running with different configurations of resources—such as memory, CPU, or network tiers— and work that fails to succeed on lower provisioned workers could be retried on higher provisioned ones. In times of resource or system constraints, when it’s impos‐ sible to process all data quickly, this separation allows you to preferentially process higher-priority items over lower ones.\n\nPipeline Best Practices\n\n|\n\n269\n\nEnd-to-end measurement\n\nIf your pipeline has a series of stages, it can be tempting to measure a per-stage or per-component SLO. However, measuring SLOs in this fashion doesn’t capture your customer’s experience or the end-to-end health of your system. For example, imagine you have an event-based pipeline such as Google Analytics. The end-to-end SLO includes log input collection and any number of pipeline steps that happen before data reaches the serving state. You could monitor each stage individually and offer an SLO on each one, but customers only care about the SLO for the sum of all stages. If you’re measuring SLOs for each stage, you would be forced to tighten your per- component alerting, which could result in more alerts that don’t model the user experience.\n\nAdditionally, if you measure data correctness only per stage, you could miss end-to- end data corruption bugs. For example, each stage in your pipeline could report that all is well, but one stage introduces a field that it expects a downstream job to process. This upstream stage assumes that the extra data has been processed and used to serve requests to users. A downstream job doesn’t expect the additional field, so it drops the data. Both jobs think they are correct, but the user doesn’t see the data.\n\nPlan for Dependency Failure Once you define your SLO, it’s good practice to confirm that you aren’t overdepend‐ ing on the SLOs/SLAs of other products that fail to meet their commitments. Many products, such as Google Cloud Platform, list their SLA promises on their sites. Once you identify any third-party dependencies, at a minimum, design for the largest fail‐ ure accounted for in their advertised SLAs. For example, when defining an SLO, the owner of a pipeline that reads or writes data to Cloud Storage would ensure that the uptimes and guarantees advertised are appropriate. If the single-region uptime guar‐ antee was less than required by the pipeline to meet its SLO on data processing time, the pipeline owner may choose to replicate the data across regions to get the higher availability.\n\nWhen a service provider’s infrastructure breaks its SLAs, the result can negatively impact dependent pipelines. If your pipeline depends on more strict guarantees than the service provider advertises, your service could fail even if the service provider remains within their SLA. Sometimes, realistically planning for dependency failure can mean accepting a lower level of reliability and offering a looser SLA to your customers.2\n\n2 For more details about factoring dependencies into your service’s reliability, see Ben Treynor et al., “The Cal‐ culus of Service Availability,” ACM Queue 15, no. 2 (2017), https://queue.acm.org/detail.cfm?id=3096459.\n\n270\n\n|\n\nChapter 13: Data Processing Pipelines\n\nAt Google, to encourage pipeline development with dependency failure in mind, we stage planned outages. For example, many pipelines at Google depend on the availa‐ bility of the datacenter where they run. Our Disaster Recovery Testing (DiRT) fre‐ quently targets these systems, simulating a regional outage. When a regional outage occurs, pipelines that have planned for failure automatically fail over to another region. Other pipelines are delayed until the operator of the failed pipeline is alerted by their monitoring and manually fails over. Successful manual failover assumes that the pipeline can obtain enough resources to bring up a production stack in another region. In a best-case scenario, an unsuccessful manual failover prolongs an outage. In a worst-case scenario, processing jobs may have continued processing stale data, which introduces out-of-date or incorrect data in any downstream pipelines. Recov‐ ery tactics from an incident like this vary depending on your setup. For example, if correct data was overwritten with incorrect data, you may have to restore data from a previous backup version and reprocess any missing data.\n\nIn summary, it’s good practice to prepare for the day when the systems you depend on are unavailable. Even the best products will fail and experience outages. Regularly practice disaster recovery scenarios to ensure your systems are resilient to common and uncommon failures. Assess your dependencies and automate your system responses as much as possible.\n\nCreate and Maintain Pipeline Documentation When well written and maintained, system documentation can help engineers visual‐ ize the data pipeline and its dependencies, understand complex system tasks, and potentially shorten downtime in an outage. We recommend three categories of docu‐ mentation for your pipeline.\n\nSystem diagrams\n\nSystem diagrams, similar to Figure 13-2, can help on-call engineers quickly find potential failure points. At Google, we encourage teams to draw system diagrams that show each component (both pipeline applications and data stores), and the transfor‐ mations that happen at each step. Each of the components and transformations shown in your diagram can get stuck, causing data to stop flowing through the sys‐ tem. Each component can also introduce a software or application configuration bug that impacts data correctness.\n\nA system diagram should contain quick links to other monitoring and debugging information at different pipeline stages. Ideally, these links should pull from live monitoring information, displaying the current status of each stage (e.g., waiting for dependent job to finish/processing/complete). Displaying historical runtime infor‐ mation can also indicate if a pipeline stage is taking longer than expected. This delay can foreshadow performance degradation or an outage.\n\nPipeline Best Practices\n\n|\n\n271\n\nFinally, even in complex systems, a system diagram makes it easier for developers to analyze data dependencies they should be aware of during feature launches.\n\nFigure 13-2. Pipeline system diagram (PII = personally identifiable information)\n\nProcess documentation\n\nIt’s important to document how to perform common tasks, such as releasing a new version of a pipeline or introducing a change to the data format. Ideally, you should also document less common (often manual) tasks, such as initial service turnup or final service turndown in a new region. Once your tasks are documented, investigate the possibility of automating away any manual work. If the tasks and system are auto‐ mated, consider generating your documentation directly from the source so you can keep both in sync.\n\nPlaybook entries\n\nEach alert condition in your system should have a corresponding playbook entry that describes the steps to recovery. At Google, we find it useful to link this documenta‐ tion in any alert messages sent to on-call engineers. Playbook entries are discussed in more detail in Chapter 11 of our first book.\n\nMap Your Development Lifecycle As shown in Figure 13-3, the development lifecycle of a pipeline (or a change to a pipeline) isn’t too different from the development lifecycle of other systems. This sec‐ tion follows a typical release flow through each stage of the pipeline development lifecycle.\n\nFigure 13-3. Pipeline development lifecycle with release workflow\n\n272\n\n|\n\nChapter 13: Data Processing Pipelines\n\nPrototyping\n\nThe first phase of development involves prototyping your pipeline and verifying semantics. Prototyping ensures that you can express the business logic necessary to execute your pipeline. You may discover that one programming language allows you to better express your business logic, or that a particular language more easily inte‐ grates with your existing libraries. A particular programming model may suit your specific use case (e.g., Dataflow versus MapReduce, batch versus streaming). For an example of a completed programming model comparison, see our blog post “Data‐ flow/Beam & Spark: A Programming Model Comparison”. If you are adding a feature to an existing pipeline, we recommend adding your code and running unit tests in the prototype stage.\n\nTesting with a 1% dry run\n\nOnce you have completed your prototype, it’s helpful to run a small setup on the full stack using production data. For example, run your pipeline using an experimental set, or a 1% dry run of production data in a nonproduction environment. Gradually scale up, tracking your pipeline performance to ensure you don’t encounter any bot‐ tlenecks. When your product has launched to customers, run performance tests. These tests are an integral development step that helps prevent outages caused by new feature rollouts.\n\nStaging\n\nBefore deploying to production, it’s useful to run your system in a preproduction (or staging) environment. The data in your staging environment should be as close to actual production data as possible. We recommend keeping a full copy of production data or at least a representative subset. Unit tests won’t catch all pipeline issues, so it’s important to let the data flow through the system end-to-end to catch integration issues.\n\nIntegration tests can also identify errors. Using both unit and integration tests, run an A/B comparison of your newly generated data to previously generated known good data. For example, check your previous release for expected or unexpected differ‐ ences before certifying the release and marking it ready to move to production.\n\nCanarying\n\nPipeline testing and verification requires more time and care than stateless jobs—the data is persisted and the transformations are often complex. If something goes wrong in your production release, it’s important to catch the issue early so you can limit the impact. Canarying your pipeline can help! Canarying is a process whereby you parti‐ ally deploy your service (in this case, the pipeline application) and monitor the results. For a more detailed discussion of canarying, see Chapter 16. Canarying is tied\n\nPipeline Best Practices\n\n|\n\n273\n\nto the entire pipeline rather than a single process. During a canary phase, you may choose to process the same real production data as the live pipeline but skip writes to production storage; techniques such as two-phase mutation can help (see the section “Idempotent and Two-Phase Mutations” on page 279). Often, you’ll have to wait for the complete cycle of processing to finish before you can discover any customer- impacting issues. After your dry run (or two-phase mutation), compare the results of your canary pipeline with your live pipeline to confirm their health and check for data differences.\n\nSometimes it is possible to progress through the canary by gradually updating tasks of a job or by updating first in one region and then another, but this is not always possible with pipelines. Pipelines that use replicated data, such as Dataproc3 and Dataflow,4 support regional endpoints5 and prevent this kind of canary progression— you can’t reload one cell in isolation from another. If you run a multihomed pipeline, it may not be possible to deploy to a single region (or a percentage of servers) like you might with a serving job. Instead, perform a rollout for a small percentage of data first, or as described earlier, roll out in dry-run mode first.\n\nDuring verification of your canary or preproduction environment, it is important to assess the health of your pipeline. Usually, you can use the same metrics you use to track your SLOs. Verifying your canary is a task that lends itself well to automation.\n\nPerforming a partial deployment\n\nIn addition to canarying your changes, you may also want to perform a partial deployment, particularly if there is a major feature launch or change that could impact system performance and resource usage. It can be difficult to predict the impact of these kinds of launches without first testing your changes on a subset of real traffic. You can implement a partial deployment as a flag or configuration option in your pipeline that accepts an allowed subset of data. Consider first processing your new features on one or two accounts, then gradually ramping up the amount of data (e.g., ~1%, ~10%, ~50%, and finally, 100% of your sample data).\n\n3 Cloud Dataproc is a fully managed cloud service for running Apache Spark and Apache Hadoop clusters.\n\n4 Cloud Dataflow is a fully managed cloud service for transforming data in stream and batch modes, with equal\n\nreliability and expressiveness.\n\n5 Regional endpoints control workers, and store and handle metadata for a Cloud Dataflow job.\n\n274\n\n|\n\nChapter 13: Data Processing Pipelines\n\nThere are a number of ways your partial deployment can go wrong: the input data might be incorrect or delayed, your data processing might have a bug, or your final storage might have an error. Any of these issues can result in an outage. Avoid promoting a corrupt set of data to your low-latency frontends. Aim to catch these types of issues as early as possible, before they reach your users.\n\nDeploying to production\n\nOnce you have fully promoted your new pipeline binaries and/or config to produc‐ tion, you should be reasonably confident that you’ve vetted any potential issues (and if an issue does occur, that your monitoring will alert you). If your deployment goes wrong, be able to quickly restore from a known good state (e.g., roll back the binar‐ ies) and mark any potentially broken data as bad (e.g., replace the bad data with data from a previous backup version, make sure no jobs read the affected data, and/or reprocess the data if necessary).\n\nReduce Hotspotting and Workload Patterns Hotspotting happens when a resource becomes overloaded from excessive access, resulting in an operation failure. Pipelines are susceptible to workload patterns—both through reads and writes—that can cause delays in isolated regions of data. Some common examples of hotspotting include:\n\nErrors thrown because multiple pipeline workers are accessing a single serving task, causing overload.\n\nCPU exhaustion due to concurrent access to a piece of data that is available on only one machine. Often, the internals of your data storage have a lowest level of granularity that may become unavailable if accessed heavily (e.g., a Spanner tab‐ let can become overloaded due to a problematic section of data even though most of the data storage is fine).\n\nLatency due to row-level lock contention in a database.\n\nLatency due to concurrent access to a hard drive, which exceeds the physical abil‐ ity of the drive head to move fast enough to quickly locate the data. In this case, consider using solid state drives.\n\nA large work unit that requires many resources.\n\nHotspotting can be isolated to a subset of data. To combat hotspotting, you can also block fine-grained data such as individual records. If that data is blocked, the rest of the pipeline can progress. Typically, your infrastructure can provide this functional‐ ity. If a chunk of processing work is consuming a disproportionate amount of resour‐ ces, the pipeline framework can dynamically rebalance by breaking the work into smaller pieces. To be safe, it’s still best to build an emergency shutdown into your\n\nPipeline Best Practices\n\n|\n\n275\n\nclient logic to allow you to stop processing and isolate fine-grained chunks of pro‐ cessing work characterized by large resource usage or errors. For example, you should be able to quickly set a flag or push a config that allows you to skip input data that matches a certain pattern or problematic user.\n\nOther strategies to reduce hotspotting include:\n\nRestructuring your data or access patterns to spread the load evenly\n\nReducing the load (e.g., statically allocate some or all of your data)\n\nReducing lock granularity to avoid data lock contention\n\nImplement Autoscaling and Resource Planning Spikes in workload are common and can lead to service outages if you’re unprepared for them. Autoscaling can help you handle these spikes. By using autoscaling, you don’t have to provision for peak load 100% of the time (for more details on autoscal‐ ing, see Chapter 11). Constantly running the number of workers required for peak capacity is an expensive and inefficient use of resources. Autoscaling turns down idle workers so you won’t pay for resources you don’t need. This strategy is particularly important for streaming pipelines and workloads that are variable. Batch pipelines may run simultaneously and will consume as many resources as are available.\n\nPredicting the future growth of your system and allocating capacity accordingly ensures that your service won’t run out of resources. It’s also important to weigh the cost of resources against the engineering effort needed to make the pipeline more efficient. When conducting resource planning with an estimate of future growth, keep in mind that costs may not be isolated to just running your pipeline job. You may also be paying the data storage and network bandwidth costs for replicating data across regions or cross-region writes and reads. Additionally, some data store systems are more expensive than others. Even though unit storage costs are low, these costs can quickly add up for very large data sets or expensive data access patterns that use a lot of computing resources on the storage servers. It’s good practice to help drive down costs by periodically examining your data set and pruning unused content.\n\nAlthough the effectiveness of a series of pipeline stages should be measured according to its end-to-end SLO, the pipeline efficiency and resource usage should be measured at each individual stage. For example, imagine that you have many jobs using Big‐ Query and notice a significant increase in BigQuery resource usage after a release. If you can quickly determine which jobs are responsible, you can focus your engineer‐ ing effort on those jobs to drive down costs.\n\n276\n\n|\n\nChapter 13: Data Processing Pipelines",
      "page_number": 289
    },
    {
      "number": 34,
      "title": "Segment 34 (pages 298-306)",
      "start_page": 298,
      "end_page": 306,
      "detection_method": "topic_boundary",
      "content": "Adhere to Access Control and Security Policies Data flows through your system and is often persisted along the way. When manag‐ ing any persisted data, we recommend you adhere to the following privacy, security, and data integrity principles:\n\nAvoid storing personally identifiable information (PII) in temporary storage. If you’re required to store PII temporarily, make sure the data is properly encrypted.\n\nRestrict access to the data. Grant each pipeline stage only the minimal access it needs to read the output data from the previous stage.\n\nPut time to live (TTL) limits on logs and PII.\n\nConsider a BigQuery instance that is tied to a GCP project whose access permissions can be managed with Google Cloud Identity and Access Management (e.g., the Dressy example described earlier). Creating different projects and instances per func‐ tion allows more fine-grained scoping to restrict access. Tables can have a master project and cross-create views among client projects to allow them controlled access. For example, Dressy has restricted access to tables containing sensitive customer information for jobs from specific project roles.\n\nPlan Escalation Paths It is important to design your pipeline to be resilient so that a system failure (like a machine or zonal outage) never triggers an SLO violation page. By the time you get paged, you need to manually intervene because all automated measures have been exhausted. If you have well-defined SLOs and reliable metrics and alert detection, you’ll be alerted before your customers notice or report issues. When an SLO is viola‐ ted, it’s important to respond quickly and send proactive communication to your customers.\n\nPipeline Requirements and Design Today’s market provides many pipeline technology and framework options, and it can be overwhelming to identify which one best suits your use case. Some platforms provide fully managed pipelines. Others give you more flexibility but require more hands-on management. In SRE, we often take a significant amount of time during the design phase to assess which technology is the best fit. We compare and contrast the various design options based on user needs, product requirements, and system con‐ straints. This section discusses tools you can use to both assess your pipeline technol‐ ogy options and make improvements to existing pipelines.\n\nPipeline Requirements and Design\n\n|\n\n277\n\nWhat Features Do You Need? Table 13-1 provides a list of features we recommend you optimize for when manag‐ ing a data processing pipeline. Some of these features may already be present in your existing pipeline technology (e.g., via managed pipeline platforms, client application logic, or operational tools). Your application may not need some of these features— for example, you don’t need “exactly once” semantics if your work units are idempo‐ tent and can be performed more than once for the same result.\n\nTable 13-1. Recommended data pipeline features\n\nPipeline item Latency\n\nData correctness\n\nFeature Use an API that supports streaming, batch, or both. Streaming processing is generally better than batch processing at supporting lower-latency applications. If you choose batch but might at some point want streaming, an API that is interchangeable may reduce the migration cost later. Exactly-once semantics globally. You can require that data is processed (at most) once to get correct results. Two-phase mutations. Windowing functions for event processing and aggregations. You may want fixed time, session, or sliding windows to divide data (since data is not always processed in the order in which it’s received). You may also want in-order guarantees. Black-box monitoring. The ability to control the flow of multiple jobs or stages of your pipeline. This control should allow you to gate a job until another completes so the job does not process incomplete data.\n\nHigh availability\n\nMultihoming. Autoscaling.\n\nMean Time to Resolve (MTTR) incidents in data processing\n\nMean Time to Detect (MTTD) outages Development lifecycle to prevent errors from reaching production Inspect and predict resource usage or cost Ease of development\n\nTie your code changes to a release, which allows for fast rollbacks. Have tested data backup and restore procedures in place. In the event of an outage, ensure that you can easily drain a region from serving or processing. Have useful alert messages, dashboards, and logs for debugging. In particular, your monitoring should be quick to identify the reason(s) why a pipeline is delayed and/or why data is corrupt. Use data checkpointing to help recover faster when a pipeline is interrupted. Ensure you have SLO monitoring in place. Monitoring out-of-SLO alerts allows you to detect issues that impact your customers. Alerting on the symptom (versus the cause) reduces monitoring gaps. We recommend running any changes in a canary environment before deploying to production. This strategy lowers the possibility of a change impacting SLOs in production.\n\nCreate (or use an existing) resource accounting dashboard. Be sure to include resources like storage and network. Create a metric that allows you to correlate or predict growth.\n\nSupport a language that best fits your use case. Often pipeline technologies limit your options to one or two languages. Use a simple API for defining data transformations and expressing your pipeline logic. Consider the tradeoff between simplicity and flexibility. Reuse base libraries, metrics, and reporting. When you’re creating a new pipeline, reusable resources allow you to focus development on any new business logic.\n\n278\n\n|\n\nChapter 13: Data Processing Pipelines\n\nPipeline item Ease of operation\n\nFeature Use existing automation and operational tools as much as possible. Doing so reduces operational costs, as you don’t need to maintain your own tools. Automate as many operational tasks as possible. Larger tasks that are performed infrequently may include a chain of dependencies and prerequisites that can be too numerous or complex for a human to assess in a timely manner (e.g., moving your data and pipeline stack from region A to region B, then turning down region A). To ease a transition like this, consider investing in automation. Perhaps introduce some pipeline health checks on the pipeline stack in region B before putting it into production.\n\nIdempotent and Two-Phase Mutations Pipelines can process large amounts of data. When a pipeline fails, some data must be reprocessed. You can use the idempotent mutations design pattern to prevent storing duplicate or incorrect data. An idempotent mutation is a type of mutation that can be applied multiple times with the same result. Implementing this design pattern allows separate executions of a pipeline with the same input data to always produce the same result.\n\nWhen testing or canarying a pipeline, you need to know if your applied mutations are acceptable to the pipeline owner according to the expected output. The two-phase mutation design pattern can help here. Typically, the data is read from a source and transformed, and then a mutation is applied. With two-phase mutation, the muta‐ tions themselves are stored in a temporary location. A separate verification step (or pipeline) can run against these potential mutations to validate them for correctness. A follow-up pipeline step applies the verified mutations only after the mutations pass validation. Figure 13-4 shows an example of two-phase mutation.\n\nFigure 13-4. Two-phase mutation\n\nCheckpointing Typically, pipelines are long-running processes that analyze or mutate large amounts of data. Without special consideration, pipelines that are terminated early will lose their state, requiring the entire pipeline to be executed again. This is especially true\n\nPipeline Requirements and Design\n\n|\n\n279\n\nfor pipelines that create AI models, as each iteration of the model calculation relies on previous calculations. Checkpointing is a technique that enables long-running pro‐ cesses like pipelines to periodically save partial state to storage so that they can resume the process later.\n\nWhile checkpointing is often used for the failure case, it’s also useful when a job needs to be preempted or rescheduled (e.g., to change CPU or RAM limits). The job can be cleanly shut down, and upon rescheduling, it’s able to detect which work units have already been processed. Checkpointing has the added advantage of enabling a pipeline to skip potentially expensive reads or computations because it already knows the work is done.\n\nCode Patterns Some common code patterns can make your pipelines more efficient to manage and reduce the effort required to make changes or updates.\n\nReusing code\n\nIf you operate multiple similar pipelines and want to implement a new monitoring capability or metric, you have to instrument each separate system. This common workflow isn’t difficult if you use the right strategy. Implementing reusable code libraries allows you to add a metric for monitoring in one place and share it across multiple pipelines or stages. Shared libraries allow you to:\n\nGain insight across all data pipelines in a standard way.\n\nReuse other data analytics systems for each pipeline (e.g., a traffic report that works for all of your pipelines).\n\nAlert on the same metric for multiple jobs, such as a generic data freshness alert.\n\nUsing the microservice approach to creating pipelines\n\nWhen using microservices, it’s important to have a service perform a single task and do it well. It’s easier to operate a group of microservices that use the same core libra‐ ries, varying only in their business logic, than it is to operate many custom services. A similar pattern can apply to pipelines. Instead of creating one monolithic pipeline application, create smaller pipelines that you can release and monitor separately. In doing so, you will get the same benefits as you get from a microservices architecture.\n\n280\n\n|\n\nChapter 13: Data Processing Pipelines\n\nPipeline Production Readiness As discussed in Chapter 18, a PRR (Production Readiness Review) is the process that Google SRE teams use to onboard a new service. In the same spirit, we use a pipeline maturity matrix when consulting on the choice or design of a pipeline technology.\n\nPipeline maturity matrix\n\nThe matrix in Table 13-2 measures five key characteristics (but you can extend the matrix to measure other characteristics you wish to optimize or standardize for):\n\nFailure tolerance\n\nScalability\n\nMonitoring and debugging\n\nTransparency and ease of implementation\n\nUnit and integration testing\n\nThe maturity matrix represents the collective knowledge of many pipeline experts at Google. These individuals are responsible for running pipelines across multiple Goo‐ gle products and productionizing the associated systems.\n\nEach characteristic is measured on a scale of 1 to 5, where 1 represents “Chaotic” (unplanned, ad hoc, risky, fully manual) and 5 represents “Continuous improve‐ ment.” To score your system, read the descriptions for each characteristic below, and select the best matching milestone. If more than one milestone applies, use the score in the middle (i.e., 2 or 4). A completed scoresheet will give you a clear picture of where your system needs improvement.\n\nWe recommend that you spend the time to make improvements in any weak areas identified by the matrix. Instrumenting monitoring, alerting, and other tooling rec‐ ommended by the matrix can be time-intensive. When making improvements, you can start by looking for existing products or open source tools that fit your needs instead of creating your own. At Google, we encourage teams to use existing pipeline technologies or tools that provide out-of-the-box pipeline support and features. The more tools and processes that can be reused, the better.\n\nPipeline Requirements and Design\n\n|\n\n281\n\nTable 13-2. Pipeline maturity matrix, with example milestones for beginning, medium, and advanced maturity\n\n1. Chaotic\n\n3. Functional\n\n5. Continuous improvement\n\nFailure tolerance Failover\n\nGlobal work scheduling\n\nFailed task management\n\nNo support for failover\n\nNo support for global work scheduling, multihoming, or failover\n\nNo support for failed work units\n\nSome support for work unit retries (even if manual) Support for hot/hot/hot processing (process same work in all three regions so if any region is unavailable, there is at least one still running) —\n\nMultihomed with automatic failover\n\nSupport for effective warm/warm/ warm processing (distribute work in all three regions and store work centrally to deal with any region loss)\n\nAutomatic retries for failed work units Automatic quarantine of bad work units\n\nScalability Automatic scaling of available worker pool\n\nAutomatic dynamic resharding to effect balanced load across the pool Load shedding/task prioritization\n\nNo autoscaling; manual intervention required\n\nWork units are fixed with no ability to make changes\n\nNo work unit prioritization exists\n\nAutoscaling works with the use of additional manual tools\n\nSupports manual resharding of work, or resharding can be achieved automatically with additional code Some capability for work unit prioritization\n\nBuilt-in automatic autoscaling support with no requirement for configuration inside a third-party tool Built-in support for dynamic subsharding to balance work across the available worker pool\n\nAn easy-to-use feature for work unit prioritization exists Built-in support for load shedding Workers understand preemption notification, after which a worker will clean up (finish work/mitigate)\n\nMonitoring and debugging Debugging tools and capabilities\n\nNo logs; no way to identify or track failed work units\n\nThere is a solution to identify a failed work unit and extract associated logs\n\nThere is a solution that allows a user to access logs for the time at which the work unit failed; this data is retrieved directly from the failed work unit There is a solution to automatically quarantine and replay a failed work unit\n\n282\n\n|\n\nChapter 13: Data Processing Pipelines\n\nDashboards and visualizations\n\n1. Chaotic No dashboards or visualization solutions that support the display of pipeline information\n\n3. Functional There is an easy-to-configure dashboard showing the following information:\n\nNumber of work units in various stages of completion\n\nLatency and aging\n\ninformation for each stage\n\nEase of implementation and transparency No feature for Discoverability discoverability (a list of the pipelines that are running and their status) Significant setup cost for using the technology\n\nSome support for discoverability; manual setup might be required, or not all pipelines are discoverable Some reusable components available\n\nCode\n\n5. Continuous improvement A fine-grained visualization of the entire execution map for a pipeline A visualization for delays up to each stage A visualization and rationale for throttling and pushback Information about limiting factors due to resource usage Information about the distribution of internal state worker machines (e.g., stack graph) Information about how many work units are failing, stuck, or slow Historical run statistics are presented and preserved Built-in support for automatic discoverability; a global data registry service that allows the listing of configured pipelines Base frameworks are available and require minimum code The pipeline can be configured in machine-readable format Zero config Libraries with semantics similar to other pipeline solutions that are most heavily used in related teams\n\nDocumentation and best practices\n\nSparse or outdated documentation\n\nMinimal setup documentation for each component\n\nComprehensive and up-to-date documentation Training examples for new users\n\nUnit and integration testing Unit testing framework\n\nNo support or unit testing framework\n\nTests take a long time to run and frequently time out Too many resource requirements No code coverage support Easy to switch data sources to test a resource\n\nRuns with sanitizers (ASAN, TSAN, etc.) The build dependency graph is as small as possible Code coverage support Provides debugging info and results No external dependencies Built-in test data generation library\n\nPipeline Requirements and Design\n\n|\n\n283\n\nEase of configuration (this has direct relevance to the scalability aspect of the pipeline)\n\nSupport for integration testing frameworks (this describes how well a pipeline should interact and support various integration testing methodologies, which are not necessarily part of the pipeline itself)\n\n1. Chaotic Test configuration is not supported or requires a significant amount of time to learn, in addition to learning about the pipeline itself—for example, testing uses a different programming language and a different API than the pipeline Using Cloud or third-party open source tools for diffing, monitoring, integration testing, and so on, can be difficult to implement and/or resource-intensive; requires in-house tools or tools do not exist\n\n3. Functional The first integration test requires significant setup, but subsequent tests are either a copy/paste or an extension to the first with minimal overrides —for example, a test data generator could be minimally tweaked to support collecting test data for many different pipeline applications Minimal documentation and examples of integration testing tools and methodologies used in conjunction with the pipeline Large amount of time required even for data sets with minimal input Difficult to trigger on-demand execution for testing scenarios Difficult to separate production from nonproduction concerns (e.g., all event logs go to production logging service)\n\n5. Continuous improvement Decoupling from production configuration, while not preventing reuse; easier to define integration test configuration and reuse relevant parts of prod configuration\n\nBuilt-in support for scaled-down input data Support for diffing of output data (e.g., persisting output test data) Configurable monitoring for test run validation Ample documentation and examples of integration tests built for the pipeline\n\nPipeline Failures: Prevention and Response A pipeline can fail for many reasons, but the most common culprits are data delay and data corruption. When an outage occurs, finding and repairing the issue quickly will greatly reduce its impact. At Google, when an outage or SLO violation occurs, we track metrics for MTTD and MTTR. Tracking these metrics indicates how effective we are at detecting and repairing an issue. In the postmortem that follows any outage at Google, we analyze the cause of the outage to elicit any patterns and address sour‐ ces of operational toil.\n\nThis section describes some common failure modes, methods to effectively respond to pipeline failures, and strategies to help you prevent future pipeline failures.\n\nPotential Failure Modes\n\nDelayed data\n\nA pipeline can fail if its input or output is delayed. Without the proper precautions, a downstream job may start running even though it doesn’t have the necessary data. Stale data is almost always better than incorrect data. If your pipeline processes incomplete or corrupt data, errors will propagate downstream. Restoring or reproc‐ essing bad data takes time and can prolong an outage. Instead, if your pipeline stalls,\n\n284\n\n|\n\nChapter 13: Data Processing Pipelines\n\nwaits for data, and then resumes once the data becomes available, the data remains high quality. Creating data dependencies that are respected by all stages is important.\n\nDepending on the type of pipeline, the impact of delayed data can range from stale application data to stalled pipelines. In batch processing pipelines, each stage waits for its predecessor to finish before it begins. Streaming systems are more flexible: using event-time processing, such as Dataflow, a downstream stage can start a por‐ tion of work as soon as the corresponding upstream portion completes, rather than waiting for all portions to complete.\n\nWhen an outage of this nature occurs, you will likely need to notify any dependent services. If the outage is user-visible, you may also have to notify your customers. When you’re debugging pipeline outages, it’s helpful to see the progress of current and past pipeline runs, and to have direct links to log files and a diagram of the flow of data. It’s also useful to be able to trace a unit of work through the system while analyzing its counters and statistics.\n\nCorrupt data\n\nIf undetected, corrupt pipeline data (input and/or output) can cause user-facing issues. You can circumvent many user-facing issues by having tests that identify corrupt data in place, and using logic that alerts you to potential corruption. For example, pipeline systems can implement blocking policies and abuse/spam detection to automatically or manually filter out bad sources of data.\n\nCorrupt data can have many causes: software bugs, data incompatibility, unavailable regions, configuration bugs, and so on. There are two main steps involved in fixing corrupt data:\n\n1. Mitigate the impact by preventing further corrupt data from entering the system.\n\n2. Restore your data from a previously known good version, or reprocess to repair the data.\n\nIf a single region is serving corrupt data, you may need to drain your serving jobs and/or data processing from that region. If a software or configuration bug is at fault, you may need to quickly roll back the relevant binary. Often, data corruption can cause windows of data that are incorrect and need to be reprocessed once the under‐ lying issue has been fixed, such as fixing a software bug in a pipeline binary. To reduce the cost of reprocessing, consider selective reprocessing—read in and process only the user or account information impacted by the data corruption. Alternatively, you could persist some intermediate data that can serve as a checkpoint to avoid reprocessing a pipeline from end to end.\n\nIf the output of your pipeline is corrupt, downstream jobs may propagate the corrupt data or serving jobs may serve incorrect data. Even with the best testing, develop‐\n\nPipeline Failures: Prevention and Response\n\n|\n\n285",
      "page_number": 298
    },
    {
      "number": 35,
      "title": "Segment 35 (pages 307-314)",
      "start_page": 307,
      "end_page": 314,
      "detection_method": "topic_boundary",
      "content": "ment, and release practices in place, a software or configuration bug can introduce data corruption. We recommend that you plan for this eventuality and have the abil‐ ity to quickly reprocess and restore your data. Recovering from this kind of data cor‐ ruption is labor-intensive and difficult to automate.\n\nPotential Causes\n\nPipeline dependencies\n\nWhen you’re trying to determine the cause of an outage, it’s useful to investigate pipeline dependencies, such as storage, network systems, or other services. These dependencies may be throttling your requests/traffic or, if they are out of resources, refusing any new data. The rate of input/output can slow for a variety of reasons:\n\nThe output sink or storage could be refusing writes of a piece of data.\n\nThere could be a particular hotspot data range that cannot complete.\n\nThere might be a storage bug.\n\nSome pipeline dependency issues won’t resolve themselves. It’s important to file a ticket or bug, and to allow for enough time to add more resources or address traffic patterns. Implementing load balancing and dropping low-priority data may help mit‐ igate the impact.\n\nPipeline application or configuration\n\nA pipeline failure could be the result of a bottleneck, a bug in your pipeline jobs, or a bug in the configurations themselves (e.g., CPU-intensive processing, performance regression, out-of-memory failures, abusive data prone to hotspotting, or configs that point to the incorrect input/output locations). Depending on the cause, there are sev‐ eral possible solutions:\n\nRoll back the binary/config, cherry-pick a fix, or repair any permission issues.\n\nConsider restructuring the data that’s causing the issue.\n\nApplication or configuration errors can introduce data incorrectness or lead to delayed data. These kinds of errors are the most common causes of outages. We rec‐ ommend spending time on pipeline development and ensuring that new binaries and configurations perform well in a nonproduction environment before they are fully deployed.\n\nUnexpected resource growth\n\nA sudden and unplanned jump in system load may cause a pipeline to fail. You may need additional unplanned resources to keep your service running. Automatic scaling\n\n286\n\n|\n\nChapter 13: Data Processing Pipelines\n\nof your application jobs can help meet the demand of new load, but you should also be aware that an increased pipeline load can also put a strain on downstream depen‐ dencies—you may also need to plan for more storage and/or network resources.\n\nGood resource planning and accurate growth prediction can help in these cases, but such predictions may not always be correct. We recommend becoming familiar with the process of requesting additional emergency resources. Depending on the nature of your pipeline’s deployment and the quantity of resources required, the time needed to acquire these resources can be substantial. Therefore, we recommend pre‐ paring interim solutions to keep your service up and running—for example, priori‐ tize different classes of data through your pipeline.\n\nRegion-level outage\n\nA regional outage is bad for all pipelines, but singly homed pipelines are particularly vulnerable. If your pipeline runs in a single region that suddenly becomes unavail‐ able, the pipeline will stop until the region comes back up. If you have multihomed pipelines with automatic failover, your response may be as simple as draining pro‐ cessing or serving from an affected region until the outage is over. When a region is down, data can become stranded or delayed, resulting in incorrect output from your pipeline. As a result, the correctness of the data output from any dependent jobs or services may be compromised.\n\nCase Study: Spotify by Igor Maravić\n\nSpotify is the leading music streaming company in the world. Every day, tens of mil‐ lions of people use Spotify to listen to their favorite songs, share music with their friends, and discover new artists.\n\nThis case study describes our event delivery system, which is responsible for reliably collecting instrumentation data generated from Spotify applications. The data pro‐ duced by this system helps us to better understand our end users and to provide them with the right music at the right time.\n\nIn this case study, a “customer” refers to the development teams within Spotify that use data from the event delivery system. “End user” refers to individuals that use the Spotify service to listen to music.\n\nCase Study: Spotify\n\n|\n\n287\n\nEvent Delivery We refer to end-user interactions as events. Every time a user listens to a song, clicks an ad, or follows a playlist, we record an event. Spotify captures and publishes hun‐ dreds of billions of events (of multiple types) to our servers daily. These events have many uses at Spotify, from A/B test analysis to showing play counts to powering per‐ sonalized discovery playlists. Most importantly, we pay royalties to artists based on delivered events.6 It’s imperative that we have a reliable means of event storage and delivery.\n\nBefore we can process event data, that data needs to be collected and delivered to per‐ sistent storage. We use an event delivery system to reliably collect and persist all pub‐ lished events. The event delivery system is one of the core pillars of our data infrastructure, as almost all of our data processing depends—either directly or indi‐ rectly—on the data it delivers.\n\nAll delivered events are partitioned by type and publishing time. As shown in Figure 13-5, events published during any given hour are grouped together and stored in a designated directory, called a delivered hourly bucket. These buckets are then grouped into event-type directories. This partitioning scheme simplifies data access control, ownership, retention, and consumption at Spotify.\n\nFigure 13-5. Delivered hourly buckets\n\n6 Delivered events are events that have been delivered to persistent storage and are exposed in such a way that\n\nthey can be consumed by customers of the event delivery system (e.g., data jobs).\n\n288\n\n|\n\nChapter 13: Data Processing Pipelines\n\nHourly buckets are the only interface our data jobs have with the event delivery sys‐ tem. As a result, we measure performance and define SLOs for our event delivery system based on how well we deliver hourly buckets per event type.\n\nEvent Delivery System Design and Architecture Our hourly buckets reside on Google Cloud Storage (GCS). Early in the design pro‐ cess, we decided to decouple data collection from data delivery within the system. To achieve this, we used a globally distributed persistent queue, Google Cloud Pub/Sub, as an intermediate layer. Once decoupled, data collection and delivery act as inde‐ pendent failure domains, which limits the impact of any production issues and results in a more resilient system. Figure 13-6 depicts the architecture of our event delivery system.\n\nFigure 13-6. Event delivery system architecture\n\nData collection\n\nProduced events7 are grouped by event types. Each event type describes a user action in the Spotify application. For example, one event type could refer to a user subscrib‐ ing to a playlist, while another event type could refer to a user starting playback of a song. To ensure that separate event types don’t impact each other, the system has full event type isolation. Individual events from different event types are published to their allocated topics in Google Cloud Pub/Sub. Publishing is performed by our microservices, which run both in Spotify datacenters and on Google Compute Engine (GCE). In order to be delivered, each published event stream is handled by a dedica‐ ted instance of an ETL process.\n\n7 Produced events are both the events that have been delivered and the events that are currently flowing\n\nthrough the event delivery system.\n\nCase Study: Spotify\n\n|\n\n289\n\nExtract Transform Load\n\nThe ETL process is responsible for delivering published events to the correct hourly buckets on GCS. The ETL process has three steps/components:\n\n1. A dedicated microservice consumes events from the event stream.\n\n2. Another microservice assigns events to their hourly partitions.\n\n3. A batch data job running on Dataproc deduplicates events from their hourly par‐ titions and persists them to their final location on GCS.\n\nEach ETL component has a single responsibility, which makes the components easier to develop, test, and operate.\n\nData delivery\n\nEvent type delivery is dynamically enabled or disabled directly by our customers (other engineering teams at Spotify). Delivery is controlled via simple configuration. In the configuration, customers define which event types should be delivered. As delivery of each event type is turned on or off, a microservice dynamically acquires and releases the Google GCE resources on which the ETL runs. The following code shows an example event type that a customer can enable/disable:\n\nevents: -CollectionUpdate -AddedToCollection -RemovedFromCollection\n\nWhen a customer enables delivery of a new event type, we don’t know in advance what quantity of resources are required to guarantee the delivery. Consequently, manually determining necessary resources is very expensive. To achieve optimal resource utilization for delivery of different event types, we use GCE Autoscaler.\n\nEvent Delivery System Operation Defining and communicating SLOs for our event delivery system helps in three ways:\n\nDesign and development\n\nWhen developing our systems, having clear SLOs in place gives us goals to work toward. These goals help us make pragmatic design choices and optimize our systems for simplicity.\n\nIdentify performance issues\n\nOnce our systems are deployed in production, SLOs help us to identify which parts of the system aren’t performing well and where we need to focus our efforts.\n\n290\n\n|\n\nChapter 13: Data Processing Pipelines\n\nSet customer expectations\n\nSLOs allow us to manage our customer expectations and avoid unnecessary sup‐ port requests. When the limits of our system are clear to our customers, they are empowered to decide how to design, build, and operate their own systems that depend on our data.\n\nWe provide our customers with three SLO types for our event delivery system: timeli‐ ness, completeness, and skewness (discussed next). These SLOs are based on hourly data buckets provided by GCS. To be as objective as possible and to avoid bloating event delivery with features that have nothing to do with it, we measure all SLOs using independent external systems (e.g., Datamon, a data visualization tool explained in the next section).\n\nTimeliness\n\nOur timeliness SLO is defined as the maximum delay of delivering an hourly bucket of data. Delivery delay is calculated as the time difference between when the bucket was delivered and the earliest theoretical time the bucket could have been closed. Figure 13-7 provides an example of this delivery delay. The diagram shows the buck‐ ets for hours 12, 13, and 14. If the bucket for hour 13 was closed at 14:53, we would say the closing delay was 53 minutes.\n\nFigure 13-7. Event time partitioning\n\nTimeliness of data delivery is the metric we use to evaluate the performance of our data pipelines. To measure and visualize timeliness, we use a tool called Datamon, our internal data monitoring tool that was built around the notion of hourly buckets. Figure 13-8 shows a typical Datamon UI. Each green rectangle (in grayscale, the vast majority of the rectangles) represents an on-time hourly bucket. Gray rectangles (clustered here on the righthand side) indicate buckets that have not been delivered, while red rectangles (3 dark rectangles on the very top row) indicate buckets that weren’t delivered within the required SLO. Days when all hours were successfully delivered are shown as a single green rectangle.\n\nCase Study: Spotify\n\n|\n\n291\n\nFigure 13-8. Datamon for Spotify’s data monitoring system\n\nDownstream data jobs can’t start their processing until the hourly buckets on which they depend are delivered. Each data job periodically checks the delivery status of its dependencies before processing the data. Any delay in delivery affects the timeliness of downstream jobs. Our customers care deeply about having data delivered in a timely fashion. To help us prioritize delivery of events during an incident, our event delivery system’s timeliness SLO is split into three priority tiers: high, normal, and low. Our customers configure to the appropriate tier for their event type.\n\nSkewness\n\nWe define our skewness SLO as the maximal percentage of data that can be mis‐ placed on a daily basis. Skewness (and completeness) are concepts specific to our event delivery system and are not present in our other data pipelines. Defining an SLO for these concepts was a key requirement when we were designing our event delivery system, as it processes (among other event types) finance-bearing events. For all other events, best-effort delivery is good enough and we don’t expose a corre‐ sponding SLO. Whether or not an event is finance-bearing is determined by cus‐ tomer configuration.\n\nTo determine when an hourly bucket should be delivered, our event delivery system uses heuristics. By definition, heuristics aren’t always completely correct. As a result, undelivered events from previously delivered buckets might be delivered to an incor‐ rect future hourly bucket. This misplaced event is referred to as a skew. A skew can negatively impact jobs, since they might first underreport and then overreport values for some time periods. Figure 13-9 shows an example of skewed data delivery.\n\n292\n\n|\n\nChapter 13: Data Processing Pipelines\n\nFigure 13-9. Delivery of skewed data\n\nCompleteness\n\nEvents can be lost in a distributed system in many ways—for example, a new release of our software may contain a bug, a cloud service may go down, or a developer might accidentally delete some persisted events. To ensure we are alerted about data loss, we measure completeness. We define completeness as the percentage of events that are delivered after they are successfully published to the system.\n\nWe report on skewness and completeness daily. To measure these values, we use an internal auditing system that compares the counts for all published and delivered events. Any mismatch is reported, and we take appropriate action.\n\nIn order to have timeliness, skewness, and completeness SLO guarantees, we assign events to our hourly buckets at the time they were received at our servers, not when they were produced on the clients. If our users are in offline mode, produced events can be buffered for up to 30 days on the clients before being published. Additionally, users can modify the system time on their device, which can result in inaccurately timestamped events. For these reasons, we use the timestamp from Spotify servers.\n\nWe don’t provide any SLOs regarding the data quality or accuracy of events delivered via our event delivery system. We observed that in a majority of cases, quality depends on the content of each event, which is populated by the business logic of our customers. To allow our system to scale with the number of customers, we keep it focused exclusively on delivering data. In this regard, we use the analogy that event delivery should behave like a postal service: your mail should be delivered on time, intact, and unopened. We leave the responsibility of providing quality SLOs to our internal teams that own the business logic and therefore understand the contents of the data.\n\nCustomer Integration and Support Many Spotify teams interact with the event delivery system daily. To encourage adoption and decrease the learning curve, we took the following steps to simplify user interaction with the event delivery system:\n\nCase Study: Spotify\n\n|\n\n293",
      "page_number": 307
    },
    {
      "number": 36,
      "title": "Segment 36 (pages 315-326)",
      "start_page": 315,
      "end_page": 326,
      "detection_method": "topic_boundary",
      "content": "Event delivery as a fully managed service\n\nWe wanted to avoid exposing the complexity of the system to our customers, allowing them to focus on the specific problems they’re trying to solve. We strived to hide any system complexities behind a well-defined and easy-to- understand API.\n\nLimited functionality\n\nTo keep our APIs simple, we support only a limited set of functionalities. Events can be published only in a specific in-house format, and can be delivered only to hourly buckets with a single serialization format. These simple APIs cover the majority of our use cases.\n\nDelivery of each event needs to be explicitly enabled\n\nWhen a customer enables delivery of an event, they define whether the event is financial-bearing and its associated timeliness requirements. Furthermore, event ownership needs to be explicitly defined as part of the enabling process. We strongly believe that holding our internal teams accountable for events they produce results in higher data quality. Explicit ownership of the events also gives us a clear channel of communication during incidents.\n\nDocumentation\n\nNo matter how simple interacting with the system is, good documentation is required to provide a good customer experience. Subpar and stale documentation is a common problem in fast-paced companies like Spotify. To address this, we treat our documentation like any other software product: all support requests that come to our team are treated either as issues with our documentation or as issues in the actual product. Most support requests are related to the system’s public APIs. Some exam‐ ples of questions we try to answer when writing our documentation include:\n\nHow is the delivery of an event type enabled?\n\nWhere is the data delivered?\n\nHow is the data partitioned?\n\nWhat are our SLOs?\n\nWhat kind of support should our customers expect during incidents?\n\nOur goal is to minimize the amount of support requests we receive as our customer base grows.\n\nSystem monitoring\n\nMonitoring our SLOs provides high-level insights into the general health of the sys‐ tem. Our reliable catch-all monitoring solution ensures we always get alerted when something goes wrong. The main problem with using an SLO violation as criteria for\n\n294\n\n|\n\nChapter 13: Data Processing Pipelines\n\nmonitoring is that we get alerted after our customers have been affected. To avoid this, we need sufficient operational monitoring of our system to resolve or mitigate issues before an SLO is broken.\n\nWe monitor the various components of our system separately, starting with basic sys‐ tem metrics, then building to more complex ones. For example, we monitor CPU usage as a signal for instance health. CPU usage is not always the most critical resource, but it works well as a basic signal.\n\nSometimes system monitoring is insufficient when we’re trying to understand and fix production issues. To supplement our monitoring data, we also maintain application logs. These logs contain important information related to the operation and health of the component they describe. We take great care to ensure we gather only the correct amount of logging data, as it’s easy for irrelevant logs to drown useful ones. For example, a bad logging implementation might log all the incoming requests for a high-volume component that deals with incoming requests. Assuming that most of the requests are similar, logging every request doesn’t add much value. Additionally, when too many requests are logged, it becomes difficult to find other log entries, disk fills up faster, and the overall performance of our service starts to degrade. A better approach is to either rate-limit the amount of logged requests, or to log only interest‐ ing requests (like the ones that result in unhandled exceptions).\n\nDebugging components in production by reading through application logs is chal‐ lenging, and should be a last resort.\n\nCapacity planning\n\nReliable round-the-clock operation of the event delivery system requires the correct amount of allocated resources, especially since the components are deployed into a single GCP project and they share a common quota pool. We use capacity planning to determine how many resources each system component needs.\n\nFor the majority of our system components, capacity planning is based on CPU usage. We provision each component to have 50% of CPU usage during peak hours. This provision acts as a safety margin that allows our system to handle unexpected bursts of traffic. When Spotify ran its own datacenters, we provided each component with static resources. This led to a waste of resources during off-peak hours and an inability to handle large bursts in traffic. To improve resource utilization, we use GCE Autoscaler for some of our stateless components.\n\nWe had some growing pains in the early days of implementing Autoscaler; under cer‐ tain conditions, Autoscaler can cause failures. For example, we use CPU usage as a metric to perform autoscaling. Autoscaler itself depends on a strong correlation between CPU usage and the amount of work performed by each component instance. If the relationship is broken—either through the addition of CPU-hungry daemons\n\nCase Study: Spotify\n\n|\n\n295\n\nto each component instance or due to component instances extensively burning CPU without doing any work—Autoscaler will start far too many instances.\n\nWhen Autoscaler is presented with constantly increasing CPU usage that has no cor‐ relation with the amount of work performed, it will scale indefinitely until it uses all of the resources it can find. To prevent Autoscaler from using up all of our quota, we implemented some workarounds:\n\nWe limit the maximum number of instances Autoscaler can use.\n\nWe heavily restrict the CPU usage of all daemons running on an instance.\n\nWe aggressively throttle a component’s CPU usage as soon as we detect that no useful work is being done.\n\nEven when using Autoscaler, we need to conduct capacity planning. We need to ensure that we have enough quota, and that the maximum number of instances Autoscaler can use is set high enough to serve traffic during peaks, but low enough to limit the impact of “runaway” autoscaling.\n\nDevelopment process\n\nTo ship new features and improvements swiftly, we developed the event delivery sys‐ tem (shown in Figure 13-10) following the continuous integration and continuous delivery (CI/CD) process. According to this process, valid, proven, or reviewed sys‐ tem changes are deployed as soon as they’re made. Having sufficient test coverage is a prerequisite for each change to be successfully deployed without negatively impacting our SLOs.\n\nWe write tests following a “testing pyramid” philosophy. This means that for each of our components, we have plenty of unit tests that focus on components’ inner work‐ ings—in addition to a smaller number of integration tests that focus on components’ public API. At the highest level of the testing pyramid, we have a system-wide, end- to-end test. In this end-to-end test, all components are treated as black boxes so the system in the test environment resembles the one in production as much as possible.\n\nAfter initial development, every change goes through a peer review. As a part of the review process, all tests are executed on a shared CI/CD server, and the results are presented to the developers. Changes can be merged only after the reviewers approve the change and all the tests have successfully passed. As soon as the change is merged, the deployment process is triggered.\n\nThe event delivery system is a critical component in Spotify’s infrastructure. If it stopped delivering data, all data processing in Spotify would stall. For this reason, we decided to take a more conservative approach to deployments and deploy each change in stages. We require a manual approval before a deployment can move from one stage to another.\n\n296\n\n|\n\nChapter 13: Data Processing Pipelines\n\nFigure 13-10. Development process\n\nDuring the first deployment stage, the change is deployed to the staging environ‐ ment. This low-risk staging system doesn’t handle production traffic. For testing pur‐ poses, a representative fraction of production traffic is mirrored in the staging system, which is a replica of the system running in production. At the second deploy‐ ment stage, the change is deployed to a small subset of production instances, or cana‐ ries. We perform a full production deployment only after we ensure that everything went well, both in staging and canaries (see Chapter 16).\n\nIncident handling\n\nWhen dealing with an incident, our first priority is to mitigate the damage and return the system to a stable previous state. To avoid making the situation worse, we refrain from deploying any major changes to our components during an incident. The exception to this rule is if we conclude that the incident was caused by recently deployed new code. In such cases, we immediately roll the system back to a previous working version.\n\nToday, the most common operational failures we encounter are caused either by a system malfunction (e.g., we introduce a software bug or a performance regression) or a failure with an external service on which we depend (e.g., an update to a service API isn’t backward-compatible or a service breaks its SLO). We use many battle- tested Google Cloud and internal Spotify services, like Cloud Pub/Sub and Helios, to speed up development of our system and to reduce our operational load. In the event\n\nCase Study: Spotify\n\n|\n\n297\n\nof an incident caused by an external service, we have a dedicated on-call team8 who provides support. One drawback of using external services is that we can’t do much to mitigate the problem ourselves. Furthemore, communicating the issue to a third party takes valuable time during an incident. Nevertheless, we believe that the ability to delegate responsibility is worth the occasional feeling of powerlessness.\n\nUnexpected system behavior under heavy load is another common source of opera‐ tional failure. Testing services under exact production conditions is impossible, so it’s hard to predict all of the edge cases that can happen. It can also be difficult to emulate the load our components face in production. Heavy load in combination with unforeseen edge cases can lead to interesting failure scenarios, such as the Autoscaler example described earlier in “Capacity planning” on page 295.\n\nOperational system failures can cause our SLOs to break. If our data freshness SLO is broken, no customer action is expected; customers must simply wait for their data to arrive. However, if our skewness or completeness SLOs are breached, we might need to involve customers, as data quality is compromised. When we detect either com‐ pleteness or skewness issues, the impacted events require reprocessing to be delivered correctly:\n\nTo deal with incompleteness, events need to be redelivered from the last check‐ point known to be good.\n\nTo deal with excessive skewness, already delivered events are reshuffled and assigned to their correct hourly buckets.\n\nBoth redelivery and reshuffling of events are done manually. After the delivered events are modified, we strongly advise our customers to reprocess them to produce data of sufficient quality.\n\nSummary Spotify’s event delivery system has evolved over the years. Because previous iterations were far less reliable, our engineers were paged every few nights. We spent the major‐ ity of our development sprints on incident remediations and postmortems. When designing the current incarnation, we focused on building a modularized system that does one core thing well: deliver events. Additionally, we wanted to provide event delivery as a product to the rest of Spotify. To achieve this, we needed to define and meet SLOs so that we could set clear expectations for our customers.\n\nWe employ a range of strategies to keep the service up and running—from well- documented on-call procedures to using well-proven external services (such as Goo‐\n\n8 The external service provider guarantees SLAs and has its own on-call team to ensure the product is meeting\n\nthese SLAs.\n\n298\n\n|\n\nChapter 13: Data Processing Pipelines\n\ngle Cloud Pub/Sub). Furthermore, a single team is responsible for the development and operation of the system throughout its entire lifecycle. This development struc‐ ture allows us to use the team experience we gain from maintaining the system to continually improve it.\n\nAs a result of these efforts, we now have a reliable system that allows us to focus our time on meeting more ambitious completeness, skewness, and timeliness SLOs. This results in better usability and a better overall customer experience.\n\nConclusion Applying SRE best practices to pipelines can help you make smart design choices and develop automation tools so that pipelines are easy to operate, scale more effectively, and are more reliable. Spotify’s event delivery system is an example of a pipeline built and operated with core SRE principles in mind, using a variety of technologies—from in-house, Google Cloud, and third parties—chosen to meet the customer’s need for timely data processing. Without proper care for operational best practices, pipelines may be more prone to failure and require a lot of manual work, especially during periods of growth, migrations, feature launches, or cleanup after outages. As with any complex system design, it is important to know your requirements and the SLOs you have chosen to keep, assess the available technology, and document the design and how to perform common tasks.\n\nConclusion\n\n|\n\n299\n\nCHAPTER 14 Configuration Design and Best Practices\n\nBy Štěpán Davidovič with Niall Richard Murphy, Christophe Kalt, and Betsy Beyer\n\nConfiguring systems is a common SRE task everywhere. It can be a tiring and frus‐ tratingly detailed activity, particularly if the engineer isn’t deeply familiar with the system they’re configuring or the configuration hasn’t been designed with clarity and usability in mind. Most commonly, you perform configuration in one of two scenar‐ ios: during initial setup when you have plenty of time, or during an emergency recon‐ figuration when you need to handle an incident.\n\nThis chapter examines configuration from the perspective of someone who designs and maintains an infrastructure system. It describes our experiences and strategies for designing configuration in a safe and sustainable way.\n\nWhat Is Configuration? When we deploy software systems, we do not think of them as fixed and never- changing. Ever-evolving business needs, infrastructure requirements, and other fac‐ tors mean that systems are constantly in flux. When we need to change system behavior quickly, and the change process requires an expensive, lengthy rebuild and redeployment process, a code change won’t suffice. Instead, configuration—which we can loosely define as a human-computer interface for modifying system behavior— provides a low-overhead way to change system functionality. SREs take advantage of this on a regular basis, when deploying systems and tuning their performance, as well as during incident response.\n\n301\n\nWe can reason about systems as having three key components:\n\nThe software\n\nThe data set that the system works with\n\nThe system configuration\n\nWhile we can intuitively identify each of these components, they are often far from clearly separated. For example, many systems use programming languages for config‐ uration, or at least have the capability to reference programming languages. Examples include Apache and modules, such as mod_lua and its request hooks, or the window manager XMonad and its Haskell-based configuration. Similarly, data sets might contain code, such as stored SQL procedures, which can amount to complex applica‐ tions.\n\nA good configuration interface allows quick, confident, and testable configuration changes. When users don’t have a straightforward way to update configuration, mis‐ takes are more likely. Users experience increased cognitive load and a significant learning curve.\n\nConfiguration and Reliability Because our systems are ultimately managed by humans, humans are responsible for configuration. The quality of the human-computer interface of a system’s configura‐ tion impacts an organization’s ability to run that system reliably. The impact of a well-crafted (or poorly crafted) configuration interface is similar to the impact of code quality on system maintainability over time.\n\nHowever, configuration tends to differ meaningfully from code in several aspects. Changing a system’s capabilities via code is typically a lengthy and involved process, involving small incremental changes, code reviews, and testing. In contrast, changing a single configuration option can have dramatic changes on functionality—for exam‐ ple, one bad firewall configuration rule may lock you out of your own system. Unlike code, configuration often lives in an untested (or even untestable) environment.\n\nSystem configuration changes may need to be made under significant pressure. Dur‐ ing an incident, a configuration system that can be simply and safely adjusted is essential. Consider the interface design of early airplanes: confusing controls and indicators led to accidents. Research at the time showed that operator failures were frequent, regardless of pilot skill or experience.1 The link between usability and relia‐ bility translates to computing systems. Consider what happens if we swap a control stick and dial indicators for .conf files and monitoring graphs.\n\n1 Kim Vicente, The Human Factor (New York: Routledge, 2006), 71–6.\n\n302\n\n|\n\nChapter 14: Configuration Design and Best Practices\n\nSeparating Philosophy and Mechanics We usually discuss configuration when designing new software or assembling a new system out of existing software components. How will we configure it? How will the configuration load? We’ll separate the overarching topic of configuration into two parts: configuration philosophy and configuration mechanics.\n\nConfiguration philosophy pertains to aspects of configuration that are completely independent of the chosen language and other mechanics. Our discussion of philoso‐ phy encompasses how to structure the configuration, how to achieve the correct level of abstraction, and how to support diverging use cases seamlessly.\n\nOur discussion of mechanics covers topics like language design, deployment strate‐ gies, and interactions with other systems. This chapter focuses less on mechanics, partly because topics like language choice are already being discussed across the industry. Additionally, because a given organization may already have strong outside requirements like preexisting configuration infrastructure, configuration mechanics aren’t easily generalizable. The following chapter on Jsonnet gives a practical example of configuration mechanics—in particular, language design—in existing software.\n\nDiscussing philosophy and mechanics separately allows us to reason more clearly about configuration. In practice, implementation details like configuration language (be it XML or Lua) don’t matter if configuration requires a huge amount of user input that’s difficult to understand. Conversely, even the simplest configuration inputs can cause problems if they must be entered into a very cumbersome interface. Consider the (very) old Linux kernel configuration process: configuration updates had to be made through a command-line terminal that required a sequence of com‐ mands to set each parameter. To make even the simplest correction, users had to start the configuration process from scratch.2\n\nConfiguration Philosophy This section discusses aspects of configuration that are completely independent of implementation, so these topics generalize across all implementations.\n\nIn the following philosophy, our ideal configuration is no configuration at all. In this ideal world, the system automatically recognizes the correct configuration based on deployment, workload, or pieces of configuration that already existed when the new system was deployed. Of course, for many systems, this ideal is unlikely to be attaina‐\n\n2 While clearly a hyperbole, a Reddit thread about the worst volume control interface can provide insight into the difference between good and bad mechanics of answering the same question, “What should the volume be?”\n\nConfiguration Philosophy\n\n|\n\n303\n\nble in practice. However, it highlights the desirable direction of configuration: away from a large number of tunables and toward simplicity.\n\nHistorically, mission-critical systems offered a large amount of controls (which amount to system configuration), but also required significant human operator train‐ ing. Consider the complex array of operator controls in the NASA spacecraft control center in Figure 14-1. In modern computer systems, such training is no longer feasi‐ ble for the majority of the industry.\n\nFigure 14-1. Control panel in the NASA spacecraft control center, illustrating possibly very complex configuration\n\nWhile this ideal reduces the amount of control we can exercise over a system, it decreases both the surface area for error and cognitive load on the operator. As the complexity of systems grows, operator cognitive increasingly important.\n\nload becomes\n\nWhen we’ve applied these principles in practical systems at Google, they typically resulted in easy, broad adoption and low cost for internal user support.\n\n304\n\n|\n\nChapter 14: Configuration Design and Best Practices\n\nConfiguration Asks Users Questions Regardless of what you’re configuring and how you’re configuring it, the human- computer interaction ultimately boils down to an interface that asks users questions, requesting inputs on how the system should operate. This model of conceptualization holds true regardless of whether users are editing XML files or using a configuration GUI wizard.\n\nIn modern software systems, we can approach this model from two different perspectives:\n\nInfrastructure-centric view\n\nIt’s useful to offer as many configuration knobs as possible. Doing so enables users to tune the system to their exact needs. The more knobs, the better, because the system can be tuned to perfection.\n\nUser-centric view\n\nConfiguration asks questions about infrastructure that the user must answer before they can get back to working on their actual business goal. The fewer knobs, the better, because answering configuration questions is a chore.\n\nDriven by our initial philosophy of minimizing user inputs, we favor the user-centric view.\n\nThe implications of this software design decision extend beyond configuration. Focusing configuration on the user means that your software needs to be designed with a particular set of use cases for your key audience. This requires user research. In contrast, an infrastructure-centric approach means that your software effectively pro‐ vides base infrastructure, but turning it into a practical system requires considerable configuration from the user. These models are not in strict conflict, but attempting to reconcile them can be quite difficult. Perhaps counterintuitively, limited configura‐ tion options can lead to better adoption than extremely versatile software—onboard‐ ing effort is substantially lower because the software mostly works “out of the box.”\n\nSystems that begin from an infrastructure-centric view may move toward a more user-centric focus as the system matures, by removing some configuration knobs via various means (some of which are discussed in subsequent sections).\n\nQuestions Should Be Close to User Goals As we follow the philosophy of user-centric configuration, we want to make sure users can easily relate to the questions we ask. We can think of the nature of user inputs on a spectrum: on one end, the user describes their needs in their own terms (fewer configuration options); on the other end, the user describes exactly how the system should implement their needs (more configuration options).\n\nConfiguration Philosophy\n\n|\n\n305\n\nLet’s use making tea as an analogy to configuring a system. With fewer configuration options, a user can ask for “hot green tea” and get roughly what they want. On the opposite end of the spectrum, a user can specify the whole process: water volume, boiling temperature, tea brand and flavor, steeping time, tea cup type, and tea volume in the cup. Using more configuration options might be closer to perfection, but the effort required to adhere to such detail might cost more than the marginal benefit of a near-perfect drink.\n\nThis analogy is helpful both to the users and the developers who work on the config‐ uration system. When a user specifies exact steps, the system needs to follow them. But when the user instead describes their high-level goals, the system can evolve over time and improve how it implements these goals. A good upfront understanding of user goals for the system is a necessary first step here.\n\nFor a practical illustration of how this spectrum plays out, consider job scheduling. Imagine you have a one-off analytical process to run. Systems like Kubernetes or Mesos enable you to meet your actual goal of running analysis, without burdening you with minute details like deciding which physical machine(s) your analytical pro‐ cess should run on.\n\nMandatory and Optional Questions A given configuration setup might contain two types of questions: mandatory and optional. Mandatory questions must be answered for the configuration to provide any functionality at all. One example might be who to charge for an operation. Optional questions don’t dictate core functionality, but answering them can improve the quality of the function—for example, setting a number of worker processes.\n\nIn order to remain user-centric and easy to adopt, your system should minimize the number of mandatory configuration questions. This is not an easy task, but it’s important. While one might argue that adding one or two small steps incurs little cost, the life of an engineer is often an endless chain of individually small steps. The principled reduction of these small steps can dramatically improve productivity.\n\nAn initial set of mandatory questions often includes the questions you thought about when designing the system. The easiest path to reduce mandatory questions is to convert them to optional questions, which means providing default answers that apply safely and effectively to most, if not all, users. For example, instead of requiring the user to define whether an execution should be dry-run or not, we can simply do dry-run by default.\n\nWhile this default value is often a static, hardcoded value, it doesn’t have to be. It can be dynamically determined based on other properties of the system. Taking advan‐ tage of dynamic determination can further simplify your configuration.\n\n306\n\n|\n\nChapter 14: Configuration Design and Best Practices",
      "page_number": 315
    },
    {
      "number": 37,
      "title": "Segment 37 (pages 327-335)",
      "start_page": 327,
      "end_page": 335,
      "detection_method": "topic_boundary",
      "content": "For context, consider the following examples of dynamic defaults. A computationally intensive system might typically decide how many computation threads to deploy via a configuration control. Its dynamic default deploys as many threads as the system (or container) has execution cores. In this case, a single static default isn’t useful. Dynamic default means we don’t need to ask the user to determine the right number of threads for the system to deploy on a given platform. Similarly, a Java binary deployed alone in a container could automatically adjust its heap limits depending on memory available in the container. These two examples of dynamic defaults reflect common deployments. If you need to restrict resource usage, it’s useful to be able to override dynamic defaults in the configuration.\n\nThe implemented dynamic defaults might not work out for everyone. Over time, users might prefer different approaches and ask for greater control over the dynamic defaults. If a significant portion of configuration users report problems with dynamic defaults, it’s likely that your decision logic no longer matches the requirements of your current user base. Consider implementing broad improvements that enable your dynamic defaults to run without requiring additional configuration knobs. If only a small fraction of users are unhappy, they may be better off manually setting configuration options. Implementing more complexity in the system creates more work for users (e.g., increased cognitive load to read documentation).\n\nWhen choosing default answers for optional questions, regardless of whether you opt for static or dynamic defaults, think carefully about the impact of your choice. Expe‐ rience shows that most users will use the default, so this is both a chance and a responsibility. You can subtly nudge people in the right direction, but designating the wrong default will do a lot of harm. For example, consider configuration defaults and their impact outside of computer science. Countries where the default for organ donors is opt-in (and individuals can opt out if they’re so inclined) have dramatically greater ratios of organ donors than countries with an opt-out default.3 Simply select‐ ing a specific default has a profound impact on medical options throughout the entire system.\n\nSome optional questions start without a clear use case. You may want to remove these questions altogether. A large number of optional questions might confuse the user, so you should add configuration knobs only when motivated by a real need. Finally, if your configuration language happens to use the concept of inheritance, it is useful to be able to revert to the default value for any optional question in the leaf configurations.\n\n3 Full text: http://www.dangoldstein.com/papers/DefaultsScience.pdf.\n\nConfiguration Philosophy\n\n|\n\n307\n\nEscaping Simplicity Thus far, we’ve discussed reducing the configuration of a system to its simplest form. However, the configuration system may need to account for power users as well. To return to our tea analogy, what if we really need to steep the tea for a particular duration?\n\nOne strategy to accommodate power users is to find the lowest common denomina‐ tor of what regular users and power users require, and settle on that level of complex‐ ity as the default. The downside is that this decision impacts everyone; even the simplest use cases now need to be considered in low-level terms.\n\nBy thinking about configuration in terms of optional overrides of default behavior, the user configures “green tea,” and then adds “steep the tea for five minutes.” In this model, the default configuration is still high-level and close to the user’s goals, but the user can fine-tune low-level aspects. This approach is not novel. We can draw paral‐ lels to high-level programming languages like C++ or Java, which enable program‐ mers to include machine (or VM) instructions in code otherwise written in the high- level language. In some consumer software, we see screens with advanced options that can offer more fine-grained control than the typical view.\n\nIt’s useful to think about optimizing for the sum of hours spent configuring across the organization. Consider not only the act of configuration itself, but also the deci‐ sion paralysis users might experience when presented with many options, the time it takes to correct the configuration after taking a wrong turn, the slower rate of change due to lower confidence, and more. When you are considering configuration design alternatives, the option that accomplishes a complex configuration in fewer but sig‐ nificantly harder steps may be preferable if it makes supporting the most common use cases significantly easier.\n\nIf you find that more than a small subset of your users need a complex configuration, you may have incorrectly identified the common use cases. If so, revisit the initial product assumptions for your system and conduct additional user research.\n\nMechanics of Configuration Our discussion up to this point has covered configuration philosophy. This section shifts focus to the mechanics of how a user interacts with the configuration.\n\nSeparate Configuration and Resulting Data Which language to store the configuration in is an inevitable question. You could choose to have pure data like in an INI, YAML, or XML file. Alternatively, the con‐ figuration could be stored in a higher-level language that allows for much more flexi‐ ble configuration.\n\n308\n\n|\n\nChapter 14: Configuration Design and Best Practices\n\nFundamentally, all questions the user is asked boil down to static information. This may include obviously static answers to questions like “How many threads should be used?” But even “What function should be used for every request?” is just a static ref‐ erence to a function.\n\nTo answer the age-old question of whether configuration is code or data, our experi‐ ence has shown that having both code and data, but separating the two, is optimal. The system infrastructure should operate on plain static data, which can be in for‐ mats like Protocol Buffers, YAML, or JSON. This choice does not imply that the user needs to actually interact with pure data. Users can interact with a higher-level inter‐ face that generates this data. This data format can, however, be used by APIs that allow further stacking of systems and automation.\n\nThis high-level interface can be almost anything. It can be a high-level language like Python-based Domain-Specific Language (DSL), Lua, or purpose-built languages, such as Jsonnet (which we will discuss in more detail in Chapter 15). We can think of such an interface as a compilation, similar to how we treat C++ code.4 The high-level interface might also be no language at all, with the configuration ingested by a web UI.\n\nStarting with a configuration UI that’s deliberately separated from its static data rep‐ resentation means the system has flexibility for deployment. Various organizations may have different cultural norms or product requirements (such as using specific languages within the company or needing to externalize configuration to end users), and a system this versatile can be adapted to support diverse configuration require‐ ments. Such a system can also effortlessly support multiple languages.5 See Figure 14-2.\n\nThis separation can be completely invisible to the user. The user’s common path may be to edit files in the configuration language while everything else happens behind the scenes. For example, once the user submits changes to the system, the newly stored configuration is automatically compiled into raw data.6\n\n4 Jsonnet is used to compile into Kubernetes YAML, providing a real-world illustration for this parallel. See\n\nhttp://ksonnet.heptio.com/.\n\n5 This can be useful when an organization performs migrations to new technologies, integrates acquisitions, or focuses on shared infrastructure but otherwise has divergent development and system management practices.\n\n6 There are various practical ways to automate compiling a new configuration into raw data. For example, if\n\nyou store your configuration in a version control system, a post-commit hook can facilitate this. Alternatively, a periodic update process can perform this, at the cost of some delay.\n\nMechanics of Configuration\n\n|\n\n309\n\nFigure 14-2. Configuration flow with a separate configuration interface and configura‐ tion data infrastructure. Note the web UI typically also displays the current configura‐ tion, making the relationship bidirectional.\n\nOnce the static configuration data is obtained, it can also be used in data analysis. For instance, if the generated configuration data is in JSON format, it can be loaded into PostgreSQL and analyzed with database queries. As the infrastructure owner, you can then quickly and easily query for which configuration parameters are being used and by whom. This query is useful for identifying features you can remove or measuring the impact of a buggy option.\n\nWhen consuming the final configuration data, you will find it useful to also store metadata about how the configuration was ingested. For example, if you know the data came from a configuration file in Jsonnet or you have the full path to the origi‐ nal before it was compiled into data, you can track down the configuration authors.\n\nIt is also acceptable for the configuration language to be static data. For example, both your infrastructure and interface might use plain JSON. However, avoid tight coupling between the data format you use as the interface and the data format you use internally. For example, you may use a data structure internally that contains the data structure consumed from configuration. The internal data structure might also contain completely implementation-specific data that never needs to be surfaced out‐ side of the system.\n\nImportance of Tooling Tooling can make the difference between a chaotic nightmare and a sustainable and scalable system, but it is often overlooked when configuration systems are designed. This section discusses the key tools that should be available for an optimal configura‐ tion system.\n\n310\n\n|\n\nChapter 14: Configuration Design and Best Practices\n\nSemantic validation\n\nWhile most languages offer syntax validation out of the box, don’t overlook semantic validation. Even if your configuration is syntactically valid, is it likely to do useful things? Or did the user reference a nonexistent directory (due to a typo), or need a thousand times more RAM than they actually have (because units aren’t what the user expected)?\n\nValidating that the configuration is semantically meaningful, to the maximum extent possible, can help prevent outages and decrease operational costs. For every possible misconfiguration, we should ask ourselves if we could prevent it at the moment the user commits the configuration, rather than after changes are submitted.\n\nConfiguration syntax\n\nWhile it’s key to ensure that configuration accomplishes what the user wants, it is also important to remove mechanical obstacles. From a syntax perspective, the con‐ figuration language should offer the following:\n\nSyntax highlighting in editors (used within the company)\n\nOften, you’ve already solved this by reusing an existing language. However, domain-specific languages may have additional “syntactic sugar” that can benefit from specialized highlighting.\n\nLinter\n\nUse a linter to identify common inconsistencies in language use. Pylint is one popular language example.\n\nAutomatic syntax formatter\n\nBuilt-in standardization minimizes relatively unimportant discussions about for‐ matting and decreases cognitive load as contributors switch projects. Standard formatting may also allow for easier automatic editing, which is helpful in sys‐ tems used broadly within a large organization. Examples of autoformatters in existing languages include clang-format7 and autopep8.\n\nThese tools enable users to write and edit configuration with confidence that their syntax is correct.8 Incorrect indentation in whitespace-oriented configs can have potentially great consequences—some of which standard formatting can prevent.\n\n7 Although C++ is unlikely to be used for configuration, clang-format nicely demonstrates that even a language\n\nmore complex than most languages used for configuration can in fact be fully autoformatted.\n\n8 In very large organizations, it is also useful to be able to annotate pieces of a broadly reused configuration that has been deprecated. When a replacement is available, automatic rewriting tools facilitate centralized changes, helping to avoid legacy issues.\n\nMechanics of Configuration\n\n|\n\n311\n\nOwnership and Change Tracking Because configuration can potentially impact critical systems of companies and insti‐ tutions, it’s important to ensure good user isolation, and to understand what changes happened in the system. As mentioned in Chapter 10, an effective postmortem cul‐ ture avoids blaming individuals. However, it’s helpful both during an incident and while you’re conducting a postmortem to know who changed a configuration, and to understand how the configuration change impacted the system. This holds true whether the incident is due to an accident or a malicious actor.\n\nEach configuration snippet for the system should have a clear owner. For example, if you use configuration files, their directories might be owned by a single production group. If files in a directory can only have one owner, it’s much easier to track who makes changes.\n\nVersioning configuration, regardless of how it is performed, allows you to go back in time to see what the configuration looked like at any given point in time. Checking configuration files into a versioning system, such as Subversion or Git, is a common practice nowadays, but this practice is equally important for configuration ingested by web UI or remote APIs. You may also wish to have tighter coupling between the configuration and the software being configured. By doing so, you can avoid inadver‐ tently configuring features that are either not yet available or no longer supported in the software.\n\nOn a related note, it is useful (and sometimes required) to log both changes to the configuration and the resulting application to the system. The simple act of commit‐ ting a new version of a configuration does not always mean that the configuration is directly applied (more on that later). When a system configuration change is suspec‐ ted as the culprit during an incident response, it is useful to be able to quickly deter‐ mine the full set of configuration edits that went into the change. This enables confident rollbacks, and the ability to notify parties whose configurations were impacted.\n\nSafe Configuration Change Application As discussed earlier, configuration is an easy way to make large changes to system functionality, but it is often not unit-tested or even easily testable. Since we want to avoid reliability incidents, we should inspect what the safe application of a configura‐ tion change means.\n\nFor a configuration change to be safe, it must have three main properties:\n\nThe ability to be deployed gradually, avoiding an all-or-nothing change\n\nThe ability to roll back the change if it proves dangerous\n\n312\n\n|\n\nChapter 14: Configuration Design and Best Practices\n\nAutomatic rollback (or at a minimum, the ability to stop progress) if the change leads to loss of operator control\n\nWhen deploying a new configuration, it is important to avoid a global all-at-once push. Instead, push the new configuration out gradually—doing so allows you to detect issues and abort a problematic push before causing a 100% outage. This is one reason why tools such as Kubernetes use a rolling update strategy for updating soft‐ ware or configuration instead of updating every pod all at once. (See Chapter 16 for related discussions.)\n\nThe ability to roll back is important for decreasing incident duration. Rolling back the offending configuration can mitigate an outage much more quickly than attempt‐ ing to patch it with a temporary fix—there is inherently lower confidence that a patch will improve things.\n\nIn order to be able to roll forward and roll back configuration, it must be hermetic. Configuration that requires external resources that can change outside of its hermetic environment can be very hard to roll back. For example, configuration stored in a version control system that references data on a network filesystem is not hermetic.\n\nLast but not least, the system should be especially careful when handling changes that might lead to sudden loss of operator control. On desktop systems, screen resolution changes often prompt a countdown and reset if a user does not confirm changes. This is because an incorrect monitor setting might prevent the user from reverting the change. Similarly, it is common for system admins to accidentally firewall them‐ selves out of the system that they are currently setting up.\n\nThese principles are not unique to configuration and apply to other methods of changing deployed systems, such as upgrading binaries or pushing new data sets.\n\nConclusion Trivial configuration changes can impact a production system in dramatic ways, so we need to deliberately design configuration to mitigate these risks. Configuration design carries aspects of both API and UI design and should be purposeful—not just a side effect of system implementation. Separating configuration into philosophy and mechanics helps us gain clarity as we design internal systems, and enables us to scope discussion correctly.\n\nApplying these recommendations takes time and diligence. For an example of how we’ve applied these principles in practice, see the ACM Queue article on Canary Analysis Service. When designing this practical internal system, we spent about a\n\nConclusion\n\n|\n\n313\n\nmonth trying to reduce mandatory questions and finding good answers for optional questions. Our efforts created a simple configuration system. Because it was easy to use, it was widely adopted internally. We’ve seen little need for user support—since users can easily understand the system, they can make changes with confidence. Of course, we have not eliminated misconfigurations and user support entirely, nor do we ever expect to.\n\n314\n\n|\n\nChapter 14: Configuration Design and Best Practices\n\nCHAPTER 15 Configuration Specifics\n\nBy Dave Cunningham and Misha Brukman with Christophe Kalt and Betsy Beyer\n\nManaging production systems is one of the many ways SREs provide value to an organization. The task of configuring and running applications in production requires insight into how those systems are put together and how they work. When things go wrong, the on-call engineer needs to know exactly where the configurations are and how to change them. This responsibility can become a burden if a team or organization hasn’t invested in addressing configuration-related toil.\n\nThis book covers the subject of toil at length (see Chapter 6). If your SRE team is bur‐ dened with a lot of configuration-related toil, we hope that implementing some of the ideas presented in this chapter will help you reclaim some of the time you spend making configuration changes.\n\nConfiguration-Induced Toil At the start of a project’s lifecycle, configuration is usually relatively lightweight and straightforward. You might have a few files in a data-only format like INI, JSON, YAML, or XML. Managing these files requires little toil. As the number of applica‐ tions, servers, and variations increases over time, configuration can become very complex and verbose. For example, you might have originally “changed a setting” by editing one configuration file, but now you have to update configuration files in mul‐ tiple locations. Reading such configuration is also hard, as important differences are hidden in a sea of irrelevant duplicated details. We can characterize this configuration-related toil as replication toil: the mundane task of managing configu‐ ration replicated across a system. This kind of toil isn’t limited to large organizations and huge systems—it’s especially common to microservice architectures with many independently configured components.\n\n315",
      "page_number": 327
    },
    {
      "number": 38,
      "title": "Segment 38 (pages 336-345)",
      "start_page": 336,
      "end_page": 345,
      "detection_method": "topic_boundary",
      "content": "Engineers often respond to replication toil by building automation or a configuration framework. They aim to remove duplication in the config system, and to make con‐ figuration easier to understand and maintain. Reusing techniques from software engineering, this approach often makes use of a “configuration language.” Google SRE has created a number of configuration languages with the aim of reducing toil for our largest and most complex production systems.\n\nUnfortunately, this tactic doesn’t necessarily eliminate configuration toil. Freed from an overwhelming number of individual configs, the project (and its config corpus) grows with renewed energy. Inevitably, you run up against complexity toil: the chal‐ lenging and frustrating task of dealing with the emergent and sometimes undesirable behaviors of complex automation. This kind of toil typically materializes in larger organizations (10+ engineers) and compounds with growth. The earlier you can tackle complexity toil, the better; the size and complexity of configuration will only grow over time.\n\nReducing Configuration-Induced Toil If your project is riddled with configuration-related toil, you have a few basic strate‐ gies for improving the situation.\n\nIn rare cases, and if your application is custom-built, you might opt to remove the configuration altogether. The application may be naturally better than a configura‐ tion language at handling certain aspects of configuration: it might make sense for the application to assign defaults because it has access to information about the machine, or to vary some values dynamically because it can scale according to load.\n\nIf removing configuration is not an option, and replication toil is becoming a prob‐ lem, consider automation to reduce the duplication in your configuration corpus. You might integrate a new configuration language, or you might need to improve or replace your existing configuration setup.1 The next section, “Critical Properties and Pitfalls of Configuration Systems” on page 317, provides some guidance on choosing or designing that system.\n\nIf you go the route of setting up a new configuration framework, you’ll need to inte‐ grate the configuration language with the application that needs to be configured. “Integrating an Existing Application: Kubernetes” on page 322 uses Kubernetes as an example of an existing application to be integrated, and “Integrating Custom Appli‐ cations (In-House Software)” on page 326 gives some more general advice. These sections walk through some examples using Jsonnet (which we chose as a representa‐ tive configuration language for illustration purposes).\n\n1 Note that you may be able to write software to convert your old configuration language to the new language;\n\nhowever, if your original source language is nonstandard or broken, this isn’t a viable option.\n\n316\n\n|\n\nChapter 15: Configuration Specifics\n\nOnce you have a configuration system in place to help with replication toil—whether you’re already committed to your existing solution, or you choose to implement a new configuration language—the best practices in “Effectively Operating a Configu‐ ration System” on page 329, “When to Evaluate Configuration” on page 331, and “Guarding Against Abusive Configuration” on page 333 should be helpful in optimiz‐ ing your setup, no matter which language you’re using. Adopting those processes and tools can help minimize complexity toil.\n\nCritical Properties and Pitfalls of Configuration Systems Chapter 14 outlined some critical properties of any configuration system. In addition to generic ideal requirements like lightweightness, ease of learning, simplicity, and expressive power, an efficient configuration system must:\n\nSupport configuration health, engineer confidence, and productivity via tooling for managing the config files (linters, debuggers, formatters, IDE integration, etc.).\n\nProvide hermetic evaluation of configuration for rollbacks and general replayability.\n\nSeparate config and data to allow for easy analysis of the config and a range of configuration interfaces.\n\nIt is not widely understood that these properties are critical, and arriving at our cur‐ rent understanding was indeed a journey. During this journey, Google invented sev‐ eral configuration systems that lacked these critical properties. We were not alone, either. Despite the great variety of popular configuration systems, it is difficult to find one that does not fall foul of at least one of the following pitfalls.\n\nPitfall 1: Failing to Recognize Configuration as a Programming Language Problem If you’re not intentionally designing a language, then it’s highly unlikely the “lan‐ guage” you’ll end up with is a good one.\n\nWhile configuration languages describe data rather than behavior, they still have the other characteristics of programming languages. If our configuration strategy starts with the objective of using a data-only format, programming language features tend to creep through the back door. Rather than remaining a data-only language, the for‐ mat becomes an esoteric and complex programming language.\n\nFor example, some systems add a count attribute to the schema of a virtual machine (VM) being provisioned. This attribute is not a property of the VM itself, but instead indicates that you want more than one of them. While useful, this is a feature of a\n\nCritical Properties and Pitfalls of Configuration Systems\n\n|\n\n317\n\nprogramming language, not a data format, because it requires an external evaluator or interpreter. A classical programming language approach would use logic outside the artifact, such as a for loop or list comprehension, to generate more VMs as required.\n\nAnother example is a configuration language that accrues string interpolation rules instead of supporting general expressions. The strings appear to be “just data,” although they can actually contain complex code, including data structure opera‐ tions, checksums, base64 encoding, and so on.\n\nThe popular YAML + Jinja solution also has drawbacks. Simple pure-data formats such as XML, JSON, YAML, and text-formatted protocol buffers are excellent choices for pure-data use cases. Likewise, textual templating engines such as Jinja2 or Go templates are excellent for HTML templating. But when combined in a configuration language, they become difficult for both humans and tools to maintain and analyze. In all of these cases, this pitfall leaves us with a complex esoteric “language” that isn’t suited to tooling.\n\nPitfall 2: Designing Accidental or Ad Hoc Language Features SREs typically feel configuration usability problems when operating systems at scale. A new language won’t have good tooling support (IDE support, good linters), and developing custom tooling is painful if the language has undocumented or esoteric semantics.\n\nAdding ad hoc programming language features to a simple config format over time might create a feature-complete solution, but ad hoc languages are more complex and usually have less expressive power than their formally designed equivalents. They also risk developing gotchas and idiosyncrasies because their authors couldn’t con‐ sider the interaction between features ahead of time.\n\nInstead of hoping your configuration system won’t grow complex enough to need simple programming constructs, it’s better to consider these requirements at the ini‐ tial design phase.\n\nPitfall 3: Building Too Much Domain-Specific Optimization The smaller the user base is for a new domain-specific solution, the longer you have to wait to accumulate enough users to justify building tooling. Engineers are unwill‐ ing to spend time understanding the language properly because it has little applicabil‐ ity outside this domain. Learning resources like Stack Overflow are less likely to be available.\n\n318\n\n|\n\nChapter 15: Configuration Specifics\n\nPitfall 4: Interleaving “Configuration Evaluation” with “Side Effects” Side effects include either making changes to external systems, or consulting out-of- band data sources (DNS, VM IDs, latest build versions) during configuration runs.\n\nSystems that allow these side effects violate hermeticity, and also prevent the separa‐ tion of config from data. In an extreme case, it is impossible to debug your config without spending money by reserving cloud resources. In order to allow separation of config and data, first evaluate the config, then make the resulting data available to the user to analyze, and only then allow for side effects.\n\nPitfall 5: Using an Existing General-Purpose Scripting Language Like Python, Ruby, or Lua This seems like a trivial way to avoid the first four pitfalls, but implementations that use a general-purpose scripting language are heavyweight and/or need intrusive sandboxing to ensure hermeticity. Since general-purpose languages can access the local system, security considerations may also call for sandboxing.\n\nAdditionally, we can’t assume that the people maintaining configuration will be familiar with all of these languages.\n\nThe desire to avoid these pitfalls led to the development of reusable domain-specific languages (DSLs) for configuration, such as HOCON, Flabbergast, Dhall, and Jsonnet. We recommend using an existing DSL for configuration. Even if a DSL seems too powerful for your needs, you may need the additional functionality at some point, and you can always restrict the functionality of the language using an in- house style guide.\n\nA Very Quick Introduction to Jsonnet Jsonnet is a hermetic open source DSL that can be used as a library or command-line tool to provide configuration for any application. It is used widely both inside and outside Google.2\n\nThe language is designed to be familiar to programmers: it uses Python-like syntax, object orientation, and functional constructs. It is an extension of JSON, meaning that a JSON file is simply a Jsonnet program that outputs itself. Jsonnet is more per‐ missive with quotes and commas than JSON, and supports comments. More impor‐ tantly, it adds computational constructs.\n\n2 While fields from computational biology to video games use Jsonnet, the most enthusiastic adopters are from the Kubernetes community. Box.com uses Jsonnet to describe the workloads that run on their Kubernetes- based internal infrastructure platform. Databricks and Bitnami also use the language extensively.\n\nCritical Properties and Pitfalls of Configuration Systems\n\n|\n\n319\n\nWhile you don’t need to be particularly familiar with Jsonnet syntax to follow the rest of this chapter, spending just a few moments reading the online tutorial can help ori‐ ent you.\n\nThere is no dominant configuration language at Google or among our reader base, but we needed to choose some language that allows us to provide examples. This chapter uses Jsonnet to show practical examples of the recommendations we provide in Chap‐ ter 14.\n\nIf you aren’t already committed to a particular configuration lan‐ guage and want to use Jsonnet, you can directly apply the examples in this chapter. In all cases, we’ve done our best to make it as easy as possible for you to abstract the underlying lesson from the code examples.\n\nAdditionally, some of the examples explore concepts (like Turing completeness) that you might expect to find in a programming book. We have taken great care to dive only as deep as required to explain a subtlety that has actually bitten us in production. In most complex systems—and certainly with respect to configurations— the failures are at the edges.\n\nIntegrating a Configuration Language This section uses Jsonnet to discuss how to integrate a configuration language with the application you need to configure, but the same techniques also transfer to other configuration languages.\n\nGenerating Config in Specific Formats A configuration language might natively output in the correct format. For example, Jsonnet outputs JSON, which is compatible with many applications. JSON is also suf‐ ficient for consumers of languages that extend JSON, such as JavaScript, YAML, or HashiCorp’s Configuration Language. If this is your situation, you don’t need to per‐ form any further integration work.\n\nFor other configuration formats that are not natively supported:\n\n1. You need to find a way to represent configuration data within the configuration language. Usually, this is not hard because configuration values like maps, lists, strings, and other primitive values are generic and available in all languages.\n\n2. Once this data is represented in the config language, you can use the constructs of that language to reduce duplication (and thus, toil).\n\n320\n\n|\n\nChapter 15: Configuration Specifics\n\n3. You need to write (or reuse) a serialization function for the necessary output for‐ mat. For example, the Jsonnet standard library has functions for outputting INI and XML from its internal JSON-like representation. If configuration data resists representation within the configuration language (for example, a Bash script), you can use basic string templating techniques as a last resort. You can find prac‐ tical examples at http://bit.ly/2La0zDe.\n\nDriving Multiple Applications Once you can drive arbitrary existing applications from the config language, you might be able to target several applications from the same config. If your applications use different config formats, you’ll need to perform some conversion work. Once you’re able to generate configuration in the necessary formats, you can easily unify, synchronize, and eliminate repetition across your entire config corpus. Given the prevalence of JSON and JSON-based formats, you may not even have to generate dif‐ ferent formats—for example, this is true if you use a deployment architecture that uses GCP Deployment Manager, AWS Cloud Formation, or Terraform for base infrastructure, plus Kubernetes for containers.\n\nAt this point, you can:\n\nOutput an Nginx web server configuration and a Terraform firewall configura‐ tion from a single Jsonnet evaluation that defines the port only once.\n\nConfigure your monitoring dashboards, retention policies, and alert notification pipelines from the same files.\n\nManage the performance tradeoff between VM startup scripts and disk image- building scripts by moving initialization commands from one list to another.\n\nAfter you unite disparate configs in one place, you have many opportunities to refine and abstract the config. Configs can even be nested—for example, a Cassandra config may be embedded inside the Deployment Manager config of its base infrastructure or inside a Kubernetes ConfigMap. A good configuration language can handle any awk‐ ward string quoting and generally make this operation natural and simple.\n\nTo make it easy to write many different files for various applications, Jsonnet has a mode that expects config execution to yield a single JSON object that maps filenames to file content (formatted as needed). You can simulate this facility in other configu‐ ration languages by emitting a map from string to string and using a postprocessing step or wrapper script to write the files.\n\nIntegrating a Configuration Language\n\n|\n\n321\n\nIntegrating an Existing Application: Kubernetes Kubernetes makes for an interesting case study for a couple of reasons:\n\nJobs running on Kubernetes need to be configured, and their configuration can become complex.\n\nKubernetes does not come with a bundled configuration language (not even an ad hoc one, thankfully).\n\nKubernetes users with minimally complex objects simply use YAML. Users with larger infrastructure extend their Kubernetes workflow with languages like Jsonnet to provide the abstraction facilities needed at that scale.\n\nWhat Kubernetes Provides Kubernetes is an open source system for orchestrating containerized workloads on a cluster of machines. Its API allows you to manage the containers themselves and many important details, such as communication between containers, communication in/out of the cluster, load balancing, storage, progressive rollout, and autoscaling. Each item of configuration is represented with a JSON object that can be managed via an API endpoint. The command-line tool kubectl lets you read these objects from disk and send them to the API.\n\nOn disk, the JSON objects are actually encoded as YAML streams.3 YAML is easily readable and converts easily to JSON via commonly available libraries. The out-of- the-box user experience involves writing YAML files that represent Kubernetes objects and running kubectl to deploy them to a cluster.\n\nTo learn about best practices for configuring Kubernetes, see the Kubernetes docu‐ mentation on that topic.\n\nExample Kubernetes Config YAML, the user interface to Kubernetes configuration, provides some simple features like comments, and has a concise syntax that most people prefer to raw JSON. How‐ ever, YAML falls short when it comes to abstraction: it only provides anchors,4 which are rarely useful in practice and are not supported by Kubernetes.\n\n3 A YAML stream is a file that contains many YAML documents separated by \"---\".\n\n4 YAML Specification §6.9.2.\n\n322\n\n|\n\nChapter 15: Configuration Specifics\n\nSuppose you want to replicate a Kubernetes object four times with different name‐ spaces, labels, and other minor variations. Following the best practices of immutable infrastructure, you store the config of all four variants, duplicating the other identical aspects of the configuration. The following code snippet presents one variant (for the sake of brevity, we omit the other three files):\n\n# example1.yaml apiVersion: v1 kind: Service metadata: labels: app: guestbook tier: frontend name: frontend namespace: prod spec: externalTrafficPolicy: Cluster ports: - port: 80 protocol: TCP targetPort: 80 selector: app: guestbook tier: frontend sessionAffinity: None type: NodePort\n\nThe variants are hard to read and maintain because the important differences are obscured.\n\nIntegrating the Configuration Language As discussed in “Configuration-Induced Toil” on page 315, managing a large number of YAML files can take a significant amount of time. A configuration language can help simplify this task. The most straightforward approach is to emit a single Kuber‐ netes object from each execution of Jsonnet, then pipe the resulting JSON directly into kubectl, which processes the JSON as if it’s YAML. Alternatively, you could emit a YAML stream (a sequence of such objects5) or a single kubectl list object, or have Jsonnet emit multiple files from the same config. For further discussion, see the Jsonnet website.\n\nDevelopers should be aware that in general, YAML allows you to write configs that are not expressible in JSON (and therefore, can’t be generated by Jsonnet). YAML configs can contain exceptional IEEE floating-point values like NaN, or objects with nonstring fields like arrays, other objects, or null. In practice, these features are very\n\n5 In the YAML specification, objects are known as documents.\n\nIntegrating an Existing Application: Kubernetes\n\n|\n\n323\n\nrarely used, and Kubernetes doesn’t allow them because the config must be JSON- encoded when sent to the API.\n\nThe following snippet shows what our example Kubernetes configuration would look like in Jsonnet:\n\n// templates.libsonnet { MyTemplate:: { local service = self, tier:: error 'Needs tier', apiVersion: 'v1', kind: 'Service',\n\nlocal selector_labels = { app: 'guestbook', tier: service.tier },\n\nmetadata: { labels: selector_labels, name: 'guestbook-' + service.tier, namespace: 'default', },\n\nspec: { externalTrafficPolicy: 'Cluster', ports: [{ port: 80, protocol: 'TCP', targetPort: 80, }], selector: selector_labels, sessionAffinity: 'None', type: 'NodePort', }, }, }\n\n// example1.jsonnet local templates = import 'templates.libsonnet';\n\ntemplates.MyTemplate { tier: 'frontend', }\n\n// example2.jsonnet local templates = import 'templates.libsonnet';\n\ntemplates.MyTemplate { tier: 'backend', metadata+: { namespace: 'prod', }, }\n\n324\n\n|\n\nChapter 15: Configuration Specifics\n\n// example3.jsonnet local templates = import 'templates.libsonnet';\n\ntemplates.MyTemplate { tier: 'frontend', metadata+: { namespace: 'prod', labels+: { foo: 'bar' }, }, }\n\n// example4.jsonnet local templates = import 'templates.libsonnet';\n\ntemplates.MyTemplate { tier: 'backend', }\n\nNote the following:\n\nWe express all four variants by instantiating an abstract template four times, but you could also use functional abstractions.\n\nWhile we use a separate Jsonnet file for each instance, you might also consolidate them in a single file.\n\nIn the abstract template, the namespace defaults to default and the tier must be overridden.\n\nAt first glance, the Jsonnet is slightly more verbose, but reduces toil as the num‐ ber of template instantiations grows.\n\nWithin MyTemplate, the local keyword defines a variable service, which is initial‐ ized to self (a reference to the closest enclosing object). This allows you to refer to the object from within nested objects, where self is redefined.\n\nThe tier field has two colons (rather than the regular JSON single colon) and is hid‐ den (not output) in the generated JSON. Otherwise, Kubernetes will reject tier as an unrecognized field. Hidden fields can still be overridden and referenced—in this case, as service.tier.\n\nThe template cannot be used by itself because referencing service.tier triggers the error construct, which raises a runtime error with the given text. To avoid the error, each instance of the template overrides the tier field with some other expression. In other words, this pattern expresses something similar to a pure virtual/abstract method.\n\nUsing functions for abstraction means that config can only be parameterized. In con‐ trast, templates allow you to override any field from the parent. As described in\n\nIntegrating an Existing Application: Kubernetes\n\n|\n\n325",
      "page_number": 336
    },
    {
      "number": 39,
      "title": "Segment 39 (pages 346-353)",
      "start_page": 346,
      "end_page": 353,
      "detection_method": "topic_boundary",
      "content": "Chapter 14, while simplicity should be fundamental to your design, the ability to escape simplicity is important. Template overrides provide a useful escape hatch to change specific details that might normally be considered too low-level. For example:\n\ntemplates.MyTemplate { tier: 'frontend', spec+: { sessionAffinity: 'ClientIP', }, }\n\nHere’s a typical workflow to convert an existing template to Jsonnet:\n\n1. Convert one of the YAML variants to JSON.\n\n2. Run the resulting JSON through the Jsonnet formatter.\n\n3. Manually add Jsonnet constructs to abstract and instantiate the code (as shown in the example).\n\nThe example showed how to remove duplication while retaining certain fields that were different. Using a configuration language becomes more compelling as differ‐ ences become more subtle (e.g., strings are slightly different) or challenging to express (e.g., configuration has structural differences like additional elements in arrays, or the same difference applied across all elements of an array).\n\nIn general, abstracting commonalities across different configurations promotes sepa‐ ration of concerns and has the same benefits as modularity in programming lan‐ guages. You can take advantage of abstraction capabilities for a number of different use cases:\n\nA single team might need to create multiple versions of their configuration that are almost (but not quite) the same—for example, when managing deployments across varied environments (prod/stage/dev/test), tuning deployments on differ‐ ent architectures, or adjusting capacity in different geographies.\n\nAn organization might have an infrastructure team that maintains reusable com‐ ponents—API serving frameworks, cache servers, or MapReduces—that are used by the application teams. For each component, the infrastructure team can main‐ tain a template that defines the Kubernetes objects needed to run that compo‐ nent at scale. Each application team can instantiate that template to add the particulars of their application.\n\nIntegrating Custom Applications (In-House Software) If your infrastructure utilizes any custom applications (i.e., software developed in- house, as opposed to off-the-shelf solutions), then you can design those applications\n\n326\n\n|\n\nChapter 15: Configuration Specifics\n\nto coexist with a reusable configuration language. The suggestions in this section should improve the overall user configuration experience when you are writing con‐ fig files or interacting with the generated config data (e.g., for debugging purposes, or when integrating with other tools). They should also simplify the application’s design and separate configuration from data.\n\nYour broad strategy for approaching custom applications should be to:\n\nLet the config language handle what it’s designed for: the language aspect of the problem.\n\nLet your application handle all other functionality.\n\nThe following best practices include examples that use Jsonnet, but the same recom‐ mendations apply to other languages:\n\nConsume a single pure data file, and let the config language split the config into files using imports. This means the config language implementation only has to emit (and the application only has to consume) a single file. Also, since applica‐ tions can combine files in different ways, this strategy explicitly and clearly delin‐ eates how the files are combined to form the application configuration.\n\nRepresent collections of named entities using objects, where the field contains the object name and the value contains the rest of the entity. Avoid using an array of objects where each element has a name field. Bad JSON: [ { \"name\": \"cat\", ... }, { \"name\": \"dog\", ... } ]\n\nGood JSON:\n\n{ \"cat\": { ... }, \"dog\": { ... } }\n\nThis strategy makes the collection (and individual animals) easier to extend, and you can reference entities by name (e.g., animals.cat) instead of referencing brittle indexes (e.g., animals[0]).\n\nAvoid grouping entities by type at the top level. Structure the JSON so that logi‐ cally related configuration is grouped in the same subtree. This allows abstrac‐ tion (at the config language level) to follow functional boundaries.\n\nIntegrating Custom Applications (In-House Software)\n\n|\n\n327\n\nBad JSON: { \"pots\": { \"pot1\": { ... }, \"pot2\": { ... } }, \"lids\": { \"lid1\": { ... }, \"lid2\": { ... } } }\n\nGood JSON:\n\n{ \"pot_assembly1\": { \"pot\": { ... }, \"lid\": { ... } }, \"pot_assembly2\": { \"pot\": { ... }, \"lid\": { ... } } }\n\nAt the config language level, this strategy enables abstractions like the following:\n\nlocal kitchen = import 'kitchen.libsonnet'; { pot_assembly1: kitchen.CrockPot, pot_assembly2: kitchen.SaucePan { pot+: { color: 'red' } }, }\n\nGenerally keep the data representation design simple:\n\n— Avoid embedding language features in the data representation (as mentioned in “Pitfall 1: Failing to Recognize Configuration as a Programming Language Problem” on page 317). These types of abstractions will be underpowered and only create confusion, since they force users to decide whether to use the abstraction features in the data representation or in the configuration language.\n\n— Don’t worry about overly verbose data representation. Solutions to reduce verbosity introduce complexity, and the problem can be managed in the con‐ figuration language.\n\n— Avoid interpreting custom string interpolation syntax, such as conditionals or placeholder references in strings, in your application. Sometimes interpreta‐ tion is unavoidable—for example, when you need to describe actions that are performed after the pure data version of the config is generated (alerts, han‐ dlers, etc.). But otherwise, let the config language do as much of the language- level work as possible.\n\nAs mentioned earlier, if you can remove configuration altogether, doing so is always your best option. Although the configuration language can hide the complexity of the underlying model by using templates with default values, the generated config data is not completely hidden—it may be processed by tools, inspected by humans, or loaded into config databases. For the same reason, don’t rely on the configuration language to fix inconsistent naming, plurals, or mistakes in the underlying model— fix them in the model itself. If you can’t fix inconsistencies in the model, it is better to live with them at the language level to avoid even more inconsistency.\n\n328\n\n|\n\nChapter 15: Configuration Specifics\n\nIn our experience, configuration changes tend to dominate outage root causes over time in a system (see our list of top causes of outages in Appendix C). Validating your config changes is a key step to maintaining reliability. We recommend validating the generated config data immediately after configuration execution. Syntactic validation alone (i.e., checking whether JSON is parsable) won’t find many bugs. After generic schema validation, check properties that are specific to your application’s domain— for example, whether required fields are present, referenced filenames exist, and pro‐ vided values are within allowed ranges.\n\nYou can validate Jsonnet’s JSON with JSONschema. For applications using protocol buffers, you can easily generate the canonical JSON form of these buffers from Json‐ net, and the protocol buffer implementation will validate during deserialization.\n\nNo matter how you decide to validate, do not ignore unrecognized field names, as they may indicate a typo at the configuration language level. Jsonnet can mask fields that should not be output using the :: syntax. It’s also a good idea to perform the same validation in a precommit hook.\n\nEffectively Operating a Configuration System When implementing “configuration as code” in any language, we recommend fol‐ lowing the discipline and processes that aid software engineering generally.\n\nVersioning Configuration languages usually trigger engineers to write libraries of templates and utility functions. Often, one team maintains these libraries, but many other teams may consume them. When you need to make a breaking change to the library, you have two choices:\n\nCommit a global update of all client code, refactoring the code so that it still works (this may not be organizationally possible).\n\nVersion the library so that different consumers can use different versions and migrate independently. Consumers who opt to use deprecated versions won’t get the benefits of the new versions and will incur technical debt—someday, they will have to refactor their code to use the new library.\n\nMost languages, including Jsonnet, do not provide any specific support for version‐ ing; instead, you can easily use directories. For a practical example in Jsonnet, see the ksonnet-lib repository, where the version is the first component of the imported path:\n\nlocal k = import 'ksonnet.beta.2/k.libsonnet';\n\nEffectively Operating a Configuration System\n\n|\n\n329\n\nSource Control Chapter 14 advocates keeping a historical record of config changes (including who made them) and ensuring that rollbacks are easy and reliable. Checking configura‐ tion into source control brings all these capabilities, plus the ability to code review config changes.\n\nTooling Consider how you will enforce style and lint your configurations, and investigate if there’s an editor plug-in that integrates these tools into your workflow. Your goals here are to maintain a consistent style across all authors, to improve readability, and to detect errors. Some editors support post-write hooks that can run formatters and other external tools for you. You can also use precommit hooks to run the same tools to ensure checked-in config is high quality.\n\nTesting We recommend implementing unit tests for upstream template libraries. Make sure the libraries generate the expected concrete configuration when instantiated in vari‐ ous ways. Similarly, libraries of functions should include unit tests so they can be maintained with confidence.\n\nIn Jsonnet, you can write tests as Jsonnet files that:\n\n1. Import the library to be tested.\n\n2. Exercise the library. 3. Use either the assert statement or the standard library assertEqual function to validate its output. The latter presents any mismatching values in its error messages.\n\nThe following example tests the joinName function and MyTemplate:\n\n// utils_test.jsonnet local utils = import 'utils.libsonnet';\n\nstd.assertEqual(utils.joinName(['foo', 'bar']), 'foo-bar') && std.assertEqual(utils.MyTemplate { tier: 'frontend' }, { ... })\n\nFor larger test suites, you can take advantage of a more comprehensive unit test framework developed by Jsonnet community members. You can use this framework to define and run suites of tests in a structured manner—for example, to report the set of all failing tests instead of aborting execution at the first failing assertion.\n\n330\n\n|\n\nChapter 15: Configuration Specifics\n\nWhen to Evaluate Configuration Our critical properties include hermeticity; that is, configuration languages must gen‐ erate the same config data regardless of where or when they execute. As described in Chapter 14 a system can be hard or impossible to roll back if it depends on resources that can change outside of its hermetic environment. Generally, hermeticism means that Jsonnet code is always interchangeable with the expanded JSON it represents. Accordingly, you can generate JSON from Jsonnet at any time between when the Jsonnet is updated and when you need the JSON—even each time you need the JSON.\n\nWe recommend storing configuration in version control. Then your earliest opportu‐ nity to validate the config is before check-in. At the other extreme, an application can evaluate the config when it needs the JSON data. As a middle-of-the-road option, you can evaluate at build time. Each of these options has various tradeoffs, and you should optimize according to the specifics of your use case.\n\nVery Early: Checking in the JSON You can generate JSON from the Jsonnet code before checking both in to version control. The typical workflow is as follows:\n\n1. Modify the Jsonnet files.\n\n2. Run the Jsonnet command-line tool (perhaps wrapped in a script) to regenerate JSON files.\n\n3. Use a precommit hook to ensure that the Jsonnet code and JSON output are always consistent.\n\n4. Package everything into a pull request for a code review.\n\nPros\n\nThe reviewer can sanity-check the concrete changes—for example, a refactoring should not affect the generated JSON at all.\n\nYou can inspect line annotations by multiple authors across different versions at both the generated and abstracted level. This is useful for auditing changes.\n\nYou don’t need to run Jsonnet at runtime, which can help to limit complexity, binary size, and/or risk exposure.\n\nWhen to Evaluate Configuration\n\n|\n\n331\n\nCons\n\nThe generated JSON is not necessarily readable—for example, if it embeds long strings.\n\nThe JSON may not be suitable for checking into version control for other reasons —for example, if it’s too large or contains secrets.\n\nMerge conflicts may arise if many concurrent edits to separate Jsonnet files con‐ verge to a single JSON file.\n\nMiddle of the Road: Evaluate at Build Time You can avoid checking JSON into source control by running the Jsonnet command- line utility at build time and embedding the generated JSON into the release artifact (e.g., as a tarball). The application code simply reads the JSON file from disk at initi‐ alization time. If you’re using Bazel, you can easily achieve this using the Jsonnet Bazel rules. At Google, we commonly favor this approach because of the pros listed next.\n\nPros\n\nYou have the ability to control runtime complexity, binary size, and risk expo‐ sure without having to rebuild the JSON files in each pull request.\n\nThere’s no risk of desynchronization between originating Jsonnet code and resulting JSON.\n\nCons\n\nThe build is more complex.\n\nIt’s harder to evaluate the concrete change during code review.\n\nLate: Evaluate at Runtime Linking the Jsonnet library allows the application itself to interpret the config at any time, yielding an in-memory representation of the generated JSON config.\n\nPros\n\nIt’s simpler, as you don’t need a prior evaluation.\n\nYou gain the ability to evaluate Jsonnet code provided by the user during execution.\n\n332\n\n|\n\nChapter 15: Configuration Specifics\n\nCons\n\nAny linked library increases the footprint and risk exposure.\n\nConfiguration bugs may be discovered at runtime, which is too late.\n\nIf the Jsonnet code is untrusted, you must take special care. (We discuss why in “Guarding Against Abusive Configuration” on page 333.)\n\nTo follow our running example, when should you run Jsonnet if you’re generating Kubernetes objects?\n\nThe answer depends on your implementation. If you’re building something like ksonnet (a client-side command-line tool that runs Jsonnet code from the local file‐ system), the easiest solution is to link the Jsonnet library into the tool and evaluate the Jsonnet in process. Doing so is safe because code runs on the author’s own machine.\n\nBox.com’s infrastructure uses Git hooks to push configuration changes to produc‐ tion. To avoid executing Jsonnet on the server, the Git hooks act on generated JSON that’s kept in the repository. For a deployment management daemon like Helm or Spinnaker, your only choice is to evaluate the Jsonnet on the server at runtime (with the caveats described in the next section).\n\nGuarding Against Abusive Configuration Unlike long-running services, configuration execution should quickly terminate with the resulting config. Unfortunately, due to bugs or deliberate attacks, configuration may take an arbitrary amount of CPU time or memory. To illustrate why, consider the following nonterminating Jsonnet program:\n\nlocal f(x) = f(x + 1); f(0)\n\nA program that uses unbounded memory is similar:\n\nlocal f(x) = f(x + [1]); f([])\n\nYou can write equivalent examples using objects instead of functions, or in other configuration languages.\n\nYou might try to avoid overconsuming resources by restricting the language so that it is no longer Turing complete. However, enforcing that all configurations terminate doesn’t necessarily prevent overconsuming resources. It’s easy to write a program that consumes enough time or memory to be practically nonterminating. For example:\n\nlocal f(x) = if x == 0 then [] else [f(x - 1), f(x - 1)]; f(100)\n\nIn fact, such programs exist even with simple config formats like XML and YAML.\n\nGuarding Against Abusive Configuration\n\n|\n\n333",
      "page_number": 346
    },
    {
      "number": 40,
      "title": "Segment 40 (pages 354-361)",
      "start_page": 354,
      "end_page": 361,
      "detection_method": "topic_boundary",
      "content": "In practice, the risk of these scenarios depends on the situation. On the less problem‐ atic side, suppose a command-line tool uses Jsonnet to build Kubernetes objects and then deploys those objects. In this case, the Jsonnet code is trusted: accidents that produce nontermination are rare, and you can use Ctrl-C to mitigate them. Acciden‐ tal memory exhaustion is extremely unlikely. At the other extreme, with a service like Helm or Spinnaker, which accepts arbitrary config code from an end user and evalu‐ ates it in a request handler, you must be very careful to avoid DOS attacks that might tie up request handlers or exhaust memory.\n\nIf you evaluate untrusted Jsonnet code in a request handler, you can avoid such attacks by sandboxing the Jsonnet execution. One easy strategy is to use a separate process and ulimit (or its non-UNIX equivalent). Typically, you need to fork to the command-line executable instead of linking the Jsonnet library. As a result, programs that do not complete within given resources fail safely and inform the end user. For additional defense against C++ memory exploits, you can use the native Go imple‐ mentation of Jsonnet.\n\nConclusion Whether you use Jsonnet, adopt another configuration language, or develop your own, we hope that you can apply these best practices to manage the complexity and operational load required to configure your production system with confidence.\n\nAt a minimum, the critical properties of a configuration language are good tooling, hermetic configurations, and separation of configuration and data.\n\nYour system may not be complex enough to need a configuration language. Transi‐ tioning to a domain-specific language like Jsonnet is a strategy to consider when your complexity increases. Doing so will allow you to provide a consistent and well- structured interface, and will free up your SRE team’s time to work on other impor‐ tant projects.\n\n334\n\n|\n\nChapter 15: Configuration Specifics\n\nCHAPTER 16 Canarying Releases\n\nBy Alec Warner and Štěpán Davidovič with Alex Hidalgo, Betsy Beyer, Kyle Smith, and Matt Duftler\n\nRelease engineering is a term we use to describe all the processes and artifacts related to getting code from a repository into a running production system. Automating releases can help avoid many of the traditional pitfalls associated with release engi‐ neering: the toil of repetitive and manual tasks, the inconsistency of a nonautomated process, the inability of knowing the exact state of a rollout, and the difficulty of roll‐ ing back. The automation of release engineering has been well covered in other litera‐ ture—for example, books on continuous integration and continuous delivery (CI/CD).1\n\nWe define canarying as a partial and time-limited deployment of a change in a service and its evaluation. This evaluation helps us decide whether or not to proceed with the rollout. The part of the service that receives the change is “the canary,” and the remainder of the service is “the control.” The logic underpinning this approach is that usually the canary deployment is performed on a much smaller subset of produc‐ tion, or affects a much smaller subset of the user base than the control portion. Can‐ arying is effectively an A/B testing process.\n\nWe’ll first cover the basics of release engineering and the benefits of automating releases to establish a shared vocabulary.\n\n1 The authors of this chapter are fans of Jez Humble and David Farley’s book Continuous Delivery: Reliable\n\nSoftware Releases Through Build, Test, and Deployment Automation (Boston: Pearson, 2011).\n\n335\n\nRelease Engineering Principles The basic principles of release engineering are as follows:\n\nReproducible builds\n\nThe build system should be able to take the build inputs (source code, assets, and so on) and produce repeatable artifacts. The code built from the same inputs last week should produce the same output this week.\n\nAutomated builds\n\nOnce code is checked in, automation should produce build artifacts and upload them to a storage system.\n\nAutomated tests\n\nOnce the automated build system builds artifacts, a test suite of some kind should ensure they function.\n\nAutomated deployments\n\nDeployments should be performed by computers, not humans.\n\nSmall deployments\n\nBuild artifacts should contain small, self-contained changes.\n\nThese principles provide specific benefits to operators:\n\nReducing operational load on engineers by removing manual and repetitive tasks.\n\nEnforcing peer review and version control, since automation is generally code-based.\n\nEstablishing consistent, repeatable, automated processes, resulting in fewer mistakes.\n\nEnabling monitoring of the release pipeline, allowing for measurement and con‐ tinuous improvement by addressing questions like:\n\n— How long does it take a release to reach production?\n\n— How often are releases successful? A successful release is a release made avail‐\n\nable to customers with no severe defects or SLO violations.\n\n— What changes can be made to catch defects as early in the pipeline as\n\npossible?\n\n— Which steps can be parallelized or further optimized?\n\nCI/CD coupled with release automation can deliver continuous improvements to the development cycle, as shown in Figure 16-1. When releases are automated, you can\n\n336\n\n|\n\nChapter 16: Canarying Releases\n\nrelease more often. For software with a nontrivial rate of change, releasing more often means fewer changes are bundled in any given release artifact. Smaller, self-contained release artifacts make it cheaper and easier to roll back any given release artifact in the event of a bug. Quicker release cadences mean that bug fixes reach users faster.\n\nFigure 16-1. The virtuous cycle of CI/CD\n\nBalancing Release Velocity and Reliability Release velocity (hereafter called “shipping”) and reliability are often treated as opposing goals. The business wants to ship new features and product improvements as quickly as possible with 100% reliability! While that goal is not achievable (as 100% is never the right target for reliability; see Chapter 2), it is possible to ship as quickly as possible while meeting specific reliability goals for a given product.\n\nThe first step toward this goal is understanding the impact of shipping on software reliability. In Google’s experience, a majority of incidents are triggered by binary or configuration pushes (see Appendix C). Many kinds of software changes can result in a system failure—for example, changes in the behavior of an underlying component, changes in the behavior of a dependency (such as an API), or a change in configura‐ tion like DNS.\n\nDespite the risk inherent in making changes to software, these changes—bug fixes, security patches, and new features—are necessary for the business to succeed. Instead of advocating against change, you can use the concept of SLOs and error budgets to measure the impact of releases on your reliability. Your goal should be to ship soft‐ ware as quickly as possible while meeting the reliability targets your users expect. The following section discusses how you can use a canary process to achieve these goals.\n\nSeparating Components That Change at Different Rates Your services are composed of multiple components with different rates of change: binaries or code, environments such as JVM, kernel/OS, libraries, service config or flags, feature/experiment config, and user config. If you have only one way to deploy\n\nBalancing Release Velocity and Reliability\n\n|\n\n337\n\nchanges, actually allowing these components to change independently may be difficult.\n\nFeature flag or experiment frameworks like Gertrude, Feature, and PlanOut allow you to separate feature launches from binary releases. If a binary release includes multiple features, you can enable them one at a time by changing the experiment configuration. That way, you don’t have to batch all of these changes into one big change or perform an individual release for each feature. More importantly, if only some of the new features don’t behave as expected, you can selectively disable those features until the next build/release cycle can deploy a new binary.\n\nYou can apply the principles of feature flags/experiments to any type of change to your service, not just software releases.\n\nWhat Is Canarying? The term canarying refers to the practice of bringing canaries into coal mines to determine if the mine is safe for humans. Because the birds are smaller and breathe faster than humans, they are intoxicated by dangerous gases faster than their human handlers.\n\nEven if your release pipeline is fully automated, you won’t be able to detect all release-related defects until real traffic is hitting the service. By the time a release is ready to be deployed to production, your testing strategy should instill reasonable confidence that the release is safe and works as intended. However, your test environ‐ ments aren’t 100% identical to production, and your tests probably don’t cover 100% of possible scenarios. Some defects will reach production. If a release deploys instantly everywhere, any defects will deploy in the same way.\n\nThis scenario might be acceptable if you can detect and resolve the defects quickly. However, you have a safer alternative: initially expose just some of your production traffic to the new release using a canary. Canarying allows the deployment pipeline to detect defects as quickly as possible with as little impact to your service as possible.\n\nRelease Engineering and Canarying When deploying a new version of a system or its key components (such as configura‐ tion or data), we bundle changes—changes that typically have not been exposed to real-world inputs, such as user-facing traffic or batch processing of user-supplied data. Changes bring new features and capabilities, but they also bring risk that is exposed at the time of deployment. Our goal is to mitigate this risk by testing each change on a small portion of traffic to gain confidence that it has no ill effects. We will discuss evaluation processes later in this chapter.\n\n338\n\n|\n\nChapter 16: Canarying Releases\n\nThe canary process also lets us gain confidence in our change as we expose it to larger and larger amounts of traffic. Introducing the change to actual production traffic also enables us to identify problems that might not be visible in testing frameworks like unit testing or load testing, which are often more artificial.\n\nWe will examine the process of canarying and its evaluation using a worked example, while steering clear of a deep dive into statistics. Instead, we focus on the process as a whole and typical practical considerations. We use a simple application on App Engine to illustrate various aspects of the rollout.\n\nRequirements of a Canary Process Canarying for a given service requires specific capabilities:\n\nA method to deploy the canary change to a subset of the population of the service.2\n\nAn evaluation process to evaluate if the canaried change is “good” or “bad.”\n\nIntegration of the canary evaluations into the release process.\n\nUltimately, the canary process demonstrates value when canaries detect bad release candidates with high confidence, and identify good releases without false positives.\n\nOur Example Setup We’ll use a simple frontend web service application to illustrate some canarying con‐ cepts. The application offers an HTTP-based API that consumers can use to manipu‐ late various data (simple information like the price of a product). The example application has some tunable parameters that we can use to simulate various produc‐ tion symptoms, to be evaluated by the canary process. For example, we can make the application return errors for 20% of requests, or we can stipulate that 5% of requests take at least two seconds.\n\nWe illustrate the canary process using an application deployed on Google App Engine, but the principles apply to any environment. While the example application is fairly contrived, in real-world scenarios, similar applications share common signals with our example that can be used in a canary process.\n\nOur example service has two potential versions: live and release candidate. The live version is the version currently deployed in production, and the release candidate is a newly built version. We use these versions to illustrate various rollout concepts and how to implement canaries to make the rollout process safer.\n\n2 The fraction of total service load you run on the canary should be proportional to the size of the canary\n\npopulation.\n\nRelease Engineering and Canarying\n\n|\n\n339\n\nA Roll Forward Deployment Versus a Simple Canary Deployment Let’s first look at a deployment with no canary process, so we can later compare it to a canaried deployment in terms of error budget savings and general impact when a breakage occurs. Our deployment process features a development environment. Once we feel the code is working in the development environment, we deploy that version in the production environment.\n\nShortly after our deployment, our monitoring starts reporting a high rate of errors (see Figure 16-2, where we intentionally configured our sample application to fail 20% of requests to simulate a defect in the example service). For the sake of this example, let’s say that our deployment process doesn’t provide us the option to roll back to a previously known good configuration. Our best option to fix the errors is to find defects in the production version, patch them, and deploy a new version during the outage. This course of action will almost certainly prolong the user impact of the bug.\n\nFigure 16-2. High rate of errors after deployment\n\n340\n\n|\n\nChapter 16: Canarying Releases\n\nTo improve upon this initial deployment process, we can utilize canaries in our roll‐ out strategy to reduce the impact of a bad code push. Instead of deploying to produc‐ tion all at once, we need a way to create a small segment of production that runs our release candidate. Then we can send a small portion of the traffic to that segment of production (the canary) and compare it against the other segment (the control). Using this method, we can spot defects in the release candidate before all of produc‐ tion is affected.\n\nThe simple canary deployment in our App Engine example splits traffic between spe‐ cific labeled versions of our application. You can split traffic using App Engine, or any number of other methods, such as backend weights on a load balancer, proxy configurations, or round-robin DNS records.\n\nFigure 16-3 shows that the impact of the change is greatly reduced when we use a canary; in fact, the errors are barely visible! This raises an interesting issue: the canary evaluation is difficult to see and track compared to the overall traffic trend.\n\nFigure 16-3. Error rate of canary deployment; because the canary population is a small subset of production, the overall error rate is reduced\n\nTo get a clearer picture of the errors we need to track at a reasonable scale, we can look at our key metric (HTTP response codes) by App Engine application version, as\n\nA Roll Forward Deployment Versus a Simple Canary Deployment\n\n|\n\n341",
      "page_number": 354
    },
    {
      "number": 41,
      "title": "Segment 41 (pages 362-371)",
      "start_page": 362,
      "end_page": 371,
      "detection_method": "topic_boundary",
      "content": "shown in Figure 16-4. When we look at per-version breakdown, we can plainly see the errors the new version introduces. We can also observe from Figure 16-4 that the live version is serving very few errors.\n\nWe can now tune our deployment to automatically react based on the HTTP error rate by App Engine version. If the error rate of the canary metric is too far from the control error rate, this signals the canary deployment is “bad.” In response, we should pause and roll back the deployment, or perhaps contact a human to help trouble‐ shoot the issue. If the error ratios are similar, we can proceed with the deployment as normal. In the case of Figure 16-4, our canary deployment is clearly bad and we should roll it back.\n\nFigure 16-4. HTTP response codes by App Engine version; the release candidate serves the vast majority of the errors, while the live version produces a low number of errors at a steady state (note: the graph uses a base-10 log scale)\n\nCanary Implementation Now that we’ve seen a fairly trivial canary deployment implementation, let’s dig deeper into the parameters that we need to understand for a successful canary process.\n\n342\n\n|\n\nChapter 16: Canarying Releases\n\nMinimizing Risk to SLOs and the Error Budget Chapter 2 discusses how SLOs reflect business requirements around service availabil‐ ity. These requirements also apply to canary implementations. The canary process risks only a small fragment of our error budget, which is limited by time and the size of the canary population.\n\nGlobal deployment can place the SLO at risk fairly quickly. If we deploy the candidate from our trivial example, we would risk failing 20% of requests. If we instead use a canary population of 5%, we serve 20% errors for 5% of traffic, resulting in a 1% over‐ all error rate (as seen earlier in Figure 16-3). This strategy allows us to conserve our error budget—impact on the budget is directly proportional to the amount of traffic exposed to defects. We can assume that detection and rollback take about the same time for both the naive deployment and the canary deployment, but when we inte‐ grate a canary process into our deployment, we learn valuable information about our new version at a much lower cost to our system.\n\nThis is a very simple model that assumes uniform load. It also assumes that we can spend our entire error budget (beyond what we’ve already included in the organic measurement of current availability) on canaries. Rather than actual availability, here we consider only unavailability introduced by new releases. Our model also assumes a 100% failure rate because this is a worst-case scenario.3 It is likely that defects in the canary deployment will not affect 100% of system usage. We also allow overall system availability to go below SLO for the duration of the canary deployment.4\n\nThis model has clear flaws, but is a solid starting point that you can adjust to match business needs.5 We recommend using the simplest model that meets your technical and business objectives. In our experience, focusing on making the model as techni‐ cally correct as possible often leads to overinvestment in modeling. For services with high rates of complexity, overly complex models can lead to incessant model tuning for no real benefit.\n\nChoosing a Canary Population and Duration When choosing an appropriate canary duration, you need to factor in development velocity. If you release daily, you can’t let your canary last for a week while running\n\n3 At least as far as availability is concerned. This analysis obviously does not cover the impact of incidents, such\n\nas a data leak.\n\n4 For a sufficiently small canary, where the fraction of service equals the difference between actual availability\n\nand SLO, we can canary nonstop with confidence. This is our use of the error budget.\n\n5 As British statistician George Box said, “Essentially, all models are wrong, but some are useful.” George E. P. Box and Norman R. Draper, Empirical Model-Building and Response Surfaces (New York: John Wiley and Sons, 1987).\n\nCanary Implementation\n\n|\n\n343\n\nonly one canary deployment at a time. If you deploy weekly, you have time to per‐ form fairly long canaries. If you deploy continuously (for example, 20 times in a day), your canary duration must be significantly shorter. On a related note, while we can run multiple canary deployments simultaneously, doing so adds significant mental effort to track system state. This can become problematic during any nonstandard circumstances, when reasoning about the system’s state quickly is important. Run‐ ning simultaneous canaries also increases the risk of signal contamination if the cana‐ ries overlap. We strongly advise running only one canary deployment at a time.\n\nFor basic evaluation, we do not need a terribly large canary population in order to detect key critical conditions.6 However, a representative canary process requires decisions across many dimensions:\n\nSize and duration\n\nIt should be sizeable and last long enough to be representative of the overall deployment. Terminating a canary deployment after receiving just a handful of queries doesn’t provide a useful signal for systems characterized by diverse quer‐ ies with varied functionality. The higher the processing rate, the less time is required to get a representative sample in order to ensure the observed behavior is actually attributable to the canaried change, and not just a random artifact.\n\nTraffic volume\n\nWe need to receive enough traffic on the system to ensure it has handled a repre‐ sentative sample, and that the system has a chance to react negatively to the inputs. Typically, the more homogeneous the requests, the less traffic volume you need.\n\nTime of day\n\nPerformance defects typically manifest only under heavy load,7 so deploying at an off-peak time likely wouldn’t trigger performance-related defects.\n\nMetrics to evaluate\n\nThe representativeness of a canary is tightly connected to the metrics we choose to evaluate (which we’ll discuss later in this chapter). We can evaluate trivial met‐ rics like query success quickly, but other metrics (such as queue depth) may need more time or a large canary population to provide a clear signal.\n\nFrustratingly, these requirements can be mutually at odds. Canarying is a balancing act, informed both by cold analysis of worst-case scenarios and the past realistic track record of a system. Once you’ve gathered metrics from past canaries, you can choose\n\n6 See a discussion of real-world outages at http://bit.ly/2LgorFz.\n\n7 For example, consider resource contention problems, such as database write conflicts or locking in multi‐\n\nthreaded applications.\n\n344\n\n|\n\nChapter 16: Canarying Releases\n\ncanary parameters based upon typical canary evaluation failure rates rather than hypothetical worst-case scenarios.\n\nSelecting and Evaluating Metrics So far, we have been looking at the success ratio, a very clear and obvious metric for canary evaluation. But intuitively, we know this single metric is not sufficient for a meaningful canary process. If we serve all requests at 10 times the latency, or use 10 times as much memory while doing so, we might also have a problem. Not all metrics are good candidates for evaluating a canary. What properties of metrics are best suited for evaluating whether a canary is good or bad?\n\nMetrics Should Indicate Problems First and foremost, the metric needs to be able to indicate problems in the service. This is tricky because what constitutes a “problem” isn’t always objective. We can probably consider a failed user request problematic.8 But what if a request takes 10% longer, or the system requires 10% more memory? We typically recommend using SLIs as a place to start thinking about canary metrics. Good SLIs tend to have strong attribution to service health. If SLIs are already being measured to drive SLO compli‐ ance, we can reuse that work.\n\nAlmost any metric can be problematic when taken to the extreme, but there’s also a cost to adding too many metrics to your canary process. We need to correctly define a notion of acceptable behavior for each of the metrics. If the idea of acceptable behavior is overly strict, we will get lots of false positives; that is, we will think a can‐ ary deployment is bad, even though it isn’t. Conversely, if a definition of acceptable behavior is too loose, we will be more likely to let a bad canary deployment go unde‐ tected. Choosing what’s acceptable behavior correctly can be an expensive process— it’s time-consuming and requires analysis. When it’s done poorly, however, your results can completely mislead you. Also, you need to reevaluate expectations on a regular basis as the service, its feature set, and its behavior evolve.\n\nWe should stack-rank the metrics we want to evaluate based on our opinion of how well they indicate actual user-perceivable problems in the system. Select the top few metrics to use in canary evaluations (perhaps no more than a dozen). Too many met‐ rics can bring diminishing returns, and at some point, the returns are outweighed by the cost of maintaining them, or the negative impact on trust in the release process if they are not maintained.\n\n8 A failed user request isn’t necessarily problematic. User requests can fail because the user requested some‐\n\nthing unreasonable, such as accessing a nonexistent URL. We need to be disciplined in distinguishing errors like these from problems in the systems.\n\nSelecting and Evaluating Metrics\n\n|\n\n345\n\nTo make this guideline more tangible, let’s look at our example service. It has many metrics we might evaluate: CPU usage, memory footprint, HTTP return codes (200s, 300s, etc.), latency of response, correctness, and so on. In this case, our best metrics are likely the HTTP return codes and latency of response because their degradation most closely maps to an actual problem that impacts users. In this scenario, metrics for CPU usage aren’t as useful: an increase in resource usage doesn’t necessarily impact a service and may result in a flaky or noisy canary process. This can result in the canary process being disabled or ignored by operators, which can defeat the point of having a canary process in the first place. In the case of frontend services, we intui‐ tively know that being slower or failing to respond are typically reliable signals that there are problems in the service.\n\nHTTP return codes contain interesting tricky cases, such as code 404, which tells us the resource was not found. This could happen because users get the wrong URL (imagine a broken URL getting shared on a popular discussion board), or because the server incorrectly stops serving a resource. Often we can work around problems like this by excluding 400-level codes from our canary evaluation and adding black-box monitoring to test for the presence of a particular URL. We can then include the black-box data as part of our canary analysis to help isolate our canary process from odd user behaviors.\n\nMetrics Should Be Representative and Attributable The source of changes in the observed metrics should be clearly attributable to the change we are canarying, and should not be influenced by external factors.\n\nIn a large population (for example, many servers or many containers), we are likely to have outliers—oversubscribed machines, machines running different kernels with different performance characteristics, or machines on an overloaded segment of the network. The difference between the canary population and the control is just as much a function of the change we have deployed as the difference between the two infrastructures on which we deploy.\n\nManaging canaries is a balancing act between a number of forces. Increasing the size of the canary population is one way to decrease impact of this problem (as discussed earlier). When we reach what we consider a reasonable canary population size for our system, we need to consider whether the metrics we have chosen could show high variance.\n\nWe should also be aware of shared failure domains between our canary and control environments; a bad canary could negatively impact the control, while bad behavior in the system might lead us to incorrectly evaluate the canary. Similarly, make sure that your metrics are well isolated. Consider a system that runs both our application and other processes. A dramatic increase in CPU usage of the system as a whole would make for a poor metric, as other processes in the system (database load, log\n\n346\n\n|\n\nChapter 16: Canarying Releases\n\nrotation, etc.) might be causing that increase. A better metric would be CPU time spent as the process served the request. An even better metric would be CPU time spent serving the request over the window of time the serving process was actually scheduled on a CPU. While a heavily oversubscribed machine colocated with our process is obviously a problem (and monitoring should catch it!), it isn’t caused by the change we’re canarying, so it should not be flagged as a canary deployment failure.\n\nCanaries also need to be attributable; that is, you should also be able to tie the canary metric to SLIs. If a metric can change wildly with no impact to service, it’s unlikely to make a good canary metric.\n\nBefore/After Evaluation Is Risky A before/after canary process is an extension of the attribution problem. In this pro‐ cess, the old system is fully replaced by the new system, and your canary evaluation compares system behavior before and after the change over a set period of time. One might call this process a “canary deployment in time-space,” where you choose the A/B groups by segmenting time instead of segmenting the population by machines, cookies, or other means. Because time is one of the biggest sources of change in observed metrics, it is difficult to assess degradation of performance with before/after evaluation.\n\nWhile the canary deployment might have caused the degradation, the degradation may very well have happened in the control system too. This scenario becomes even more problematic if we attempt to run a canary deployment over a longer period of time. For example, if we perform a release on Monday, we may be comparing behav‐ ior during a business day to behavior during a weekend, introducing a large amount of noise. In this example, users may use the service very differently over the weekend, thereby introducing noise in the canary process.\n\nThe before/after process itself introduces a question of whether a big error spike (as introduced by a before/after evaluation) is better than a small but possibly longer rate of errors (as introduced by a small canary). If the new release is completely broken, how quickly can we detect and revert? A before/after canary may detect the problem faster, but the overall time to recovery may still be quite substantial and similar to a smaller canary. During that time, users suffer.\n\nUse a Gradual Canary for Better Metric Selection Metrics that don’t meet our ideal properties may still bring great value. We can intro‐ duce these metrics by using a more nuanced canary process.\n\nInstead of simply evaluating a single canary stage, we can use a canary containing multiple stages that reflect our ability to reason about the metrics. In the first stage,\n\nSelecting and Evaluating Metrics\n\n|\n\n347\n\nwe have no confidence or knowledge about the behavior of this release. We therefore want to use a small stage in order to minimize negative impact. In a small canary, we prefer metrics that are the clearest indication of a problem—application crashes, request failures, and the like. Once this stage passes successfully, the next stage will have a larger canary population to increase confidence in our analysis of the impact of the changes.\n\nDependencies and Isolation The system being tested will not operate in a complete vacuum. For practical reasons, the canary population and the control may share backends, frontends, networks, data stores, and other infrastructure. There may even be extremely nonobvious interac‐ tions with the client. For example, imagine two consecutive requests sent by a single client. The first request may be handled by the canary deployment. The response by the canary may change the content of the second request, which may land on the control, altering the control’s behavior.\n\nImperfect isolation has several consequences. Most importantly, we need to be aware that if the canarying process provides results that indicate we should stop a produc‐ tion change and investigate the situation, the canary deployment isn’t necessarily at fault. This fact is true of canarying in general, but in practice, it’s frequently enforced by isolation issues.\n\nAdditionally, imperfect isolation means that bad behavior of the canary deployment can also negatively impact the control. Canarying is an A/B comparison, and it’s pos‐ sible that both A and B can change in tandem; this may cause confusion in the canary evaluation. It is important to also use absolute measures, such as defined SLOs, to ensure the system is operating correctly.\n\nCanarying in Noninteractive Systems The chapter has focused on an interactive request/response system, which in many ways is the simplest and most commonly discussed system design. Other systems, such as asynchronous processing pipelines, are equally important, but have different canarying considerations, which we’ll enumerate briefly. For more information on canarying as related to data processing pipelines, see Chapter 13.\n\nFirst and foremost, the duration and deployment of the canary inherently depends on the duration of work unit processing. We’ve ignored this factor when it comes to interactive systems, assuming work unit processing will take no more than a few sec‐ onds, which is shorter than the canary duration. Work unit processing in noninterac‐ tive systems, such as rendering pipelines or video encoding, can take much longer. Accordingly, make sure the canary duration at minimum spans the duration of a sin‐ gle work unit.\n\n348\n\n|\n\nChapter 16: Canarying Releases\n\nIsolation can become more complex for noninteractive systems. Many pipeline sys‐ tems have a single work assigner and a fleet of workers with the application code. In multistage pipelines, a work unit is processed by a worker, then returned to the pool for the same or another worker to perform the next stage of processing. It is helpful for canary analysis to ensure that the workers processing a particular unit of work are always pulled from the same pool of workers—either the canary pool or the control pool. Otherwise, the signals get increasingly mixed (for more about the need to untangle signals, see “Requirements on Monitoring Data” on page 349).\n\nFinally, metric selection can be more complicated. We may be interested in end-to- end time to process the work unit (similar to latency in interactive systems), as well as quality of the processing itself (which is, of course, completely application-specific).\n\nGiven these caveats, the general concept of canarying remains viable, and the same high-level principles apply.\n\nRequirements on Monitoring Data When conducting canary evaluation, you must be able to compare the canary signals to the control signals. Often, this requires some care in structuring the monitoring system—effective comparisons are straightforward and produce meaningful results.\n\nConsider our earlier example of a canary deployment to 5% of the population that runs at a 20% error rate. Because monitoring likely looks at the system as a whole, it will detect an overall error rate of only 1%. Depending on the system, this signal might be indistinguishable from other sources of errors (see Figure 16-3).\n\nIf we break down metrics by population servicing the request (the canary versus the control), we can observe the separate metrics (see Figure 16-4). We can plainly see the error rate in the control versus the canary, a stark illustration of what a full deployment would bring. Here we see that monitoring that reasons well about an entire service isn’t sufficient to analyze our canary. When collecting monitoring data, it is important to be able to perform fine-grained breakdowns that enable you to dif‐ ferentiate metrics between the canary and control populations.\n\nAnother challenge with collecting metrics is that canary deployments are time- limited by design. This can cause problems when metrics are aggregated over specific periods. Consider the metric errors per hour. We can calculate this metric by sum‐ ming the requests over the past hour. If we use this metric to evaluate our canary, we might encounter problems, as described in the following timeline:\n\nRequirements on Monitoring Data\n\n|\n\n349\n\n1. An unrelated event causes some errors to occur.\n\n2. A canary is deployed to 5% of the population; the canary duration is 30 minutes.\n\n3. The canary system starts to watch the errors-per-hour metric to see if the deploy‐ ment is good or bad.\n\n4. The deployment is detected as bad because the errors-per-hour metric is signifi‐ cantly different from the errors per hour of the control population.\n\nThis scenario is a result of using a metric that is computed hourly to evaluate a deployment that is only 30 minutes long. As a result, the canary process provides a very muddied signal. When using metrics to evaluate canary success, make sure the intervals of your metrics are either the same as or less than your canary duration.\n\nRelated Concepts Often, our conversations with customers touch upon using blue/green deployment, artificial load generation, and/or traffic teeing in production. These concepts are sim‐ ilar to canarying, so while they’re not strictly canary processes, they might be used as such.\n\nBlue/Green Deployment Blue/green deployment maintains two instances of a system: one that is serving traf‐ fic (green), and another that is ready to serve traffic (blue). After deploying a new release in the blue environment, you can then move traffic to it. The cutover doesn’t require downtime, and rollback is a trivial reversal of the router change. One down‐ side is that this setup uses twice as many resources as a more “traditional” deploy‐ ment. In this setup, you are effectively performing a before/after canary (discussed earlier).\n\nYou can use blue/green deployments more or less as normal canaries by utilizing both blue and green deployments simultaneously (rather than independently). In this strategy, you can deploy the canary to the blue (standby) instance and slowly split traffic between green and blue environments. Both your evaluations and the metrics that compare the blue environment to the green environment should be tied to traffic control. This setup resembles an A/B canary, where the green environment is the control, the blue environment is the canary deployment, and the canary population is controlled by the amount of traffic sent to each.\n\nArtificial Load Generation Instead of exposing live user traffic to a canary deployment, it may be tempting to err on the side of safety and use artificial load generation. Often, you can run load tests in multiple deployment stages (QA, preproduction, and even in production). While\n\n350\n\n|\n\nChapter 16: Canarying Releases\n\nthese activities don’t qualify as canarying according to our definition, they are still viable approaches to finding defects with some caveats.\n\nTesting with synthetic load does a good job of maximizing code coverage, but doesn’t provide good state coverage. It can be especially hard to artificially simulate load in mutable systems (systems with caches, cookies, request affinity, etc.). Artificial load also might not accurately model organic traffic shifts that happen in a real system. Some regressions may manifest only during events not included in the artificial load, leading to gaps in coverage.\n\nArtificial load also works poorly in mutable systems. For example, it may be down‐ right dangerous to attempt to generate artificial load on a billing system: the system might start sending callouts to credit card providers, which would then start actively charging customers. While we can avoid testing dangerous code paths, the lack of testing on these paths reduces our test coverage.\n\nTraffic Teeing If artificial load is not representative, we could copy the traffic and send it to both the production system and the system in the test environment. This technique is referred to as teeing. While the production system serves the actual traffic and delivers responses to users, the canary deployment serves the copy and discards the responses. You might even compare the canary responses to the actual responses and run fur‐ ther analysis.\n\nThis strategy can provide representative traffic, but is often more complicated to set up than a more straightforward canary process. Traffic teeing also doesn’t adequately identify risk in stateful systems; copies of traffic may introduce unexpected influences between the seemingly independent deployments. For example, if the canary deploy‐ ment and production systems share a cache, an artificially inflated cache hit rate would invalidate performance measurements for the canary metrics.\n\nConclusion You can use a number of tools and approaches to automate your releases and intro‐ duce canarying into your pipeline. No single testing methodology is a panacea, and testing strategies should be informed by the requirements and behavior of the system. Canarying can be a simple, robust, and easily integratable way to supplement testing. When you catch system defects early, users are minimally impacted. Canarying can also provide confidence in frequent releases and improve development velocity. Just as testing methodology must evolve alongside system requirements and design, so must canarying.\n\nConclusion\n\n|\n\n351",
      "page_number": 362
    },
    {
      "number": 42,
      "title": "Segment 42 (pages 372-384)",
      "start_page": 372,
      "end_page": 384,
      "detection_method": "topic_boundary",
      "content": "PART III Processes\n\nSRE is more than just a collection of technical practices—it’s a culture that requires consistent and logical processes. This section addresses some important elements of processes as applied in SRE: managing operations and development work, recovering from overload, structuring and managing your relationships with development part‐ ners and customers, and implementing practical change management.\n\nIf you are an SRE leader, this section is your how-to guide for creating the space and environment your teams need to successfully implement the practices covered in Part II.\n\nCHAPTER 17 Identifying and Recovering from Overload\n\nBy Maria-Hendrike Peetz, Luis Quesada Torres, and Marilia Melo with Diane Bates\n\nWhen an SRE team is running smoothly, team members should feel like they can comfortably handle all of their work. They should be able to work on tickets and still have time to work on long-term projects that make it easier to manage the service in the future.\n\nBut sometimes circumstances get in the way of a team’s work goals. Team members take time off for long-term illnesses or move to new teams. Organizations hand down new production-wide programs for SRE. Changes to the service or the larger system introduce new technical challenges. As workload increases, team members start working longer hours to handle tickets and pages and spend less time on engineering work. The whole team starts to feel stressed and frustrated as they work harder but don’t feel like they are making progress. Stress, in turn, causes people to make more mistakes, impacting reliability and, ultimately, end users. In short, the team loses its ability to regulate its daily work and effectively manage the service.\n\nAt this point, the team needs to find a way out of this overloaded state. They need to rebalance their workload so that team members can focus on essential engineering work.\n\nOperational load (or operational workload) is a term that describes the ongoing main‐ tenance tasks that keep systems and services running at optimal performance. There are three distinct types of operational load: pages, tickets, and ongoing operational responsibilities. Pages typically require immediate attention, and tickets related to urgent problems can have tight deadlines. Both pages and urgent tickets interrupt SREs from working on engineering projects that support the team’s operational responsibilities. For that reason, we refer to them as interrupts. Chapter 29 of Site\n\n355\n\nReliability Engineering discusses techniques to manage the interrupts that naturally arise when a team is maintaining a complex system in a functional state.\n\nWhen operational load outstrips a team’s ability to manage it, the team ends up in a state of operational overload (also called work overload). A team is in a state of opera‐ tional overload when it can’t make progress toward key priorities because urgent issues continually preempt project work. In addition to detracting from the team’s priorities and service improvements, overload can increase the chance that engineers make errors.1\n\nThe threshold of operational overload can vary from team to team. Google SRE teams cap operational work at 50% of an engineer’s time. A successful SRE team must have confidence that over the long term, they will be able to complete the engineering projects required to reduce the operational load for the services they manage.\n\nThis chapter describes how teams at Google progressed from a difficult situation characterized by operational overload to a well-managed workload. Two case studies show the detrimental effect of operational overload on team health, and how the teams made changes to their daily tasks so they could focus on long-term impactful projects. In Case Study 1, overload results when remaining members on a shrinking team are unable to keep up with the workload. In Case Study 2, a team suffers from perceived overload—a state that has the same effects as operational overload, but starts as a misperception of the real workload.\n\nWhile these case studies highlight specific actions that worked for two Google SRE teams, the section “Strategies for Mitigating Overload” on page 366 provides practices for identifying and mitigating overload that apply to any company or organization. Therefore, this chapter should be useful to managers of overloaded teams, or any SRE team concerned about overload.\n\nFrom Load to Overload Regardless of its origin, overload is an occupational stress that can cripple productiv‐ ity. Left unchecked, it can cause serious illness. For SRE teams, operational load is typically a combination of cognitively difficult tasks (like debugging memory leaks or segmentation faults) and many small tasks that require frequent context switches (working through quota requests, starting binary rollouts, etc.).\n\nWork overload often happens when a team doesn’t have enough time to handle all these tasks—an objective reality when the number of tasks assigned to a team can’t be\n\n1 Kara A. Latorella, Investigating Interruptions: Implications for Flightdeck Performance (Hampton, VA: Langley\n\nResearch Center, 1999), https://go.nasa.gov/2Jc50Nh; NTSB, Aircraft Accident Report: NWA DC-9-82 N312RC, Detroit Metro, 16 August 1987 (No. NTSB/AAR-88/05) (Washington, DC: National Transportation Safety Board, 1988), http://libraryonline.erau.edu/online-full-text/ntsb/aircraft-accident-reports/AAR88-05.pdf.\n\n356\n\n|\n\nChapter 17: Identifying and Recovering from Overload\n\ncompleted within the given deadline for each task. Perceived overload is more subjec‐ tive, and happens when individuals on the team feel that they have too much work. This usually happens when several organizational or work changes take place over a short period of time, but the team has little opportunity to communicate with leader‐ ship about the changes.\n\nIt’s never clear what problems will develop when you’re on-call, or what your work‐ load will be. On the one hand, a single, seemingly innocent ticket about running out of disk space might lead to an in-depth investigation of a recurring garbage collection job. On the other hand, a pager storm with 20+ pages might turn out to be a case of bad monitoring. When it’s hard to estimate or predict your workload, you can easily fall victim to cognitive biases and misjudge your workload—for example, you might gauge a ticket queue as too large to finish during your on-call shift. Even if you can finish all the tickets quickly and the actual workload is low, you feel overloaded when you first look at the ticket queue. This perceived overload2 itself has a psychological component that affects your approach and attitude toward your work. If you don’t start your day with the preconception that there’s too much work, you’re more likely to dive in and start working your way through the ticket queue. Perhaps you work all day and don’t finish your workload (thus facing work overload), but you make a lot more progress than if you had started your day feeling overwhelmed.\n\nAccumulating many interrupts can lead to work overload, but it doesn’t have to. But when frequent interruptions are paired with external stress factors, a large workload (or even a small workload) can easily turn into perceived overload. This stress might stem from the fear of disappointing other team members, job insecurity, work- related or personal conflicts, illness, or health-related issues like the lack of sleep or exercise.\n\nIf your work isn’t properly prioritized, every task can seem equally urgent, leading to both actual and perceived overload. In the case of actual overload, the urgency of tickets and alerts might cause team members to work until they resolve the problem, even if doing so means continuous long hours. When a team faces perceived over‐ load, reprioritizing can help decrease the amount of urgent work, creating space for them to tackle the sources of overload through project work.\n\nWhen analyzing your specific situation, you shouldn’t necessarily assume that the workload itself needs to change. Instead, we recommend first quantifying the work\n\n2 Emmanuelle Brun and Malgorzata Milczarek, Expert Forecast on Emerging Psychosocial Risks Related to Occu‐ pational Safety and Health (Bilbao, Spain: European Agency for Safety and Health at Work, 2007), https:// osha.europa.eu/en/tools-and-publications/publications/reports/7807118; M. Melchior, I. Niedhammer, L. F. Berkman, and M. Goldberg, “Do Psychosocial Work Factors and Social Relations Exert Independent Effects on Sickness Absence? A Six-Year Prospective Study of the GAZEL Cohort,” Journal of Epidemiology and Community Health 57, no. 4 (2003): 285–93, http://jech.bmj.com/content/jech/57/4/285.full.pdf.\n\nFrom Load to Overload\n\n|\n\n357\n\nyour team faces, and how it has (or hasn’t) changed over time. For example, you might measure workload by the number of tickets and pages the team handles. If your workload hasn’t actually changed over time, the team might feel overloaded simply because they perceive the work as overwhelming. To get a more holistic view of the team’s current workload, you can collect a one-time snapshot by asking every member to list all the work tasks they face. Then take a look at psychological stress factors your team faces, such as organizational changes or reprioritization. Once you’ve done your research, you have a stable basis for making decisions about chang‐ ing the workload.\n\n“Strategies for Mitigating Overload” on page 366 talks more about how to identify overload, both real and perceived. First, we present two case studies of teams that rec‐ ognized that they were in overload and took steps to alleviate it.\n\nCase Study 1: Work Overload When Half a Team Leaves\n\nBackground One of Google’s internal storage SRE teams was in charge of backends for multiple services, including Gmail, Google Drive, and Google Groups, and many other inter‐ nal or user-facing services. We experienced a crisis in mid-2016 when two-thirds of the team—including the most senior engineer (the manager)—transferred to other opportunities within a relatively short window, for genuinely entirely unrelated rea‐ sons. This event obviously led to a huge workload management problem: fewer SREs available to cover the same operational and project work quickly resulted in overload. Our work was also bottlenecked because each team member’s expertise was siloed to a different area of production. While the addition of new team members and three interns would improve our workload in the long term, ramping up those engineers would take a serious investment of time and energy.\n\nProblem Statement The preceding factors significantly decreased team productivity. We started to fall behind on project work, and tickets related to the many services we managed began to pile up. We didn’t have the bandwidth to address this backlog, as all of our work was consumed by higher-priority tasks. It wouldn’t be long before we weren’t able to undertake all of the critical and urgent work we needed to. Meanwhile, our team was slated to receive more high-priority work soon.\n\nIf we didn’t move some work off our plate, it was only a matter of time before we accidentally began to drop important work. However, as soon as we started offload‐ ing work, we hit some psychological barriers:\n\n358\n\n|\n\nChapter 17: Identifying and Recovering from Overload\n\nDropping any work that was in progress felt like we had just wasted our efforts. Most of the backlog seemed to be either critical or worth the effort to us, so it just didn’t feel right to cancel or delay projects indefinitely. We didn’t realize we were in the grip of a sunk cost fallacy.\n\nPutting effort into automating processes or fixing the root cause of the workload was not as critical as immediately dealing with high-priority interrupts. When this work was added to the top of an already huge pile, all of the work felt overwhelming.\n\nWhat We Decided to Do We gathered the team in a room and listed all the team’s responsibilities, including project backlog, operational work, and tickets. Then we triaged every list item. View‐ ing every single one of our work tasks (even though the list barely fit on the white‐ board) helped us identify and redefine our actual priorities. We were then able to find ways to minimize, hand off, or eliminate lower-priority work items.\n\nImplementation We identified low-effort automation that, while not critical, would significantly reduce operational load once deployed.\n\nWe also identified common problems that we could document that would enable self-service. Writing the procedures our customers needed didn’t take long, and removed some repetitive work from our queue.\n\nWe closed as many of our backlogged tickets as we reasonably could. Most of these tickets turned out to be obsolete, redundant, or not as urgent as they claimed. Some tickets were monitoring artifacts that were nonactionable, so we fixed the relevant monitoring. In some cases, we were actively addressing issues that weren’t critical. We set these issues aside to work on more urgent tickets, but first documented our progress so we wouldn’t lose context before we were able to work on them again.\n\nWhen in doubt, we dropped a task, but marked it for a second phase of triage. Once our plates were (almost) empty, we revisited this tentative list to decide what tasks to resume. It turned out that almost none of these tasks were impactful or important enough to resume.\n\nIn two days—one day of intensive triage plus one day of documenting processes and implementing automation—our much smaller team addressed a backlog of several months of interrupts. We could then deal with the few remaining interrupts, which were related to active issues in production.\n\nCase Study 1: Work Overload When Half a Team Leaves\n\n|\n\n359\n\nLessons Learned Our team learned that identifying and scoping overload is the first step toward fixing it. We needed to get everyone in a room and reevaluate the backlog before we could help our team get back to a healthy state.\n\nIn order to avoid a new pile-up of interrupts, we started triaging interrupts once every two weeks. Our technical lead periodically checks the task queue and evaluates whether the team is at risk of becoming overloaded. We decided that each team member should have 10 or fewer open tickets to avoid overload. If the team lead noti‐ ces that team members have more than 10 tickets, they can do one or some combina‐ tion of the following:\n\nRemind the team to close out stale tickets.\n\nSync with overloaded team members and offload tickets from them.\n\nPrompt individual team members to address their ticket queue.\n\nOrganize a team-wide one-day ticket fix-it.\n\nAssign work to fix the sources of tickets, or operational work to reduce future tickets.\n\nCase Study 2: Perceived Overload After Organizational and Workload Changes\n\nBackground The Google SRE team in this case study was split between two locations, with six or seven on-call engineers at each site (for more discussion on team size, see Chapter 11 of Site Reliability Engineering. While the Sydney team was operationally healthy, the Zürich team was overloaded.\n\nBefore the Zürich team went into overload, we were stable and content. The number of services we managed was relatively stable, and each was varied and high mainte‐ nance. While the SLOs of the services we supported were mismatched with the SLOs of their external dependencies, this mismatch hadn’t caused any issues. We were working on a number of projects to improve the services we managed (for example, improving load balancing).\n\nSimultaneous triggers sent the Zürich team into overload: we started onboarding new services that were noisier and less integrated into Google’s general infrastructure, and the technical lead manager and another team member left our team, leaving it two people short. The combination of the additional workload and knowledge drain trig‐ gered more problems:\n\n360\n\n|\n\nChapter 17: Identifying and Recovering from Overload\n\nUntuned monitoring for the new services and the migration-related monitoring resulted in more pages per shift. This buildup was gradual, so we didn’t notice the uptick as it occurred.\n\nSREs felt relatively helpless with the new services. We didn’t know enough about them to react appropriately, and often needed to ask the development team ques‐ tions. While the overload perhaps warranted handing a service back to develop‐ ers, our team had never handed back a service, so we didn’t really consider this a viable option.\n\nA smaller on-call rotation of five people cut into the hours we normally spent on operational work.\n\nNew ticket alerts were surfacing problems that existed before the recent team changes. While we had simply ignored these problems in the past, we were now required to move ignored email alerts to tickets. Project planning hadn’t taken this new source of technical debt into account.\n\nA new ticket SLO required us to handle tickets within three days, meaning that on-callers had to resolve tickets created during their on-call shift much sooner.3 The SLO aimed to reduce the number of tickets being added to our (mostly ignored) backlog, but created a side effect that was perhaps even worse. Now SREs felt that they couldn’t get the rest they needed after a shift because they had to immediately tackle follow-up work. The higher priority placed on these tickets also meant that SREs didn’t have enough time for other operational work.\n\nDuring this time, our team was assigned to a new manager who also managed two other teams. The new manager was not part of the on-call rotation and therefore didn’t directly feel the stress team members were experiencing. When the team explained the situation to the manager, nothing changed. Team members felt that they weren’t being heard, which left them feeling distant from the management team.\n\nThe overload from tickets continued for months, making team members grumpy, until a cascade of unhappiness spread across the team.\n\nProblem Statement After losing two people and receiving additional and varied work, our team felt over‐ loaded. When we tried to communicate this feeling to our direct manager, the man‐ ager disagreed. As the long hours continued, exhaustion set in. Productivity was declining and tasks started accruing faster than the team could resolve them. The per‐ ceived overload now became objective overload, making the situation worse.\n\n3 For context, according to estimates, an SRE needed at least one additional day of ticket follow-up per shift.\n\nCase Study 2: Perceived Overload After Organizational and Workload Changes\n\n|\n\n361\n\nThe emotional stress caused by overload was lowering morale and causing some team members to burn out. As individuals dealt with the physical effects from overwork (illness and lower productivity), other people on the team had to pick up more work. The work assigned in weekly team meetings wasn’t getting done.\n\nWe then started assuming we couldn’t depend on other people to get their work done, which eroded feelings of trust and dependability within the team. As a result, we did not feel safe about interpersonal risk taking, an important factor in psychologi‐ cal safety (see Chapter 11 in Site Reliability Engineering). Team members didn’t feel accepted and respected by other team members, so they didn’t freely collaborate with each other. As psychological safety diminished on the team, collaboration stopped, slowing down information sharing and causing further inefficiencies.\n\nTeam surveys also revealed a loss of psychological safety—team members said they didn’t feel like they belonged on the team. They no longer cared about their own career development, and the promotion rate on the team dropped to an all-time low.\n\nWe finally hit a breaking point when upper management assigned us new mandatory company-wide projects. At this point, we renewed our conversations with manage‐ ment about overload with renewed vigor. A series of discussions revealed that our unhappy situation wasn’t just a result of too much work—our perceptions of team safety led us to stop trusting and collaborating with each other.\n\nWhat We Decided to Do Upper management assigned our team a new manager who wasn’t shared among three teams. The new manager used a participatory management style to improve psychological safety on the team so that we could once again collaborate. This method empowers team members to actively participate in solving team problems. The entire team, including our direct manager, engaged in a set of simple team- building exercises to improve the effectiveness of our team (some of which were as simple as drinking tea together).4 As a result, we were able to draft a set of goals:\n\nShort term\n\nRelieve stress and improve psychological safety to establish a healthy work atmosphere.\n\nMedium term\n\nBuild confidence of individual team members through training.\n\nFind the root cause of the issues that are causing overload.\n\n4 We used the Google program based on Project Aristotle: http://bit.ly/2LPemR2.\n\n362\n\n|\n\nChapter 17: Identifying and Recovering from Overload\n\nLong term\n\nResolve ongoing problems that contributed to the cascade.\n\nIn order to set these goals, we had to first achieve some kind of baseline psychological safety within the team. As morale improved, we began to share knowledge and build on each other’s ideas to figure out ways to get our workload under control.\n\nImplementation\n\nShort-term actions\n\nLong-term stress, whether caused by overwork or perceptions of team safety, decrea‐ ses productivity and impacts people’s health. Therefore, our most important short- term action was to provide stress relief and improve trust and psychological safety. Once relieved of some stress, team members could think more clearly and participate in driving the whole team forward. Within a month of identifying the overload, we implemented the following:\n\nStarted a semiregular round table to discuss issues. The team released frustra‐ tion and brainstormed possible causes of the overload.\n\nFound a better metric for measuring load. We decided to improve upon our original metric of number of pages. We auto-assigned tickets to on-callers, and the on-caller was responsible for these tickets even after their shift ended. Our new metric measured how much time an on-caller needed to resolve a ticket after their shift.\n\nAudited and removed spamming alerts. We reviewed alerts and removed the ones that didn’t represent user-facing problems.\n\nSilenced alerts generously. The team deliberately didn’t try to find the source for every single alert, but focused on relieving the stress from being paged and ticketed continuously for issues we already knew about. We used the following strategy: — Alerts that surfaced were silenced until they were fixed.\n\n— Alerts could be silenced only for a limited period of time (typically a day,\n\nsometimes up to a week). Otherwise, they might mask outages.\n\n— Alerts that couldn’t be fixed within a few minutes were assigned to a tracking\n\nticket.\n\nAdded a direct manager dedicated to a single team. Making a well-respected team member the new manager reestablished trust in management. Rather than managing three teams, the new manager could focus more time on the individual team and its members.\n\nCase Study 2: Perceived Overload After Organizational and Workload Changes\n\n|\n\n363\n\nRebalanced the team. We introduced a new perspective and on-call relief by adding technically experienced SREs that didn’t have preconceptions about the team or organization. Finding appropriate people was by no means an easy task, but was well worth the effort.\n\nInstituted team events like lunches and board game sessions. Talking about non-work-related topics and laughing together eased tension on the team and improved psychological safety.\n\nMid-term actions\n\nShort-term solutions alone wouldn’t sustain a healthy atmosphere—for example, one of our short-term tactics was to silence alerts without actually fixing the cause. Within three months, we also took the following actions:\n\nLimited operational work to on-call time as much as possible (see Chapter 29 in Site Reliability Engineering) so the team could concentrate on permanent fixes and project work.\n\nReturned responsibility for one service back to its development team.\n\nTrained each other (and new team members). While training requires an investment of time and energy, disseminating knowledge meant that all team members (and future hires) could troubleshoot and fix issues more quickly in the future. Training coworkers improved our confidence, because we came to realize that we actually knew quite a bit about the services. As they gained knowledge, team members started to find new ways to manage services, improving their reli‐ ability and reducing overload.\n\nBrought in SREs from the remote team to staff some of our on-call shifts and participate in training. They noticed the strain on the team and provided some valuable new perspective.\n\nBackfilled the two open roles on the team.\n\nTackled each alert as the silences expired. We discussed repetitive pages and pages that resulted in no action at length in the weekly production meeting, which led us to tune alerts and/or fix the underlying problems. While these were important (and obvious) actions, we only had the space to analyze and take action once the alert was silenced and not creating constant noise.\n\nOrganized listening events. Management (including the skip-level manager and team leads) made a conscious effort to listen to the team’s pain points and to find a team-driven solution.\n\n364\n\n|\n\nChapter 17: Identifying and Recovering from Overload\n\nAdded perspective. Hope is not a strategy, but it certainly helps team morale. With the promise of new members joining the on-call rotation, a shift to clearer priorities, and an end to noise-generating projects, the team’s mood improved.\n\nLong-term actions\n\nTo help maintain our newfound stability, we are currently aligning our SLOs with the SLOs of their service backends, and working toward making the services more uni‐ form. Uniformity has a double benefit: it decreases cognitive load for SREs and makes it easier to write automation that can be used across services. We’re also reviewing services that have been around for a long time and updating them to cur‐ rent production standards. For example, some services are operating poorly under load that’s increased significantly over the years. Some services need to be updated per changes to their backend services’ policies. Other services simply haven’t been updated for several years.\n\nEffects A few months after our first brainstorming meeting, results began to surface: on-call shifts became quieter, and our team managed to quickly and efficiently deal with a difficult incident collaboratively as a group. A bit later, new team members arrived. When we discussed psychological safety during a round-table session, the new mem‐ bers said they couldn’t imagine that the team ever had such problems. In fact, they saw our team as a warm and safe place to work. About one year after the original escalation, little of the original overload remained and an anonymous survey showed that team members now felt the team was effective and safe.\n\nLessons Learned Workplace changes can have a psychological impact on the people on the team— after all, your teammates are not machines. You need to attend to the team’s stress levels so that people start trusting each other enough to work together; otherwise, the team can enter a vicious cycle of overload that causes stress, which in turn prevents you from tackling overload.\n\nPerceived overload is, in fact, overload, and has as much impact to a team as work overload caused by other factors. In our case, our sister team in Sydney didn’t experi‐ ence the same issues, and the number of pages we fielded didn’t actually change very much compared to previous years. Instead, the loss of two team members, increased cognitive load, increased ticket noise, and a new three-day SLO on tickets led the team to perceive overload. In the end, the difference between objective and perceived overload didn’t matter: the perceived overload of a few team members can very quickly lead to overload for the whole team.\n\nCase Study 2: Perceived Overload After Organizational and Workload Changes\n\n|\n\n365\n\nStrategies for Mitigating Overload An outside perspective can sometimes quite easily identify when a team is overloa‐ ded. Similarly, it’s easy to comment on what actions should have been taken in retro‐ spect. But how do you identify overload when you’re in the middle of experiencing it? The path toward a healthy, friendly, and happy work atmosphere can be hard to visu‐ alize when you’re mired in overload. This section describes practices for both identi‐ fying and mitigating overload on your team.\n\nRecognizing the Symptoms of Overload It’s pretty easy to identify an overloaded team if you know the symptoms of overload:\n\nDecreased team morale\n\nOverload might manifest as rants and complaints. Surveys on relevant topics (job conditions, work satisfaction, projects, peers, and managers) usually reflect team morale and yield more negative results when a team is overloaded. Regular active listening sessions with team leaders can surface issues that you weren’t aware of. An essential element of active listening is to listen without judgment.\n\nTeam members working long hours, and/or working when sick\n\nWorking overtime without compensation can be a psychosocial stressor. Leaders should set a good example: work contractual hours and stay home when sick.\n\nMore frequent illness5\n\nOverworked team members tend to get run down and sick more often.\n\nAn unhealthy tasks queue\n\nWe recommend regularly reviewing your team’s tasks queue to see how many tickets are backlogged, who is dealing with which issues, and what tasks can be delayed or dropped. If the team is missing deadlines, or if urgent matters prevent you from performing this review regularly, the team is very likely accumulating interrupts faster than it can attend to them.\n\nImbalanced metrics\n\nA few key metrics might indicate that your team is overloaded:\n\nLong time periods to close a single issue\n\nHigh proportion of time spent on toil\n\nLarge number of days to close issues originating from an on-call session\n\n5 Kurt G. I. Wahlstedt and Christer Edling, “Organizational Changes at a Postal Sorting Terminal—Their Effects Upon Work Satisfaction, Psychosomatic Complaints and Sick Leave,” Work and Stress 11, no. 3 (1997): 279–91.\n\n366\n\n|\n\nChapter 17: Identifying and Recovering from Overload",
      "page_number": 372
    },
    {
      "number": 43,
      "title": "Segment 43 (pages 385-402)",
      "start_page": 385,
      "end_page": 402,
      "detection_method": "topic_boundary",
      "content": "The team should work together to decide what measures to use. There is no one-size- fits-all approach; every team’s overload is reflected in different ways. As a manager, don’t impose a measure on the team without getting an idea of each individual’s workload and work habits. Team members might feel that you don’t understand the work if you insist on using a specific measure. For example, if you’re evaluating load by the number of days it takes to fix an issue, one person might work a full day fixing an issue, while another person might distribute the work across several days, along with other work.\n\nReducing Overload and Restoring Team Health After reading through the criteria, you might think your team is already overloaded. Don’t despair! This section provides a list of ideas to get your team back to a healthy state.\n\nIn general, giving team members more control and power reduces perceived over‐ load.6 While managers might be tempted to resort to micro-management in stressful situations, it’s important to keep the team in the loop and work on prioritization together in order to increase the level of performance and job satisfaction.7 This model assumes a baseline of a functional team, where you have (at minimum) a somewhat healthy relationship between management and team members, and between team members.\n\nIdentify and alleviate psychosocial stressors\n\nWhen it comes to fixing a dysfunctional team, first and foremost, individual team members need to regain their sense of psychological safety. A team can function only as well as its individual members.\n\nYou can start by identifying and alleviating psychosocial stressors8 for each individual and the team as a whole. Which of these factors do you actually have control over? You can’t control whether or not a team member has a major illness, but you can control the size of your team’s backlog (as seen in Case Study 1) or silence pages (as in Case Study 2).\n\n6 Robert A. Karasek Jr., “Job Demands, Job Decision Latitude, and Mental Strain—Implications for Job Rede‐\n\nsign,” Administrative Science Quarterly 24, no. 2 (1979): 285–308.\n\n7 Frank W. Bond and David Bunce, “Job Control Mediates Change in a Work Reorganization Intervention for Stress Reduction,” Journal of Occupational Health Psychology 6, no. 4 (2001): 290–302; Toby D. Wall, Paul R. Jackson, and Keith Davids, “Operator Work Design and Robotics System Performance: A Serendipitous Field Study,” Journal of Applied Psychology 77, no. 3 (1992): 353–62.\n\n8 Brun and Malgorzata, Expert Forecast.\n\nStrategies for Mitigating Overload\n\n|\n\n367\n\nCommunicate with your partner product developer teams, and let them know your team is overloaded. They might be able to give a helping hand, provide compassion, or even take over entire projects.\n\nWhen your team members rely on each other and achieve a certain level of psycho‐ logical safety (such that they’re able to take interpersonal risks), you can give more responsibility to individual team members. Uncovering areas of expertise and assign‐ ing point people and technical leads to specific technologies increases their self- confidence and therefore enables them to take risks.\n\nDecision making should be transparent and, if possible, democratic. Each team mem‐ ber should have a feeling of control over the situation. For example, the brainstorm‐ ing session in Case Study 2 helped the team identify and discuss issues.\n\nPrioritize and triage within one quarter\n\nA healthy team can prioritize and triage issues. Case Study 1 provides a good example of this exercise: the team sat together in a room and reviewed their backlog. The review helped them realize they were overloaded. They reprioritized their work, and worked on the tasks that would quickly reduce some of the overload. The team in Case Study 2 now meets at the end of each quarter to plan and prioritize existing and future work together.\n\nIf possible, we recommend that SREs schedule interrupt-free time (no on-call) on their calendars, so that they have time to work on qualitatively difficult tasks like developing automation and investigating the root causes of interrupts. In Case Study 2, when the remote team gave the on-call some relief, team members then had pre‐ cious time to focus on their projects.\n\nIf absolutely necessary, drop work: in Case Study 2, the team dropped on-call support for one of their services by returning this responsibility to the development team.\n\nProtect yourself in the future\n\nWe strongly recommend establishing metrics to evaluate the team’s workload. Regu‐ larly review the metrics to make sure they are measuring the right things.\n\nOnce your team emerges from overload, you can prevent future overload by taking steps to monitor or resolve the underlying problems. For example, the team in Case Study 1 now maintains a lightweight triage process to detect a growing backlog of tasks. The team in Case Study 2 is currently working on a long-term plan to align backend and service SLOs.\n\nWhen your team is in overload, prioritize project work that pays down repetitive toil even more than you would if you weren’t overloaded. You will profit in the future.\n\n368\n\n|\n\nChapter 17: Identifying and Recovering from Overload\n\nFinally, everyone on the team should feel responsible for the early warning signs (see “Recognizing the Symptoms of Overload” on page 366) that indicate a possible over‐ load situation. Managers should sit down and talk with team members if they feel that the team is moving toward overload.\n\nConclusion In a perfect world, SRE teams would always be able to manage interrupts with the tactics described in our first book. But we’re only human, and sometimes our teams don’t reach that ideal. This chapter examined some of the ways that overload can consume a team and discussed how to detect and respond when it does.\n\nParticularly when it comes to operational work, excessive interrupts can very easily cause a team to slip from a normal workload to overload. Frequent interrupts can lead to overload, and overload negatively affects health and productivity. Overload creates psychosocial stressors for team members, which impacts work even further, causing a self-enforcing cycle.\n\nPerceived overload is a special form of overload that can’t be measured by the amount of toil or operational work. It is hard to pinpoint and to eliminate.\n\nIn order to keep a team’s workload in balance, it’s important to constantly monitor (perceived or nonperceived) overload. To better serve your users and do good work, you need to first show respect to yourself and your team. Maintaining a healthy bal‐ ance in your daily work goes a long way in helping you and your team accomplish that goal.\n\nConclusion\n\n|\n\n369\n\nCHAPTER 18 SRE Engagement Model\n\nBy Michael Wildpaner, Gráinne Sheerin, Daniel Rogers, and Surya Prashanth Sanagavarapu (New York Times) with Adrian Hilton and Shylaja Nukala\n\nChapter 32 in our first SRE book describes technical and procedural approaches that an SRE team can take to analyze and improve the reliability of a service. These strate‐ gies include Production Readiness Reviews (PRRs), early engagement, and continu‐ ous improvement.\n\nSimply put, SRE principles aim to maximize the engineering velocity of developer teams while keeping products reliable. This two-fold goal is good for the product users and good for the company. But there’s a limit to how much even the best SRE team can accomplish, and the SRE model is less effective when the domain is too large and overly complex. The current microservices movement makes this dynamic even more acute—a small company can easily have more microservices than a single SRE team can handle. Given a large production landscape, and with the knowledge that they can’t cover every service, an SRE team must decide where to focus their attention to achieve the best results. Product development and SRE teams can collab‐ orate to identify the correct point of focus.\n\nThis chapter adopts the perspective of an SRE team that’s intending to provide sup‐ port for a new service. We look at how to engage most effectively with the service, and with the developer and product teams who own it. Although SRE engagement often builds around one or more services, the engagement entails much more than the services themselves—it focuses on understanding the aims of developer and prod‐ uct teams and finding the right way to support them.\n\nMost of this discussion is applicable regardless of your organization’s scale. While we use the word team frequently, a team could theoretically start off as a single person (although that person would be quite busy). Regardless of your team’s size, it’s\n\n371\n\nimportant to proactively define the role of SRE and manage communication and col‐ laboration with product development.\n\nThe Service Lifecycle As described in the preface to the first SRE book, an SRE team’s contributions to ser‐ vice reliability happen throughout all phases of the service lifecycle. Their application of production knowledge and experience can substantially improve the reliability of a service well before any SRE picks up the pager for the service.\n\nFigure 18-1 shows the ideal levels of SRE engagement over the course of a service’s life. However, an SRE team might begin their engagement with a service at any stage in the lifecycle. For example, if the development team begins planning a replacement service for an SRE-supported service, SRE might be involved in the new service very early on. Alternatively, an SRE team might formally engage with a service once it has been generally available for months or years and is now facing reliability or scaling challenges. This section provides guidance on how SRE teams can effectively contrib‐ ute at each phase.\n\nFigure 18-1. Level of SRE engagement during the service lifecycle\n\nPhase 1: Architecture and Design SRE can influence the architecture and design of a software system in different ways:\n\nCreating best practices, such as resilience to various single points of failure, that a developer team can employ when building a new product\n\n372\n\n|\n\nChapter 18: SRE Engagement Model\n\nDocumenting the dos and don’ts of particular infrastructure systems (based upon prior experience) so developers can choose their building blocks wisely, use them correctly, and avoid known pitfalls\n\nProviding early engagement consulting to discuss specific architectures and design choices in detail, and to help validate assumptions with the help of targe‐ ted prototypes\n\nJoining the developer team and participating in development work\n\nCodesigning part of the service\n\nFixing architectural mistakes becomes more difficult later in the development cycle. Early SRE engagement can help avoid costly redesigns that become necessary when systems interact with real-world users and need to scale in response to service growth.\n\nPhase 2: Active Development As the product takes shape during active development, SREs can start productioniz‐ ing the service—getting it in shape to be released into production. Productionaliza‐ tion typically includes capacity planning, setting up extra resources for redundancy, planning for spike and overload handling, implementing load balancing, and putting in place sustainable operational practices like monitoring, alerting, and performance tuning.\n\nPhase 3: Limited Availability As a service progresses toward Beta, the number of users, variety of use cases, inten‐ sity of usage, and availability and performance demands increase. At this stage, SRE can help measure and evaluate reliability. We strongly recommend defining SLOs before general availability (GA) so that the service teams have an objective measure of how reliable the service is. The product team still has the option to withdraw a product that can’t meet its target reliability.\n\nDuring this phase, the SRE team can also help scale the system by building a capacity model, acquiring resources for upcoming launch phases, and automating turnups and in-place service resizing. SRE can ensure proper monitoring coverage and help create alerts that ideally match the upcoming service SLOs.\n\nWhile service usage is still changing, the SRE team can expect an increased amount of work during incident response and operational duties because the teams are still learning how the service works and how to manage its failure modes. We recom‐ mend sharing this work between the developer and SRE teams. That way, the devel‐ oper team gains operational experience with the service and the SREs gain experience\n\nThe Service Lifecycle\n\n|\n\n373\n\nwith the service in general. Operational work and incident management will inform the system changes and updates the service owners need to make before GA.\n\nPhase 4: General Availability In this phase, the service has passed the Production Readiness Review (see Chapter 32 in Site Reliability Engineering for more details) and is accepting all users. While SRE typically performs the majority of operational work, the developer team should continue to field a small part of all operational and incident response work so they don’t lose perspective on these aspects of the service. They might permanently include one developer in the on-call rotation to help the developers keep track of operational load.\n\nIn the early phase of GA, as the developer team focuses on maturing the service and launching the first batches of new features, it also needs to stay in the loop to under‐ stand system properties under real load. In the later stages of GA, the developer team provides small incremental features and fixes, some of which are informed by opera‐ tional needs and any production incidents that occur.\n\nPhase 5: Deprecation No system runs forever. If and when a better replacement system is available, the existing system is closed for new users and all engineering focuses on transitioning users from the existing system to the new one. SRE operates the existing system mostly without involvement from the developer team, and supports the transition with development and operational work.\n\nWhile SRE effort required for the existing system is reduced, SRE is effectively sup‐ porting two full systems. Headcount and staffing should be adjusted accordingly.\n\nPhase 6: Abandoned Once a service is abandoned, the developer team typically resumes operational sup‐ port. SRE supports service incidents on a best-effort basis. For a service with internal users, SRE hands over service management to any remaining users. This chapter pro‐ vides two case studies of how SRE can hand back a service to developer teams.\n\nPhase 7: Unsupported There are no more users, and the service has been shut down. SRE helps to delete references to the service in production configurations and in documentation.\n\n374\n\n|\n\nChapter 18: SRE Engagement Model\n\nSetting Up the Relationship A service does not exist in a vacuum: the SRE team engages with the developer team that builds the service and the product team that determines how it should evolve. This section recommends some strategies and tactics for building and maintaining good working relationships with those teams.\n\nCommunicating Business and Production Priorities Before you can help someone, you need to understand their needs. To that end, SREs need to understand what the product developers expect the SRE engagement to ach‐ ieve. When engaging with a developer team, SREs should build a deep understanding of the product and business goals. SREs should be able to articulate their role and how SRE engagement can enable developers to execute toward these goals.\n\nTeams need to regularly talk with each other about business and production priori‐ ties. The SRE and developer leadership teams should ideally work as a unit, meeting regularly and exchanging views about technical and prioritization challenges. Some‐ times SRE leads join the product development leadership team.\n\nIdentifying Risks Because an SRE team is focused on system reliability, they are well positioned to identify potential risks. Gauging the likelihood and potential impact of those risks as accurately as possible is important, as the cost of disrupting regular development and feature flow is significant to the product and to engineers.\n\nAligning Goals The developer and SRE teams both care about reliability, availability, performance, scalability, efficiency, and feature and launch velocity. However, SRE operates under different incentives, mainly favoring service long-term viability over new feature launches.\n\nIn our experience, developer and SRE teams can strike the right balance here by maintaining their individual foci but also explicitly supporting the goals of the other group. SREs can have an explicit goal to support the developer team’s release velocity and ensure the success of all approved launches. For example, SRE might state, “We will support you in releasing as quickly as is safe,” where “safe” generally implies stay‐ ing within error budget. Developers should then commit to dedicating a reasonable percentage of engineering time to fixing and preventing the things that are breaking reliability: resolving ongoing service issues at the design and implementation level, paying down technical debt, and including SREs in new feature development early so that they can participate in design conversations.\n\nSetting Up the Relationship\n\n|\n\n375\n\nShared Goals: SRE Engagements at the New York Times\n\nby Surya Prashanth Sanagavarapu (New York Times)\n\nIn our organization, SRE resources are in high demand when it comes to cloud migrations, production ramp-ups, and applications moving toward containers. In addition, SRE teams have their own backlogs to tackle. In the face of limited resour‐ ces, these competing priorities define success for the SRE team. While hiring SREs is one obvious way to address the demand for SRE time, not every team has the luxury, experience, or time to do so.\n\nThe core mission of the SRE function at the New York Times is to empower product development teams with tools and processes to maximize reliability and resilience in applications that support our newsroom, thus enabling distribution of high-quality journalism to readers. We adopted a shared goals model to achieve a balance between reducing the automation backlog and engaging with other teams.\n\nBefore engaging with teams, we review our overall backlog for the current quarter/ year and clearly define its work items and categories. For instance, our backlog items might include:\n\nAdd automation to set up baseline monitoring and alerting by hitting service sta‐ tus endpoints for applications.\n\nImplement more reliable and/or faster build pipelines.\n\nWhen teams approach SREs for help, one of the factors we consider when prioritizing a request is whether a joint engagement might help reduce our backlog.\n\nDefining the Engagement\n\nOur SREs work with product development teams according to two different models:\n\nA full-time basis\n\nA part-time basis for fairly brief and constrained projects\n\nWe define the type of engagement based upon the SRE team’s bandwidth. For full- time engagements, we prefer to embed an SRE in a product development team. This helps provide focus and time to relieve some burden from the product engineering teams. The SRE and product teams have maximum time to learn about each other as the developers ramp up on SRE skills and capabilities. For long-term engagements, we prioritize applications that best fit into our company strategy.\n\nWhen defining the engagement scope, we attempt to gauge the maturity of the team or the application in relation to SRE practices. We find that various teams are at dif‐ ferent levels of maturity when it comes to thinking about SRE practices and princi‐ ples. We are working on applying an application maturity model to help here.\n\n376\n\n|\n\nChapter 18: SRE Engagement Model\n\nSetting Shared Goals and Expectations\n\nSetting the right expectations is critical for meeting deadlines and task completion. To this end, we work according to the following principles:\n\nWe emphasize that the application owners, not SREs, are directly responsible for making changes to an application.\n\nSRE engagement is for company-wide benefit. Any new automation or tooling should improve common tools and automation used across the company and avoid one-off script development.\n\nSREs should give the developer team a heads up about any new processes the engagement might introduce (for example, load testing).\n\nThe engagements may involve Application Readiness Reviews (ARRs) and Pro‐ duction Readiness Reviews (PRRs), as described in Chapter 32 of Site Reliability Engineering. Proposed changes from ARR and PRR must be prioritized jointly by the developers and the SREs.\n\nSREs are not traditional operations engineers. They do not support manual work such as running a job for deployment.\n\nWhen we set shared goals, we write them jointly with the development team and divide the goals into milestones. If you are an Agile-based company, you might write epics or stories. The SRE team can then map those goals into their own backlog.\n\nOur common pattern when setting goals is to:\n\n1. Define the scope of the engagement.\n\nExample 1: In the next quarter, I want all members of my team to handle GKE/GAE deployments, become comfortable with production environments, and be able to handle a production outage.\n\nExample 2: In the next quarter, I want SRE to work with the dev team to stabi‐ lize the app in terms of scaling and monitoring, and to develop runbooks and automation for outages.\n\n2. Identify the end result success story, and call it out explicitly.\n\nExample: After the engagement, the product development team can handle our service outages in Google Kubernetes Engine without escalation.\n\nSprints and Communication\n\nAny engagement with product development teams begins with a kickoff and planning meeting. Prior to kickoff, our SRE team reviews the application architecture and our shared goal to verify that the expected outcome is realistic within the given time\n\nSetting Up the Relationship\n\n|\n\n377\n\nframe. A joint planning meeting that creates epics and stories can be a good starting point for the engagement.\n\nA roadmap for this engagement might be:\n\n1. Review the application architecture.\n\n2. Define shared goals.\n\n3. Hold the kickoff and planning session.\n\n4. Implement development cycles to reach milestones.\n\n5. Set up retrospectives to solicit engagement feedback.\n\n6. Conduct Production Readiness Reviews.\n\n7. Implement development cycles to reach milestones.\n\n8. Plan and execute launches.\n\nWe require that the teams define a feedback method and agree on its frequency. Both the SRE and development teams need feedback on what is working and what is not. For these engagements to be successful, we have found that providing a constant feedback loop outside of Agile sprint reviews via an agreed-upon method is useful— for example, setting up a biweekly retrospective or check-in with team managers. If an engagement isn’t working, we expect teams to not shy away from planning for disengagement.\n\nMeasuring Impact\n\nWe have found it important to measure the impact of the engagement to make sure that SREs are doing high-value work. We also measure the maturity level of each partner team so that the SREs can determine the most effective ways to work with them. One approach we adopted from working with Google’s Customer Reliability Engineering (CRE) team is to conduct a point-in-time assessment with leads of the product engineering team before starting the engagement.\n\nA point-in-time assessment consists of walking through a maturity matrix, gauging the maturity of the service along the various axes of concern to SRE (as described in Chapter 32 of Site Reliability Engineering), and agreeing on scores for functional areas such as observability, capacity planning, change management, and incident response. This also helps tailor the engagement more appropriately after we learn more about the team’s strengths, weaknesses, and blind spots.\n\nAfter the engagement ends and the development team is performing on its own, we perform the assessment again to measure the value SRE added. If we have a maturity model in place, we measure against the model to see if the engagement results in a higher level of maturity. As the engagement comes to an end, we plan for a celebra‐ tion!\n\n378\n\n|\n\nChapter 18: SRE Engagement Model\n\nSetting Ground Rules At Google, every SRE team has two major goals:\n\nShort term\n\nFulfill the product’s business needs by providing an operationally stable system that is available and scales with demand, with an eye on maintainability.\n\nLong term\n\nOptimize service operations to a level where ongoing human work is no longer needed, so the SRE team can move on to work on the next high-value engagement.\n\nTo this end, the teams should agree upon some principles of cooperation, such as:\n\nDefinitions of (and a hard limit on) operational work.\n\nAn agreed-upon and measured SLO for the service that is used to prioritize engi‐ neering work for both the developer and SRE teams. You can start without an SLO in place, but our experience shows that not establishing this context from the beginning of the relationship means you’ll have to backtrack to this step later. For an example of how engineering work proceeds less than ideally in the absence of an SLO, see “Case Study 1: Scaling Waze—From Ad Hoc to Planned Change” on page 427.\n\nAn agreed-upon quarterly error budget that determines release velocity and other safety parameters, such as excess service capacity to handle unexpected usage growth.\n\nDeveloper involvement in daily operations to ensure that ongoing issues are visi‐ ble, and that fixing their root causes is prioritized.\n\nPlanning and Executing Proactive planning and coordinated execution ensure that SRE teams meet expecta‐ tions and product goals while optimizing operations and reducing operational cost. We suggest planning at two (connected) levels:\n\nWith developer leadership, set priorities for products and services and publish yearly roadmaps.\n\nReview and update roadmaps on a regular basis, and derive goals (quarterly or otherwise) that line up with the roadmap.\n\nRoadmaps ensure that each team has a long-term time horizon of clear, high-impact work. There can be good reasons to forego roadmaps (for example, if the develop‐ ment organization is changing too quickly). However, in a stable environment, the\n\nSetting Up the Relationship\n\n|\n\n379\n\nabsence of a roadmap may be a signal that the SRE team can merge with another team, move service management work back to the development teams, expand scope, or dissolve.\n\nHolding ongoing strategy conversations with developer leadership helps to quickly identify shifts in focus, discuss new opportunities for SRE to add value to the busi‐ ness, or stop activities that are not cost-effective for the product.\n\nRoadmaps can focus on more than just improving the product. They can also address how to apply and improve common SRE technologies and processes to drive down operational cost.\n\nSustaining an Effective Ongoing Relationship Healthy and effective relationships require ongoing effort. The strategies outlined in this section have worked well for us.\n\nInvesting Time in Working Better Together The simple act of spending time with each other helps SREs and developers collabo‐ rate more effectively. We recommend that SREs meet regularly with their counter‐ parts for the services they run. It’s also a good idea for SREs to meet periodically with other SRE teams who run services that either send traffic to the service or provide common infrastructure that the service uses. The SRE team can then escalate confi‐ dently and quickly during outages or disagreements because the teams know each other and have already set expectations of how escalations should be initiated and managed.\n\nMaintaining an Open Line of Communication In addition to the day-to-day communication between teams, we’ve found a couple methods of more formal information exchange to be particularly helpful over the course of the engagement.\n\nSREs can give a quarterly “state of production” talk to product development leader‐ ship to help them understand where they should invest resources and how exactly SRE is helping their product or service. In a similar vein, developers can give a peri‐ odic “state of the product” talk to the SRE team or involve SRE in the developer team’s executive presentations. This gives the SRE team an overview of what the developer team has accomplished over the last quarter (and lets the SREs see how their own work enabled that). It also provides an update on where the product is going over the next few quarters, and where the product lead sees SRE engaging to make that happen.\n\n380\n\n|\n\nChapter 18: SRE Engagement Model\n\nPerforming Regular Service Reviews As the decision makers for the service’s future, the SRE and developer team leads responsible for the service should meet face-to-face at least once a year. Meeting more frequently than this can be challenging—for example, because it may involve intercontinental travel. During this meeting, we typically share our roadmaps for the next 12–18 months and discuss new projects and launches.\n\nSRE teams sometimes facilitate a retrospective exercise, where the leads discuss what the teams want to stop doing, keep doing, and start doing. Items can appear in more than one area, and all opinions are valid. These sessions need active facilitation because the best results come from full-team participation. This is often rated the most useful session in the service meeting because it yields details that can drive sig‐ nificant service changes.\n\nReassessing When Ground Rules Start to Slip If cooperation in any of the agreed-upon areas (see “Setting Ground Rules” on page 379) begins to regress, both developers and SRE need to change priorities to get the service back in shape. We have found that, depending on the urgency, this can mean any of the following:\n\nThe teams identify specific engineers who must drop their lower-priority tasks to focus on the regression.\n\nBoth teams call a “reliability hackathon,” but usual team priorities continue out‐ side of the hackathon days.\n\nA feature freeze is declared and the majority of both teams focus on resolving the regression.\n\nTechnical leadership determines that the reliability of the product is at acute risk, and the teams call an “all hands on deck” response.\n\nAdjusting Priorities According to Your SLOs and Error Budget The subtle art of crafting a well-defined SLO helps a team prioritize appropriately. If a service is in danger of missing the SLO or has exhausted the error budget, both teams can work with high priority to get the service back into safety. They can address the situation through both tactical measures (for example, overprovisioning to address traffic-related performance regressions) and more strategic software fixes (such as optimizations, caching, and graceful degradation).\n\nIf a service is well within SLO and has ample error budget left, we recommend using the spare error budget to increase feature velocity rather than spending overpropor‐ tional efforts on service improvements.\n\nSustaining an Effective Ongoing Relationship\n\n|\n\n381\n\nHandling Mistakes Appropriately Humans inevitably make mistakes. Consistent with our postmortem culture, we don’t blame people, and instead focus on system behavior. Your mileage may vary, but we have had success with the following tactics.\n\nSleep on it\n\nIf possible, don’t conduct follow-up conversations when you’re tired or emotions are high. During high-stress situations, people can easily misinterpret tone in written communication like emails. Readers will remember how the words made them feel, not necessarily what was written. When you’re communicating across locations, it’s often worth the time to set up a video chat so that you can see facial expressions and hear the tone of voice that helps disambiguate words.\n\nMeet in person (or as close to it as possible) to resolve issues\n\nInteractions conducted solely via code reviews or documentation can quickly become drawn out and frustrating. When a behavior or decision from another team is at odds with our expectations, we talk with them about our assumptions and ask about miss‐ ing context.\n\nBe positive\n\nThank people for their positive behaviors. Doing so can be simple—for example, dur‐ ing code reviews, design reviews, and failure scenario training, we ask engineers to call out what was good and explain why. You might also recognize good code com‐ ments or thank people for their time when they invest in a rigorous design review.\n\nUnderstand differences in communication\n\nDifferent teams have different internal expectations for how information is dissemi‐ nated. Understanding these differences can help strengthen relationships.\n\nScaling SRE to Larger Environments The scenarios we’ve discussed so far involve a single SRE team, a single developer team, and one service. Larger companies, or even small companies that use a micro‐ services model, may need to scale some or all of these numbers.\n\nSupporting Multiple Services with a Single SRE Team Because SREs have specialized skills and are a scarce resource, Google generally maintains an SRE-to-developer ratio of < 10%. Therefore, one SRE team commonly works with multiple developer teams in their product area (PA).\n\n382\n\n|\n\nChapter 18: SRE Engagement Model\n\nIf SREs are scarce relative to the number of services that merit SRE support, an SRE team can focus their efforts on one service, or on a few services from a small number of developer teams.\n\nIn our experience, you can scale limited SRE resources to many services if those serv‐ ices have the following characteristics:\n\nServices are part of a single product. This provides end-to-end ownership of the user experience and alignment with the user.\n\nServices are built on similar tech stacks. This minimizes cognitive load and ena‐ bles effective reuse of technical skills.\n\nServices are built by the same developer team or a small number of related devel‐ oper teams. This minimizes the number of relationships and makes it easier to align priorities.\n\nStructuring a Multiple SRE Team Environment If your company is big enough to have multiple SRE teams, and perhaps multiple products, you need to choose a structure for how SRE and the product groups relate.\n\nWithin Google, we support a complex developer organization. As shown in Figure 18-2, each PA consists of multiple product groups that each contain multiple products. The SRE organization shadows the developer organization hierarchically, with shared priorities and best practices at each level. This model works when all teams in a group, or all groups in a PA, share the same or similar specific business goals, and when every product group has both a product leader and an SRE lead.\n\nFigure 18-2. Large-scale developer-to-SRE team relationships (per product area)\n\nScaling SRE to Larger Environments\n\n|\n\n383\n\nIf your organization has multiple SRE teams, you’ll need to group them in some way. The two main approaches we’ve seen work well are:\n\nGroup the teams within a product, so they don’t have to coordinate with too many different developer teams.\n\nGroup the teams within a technology stack (e.g., “storage” or “networking”).\n\nTo prevent churn in SRE teams during developer reorgs, we recommend organizing SRE teams according to technology rather than developer PA reporting structure. For example, many teams that support storage systems are structured and operate in the same way. Grouping storage systems in technology-focused product groups may make more sense even if they come from different parts of the developer organiza‐ tion.\n\nAdapting SRE Team Structures to Changing Circumstances If you need to modify the structure of your SRE teams to reflect changing PA needs, we recommend creating, splitting (sharding), merging, and dissolving SRE teams based on service needs and engineering and operational load. Each SRE team should have a clear charter that reflects their services, technology, and operations. When a single SRE team has too many services, rather than building new teams from scratch, we prefer to shard the existing team into multiple teams to transfer culture and grow existing leadership. Changes like this are inevitably disruptive to existing teams, so we’d recommend that you restructure teams only when necessary.\n\nRunning Cohesive Distributed SRE Teams If you need to ensure 24/7 coverage and business continuity, and you have a global presence, it’s worth trying to distribute your SRE teams around the globe to provide even coverage. If you have a number of globally distributed teams, we recommend colocating teams based upon adjacency and upon similarity of services and shared technology. We’ve found that singleton teams are generally less effective and more vulnerable to the effects of reorgs outside the team—we create such teams only if clearly defined business needs call for them and we’ve considered all other options.\n\nMany companies don’t have the resources for full global coverage, but even if you’re split only across buildings (never mind continents), it’s important to create and maintain a two-location arrangement.\n\nIt’s also important to create and maintain organizational standards that drive plan‐ ning and execution and foster and maintain a shared team culture. To this end, we find it useful to gather the entire team in one physical location periodically—for example, at an org-wide summit every 12–18 months.\n\n384\n\n|\n\nChapter 18: SRE Engagement Model\n\nSometimes it doesn’t make sense for everyone on the team to own certain responsi‐ bilities—for example, conducting regular test restores from backups or implementing cross-company technical mandates. When balancing these responsibilities between a team’s distributed sites, keep the following strategies in mind:\n\nAssign individual responsibilities to single locations, but rotate them regularly (e.g., yearly).\n\nShare every responsibility between locations, making an active effort to balance the involvement and workload.\n\nDon’t lock a responsibility to a single location for multiple years. We’ve found that the costs of this configuration ultimately outweigh the benefits. Although that location will tend to become really good at executing those responsibilities, this fosters an “us versus them” mentality, hinders distribution of knowledge, and presents a risk for business continuity.\n\nAll of these strategies require locations to maintain tactical and strategic communica‐ tion.\n\nEnding the Relationship SRE engagements aren’t necessarily indefinite. SREs provide value by doing impact‐ ful engineering work. If the work is no longer impactful (i.e., the value proposition of an SRE engagement goes away), or if the majority of the work is no longer on the engineering (versus operations) side, you may need to revisit the ongoing SRE engagement. In general, individual SREs will move away from toil-heavy teams to teams with more interesting engineering work.\n\nOn a team level, you might hand back a service if SRE no longer provides sufficient business value to merit the costs. For example:\n\nIf a service has been optimized to a level where ongoing SRE engagement is no longer necessary\n\nIf a service’s importance or relevance has diminished\n\nIf a service is reaching end of life\n\nThe following case studies demonstrate how two Google SRE engagement models ended. The first ends with largely positive results, while the other ends with a more nuanced outcome.\n\nCase Study 1: Ares Google’s Abuse SRE and Common Abuse Tool (CAT) teams provided anti-abuse protection for most Google properties and worked with customer-facing products to\n\nEnding the Relationship\n\n|\n\n385",
      "page_number": 385
    },
    {
      "number": 44,
      "title": "Segment 44 (pages 403-410)",
      "start_page": 403,
      "end_page": 410,
      "detection_method": "topic_boundary",
      "content": "keep users safe. The Abuse SRE team applied engineering work to lower CAT’s operational support burden so that the developers were able to take a direct role in supporting their users. These users were the Googlers operating the properties defen‐ ded by CAT, who had high expectations about the efficacy of CAT and its response time to problems or new threats.\n\nEfficient abuse fighting requires constant attention, rapid adaptive changes, and nim‐ ble flexibility in the face of new threats and attacks. These requirements clashed with the common SRE goals of reliable and planned feature development. CAT teams rou‐ tinely needed to implement fast development and deploy new protections to proper‐ ties under attack. However, Abuse SRE pushed back on requested changes, requesting more in-depth analysis of the consequences each new protection would have on the overall production system. Time constraints on consultations between teams and reviews compounded this tension.\n\nTo hopefully improve the situation, Abuse SRE and CAT leadership engaged in a multiyear project to create a dedicated infrastructure team within CAT. The newly formed “Ares” team had a mandate to unify abuse-fighting infrastructure for Google properties. This team was staffed by CAT engineers who had production infrastruc‐ ture knowledge and experience building and running large services. The teams started an exchange program to transfer production management knowledge from Abuse SRE to the CAT infrastructure team members.\n\nAbuse SREs taught the Ares team that the easiest way to launch a new service in pro‐ duction (when you’re already running large distributed services) is to minimize the additional cognitive load that the service imposes. To reduce this cognitive load, sys‐ tems should be as homogeneous as possible. Deploying and managing a collection of production services together means they can share the same release structure, capacity planning, subservices for accessing storage, and so on. Following this advice, Ares redesigned the whole abuse-fighting stack, applying modularity concepts to shift toward a microservice model. They also built a new layer that provided abstractions for developers so that they didn’t have to worry about lower-level production details like monitoring, logging, and storage.\n\nAt this point, the Ares team started to act more like an SRE team for CAT by admin‐ istering the new abuse-fighting infrastructure. Meanwhile, Abuse SRE focused on the production deployment and efficient day-to-day operation of the overall abuse- fighting infrastructure.\n\nCollaboration between the Ares engineers and Abuse SRE resulted in the following improvements:\n\nBecause the CAT team now had “in-house” production experts that were also experts in abuse fighting, Abuse SRE no longer had to vet new feature integra‐ tion. This greatly reduced time to production for new features. At the same time,\n\n386\n\n|\n\nChapter 18: SRE Engagement Model\n\nthe CAT team’s developer velocity increased because the new infrastructure abstracted away production management details.\n\nThe Abuse SRE team now had many fewer requests from the CAT team to launch new features, as most of the requests did not require infrastructure changes. The team also needed less knowledge to evaluate the impact of a new feature, since infrastructure changes were rarely required. When infrastructure changes were necessary, Abuse SRE only needed to clarify the implications on the infrastructure rather than specific feature functionality.\n\nProducts that needed to integrate with abuse-fighting infrastructure had a faster and more predictable turnaround time since a product integration was now equivalent in effort to a feature launch.\n\nAt the end of this project, Abuse SREs disengaged from directly supporting CAT, focusing instead on the underlying infrastructure. This did not compromise CAT’s reliability or overburden the CAT team with additional operational work; instead, it increased CAT’s overall development velocity.\n\nCurrently, Ares protects users across a large number of Google properties. Since the team’s inception, SREs and product development have partnered to make collabora‐ tive decisions on how infrastructure will work in production. This partnership was only possible because the Ares effort created a sense of shared destiny.\n\nCase Study 2: Data Analysis Pipeline Sometimes the cost of maintaining an SRE support relationship is higher than the value (perceived or measured) that SREs provide. In these cases, it makes sense to end the relationship by disbanding the SRE team.1\n\nWhen the value of a relationship declines over time, it is extremely difficult to iden‐ tify a point in time when it makes sense to terminate that relationship. Two teams at Google that supported a revenue-critical data analysis pipeline had to face this chal‐ lenge. Figuring out that a parting of the ways was appropriate was not a trivial task, especially after a decade of cooperation. In retrospect, we were able to identify several patterns within the team interaction that were strong indicators that we needed to reconsider the relationship between the SRE team and the product team.\n\nThe pivot\n\nThree years before the turndown, all involved parties recognized that their primary data analysis pipeline was running into scaling limitations. At that time, the devel‐ oper team decided to start planning their new system and dedicated a small number\n\n1 Google HR supports employees by finding new opportunities when such transitions occur.\n\nEnding the Relationship\n\n|\n\n387\n\nof engineers to the new effort. As that effort began to coalesce, it made sense to deprioritize development of large, complex, or risky features for the existing system in favor of work on the new system. This had two important effects over time:\n\nAn informal rule was applied to new projects: if the project’s complexity or the risk involved in modifying the existing system to accommodate the project was sufficiently high, then it was better to make that investment in the new system.\n\nAs resources shifted to developing the new system, even relatively conservative changes to the existing system became more difficult. Nevertheless, usage contin‐ ued to grow at an extremely high rate.\n\nCommunication breakdown\n\nKeeping an existing system operational while a replacement system is simultaneously designed, built, and launched is challenging for any engineering team. Stresses natu‐ rally build between the people focused on new versus old systems, and teams need to make difficult prioritization decisions. These difficulties can be compounded when the teams are separated organizationally—for example, an SRE team focused on maintaining and operating an existing system and a developer team working on the next-generation system.\n\nRegular, open, and cooperative communication is vital throughout this entire cycle in order to maintain and preserve a good working relationship across teams. In this example, a gap in communication led to a breakdown in the working relationship between teams.\n\nDecommission\n\nIt took some time to realize that the disconnectedness between the SRE and devel‐ oper teams was insurmountable. Ultimately, the simplest solution was to remove the organizational barrier and give the developer team full control over prioritizing work on old and new systems. The systems were expected to overlap for 18–24 months before the old system was fully phased out.\n\nCombining SRE and product development functions into a single team allowed upper management to be maximally responsive to their areas of accountability. Meanwhile, the team could decide how to balance operational needs and velocity. Although decommissioning two SRE teams was not a pleasant experience, doing so resolved the continual tension over where to invest engineering effort.\n\nDespite the inevitable extra operational load on the developer team, realigning own‐ ership of the old system with people who had greater knowledge of service internals provided the opportunity to more quickly address operational problems. This team also had more insight into potential causes of outages, which generally resulted in\n\n388\n\n|\n\nChapter 18: SRE Engagement Model\n\nmore effective troubleshooting and quicker issue resolution. However, there were some unavoidable negative impacts while the developer team learned about the nuances of the operational work needed to support the service in a short amount of time. The SRE team’s final job was to make the transfer of this knowledge as smooth as possible, equipping the developer team to take on the work.\n\nIt is worth noting that if the working relationship were healthier—with teams work‐ ing together effectively to solve problems—SRE would have handed production work back to the developer team for a short period of time. After the system was restabi‐ lized and hardened for expected growth needs, SRE would normally reassume responsibility of the system. SRE and development teams need to be willing to address issues head on and identify points of tension that need resetting. Part of SRE’s job is to help maintain production excellence in the face of changing business needs, and often this means engaging with developers to find solutions to challenging problems.\n\nConclusion The form of an SRE team’s engagement changes over the various phases of a service’s lifecycle. This chapter provided advice specific to each phase. Examples from both the Google and the New York Times SRE teams show that effectively managing the engagement is just as important as making good technical design decisions. Some‐ times an SRE engagement should reach a natural conclusion. Case studies from Ares and a data analysis pipeline team provided examples of how this can happen, and how best to end the engagement.\n\nWhen it comes to best practices for setting up an effective relationship between SRE and product development teams, a shared sense of purpose and goals with regular and open communication is key. You can scale an SRE team’s impact in a number of ways, but these principles for relationship management should always hold true. For sustaining the long-term success of an engagement, investing in aligning team goals and understanding each other’s objectives is as important as defending SLOs.\n\nConclusion\n\n|\n\n389\n\nCHAPTER 19 SRE: Reaching Beyond Your Walls\n\nBy Dave Rensin with Betsy Beyer, Niall Richard Murphy, and Liz Fong-Jones\n\nIt has been 14 years since we started practicing SRE at Google. Some of what has come in that time seems obvious in retrospect, while other developments came as something of a shock. The past two years since the publication of our first SRE book have been especially interesting. The number of companies now practicing the SRE discipline and the amount of time we spend talking about it at conferences and with customers has grown beyond anything we previously imagined.\n\nThat change in particular—the rapid expansion of the non-Google ecosystem around SRE—is the most exciting development, but it makes predicting the future of the SRE profession more difficult. Still, in our own SRE work at Google we are starting to see some trends that might inform an outline of the profession’s future. This chapter rep‐ resents our effort to share what we, along with our SRE coworkers around the globe, have seen, and what we have concluded so far.\n\nTruths We Hold to Be Self-Evident The only way to make any useful sense of the future is to start with a set of principles and work forward. Some of what follows should be uncontroversial. Other bits, not so much. In every case, though, these principles are based on real things we’re seeing in the world.\n\nReliability Is the Most Important Feature People don’t normally disagree much with us when we assert that “reliability is the most important feature of any system”—as long as we take care to point out that “reliability” often covers a wide area.\n\n391\n\nThe argument is simple enough:\n\nIf a system isn’t reliable, users won’t trust it.\n\nIf users don’t trust a system, when given a choice, they won’t use it.\n\nSince all software systems are governed by network effects, if a system has no users, it’s worth nothing.\n\nYou are what you measure, so choose your metrics carefully.\n\nYour Users, Not Your Monitoring, Decide Your Reliability Since the value of a system is related to its users, it stands to reason that the only measure of reliability that matters is how your users experience reliability. If your user is worried that your platform is responsible for instability they’re experiencing, then telling them “our monitoring looks fine; the problem must be on your end” won’t make them any less grumpy. They’re experiencing your system as unstable, and that’s what they will remember when the time comes to choose between you and your competitor. (This phenomenon is called the peak-end rule.)\n\nYour monitoring, logs, and alerting are valuable only insofar as they help you notice problems before your customers do.\n\nIf You Run a Platform, Then Reliability Is a Partnership If the only way for someone to use your system is via a visual user interface (e.g., a web page) and your system is consumed only by actual human beings (as opposed to machines), then the reliability your users experience is almost exclusively tied to the job you do as an SRE keeping your system healthy.\n\nHowever, once you add an API and some of your “users” are actually other machines, you are running a platform and the rules change.\n\nWhen your product acts as a platform, the reliability your users experience isn’t limi‐ ted to the choices you make. Reliability becomes a partnership. If your users build or operate a system on your platform that never achieves better than 99% availability— even if you’re running your platform at 99.999% availability—then their best-case experience is 98.99901%.\n\nThe choices these users make directly affect the experience they have and associate with your service. You might not like it, but they will hold you accountable for what‐ ever they experience—even if it’s not “your fault.”\n\n392\n\n|\n\nChapter 19: SRE: Reaching Beyond Your Walls\n\nEverything Important Eventually Becomes a Platform Since the value of your system increases with the number of people using it, you will want to find ways to reach other large established user pools. As you attract more users, other software systems will want to reach your audience, too.\n\nThis is when other companies start making their machines talk to your machines via APIs. If your system is even remotely popular, integration is an inevitable step in your evolution.\n\nEven if you decide that you don’t care about other user communities, and decide to never create a machine-consumable API, you still won’t be able to avoid this future. Other people will simply wrap your UI into a machine API and consume it. The only difference is that you’ll have no control over the outcome.\n\nOnce your system becomes a gateway to a large collection of users, it becomes valua‐ ble. APIs—official or unofficial—will be a part of your future.\n\nWhen Your Customers Have a Hard Time, You Have to Slow Down When your customers have a hard time, their frustration turns into friction for you. Even if you don’t have traditional modes of support (trouble tickets, email, phone, etc.), you will still spend time triaging questions and responding to complaints via StackOverflow, or even Twitter, Facebook, and other social platforms.\n\nWhatever energy you put into helping users past their difficult moments is energy you can’t invest in advancing your system. We have seen many teams (and compa‐ nies) allow their time to be slowly absorbed by break/fix customer problems—leaving an ever-diminishing innovation budget. These teams are consumed by toil.\n\nOnce in this state, it’s hard to dig out (see Chapter 6). A better plan is to get ahead of the impending toil. You might be reading this and thinking, Gee, I’m on an internal platform team. This doesn’t apply to me!\n\nWe’re sorry to inform you that this doubly applies to you! In your case, your custom‐ ers are the consumers of your system within your company.\n\nThis leads us to the next conclusion.\n\nYou Will Need to Practice SRE with Your Customers If you want your customers to design and operate reliable systems using your plat‐ form, you have to teach them how to do it. Yes, this includes your internal customers, too. Just because you work on an internal platform team doesn’t mean you escape this dynamic—in fact, you’re likeliest to run into it first.\n\nEven if you could perfectly distill that information into highly scaled one-to-many forms (books, blog posts, architecture diagrams, videos, etc.), you still need a way to\n\nTruths We Hold to Be Self-Evident\n\n|\n\n393\n\nfigure out what content and training to include. As you grow and improve your plat‐ form, those lessons will change. You will always need a way to keep these resources from getting stale.\n\nThe best way to learn these lessons is to “do SRE” with your customers.\n\nThat doesn’t necessarily mean you need to take the pagers for your customers’ sys‐ tems, but you do need to undertake most of the work that normally leads up to pager handoff (meaning the system has met certain minimum viable reliability require‐ ments), with at least a representative sample of your users.\n\nHow to: SRE with Your Customers The idea of walking an SRE journey with your customers might seem a little daunt‐ ing. You’re probably reading this book because you’re not entirely sure how to walk it yourself! No worries. It’s possible to do both at the same time. In fact, the former can help you accelerate the latter.\n\nHere are the steps we like to follow. They work pretty well for us, and we think they’ll be useful for you, too.\n\nStep 1: SLOs and SLIs Are How You Speak You want your customers to perceive your system as reliable. Otherwise, you risk los‐ ing them. It stands to reason, therefore, that you should care a lot about how they form those opinions. What do they measure? How do they measure it? Most impor‐ tantly, what promises are they making to their customers?\n\nYour life will be a lot better if your customers measure SLIs and alert on SLOs, and if they share those measurements with you. Otherwise, you will spend a lot of energy in conversations like this:\n\nCustomer: API call X usually takes time T, but now it’s taking time U. I think you are having a problem. Please look into it and get back to me immediately.\n\nYou: That performance seems in line with what we expect, and everything looks fine on our end. Is it a problem if API call X takes this long?\n\nCustomer: I don’t know. It doesn’t usually take this long, so obviously something has changed and we’re worried about it.\n\nThis conversation will go round in circles and never reach a satisfactory answer. You will either spend a lot of time convincing your customer that they shouldn’t care, or you will spend a lot of time root-causing the change so you can convince your customer they shouldn’t care. In either case, you’re spending a lot of effort that you could be using elsewhere.\n\nThe root cause of this problem is that the customer isn’t using SLOs to figure out if they should care about the performance they’re seeing. They’re just noticing an unex‐\n\n394\n\n|\n\nChapter 19: SRE: Reaching Beyond Your Walls",
      "page_number": 403
    },
    {
      "number": 45,
      "title": "Segment 45 (pages 411-419)",
      "start_page": 411,
      "end_page": 419,
      "detection_method": "topic_boundary",
      "content": "pected change and deciding to worry about it. Remember, in the absence of a stated SLO, your customer will inevitably invent one and not tell you until you don’t meet it! You’d much rather have this conversation:\n\nCustomer: We’re burning through our SLO for application FOO too quickly and the application is in jeopardy. SLIs X and Y seem to have fallen off a cliff. They both depend on your API X.\n\nYou: Okay. Let me look into how API X is performing in our system and/or how it’s performing specific to you.\n\nThat’s a much more productive conversation because (a) it will happen only when the SLO is threatened, and (b) it relies on mutually understood metrics (SLIs) and targets (SLOs).\n\nIf you’re running your systems using SRE practices, then you are speaking SLOs internally. Your life will be better and your customers will be happier if they are speaking SLOs, too, because it makes it easier for the two of you to talk.\n\nWe recommend a simple exercise to make your working relationship with a customer a lot better: sit down with your customer. Explain SLOs, SLIs, and error budgets— and especially how you practice them in your teams. Then help them describe the critical applications they’ve built on your platform in those terms.\n\nStep 2: Audit the Monitoring and Build Shared Dashboards Once your customers have picked some basic SLOs for their application, the next question is if they are measuring the right things to determine whether or not they’re meeting those goals. You should help them figure out if the measurements they’re using are appropriate.\n\nIn our experience, up to half of the things your customer is measuring (and alerting on) have zero impact on their SLOs. Your life will be better when you point this out to them and they turn off the offending alerting. It will mean fewer pages for them, and for you!\n\nThe remaining measurements are useful candidate SLIs. Help your customer assem‐ ble those measurements to calculate their SLOs.\n\nOnce you begin this exercise, you’ll quickly find that parts of the SLOs are uncovered —there aren’t relevant measurements in place to say anything useful about these dimensions. You should help your customer cover these parts of their SLOs, too.\n\nNow, your customers can start to say something about their application’s SLO per‐ formance on your platform.\n\nFinally, build a set of shared SLO dashboards with your customer. You should be able to see their application SLOs, and you should share any information you have that’s relevant to how they’re experiencing your system performance. Your goal is that\n\nHow to: SRE with Your Customers\n\n|\n\n395\n\nwhenever your customer contacts you because their SLO seems threatened, you shouldn’t have to swap much additional information. All of that information should be in the shared monitoring.\n\nStep 3: Measure and Renegotiate Once you sort the measurements out, you should collect data for a month or two. Be prepared for the likelihood that your customer is in for a rude awakening. The appli‐ cation they thought was operating at “five 9s” (99.999%; everybody thinks they’re get‐ ting five 9s) is probably achieving only 99.5%–99.9% when measured against their shiny new SLOs.\n\nAfter the initial shock wears off, this is a great time to point out that their users aren’t yelling all the time, so they probably never needed the five 9s they haven’t really been getting.\n\nThe key question is, how satisfied are their users with the application’s performance? If their users are happy, and there’s no evidence that improving performance or availability will increase user adoption/retention/usage, then you’re done. You should periodically ask yourself this question to make sure that your budgets and priorities are still correct. (See Chapter 2 for a more in-depth treatment of this topic.)\n\nIf the customer thinks they still need to make things a little better, move on to the next step.\n\nStep 4: Design Reviews and Risk Analysis Sit down with your customer and really understand how their application is designed and operated. Do they have any hidden single point of failures (SPOFs)? Are their rollouts and rollbacks manual? Basically, conduct the same exercise you conduct for your own internal applications.\n\nNext, rank the issues you find by how much of their error budget each item con‐ sumes. (Read more about how to do that on the Google Cloud Platform Blog.) Pay attention to which items your customer chooses to fix in order to “earn back the 9s” they want (e.g., to move from 99.5% to 99.9%).\n\nWhat you learn from these reviews will tell you:\n\nHow your customers consume your platform\n\nWhat reliability mistakes they make when doing so\n\nWhich tradeoffs they choose when trying to improve\n\nThis exercise will also help your customer set realistic expectations around the relia‐ bility they should experience with their current application. Their expectations will\n\n396\n\n|\n\nChapter 19: SRE: Reaching Beyond Your Walls\n\naffect their perceptions, so setting them appropriately can only be helpful in earning and keeping their trust.\n\nStep 5: Practice, Practice, Practice The final step is to create some operational rigor with your customer. Practice simu‐ lated problems (Wheel of Misfortune exercises, disaster and recovery testing, paper game days, etc.).\n\nDevelop a healthy muscle memory between the teams for effective ways to communi‐ cate during a crisis. It’s a great way to build trust, lower the MTTR, and learn about weird operational edge cases that you can integrate as enhancements into your plat‐ form features.\n\nWhen an incident does occur, don’t just share your postmortems with your cus‐ tomer. Actually conduct some joint postmortems. Doing so will also build trust and teach you some invaluable lessons.\n\nBe Thoughtful and Disciplined It will quickly become impossible to carry out these steps with more than a small per‐ centage of your customers. Please don’t try extending this model to everyone. Instead, make some principled decisions about how you will make selections. Here are some common approaches:\n\nRevenue coverage\n\nSelect the minimum number of customers to account for XX% of your revenue. If your revenue is heavily weighted to a few large customers, then this might be the right choice for you.\n\nFeature coverage\n\nSelect the minimum number of customers to cover more than XX% of your plat‐ form features. If you run a highly diverse platform with a long tail of customers doing a lot of different things, then this approach will help you avoid surprises.\n\nWorkload coverage\n\nYour platform’s usage may be dominated by a few distinct use cases or customer types. Perhaps no individual customer in those types is dominant, but you can easily group them into cohorts. In that case, sampling one or two customers from each cohort is a good way to get platform coverage and discover operational dif‐ ferences between the use cases.\n\nWhatever approach you choose, stick to it. Mixing and matching will confuse your stakeholders and quickly overwhelm your team.\n\nHow to: SRE with Your Customers\n\n|\n\n397\n\nConclusion Over the last few years, the SRE profession and role has spread widely outside the walls of Google. Although we never expected this, we are nonetheless thrilled by it. We might be able to say something credible about how we think the discipline will evolve inside Google, but in the wild—well, that’s an “uncomfortably exciting” prop‐ osition.\n\nOne thing we feel pretty sure about is that as you adopt SRE principles into your organization, you will cross many of the same inflection points we did (and some we have not!)—including the need to blur the lines more between where your customers end and where you start.\n\nEngaging with individual customers at this level of operational depth is a rewarding new frontier for us, and we’re still very much on the path. (You can follow along online at the Google Cloud Platform Blog.) The further we go, however, the more certain we are that this is a journey that you, too, will need to take.\n\n398\n\n|\n\nChapter 19: SRE: Reaching Beyond Your Walls\n\nCHAPTER 20 SRE Team Lifecycles\n\nBy David Ferguson and Prashant Labhane with Shylaja Nukala\n\nThe Preface to this book set a goal to “dispel the idea that SRE is implementable only at ‘Google scale’ or in ‘Google culture.’” This chapter lays out a roadmap for matur‐ ing an SRE organization from unstaffed but aspirational, through various stages of maturity, to a robust and (potentially) globally distributed set of SRE teams. Regard‐ less of where you are in your journey as an SRE organization, this chapter will help you identify strategies for evolving your SRE organization.\n\nWe discuss the SRE principles that need to be in place at each stage of this journey. While your own journey will vary depending on the size, nature, and geographic dis‐ tribution of your organization, the path we describe to successfully apply SRE princi‐ ples and implement SRE practices should be generalizable to many different types of organizations.\n\nSRE Practices Without SREs Even if you don’t have SREs, you can adopt SRE practices by using SLOs. As dis‐ cussed in Chapter 2, SLO are the foundations for SRE practices. As such, they inform our first principle of SRE:\n\nPrinciple #1\n\nSRE needs SLOs with consequences.\n\nThe performance of your service relative to SLOs should guide your business decisions.\n\n399\n\nWe believe that the following practices—which you can achieve without even having a single SRE—are the crucial steps toward implementing SRE practices:\n\nAcknowledge that you don’t want 100% reliability.\n\nSet a reasonable SLO target. This SLO should measure the reliability that is most important to your users.\n\nAgree on an error budget policy that will help defend your user experience. Use the error budget to help guide:\n\n— Tactical actions to mitigate outages or to manage changes that return your\n\nsystem to a reliable state\n\n— Longer-term prioritization of work to make the system more reliable and use\n\nless of the error budget\n\nMeasure the SLO and commit to following the error budget policy. This commit‐ ment requires agreement from company leadership.\n\nEven if an organization doesn’t have SRE staff, we believe that it is worthwhile to set SLOs for critical customer applications and to implement an error budget policy, if only because an implicit 100% SLO means a team can only ever be reactive. This SRE principle allows you to make data-informed decisions about how to ensure the relia‐ bility of your application.\n\nStarting an SRE Role\n\nFinding Your First SRE It’s possible that your first SRE employees won’t have explicit experience as an SRE. We’ve found the following areas to be relevant to the SRE role, and therefore appro‐ priate to cover in interviews:\n\nOperations\n\nRunning applications in production gives invaluable insights that cannot be easily gained otherwise.\n\nSoftware engineering\n\nSREs need to understand the software they are supporting, and be empowered to improve it.\n\nMonitoring systems\n\nSRE principles require SLOs that can be measured and accounted for.\n\nProduction automation\n\nScaling operations requires automation.\n\n400\n\n|\n\nChapter 20: SRE Team Lifecycles\n\nSystem architecture\n\nScaling the application requires good architecture.\n\nYour first SRE will likely occupy a difficult and ambiguous position between velocity and reliability goals. They will need to be resilient and flexible in order to provide the right balance between enabling product development and defending the customer experience.\n\nPlacing Your First SRE Once you’ve hired your first SRE, you now need to decide where to embed them in your organization. You have three main choices:\n\nIn a product development team\n\nIn an operations team\n\nIn a horizontal role, consulting across a number of teams\n\nWe recommend that you evaluate the pros and cons of each of these three options after reading this chapter, taking into account:\n\nYour own role and sphere of influence.\n\nIf you’re able to effectively influence product development team(s), then embed‐ ding an SRE in operations or horizontal work can help iron out gnarly produc‐ tion issues early.\n\nThe immediate challenges that you face.\n\nIf the challenges require hands-on work to mitigate a technical problem or busi‐ ness risk, then embedding an SRE in an operations or product team can be advantageous. Doing so removes organizational silos and facilitates easy commu‐ nication between team members.\n\nThe challenges you expect to face in the next 12 months.\n\nFor example, if you’re focusing on launches, embedding the SRE within a prod‐ uct development team might make sense. If you’re focusing on infrastructure changes, embedding the SRE with an operations team might make more sense.\n\nYour plan for how you want to change your organization.\n\nIf you plan to move toward a centralized SRE organization, you might not want to embed SREs in product development teams initially—it might be hard to remove them from these teams later.\n\nThe person you have identified as your first SRE.\n\nDecide where this first SRE would be most productive based upon their back‐ ground and skills.\n\nStarting an SRE Role\n\n|\n\n401\n\nIt might make sense to experiment with different models as you figure out which approach works best for you. However, we strongly recommend sticking with one stable and coherent model in the long term; otherwise, the instability will undermine the effectiveness of SRE.\n\nBootstrapping Your First SRE Your first SRE’s initial mission is to get up to speed on the service. In order to have a positive impact, an SRE needs to understand the service’s current problems, its required toil (see Chapter 6) and the engineering required to keep the system within SLOs. If your organization doesn’t already have SLOs and error budgets as per Prin‐ ciple #1, your first SRE needs to perform the engineering required to design and implement these tools. At this point, our second SRE principle comes into play:\n\nPrinciple #2\n\nSREs must have time to make tomorrow better than today.\n\nWithout this principle, toil will only increase as service usage increases and the sys‐ tem becomes correspondingly larger and more complex. A healthy balance between operational responsibilities and project work is essential—if toil becomes too burden‐ some, talented engineers will flee the team. For more guidance on how an SRE team might obtain that balance, see Chapter 17.\n\nInitial project work might focus on one of the following:\n\nImproving monitoring so you can better understand the system when things go wrong.\n\nAddressing any high-priority actions identified in recent postmortems (see Chapter 10).\n\nImplementing automation to reduce a specific element of toil required to run the service.\n\nIt is vital that the SRE has a distinctive role and that their projects benefit the whole team. Look out for signs that the SRE work is not going well:\n\nTheir mix of work is indistinguishable from other engineering work.\n\nIf your first SRE is on a product development team, they are doing more than their fair share of operational work, or they are the only person working on ser‐ vice configuration changes.\n\n402\n\n|\n\nChapter 20: SRE Team Lifecycles\n\nThe SLOs are not being taken seriously, and the SRE isn’t making progress in measuring and defending the customer experience.\n\nDistributed SREs If your organization doesn’t have (or doesn’t plan to have) a discrete SRE team (or teams), it’s important to construct a community for distributed SREs. This commu‐ nity should advocate the SRE’s distinctive role and drive consistent changes in reliability-focused technology or practices across teams. Without a social grouping, individual SREs may feel very isolated.\n\nYour First SRE Team You might start an SRE team in a number of ways. Approaches we’ve used at Google, from least to most complex, include:\n\nCreating a new team as part of a major project\n\nEstablishing a horizontal SRE team\n\nConverting an existing team (for example, an operations team)\n\nThe approach that’s best for your organization is highly situational. A team needs enough SREs to handle the operational tasks required to run the service. Addressing that workload brings us to our third principle:\n\nPrinciple #3\n\nSRE teams have the ability to regulate their workload.\n\nOutside of a large SRE organization, a team likely can’t embrace this concept from day one. This principle is open to interpretation and can be difficult to put into prac‐ tice organizationally. It’s also the most subtle of our three principles, and bears some unpacking. The following sections walk through the stages of building a team, using Tuckman’s performance model and stages of forming, storming, norming, and performing.1\n\n1 Bruce W. Tuckman, “Developmental Sequence in Small Groups,” Psychological Bulletin 63, no. 6 (1965):\n\n384–99.\n\nYour First SRE Team\n\n|\n\n403",
      "page_number": 411
    },
    {
      "number": 46,
      "title": "Segment 46 (pages 420-428)",
      "start_page": 420,
      "end_page": 428,
      "detection_method": "topic_boundary",
      "content": "Forming The team you assemble should have combined experience and expertise that includes the following:\n\nMaking changes to application software to improve reliability and performance.\n\nWriting software to:\n\n— Expedite the detection and mitigation of problems in production.\n\n— Automate manual processes.\n\nEstablishing and using strong software practices and standards to facilitate long- term maintainability.\n\nHaving a methodical and careful approach to making operational changes: be able to describe why certain practices are reliable.\n\nUnderstanding system architecture (distributed systems design and operation).\n\nIdeally, your team will be ready to adopt a new way of working, and have a balance of skills and established personal relationships with other teams. If possible, we recom‐ mend that you seed the team with internal transfers. This can reduce the time it takes your team to get up and running.\n\nCreating a new team as part of a major project\n\nYou might create a new SRE team for a major project that is large enough to justify new headcount, and for which reliability and operational capability have been identi‐ fied as project risks. Examples might include the creation of a new service or a sub‐ stantial change in your technology (e.g., migration to a public cloud).\n\nAssembling a horizontal SRE team\n\nIn this approach (well documented in Chapter 27 of our first book), a small team of SREs consults across a number of teams. This team might also establish best practices and tools for configuration management, monitoring, and alerting.\n\nConverting a team in place\n\nYou might be able to convert an existing team into an SRE team. The existing team likely isn’t a product development team; typical candidates include an operations team or a team responsible for managing a popular open source component that your organization uses heavily. Be careful to avoid renaming a team from “Operations” to “SRE” without first applying SRE practices and principles! If your rebranding effort fails, your organization may be poisoned against the entire concept of SRE in the future.\n\n404\n\n|\n\nChapter 20: SRE Team Lifecycles\n\nStorming Once assembled, the team needs to start working collaboratively: the team members need to work well with each other, and also with other teams.\n\nYou might employ any number of tactics to promote this type of cohesion. At Goo‐ gle, we’ve had success providing a regular forum for learning and discussing SRE practices and reflecting on how the team is performing. For example, you might hold a regular television lunch, where you show a video from SREcon, or a book club, where you all preread some relevant content and then discuss how you can apply it.\n\nDuring this phase, encourage your new SRE team to stretch themselves. Your new SREs should be comfortable speaking out about SRE practices that don’t fit within your organization, and whether it’s worth making the change so they fit.\n\nRisks and mitigations\n\nDuring this nascent phase of the SRE journey, there are a number of ways the team might fail. Next we present some risks and possible mitigation strategies, broken down by how the new team formed. You might use one or more of the mitigation strategies for each risk.\n\nNew team as part of a major project\n\nRisks\n\nThe team:\n\nSpreads itself too thin by taking responsibility for too many services at once.\n\n— A team that is constantly firefighting doesn’t have time to address risk in\n\na more permanent way.\n\nBecomes too introspective trying to understand SRE principles and how to implement them. As a result, it underdelivers.\n\n— For example, the team might become consumed with developing the per‐ fect SLO definition, neglecting the needs of the service in the meantime.\n\nDoesn’t examine its work thoroughly. As a result, service management reverts to previous behaviors.\n\n— The team is paged 100 times a day. Since the pages don’t indicate that\n\nimmediate intervention is required, they ignore the pages.\n\nAbandons SRE principles and practices in order to meet product milestones.\n\n— Reliability improvements to defend the SLO, such as architectural changes, may never be implemented because they set back development timelines.\n\nYour First SRE Team\n\n|\n\n405\n\nGets distracted by conflict with existing teams that perceive a loss of influ‐ ence or power as a result of the new SRE team.\n\nDoes not have the necessary breadth of skills, so delivers only part of the necessary improvements.\n\n— Without the ability to, for example, program, SREs may be unable to\n\ninstrument the product to measure reliability.\n\nMitigations\n\nThe team:\n\nEngages initially on a single important service.\n\nEngages as early as possible on the project, ideally at the design stage.\n\nHas input into the design, with a particular focus on defining SLOs and ana‐ lyzing reliability risks inherent in the design.\n\nPartners with the product development team and works on features specific to reliability and integration with existing operational platforms.\n\nIs not expected to have operational responsibility on day one. Instead, this responsibility initially sits with the product development team or project team. This may be a significant cultural change that needs support from management.\n\nHas clear agreement on the conditions that a service must meet to be onboarded by SRE (see Chapter 32 of Site Reliability Engineering).\n\nIn addition:\n\nIf the project involves a migration, the team should have a solid understand‐ ing of the current and future environments. If you need to recruit team members externally, consider candidates who have knowledge of software engineering and the future environment.\n\nContinue to keep the number of new hires to less than a third of the team so that the training effort doesn’t overwhelm existing team members.\n\nHorizontal SRE team\n\nRisks\n\nThe team is perceived as a new “gating” organization that does no real work or adds no real value.\n\nMitigations\n\nThe team:\n\n406\n\n|\n\nChapter 20: SRE Team Lifecycles\n\nIs seeded with respected engineers who have relevant subject matter expertise.\n\nUndertakes project work that focuses on delivering tools (for monitoring, alerting, rollouts, best practices, checklists). These tools should have a short- term beneficial impact on at least two other teams.\n\nCommunicates successes and benefits. An SRE team that makes an efficiency breakthrough, automates away toil, or permanently eliminates a source of system unreliability should be celebrated.\n\nSees themselves as enablers, not gatekeepers. Focus on solutions, not just problems.\n\nA team converted in place\n\nRisks\n\nThe team:\n\nPerceives that the conversion process is the start of a slow journey to job los‐ ses as automation replaces humans.\n\nDoesn’t support the change to an SRE team.\n\nHas no slack capacity they can leverage to change the team’s day-to-day activities.\n\nSees no benefit to their day-to-day routine after a few months.\n\nWorks with systems that do not support scripting or automation.\n\nDoesn’t have the software engineering skills to automate their current workload.\n\nDoesn’t consistently have the skills needed to evolve toward SRE, or an inter‐ est in acquiring the skills.\n\nMitigations\n\nThe team:\n\nSecures senior leadership support for the change.\n\nRenegotiates responsibilities to create the slack needed to effect change.\n\nManages communication of the change very carefully.\n\nHas access to robust personal and technical support throughout the transition.\n\nDeals with the concern about job losses head on. In a lot of environments, automation eliminates portions of work, but not jobs as a whole; while this might be a step on the path to job losses, it does at least have the virtue of\n\nYour First SRE Team\n\n|\n\n407\n\nfreeing up time to do something better (and more sellable to a future employer) than nonautomated toil.\n\nCan escape operational overload and have more significant impact. If engi‐ neers reduce the volume of toil enough to necessitate a smaller team, then their experience should be highly reusable elsewhere in your organization. If their experience can’t be used internally, it should provide an advantage in seeking work elsewhere.\n\nReceives training to acquire the skills SREs need. Your product development team can provide product training, while SRE orientation can make use of this book and other external resources.\n\nChanges how performance is evaluated—the metrics that assess both the team and individuals. The former should be aligned with SLOs and adoption of other SRE practices; the latter should be aligned with evidence of SRE skills.\n\nAdds an experienced SRE or developer to the team.\n\nHas the freedom (budget or time) to identify and introduce new open source or cloud-based monitoring and alerting systems to enable automation. Determining whether the existing systems are sufficient should be an early priority.\n\nRegularly reviews progress internally and with stakeholders.\n\nNorming Norming entails working past the issues raised in “Risks and mitigations” on page 405 and reaching broad agreement on best practices for the organization’s SRE teams. Teams need to agree on an acceptable level of toil, appropriate alerting thresh‐ olds, and important and relevant SRE practices. Teams also need to become self- sufficient at proactively identifying the challenges ahead of the service and setting medium- and long-term goals to improve the service.\n\nTeams should reach the following levels of maturity during the norming phase:\n\nSLOs and error budgets are in place, and the error budget policy is exercised fol‐ lowing significant incidents. Leadership is interested in SLO measurements.\n\nOn-call rotations are established and sustainable (see Chapter 8). On-call engi‐ neers are compensated for their on-call time. There is sufficient tooling, docu‐ mentation,2 and training to support any team member during a significant incident.\n\n2 Shylaja Nukala and Vivek Rau, “Why SRE Documents Matter,” ACM Queue (May–June 2018): forthcoming.\n\n408\n\n|\n\nChapter 20: SRE Team Lifecycles\n\nToil is documented, bounded, and managed. As a result, SREs complete impact‐ ful projects that improve reliability and efficiency.\n\nPostmortem culture is well established. (See Chapter 10.)\n\nThe team exhibits most of the tenets listed in Chapter 1.\n\nAs the team solves initial issues listed in “Storming” on page 405, they capture what they learned and prevent repeating problems. The team regularly runs training exercises, such as Wheel of Misfortune or DiRT (Disaster Recovery Testing). (For more information on on-call training, see Chapter 11 in our first book and Chapter 18 in this book.)\n\nThe product development team benefits from remaining involved in the on-call rotation.\n\nThe team produces regular reports (e.g., quarterly) for their stakeholders that cover the highlights, lowlights, and key metrics of the reporting period.\n\nTransforming an Existing Team into an SRE Team\n\nby Brian Balser, New York Times\n\nWhen the New York Times formed its Delivery and Site Reliability Engineering department, we assembled SRE teams from engineers who had SRE-type skills, such as building tooling and operating production systems. Some teams were “greenfield”: they were designed with SRE in mind with respect to talent, vision, and responsibility. Other teams had existed for several years, and had ended up running production architecture due to a combination of skill sets, interests, and chance.\n\nChallenges\n\nOne of the existing teams transitioning into SRE was in a very challenging position. Over the years, the team had gained ownership and responsibility for managing con‐ figurations, change requests, and operations of a core component of our site-wide architecture. They effectively became a service team supporting all of our product development teams. Their work was driven by tickets and production issues, and they were in a continuous reactive mode. They didn’t have time to make improvements, innovate, or do other higher-value strategic work.\n\nWhile the team had many great ideas, it was overloaded with toil and a number of high-priority “blocker” service requests that were typically tied to product launches. This model was not sustainable, and the team would need to grow linearly with prod‐ ucts to keep up with this support burden. To exacerbate this situation, the small team had a wealth of institutional knowledge that had accumulated over the years. A high volume of interrupts from teams who needed that information compounded the team’s overload, and a bus factor loomed over the team.\n\nYour First SRE Team\n\n|\n\n409\n\nWorking from First Principles\n\nOne guiding principle of our SRE organization is to remove ourselves from the criti‐ cal path and to empower product development teams with self-service solutions. With that in mind, our goal became clear: invert the responsibility model to enable the product development teams to push their own changes. This strategy would both:\n\nSpeed up delivery.\n\nFree SREs from managing configuration churn, allowing them to make real improvements to the system as a whole.\n\nProcess Improvement\n\nWe improved our processes through several stages of change:\n\n1. We embedded an SRE in the development team to help relieve pressure.\n\n2. To enable product development teams to take ownership of their service config‐ uration in isolation, we broke out each service configuration into a team-based repo.\n\n3. We migrated each service from the legacy CI system to our standard Drone CI/CD pipeline. The developer-friendly workflow was completely driven by GitHub events.\n\n4. We onboarded each of the product teams to the new tooling and workflow so they could submit their own change requests without being blocked by a service ticket.\n\nWhile these improvements were a big step forward, we hadn’t yet reached our ideal end state. Reviewing pull requests still often required SRE expertise. To make inter‐ rupts for time-consuming reviews more manageable, we scheduled daily office hours. This consistent practice allowed us to batch questions and discussions in a more pre‐ dictive manner, and also provided a venue for sharing knowledge with teams under‐ going onboarding.\n\nEnd Result and Next Steps\n\nThe SRE team is now meeting its initial goal of > 50% project work (versus support- related work). The team still has a wealth of institutional knowledge, but that knowl‐ edge is now being propagated more broadly, gradually improving the bus factor and reducing interrupts.\n\nNow that we have breathing room for project work, our next steps are to focus on adding more advanced capabilities such as canary deploys, better test tooling, and observability and resilience features. Doing so will give product development teams more confidence in exercising full autonomy over their service configurations without depending on SREs for change management.\n\n410\n\n|\n\nChapter 20: SRE Team Lifecycles\n\nEstablishing a healthy relationship with your product development team forms the basis of many of these mitigation strategies. Teams should plan work together per your organization’s planning cycle.\n\nBefore moving on to the next step: pause, celebrate this success, and write a retro‐ spective that covers your journey so far.\n\nPerforming The SRE team’s experience with production and work up to this point should have earned the respect and attention of the wider organization, and laid the foundation for strategically moving forward. In the final stage of Tuckman’s performance model, performing, you should expect to:\n\nPartner on all architecture design and change.\n\nFrom the initial design phase onward, SRE should define the patterns for how software is built and structured for reliability.\n\nHave complete workload self-determination.\n\nTeams should consistently apply Principle 3 with a view toward the holistic health of the system.\n\nPartnering on architecture\n\nThe product development team should start to reach out to its partner SRE team for advice on all significant service changes. The SRE team now has the opportunity to have some of its greatest impact.\n\nFor example, the SRE team might provide early input into the design of new service architecture to reduce the likelihood of high-cost reengineering at a later date. The product development and SRE teams can acknowledge their differences in perspec‐ tive on architectural decisions to arrive at a good design process. A successful engage‐ ment can add value through:\n\nImproved reliability, scalability, and operability\n\nBetter reuse of existing patterns\n\nSimpler migration (if required)\n\nSelf-regulating workload\n\nWhereas architectural partnerships should emerge somewhat organically over time, an SRE team must clearly assert Principle #3 to its partners. Doing so requires strong team leadership and clear, upfront commitment from senior management. The abil‐ ity to regulate its own workload secures the SRE team’s position as an engineering\n\nYour First SRE Team\n\n|\n\n411\n\nteam that works on the organization’s most important services, equal to its product development team peers.\n\nIn practice, how an SRE team goes about determining its own workload depends on the teams with which SREs interface. At Google, SRE teams most commonly interact with a distinct product development team. In this case, the relationship has the fol‐ lowing characteristics:\n\nAn SRE team chooses if and when to onboard a service (see Chapter 32 of Site Reliability Engineering).\n\nIn the event of operational overload, the team can reduce toil by:\n\n— Reducing the SLO\n\n— Transferring operational work to another team (e.g., a product development\n\nteam)\n\nIf it becomes impossible to operate a service at SLO within agreed toil con‐ straints, the SRE team can hand back the service to the product development team.\n\nSRE engagement is not perpetual—it feeds itself by solving problems at scale and improving the reliability of services. If an SRE team has solved all such problems for a service, you need to either: — Intentionally consider what other reliability challenges the SRE team needs to\n\ntackle.\n\n— Make an intentional decision to hand back the service to the product develop‐\n\nment team.\n\nOtherwise, your team risks attrition as SREs move on to more interesting oppor‐ tunities. The slow bleed from attrition can put production at risk.\n\nNot all SRE teams have partner product development teams. Some SRE teams are also responsible for developing the systems they run. Some SRE teams package third- party software, hardware, or services (e.g., open source packages, network equip‐ ment, something-as-a-service), and turn those assets into internal services. In this case, you don’t have the option to transfer work back to another team. Instead, con‐ sider the following tactics:\n\nIf the service does not conform to its SLO, stop feature-related project work in favor of reliability-focused project work.\n\nIf it becomes impossible to operate a service at SLO within agreed toil con‐ straints, reduce your SLOs—unless management provides more capacity (people or infrastructure) to deal with the situation.\n\n412\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "page_number": 420
    },
    {
      "number": 47,
      "title": "Segment 47 (pages 429-438)",
      "start_page": 429,
      "end_page": 438,
      "detection_method": "topic_boundary",
      "content": "Making More SRE Teams Once your first SRE team is up and running, you may want to form an additional SRE team. You might do so for one of the following reasons:\n\nService complexity\n\nAs a service gains users and features, it becomes more complex and harder for a single SRE team to support effectively. You might want to split the team into subteams that specialize in parts of the service.\n\nSRE rollout\n\nIf your first SRE team has been successful and made a clear difference, there may be an organizational interest in adopting this approach across more services.\n\nGeographically split\n\nYou want to split the team into two halves in different time zones and move to 12-hour on-call shifts.\n\nWhen you’re creating a new SRE team, we recommend that you do the following:\n\nRead any postmortems written after other teams were established. Identify and repeat what went well and fix and explore alternatives for things that didn’t go well.\n\nSeed the new team with SREs from the existing team—some of your best SREs and highest-potential SREs who can rise to the challenge. In our experience, finding qualified SRE candidates is difficult, so growing a team quickly with new hires often isn’t realistic.\n\nStandardize the framework for establishing teams and onboarding services (see Chapter 18).\n\nMake changes to the on-call responsibilities slowly. For example:\n\n— To avoid a sudden loss of skilled on-call engineers, keep team members on-\n\ncall for their previous team’s systems for a transitional period.\n\n— After the teams split, wait three to six months to split the on-call rotations.\n\nService Complexity\n\nWhere to split\n\nIf a service becomes too complex for a single team to manage, there are a number of ways to split the work. Consider the following options to simplify the cognitive load on team members:\n\nMaking More SRE Teams\n\n|\n\n413\n\nArchitectural splits\n\nFor example, compute, storage, and network; frontend and backend; frontend and database; client and server; frontend and pipelines.\n\nLanguage splits\n\nSRE principles are not dependent on programming languages. However, if your SREs are deeply involved in your source code, there may be some benefit in a split along these lines.\n\nLocation splits\n\nIf your organization’s engineering spans multiple offices, you might want to align SRE team placement with application development.\n\nPitfalls\n\nWhen a team splits, sometimes none of the new teams pick up responsibility for a component owned by the original team. To mitigate this risk, you can:\n\nDesignate one team as responsible for everything not covered in the second team’s charter.\n\nAppoint a senior SRE to an overarching technical lead role across both teams.\n\nSRE Rollout If your initial SRE team(s) are successful, your organization may want more of them. We recommend carefully prioritizing the services that receive SRE support. Consider the following points:\n\nPrioritize services for which reliability has a high financial or reputational impact. The higher the impact, the higher the priority.\n\nDefine the minimal viable set of services that need to be up in order for the prod‐ uct to function. Prioritize those services and make sure that other services degrade gracefully.\n\nA service should not be a priority for SRE simply because it’s unreliable. SRE should be applied tactically where it is most relevant for the business. You also don’t want to allow your developers to ignore reliability until after SREs are engaged.\n\nGeographical Splits As described in Chapter 11 of our first book, Google commonly staffs sister SRE teams on different continents. We do this for a number of reasons:\n\n414\n\n|\n\nChapter 20: SRE Team Lifecycles\n\nService reliability\n\nIf a major incident (e.g., natural disaster) prevents one team from operating, the other team can continue to support a service.\n\nOn-call stress\n\nSplitting the pager rotation into 12-hour shifts allows proper breaks for on-call engineers.\n\nRecruiting and retaining talent\n\nAn on-call shift that overlaps the normal working day broadens the base of engi‐ neers that we can recruit into SRE roles, and underlines the engineering part of our role.\n\nProduction maturity\n\nSplitting service responsibility across two offices tends to lead to an improvement in maturity as the need for documentation, training, and standardization become more important.\n\nIf your organization is lucky enough to already have engineering teams on multiple continents, we recommend staffing multisite SRE teams. It’s possible to have an SRE team in a different office than the development team, but in our experience, coloca‐ tion provides benefits in the form of a healthy and robust interteam dialog. Other‐ wise, it’s harder for SREs to understand how the services evolve or how the technical infrastructure is used, and it’s harder for product developers to be optimistic about infrastructure improvements.\n\nPlacement: How many time zones apart should the teams be?\n\nAssuming you have some choice, time zone separation is an important consideration in deciding where to locate the two teams. Unfortunately, the objectives are mutually exclusive:\n\nMinimizing the number of hours that on-callers have to work outside of normal office hours\n\nMaximizing the overlap time when both teams are online so that they can inter‐ act with each other regularly\n\nThe situation is complicated by Daylight Saving Time.\n\nIn our experience, staffing teams in time zones that are six to eight hours apart works well and avoids 12 a.m. to 6 a.m. on-call shifts. You can use online resources like https://www.timeanddate.com/worldclock/meeting.html to visualize time zone over‐ laps for various locations.\n\nMaking More SRE Teams\n\n|\n\n415\n\nPeople and projects: Seeding the team\n\nWhen you split a team geographically, the first SRE team in a new office will set the norms for future SRE teams. Your likelihood of success will be much higher if you can identify one or more SREs who are willing to relocate from the original site on a temporary or long-term basis to establish SRE practices and recruit and train the new team. The new team should also undertake a high-value project that fosters collabo‐ ration within the team and requires interaction with their sister team.\n\nParity: Distributing Work Between Offices and Avoiding a “Night Shift”\n\nOften, one of two sister SRE teams is colocated (or at least in the same time zone) with the product development team (we’ll call this “Office 1”). If this is the case, be vigilant to ensure that the team that is not colocated (“Office 2”) doesn’t become a night shift that has little contact with the product development team, takes more than its fair share of toil, or is assigned only the less interesting or impactful projects.\n\nThe workloads of the two offices will have some natural differences:\n\nYour service likely has a daily peak, and one office will be on-call during that peak. As a result, the on-call experience of the two sites will differ.\n\nYour development process will produce new releases with a particular cadence. One office will likely take more of the burden associated with rollouts and rollbacks.\n\nOffice 1 is more likely to be interrupted during their working day by questions from the product development team.\n\nIt’s easier for Office 1 to undertake project work associated with major releases. Conversely, it’s easier for Office 2 to undertake project work decoupled from immediate product goals.\n\nYou can help maintain balance by using the following practices:\n\nBalance the on-call load between offices. Designate a higher percentage of tickets to the office that fields the lower percentage of pages.\n\nAssociate development areas with SRE teams in a particular office. This could be short term (e.g., according to project) or longer term (e.g., according to service). Otherwise, the product development team will likely lean on Office 1, and not effectively engage with SREs in Office 2.\n\nAssign a higher percentage of internal service improvement projects (that are likely to require less involvement with the product development team) to Office 2.\n\nSpread the most interesting and impactful projects fairly between the two offices.\n\nMaintain a similar team size and seniority mix between the two offices.\n\n416\n\n|\n\nChapter 20: SRE Team Lifecycles\n\nSplit projects across the two sites to deliberately foster interoffice interactions between SREs. While running a major project from a single office might gain some efficiencies, splitting projects across the two sites both helps spread knowl‐ edge and builds trust between offices.\n\nAllow engineers to travel to the other office regularly. This enables creating bet‐ ter rapport and, hence, willingness to do work for the other side.\n\nPlacement: What about having three shifts?\n\nOur attempts at splitting SRE teams across three sites resulted in various issues:\n\nIt is impossible to have an interoffice production meeting that all SREs can attend (see Chapter 31 of our first book).\n\nIt is harder to ensure parity of knowledge, capability, and operational response across three offices.\n\nIf all on-call duties take place only during office hours, there’s less of an incentive to automate low-level toil and low-value pages. Being the hero that fixes easy problems is fun during office hours. But if it has some amount of personal cost, the motivation to make sure it never happens again is sharp and immediate.\n\nTiming: Should both halves of the team start at the same time?\n\nYou might spin up sister teams using any of the following models:\n\nBoth halves start at the same time.\n\nSet up the site that is colocated with the product development team first. This allows SREs to get involved earlier in the product lifecycle.\n\nSet up the site that is not colocated with the product development team first or, if a service has been in production for some time, the SRE team and the product development team can share the pager.\n\nStart making changes according to where the right people are at the right time.\n\nFinance: Travel budget\n\nIt is very important to create opportunities for high-quality interactions between the two halves of the team. Despite the effectiveness of video conferencing for day-to-day meetings, we’ve found that regular face-to-face interactions go a long way toward facilitating healthy relationships and trust. We recommend that:\n\nEvery SRE, product development manager, and technical lead in Site 1 visit Site 2 annually (at a minimum), and vice versa.\n\nMaking More SRE Teams\n\n|\n\n417\n\nEvery SRE in a management or technical leadership role at Site 1 visit Site 2 at least twice a year, and vice versa.\n\nAll SREs convene at least once a year.\n\nLeadership: Joint ownership of a service\n\nIf you have multiple SRE sites, you likely have decision makers in each office. These parties should meet regularly face-to-face and by video conference. Only by establish‐ ing a strong personal relationship can they:\n\nDebate solutions to challenges that the team faces.\n\nResolve differences of opinion and agree on a joint path forward.\n\nAdvocate on behalf of each other’s team (to prevent an “us versus them” mentality).\n\nSupport the health of each other’s team.\n\nSuggested Practices for Running Many Teams New challenges arise as your organization accumulates more SREs and SRE teams. For example, you’ll have to:\n\nEnsure you provide SREs with the career opportunities they need.\n\nEncourage consistency of practices and tooling.\n\nDeal with services that don’t justify a full SRE engagement.\n\nThis section describes a number of the practices that we have adopted at Google to deal with these concerns. Depending on the specifics of your organization, some or many may work for you too.\n\nMission Control Google’s Mission Control program gives engineers from product development teams the opportunity to spend six months embedded in an SRE team. We typically match these engineers to SRE teams working in a distinctly different area from their exper‐ tise. The software engineer is trained in production systems and practices and even‐ tually goes on-call for that service. After six months, some engineers decide to stay in SRE; others return to their old teams with a much better appreciation for the produc‐ tion environment and SRE practices. SRE teams benefit from additional engineering resources and gain valuable insight into gaps and inaccuracies in training material and documentation.\n\n418\n\n|\n\nChapter 20: SRE Team Lifecycles\n\nSRE Exchange Google’s SRE Exchange program lets an SRE spend a week working alongside a dif‐ ferent SRE team. The visiting SRE observes how the host team works and shares practices from their home team that might be useful to the host team. At the end of the exchange, the visiting SRE writes a trip report describing their week, their obser‐ vations, and their recommendations for both teams. This program is useful at Google because our SRE teams are highly specialized.\n\nTraining Training is critical to SRE’s ability to operate systems. While most of this is delivered in-team (see “Training roadmap” on page 150 in Chapter 8), consider establishing a standard training curriculum for all SREs. At Google, all new SREs attend SRE EDU, an immersive weeklong training that introduces key concepts, tooling, and platforms that almost all SREs work with. This provides a baseline level of knowledge across all new SREs, and simplifies team-specific and service-specific training objectives. The SRE EDU team also runs a second series of classes a few months later that covers the common tools and processes that we use for managing major incidents. Our perfor‐ mance management process specifically recognizes SREs who facilitate this training.\n\nHorizontal Projects Because SRE teams are tightly aligned with a set of services, there is a temptation for teams to build proprietary solutions to deal with the challenges they encounter—for example, monitoring, software rollout, and configuration tools. This can lead to sig‐ nificant duplication of efforts across teams. While there is value in allowing a number of solutions to compete for “market” adoption, at some point, it makes sense to con‐ verge upon a standard solution that:\n\nMeets most teams’ requirements\n\nProvides a stable and scalable platform upon which the next layer of innovation can be built\n\nGoogle approaches these efforts by using horizontal teams, which are often staffed by experienced SREs. These horizontal teams build and run a standard solution and partner with other SRE teams to ensure smooth adoption. (For more information on horizontal software development, see “Case Study 2: Common Tooling Adoption in SRE” on page 432 in Chapter 21.)\n\nSRE Mobility Google does its best to ensure that engineers actively want to be part of their respec‐ tive teams. To this end, we make sure that SREs are able to (and aware that they’re\n\nSuggested Practices for Running Many Teams\n\n|\n\n419\n\nable to) transfer between teams. Assuming there are no performance issues, SREs are free to transfer to other SRE teams with open headcount. SREs who also passed our hiring bar for software engineer roles are free to transfer to product development teams (see http://bit.ly/2xyQ4aD).\n\nThis level of mobility is very healthy for individuals and teams for a number of reasons:\n\nEngineers are able to identify and occupy roles of interest.\n\nIf personal circumstances change and on-call responsibilities become impracti‐ cal, SREs can explore opportunities on teams with less demanding on-call duties. They can obtain this information by talking to other teams and reviewing team on-call stats.\n\nSREs who move between teams broaden the experience of the teams they join.\n\nSREs who move between offices help build or maintain cultural consistency between different offices.\n\nSREs are not compelled to work on services that are unhealthy, or for managers who aren’t supportive of their personal development.\n\nThis policy also has the side effect of keeping your SRE managers focused on healthy and happy services and teams.\n\nTravel In addition to the travel required to keep geographically split teams healthy (see the section “Finance: Travel budget” on page 417), consider funding for:\n\nBuilding internal company communities of interest that include SREs from a number of offices. Such groups can largely collaborate via email and video con‐ ferencing, but meet face-to-face at least annually.\n\nAttending and presenting at industry-wide SRE and SRE-related conferences to broaden knowledge, learn how other organizations tackle similar problems, and, hopefully, be inspired and energized.\n\nLaunch Coordination Engineering Teams As described in Chapter 27 of our first book, a Launch Coordination Engineering (LCE) team can apply SRE principles to a broader set of product development teams —teams that build services that don’t require the level of attention that merits SRE engagement. Just like any other SRE team, an LCE team should be actively engaged in automating its daily operations. For example, developing standard tooling and\n\n420\n\n|\n\nChapter 20: SRE Team Lifecycles\n\nframeworks enable product development teams to design, build, and launch their ser‐ vice in a production environment.\n\nProduction Excellence As the number of SRE teams at your organization grows, a number of best practices will emerge. Every SRE team evolves differently, so evaluating them requires senior SREs with insight into multiple teams.\n\nAt Google, we run a regular service review called Production Excellence. On a regular basis, senior SRE leaders review every SRE team, assessing them on a number of stan‐ dard measures (e.g., pager load, error budget usage, project completion, bug closure rates). The review both applauds outstanding performance and provides suggestions for underperforming teams.\n\nExperienced SREs are equipped to evaluate nuanced scenarios. For example, it can be challenging to tease out a drop in project completion rate caused by a team merger or split versus genuine team performance issues. If a team is at risk of becoming over‐ whelmed, the reviewers can and should to use their organizational position to sup‐ port the team’s leadership in rectifying the situation.\n\nSRE Funding and Hiring At Google, we use two practices to make sure that every SRE contributes significant value:\n\nMuch of SRE funding comes from the same source as product development team funding. Similar to testing or security, reliability is a core pillar of product devel‐ opment, and is funded as such.\n\nIn our experience, the supply of SREs is always smaller than the demand for them. This dynamic ensures that we regularly review and prioritize the services that receive SRE support.\n\nIn short, you should have fewer SREs than the organization would like, and only enough SREs to accomplish their specialized work.\n\nAt Google, the ratio of SREs to engineers on product development teams ranges from around 1:5 (e.g., low-level infrastructure services) to around 1:50 (e.g., consumer- facing applications with a large number of microservices built using standard frame‐ works). Many services fall in the middle of this range, at a ratio of around 1:10.\n\nConclusion We believe an organization of any size can implement SRE practices by applying the following three principles:\n\nConclusion\n\n|\n\n421\n\nSRE needs SLOs with consequences.\n\nSREs must have time to make tomorrow better than today.\n\nSRE teams have the ability to regulate their workload.\n\nSince Google started talking publicly about SRE, it has grown from Google-specific production practices into a profession practiced in many companies. These principles have often proven true—both over our years of direct experience at scale, and during our more recent experience of working with our customers to adopt SRE practices. Because we’ve seen these practices work both within and outside of Google, we feel these recommendations should prove useful across a range of organizations of differ‐ ent types and sizes.\n\n422\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "page_number": 429
    },
    {
      "number": 48,
      "title": "Segment 48 (pages 439-446)",
      "start_page": 439,
      "end_page": 446,
      "detection_method": "topic_boundary",
      "content": "CHAPTER 21 Organizational Change Management in SRE\n\nBy Alex Bramley, Ben Lutch, Michelle Duffy, and Nir Tarcic with Betsy Beyer\n\nIn the introduction to the first SRE Book, Ben Treynor Sloss describes SRE teams as “characterized by both rapid innovation and a large acceptance of change,” and speci‐ fies organizational change management as a core responsibility of an SRE team. This chapter examines how theory can apply in practice across SRE teams. After reviewing some key change management theories, we explore two case studies that demonstrate how different styles of change management have played out in concrete ways at Goo‐ gle.\n\nNote that the term change management has two interpretations: organizational change management and change control. This chapter examines change management as a collective term for all approaches to preparing and supporting individuals, teams, and business units in making organizational change. We do not discuss this term within a project management context, where it may be used to refer to change control processes, such as change review or versioning.\n\nSRE Embraces Change More than 2,000 years ago, the Greek philosopher Heraclitus claimed change is the only constant. This axiom still holds true today—especially in regards to technology, and particularly in rapidly evolving internet and cloud sectors.\n\nProduct teams exist to build products, ship features, and delight customers. At Goo‐ gle, most change is fast-paced, following a “launch and iterate” approach. Executing on such change typically requires coordination across systems, products, and globally distributed teams. Site Reliability Engineers are frequently in the middle of this com‐ plicated and rapidly shifting landscape, responsible for balancing the risks inherent in\n\n423\n\nchange with product reliability and availability. Error budgets (see Chapter 2) are a primary mechanism for achieving this balance.\n\nIntroduction to Change Management Change management as an area of study and practice has grown since foundational work in the field by Kurt Lewin in the 1940s. Theories primarily focus on developing frameworks for managing organizational change. In-depth analysis of particular the‐ ories is beyond the scope of this book, but to contextualize them within the realm of SRE, we briefly describe some common theories and how each might be applicable in an SRE-type organization. While the formal processes implicit in these theoretical frameworks have not been applied by SRE at Google, considering SRE activities through the lens of these frameworks has helped us refine our approach to managing change. Following this discussion, we will introduce some case studies that demon‐ strate how elements of some of these theories apply to change management activities led by Google SRE.\n\nLewin’s Three-Stage Model Kurt Lewin’s “unfreeze–change–freeze” model for managing change is the oldest of the relevant theories in this field. This simple three-stage model is a tool for manag‐ ing process review and the resulting changes in group dynamics. Stage 1 entails per‐ suading a group that change is necessary. Once they are amenable to the idea of change, Stage 2 executes that change. Finally, when the change is broadly complete, Stage 3 institutionalizes the new patterns of behavior and thought. The model’s core principle posits the group as the primary dynamic instrument, arguing that individ‐ ual and group interactions should be examined as a system when the group is plan‐ ning, executing, and completing any period of change. Accordingly, Lewin’s work is most useful for planning organizational change at the macro level.\n\nMcKinsey’s 7-S Model McKinsey’s seven S’s stand for structure, strategy, systems, skills, style, staff, and shared values. Similar to Lewin’s work, this framework is also a toolset for planned organizational change. While Lewin’s framework is generic, 7-S has an explicit goal of improving organizational effectiveness. Application of both theories begins with an analysis of current purpose and processes. However, 7-S also explicitly covers both business elements (structure, strategy, systems) and people-management elements (shared values, skills, style, staff). This model could be useful for a team considering change from a traditional systems administration focus to the more holistic Site Reli‐ ability Engineering approach.\n\n424\n\n|\n\nChapter 21: Organizational Change Management in SRE\n\nKotter’s Eight-Step Process for Leading Change Time magazine named John P. Kotter’s 1996 book Leading Change (Harvard Busi‐ ness School Press) one of the Top 25 Most Influential Business Management Books of all time. Figure 21-1 depicts the eight steps in Kotter’s change management process.\n\nFigure 21-1. Kotter’s model of change management (source: https://www.kotterinc.com/ 8-steps-process-for-leading-change/)\n\nKotter’s process is particularly relevant to SRE teams and organizations, with one small exception: in many cases (e.g., the upcoming Waze case study), there’s no need to create a sense of urgency. SRE teams supporting products and systems with accel‐ erating growth are frequently faced with urgent scaling, reliability, and operational challenges. The component systems are often owned by multiple development teams, which may span several organizational units; scaling issues may also require coordi‐ nation with teams ranging from physical infrastructure to product management. Because SRE is often on the front line when problems occur, it is uniquely motivated to lead the change needed to ensure products are available 24/7/365. Much of SRE work (implicitly) embraces Kotter’s process to ensure the continued availability of supported products.\n\nThe Prosci ADKAR Model The Prosci ADKAR model focuses on balancing both the business and people aspects of change management. ADKAR is an acronym for the goals individuals must ach‐\n\nIntroduction to Change Management\n\n|\n\n425\n\nieve for successful organizational change: awareness, desire, knowledge, ability, and reinforcement.\n\nIn principle, ADKAR provides a useful, thoughtful, people-centric framework. How‐ ever, its applicability to SRE is limited because operational responsibilities quite often impose considerable time constraints. Proceeding iteratively through ADKAR’s stages and providing the necessary training or coaching requires pacing and invest‐ ment in communication, which are difficult to implement in the context of globally distributed, operationally focused teams. That said, Google has successfully used ADKAR-style processes for introducing and building support for high-level changes —for example, introducing global organizational change to the SRE management team while preserving local autonomy for implementation details.\n\nEmotion-Based Models The Bridges Transition Model describes people’s emotional reactions to change. While a useful management tool for people managers, it’s not a framework or process for change management. Similarly, the Kübler-Ross Change Curve describes ranges of emotions people may feel when faced with change. Developed from Elisabeth Kübler-Ross’s research on death and dying,1 it has been applied to understanding and anticipating employee reactions to organizational change. Both models can be useful in maintaining high employee productivity throughout periods of change, since unhappy people are rarely productive.\n\nThe Deming Cycle Also known as the Plan-Do-Check-Act (or PDCA) Cycle, this process from statisti‐ cian Edward W. Deming is commonly used in DevOps environments for process improvements—for example, adoption of continuous integration/continuous deliv‐ ery techniques. It is not suited to organizational change management because it does not cover the human side of change, including motivations and leadership styles. Deming’s focus is to take existing processes (mechanical, automated, or workflow) and cyclically apply continuous improvements. The case studies we refer to in this chapter deal with larger, organizational changes where iteration is counterproductive: frequent, wrenching org-chart changes can sap employee confidence and negatively impact company culture.\n\n1 Elisabeth Kübler-Ross, On Death and Dying: What the Dying Have to Teach Doctors, Nurses, Clergy and Their\n\nOwn Families (New York: Scribner, 1969).\n\n426\n\n|\n\nChapter 21: Organizational Change Management in SRE\n\nHow These Theories Apply to SRE No change management model is universally applicable to every situation, so it’s not surprising that Google SRE hasn’t exclusively standardized on one model. That said, here’s how we like to think about applying these models to common change manage‐ ment scenarios in SRE:\n\nKotter’s Eight-Step Process is a change management model for SRE teams who necessarily embrace change as a core responsibility.\n\nThe Prosci ADKAR model is a framework that SRE management may want to consider to coordinate change across globally distributed teams.\n\nAll individual SRE managers will benefit from familiarity with both the Bridges Transition Model and the Kübler-Ross Change Curve, which provide tools to sup‐ port employees in times of organizational change.\n\nNow that we’ve introduced the theories, let’s look at two case studies that show how change management has played out at Google.\n\nCase Study 1: Scaling Waze—From Ad Hoc to Planned Change\n\nBackground Waze is a community-based navigation app acquired by Google in 2013. After the acquisition, Waze entered a period of significant growth in active users, engineering staff, and computing infrastructure, but continued to operate relatively autono‐ mously within Google. The growth introduced many challenges, both technical and organizational.\n\nWaze’s autonomy and startup ethos led them to meet these challenges with a grass‐ roots technical response from small groups of engineers, rather than management- led, structured organizational change as implied by the formal models discussed in the previous section. Nevertheless, their approach to propagating changes through‐ out the organization and infrastructure significantly resembles Kotter’s model of change management. This case study examines how Kotter’s process (which we apply retroactively) aptly describes a sequence of technical and organizational challenges Waze faced as they grew post-acquisition.\n\nThe Messaging Queue: Replacing a System While Maintaining Reliability Kotter’s model begins the cycle of change with a sense of urgency. Waze’s SRE team needed to act quickly and decisively when the reliability of Waze’s message queueing\n\nCase Study 1: Scaling Waze—From Ad Hoc to Planned Change\n\n|\n\n427\n\nsystem regressed badly, leading to increasingly frequent and severe outages. As shown in Figure 21-2, the message queueing system was critical to operations because every component of Waze (real time, geocoding, routing, etc.) used it to communi‐ cate with other components internally.\n\nFigure 21-2. Communication paths between Waze components\n\nAs throughput on the message queue grew significantly, the system simply couldn’t cope with the ever-increasing demands. SREs needed to manually intervene to pre‐ serve system stability at shorter and shorter intervals. At its worst, the entire Waze SRE team spent most of a two-week period firefighting 24/7, eventually resorting to restarting some components of the message queue hourly to keep messages flowing and tens of millions of users happy.\n\nBecause SRE was also responsible for building and releasing all of Waze’s software, this operational load had a noticeable impact on feature velocity—when SREs spent all of their time fighting fires, they hardly had time to support new feature rollouts. By highlighting the severity of the situation, engineers convinced Waze’s leadership to reevaluate priorities and dedicate some engineering time to reliability work. A guiding coalition of two SREs and a senior engineer came together to form a strategic vision of a future where SRE toil was no longer necessary to keep messages flowing. This small team evaluated off-the-shelf message queue products, but quickly decided that they could only meet Waze’s scaling and reliability requirements with a custom- built solution.\n\n428\n\n|\n\nChapter 21: Organizational Change Management in SRE\n\nDeveloping this message queue in-house would be impossible without some way to maintain operations in the meantime. The coalition removed this barrier to action by enlisting a volunteer army of developers from the teams who used the current mes‐ saging queue. Each team reviewed the codebase for their service to identify ways to cut the volume of messages they published. Trimming unnecessary messages and rolling out a compression layer on top of the old queue reduced some load on the system. The team also gained some more operational breathing room by building a dedicated messaging queue for one particular component that was responsible for over 30% of system traffic. These measures yielded enough of a temporary opera‐ tional reprieve to allow for a two-month window to assemble and test a prototype of the new messaging system.\n\nMigrating a message queue system that handles tens of thousands of messages per second is a daunting task even without the pressure of imminent service meltdown. But gradually reducing the load on the old system would relieve some of this pres‐ sure, affording the team a longer time window to complete the migration. To this end, Waze SRE rebuilt the client libraries for the message queue so they could publish and receive messages using either or both systems, using a centralized control surface to switch the traffic over.\n\nOnce the new system was proven to work, SRE began the first phase of the migration: they identified some low-traffic, high-importance message flows for which messaging outages were catastrophic. For these flows, writing to both messaging systems would provide a backup path. A couple of near misses, where the backup path kept core Waze services operating while the old system faltered, provided the short-term wins that justified the initial investment.\n\nMass migration to the new system required SRE to work closely with the teams who use it. The team needed to figure out both how to best support their use cases and how to coordinate the traffic switch. As the SRE team automated the process of migrating traffic and the new system supported more use cases by default, the rate of migrations accelerated significantly.\n\nKotter’s change management process ends with instituting change. Eventually, with enough momentum behind the adoption of the new system, the SRE team could declare the old system deprecated and no longer supported. They migrated the last stragglers a few quarters later. Today, the new system handles more than 1000 times the load of the previous one, and requires little manual intervention from SREs for ongoing support and maintenance.\n\nThe Next Cycle of Change: Improving the Deployment Process The process of change as a cycle was one of Kotter’s key insights. The cyclical nature of meaningful change is particularly apparent when it comes to the types of technical changes that face SRE. Eliminating one bottleneck in a system often highlights\n\nCase Study 1: Scaling Waze—From Ad Hoc to Planned Change\n\n|\n\n429\n\nanother one. As each change cycle is completed, the resulting improvements, stand‐ ardization, and automation free up engineering time. Engineering teams now have the space to more closely examine their systems and identify more pain points, trig‐ gering the next cycle of change.\n\nWhen Waze SRE could finally take a step back from firefighting problems related to the messaging system, a new bottleneck emerged, bringing with it a renewed sense of urgency: SRE’s sole ownership of releases was noticeably and seriously hindering development velocity. The manual nature of releases required a significant amount of SRE time. To exacerbate an already suboptimal situation, system components were large, and because releases were costly, they were relatively infrequent. As a result, each release represented a large delta, significantly increasing the possibility that a major defect would necessitate a rollback.\n\nImprovements toward a better release process happened incrementally, as Waze SRE didn’t have a master plan from square one. To slim down system components so the team could iterate each more rapidly, one of the senior Waze developers created a framework for building microservices. This provided a standard “batteries included” platform that made it easy for the engineering organization to start breaking their components apart. SRE worked with this developer to include some reliability- focused features—for example, a common control surface and a set of behaviors that were amenable to automation. As a result, SRE could develop a suite of tools to man‐ age the previously costly parts of the release process. One of these tools incentivized adoption by bundling all of the steps needed to create a new microservice with the framework.\n\nThese tools were quick-and-dirty at first—the initial prototypes were built by one SRE over the course of several days. As the team cleaved more microservices from their parent components, the value of the SRE-developed tools quickly became appa‐ rent to the wider organization. SRE was spending less time shepherding the slimmed- down components into production, and the new microservices were much less costly to release individually.\n\nWhile the release process was already much improved, the proliferation of new microservices meant that SRE’s overall burden was still concerning. Engineering leadership was unwilling to assume responsibility for the release process until releases were less burdensome.\n\nIn response, a small coalition of SREs and developers sketched out a strategic vision to shift to a continuous deployment strategy using Spinnaker, an open source, multi‐ cloud, continuous delivery platform for building and executing deployment work‐ flows. With the time saved by our bootstrap tooling, the team now was able to engineer this new system to enable one-click builds and deployments of hundreds or thousands of microservices. The new system was technically superior to the previous system in every way, but SRE still couldn’t persuade development teams to make the\n\n430\n\n|\n\nChapter 21: Organizational Change Management in SRE",
      "page_number": 439
    },
    {
      "number": 49,
      "title": "Segment 49 (pages 447-454)",
      "start_page": 447,
      "end_page": 454,
      "detection_method": "topic_boundary",
      "content": "switch. This reluctance was driven by two factors: the obvious disincentive of having to push their own releases to production, plus change aversion driven by poor visibil‐ ity into the release process.\n\nWaze SRE tore down these barriers to adoption by showing how the new process added value. The team built a centralized dashboard that displayed the release status of binaries and a number of standard metrics exported by the microservice frame‐ work. Development teams could easily link their releases to changes in those metrics, which gave them confidence that deployments were successful. SRE worked closely with a few volunteer systems-oriented development teams to move services to Spin‐ naker. These wins proved that the new system could not only fulfill its requirements, but also add value beyond the original release process. At this point, engineering leadership set a goal for all teams to perform releases using the new Spinnaker deployment pipelines.\n\nTo facilitate the migration, Waze SRE provided organization-wide Spinnaker training sessions and consulting sessions for teams with complex requirements. When early adopters became familiar with the new system, their positive experiences sparked a chain reaction of accelerating adoption. They found the new process faster and less painful than waiting for SRE to push their releases. Now, engineers began to put pres‐ sure on dependencies that had not moved, as they were the impediment to faster development velocity—not the SRE team!\n\nToday, more than 95% of Waze’s services use Spinnaker for continuous deployment, and changes can be pushed to production with very little human involvement. While Spinnaker isn’t a one-size-fits-all solution, configuring a release pipeline is trivial if a new service is built using the microservices framework, so new services have a strong incentive to standardize on this solution.\n\nLessons Learned Waze’s experience in removing bottlenecks to technical change contains a number of useful lessons for other teams attempting engineering-led technical or organizational change. To begin with, change management theory is not a waste of time! Viewing this development and migration process through the lens of Kotter’s process demon‐ strates the model’s applicability. A more formal application of Kotter’s model at the time could have helped streamline and guide the process of change.\n\nChange instigated from the grass roots requires close collaboration between SRE and development, as well as support from executive leadership. Creating a small, focused group with members from all parts of the organization—SRE, developers, and man‐ agement—was key to the team’s success. A similar collaboration was vital to institut‐ ing the change. Over time, these ad hoc groups can and should evolve into more formal and structured cooperation, where SREs are automatically involved in design\n\nCase Study 1: Scaling Waze—From Ad Hoc to Planned Change\n\n|\n\n431\n\ndiscussions and can advise on best practices for building and deploying robust appli‐ cations in a production environment throughout the entire product lifecycle.\n\nIncremental change is much easier to manage. Jumping straight to the “perfect” solu‐ tion is too large a step to take all at once (not to mention probably infeasible if your system is about to collapse), and the concept of “perfect” will likely evolve as new information comes to light during the change process. An iterative approach can demonstrate early wins that help an organization buy into the vision of change and justify further investment. On the other hand, if early iterations don’t demonstrate value, you’ll waste less time and fewer resources when you inevitably abandon the change. Because incremental change doesn’t happen all at once, having a master plan is invaluable. Describe the goals in broad terms, be flexible, and ensure that each iter‐ ation moves toward them.\n\nFinally, sometimes your current solutions can’t support the requirements of your strategic vision. Building something new has a large engineering cost, but can be worthwhile if the project pushes you out of a local maxima and enables long-term growth. As a thought experiment, figure out where bottlenecks might arise in your systems and tooling as your business and organization grow over the next few years. If you suspect any elements don’t scale horizontally, or have superlinear (or worse, exponential) growth with respect to a core business metric such as daily active users, you may need to consider redesigning or replacing them.\n\nWaze’s development of a new in-house message queue system shows that it is possi‐ ble for small groups of determined engineers to institute change that moves the nee‐ dle toward greater service reliability. Mapping Kotter’s model onto the change shows that some consideration of change management strategy can help provide a formula for success even in small, engineering-led organizations. And, as the next case study also demonstrates, when changes promote standardizing technology and processes, the organization as a whole can reap considerable efficiency gains.\n\nCase Study 2: Common Tooling Adoption in SRE\n\nBackground SREs are opinionated about the software they can and should use to manage produc‐ tion. Years of experience, observing what goes well and what doesn’t, and examining the past through the lens of the postmortem, have given SREs a deep background coupled with strong instincts. Specifying, building, and implementing software to automate this year’s job away is a core value in SRE. In particular, Google SRE recently focused our efforts on horizontal software. Adoption of the same solution by a critical mass of users and developers creates a virtuous cycle and reduces reinven‐ tion of wheels. Teams who otherwise might not interact share practices and policies that are automated using the same software.\n\n432\n\n|\n\nChapter 21: Organizational Change Management in SRE\n\nThis case study is based on an organizational evolution, not a response to a systems scaling or reliability issue (as discussed in the Waze case study). Hence, the Prosci ADKAR model (shown in Figure 21-3) is a better fit than Kotter’s model, as it recog‐ nizes both explicit organizational/people management characteristics and technical considerations during the change.\n\nFigure 21-3. Prosci ADKAR model of change management\n\nProblem Statement A few years ago, Google SRE found itself using multiple independent software solu‐ tions for approximately the same problem across multiple problem spaces: monitor‐ ing, releases and rollouts, incident response, capacity management, and so on.\n\nThis end state arose in part because the people building tools for SRE were dissoci‐ ated from their users and their requirements. The tool developers didn’t always have a current view of the problem statement or the overall production landscape—the production environment changes very rapidly and in new ways as new software, hardware, and use cases are brought to life almost daily. Additionally, the consumers of tools were varied, sometimes with orthogonal needs (“this rollout has to be fast; approximate is fine” versus “this rollout has to be 100% correct; okay for it to go slowly”).\n\nAs a result, none of these long-term projects fully addressed anyone’s needs, and each was characterized by varying levels of development effort, feature completeness, and ongoing support. Those waiting for the big use case—a nonspecific, singing-and- dancing solution of the future—waited a long time, got frustrated, and used their own\n\nCase Study 2: Common Tooling Adoption in SRE\n\n|\n\n433\n\nsoftware engineering skills to create their own niche solution. Those who had smaller, specific needs were loath to adopt a broader solution that wasn’t as tailored to them. The long-term, technical, and organizational benefits of more universal sol‐ utions were clear, but customers, services, and teams were not staffed or rewarded for waiting. To compound this scenario, requirements of both large and small customer teams changed over time.\n\nWhat We Decided to Do To scope this scenario as one concrete problem space, we asked ourselves: What if all Google SREs could use a common monitoring engine and set of dashboards, which were easy to use and supported a wide variety of use cases without requiring customi‐ zation?\n\nLikewise, we could extend this model of thinking to releases and rollouts, incident response, capacity management, and beyond. If the initial configuration of a product captured a wide representation of approaches to address the majority of our func‐ tional needs, our general and well-informed solutions would become inevitable over time. At some point, the critical mass of engineers who interact with production would outgrow whatever solution they were using and self-select to migrate to a com‐ mon, well-supported set of tools and automation, abandoning their custom-built tools and their associated maintenance costs.\n\nSRE at Google is fortunate that many of its engineers have software engineering back‐ grounds and experience. It seemed like a natural first step to encourage engineers who were experts and opinionated about specific problems—from load balancing to rollout tooling to incident management and response—to work as a virtual team, self-selected by a common long-term vision. These engineers would translate their vision into working, real software that would eventually be adopted across all of SRE, and then all of Google, as the basic functions of production.\n\nTo return to the ADKAR model for change management, the steps discussed so far— identifying a problem and acknowledging an opportunity—are textbook examples of ADKAR’s initiating awareness step. The Google SRE leadership team agreed on the need (desire) and had sufficient knowledge and ability to move to designing solutions fairly quickly.\n\nDesign Our first task was to converge upon a number of topics that we agreed were central, and that would benefit greatly from a consistent vision: to deliver solutions and adop‐ tion plans that fit most use cases. Starting from a list of 65+ proposed projects, we spent multiple months collecting customer requirements, verifying roadmaps, and performing market analysis, ultimately scoping our efforts toward a handful of vetted topics.\n\n434\n\n|\n\nChapter 21: Organizational Change Management in SRE\n\nOur initial design created a virtual team of SRE experts around these topics. This vir‐ tual team would contribute a significant percentage of their time, around 80%, to these horizontal projects. The idea behind 80% time and a virtual team was to ensure we did not design or build solutions without constant contact with production. How‐ ever, we (maybe predictably) discovered a few pain points with this approach:\n\nCoordinating a virtual team—whose focus was broken by being on-call regularly, across multiple time zones—was very difficult. There was a lot of state to be swapped between running a service and building a serious piece of software.\n\nEverything from gathering consensus to code reviews was affected by the lack of a central location and common time.\n\nHeadcount for horizontal projects initially had to come from existing teams, who now had fewer engineering resources to tackle their own projects. Even at Goo‐ gle, there’s tension between delegating headcount to support the system as is ver‐ sus delegating headcount to build future-looking infrastructure.\n\nWith enough data in hand, we realized we needed to redesign our approach, and set‐ tled on the more familiar centralized model. Most significantly, we removed the requirement that team members split their time 80/20 between project work and on- call duties. Most SRE software development is now done by small groups of senior engineers with plenty of on-call experience, but who are heads-down focused on building software based on those experiences. We also physically centralized many of these teams by recruiting or moving engineers. Small group (6–10 people) develop‐ ment is simply more efficient within one room (however, this argument doesn’t apply to all groups—for example, remote SRE teams). We can still meet our goal of collecting requirements and perspectives across the entire Google engineering orga‐ nization via videoconference, email, and good old-fashioned travel.\n\nSo our evolution of design actually ended up in a familiar place—small, agile, mostly local, fast-moving teams—but with the added emphasis on selecting and building automation and tools for adoption by 60% of Google engineers (the figure we deci‐ ded was a reasonable interpretation of the goal of “almost everyone at Google”). Suc‐ cess means most of Google is using what SRE has built to manage their production environment.\n\nThe ADKAR model maps the implementation phase of the change project between the people-centric stages of knowledge and ability. This case study bears out that mapping. We had many engaged, talented, and knowledgeable engineers, but we were asking people who had been focused on SRE concerns to act like product soft‐ ware development engineers by focusing on customer requirements, product road‐ maps, and delivery commitments. We needed to revisit the implementation of this change to enable engineers to demonstrate their abilities with respect to these new attributes.\n\nCase Study 2: Common Tooling Adoption in SRE\n\n|\n\n435\n\nImplementation: Monitoring To return to the monitoring space mentioned in the previous section, Chapter 31 in the first SRE book described how Viceroy—Google SRE’s effort to create a single monitoring dashboard solution suitable for everyone—addressed the problem of dis‐ parate custom solutions. Several SRE teams worked together to create and run the initial iteration, and as Viceroy grew to become the de facto monitoring and dash‐ boarding solution at Google, a dedicated centralized SRE development team assumed ownership of the project.\n\nBut even when the Viceroy framework united SRE under a common framework, there was a lot of duplicated effort as teams built complex custom dashboards specific to their services. While Viceroy provided a standard hosted method to design and build visual displays of data, it still required each team to decide what data to display and how to organize it.\n\nThe now-centralized software development team began a second parallel effort to provide common dashboards, building an opinionated zero-config system on top of the lower-level “custom” system. This zero-config system provided a standard set of comprehensive monitoring displays based on the assumption that a given service was organized in one of a handful of popular styles. Over time, most services migrated to using these standard dashboards instead of investing in custom layouts. Very large, unique, or otherwise special services can still deploy custom views in the hosted sys‐ tem if they need to.\n\nReturning to the ADKAR model, the consolidation of monitoring tools at Google began as a grassroots effort, and the resulting improvements in operational efficien‐ cies provided a quantifiable basis (awareness and desire) to initiate a broader effort: SRE self-funded a software development team to build production management tool‐ ing for all of Google.\n\nLessons Learned Designing a migration of interdependent pieces is often more complicated than a blank-sheet design. But in real life, the hardest engineering work ends up being the evolution of many small/constrained systems into fewer, more general systems— without disturbing already running services that many customers depend on. In the meantime, alongside the existing systems, new small systems are added—some of which eventually surprise us by growing into large systems. There is an intellectual attraction to starting anew with the big design, only backing into constraints that are really necessary, but the migration of systems and teams turns out to be the most dif‐ ficult work by far.\n\nDesigning horizontal software requires a lot of listening to prospective end users, and, in many ways, the tasks of building and adoption look much like the role of a\n\n436\n\n|\n\nChapter 21: Organizational Change Management in SRE\n\nproduct manager. In order for this effort to achieve success, we had to make sure that we absorbed and prioritized priorities. Meeting customer needs—of both SREs and other production users—was also a critical element of success. It is important to acknowledge that the move toward common tooling is still a work in progress. We iterated on the structure and staffing of the teams building our shared technologies to better enable meeting customer needs, and we added product management and user experience talent (addressing missing knowledge).\n\nIn the past year or two, we have seen uptake of these SRE-designed and -built prod‐ ucts across a broad swath of teams at Google. We have learned that to achieve suc‐ cess, the cost of migration (from older, fragmented but specialized solutions) needs to be small relative to the net benefits of the new common solution. Otherwise, the migration itself becomes a barrier to adoption. We continue to work with the indi‐ vidual teams building these products to reinforce the behaviors needed to delight cus‐ tomers with the common solutions the teams are delivering.\n\nOne common theme we discovered across horizontal software development projects was that no matter how good new software and products were, the cost of migration —away from something that was already working to something new—was always perceived as very high. Despite the allure of easier management and less specific deep knowledge, the costs of migrating away from the familiar (with all its warts and toil) were generally a barrier. In addition, individual engineers often had a similar internal monologue: “I’m not improving or changing the system; I’m swapping out one work‐ ing piece for another working piece.” ADKAR describes this resistance as the “knowledge-to-ability gap.” On the human side, in order to recognize and embrace change, people need time, coaching, and training in new tools and skills. On the tech‐ nical side, implementing change requires understanding adoption costs and includ‐ ing work to minimize these costs as part of the launch process.\n\nAs a result, migration costs need to be nearly zero (“just recompile and you pick up new $thing”) and the benefits need to be clear (“now you’re protected from $foo vul‐ nerability”) to the team, to individuals, and to the company.\n\nSRE commonly used to build products that we committed to in a “best effort” way, meaning that the amount of time we gave the product fit into the cracks between everything else we were doing (managing primary services, capacity planning, deal‐ ing with outages, etc.). As a result, our execution was not very reliable; it was impos‐ sible to predict when a feature or service would be available. By extension, consumers of our products had less trust in the end result since it felt perpetually delayed and was staffed by a rotating cast of product managers and individual engineers. When individual SREs or SRE teams built tools for their own use, the focus was on solving individual problems to reduce the cost of maintaining SLOs for supported systems. In endeavoring to build common tooling for most use cases at Google, we needed to shift the focus to measuring the success of this effort in terms of product adoption.\n\nCase Study 2: Common Tooling Adoption in SRE\n\n|\n\n437\n\nOwing to both our organizational culture and our wealth of resources, we approached this project in a bottom-up, rather than top-down, fashion. Instead of mandating that users migrated to our new monitoring system, we sought to win over users by demonstrating that our new offering was better than existing solutions.\n\nOver time, we learned that how we conducted our development process would inform how potential internal users perceived the end result. These projects gained real traction only when staffed by production-experienced engineers 100% dedicated to building software, with schedules and support identical to the rest of Google’s soft‐ ware development. Building common software transparently, like clockwork, with great communication (“We’ll have X done by Y date”), greatly improved the speed of migration to the new system. People already trusted the new system because they could observe how it was developed from an early stage. Perceptions of how the saus‐ age is made turned out to be more important than we anticipated from the get-go. Our initial thought that “if you build something great, people will naturally flock to it” didn’t hold true. Rather, these projects had to be clearly defined, well advertised in advance, evaluated against a multitude of user cases (targeted to the grumpiest adopt‐ ers first), leaps and bounds better than existing options, and adoptable with little to no effort.\n\nThe more consumers you have for common tooling and adoption, the more time you actually have to spend doing things other than writing code. This may sound obvious in retrospect, but clear end goals, believable dates, regular updates, and constant con‐ tact with consumers is paramount. Often skeptical consumers will ask, “If my current one-off shell script works okay, do I really need this?” Adoption of common software or processes is analogous to reliability as a feature—you may build the best thing in the world, but if people don’t adopt it (or can’t use it if it’s not reliable), it’s not useful to anyone. Having a plan for adoption—from champions to beta testers to executive sponsors to dedicated engineers who understand the importance of minimizing bar‐ riers to adoption—is both the end goal and the starting point when it comes to build‐ ing and adopting common tools and practices.\n\nThis is because adoption drives a network effect: as the scale and reach of common software tools increases, incremental improvements to those tools are more valuable to the organization. As the value of the tools increases, development effort dedicated to them also tends to increase. Some of this development effort naturally goes toward further reducing migration costs, incentivizing greater adoption. Broad adoption encourages building organization-wide improvements in a consistent, product-like fashion, and justifies staffing full teams to support the tools for the long term. These tools should be characterized by rapid development, feature stability, common con‐ trol surfaces, and automatable APIs.\n\nWhen it comes to measuring the impact of such efforts, we can ask questions similar to the following:\n\n438\n\n|\n\nChapter 21: Organizational Change Management in SRE",
      "page_number": 447
    },
    {
      "number": 50,
      "title": "Segment 50 (pages 455-463)",
      "start_page": 455,
      "end_page": 463,
      "detection_method": "topic_boundary",
      "content": "How quickly can a new product developer build and manage a world-scale service?\n\nEnabled by common tools and practices, how easily can an SRE in one domain move to another domain?\n\nHow many services can be managed with the same primitives, as end-to-end user experiences versus separate services?\n\nThese are all possible and highly valuable ways to measure impact, but our first meas‐ urement must be adoption.\n\nConclusion As demonstrated by the Waze and horizontal software case studies, even within a sin‐ gle company, SRE change management may need to tackle a variety of problem spaces and organizational context. As a result, there’s likely no single formal model of change management that will neatly apply to the spectrum of changes any given organization may tackle. However, these frameworks, particularly Kotter’s eight-step process and the Prosci ADKAR model, can provide useful insights for approaching change. One commonality across any change necessary in an environment as dynamic as SRE is constant reevaluation and iteration. While many changes may start organically in a grassroots fashion, most can benefit from structured coordina‐ tion and planning as the changes mature.\n\nConclusion\n\n|\n\n439\n\nConclusion\n\nBy Dave Rensin, Betsy Beyer, Niall Richard Murphy, Stephen Thorne, and Kent Kawahara\n\nOnward… The American economist Edgar Fiedler used to say that “[h]e who lives by the crystal ball soon learns to eat ground glass.” Predicting the future is dangerous.\n\nNonetheless, we’re going to risk the broken glass and try to say a few useful words about what we think comes after this book.\n\nThe Future Belongs to the Past Our experiences since the publication of the first SRE book and the process of assem‐ bling this volume have clearly demonstrated a huge pent-up demand for SRE from enterprises both large and small. From this, some interesting observations emerge.\n\nFirst, large enterprises tend to have correspondingly large appetites to adopt SRE practices in a robust way. The familiar meme that large enterprises are slow to change is decidedly not true in this case. We expect to see a lot of interesting innovation in the SRE space from these firms over the next year, and that’s really exciting.\n\nNext, smaller firms are finding ways to adopt SRE practices regardless of whether or not they can staff a full-blown, globally distributed SRE team. We’ve long speculated that although the substance and sequence of the dishes are vitally important, people don’t have to eat the whole SRE meal at once. We are now seeing that notion put into good practice, and that’s also really exciting because it allows everyone to participate.\n\nFinally, if you are reading this book and wondering if there’s a market opportunity for you to offer services or build products that help firms adopt SRE, then the answer is a resounding yes. In fact, if that’s something you decide to do, please let us know through O’Reilly at bookquestions@oreilly.com. We’d like to keep up with your progress.\n\nConclusion\n\n|\n\n441\n\nSRE + <Insert Other Discipline> We heard from many thoughtful people that SRE principles and practices seem like they should also apply to other disciplines—particularly security. We didn’t cover the SRE/security overlap in the first book (or this book), but this is clearly a quickly bur‐ geoning area of focus. If you’re wondering why we didn’t cover it in any depth in this volume, it’s because we’re not sure what we want to say about it (yet).\n\nAt the time of this writing (early spring 2018) we’re already seeing the emergence of the term DevSecOps—a recognition that development, security, and operations are all interdependent—in the marketplace. If you’re an SRE looking for a useful and unex‐ plored space in which to spend some time, that’s a really good candidate!\n\nIn general, we think this is the start of a trend toward asking, “How would SRE be applied to <insert other discipline>?” It certainly stands to reason that some SRE principles and practices could have value in other domains.\n\nWe’re pretty excited to see where that leads…\n\nTrickles, Streams, and Floods The number of people offering to contribute content to this volume was much larger than the previous volume. That seems easy enough to explain—the first book was pretty popular, so people were keen to contribute to the second one. However, the variety of people offering to pitch in has been interesting. The types and range of the content proposals we evaluated surprised us. For example, a team of lawyers approached us about how they might incorporate error budgets into nontechnical legal agreements. How SRE applies to the legal profession is a topic clearly out of scope for this book, but is probably really interesting to a whole other professional population.\n\nBecause of this variety, we decided that this volume will not just be an implementa‐ tion companion to the previous book. It will also be a launching point for whole new streams of SRE-related content. That means more books, articles, podcasts, videos, and who knows what else. This volume is a beginning, not an end.\n\nSRE Belongs to All of Us When we started work on the first book, our primary motivation was to explain SRE—this interesting thing we do to make Google work well for our users. It seemed useful to spread that knowledge around.\n\nIn our enthusiasm to explain our view of the world, we anchored on our direct expe‐ riences. As a result, we unintentionally alienated some in the larger DevOps commu‐ nity and beyond, who felt we ignored other organizations’ contributions to the field.\n\n442\n\n|\n\nConclusion\n\nThis volume aims to correct that mistake by devoting considerable space to discus‐ sing DevOps and SRE and why they are not at odds.\n\nTo our great joy, SRE is a growing community of practitioners that now extends very far outside of Google. In fact, it’s likely that the number of non-Google SREs will sig‐ nificantly outnumber Google SREs by the time you read this.\n\nWhatever its history, SRE is now a global community of which Google is one mem‐ ber. It belongs to all of us, and that’s a good thing. It’s already abundantly clear, via conferences like SREcon, meetups, and other publications, that we all have a lot to share with and learn from each other. To that end, we hope this book further expands that ongoing conversation.\n\nOn Gratitude This volume has been a labor of love for us, and we are deeply grateful that you deci‐ ded to read it. This process has taught each of us some surprising lessons about what SRE has become and made us all very excited to see what comes next.\n\n(And since we are SREs, we’ll be starting a lengthy postmortem on this process. Who knows, maybe you’ll even see it in a blog post one of these days…)\n\nMay your queries flow and your pagers stay silent. —Dave, Betsy, Niall, Stephen, and Kent\n\nConclusion\n\n|\n\n443\n\nAPPENDIX A Example SLO Document\n\nThis document describes the SLOs for the Example Game Service.\n\nStatus Author Date Reviewers Approvers Approval Date Revisit Date\n\nPublished Steven Thurgood 2018-02-19 David Ferguson Betsy Beyer 2018-02-20 2019-02-01\n\nService Overview The Example Game Service allows Android and iPhone users to play a game with each other. The app runs on users’ phones, and moves are sent back to the API via a REST API. The data store contains the states of all current and previous games. A score pipeline reads this table and generates up-to-date league tables for today, this week, and all time. League table results are available in the app, via the API, and also on a public HTTP server.\n\nThe SLO uses a four-week rolling window.\n\nExample SLO Document\n\n|\n\n445\n\nSLIs and SLOs\n\nCategory API Availability\n\nSLI\n\nThe proportion of successful requests, as measured from the load balancer metrics. Any HTTP status other than 500–599 is considered successful. count of \"api\" http_requests which do not have a 5XX status code divided by count of all \"api\" http_requests\n\nLatency\n\nThe proportion of sufficiently fast requests, as measured from the load balancer metrics. “Sufficiently fast” is defined as < 400 ms, or < 850 ms. count of \"api\" http_requests with a duration less than or equal to \"0.4\" seconds divided by count of all \"api\" http_requests\n\ncount of \"api\" http_requests with a duration less than or equal to \"0.85\" seconds divided by count of all \"api\" http_requests\n\nHTTP server Availability\n\nThe proportion of successful requests, as measured from the load balancer metrics. Any HTTP status other than 500–599 is considered successful. count of \"web\" http_requests which do not have a 5XX status code divided by count of all \"web\" http_requests\n\nLatency\n\nThe proportion of sufficiently fast requests, as measured from the load balancer metrics. “Sufficiently fast” is defined as < 200 ms, or < 1,000 ms. count of \"web\" http_requests with a duration less than or equal to \"0.2\" seconds divided by count of all \"web\" http_requests\n\ncount of \"web\" http_requests with a duration less than or equal to \"1.0\" seconds divided by count of all \"web\" http_requests\n\n446\n\n| Appendix A: Example SLO Document\n\nSLO\n\n97% success\n\n90% of requests < 400 ms 99% of requests < 850 ms\n\n99%\n\n90% of requests < 200 ms 99% of requests < 1,000 ms\n\nCategory SLI Score pipeline Freshness\n\nThe proportion of records read from the league table that were updated recently. “Recently” is defined as within 1 minute, or within 10 minutes. Uses metrics from the API and HTTP server: count of all data_requests for \"api\" and \"web\" with freshness less than or equal to 1 minute divided by count of all data_requests\n\nSLO\n\n90% of reads use data written within the previous 1 minute. 99% of reads use data written within the previous 10 minutes.\n\ncount of all data_requests for \"api\" and \"web\" with freshness less than or equal to 10 minutes divided by count of all data_requests\n\nCorrectness\n\nThe proportion of records injected into the state table by a correctness prober that result in the correct data being read from the league table. A correctness prober injects synthetic data, with known correct outcomes, and exports a success metric: count of all data_requests which were correct divided by count of all data_requests\n\n99.99999% of records injected by the prober result in the correct output.\n\nCompleteness\n\nThe proportion of hours in which 100% of the games in the data store were processed (no records were skipped). Uses metrics exported by the score pipeline: count of all pipeline runs that processed 100% of the records divided by count of all pipeline runs\n\n99% of pipeline runs cover 100% of the data.\n\nRationale Availability and latency SLIs were based on measurement over the period 2018-01-01 to 2018-01-28. Availability SLOs were rounded down to the nearest 1% and latency SLO timings were rounded up to the nearest 50 ms. All other numbers were picked by the author and the services were verified to be running at or above those levels.\n\nNo attempt has yet been made to verify that these numbers correlate strongly with user experience.1\n\n1 Even if the numbers in the SLO are not strongly evidence-based, it is necessary to document this so that\n\nfuture readers can understand this fact, and make their decisions appropriately. They may decide that it is worth the investment to collect more evidence.\n\nExample SLO Document\n\n|\n\n447\n\nError Budget Each objective has a separate error budget, defined as 100% minus (–) the goal for that objective. For example, if there have been 1,000,000 requests to the API server in the previous four weeks, the API availability error budget is 3% (100% – 97%) of 1,000,000: 30,000 errors.\n\nWe will enact the error budget policy (see Appendix B) when any of our objectives has exhausted its error budget.\n\nClarifications and Caveats\n\nRequest metrics are measured at the load balancer. This measurement may fail to accurately measure cases where user requests didn’t reach the load balancer.\n\nWe only count HTTP 5XX status messages as error codes; everything else is counted as success.\n\nThe test data used by the correctness prober contains approximately 200 tests, which are injected every 1s. Our error budget is 48 errors every four weeks.\n\n448\n\n| Appendix A: Example SLO Document\n\nAPPENDIX B Example Error Budget Policy\n\nStatus Author Date Reviewers Approvers Approval date Revisit date\n\nPublished Steven Thurgood 2018-02-19 David Ferguson Betsy Beyer 2018-02-20 2019-02-01\n\nService Overview The Example Game Service allows Android and iPhone users to play a game with each other. New releases of the backend code are pushed daily. New releases of clients are pushed weekly. This policy applies both to backend and client releases.\n\nGoals The goals of this policy are to:\n\nProtect customers from repeated SLO misses\n\nProvide an incentive to balance reliability with other features\n\nNon-Goals This policy is not intended to serve as a punishment for missing SLOs. Halting change is undesirable; this policy gives teams permission to focus exclusively on\n\nExample Error Budget Policy\n\n|\n\n449",
      "page_number": 455
    },
    {
      "number": 51,
      "title": "Segment 51 (pages 464-472)",
      "start_page": 464,
      "end_page": 472,
      "detection_method": "topic_boundary",
      "content": "reliability when data indicates that reliability is more important than other product features.\n\nSLO Miss Policy If the service is performing at or above its SLO, then releases (including data changes) will proceed according to the release policy.\n\nIf the service has exceeded its error budget for the preceding four-week window, we will halt all changes and releases other than P01 issues or security fixes until the ser‐ vice is back within its SLO.\n\nDepending upon the cause of the SLO miss, the team may devote additional resour‐ ces to working on reliability instead of feature work.\n\nThe team must work on reliability if:\n\nA code bug or procedural error caused the service itself to exceed the error budget.\n\nA postmortem reveals an opportunity to soften a hard dependency.\n\nMiscategorized errors fail to consume budget that would have caused the service to miss its SLO.\n\nThe team may continue to work on non-reliability features if:\n\nThe outage was caused by a company-wide networking problem.\n\nThe outage was caused by a service maintained by another team, who have them‐ selves frozen releases to address their reliability issues.\n\nThe error budget was consumed by users out of scope for the SLO (e.g., load tests or penetration testers).\n\nMiscategorized errors consume budget even though no users were impacted.\n\nOutage Policy If a single incident consumes more than 20% of error budget over four weeks, then the team must conduct a postmortem. The postmortem must contain at least one P0 action item to address the root cause.\n\n1 P0 is the highest priority of bug: all hands on deck; drop everything else until this is fixed.\n\n450\n\n| Appendix B: Example Error Budget Policy\n\nIf a single class of outage consumes more than 20% of error budget over a quarter, the team must have a P0 item on their quarterly planning document2 to address the issues in the following quarter.\n\nEscalation Policy In the event of a disagreement between parties regarding the calculation of the error budget or the specific actions it defines, the issue should be escalated to the CTO to make a decision.\n\nBackground\n\nThis section is boilerplate, intended to give a succinct overview of error budgets to those unfamiliar with them.\n\nError budgets are the tool SRE uses to balance service reliability with the pace of innovation. Changes are a major source of instability, representing roughly 70% of our outages, and development work for features competes with development work for stability. The error budget forms a control mechanism for diverting attention to stability as needed.\n\nAn error budget is 1 minus the SLO of the service. A 99.9% SLO service has a 0.1% error budget.\n\nIf our service receives 1,000,000 requests in four weeks, a 99.9% availability SLO gives us a budget of 1,000 errors over that period.\n\n2 At Google, quarterly planning is public, and teams are held accountable to their plans.\n\nExample Error Budget Policy\n\n|\n\n451\n\nAPPENDIX C Results of Postmortem Analysis\n\nAt Google, we have a standard postmortem template that allows us to consistently capture the incident root cause and trigger, which enables trend analysis. We use this trend analysis to help us target improvements that address systemic root-cause types, such as faulty software interface design or immature change deployment planning. Table C-1 shows the breakdown of our top eight triggers for outages, based on a sam‐ ple of thousands of postmortems over the last seven years.\n\nTable C-1. Top eight outage triggers, 2010–2017\n\nBinary push Configuration push User behavior change Processing pipeline Service provider change Performance decay Capacity management Hardware\n\n37% 31% 9% 6% 5% 5% 5% 2%\n\nTable C-2 presents the top five contributing root-cause categories.\n\nTable C-2. Top five root-cause categories for outages\n\nSoftware Development process failure Complex system behaviors Deployment planning Network failure\n\n41.35% 20.23% 16.90% 6.74% 2.75%\n\nResults of Postmortem Analysis\n\n|\n\n453\n\nA abandoned phase (service lifecycle), SRE\n\nengagement in, 374\n\nAbuse SRE and Common Abuse Tool (CAT)\n\nteams, Ares case study, 385-387\n\naccess control policies for data processing pipe‐\n\nlines, 277\n\naccidents, view in DevOps, 3 ACM Queue article on Canary Analysis service,\n\n313\n\naction items in postmortems, 200\n\ngamification of postmortem action items,\n\n216\n\nin good postmortem example, 212\n\nblamelessness of, 213 concrete action items, 213\n\nmonitoring tool for, 222 rewarding closeout of, 215\n\nactive development phase (service lifecycle),\n\nSRE engagement in, 373\n\nADKAR, 426, 433\n\n(see also Prosci ADKAR model) AdMob and AdSense systems, 137 AdWords NALSD example, 246-259\n\ndesign process, 246 distributed system, 251-259\n\nLogJoiner, 252 MapReduce, evaluating, 251\n\ninitial requirements, 247 running application on one machine, 248 scaling resources for parsing logs, 249\n\nalerts\n\nalert suppression, 64 alerting on SLOs, 75-91\n\nIndex\n\nburn rate for error budgets, 80 considerations in, 75 increased alert window, 78 incrementing alert duration, 79 low-traffic services and error budget\n\nalerting, 86-89\n\nmaking sure alerting is scalable, 89 multiple burn rate alarms, 82 multiwindow, multi-burn-rate alerts, 84 services with extreme availability goals,\n\n89\n\ntarget error rate SLO threshold, 76\n\ncontributors to high pager load, 158 paging alerts, defining thresholds for, 163 provided by monitoring system, 64\n\nin metrics-based and logs-based systems,\n\n65\n\nseparating alerting in monitoring systems,\n\n68\n\ntesting alerting logic in monitoring system,\n\n72\n\nusing good alerts and consoles to identify\n\ncause of pages, 161 analysis of postmortems, 222, 453 animated (undesirable) language in postmor‐\n\ntems, 201 anycast, 226\n\nstabilized, implementation of, 226\n\nAPIs\n\navailability and latency for API calls, Home\n\nDepot case study, 52\n\navailability and latency SLIs, 25 case study, end-to-end API simplicity, 134 machine consumable, 393\n\nIndex\n\n|\n\n455\n\nproposed SLOs for the API, 28\n\napplication errors in data processing pipeline,\n\n286\n\nApplication Readiness Reviews (ARRs), 377 architecture and design phase (service lifecy‐\n\ncle), SRE engagement in, 372\n\narchitecture and design, SRE team partnering\n\non, 411\n\narchitectures (opaque), troubleshooting for,\n\n100\n\nartificial load generation, 350 aspirational SLOs, 36 authoring of postmortems, including all partic‐\n\nipants in, 215 autohealing, 236 automated builds, 336 automated health checking, 160 automation\n\narchiving and migration, in filer-backed\n\nhome directory decommissioning, 126\n\nassessing risks of, 104 automating this year’s job away, 6 automating toil response, 104 increasing uniformity in production envi‐\n\nronment, 103\n\nmeasuring effectiveness of automated tasks,\n\n105\n\npartial automation with human-backed\n\ninterfaces, 102, 127\n\nusing to reduce toil in datacenter, case\n\nstudy, 107-120 autoscaling, 236-239\n\navoiding overloading backends, 238 avoiding traffic imbalance, 239 configuring conservatively, 237 handling unhealthy machines, 236 implementing for data processing pipelines,\n\n276\n\nin Spotify case study, 295 including kill switches and manual over‐\n\nrides, 238\n\nload-based, using with load balancing, 239 load-based, using with load shedding, 239 setting constraints on the autoscaler, 237 using with load balancing and load shed‐\n\nding, precautions with, 242 working with stateful systems, 237\n\navailability\n\n456\n\n|\n\nIndex\n\nalerting on services with extreme availability\n\ngoals, 89\n\nduring canary deployment, 343 Evernote’s goal for, 45 factoring dependencies into, 100 for API calls, SLOs in Home Depot case\n\nstudy, 52\n\ngrouping request types into buckets of simi‐\n\nlar availability requirements, 89\n\nhigh availability with GCLB, 231\n\navailability SLI, 24\n\nAPI and HTTP server availability, 25 measuring availability with health-checking\n\nhandler, 36\n\nB backend services, avoiding overloading in\n\nautoscaling, 238\n\nbalance between on-call and project work for\n\nSREs, 148\n\nbaseline of a functional team, 367 Beyond Corp network security protocol, 122 BGP (Border Gateway Protocol), 226 blameful language, mitigating damage of, 219 blameless language, 215 blameless postmortems, 8, 10, 195\n\n(see also postmortems) blamelessness in good postmortem exam‐\n\nple, 213\n\nmodeling and enforcing blameless behavior,\n\n214\n\nresponding to culture failures in, 218\n\nblue/green deployment, 350 boiling the frog, 167 Borg, 134 breaks (long-term) in on-call scheduling, 170 Bridges Transition Model, 426, 427 bucketing, using with SLIs, 39 bugs\n\nbug tracking systems, 166 new bugs in production environment, 159 preexisting bugs in production environ‐\n\nment, 159\n\ntracking new bugs in production, 160\n\nburn rate (error budgets)\n\nalerting on, 80 multiple alerts on, 82 multiwindow multi-burn-rate alerts, 84\n\nbusiness intelligence, 265\n\nbusiness priorities, communicating between\n\nSRE and developer teams, 375 business processes producing toil, 98\n\nquestioning, 127\n\nC calculations support (monitoring systems), 62 CALMS (Culture, Automation, Lean, Measure‐\n\nment, and Sharing), 2\n\ncanarying releases, 161, 335-351\n\nbalancing release velocity and reliability,\n\n337\n\ncanary implementation, 342-345\n\nchoosing canary population and dura‐\n\ntion, 343\n\nminimizing risk to SLOs and error\n\nbudget, 343 canarying, defined, 338 dependencies and isolation, 348 for data processing pipeline, 273 in noninteractive systems, 348 related concepts, 350\n\nartificial load generation, 350 blue/green deployment, 350 traffic teeing, 351\n\nrelease engineering and canarying, 338\n\nexample setup, 339 requirements of canary process, 339 release engineering principles, 336-337 requirements on monitoring data, 349 roll forward deployment vs. simple canary\n\ndeployment, 340-342\n\nselecting and evaluating metrics, 345-348\n\nbefore/after evaluation, riskiness of, 347 metrics indicating problems, 345 representative and attributable metrics,\n\n346\n\nusing gradual canary for better metric\n\nselection, 347\n\nseparating components that change at dif‐\n\nferent rates, 337\n\nwith GCLB, 231 capacity planning, 100\n\nfor data processing pipeline, 276 in Spotify case study, 295 setting traffic volume SLOs in Home Depot\n\ncase study, 52\n\nCCN (cyclomatic complexity number), 131 change control, 423\n\nchange management\n\nin DevOps and SRE, 8 organizational change management in SRE,\n\n423-439 case study, common tooling adoption in\n\nSRE, 432-439\n\ncase study, scaling Waze, 427-432 emotion-based models, 426 how change management theories apply\n\nto SRE, 427\n\nKotter’s eight-step process, 425 Lewin’s three-stage model, 424 McKinsey’s 7-S model, 424 Prosci ADKAR model, 425 SRE embracing change, 423\n\nchanges\n\navoiding changes that can’t be rolled back,\n\n162\n\nchange tracking for configurations, 312 gradual change in DevOps, 3 monitoring intended changes in services, 70 safe configuration change application, 312\n\nchecklist for new SRE team training, 150 checklist for postmortems, 221 checkpointing in data processing pipelines, 279 clarity in good postmortem example, 212 click-through rate (CTR), 246\n\ncalculating, 247\n\nClickMap (AdWords example), 252 in multidatacenter design, 257 scaling, calculations for, 254\n\nin multidatacenter design, 258 client behavior changes, resulting in bugs, 160 Clos network topology, 107 cloud environment\n\nbreaking down SLO wall between GCP and\n\nEvernote, 48\n\nEvernote, on-call setup for cloud datacen‐\n\nters, 153-156\n\nGoogle Cloud Platform (GCP), 43\n\ncode\n\ncode patterns for data processing pipelines,\n\n280\n\nconfiguration as code or data, 309 cyclomatic code complexity, 131\n\ncodelabs, 150 collaboration in DevOps and SRE, 8 colocation facilities (colos), racks of proxy/\n\ncache machines in, 196\n\nIndex\n\n|\n\n457\n\ncommunication\n\nbetween teams, understanding differences\n\nin, 382\n\nin incident response, 176\n\ndeciding on communication channel,\n\n192\n\nfailure in Google Home incident, 180 keeping your audience informed, 192 maintaining open line between SRE and\n\nother teams, 380\n\nCommunications Lead (CL), 187 completeness SLO (Spotify case study), 293 complexity\n\ncase study, project lifecycle complexity, 134 measuring, 131-132\n\ncomplexity toil, 316 components\n\nseparating components that change at dif‐\n\nferent rates, 337\n\ntypes of, 22\n\nSLIs for different types, 24\n\nCompute Engine, 48 conciseness in postmortems, 214 configuration, 301-314\n\nabout, 301 and reliability, 302 configuration-induced toil, 315\n\nreducing, 316\n\ncritical properties and pitfalls of configura‐\n\ntion systems, 317-320 building too much domain-specific opti‐\n\nmization, 318\n\ndesigning accidental or ad hoc language\n\nfeatures, 318\n\nfailing to recognize configuration as pro‐ gramming language problem, 317 interleaving configuration evaluation\n\nwith side effects, 319\n\nusing general-purpose scripting lan‐\n\nguages, 319\n\ndata processing pipeline, causing failures,\n\n286\n\neffectively operating a configuration system,\n\n329-330 testing, 330 using source control, 330 versioning, 329\n\nguarding against abusive configuration, 333 integrating a configuration language, 320\n\n458\n\n|\n\nIndex\n\ndriving multiple applications, 321 generating config in specific formats,\n\n320\n\nintegrating custom applications, 327-329 integrating existing application, Kubernetes,\n\n322-326 example Kubernetes config, 322 integrating the configuration language,\n\n323\n\nmechanics of, 308-313\n\nimportance of tooling, 310 ownership and change tracking, 312 safe configuration change application,\n\n312\n\nseparating configuration and resulting\n\ndata, 308\n\nmonitoring system, treating as code, 67 philosophy of, 303-308\n\nconfiguration asks users questions, 305 escaping simplicity, 308 mandatory and optional questions, 306 questions should be close to user goals,\n\n305\n\nseparating philosophy and mechanics, 303 when to evaluate, 331-333\n\nearly evaluation, checking in the JSON,\n\n331\n\nlate evaluation at runtime, 332 middle of the road, evaluation at build\n\ntime, 332\n\nconfiguration syntax, tooling for, 311 connection tracking, 228 consensus algorithms, 257 consistent hashing, 228\n\nusing with stateful systems, 237 contacts, preparing for an incident, 192 context, missing, in bad postmortem, 199 continuous integration and continuous delivery\n\n(CI/CD), 3, 335 coupled with release automation, virtuous\n\ncycle of, 336\n\ncoordination of incident response effort, 176 correctness SLI, 24 correctness SLOs, 269 corrupt data (in data processing pipeline), 285 cost engineering, 100 coverage SLI, 24\n\nimplementation for pipeline coverage, 26,\n\n26\n\ncoverage, SLO lacking, 35 CRE (see Google’s Customer Reliability Engi‐\n\nneering (CRE) team) CRITICAL requests, 90 cross-team reviews of postmortems, 218 CRUD-style APIs, monitoring system configu‐\n\nration, 68\n\nCs of incident management (coordinate, com‐\n\nmunicate, control), 176 CTR (see click-through rate) culture\n\nand tooling in DevOps, 3 learning from failure in postmortems (see\n\npostmortems)\n\nresponding to postmortem culture failures,\n\n218\n\nSLO culture project at Home Depot, 50\n\ncustomers\n\nhaving a hard time, 393 practicing SRE with, 393 SRE with, how to, 394-397 cyclomatic code complexity, 131\n\nD dashboards\n\nbuilding shared SLO dashboards with cus‐\n\ntomers, 395\n\nfor data processing pipeline, 283 providing for SLOs, 33 separate dashboarding system in monitor‐\n\ning, 69\n\nshowing SLI trends, 33 VALET dashboard, Home Depot case study,\n\n56\n\ndata analysis pipeline, case study, 387-389 data analytics, 265 data collection to monitor causes in on-call\n\nload, 165\n\ndata correctness, 269 data formats for configuration information, 309 data freshness, 269 data isolation, 269\n\ncanarying releases and, 348 in noninteractive systems, 349 data processing pipelines, 263-299\n\nbest practices, 268-277\n\nadhering to access control and security\n\npolicies, 277\n\ncreating and maintaining pipeline docu‐\n\nmentation, 271\n\ndefining and measuring service level\n\nobjectives, 268-270\n\nimplementing autoscaling and resource\n\nplanning, 276\n\nmapping your development lifecycle,\n\n272-275\n\nplanning escalation paths, 277 planning for dependency failure, 270 reducing hotspotting and workload pat‐\n\nterns, 275\n\ncase study, Spotify, 287-299\n\ncustomer integration and support,\n\n293-298\n\nevent delivery, 288 event delivery system design and archi‐\n\ntecture, 289\n\nevent delivery system operation, 290-293\n\nfailures, prevention and response, 284-287\n\npotential causes, 286 potential failure modes, 284 pipeline applications, 264-268\n\ndata analytics, 265 event processing and data transforma‐\n\ntion, 264\n\nmachine learning, 265\n\nrequirements and design, 277-280\n\ncheckpointing, 279 code patterns, 280 features, 278 idempotent and two-phase mutations,\n\n279\n\npipeline production readiness, 281-284\n\ndata-only languages (configuration), 317 datacenters\n\nmultidatacenter in AdWords example, 257 using automation to reduce toil, case study,\n\n107-120 debugging, 68\n\nfor data processing pipeline, 282 in App Engine errors, 65 metrics for, 72\n\ndelayed data (in data processing pipeline), 284 Deming Cycle, 426 dependencies\n\ncanarying releases and, 348 circular dependency, pDNS, 140 effects on availability, 100\n\nIndex\n\n|\n\n459\n\nexternal dependencies and incident\n\nresponse, 183\n\nin data processing pipeline, causing failures,\n\n286\n\nmodeling, 40 monitoring system metrics from, 70 planning for failure in data processing pipe‐\n\nlines, 270\n\ndeployments\n\nautomated, 336 blue/green, 350 continuous, 3\n\n(see also continuous integration and\n\ncontinuous delivery)\n\ndeploying data processing pipeline to pro‐\n\nduction, 275\n\npartial, performing for data processing\n\npipelines, 274\n\nroll forward deployment vs. simple canary\n\ndeployment, 340-342\n\nsmall, 336\n\ndeprecation phase (service lifecycle), SRE\n\nengagement in, 374 depth in postmortems, 213 design phase (service lifecycle), SRE engage‐\n\nment in, 372\n\ndesign process (NALSD), 246 destructive testing or fuzzing, 159 detection time (SLO alerts), 76 development\n\ndevelopment process in Spotify case study,\n\n296\n\nmapping data processing pipeline develop‐\n\nment lifecycle, 272-275\n\npartnership with SRE, critical importance\n\nof, 11\n\nplacing your first SRE in development team,\n\n401\n\nsetting up relationship between SRE and\n\ndevelopment team, 375-380 aligning goals, 375-378 communicating business and produc‐\n\ntion priorities, 375 identifying risks, 375 planning and executing, 379 setting ground rules, 379\n\nSRE teams having responsibility for, 412 SRE-to-developer ratio and support of mul‐ tiple services by single SRE team, 382\n\n460\n\n|\n\nIndex\n\nSREs sharing ownership with developers, 6 sustaining an effective ongoing relationship between SRE and development teams, 380-382\n\nDevOps\n\nabout, 2 accidents, view of, 3 comparing and contrasting with SRE, 7 elimination of silos, 2 gradual change, 3 implementation by SRE, 4 interrelation of tooling and culture, 3 measurement as crucial, 4 organizational context and fostering suc‐\n\ncessful adoption, 9-12\n\ndisaster and recovery testing, practicing with\n\ncustomers, 397\n\ndisaster recovery testing (DiRT) at Google, 193,\n\n271\n\ndiskerase, 196 Display Ads Spiderweb, simplification of (case\n\nstudy), 137\n\ndistributed SRE teams, running, 384 distributed SREs, 403 documentation\n\ncreating and maintaining for data process‐\n\ning pipelines, 271\n\nSpotify case study, customer integration and\n\nsupport, 294\n\ndomain-specific languages (DSLs) for configu‐\n\nration, 319\n\ndomain-specific optimization (excessive) in\n\nconfigurations, 318\n\ndraining requests away from buggy system ele‐\n\nments, 162\n\ndrills (incident management), 193 dropping work, 368 durability SLI, 25 duration parameter (alerts), incrementing, 79\n\nE ease of implementation and transparency for data processing pipeline, 283 emergency response, practicing, 161 emotion-based models for change manage‐\n\nment, 426\n\nend-to-end measurement for data processing\n\npipeline SLOs, 270\n\nending SRE engagements, 385-389",
      "page_number": 464
    },
    {
      "number": 52,
      "title": "Segment 52 (pages 473-484)",
      "start_page": 473,
      "end_page": 484,
      "detection_method": "topic_boundary",
      "content": "case study, Ares, 386-387 case study, data analysis pipeline, 387 Equal-Cost Multi-Path (ECMP) forwarding,\n\n227\n\nerror budgets, 47\n\n(see also service level objectives) addressing missed SLO caused by a depend‐\n\nency, 41\n\nadjusting priorities according to, 381 agreed-upon by SRE and development\n\nteams for a service, 379\n\nalerting on burn rate, 80 multiple alarms, 82 multiwindow, multi-burn-rate alerts, 84\n\ncalculating, 20 dashboard showing error budget consump‐\n\ntion, 34\n\ndecision making using, 37-38 documenting error budget policy, 32 establishing error budget policy, 31 example policy, 449-451 for example game service, 448 low-traffic services and error budget alert‐\n\ning, 86-89 combining services, 87 generating artificial traffic, 87 lowering the SLO or increasing the win‐\n\ndow, 88\n\nmaking service and infrastructure\n\nchanges, 87\n\nminimizing risk to by canarying releases,\n\n343\n\nprerequisites for adopting as SRE approach,\n\n18\n\nreliability targets and, 19 rolling back recent changes and, 162 support tickets per day vs. measured loss in\n\nbudget, 35\n\nerrors\n\nalerting for target error rate over SLO thres‐\n\nhold, 76\n\ndebugging in different monitoring systems,\n\n65\n\ndefining SLOs for in Home Depot case\n\nstudy, 53\n\nerrors per hour metric in canary deploy‐\n\nment, 349\n\nincreased alert window for SLO errors, 78 measurement in Home Depot case study, 51\n\nevangelism, SLOs at Home Depot, 51, 54 events\n\nevent delivery in Spotify case study, 288 event processing to order or structure data,\n\n265\n\nEvernote, SLO case study, 43-49\n\ncurrent state of SLO use and practice, 49 introduction of SLOs, journey in progress,\n\n45-47\n\nwhy Evernote adopted SRE model, 44 extract, transform, load (ETL) model, 264\n\nETL pipelines, 264 in Spotify case study, 290\n\nF failures, 3\n\ndata processing pipeline, prevention and\n\nresponse, 284-287 potential causes, 286 potential failure modes, 284\n\ndependency failure in data processing pipe‐\n\nline, 270\n\nfailure tolerance in data processing pipeline,\n\n282\n\nhandling mistakes appropriately, 382 not passing off blame for, 10 reducing cost of, 6 feature isolation, 162 features\n\nfeature coverage in SRE with customers, 397 planning for data processing pipelines, 278 separating feature launches from binary\n\nreleases, 338\n\ntradeoffs between feature velocity and relia‐\n\nbility, 19\n\nfeedback from users, toil management with,\n\n105\n\nfinger pointing in postmortems, 201 follow-up to pager alerts, rigor in, 164 follow-up to postmortems, 222 forming your first SRE team, 404 Four Golden Signals, 51, 70 freshness\n\ndata freshness SLOs for data processing\n\npipeline, 269\n\nof data in monitoring system, 62\n\nfreshness SLI, 24\n\nimplementation for pipeline freshness, 26\n\nfunding and hiring (SREs), 421\n\nIndex\n\n|\n\n461\n\nfuture protection from overload, 368\n\nG G Suite Team Drive, 123 GCE (see Google Compute Engine) GCLB (Google Cloud Load Balancer), 225 (see also Google Cloud Load Balancing) general availability phase (service lifecycle),\n\nSRE engagement in, 374\n\ngeneric mitigations, 184\n\nuseful, in GKE CreateCluster failure case\n\nstudy, 184\n\ngeographical splits (SRE teams), 414\n\nfinance, travel budget, 417 leadership, joint ownership of a service, 418 parity, distributing work and avoiding a\n\nnight shift, 416\n\npeople and projects, seeding the team, 416 placement, and having three shifts, 417 placement, time zones apart, 415 should both halves of the team start at the\n\nsame time, 417\n\nGlobal Software Load Balancer (GSLB), 229 glossary in good postmortem example, 209, 212 goals, aligning between SRE and development\n\nteams, 375-378\n\ngolden signals (see Four Golden Signals) Google AdWords (see AdWords NALSD\n\nexample)\n\nGoogle Analytics, 265 Google Apps Script, 220 Google Assistant (version 1.88), bug in, 178 Google Cloud Load Balancer (GCLB), 225\n\nhigh availability with, 231\n\nGoogle Cloud Load Balancing, 225-235\n\nanycast network addressing and routing,\n\n226 stabilized anycast, 226\n\ncase study, Pokémon GO on GCLB, 231-235\n\nfuture-proofing, 235 migrating to GCLB, 233 resolving issue with request spikes and\n\nGFE, 234\n\nGlobal Software Load Balancer (GSLB), 229 Google Front End (GFE), 229 low latency with GCLB, 230 Maglev packet-level load balancer, 227\n\nGoogle Cloud Platform (GCP), 43, 153\n\n462\n\n|\n\nIndex\n\nbreaking down SLO wall between GCP and\n\nEvernote, 48\n\nGoogle Compute Engine (GCE), 289\n\nAutoscaler, 290, 295 losing large number of disk trays, incident\n\nresponse case study, 186-188 Google Front Ends (GFE), 228, 229\n\ncapacity reduction caused by synchronous\n\nclient retries, 233\n\nGoogle Home software bug incident response\n\ncase study, 177-180\n\nGoogle Kubernetes Engine (GKE), CreateClus‐\n\nter failure case study, 180-185 Google’s Colossus File System, 123 Google’s Customer Reliability Engineering\n\n(CRE) team, 43, 155\n\nGoogle’s template for postmortems, 220 GSLB (Global Software Load Balancer), 229\n\nH HashiCorp Configuration Language, 320 health checking, automated, problems with,\n\n160\n\nhelp, asking for, 162 HIGH_FAST requests, 90 HIGH_SLOW requests, 90 Home Depot, SLO case study, 49-59\n\napplying VALET to batch applications, 57 automating VALET data collection, 55 evangelizing SLOs, 54 first set of SLOs, 52-54 future aspirations, 58 proliferation of SLOs, 57 using VALET in testing, 58\n\nhorizontal projects, 419 horizontal SRE team, 404\n\nrisks and mitigations for, 406\n\nhotspotting, reducing in data processing pipe‐\n\nline, 275 HTTP requests\n\ngrading importance of, 39 success of, SLIs for, 20\n\nHTTP servers, availability and latency, 25 HTTP status codes, 53, 65, 448\n\nincluding in metrics-based monitoring, 66 monitoring system metrics on served traffic,\n\n72\n\nhuman error causing new bugs in production,\n\n161\n\nhuman processes in pager load, 159 human-backed interfaces, starting with, 102,\n\n127\n\nHyrum’s Law, 132\n\nI IC (Incident Commander), 177 ICS (Incident Command System), 176 idempotent mutations, 279 identification delay for causes of pages, 161 incentives\n\nfor SLO setting and measuring at Home\n\nDepot, 51\n\nfor successful adoption of DevOps and SRE,\n\n9-12 avoiding passing of blame, 10 narrow incentives narrowing success, 9 striving for parity of esteem, 12\n\nincident response, 175-194 basic principles, 175 best practices, using, 191-194\n\ndrills, 193 preparing beforehand, 192 training, 191\n\ncase study, Google Home software bug and\n\nfailure to communicate, 177-180 incident, 178 review, 180\n\ncase study, Google Kubernetes Engine\n\n(GKE), cluster creation failure, 180-185 incident, 181 responses that needed improvement, 184 responses that went well, 184\n\ncase study, incident response at PagerDuty,\n\n188-191 major incident response, 188 tools used, 190\n\ncase study, lightning strikes at Google data‐\n\ncenter, 185-188 incident, 186 review, 188\n\nincident management at Google, 176-177 Incident Command System (ICS), 176 main roles in incident response, 177\n\npracticing in SRE with customers, 397\n\nincidents\n\nestablishing criteria for, 193 finding causes of repeating incidents, 219 incident handling in Spotify case study, 297\n\nroot cause and trigger, in postmortem anal‐\n\nysis results, 453 weekly reporting of, 218\n\ninfrastructure-centric view (configuration), 305 intent-based configuration, monitoring system,\n\n68\n\ninterpersonal risk taking, 362 interrupts, 355 triaging, 360 work overload and, 357\n\niterations for SLO quality improvement, 37\n\nJ JavaScript, 320 jitter, 235 JSON, 320\n\nconfiguration data in, 310 configuration items in Kubernetes repre‐\n\nsented as JSON objects, 322\n\nexamples of bad and good JSON output by\n\nJsonnet, 327\n\nJsonnet, 310, 320, 327\n\nconverting existing template to, 326 generating JSON for configuration evalua‐\n\ntion, 331-333\n\nguarding against abusive configurations in,\n\n333\n\nlibrary functions for outputting INI and\n\nXML, 321\n\nquick introduction to, 319 using with Kubernetes configurations, 323 validating JSON with JSONschema, 329 versioning in, 329 writing tests as Jsonnet files, 330\n\nK key details omitted in bad postmortem, 200 kill switches and manual overrides in autoscal‐\n\ning, 238\n\nKotter’s eight-step process for leading change,\n\n425, 427 in Waze case study, 427\n\nKubernetes, 135, 322-326 capabilities of, 322 example Kubernetes config, 322 GKE CreateCluster failure, incident response case study, 180-185\n\nintegrating the configuration language, 323\n\nIndex\n\n|\n\n463\n\nusing Jsonnet to build and deploy objects,\n\n334\n\nKübler-Ross Change Curve, 426, 427\n\nL languages, configuration\n\nchoosing language to store configuration in,\n\n308\n\nconfiguration syntax features, 311 failing to recognize configuration as pro‐ gramming language problem, 317 integrating a configuration language, 320 integrating in Kubernetes, 323 semantic validation, 311 using existing general-purpose scripting languges for configuration, 319\n\nlatency\n\ncalculations for multidatacenter design in\n\nAdWords example, 258\n\nfor API calls in Home Depot case study, 52 low latency with GCLB, 230 measurement in Home Depot case study, 51 SLOs in Home Depot case study, 52\n\nlatency SLI, 24\n\nAPI and HTTP server latency, 25 Launch Coordination Engineering (LCE)\n\nteams, 420\n\nleadership in geographically split SRE teams,\n\n418\n\nlegacy systems, 105\n\ndecommissioning filer-backed home direc‐\n\ntories, case study, 121-129 Lewin’s three-stage model for managing\n\nchange, 424\n\nlimited audience in bad postmortem example,\n\n202\n\nlimited availability phase (service lifecycle),\n\nSRE engagement in, 373\n\nline-card repair\n\ndesign first effort, Saturn line-card repair,\n\n110\n\nSaturn automated line-card repair work‐\n\nflow, 111\n\nSaturn vs. Jupiter line-card repair, 112 workflow before automation, 108\n\nlinters, 311 live version, 339 load\n\nartificial generation of, 350\n\n464\n\n|\n\nIndex\n\nbugs manifesting only at specific levels of\n\nload, 160\n\nload-based autoscaling, 239 testing, 159\n\nload balancer monitoring, 25 load balancing\n\ncombining strategies to manage load,\n\n239-240 precautions with, 242\n\nfor priority items in data processing pipe‐\n\nlines, 269\n\nGoogle Cloud, 225-235\n\ncase study, Pokémon GO on GCLB,\n\n231-235\n\nGCLB, high availability with, 231 GCLB, low latency with, 230 Global Software Load Balancer (GSLB),\n\n229\n\nGoogle Front End, 229 Maglev load balancer, 227 using anycast, 226\n\ntask-level, using with autoscaling on stateful\n\nsystems, 237\n\nusing with autoscaling, 236\n\nload shedding, 160, 239\n\ncase study, when load shedding attacks,\n\n240-243 precautions with load shedding, 242\n\nLogJoiner (AdWords example), 252\n\nscaling, calculations, 253 sharded, 254\n\nlogs, 64\n\nchoosing between log-based and metrics-\n\nbased monitoring systems, 65 logging change information, 161 logs-based monitoring systems, 64\n\nlong term goals (SRE team), 379 LOW (availability) requests, 90 low-traffic services, error budget alerting on,\n\n86-89 combining services, 87 generating artificial traffic, 87 lowering the SLO or increasing the window,\n\n88\n\nmaking service and infrastructure changes,\n\n87\n\nM machine learning, 265\n\nexample machine learning data processing\n\npipeline, 266\n\nMaglev, 226\n\nimplementing stabilized anycast with, 226 packet delivery using consistent hashing\n\nand connection tracking, 228 major incident response at PagerDuty, 188 manual overrides and kill switches in autoscal‐\n\ning, 238\n\nMapReduce, evaluating for use in AdWords\n\ndistributed system, 251\n\nmaturity matrix for data processing pipeline,\n\n281-284\n\nMcKinsey’s 7-S change management model,\n\n424\n\nmean time to repair (MTTR), 6 measurements\n\ndecision on what/how to measure for SLOs\n\nat Evernote, 46\n\neffectiveness of automated tasks, 105 end-to-end measurement for data process‐\n\ning pipeline SLOs, 270 importance in DevOps, 4 in DevOps and SRE, 8 in SRE with customers, 396 measurability in action items in postmor‐\n\ntems, 213\n\nmeasuring the SLIs, 26-28 measuring toil, 96-98, 101 metrics for Home Depot services, 51 sources of, for API and HTTP sever availa‐\n\nbility and latency SLI, 25\n\nwith service level indicators (SLIs), 20\n\nmeeting in person to resolve issues, 382 metrics, 64\n\n(see also measurements) choosing between metrics-based and logs-\n\nbased monitoring systems, 65\n\ncollecting in canary deployments, time lim‐\n\nits on, 349\n\nestablishing to evaluate team workload, 368 indicating work overload, 366 metric-based monitoring system, 65 quantifiable, in good postmortem example,\n\n213\n\nrestructuring at Evernote for cloud datacen‐\n\nters, 154\n\nselecting and evaluating for canary deploy‐\n\nments, 345-348\n\nselection for canarying in noninteractive\n\nsystems, 349\n\nvisible and useful, from monitoring system,\n\n69-72 dependencies, 70 implementing purposeful metrics, 72 intended changes to your service, 70 on resource usage saturation, 71 status of served traffic, 72\n\nmicroservices\n\ncombining for low-traffic services and error\n\nbudget alerting, 87\n\nlimiting how much an SRE team can\n\naccomplish, 371\n\nrunning hundreds on a shared platform,\n\ncase study, 139\n\nusing microservice approach to creating\n\ndata processing pipelines, 280\n\nmigrations, 99\n\nautomation in filer-backed home directory\n\ndecommissioning, 126\n\nMission Control program (SRE teams), 418 mistakes, handling appropriately, 382 mitigation delays, reducing, 162 mitigation in incident response, 184\n\nprioritizing mitigation above all else, 185\n\nmobility for SREs, 419 Moira portal, 125 monitoring, 61-74\n\nauditing and building shared dashboards in\n\nSRE with customers, 395 calculating SLOs from data, 46 choosing between monitoring systems,\n\nexamples, 65\n\ncovering in interviews with SREs, 400 data collection for causes of on-call paging,\n\n165\n\ndecisions on reliability and, 392 desirable features of monitoring strategy,\n\n62-64 alerts, 64 calculations support, 62 interfaces for data display, 63 speed of data retrieval, 62 for data processing pipeline, 282 implementation in common tooling adop‐\n\ntion in SRE case study, 436\n\nmanaging monitoring systems, 67-69 encouraging consistency, 68\n\nIndex\n\n|\n\n465\n\nloose coupling of components, 68 treating configuration as code, 67\n\nof release pipeline, 336 or prevention fixes for pager alerts, 164 providing visible and useful metrics, 69-72 implementing purposeful metrics, 72 on dependencies, 70 on resource usage saturation, 71 status of served traffic, 72\n\nrequirements in canary evaluation, 349 restructuring at Evernote for cloud datacen‐\n\nters, 154\n\nsources of data, 64 system monitoring in Spotify case study,\n\n294\n\ntesting alerting logic, 72\n\nMoonwalk, 124 multidatacenter design (AdWords example),\n\n257 evaluating dataflow, 259 scaling, calculations for, 258\n\nMurphy-Beyer effect, 6 mutations, idempotent and two-phase, 279\n\nN NALSD (see non-abstract large system design) negative acknowledgments (NACKs), 229 NFS/CIFS protocols, 121 non-abstract large system design (NALSD),\n\n245-261 about, 245 AdWords example, 246-259 design process, 246 distributed system, designing, 251-259 initial requirements, 247 running application on one machine,\n\n248\n\nkey questions in design iterations, 261 why non-abstract, 246\n\nnoninteractive systems, canarying in, 348 norming (SRE teams), 408 NO_SLO requests, 90\n\nO Omega, 134 on-call, 147-173\n\nactions in incident response, 191 balancing between geographically split SRE\n\nteams, 416\n\n466\n\n|\n\nIndex\n\nexample setup within Google, 149-153 example setups, Evernote case study,\n\n153-156\n\nflexibility in, 167-171\n\nscenario, a change in personal circum‐\n\nstances, 168-171\n\npager load, 156-167\n\nappropriate response times for pages,\n\n156\n\ncontributors to high pager load, 158 scenario, a team in overload, 157\n\nrecap from first SRE book, 148 team dynamics, 171-173\n\nscenario, a survive the week culture,\n\n171-173\n\noperational load (or operational workload), 355 operational overload (or work overload), 356 operations, 1\n\nand separation between development and\n\nproduction, 6\n\nbenefits provided by release engineering\n\nprinciples, 336\n\ncovering in interviews with SREs, 400 creating operational rigor with customers,\n\n397\n\ndeveloper involvement in, 379 empowering ops engineers in SRE, 172 placing your first SRE in operations team,\n\n401\n\nOperations or Ops Lead (OL), 177 organizational change (positive), rewarding,\n\n216\n\norganizational change management in SRE,\n\n423-439 case study, common tooling adoption in\n\nSRE, 432-439\n\ncase study, scaling Waze, 427-432 introduction to change management,\n\n424-427 Deming Cycle, 426 emotion-based models, 426 how the theories apply to SRE, 427 Kotter’s eight-step process, 425 Lewin’s three-stage model, 424 McKinsey’s 7-S model, 424 Prosci ADKAR model, 425\n\nSRE embraces change, 423\n\noutages\n\nproblem summary in postmortems, 200\n\nreporting weekly, 218 top triggers of, 453\n\noverload, identifying and recovering from,\n\n355-369 case study, perceived overload after organi‐ zational and workload changes, 360-365 decision on the solution, 362 lessons learned, 365 long-term actions to address, 365 mid-term actions to address, 364 problem statement, 361 results of actions, 365 short-term actions to address, 363\n\ncase study, work overload when half a team\n\nleaves, 358-360 decision on the solution, 359 implementation of the solution, 359 lessons learned, 360 problem statement, 358 from load to overload, 356-358 mitigation strategies, 366-369\n\nrecognizing symptoms of overload, 366 reducing overload and restoring team\n\nhealth, 367\n\nownership\n\naction items in good postmortem example,\n\n213\n\nmissing, in bad postmortem example, 202 of a service in geographically split SRE\n\nteam, 418\n\nof configurations, 312 viewing postmortem owners as leaders, 216\n\nP pager load, 156-167\n\nappropriate response times, 156 determining causes of high load, 158\n\nalerting, 163 data quality, 165 identification delay for root cause of\n\npages, 161\n\nmitigation delay, 162 new bugs in production, 159 preexisting bugs, 159 rigor of follow-up, 164 vigilance, 167\n\nscenario, a team in overload, 157 PagerDuty, incident response case study,\n\n188-191\n\npart-time work schedules for on-call engineers,\n\n170\n\nparticipatory management, 362 Paxos consensus algorithm, 257 pDNS (Production DNS), eliminating depend‐\n\nency on itself (case study), 140\n\npeak-end rule, 392 perceived overload, 356, 357\n\nafter organizational and workload changes,\n\ncase study, 360-365\n\nreducing by giving team members more\n\ncontrol and power, 367\n\nperformance\n\ncurrent performance as determinant of\n\nSLOs, 22\n\nKPI (key performance indicator), SLO com‐\n\npliance as, 19 performing (SRE team), 411\n\npartnering on architecture, 411 self-regulating workload, 411\n\npets vs. cattle approach, 103 pipeline components, 23\n\nSLIs for freshness, coverage, and correct‐\n\nness, 26\n\npipelines, data processing (see data processing\n\npipelines)\n\nPiper/Git-on-Borg version control system, 123 Plan-Do-Check-Act (or PDCA) Cycle, 426 planning by SRE and development teams, 379 platforms\n\neverything important becomes a platform,\n\n393\n\nrunning, reliability and, 392\n\nplaybooks, maintaining, 152\n\nentries for data processing pipelines, 272\n\npoint fixes for paging alerts, 164 Pokémon GO on GCLB, case study, 231-235 positive behaviors, 382 postmortems, 195-223\n\nbad postmortem example, 197-199\n\nflaws in, 199-202\n\nblameless, 8, 10 case study, rack decommission leading to\n\nservice latency, 196-197\n\nconducting joint postmortems with custom‐\n\ners, 397\n\ngood postmortem example, 203-212 good writing practices used, 212 organizational incentives for, 214-220\n\nIndex\n\n|\n\n467\n\nmodeling and enforcing blameless\n\nbehavior, 214\n\nresponding to postmortem culture fail‐\n\nures, 218\n\nrewarding postmortem outcomes, 215 sharing postmortems openly, 217\n\nresults of postmortem analysis, 453 templates for, 220\n\nGoogle template, 220 other industry templates, 220\n\ntools for, 221\n\nchecklist, 221 follow-up on postmortems, 222 other industry tools, 223 postmortem analysis, 222 postmortem creation, 221 storage, 221 precision in SLO alerts, 76 preparations for incidents, 192 preventative actions in postmortems, 200, 213 priorities\n\nadjusting according to SLOs and error\n\nbudget, 381\n\nbusiness and production, understanding,\n\n375\n\nprioritizing and triaging issues, 368 probers, 21, 46, 87\n\nuse at Evernote in monitoring, 46 problem summary (postmortems), 200 problems (simulated), practicing with custom‐\n\ners, 397\n\nprocess documentation for data processing\n\npipelines, 272\n\nproduction\n\nautomation, covering in interviews with\n\nSREs, 400\n\nboundaries between application develop‐\n\nment and, 6\n\ncontributors to high pager load, 158\n\npreexisting bugs, 159\n\ndata processing pipeline readiness for,\n\n281-284\n\nmanaging services in DevOps and SRE, 8 priorities, communication by SRE and\n\ndeveloper teams, 375\n\nproduction excellence reviews, 421 wisdom from, 5\n\nproduction interrupts, 99\n\n468\n\n|\n\nIndex\n\nProduction Readiness Reviews (PRRs), 281,\n\n371, 377\n\nproductionizing a service, 373 programming languages\n\nconfiguration as code, 309 designing accidental or ad hoc language fea‐\n\ntures in configuration system, 318 failing to recognize configuration as pro‐ gramming language problem, 317\n\nuse for configuration, 302 using existing general-purpose scripting languages for configuration, 319\n\nproject lifecycle complexity, case study, 134 Prometheus monitoring system, 69 Prosci ADKAR model, 425, 427, 433, 434\n\nmapping implementation phase of change\n\nproject, 435 protocol buffers, 318, 329 psychological safety\n\nin on-call rotations, 149 interpersonal risk taking, 362 regaining by identifying and alleviating psy‐\n\nchological stressors, 367 publication of postmortems, 202, 214\n\nQ quality of service (QoS)\n\nagreement on definition at Evernote, 47 maintaining while increasing feature veloc‐\n\nity, 44\n\nquality SLI, 24 QueryMap (AdWords example), 252\n\nscaling, calculations for\n\nin multidatacenter design, 258 QueryStore (AdWords example), 252 scaling, calculations for, 253\n\nR recall (SLO alerts), 76 recovery efforts (in postmortems), 200 region-level outages in data processing pipe‐\n\nline, 287\n\nregional groups of instances (RMiGs), autoscal‐\n\ners balancing instances across, 239 relationships, sustaining between SRE and\n\nother teams, 380-382 release candidate version, 339 release engineering, 335 and canarying, 338\n\nprinciples, 336-337\n\nreleases\n\nbenefits of frequent, smaller releases, 161 canarying (see canarying releases) shepherding, 99\n\nreliability\n\nas a partnership if you run a platform, 392 as most important feature, 391 balancing release velocity and, 337 configuration and, 302 considering work on as specialized role, 10 decided by users, not monitoring, 392 experimenting with relaxing SLOs, 41 improvements in, resulting from postmor‐\n\ntems, 216\n\nreliability hackathon for products at risk,\n\n381\n\nreliability targets and error budgets, 19\n\nrename-and-shame, 12 repeating incidents, finding causes of, 219 replication toil, 315\n\nautomating for configuration, 316\n\nreports on SLO compliance, 33 reproducible builds, 336 request-driven components, 23 requests\n\ngrouping request types into buckets of simi‐\n\nlar availability requirements, 89\n\nspecific mix of, bugs manifesting with, 160\n\nRequiem (postmortem storage tool), 221 reset time (SLO alerts), 76 resources\n\nmetrics about resource consumption, 63 monitoring resource usage, 71 resource planning for data processing pipe‐\n\nlines, 276\n\nunexpected growth in data processing pipe‐\n\nline, causing failures, 286\n\nresponse times to pages, 156 reusing code in data processing pipelines, 280 revenue coverage, 397 reviews, designing in SRE with customers, 396 revision control system, storing monitoring\n\nsystem configuration in, 67\n\nrisk analysis in SRE with customers, 396 risks and mitigations for first SRE team, 405 risks, identifying by SRE team to developer\n\nteam, 375 roadmaps, 379\n\nroll forward deployment vs. simple canary\n\ndeployment, 340-342\n\nrollback strategy for releases, 160 configuration changes, 313 promptly removing bugs from production,\n\n162\n\nrolling update strategy, 313 root causes and trigger (in postmortems), 200,\n\n213 routing\n\nanycast methodology, 226 RPCs (remote procedure calls) managing load with, 243 monitoring system metrics on, 70\n\nS satellites, 196 scaling, 236\n\n(see also autoscaling) calculations for AdWords NALSD example,\n\n249\n\ncalculations for LogJoiner, QueryStore,\n\nClickMap,, and QueryMap in AdWords example, 253\n\nduring limited availability phase of service\n\nlifecycle, 373\n\nof SRE to larger environments, 382-385 scalability of data processing pipeline, 282 Waze case study, 427-432\n\nscheduling on-call engineers, 167-171\n\nscenario, a change in personal circumstan‐\n\nces, 168-171 automating on-call scheduling, 168 planning for long-term breaks, 170 planning for part-time work schedules,\n\n170\n\nplanning for short-term swaps, 169 scripting languages, general-purpose, using for\n\nconfiguration system, 319\n\nsecurity policies for data processing pipeline,\n\nadhering to, 277\n\nself-healing, 160 self-regulating workload (SRE team), 411 self-service methods for users, 102, 127 semantic validation (configuration), 311 service complexity and forming more SRE\n\nteams, 413 pitfalls of team splits, 414 where to split the work, 413\n\nIndex\n\n|\n\n469\n\nservice level agreements (SLAs)\n\nand dependency failures in data processing\n\npipelines, 270\n\nGoogle and Evernote, 48 service level indicators (SLIs), 17\n\nabstracting your system into types of com‐\n\nponents, 22\n\narchitecture for example mobile phone\n\ngame, 23-25\n\nautomation of collection of data at Home\n\nDepot, 51\n\ncanary metrics and, 345 changing SLI implementation, 36 dashboards showing SLI trends, 33 explaining to customers, 395 for example game service SLOs, 446 implementation, 21 measurements with, 20 measuring, 26-28\n\ncalculating SLIs over previous week, 28 moving from specification to implementa‐\n\ntion, 25 API and HTTP server availability and\n\nlatency, 25\n\npipeline freshness, coverage, and cor‐\n\nrectness, 26\n\nspecifications, 21 using to calculate starter SLOs, 28 service level objectives (SLOs), 17-42\n\nadjusting priorities according to, 381 alerting on, 75-91\n\nconsiderations in, 75 low-traffic services and error budget\n\nalerting, 86-89\n\nmaking sure alerting is scalable, 89 pager alerts, 163 services with extreme availability goals,\n\n89\n\nsignificant events, 76-86\n\nby SRE and development teams for a ser‐\n\nvice, 379\n\ncontinuous improvement of SLO targets,\n\n34-37 improving quality of SLOs, 35 decision making using SLOs and error\n\nbudgets, 37-38\n\ndefining and measuring for data processing\n\npipelines, 268 data correctness, 269\n\n470\n\n|\n\nIndex\n\ndata freshness, 269 data isolation/load balancing, 269 end-to-end measurement, 270\n\ndefining before general availability phase of\n\nservice lifecycle, 373\n\ndesign and implementation by your first\n\nSRE, 402\n\nEvernote case study, 43-49\n\nbreaking down SLO wall between cus‐ tomer and cloud provider, 48\n\ncurrent state of SLOs, 49 introduction of SLOs, 45-47 why Evernote adopted SRE model, 44\n\nexample document for game service,\n\n445-448\n\nfor Spotify event delivery system operation,\n\n290 skewness SLO, 292 timeliness SLO, 291\n\nfundamental importance in SRE, 43 getting started with, 18-23\n\nmeasurements using SLIs, 20-23 reliability targets and error budgets, 19\n\nHome Depot case study, 49-59\n\napplying VALET to batch applications,\n\n57\n\nautomating VALET data collection, 55 evangelizing SLOs, 54 first set of SLOs, 52-54 future aspirations, 58 proliferation of SLOs, 57 SLO culture project, 50 using VALET in testing, 58\n\nimplementing, worked example, 23-34\n\nchoosing appropriate time window, 29 dashboards and reports, 33 documenting SLOs and error budget\n\npolicy, 32\n\nestablishing error budget policy, 31 getting stakeholder agreement, 30 measuring the SLIs, 26-28 moving from SLI specification to imple‐\n\nmentation, 25\n\nusing SLIs to calculate starter SLOs, 28\n\nin SRE with customers, 394\n\nauditing monitoring and building shared\n\ndashboards, 395\n\nmeasuring and renegotiating, 396\n\nmanaging by, in SRE, 5\n\nminimizing risk to by canarying releases,\n\n343 refining\n\nexperimenting with relaxing SLOs, 41 grading interaction importance, 39 modeling dependencies, 40 modeling user journeys, 39\n\ntracking performance over time at Evernote,\n\n155\n\nusing for SRE practices without SREs, 399 using to reduce toil, 102 why SREs need them, 17\n\nservice lifecycle, SRE engagement during,\n\n372-374 abandoned phase, 374 active development phase, 373 architecture and design phase, 372 deprecation phase, 374 general availability phase, 374 limited availability phase, 373 unsupported phase, 374\n\nservice reviews (regular), performing, 381 services\n\nmultiple, supporting with single SRE team,\n\n382\n\nSRE rollout for, 414\n\nsharded LogJoiner (AdWords example), 254 sharing postmortems openly, 217 shift length for on-call SREs, 167 short term goals (SRE team), 379 side effects, interleaving with configuration\n\nevaluation, 319 silos, elimination of, 2 simplicity, 133-141\n\ncase study, end-to-end API simplicity, 134 case study, project lifecycle complexity, 134 escaping in configuration, 308, 326 regaining\n\ncase study, eliminating pDNS depend‐\n\nency on itself, 140\n\ncase study, running hundreds of micro‐ services on shared platform, 139 case study, simplifying Display Ads Spi‐\n\nderweb, 137\n\nsite reliability engineering (see SRE) site reliability engineers (see SREs) skewness SLO (Spotify case study), 292 SLAs (see service level agreements) SLIs (see service level indicators)\n\nSLOs (see service level objectives) software engineering, 400 software-defined networking (SDN), 107 source control, using with configurations, 330 speed of data retrieval (monitoring system), 62 Spotify case study, 287-299\n\ncustomer integration and support, 293-298\n\ncapacity planning, 295 development process, 296 documentation, 294 incident handling, 297 system monitoring, 294\n\nevent delivery, 288 event delivery system design and architec‐\n\nture, 289 data collection, 289 data delivery, 290 extract, transform, load process, 290 event delivery system operation, 290-293\n\nSRE (site reliability engineering)\n\nabout, 4 comparing and contrasting with DevOps, 7 development by Google and others, 43 organizational context and fostering suc‐\n\ncessful adoption, 9-12 practices without SREs, 399 principles, 4-7\n\nmanaging by SLOs, 5 moving fast by reducing cost of failure, 6 sharing ownership with developers, 6 using same tooling regardless of job title,\n\n7\n\nworking to minimize toil, 5\n\nreaching beyond your walls, 391-398 reasons for adoption by Evernote, 44 rollout for services, 414\n\nSRE engagement model, 371-389\n\nending the relationship, 385-389 scaling SRE to larger environments, 382-385 service lifecycle, 372-374 setting up relationship with development\n\nteam, 375-380\n\nsustaining an effective ongoing relationship,\n\n380-382\n\nSRE teams\n\nadjusting structures to changing circum‐\n\nstances, 384\n\ncohesive distributed SRE teams, running,\n\n384\n\nIndex\n\n|\n\n471\n\nforming new team at Google, 149-153\n\nafterword, 152 initial scenario, 149 maintaining playbooks, 152 training, 150 lifecycles, 399-422\n\nmaking more SRE teams, 413-418 starting an SRE role, 400-403 suggested practices for running many\n\nteams, 418-421\n\nyour first SRE team, 403-412\n\non-call engineers in survive the week cul‐\n\nture, 171-173\n\nsingle team supporting multiple services,\n\n382\n\nstructuring multiple SRE team environ‐\n\nment, 383\n\nwork overload when half a team leaves, case\n\nstudy, 358-360\n\nSREs (site reliability engineers) being on-call (see on-call) exchange program at Google, 419 funding and hiring, 421 mobility for, 419 starting an SRE role, 400-403\n\nbootstrapping your first SRE, 402 distributed SREs, 403 finding your first SRE, 400 placing your first SRE, 401\n\ntraining for, 419 why they need SLOs, 17 work overload (see overload, identifying\n\nand recovering from)\n\nstaging, 159 stakeholders, getting agreement from on SLOs,\n\n30\n\nstateful systems\n\ntraffic teeing in, 351 using autoscaling with, 237\n\nstatsd metric aggregation daemon, 69 storage systems, 23\n\nalternatives to filer-based home directories,\n\n123\n\nstorming (first SRE team), 405 stressors (psychological), identifying and allevi‐\n\nating, 367\n\nstring interpolation, 318 sunk cost fallacy, 359\n\n472\n\n|\n\nIndex\n\nsuperfluous (undesirable) language in postmor‐\n\ntems, 201\n\nsupport for services, deciding on, 11 survive the week culture, 171-173\n\nempowering ops engineers in SRE, 172 improving team relations, 172\n\nswaps (short-term) in on-call scheduling, 169 symptoms of overload, 366 system architecture, covering in interviews with\n\nSREs, 401\n\nsystem diagrams for data processing pipeline,\n\n271\n\nsystemic fixes for pager alerts, 164 systems\n\ncomplexity of, measures for, 132 keeping architectural drawings of, 133 maturity levels, 18\n\nT TCP, 226 team, existing, converting to SRE team, 404,\n\n409 risks and mitigations for, 407\n\ntemplates\n\nfor postmortems, 220 templating engines, using for configuration,\n\n318\n\ntesting templates in a configuration system,\n\n330\n\nusing for configurations, 326\n\ntesting\n\nalerting logic in monitoring system, 72 automated tests, 336 for configuration systems, 330 for preexisting bugs in production environ‐\n\nment, 159\n\nquick fixes for bugs, 162 software testing to reduce bugs reaching\n\nproduction, 159\n\ntesting pyramid philosophy in Spotify\n\ndevelopment process, 296\n\nunit and integration testing, data processing\n\npipeline, 283\n\nThe Home Depot (THD) (see Home Depot,\n\nSLO case study)\n\nthree Cs of incident management, 176 tickets\n\nnew ticket SLO in perceived overload case\n\nstudy, 361",
      "page_number": 473
    },
    {
      "number": 53,
      "title": "Segment 53 (pages 485-493)",
      "start_page": 485,
      "end_page": 493,
      "detection_method": "topic_boundary",
      "content": "P1-P5 tickets in Evernote/Google relation‐\n\nship, 49\n\nSLOs in Home Depot case study, 53 support tickets for Home Depot services, 51 ticket toil, 98\n\ntiered SRE engagement, 140 time for postmortems, lacking, 219 time windows for SLOs, 29\n\nat Evernote, 46\n\ntimeliness SLO (Spotify case study), 291 toil\n\nconfiguration-induced, 315\n\nreducing, 316\n\ngetting ahead of by helping customers, 393 metrics in work overload, 367 working to minimize in SRE, 5\n\ntoil, eliminating, 93-129\n\ncase study, decommissioning filer-backed\n\nhome directories, 121-129 background, 121 decision on the solution, 122 design and implementation, 123 key components of the solution, 124-126 lessons learned, 127-129 problem statement, 121\n\ncase study, reducing toil in datacenter with\n\nautomation, 107-120 background, 107-110 decision on the solution, 110 design first effort, Saturn line-card\n\nrepair, 110\n\ndesign second effort, Saturn vs. Jupiter\n\nline-card repair, 112\n\nimplementation, Jupiter line-card repair,\n\n114\n\nimplementation, Saturn line-card repair\n\nwith automation, 111 lessons learned, 118-120 problem statement, 110\n\ncharacteristics and examples of toil, 94-96 measuring toil, 96-98 taxonomy of toil, 98-100 business processes, 98 cost engineering and capacity planning,\n\n100\n\nmigrations, 99 production interrupts, 99 release shepherding, 99\n\ntroubleshooting for opaque architec‐\n\ntures, 100\n\ntoil management strategies, 101-106 assessing risks in automation, 104 automating toil response, 104 engineering toil out of the system, 101 getting support from management and\n\ncolleagues, 103\n\nidentifying and measuring toil, 101 increasing uniformity, 103 legacy systems, 105 promoting toil reduction as a feature,\n\n103\n\nproviding self-service methods, 102 rejecting toil, 101 starting small, then improving, 103 starting with human-backed interfaces,\n\n102\n\nusing feedback to improve, 105 using open source and third-party tools,\n\n105\n\nusing SLOs to reduce toil, 102\n\ntooling\n\nin DevOps and SRE, 8 relationship with culture in DevOps, 3 using same tooling regardless of job title, 7\n\ntools\n\ncommon tooling adoption in SRE, case\n\nstudy, 432-439\n\nfor configuration systems, 330 for incident response, 190 for postmortems, 221 in configuration system, 310 increasing uniformity in, 103 using open source and third-party tools, 105\n\ntraffic teeing, 351 traffic volume metrics, 51\n\nSLOs in Home Depot case study, 52\n\ntraining\n\nfor incident response, 191 for SREs, 419 new SRE team at Google, 150 teaching customers, 393 to reduce perceived work overload, 364 using postmortems to train new engineers,\n\n218\n\ntravel for SRE teams, 420 triaging interrupts, 360 troubleshooting for opaque architectures, 100\n\nIndex\n\n|\n\n473\n\ntruncated exponential backoff, 235 two-phase mutations, 279\n\nU ulimit utility, 334 unhealthy instances, handling, 236 uniformity, increasing, 103, 128 unsupported phase, service lifecycle, 374 user behaviors causing bugs to manifest, 160 user journeys, modeling, 39 user-centric view (configuration), 305\n\nmandatory and optional configuration\n\nquestions, 306\n\nquestions asked should be close to user\n\ngoals, 305\n\nusers\n\ndeciding reliability, 392 helping past difficulties, 393\n\nutilization\n\ninfrastructure utilization in Home Depot\n\ncase study, 52\n\nmeasurement in Home Depot case study, 51 monitoring system metrics on saturation, 71\n\nV VALET (SLOs at Home Depot), 53 versioning, using with configurations, 312, 329 virtual machines run by cloud provider, availa‐\n\nbility of, 48 visualizations, 33\n\n474\n\n|\n\nIndex\n\n(see also dashboards) for data processing pipeline, 283\n\nvolume (traffic), 51\n\n(see also traffic volume metrics) in Home Depot VALET SLOs, 53\n\nW Waze, scaling, change management case study,\n\n427-432\n\nwisdom of production, 5 work overload, 356\n\n(see also overload, identifying and recover‐\n\ning from)\n\nworkloads\n\ndistributing between geographically split\n\nSRE teams, 416\n\nSRE teams having complete self-\n\ndetermination of, 411 SRE teams regulating, 403 workload coverage, 397\n\nX x20 filesystem, 123\n\nY YAML, 320\n\nconfigs written in, JSON and, 323 JSON object encoded as YAML streams in\n\nKubernetes, 322\n\nAbout the Editors\n\nBetsy Beyer is a Technical Writer for Google Site Reliability Engineering in NYC. She has previously written documentation for Google Datacenters and Hardware Operations teams. Before moving to New York, Betsy was a lecturer on technical writing at Stanford University. En route to her current career, Betsy studied Interna‐ tional Relations and English Literature, and holds degrees from Stanford and Tulane.\n\nNiall Richard Murphy has been working in internet infrastructure for 20 years. He is a company founder, a published author, a photographer, and holds degrees in Com‐ puter Science & Mathematics and Poetry Studies.\n\nDave Rensin is a Google SRE Director, previous O’Reilly author, and serial entrepre‐ neur. He holds a degree in Statistics.\n\nKent Kawahara is a Program Manager for Google’s Site Reliability Engineering team focused on Google Cloud Platform customers and is based in Sunnyvale, CA. In pre‐ vious Google roles, he managed technical and design teams to develop advertising support tools and worked with large advertisers and agencies on strategic advertising initiatives. Prior to Google, he worked in Product Management, Software QA, and Professional Services at two successful telecommunications startups. He holds a BS in Electrical Engineering and Computer Science from the University of California at Berkeley.\n\nStephen Thorne is a Senior Site Reliability Engineer at Google. He currently works in Customer Reliability Engineering, helping to integrate Google’s Cloud customers’ operations with Google SRE. Stephen learned how to be an SRE on the team that runs Google’s advertiser and publisher user interfaces, and later worked on App Engine. Before his time at Google, he fought against spam and viruses in his home country of Australia, where he also earned his BSc in Computer Science.\n\nColophon\n\nThe animal on the cover of The Site Reliability Workbook is a green thornytail iguana (Uracentron azureum), an arboreal lizard that lives in the Amazon and other South American rainforests.\n\nThe skin of this lizard is a very vivid green, interspersed with black stripes. As its name suggests, it also has rows of spikes on its tail, but the purpose of these is unclear. The green thornytail lizard is rather small, at about 3.5 inches long, and is difficult to spot in the wild because it tends to live high in the forest canopy (where it can more easily bask in sunlight). Ants make up the bulk of the lizard’s diet, which it catches by using a “sit and wait” method until insects wander by its location on a tree.\n\nMany of the animals on O’Reilly covers are endangered; all of them are important to the world. To learn more about how you can help, go to animals.oreilly.com.\n\nThe cover image is from a loose plate, source unknown. The cover fonts are URW Typewriter and Guardian Sans. The text font is Adobe Minion Pro; the heading font is Adobe Myriad Condensed; and the code font is Dalton Maag’s Ubuntu Mono.",
      "page_number": 485
    },
    {
      "number": 54,
      "title": "Segment 54 (pages 494-501)",
      "start_page": 494,
      "end_page": 501,
      "detection_method": "topic_boundary",
      "content": "",
      "page_number": 494
    },
    {
      "number": 55,
      "title": "Segment 55 (pages 502-508)",
      "start_page": 502,
      "end_page": 508,
      "detection_method": "topic_boundary",
      "content": "",
      "page_number": 502
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "content": "Presented by Google Cloud Launch Day Edition Companion to the Bestselling SRE Book\n\nThe Site Reliability Workbook\n\nPractical Ways to Implement SRE\n\nEdited by Betsy Beyer, Niall Richard Murphy, David K. Rensin, Kent Kawahara & Stephen Thorne",
      "content_length": 240,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 3,
      "content": "Praise for The Site Reliability Workbook\n\nThis new workbook will help people to take the sometimes theoretical and abstract concepts covered in Site Reliability Engineering out of the special context of the Googleplex and see how the same concepts work in other organizations. I’m especially excited to see more detail in the analysis of toil, how to apply SRE principles to data pipelines, and the case study reports discussing practical service level management.\n\n—Kurt Andersen, Site Reliability Engineer, LinkedIn\n\nThis practical hands-on guide to implementing SRE is valuable for engineers at companies of all sizes. It’s excellent to see this workbook being shared so that we can all move forward and build more reliable systems together. I was impressed with the level of detail shared; you can pick this book up and get started implementing SRE practices today.\n\n—Tammy Bütow, Principal SRE, Gremlin\n\nA timely reminder, from the team that made SRE a required practice for everyone operating at scale, that reliability is created by people. This book is full of practical examples of how to optimize for reliability by focusing on the interactions between users and engineers and between technology and tools, without losing sight of feature velocity. The result is a compelling, interesting, and thought-provoking companion to Site Reliability Engineering.\n\n—Casey Rosenthal, CTO, Backplane.io\n\nGoogle’s first book explained the what and why of SRE. This book shows you how to implement SRE at any company, startup or giant. Great work by the editorial team.\n\n—Jonah Horowitz, SRE at Stripe",
      "content_length": 1598,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 4,
      "content": "In 2016, Google dropped Site Reliability Engineering on the operations world, and the operations world was never the same. For the first time people had access to over 500 pages of distilled information on what Google does to run its planet-wide infrastructure. Most people liked the book, a handful didn’t, but nobody ignored it. It became a seminal work and an important touchstone for how people thought about SRE (especially the Google implementation of it) from that point on. But it was missing something….\n\nNow in 2018, Google returns to fill in a crucial piece of the puzzle: in their first volume they described what they do, but that didn’t help those who couldn’t see themselves in Google’s story. This book aims to demonstrate how Google does SRE— and how you can do it, too.\n\n—David N. Blank-Edelman, editor of Seeking SRE: Conversations about Running Production Systems at Scale and cofounder of the global set of SREcon conferences",
      "content_length": 946,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 5,
      "content": "The Site Reliability Workbook Practical Ways to Implement SRE\n\nEdited by Betsy Beyer, Niall Richard Murphy, David K. Rensin, Kent Kawahara, and Stephen Thorne\n\nBeijing Beijing\n\nBoston Boston\n\nFarnham Sebastopol Farnham Sebastopol\n\nTokyo Tokyo",
      "content_length": 242,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 6,
      "content": "The Site Reliability Workbook edited by Betsy Beyer, Niall Richard Murphy, David K. Rensin, Kent Kawahara, and Stephen Thorne\n\nCopyright © 2018 Google LLC. All rights reserved.\n\nPrinted in the United States of America.\n\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\n\nO’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles (http://oreilly.com/safari). For more information, contact our corporate/insti‐ tutional sales department: 800-998-9938 or corporate@oreilly.com.\n\nAcquisitions Editor: Nikki McDonald Developmental Editor: Virginia Wilson Production Editor: Kristen Brown Copyeditor: Rachel Monaghan Proofreader: Kim Cofer\n\nIndexer: Ellen Troutman-Zaig Interior Designer: David Futato Cover Designer: Karen Montgomery Illustrator: Rebecca Demarest\n\nAugust 2018:\n\nFirst Edition\n\nRevision History for the First Edition 2018-06-08: First Release 2018-06-22: Second Release\n\nSee http://oreilly.com/catalog/errata.csp?isbn=9781492029502 for release details.\n\nThis work is part of a collaboration between O’Reilly and Google. See our statement of editorial independ‐ ence.\n\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. The Site Reliability Workbook, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.\n\nThe views expressed in this work are those of the authors, and do not represent the publisher’s views. While the publisher and the authors have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the authors disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work. Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.\n\n978-1-492-02950-2\n\n[LSCH]",
      "content_length": 2185,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 7,
      "content": "Table of Contents\n\nForeword I. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xvii\n\nForeword II. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xix\n\nPreface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxiii\n\n1. How SRE Relates to DevOps. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Background on DevOps 2 No More Silos 2 Accidents Are Normal 3 Change Should Be Gradual 3 Tooling and Culture Are Interrelated 3 Measurement Is Crucial 4 Background on SRE 4 Operations Is a Software Problem 4 Manage by Service Level Objectives (SLOs) 5 Work to Minimize Toil 5 Automate This Year’s Job Away 6 Move Fast by Reducing the Cost of Failure 6 Share Ownership with Developers 6 Use the Same Tooling, Regardless of Function or Job Title 7 Compare and Contrast 7 Organizational Context and Fostering Successful Adoption 9 Narrow, Rigid Incentives Narrow Your Success 9 It’s Better to Fix It Yourself; Don’t Blame Someone Else 10 Consider Reliability Work as a Specialized Role 10 When Can Substitute for Whether 11 Strive for Parity of Esteem: Career and Financial 12 v",
      "content_length": 1378,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 8,
      "content": "Conclusion 12\n\nPart I.\n\nFoundations\n\n2.\n\nImplementing SLOs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 Why SREs Need SLOs 17 Getting Started 18 Reliability Targets and Error Budgets 19 What to Measure: Using SLIs 20 A Worked Example 23 Moving from SLI Specification to SLI Implementation 25 Measuring the SLIs 26 Using the SLIs to Calculate Starter SLOs 28 Choosing an Appropriate Time Window 29 Getting Stakeholder Agreement 30 Establishing an Error Budget Policy 31 Documenting the SLO and Error Budget Policy 32 Dashboards and Reports 33 Continuous Improvement of SLO Targets 34 Improving the Quality of Your SLO 35 Decision Making Using SLOs and Error Budgets 37 Advanced Topics 38 Modeling User Journeys 39 Grading Interaction Importance 39 Modeling Dependencies 40 Experimenting with Relaxing Your SLOs 41 Conclusion 42\n\n3. SLO Engineering Case Studies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 Evernote’s SLO Story 43 Why Did Evernote Adopt the SRE Model? 44 Introduction of SLOs: A Journey in Progress 45 Breaking Down the SLO Wall Between Customer and Cloud Provider 48 Current State 49 The Home Depot’s SLO Story 49 The SLO Culture Project 50 Our First Set of SLOs 52 Evangelizing SLOs 54 Automating VALET Data Collection 55 The Proliferation of SLOs 57 Applying VALET to Batch Applications 57 Table of Contents\n\n3. SLO Engineering Case Studies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 Evernote’s SLO Story 43 Why Did Evernote Adopt the SRE Model? 44 Introduction of SLOs: A Journey in Progress 45 Breaking Down the SLO Wall Between Customer and Cloud Provider 48 Current State 49 The Home Depot’s SLO Story 49 The SLO Culture Project 50 Our First Set of SLOs 52 Evangelizing SLOs 54 Automating VALET Data Collection 55 The Proliferation of SLOs 57 Applying VALET to Batch Applications 57 Table of Contents",
      "content_length": 1995,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 9,
      "content": "Using VALET in Testing 58 Future Aspirations 58 Summary 59 Conclusion 60\n\n4. Monitoring. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 Desirable Features of a Monitoring Strategy 62 Speed 62 Calculations 62 Interfaces 63 Alerts 64 Sources of Monitoring Data 64 Examples 65 Managing Your Monitoring System 67 Treat Your Configuration as Code 67 Encourage Consistency 68 Prefer Loose Coupling 68 Metrics with Purpose 69 Intended Changes 70 Dependencies 70 Saturation 71 Status of Served Traffic 72 Implementing Purposeful Metrics 72 Testing Alerting Logic 72 Conclusion 73\n\n5. Alerting on SLOs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 Alerting Considerations 75 Ways to Alert on Significant Events 76 1: Target Error Rate ≥ SLO Threshold 76 2: Increased Alert Window 78 3: Incrementing Alert Duration 79 4: Alert on Burn Rate 80 5: Multiple Burn Rate Alerts 82 6: Multiwindow, Multi-Burn-Rate Alerts 84 Low-Traffic Services and Error Budget Alerting 86 Generating Artificial Traffic 87 Combining Services 87 Making Service and Infrastructure Changes 87 Lowering the SLO or Increasing the Window 88 Extreme Availability Goals 89 Alerting at Scale 89\n\nTable of Contents\n\n|\n\nvii",
      "content_length": 1331,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 10,
      "content": "Conclusion 91\n\n6. Eliminating Toil. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 What Is Toil? 94 Measuring Toil 96 Toil Taxonomy 98 Business Processes 98 Production Interrupts 99 Release Shepherding 99 Migrations 99 Cost Engineering and Capacity Planning 100 Troubleshooting for Opaque Architectures 100 Toil Management Strategies 101 Identify and Measure Toil 101 Engineer Toil Out of the System 101 Reject the Toil 101 Use SLOs to Reduce Toil 102 Start with Human-Backed Interfaces 102 Provide Self-Service Methods 102 Get Support from Management and Colleagues 103 Promote Toil Reduction as a Feature 103 Start Small and Then Improve 103 Increase Uniformity 103 Assess Risk Within Automation 104 Automate Toil Response 104 Use Open Source and Third-Party Tools 105 Use Feedback to Improve 105 Case Studies 106 Case Study 1: Reducing Toil in the Datacenter with Automation 107 Background 107 Problem Statement 110 What We Decided to Do 110 Design First Effort: Saturn Line-Card Repair 110 Implementation 111 Design Second Effort: Saturn Line-Card Repair Versus Jupiter Line-Card Repair 113 Implementation 114 Lessons Learned 118 Case Study 2: Decommissioning Filer-Backed Home Directories 121 Background 121 Problem Statement 121 What We Decided to Do 122\n\n6. Eliminating Toil. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 What Is Toil? 94 Measuring Toil 96 Toil Taxonomy 98 Business Processes 98 Production Interrupts 99 Release Shepherding 99 Migrations 99 Cost Engineering and Capacity Planning 100 Troubleshooting for Opaque Architectures 100 Toil Management Strategies 101 Identify and Measure Toil 101 Engineer Toil Out of the System 101 Reject the Toil 101 Use SLOs to Reduce Toil 102 Start with Human-Backed Interfaces 102 Provide Self-Service Methods 102 Get Support from Management and Colleagues 103 Promote Toil Reduction as a Feature 103 Start Small and Then Improve 103 Increase Uniformity 103 Assess Risk Within Automation 104 Automate Toil Response 104 Use Open Source and Third-Party Tools 105 Use Feedback to Improve 105 Case Studies 106 Case Study 1: Reducing Toil in the Datacenter with Automation 107 Background 107 Problem Statement 110 What We Decided to Do 110 Design First Effort: Saturn Line-Card Repair 110 Implementation 111 Design Second Effort: Saturn Line-Card Repair Versus Jupiter Line-Card Table of Contents",
      "content_length": 2492,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 11,
      "content": "Design and Implementation 123 Key Components 124 Lessons Learned 127 Conclusion 129\n\n7. Simplicity. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131 Measuring Complexity 131 Simplicity Is End-to-End, and SREs Are Good for That 133 Case Study 1: End-to-End API Simplicity 134 Case Study 2: Project Lifecycle Complexity 134 Regaining Simplicity 135 Case Study 3: Simplification of the Display Ads Spiderweb 137 Case Study 4: Running Hundreds of Microservices on a Shared Platform 139 Case Study 5: pDNS No Longer Depends on Itself 140 Conclusion 141\n\nPart II. Practices\n\n8. On-Call. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147 Recap of “Being On-Call” Chapter of First SRE Book 148 Example On-Call Setups Within Google and Outside Google 149 Google: Forming a New Team 149 Evernote: Finding Our Feet in the Cloud 153 Practical Implementation Details 156 Anatomy of Pager Load 156 On-Call Flexibility 167 On-Call Team Dynamics 171 Conclusion 173\n\n9.\n\nIncident Response. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175 Incident Management at Google 176 Incident Command System 176 Main Roles in Incident Response 177 Case Studies 177\n\nCase Study 1: Software Bug—The Lights Are On but No One’s (Google)\n\nHome 177 Case Study 2: Service Fault—Cache Me If You Can 180 Case Study 3: Power Outage—Lightning Never Strikes Twice…\n\nUntil It Does 185 Case Study 4: Incident Response at PagerDuty 188 Putting Best Practices into Practice 191\n\nTable of Contents\n\n|\n\nix",
      "content_length": 1685,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 12,
      "content": "Incident Response Training 191 Prepare Beforehand 192 Drills 193 Conclusion 194\n\n10. Postmortem Culture: Learning from Failure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195 Case Study 196 Bad Postmortem 197 Why Is This Postmortem Bad? 199 Good Postmortem 203 Why Is This Postmortem Better? 212 Organizational Incentives 214 Model and Enforce Blameless Behavior 214 Reward Postmortem Outcomes 215 Share Postmortems Openly 217 Respond to Postmortem Culture Failures 218 Tools and Templates 220 Postmortem Templates 220 Postmortem Tooling 221 Conclusion 223\n\n11. Managing Load. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225 Google Cloud Load Balancing 225 Anycast 226 Maglev 227 Global Software Load Balancer 229 Google Front End 229 GCLB: Low Latency 230 GCLB: High Availability 231 Case Study 1: Pokémon GO on GCLB 231 Autoscaling 236 Handling Unhealthy Machines 236 Working with Stateful Systems 237 Configuring Conservatively 237 Setting Constraints 237 Including Kill Switches and Manual Overrides 238 Avoiding Overloading Backends 238 Avoiding Traffic Imbalance 239 Combining Strategies to Manage Load 239 Case Study 2: When Load Shedding Attacks 240 Conclusion 243 Table of Contents\n\n11. Managing Load. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225 Google Cloud Load Balancing 225 Anycast 226 Maglev 227 Global Software Load Balancer 229 Google Front End 229 GCLB: Low Latency 230 GCLB: High Availability 231 Case Study 1: Pokémon GO on GCLB 231 Autoscaling 236 Handling Unhealthy Machines 236 Working with Stateful Systems 237 Configuring Conservatively 237 Setting Constraints 237 Including Kill Switches and Manual Overrides 238 Avoiding Overloading Backends 238 Avoiding Traffic Imbalance 239 Combining Strategies to Manage Load 239 Case Study 2: When Load Shedding Attacks 240 Conclusion 243 Table of Contents",
      "content_length": 1987,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 13,
      "content": "12.\n\nIntroducing Non-Abstract Large System Design. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245 What Is NALSD? 245 Why “Non-Abstract”? 246 AdWords Example 246 Design Process 246 Initial Requirements 247 One Machine 248 Distributed System 251 Conclusion 260\n\n13. Data Processing Pipelines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263 Pipeline Applications 264 Event Processing/Data Transformation to Order or Structure Data 264 Data Analytics 265 Machine Learning 265 Pipeline Best Practices 268 Define and Measure Service Level Objectives 268 Plan for Dependency Failure 270 Create and Maintain Pipeline Documentation 271 Map Your Development Lifecycle 272 Reduce Hotspotting and Workload Patterns 275 Implement Autoscaling and Resource Planning 276 Adhere to Access Control and Security Policies 277 Plan Escalation Paths 277 Pipeline Requirements and Design 277 What Features Do You Need? 278 Idempotent and Two-Phase Mutations 279 Checkpointing 279 Code Patterns 280 Pipeline Production Readiness 281 Pipeline Failures: Prevention and Response 284 Potential Failure Modes 284 Potential Causes 286 Case Study: Spotify 287 Event Delivery 288 Event Delivery System Design and Architecture 289 Event Delivery System Operation 290 Customer Integration and Support 293 Summary 298 Conclusion 299 xi",
      "content_length": 1370,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 14,
      "content": "14. Configuration Design and Best Practices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301 What Is Configuration? 301 Configuration and Reliability 302 Separating Philosophy and Mechanics 303 Configuration Philosophy 303 Configuration Asks Users Questions 305 Questions Should Be Close to User Goals 305 Mandatory and Optional Questions 306 Escaping Simplicity 308 Mechanics of Configuration 308 Separate Configuration and Resulting Data 308 Importance of Tooling 310 Ownership and Change Tracking 312 Safe Configuration Change Application 312 Conclusion 313\n\n15. Configuration Specifics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315 Configuration-Induced Toil 315 Reducing Configuration-Induced Toil 316 Critical Properties and Pitfalls of Configuration Systems 317 Problem 317 Pitfall 2: Designing Accidental or Ad Hoc Language Features 318 Pitfall 3: Building Too Much Domain-Specific Optimization 318 Pitfall 4: Interleaving “Configuration Evaluation” with “Side Effects” 319 Pitfall 5: Using an Existing General-Purpose Scripting Language Like\n\nPython, Ruby, or Lua 319 Integrating a Configuration Language 320 Generating Config in Specific Formats 320 Driving Multiple Applications 321 Integrating an Existing Application: Kubernetes 322 What Kubernetes Provides 322 Example Kubernetes Config 322 Integrating the Configuration Language 323 Integrating Custom Applications (In-House Software) 326 Effectively Operating a Configuration System 329 Versioning 329 Source Control 330 Tooling 330 Testing 330 When to Evaluate Configuration 331 Very Early: Checking in the JSON 331\n\nxii\n\n|\n\nTable of Contents",
      "content_length": 1698,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 15,
      "content": "Middle of the Road: Evaluate at Build Time 332 Late: Evaluate at Runtime 332 Guarding Against Abusive Configuration 333 Conclusion 334\n\n16. Canarying Releases. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 335 Release Engineering Principles 336 Balancing Release Velocity and Reliability 337 What Is Canarying? 338 Release Engineering and Canarying 338 Requirements of a Canary Process 339 Our Example Setup 339 A Roll Forward Deployment Versus a Simple Canary Deployment 340 Canary Implementation 342 Minimizing Risk to SLOs and the Error Budget 343 Choosing a Canary Population and Duration 343 Selecting and Evaluating Metrics 345 Metrics Should Indicate Problems 345 Metrics Should Be Representative and Attributable 346 Before/After Evaluation Is Risky 347 Use a Gradual Canary for Better Metric Selection 347 Dependencies and Isolation 348 Canarying in Noninteractive Systems 348 Requirements on Monitoring Data 349 Related Concepts 350 Blue/Green Deployment 350 Artificial Load Generation 350 Traffic Teeing 351 Conclusion 351 Identifying and Recovering from Overload. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355 From Load to Overload 356 Case Study 1: Work Overload When Half a Team Leaves 358 Background 358 Problem Statement 358 What We Decided to Do 359 Implementation 359 Lessons Learned 360\n\n16. Canarying Releases. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 335 Release Engineering Principles 336 Balancing Release Velocity and Reliability 337 What Is Canarying? 338 Release Engineering and Canarying 338 Requirements of a Canary Process 339 Our Example Setup 339 A Roll Forward Deployment Versus a Simple Canary Deployment 340 Canary Implementation 342 Minimizing Risk to SLOs and the Error Budget 343 Choosing a Canary Population and Duration 343 Selecting and Evaluating Metrics 345 Metrics Should Indicate Problems 345 Metrics Should Be Representative and Attributable 346 Before/After Evaluation Is Risky 347 Use a Gradual Canary for Better Metric Selection 347 Dependencies and Isolation 348 Canarying in Noninteractive Systems 348 Requirements on Monitoring Data 349 Related Concepts 350 Blue/Green Deployment 350 Artificial Load Generation 350 Traffic Teeing 351 Conclusion 351 Identifying and Recovering from Overload. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355 From Load to Overload 356 Case Study 1: Work Overload When Half a Team Leaves 358 Background 358 Problem Statement 358 What We Decided to Do 359 Implementation 359 Lessons Learned 360\n\nPart III. Processes\n\nTable of Contents\n\n|\n\nxiii",
      "content_length": 2701,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 16,
      "content": "Case Study 2: Perceived Overload After Organizational and Workload\n\nChanges 360 Background 360 Problem Statement 361 What We Decided to Do 362 Implementation 363 Effects 365 Lessons Learned 365 Strategies for Mitigating Overload 366 Recognizing the Symptoms of Overload 366 Reducing Overload and Restoring Team Health 367 Conclusion 369\n\n18. SRE Engagement Model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371 The Service Lifecycle 372 Phase 1: Architecture and Design 372 Phase 2: Active Development 373 Phase 3: Limited Availability 373 Phase 4: General Availability 374 Phase 5: Deprecation 374 Phase 6: Abandoned 374 Phase 7: Unsupported 374 Setting Up the Relationship 375 Communicating Business and Production Priorities 375 Identifying Risks 375 Aligning Goals 375 Setting Ground Rules 379 Planning and Executing 379 Sustaining an Effective Ongoing Relationship 380 Investing Time in Working Better Together 380 Maintaining an Open Line of Communication 380 Performing Regular Service Reviews 381 Reassessing When Ground Rules Start to Slip 381 Adjusting Priorities According to Your SLOs and Error Budget 381 Handling Mistakes Appropriately 382 Scaling SRE to Larger Environments 382 Supporting Multiple Services with a Single SRE Team 382 Structuring a Multiple SRE Team Environment 383 Adapting SRE Team Structures to Changing Circumstances 384 Running Cohesive Distributed SRE Teams 384 Ending the Relationship 385 Case Study 1: Ares 385 Table of Contents\n\n18. SRE Engagement Model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371 The Service Lifecycle 372 Phase 1: Architecture and Design 372 Phase 2: Active Development 373 Phase 3: Limited Availability 373 Phase 4: General Availability 374 Phase 5: Deprecation 374 Phase 6: Abandoned 374 Phase 7: Unsupported 374 Setting Up the Relationship 375 Communicating Business and Production Priorities 375 Identifying Risks 375 Aligning Goals 375 Setting Ground Rules 379 Planning and Executing 379 Sustaining an Effective Ongoing Relationship 380 Investing Time in Working Better Together 380 Maintaining an Open Line of Communication 380 Performing Regular Service Reviews 381 Reassessing When Ground Rules Start to Slip 381 Adjusting Priorities According to Your SLOs and Error Budget 381 Handling Mistakes Appropriately 382 Scaling SRE to Larger Environments 382 Supporting Multiple Services with a Single SRE Team 382 Structuring a Multiple SRE Team Environment 383 Adapting SRE Team Structures to Changing Circumstances 384 Running Cohesive Distributed SRE Teams 384 Ending the Relationship 385 Case Study 1: Ares 385 Table of Contents",
      "content_length": 2712,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 17,
      "content": "Case Study 2: Data Analysis Pipeline 387 Conclusion 389\n\n19. SRE: Reaching Beyond Your Walls. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 391 Truths We Hold to Be Self-Evident 391 Reliability Is the Most Important Feature 391 Your Users, Not Your Monitoring, Decide Your Reliability 392 If You Run a Platform, Then Reliability Is a Partnership 392 Everything Important Eventually Becomes a Platform 393 When Your Customers Have a Hard Time, You Have to Slow Down 393 You Will Need to Practice SRE with Your Customers 393 How to: SRE with Your Customers 394 Step 1: SLOs and SLIs Are How You Speak 394 Step 2: Audit the Monitoring and Build Shared Dashboards 395 Step 3: Measure and Renegotiate 396 Step 4: Design Reviews and Risk Analysis 396 Step 5: Practice, Practice, Practice 397 Be Thoughtful and Disciplined 397 Conclusion 398\n\n20. SRE Team Lifecycles. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399 SRE Practices Without SREs 399 Starting an SRE Role 400 Finding Your First SRE 400 Placing Your First SRE 401 Bootstrapping Your First SRE 402 Distributed SREs 403 Your First SRE Team 403 Forming 404 Storming 405 Norming 408 Performing 411 Making More SRE Teams 413 Service Complexity 413 SRE Rollout 414 Geographical Splits 414 Suggested Practices for Running Many Teams 418 Mission Control 418 SRE Exchange 419 Training 419 Horizontal Projects 419 SRE Mobility 419\n\nTable of Contents\n\n|\n\nxv",
      "content_length": 1501,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 18,
      "content": "Travel 420 Launch Coordination Engineering Teams 420 Production Excellence 421 SRE Funding and Hiring 421 Conclusion 421\n\n21. Organizational Change Management in SRE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423 SRE Embraces Change 423 Introduction to Change Management 424 Lewin’s Three-Stage Model 424 McKinsey’s 7-S Model 424 Kotter’s Eight-Step Process for Leading Change 425 The Prosci ADKAR Model 425 Emotion-Based Models 426 The Deming Cycle 426 How These Theories Apply to SRE 427 Case Study 1: Scaling Waze—From Ad Hoc to Planned Change 427 Background 427 The Messaging Queue: Replacing a System While Maintaining Reliability 427 The Next Cycle of Change: Improving the Deployment Process 429 Lessons Learned 431 Case Study 2: Common Tooling Adoption in SRE 432 Background 432 Problem Statement 433 What We Decided to Do 434 Design 434 Implementation: Monitoring 436 Lessons Learned 436 Conclusion 439 449\n\n21. Organizational Change Management in SRE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423 SRE Embraces Change 423 Introduction to Change Management 424 Lewin’s Three-Stage Model 424 McKinsey’s 7-S Model 424 Kotter’s Eight-Step Process for Leading Change 425 The Prosci ADKAR Model 425 Emotion-Based Models 426 The Deming Cycle 426 How These Theories Apply to SRE 427 Case Study 1: Scaling Waze—From Ad Hoc to Planned Change 427 Background 427 The Messaging Queue: Replacing a System While Maintaining Reliability 427 The Next Cycle of Change: Improving the Deployment Process 429 Lessons Learned 431 Case Study 2: Common Tooling Adoption in SRE 432 Background 432 Problem Statement 433 What We Decided to Do 434 Design 434 Implementation: Monitoring 436 Lessons Learned 436 Conclusion 439 445\n\n21. Organizational Change Management in SRE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423 SRE Embraces Change 423 Introduction to Change Management 424 Lewin’s Three-Stage Model 424 McKinsey’s 7-S Model 424 Kotter’s Eight-Step Process for Leading Change 425 The Prosci ADKAR Model 425 Emotion-Based Models 426 The Deming Cycle 426 How These Theories Apply to SRE 427 Case Study 1: Scaling Waze—From Ad Hoc to Planned Change 427 Background 427 The Messaging Queue: Replacing a System While Maintaining Reliability 427 The Next Cycle of Change: Improving the Deployment Process 429 Lessons Learned 431 Case Study 2: Common Tooling Adoption in SRE 432 Background 432 Problem Statement 433 What We Decided to Do 434 Design 434 Implementation: Monitoring 436 Lessons Learned 436 Conclusion 439 449\n\nConclusion. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441\n\nC. Results of Postmortem Analysis. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 453\n\nIndex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 455\n\nxvi\n\n|\n\nTable of Contents",
      "content_length": 3035,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 19,
      "content": "Foreword I\n\nMark Burgess\n\nHaving introduced the first SRE book for O’Reilly, I am honored to be invited back for the sequel. In this book, the writing team is leaving the history of the first book to speak for itself and reaching out to a broader audience, offering direct experiences, case studies, and informal guidance. The broad themes will be familiar to anyone in IT, perhaps relabeled and reprioritized, and with a modern sense of business aware‐ ness. In place of technical descriptions, here we have user-facing services and their promises or objectives. We see human-computer systems originate from within the evolving business, intrinsic to its purpose, rather than as foreign meteorites impact‐ ing an unsuspecting and pristine infrastructure. Cooperation of all human-computer parts is the focus. Indeed, the book might be summarized as follows:\n\nCommit to clear promises that set service objectives, expectations, and levels. • Assess those promises continuously, with metrics and budgetary limits. • React quickly to keep and repair promises, be on-call, and guard autonomy to avoid new gatekeepers.\n\nKeeping promises reliably (to all stakeholders) depends on the stability of all their dependencies, of intent, and of the lives of the people involved (e.g., see Thinking in Promises). Remarkably, the human aspects of human-computer systems only grow alongside the perceived menace of scale: it turns out that automation doesn’t elimi‐ nate humans, after all; rather, it challenges us to reassert human needs across all scales, from the genesis of an individual idea to the massive deployments on behalf of a global user base.\n\nTeaching these lessons is a service challenge in its own right—and, like any service, hard-won knowledge is an iterative process. We make these lessons our own by ques‐ tioning, trying, failing, rehearsing, and perfecting them. There’s a wealth of material to ponder and adapt in the book, so let’s go.\n\nForeword I\n\n|\n\nxvii",
      "content_length": 1967,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 21,
      "content": "Foreword II\n\nAndrew Clay Shafer\n\nWhen I found out people were working on a second SRE book, I reached out and asked if I could write a few words. The principles from the first SRE book align so well with what I always imagined DevOps to be, and the practices are insightful, even when they aren’t 100% applicable outside of Google. After reading the principles from the first SRE book for the first time—embracing risk (Chapter 3), service level objectives (Chapter 4), and eliminating toil (Chapter 5)—I wanted to shout that mes‐ sage from the rooftops. “Embracing risk” resonated so much because I had used simi‐ lar language many times to help traditional organizations motivate change. Chapter 6 was always an implicit DevOps goal, both to allow humans more time for creative higher-order work and to allow them to be more human. But I really fell in love with “service level objectives.” I love that the language and the process create a dispassion‐ ate contract between operational considerations and delivering new functionality. The SRE, SWE (software engineer), and business all agree that the service has to be up to be valuable, and the SRE solution quantifies objectives to drive actions and pri‐ orities. The solution—make the service level a target, and when you are below the tar‐ get prioritize reliability over features—eliminates a classic conflict between operations and developers. This is a simple and elegant reframing that solves prob‐ lems by not having them. I give these three chapters as a homework assignment to almost everyone I’ve met since. They are that good. Everyone should know. Tell all your friends. I’ve told all mine.\n\nThe last decade of my career has been focused on helping people deliver software with better tools and process. Sometimes people say I contributed to inventing DevOps, but I was just in the position to borrow and steal successful patterns from across many different organizations and projects. I get embarrassed when people say “DevOps” was invented by anyone, but especially by me. I don’t consider myself an expert in anything but being inquisitive. My idealized DevOps always patterned off whatever information I could extract or infer from my friends, and my friends happened to be building the internet. I had the privilege of behind-the-scenes access\n\nForeword II\n\n|\n\nxix",
      "content_length": 2335,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 22,
      "content": "to people deploying and operating a representative sample of the world’s most incredible infrastructures and applications. DevOps symbolizes aspects of the emer‐ gent and existential optimizations required to rapidly deliver highly available soft‐ ware over the internet. The shift from software delivered on physical media to software delivered as a service forced an evolution of tools and processes. This evolu‐ tion elevated operations’ contribution to the value chain. If the systems are down, the software has no value. The good news is, you don’t have to wait for shipping the next shrink-wrapped box to change the software. For some, this is also the bad news. I simply had the opportunity and perspective to articulate the most successful patterns of the new way to a receptive audience.\n\nIn 2008, before we used the word DevOps like we do now, I’d been through the dot- com collapse, grad school, and a couple of venture-funded rollercoaster rides as a developer—searching Google for answers daily the whole time. I was working on Puppet full-time and I was fascinated by the potential for automation to transform IT organizations. Puppet thrust me into solving problems in the operations domain. At this time, Google used Puppet to manage their corporate Linux and OS X worksta‐ tions at a scale that pushed the capabilities of the Puppet server. We had a great working relationship with Google, but Google kept certain details of their internal operations secret as a matter of policy. I know this because I’m naturally curious and was constantly seeking more information. I always knew Google must have great internal tools and processes, but what these tools and processes were wasn’t always apparent. Eventually, I accepted that asking deep questions about Borg probably meant the current conversation wasn’t going very far. I would have loved to know more about how Google did everything, but this simply wasn’t allowed at the time. The significance of 2008 also includes the first O’Reilly Velocity conference and the year I met Patrick Debois. “DevOps” wasn’t a thing yet, but it was about to be. The time was right. The world was ready. DevOps symbolized a new way, a better way. If Site Reliability Engineering had been published then, I believe the community that formed would have rallied to fly the “eliminate toil” flag and the term DevOps might have never existed. Counterfactuals notwithstanding, I know the first SRE book per‐ sonally advanced my understanding of the possible, and I already helped many others just with the SRE principles.\n\nIn the early days of the DevOps movement, we consciously avoided codifying practi‐ ces because everything was evolving so rapidly and we didn’t want to set limits on what DevOps could become. Plus, we explicitly didn’t want anyone to “own” DevOps. When I wrote about DevOps in 2010, I made three distinct points. First, developers and operations can and should work together. Second, system administra‐ tion will become more and more like software development. Finally, sharing with a global community of practice accelerates and multiplies our collective capabilities. Around the same time, my friends Damon Edward and John Willis coined the acronym CAMS for Culture, Automation, Metrics, and Sharing. Jez Humble later\n\nxx\n\n|\n\nForeword II",
      "content_length": 3308,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 23,
      "content": "expanded this acronym to CALMS by adding Lean continuous improvement. What each of these words might mean in context deserves to be a full book, but I mention them here because Site Reliability Engineering explicitly references Culture, Automa‐ tion, Metrics, and Sharing alongside anecdotes about Google’s journey to continu‐ ously improve. By publishing the first SRE book, Google shared their principles and practices with the global community. Now I define DevOps simply as “optimizing human performance and experience operating software, with software, and with humans.” I don’t want to put words in anyone’s mouth, but that seems like a great way to describe SRE as well.\n\nUltimately, I know DevOps when I see it and I see SRE at Google, in theory and prac‐ tice, as one of the most advanced implementations. Good IT operations has always depended on good engineering, and solving operations problems with software has always been central to DevOps. Site Reliability Engineering makes the engineering aspect even more explicit. I cringe when I hear someone say “SRE versus DevOps.” For me, they are inseparable in time and space, as labels describing the sociotechnical systems that deliver modern infrastructure with software. I consider DevOps a loose generic set of principles and SRE an advanced explicit implementation. A parallel analogy would be the relationship between Agile and Extreme Programming (XP). True, XP is Agile, arguably the best of Agile, but not all organizations are capable of or willing to adopt XP.\n\nSome say “software is eating the world,” and I understand why they do, but “soft‐ ware” alone is not the right framing. Without the ubiquity of computational hard‐ ware connected with high-speed networks, much of what we take for granted as “software” would not be possible. This is an undeniable truth. What I think many miss in this conversation about technology are the humans. Technology exists because of humans and hopefully for humans, but if you look a little deeper, you also realize that the software we rely on, and probably take for granted, is largely depen‐ dent on humans. We rely on software, but software also relies on us. This is a single interconnected system of imperfect hardware—software and humans relying on themselves to build the future. Reliability is eating the world. Reliability is not just about technology, though, but also about people. The people and the technology form a single technosocial system. One nice feature about having Google share SRE with the rest of the industry is that any excuses about what kind of processes work at scale became invalid. Google set the highest standard for both reliability and scale. There might be valid arguments about why someone can’t adopt Google SRE practi‐ ces directly, but the guiding principles should still apply. As I look at the landscape of possibilities to build the future and the ambition to transform human experience with software, I see a lot of ambitious projects to quite literally connect everything to the internet. My math says that the successful projects will find themselves ingesting and indexing incredible amounts of data. Few, if any, will surpass the scale of Google today, but some will be the same size Google was when they started SRE and will\n\nForeword II\n\n|\n\nxxi",
      "content_length": 3305,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 24,
      "content": "need to solve the same reliability problems. I contend that in these cases, adopting tools and process that look suspiciously like SRE is not optional but existential— though there is no need to wait for that crisis because SRE principles and practices apply at any scale.\n\nSRE is usually framed as how Google does operations, but that misses the bigger pic‐ ture: SRE in practice enables software engineering, but also transforms architecture, security, governance, and compliance. When we leverage the SRE focus on providing a platform of services, all these other considerations get to have first-class emphasis, but where and how that happens may be quite different. Just like SRE (and hopefully DevOps) shifted more and more of the burden to software engineering, modern architecture and security practices evolve from slides, checklists, and hope to ena‐ bling the right behaviors with running code. Organizations adopting SRE principles and practices without revisiting these other aspects lose a huge opportunity to improve, and will also probably meet with internal resistance if the people who con‐ sider themselves responsible for those aspects are not converted into allies.\n\nI always enjoy learning. I read every word of the first SRE book straight through. I loved the language. I loved the anecdotes. I loved understanding more about how Google sees itself. But the question for me is always, “What behavior will I change?” Learning isn’t collecting information. Learning is changing behavior. This is easy to determine or even quantify in certain disciplines. You have learned to play a new song when you can play the song. You are better at chess when you win games against stronger players. Site Reliability Engineering, like DevOps, should not just be changing titles, but making definitive behavior changes, focusing on outcomes and obviously reliability. The Site Reliability Workbook promises to move forward from an enumeration of principles and practices by Google for Google toward more con‐ textual actions and behaviors. Site reliability is for everyone, but reliability doesn’t come from reading books. Here’s to embracing risk and eliminating toil.\n\nxxii\n\n|\n\nForeword II",
      "content_length": 2199,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 25,
      "content": "Preface\n\nWhen we wrote the original Site Reliability Engineering book, we had a goal: explain the philosophy and the principles of production engineering and operations at Goo‐ gle. The book was our attempt to share our teams’ best practices and lessons with the rest of the computing world. We assumed that the SRE book might appeal to a mod‐ est number of engineers working in large, reliability-conscious endeavors, and that both the quantity and the focus of the content would tend to limit the book’s appeal.\n\nAs it turned out, we were happily mistaken on both counts.\n\nTo our surprise and delight, the SRE book was a best-seller in computing for an exhilarating period after its release, and it was not just being sold or downloaded; it was being read. We received questions from around the world about the book, the team, the practices, and the outcomes. We were asked to speak about chapters, approaches, and incidents. We found ourselves in the unexpected position of having to turn down outside requests because we were out of cycles.\n\nLike most success disasters, the SRE book created an opportunity to respond with human effort (“Hire more people! Do more speaking engagements!”) or with some‐ thing more scalable. And being SREs, it will surprise few readers that we gravitated toward the latter approach. We decided to write a second SRE book—one that expan‐ ded on the content we were most frequently being asked to speak about, and that addressed the most common questions readers had about the first book.\n\nOut of the many different questions, requests, and comments we received about the first SRE book, two themes were particularly interesting to us; if left unaddressed, they were barriers to putting SRE’s lessons to productive use. These themes are collo‐ quially summarized as:\n\nPrinciples are interesting, but how do I turn them into practice in my project/ team/company?\n\nPreface\n\n|\n\nxxiii",
      "content_length": 1914,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 26,
      "content": "SRE’s approach would not work for me; it is feasible only in Google’s culture, and makes sense only at Google’s scale.\n\nThe purpose of this second SRE book is (a) to add more implementation detail to the principles outlined in the first volume, and (b) to dispel the idea that SRE is imple‐ mentable only at “Google scale” or in “Google culture.”\n\nThis volume is a companion to the previous work—not a new version. The two books should be taken together as a pair. You will get the most from this book if you’re already familiar with its predecessor. The first SRE book is available online for free.\n\nBy design, the structure of this book roughly follows the structure of the first volume. We want you to be able to read the chapters in tandem. Each chapter in this volume assumes you’re familiar with its counterpart from the previous work; our goal is to allow you to jump back and forth between principle and practice as you go. That way, you can use both volumes as ongoing references.\n\nNext, a word about ethos: We heard from some readers that while describing Goo‐ gle’s journey toward better operations we concentrated too much on just us. Some readers suggested that we were too removed from the practicalities of the world out‐ side Google, and failed to address the interaction of our ideas with the principles of DevOps. That’s an entirely fair criticism that we’ve tried to take to heart in this vol‐ ume.\n\nHowever, we do think that the highly opinionated nature of SRE contributes to its usefulness as a discipline. To us that’s a feature, not a bug. We do not advocate that SRE is the only way (or even universally the best way) to build and operate highly reliable systems. It’s just the way that has been most successful for us.\n\nWe’ll also spend a few words talking about how SRE and DevOps relate to each other. The important point to keep in mind is that they are not in conflict.\n\nWe’d like to acknowledge up front that this volume is necessarily incomplete. The SRE discipline is a broad field even inside the confines of Google, and it is evolving even faster now that it’s practiced widely outside of Google. Rather than go broad and superficial, we focused this volume to answer the most requested implementation details from the first volume.\n\nFinally, this volume and its predecessor are not intended to be gospel. Please don’t treat them that way. Even after all these years, we’re still finding conditions and cases that cause us to tweak (or in some cases, replace) previously firmly held beliefs. SRE is a journey as much as it is a discipline.\n\nWe hope that you enjoy what you read in these pages and find the book useful. Assembling it has been a labor of love. We’re delighted that there’s a growing and skilled community of SRE professionals with whom we can learn and improve.\n\nxxiv\n\n| Preface",
      "content_length": 2828,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 27,
      "content": "As always, your direct feedback is much appreciated. It teaches us something valuable every time you contribute it.\n\nHow to Read This Book This book is the companion volume to Google’s first book, Site Reliability Engineer‐ ing. To get the most out of this volume, we recommend that you have read, or can refer to, the first SRE book (available to read online for free at google.com/sre). The two works complement each other in the following ways:\n\nThe previous work was an introduction to principles and philosophy. This vol‐ ume concentrates on how those principles are applied. (In a few areas—particu‐ larly configuration management and canarying—we also cover some new ground to provide background for the practical treatment of other subjects.)\n\nThe earlier volume concentrated exclusively on how SRE is practiced at Google. This work includes perspectives from a number of other firms—from traditional enterprises (including The Home Depot and the New York Times) to digital natives (Evernote, Spotify, and others).\n\nThe first book didn’t directly refer to the larger operations community—espe‐ cially DevOps—whereas this book speaks directly to how SRE and DevOps relate to each other.\n\nThis volume assumes that you will bounce between this volume and its predecessor. You might, for example, read Chapter 4, “Service Level Objectives” in the first book and then read its implementation complement (Chapter 2) in this volume.\n\nThis book assumes that every chapter is just the starting point for a longer discussion and journey. Accordingly, this book is intended to be a conversation starter rather than the last word.\n\n—The Editors\n\nConventions Used in This Book The following typographical conventions are used in this book:\n\nItalic\n\nIndicates new terms, URLs, email addresses, filenames, and file extensions.\n\nConstant width\n\nUsed for program listings, as well as within paragraphs to refer to program ele‐ ments such as variable or function names, databases, data types, environment variables, statements, and keywords.\n\nPreface\n\n|\n\nxxv",
      "content_length": 2048,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 28,
      "content": "Constant width bold\n\nShows commands or other text that should be typed literally by the user.\n\nConstant width italic\n\nShows text that should be replaced with user-supplied values or by values deter‐ mined by context.\n\nThis element signifies a tip or suggestion.\n\nThis element signifies a general note.\n\nThis element indicates a warning or caution.\n\nUsing Code Examples Supplemental material (code examples, exercises, etc.) is available for download at http://g.co/SiteReliabilityWorkbookMaterials.\n\nThis book is here to help you get your job done. In general, if example code is offered with this book, you may use it in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing a CD-ROM of examples from O’Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a signifi‐ cant amount of example code from this book into your product’s documentation does require permission.\n\nWe appreciate, but do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: “The Site Reliability Workbook, edi‐ ted by Betsy Beyer, Niall Richard Murphy, David K. Rensin, Kent Kawahara, and Ste‐ phen Thorne (O’Reilly). Copyright 2018 Google LLC, 978-1-492-02950-2.”\n\nxxvi\n\n| Preface",
      "content_length": 1522,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 29,
      "content": "If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at permissions@oreilly.com.\n\nO’Reilly Safari\n\nSafari (formerly Safari Books Online) is a membership-based training and reference platform for enterprise, government, educators, and individuals.\n\nMembers have access to thousands of books, training videos, Learning Paths, interac‐ tive tutorials, and curated playlists from over 250 publishers, including O’Reilly Media, Harvard Business Review, Prentice Hall Professional, Addison-Wesley Pro‐ fessional, Microsoft Press, Sams, Que, Peachpit Press, Adobe, Focal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones & Bartlett, and Course Technology, among others.\n\nFor more information, please visit http://oreilly.com/safari.\n\nHow to Contact Us Please address comments and questions concerning this book to the publisher:\n\nO’Reilly Media, Inc. 1005 Gravenstein Highway North Sebastopol, CA 95472 800-998-9938 (in the United States or Canada) 707-829-0515 (international or local) 707-829-0104 (fax)\n\nWe have a web page for this book, where we list errata, examples, and any additional information. You can access this page at http://bit.ly/siteReliabilityWkbk.\n\nTo comment or ask technical questions about this book, send email to bookquestions@oreilly.com.\n\nFor more information about our books, courses, conferences, and news, see our web‐ site at http://www.oreilly.com.\n\nFind us on Facebook: http://facebook.com/oreilly\n\nFollow us on Twitter: http://twitter.com/oreillymedia\n\nWatch us on YouTube: http://www.youtube.com/oreillymedia\n\nPreface\n\n|\n\nxxvii",
      "content_length": 1726,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 30,
      "content": "Acknowledgments This book is the product of the enthusiastic and generous contributions of more than 100 people, including authors, tech writers, and reviewers. Each chapter has a byline for the individual authors and tech writers. We’d also like to take a moment to thank everyone not listed there.\n\nWe would like to thank the following reviewers for providing valuable (and some‐ times pointed) feedback: Abe Hassan, Alex Perry, Cara Donnelly, Chris Jones, Cody Smith, Dermot Duffy, Jarrod Todd, Jay Judkowitz, John T. Reese, Liz Fong-Jones, Mike Danese, Murali Suriar, Narayan Desai, Niccolò Cascarano, Ralph Pearson, Salim Virji, Todd Underwood, Vivek Rau, and Zoltan Egyed.\n\nWe would like to express our deepest appreciation to the following people for serving as our overall quality bar for this volume. They made substantial contributions throughout the entire volume: Alex Matey, Max Luebbe, Matt Brown, and JC van Winkel.\n\nAs the leaders of Google SRE, Benjamin Treynor Sloss and Ben Lutch were this book’s primary executive sponsors within Google; their strong and unwavering belief in a follow-up project that was a worthy companion of the first SRE book was essen‐ tial to making this book happen.\n\nWhile the authors and technical writers are specifically acknowledged in each chap‐ ter, we’d like to recognize those that contributed to each chapter by providing thoughtful input, discussion, and review. In chapter order, they are:\n\nChapter 2: Javier Kohen, Patrick Eaton, Richard Bondi, Yaniv Aknin\n\nChapter 4: Alex Matey, Clint Pauline, Cody Smith, JC van Winkel, Ola Kłapciń‐ ska, Štěpán Davidovič\n\nChapter 5: Alex Matey, Clint Pauline, Cody Smith, Iain Cooke, JC van Winkel, Štěpán Davidovič\n\nChapter 6: Dermot Duffy, James O’Keeffe, Stephen Thorne\n\nChapter 7: Mark Brody\n\nChapter 8: Alex Perry, Alex Hidalgo, David Huska, Sebastian Kirsch, Sabrina Farmer, Steven Carstensen, Liz Fong-Jones, Nandu Shah (Evernote), Robert Hol‐ ley (Evernote)\n\nChapter 9: Alex Hidalgo, Alex Matey, Alex Perry, Dave Rensin, Matt Brown, Tor Gunnar Houeland, Trevor Strohman\n\nChapter 10: John T. Reese\n\nxxviii\n\n| Preface",
      "content_length": 2116,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 31,
      "content": "Chapter 11: Daniel E. Eisenbud, Dave Rensin, Dmitry Nefedkin, Dževad Tru‐ mić, Edward Wu (Niantic), JC van Winkel, Lucas Pereira, Luke Stone, Matt Brown, Natalia Sakowska, Niall Richard Murphy, Phil Keslin (Niantic), Rita Sodt, Scott Devoid, Simon Donovan, Tomasz Kulczyński\n\nChapter 12: Ivo Krka, Matt Brown, Nicky Nicolosi, Tanya Reilly\n\nChapter 13: Bartosz Janota (Spotify), Cara Donnelly, Chris Farrar, Johannes Rußek (Spotify), Max Charas, Max Luebbe, Michelle Duffy, Nelson Arapé (Spo‐ tify), Riccardo Petrocco (Spotify), Rickard Zwahlen (Spotify), Robert Stephenson (Spotify), Steven Thurgood\n\nChapter 14: Charlene Perez, Dave Cunningham, Dave Rensin, JC van Winkel, John Reese, Stephen Thorne\n\nChapter 15: Alex Matey, Bo Shi, Charlene Perez, Dave Rensin, Eric Johnson, Juliette Benton, Lars Wander, Mike Danese, Narayan Desai, Niall Richard Mur‐ phy, Štěpán Davidovič, Stephen Thorne\n\nChapter 16: Alex Matey, Liz Fong-Jones, Max Luebbe\n\nChapter 17: Andrew Harvey, Aleksander Szymanek, Brad Kratochvil, Ed Wehr‐ wein, Duncan Sargeant, Jessika Reissland, Matt Brown, Piotr Sieklucki and Tho‐ mas Adamcik\n\nChapter 18: Brian Balser (New York Times), Deep Kapadia (New York Times), Michelle Duffy, Xavier Llorà\n\nChapter 19: Matt Brown\n\nChapter 20: Brian Balser (New York Times), Christophe Kalt, Daniel Rogers, Max Luebbe, Niall Richard Murphy, Ramón Medrano Llamas, Richard Bondi, Steven Carstensen, Stephen Thorne, Steven Thurgood, Thomas Wright\n\nChapter 21: Dave Rensin, JC Van Winkel, Max Luebbe, Ronen Louvton, Ste‐ phen Thorne, Tom Feiner, Tsiki Rosenman\n\nWe are also grateful to the following contributors, who supplied significant expertise or resources, or had some otherwise excellent effect on this work: Caleb Donaldson, Charlene Perez, Evan Leonard, Jennifer Petoff, Juliette Benton, and Lea Miller.\n\nWe very much appreciate the thoughtful and in-depth feedback that we received from industry reviewers: Mark Burgess, David Blank-Edelman, John Looney, Jennifer Davis, Björn Rabenstein, Susan Fowler, Thomas A. Limoncelli, James Meickle, Theo Schlossangle, Jez Humble, Alice Goldfuss, Arup Chakrabarti, John Allspaw, Angus Lees, Eric Liang, Brendan Gregg, and Bryan Liles.\n\nWe would like to extend a special thanks to Shylaja Nukala, who generously commit‐ ted the time and skills of the SRE Technical Writing Team. She enthusiastically sup‐ ported their necessary and valued efforts.\n\nPreface\n\n|\n\nxxix",
      "content_length": 2417,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 32,
      "content": "Thanks also to the O’Reilly Media team—Virginia Wilson, Kristen Brown, Rachel Monaghan, Nikki McDonald, Melanie Yarbrough, and Gloria Lukos—for their help and support making the book a reality in our ambitious timeline.\n\nAnd an extra special thanks to Niall Richard Murphy: despite the fact that he moved on from Google before this book hit the shelves, his continual insights and dedication were crucial for getting a goodly portion of meaningful content over the finish line. His leadership, thoughtfulness, tenacity, and wit are nothing short of inspirational!\n\nFinally, the editors would also like to personally thank the following people:\n\nBetsy Beyer: To Grandmother, my go-to source for encouragement, inspiration, popcorn, pep, and puzzling. You made both this book and my everyday life bet‐ ter! To Duzzie, Hammer, Joan, Kiki, and Mini (note the alphabetical order—ha!) who helped shape me into the obsessive writer slash person I am today. And of course, Riba, for providing the DMD and other provisions necessary to fuel this effort.\n\nNiall Richard Murphy: To Léan, Oisín, Fiachra, and Kay, north stars. To some‐ one whose protestations of self-interest are entirely out of odds with how he acts. To Sharon, more influential than she knows. To Alex, in a light-filled sitting room, with a cup of tea, a book, a box of dice, and thou.\n\nStephen Thorne: To my mum and dad, who have always encouraged me to push myself. To my wife, Elspeth. To my colleagues who have given me more respect and encouragement than I think I deserve: Ola, Štěpán, Perry, and David.\n\nDave Rensin: After I wrote my first book, I swore I’d never write another. That was six books ago and I say exactly the same thing each time. To my wife, Lia, who gives me the space to do it and never says “I told you so.” (Even though she tells me so.) To my colleagues at Google—and particularly to the family of SRE— who have taught me more these last few years about production engineering at scale than I had learned in the previous 20. Finally, to Benjamin Treynor Sloss, who interviewed me and convinced me to come to Google in the first place.\n\nKent Kawahara: To my parents, Denby and Setsuko, and my Aunt Asako for helping me get to where I am. To my siblings, Randy and Patti, for their support over the years. To my wife, Angela, and my sons, Ryan, Ethan, and Brady, for their love and support. Finally, to the core team of Dave, Betsy, Niall, Juliette, and Stephen, I feel honored to have worked with you on this project.\n\nxxx\n\n| Preface",
      "content_length": 2519,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 33,
      "content": "CHAPTER 1 How SRE Relates to DevOps class SRE implements interface DevOps\n\nBy Niall Richard Murphy, Liz Fong-Jones, and Betsy Beyer, with Todd Underwood, Laura Nolan, and Dave Rensin\n\nOperations, as a discipline, is hard.1 Not only is there the generally unsolved question of how to run systems well, but the best practices that have been found to work are highly context-dependent and far from widely adopted. There is also the largely unaddressed question of how to run operations teams well. Detailed analysis of these topics is generally thought to originate with Operational Research devoted to improving processes and output in the Allied military during World War II, but in reality, we have been thinking about how to operate things better for millennia.\n\nYet, despite all this effort and thought, reliable production operations remains elusive —particularly in the domains of information technology and software operability. The enterprise world, for example, often treats operations as a cost center,2 which makes meaningful improvements in outcomes difficult if not impossible. The tre‐ mendous short-sightedness of this approach is not yet widely understood, but dissat‐ isfaction with it has given rise to a revolution in how to organize what we do in IT.\n\n1 Note that as this discussion appears in a book about SRE, some of this discussion is specific to software ser‐\n\nvice operations, as opposed to IT operations.\n\n2 Mary Poppendieck has an excellent article on this called “The Cost Center Trap.” Another way in which this approach fails is when a very large and improbable disaster completely wipes out the cost savings you made by moving to a low-grade operations model (c.f. the British Airways outage in May 2017).\n\n1",
      "content_length": 1738,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 34,
      "content": "That revolution stemmed from trying to solve a common set of problems. The newest solutions to these problems are called by two separate names—DevOps and Site Reli‐ ability Engineering (SRE). Although we talk about them individually as if they are totally separate reactions to the enterprise mentality just described,3 we hope to per‐ suade you that in fact they are much more alike, and practitioners of each have much more in common, than you might assume.\n\nBut first, some background on the key tenets of each.\n\nBackground on DevOps DevOps is a loose set of practices, guidelines, and culture designed to break down silos in IT development, operations, networking, and security. Articulated by John Willis, Damon Edwards, and Jez Humble, CA(L)MS—which stands for Culture, Automation, Lean (as in Lean management; also see continuous delivery), Measure‐ ment, and Sharing—is a useful acronym for remembering the key points of DevOps philosophy. Sharing and collaboration are at the forefront of this movement. In a DevOps approach, you improve something (often by automating it), measure the results, and share those results with colleagues so the whole organization can improve. All of the CALMS principles are facilitated by a supportive culture.\n\nDevOps, Agile, and a variety of other business and software reengineering techniques are all examples of a general worldview on how best to do business in the modern world. None of the elements in the DevOps philosophy are easily separable from each other, and this is essentially by design. There are, however, a few key ideas that can be discussed in relative isolation.\n\nNo More Silos The first key idea is no more silos. This is a reaction to a couple ideas:\n\nThe historically popular but now increasingly old-fashioned arrangement of sep‐ arate operations and development teams\n\nThe fact that extreme siloization of knowledge, incentives for purely local opti‐ mization, and lack of collaboration have in many cases been actively bad for business4\n\n3 Of course, there are a number of other potential reactions. For example, ITIL® is another approach to IT man‐\n\nagement that advocates for better standardization.\n\n4 Note also that because this is a complicated world, there are also positive effects to partitioning, silos, and the\n\nlike, but the downsides seem to be particularly pernicious in the domain of operations.\n\n2\n\n|\n\nChapter 1: How SRE Relates to DevOps",
      "content_length": 2422,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 35,
      "content": "Accidents Are Normal The second key idea is that accidents are not just a result of the isolated actions of an individual, but rather result from missing safeguards for when things inevitably go wrong.5 For example, a bad interface inadvertently encourages the wrong action under pressure; a system misfeature makes failure inevitable if the (unarticulated) wrong circumstances occur; broken monitoring makes it impossible to know if some‐ thing is wrong, never mind what is wrong. Some more traditionally minded busi‐ nesses possess the cultural instinct to root out the mistake maker and punish them. But doing so has its own consequences: most obviously, it creates incentives to con‐ fuse issues, hide the truth, and blame others, all of which are ultimately unprofitable distractions. Therefore, it is more profitable to focus on speeding recovery than pre‐ venting accidents.\n\nChange Should Be Gradual The third key idea is that change is best when it is small and frequent. In environ‐ ments where change committees meet monthly to discuss thoroughly documented plans to make changes to the mainframe configuration, this is a radical idea. How‐ ever, this is not a new idea. The notion that all changes must be considered by experi‐ enced humans and batched for efficient consideration turns out to be more or less the opposite of best practice. Change is risky, true, but the correct response is to split up your changes into smaller subcomponents where possible. Then you build a steady pipeline of low-risk change out of regular output from product, design, and infra‐ structure changes.6 This strategy, coupled with automatic testing of smaller changes and reliable rollback of bad changes, leads to approaches to change management like continuous integration (CI) and continuous delivery or deployment (CD).\n\nTooling and Culture Are Interrelated Tooling is an important component of DevOps, particularly given the emphasis on managing change correctly—today, change management relies on highly specific tools. Overall, however, proponents of DevOps strongly emphasize organizational culture—rather than tooling—as the key to success in adopting a new way of work‐ ing. A good culture can work around broken tooling, but the opposite rarely holds true. As the saying goes, culture eats strategy for breakfast. Like operations, change itself is hard.\n\n5 See https://en.wikipedia.org/wiki/Normal_Accidents.\n\n6 Higher-risk changes, or those unvalidatable by automatic means, should obviously still be vetted by humans,\n\nif not enacted by them.\n\nBackground on DevOps\n\n|\n\n3",
      "content_length": 2579,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 36,
      "content": "Measurement Is Crucial Finally, measurement is particularly crucial in the overall business context of, for example, breaking down silos and incident resolution. In each of these environments, you establish the reality of what’s happening by means of objective measurement, verify that you’re changing the situation as you expect, and create an objective foun‐ dation for conversations that different functions agree upon. (This applies in both business and other contexts, such as on-call.)\n\nBackground on SRE Site Reliability Engineering (SRE) is a term (and associated job role) coined by Ben Treynor Sloss, a VP of engineering at Google.7 As we can see in the previous section, DevOps is a broad set of principles about whole-lifecycle collaboration between oper‐ ations and product development. SRE is a job role, a set of practices (described next) we’ve found to work, and some beliefs that animate those practices. If you think of DevOps as a philosophy and an approach to working, you can argue that SRE imple‐ ments some of the philosophy that DevOps describes, and is somewhat closer to a concrete definition of a job or role than, say, “DevOps engineer.”8 So, in a way, class SRE implements interface DevOps.\n\nUnlike the DevOps movement, which originated from collaborations between leaders and practitioners at multiple companies, SRE at Google inherited much of its culture from the surrounding company before the term SRE became widely popularized across the industry. Given that trajectory, the discipline as a whole currently does not foreground cultural change by default quite as much as DevOps. (That doesn’t imply anything about whether cultural change is necessary to do SRE in an arbitrary orga‐ nization, of course.)\n\nSRE is defined by the following concrete principles.\n\nOperations Is a Software Problem The basic tenet of SRE is that doing operations well is a software problem. SRE should therefore use software engineering approaches to solve that problem. This is across a wide field of view, encompassing everything from process and business\n\n7 The history of SRE at Google is that it sprang from a precursor team, which was more operationally focused,\n\nand Ben provided the impetus for treating the problem from an engineering standpoint.\n\n8 This is a misnomer in a large number of ways, perhaps the most fundamental being that you can’t just hire\n\nsome people, call them “DevOps engineers,” and expect benefits immediately. You have to buy into the whole philosophy of changing how you work in order to benefit. As Andrew Clay Shafer says, “People sell DevOps, but you can’t buy it.” And, as Seth Vargo points out in “The 10 Myths of DevOps”, you can’t “hire a DevOp to fix your organization.”\n\n4\n\n|\n\nChapter 1: How SRE Relates to DevOps",
      "content_length": 2769,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 37,
      "content": "change to similarly complicated but more traditional software problems, such as rewriting a stack to eliminate single points of failure in business logic.\n\nManage by Service Level Objectives (SLOs) SRE does not attempt to give everything 100% availability. As discussed in our first book, Site Reliability Engineering, this is the wrong target for a number of reasons. Instead, the product team and the SRE team select an appropriate availability target for the service and its user base, and the service is managed to that SLO.9 Deciding on such a target requires strong collaboration from the business. SLOs have cultural implications as well: as collaborative decisions among stakeholders, SLO violations bring teams back to the drawing board, blamelessly.\n\nWork to Minimize Toil For SRE, any manual, structurally mandated operational task is abhorrent. (That doesn’t mean we don’t have any such operations: we have plenty of them. We just don’t like them.) We believe that if a machine can perform a desired operation, then a machine often should. This is a distinction (and a value) not often seen in other organizations, where toil is the job, and that’s what you’re paying a person to do. For SRE in the Google context, toil is not the job—it can’t be. Any time spent on opera‐ tional tasks means time not spent on project work—and project work is how we make our services more reliable and scalable.\n\nPerforming operational tasks does, however, by “the wisdom of production,” provide vital input into decisions. This work keeps us grounded by providing real-time feed‐ back from a given system. Sources of toil need to be identifiable so you can minimize or eliminate them. However, if you find yourself in a position of operational under‐ load, you may need to push new features and changes more often so that engineers remain familiar with the workings of the service you support.\n\nThe Wisdom of Production A note on “the wisdom of production”: by this phrase, we mean the wisdom you get from something running in production—the messy details of how it actually behaves, and how software should actually be designed, rather than a whiteboarded view of a service isolated from the facts on the ground. All of the pages you get, the tickets the team gets, and so on, are a direct connection with reality that should inform better system design and behavior.\n\n9 A service level objective is a target for performance of a particular metric (e.g., available 99.9% of the time).\n\nBackground on SRE\n\n|\n\n5",
      "content_length": 2507,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 38,
      "content": "Automate This Year’s Job Away The real work in this area is determining what to automate, under what conditions, and how to automate it.\n\nSRE as practiced in Google has a hard limit of how much time a team member can spend on toil, as opposed to engineering that produces lasting value: 50%. Many peo‐ ple think of this limit as a cap. In fact, it’s much more useful to think of it as a guaran‐ tee—an explicit statement, and enabling mechanism, for taking an engineering-based approach to problems rather than just toiling at them over and over.\n\nThere is an unintuitive and interesting interaction between this benchmark and how it plays out when we think about automation and toil. Over time, an SRE team winds up automating all that it can for a service, leaving behind things that can’t be automa‐ ted (the Murphy-Beyer effect). Other things being equal, this comes to dominate what an SRE team does unless other actions are taken. In the Google environment, you tend to either add more services, up to some limit that still supports 50% engi‐ neering time, or you are so successful at your automation that you can go and do something else completely different instead.\n\nMove Fast by Reducing the Cost of Failure One of the main benefits of SRE engagement is not necessarily increased reliability, although obviously that does happen; it is actually improved product development output. Why? Well, a reduced mean time to repair (MTTR) for common faults results in increased product developer velocity, as engineers don’t have to waste time and focus cleaning up after these issues. This follows from the well-known fact that the later in the product lifecycle a problem is discovered, the more expensive it is to fix. SREs are specifically charged with improving undesirably late problem discovery, yielding benefits for the company as a whole.\n\nShare Ownership with Developers Rigid boundaries between “application development” and “production” (sometimes called programmers and operators) are counterproductive. This is especially true if the segregation of responsibilities and classification of ops as a cost center leads to power imbalances or discrepancies in esteem or pay.\n\nSREs tend to be inclined to focus on production problems rather than business logic problems, but as their approach brings software engineering tools to bear on the problem, they share skill sets with product development teams. In general, an SRE has particular expertise around the availability, latency, performance, efficiency, change management, monitoring, emergency response, and capacity planning of the service(s) they are looking after. Those specific (and usually well-defined) competen‐ cies are the bread-and-butter of what SRE does for a product and for the associated\n\n6\n\n|\n\nChapter 1: How SRE Relates to DevOps",
      "content_length": 2812,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 39,
      "content": "product development team.10 Ideally, both product development and SRE teams should have a holistic view of the stack—the frontend, backend, libraries, storage, kernels, and physical machine—and no team should jealously own single compo‐ nents. It turns out that you can get a lot more done if you “blur the lines”11 and have SREs instrument JavaScript, or product developers qualify kernels: knowledge of how to make changes and the authority to do so are much more widespread, and incen‐ tives to jealously guard any particular function are removed.\n\nIn Site Reliability Engineering, we did not make it sufficiently clear that product development teams in Google own their service by default. SRE is neither available nor warranted for the bulk of services, although SRE principles still inform how serv‐ ices are managed throughout Google.12 The ownership model when an SRE team works with a product development team is ultimately a shared model as well.\n\nUse the Same Tooling, Regardless of Function or Job Title Tooling is an incredibly important determinant of behavior, and it would be naive to assume that the efficacy of SRE in the Google context has nothing to do with the widely accessible unified codebase, the wide array of software and systems tooling, the highly optimized and proprietary production stack, and so on. Yet we share this absolute assumption with DevOps: teams minding a service13 should use the same tools, regardless of their role in the organization. There is no good way to manage a service that has one tool for the SREs and another for the product developers, behav‐ ing differently (and potentially catastrophically so) in different situations. The more divergence you have, the less your company benefits from each effort to improve each individual tool.\n\nCompare and Contrast Looking at the preceding principles, we immediately see quite a lot of commonality in the points outlined:\n\n10 Of course, not every team does everything, but those are the most common headings under which SRE works.\n\n11 Perform a layering violation, if you think of this as layered stacks.\n\n12 In fact, there’s a Production Readiness Review for onboarding anything; SRE won’t just onboard services\n\nfrom a standing start.\n\n13 A service is loosely defined as software running to perform some business need, generally with availability\n\nconstraints.\n\nCompare and Contrast\n\n|\n\n7",
      "content_length": 2388,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 40,
      "content": "DevOps and SRE are both contingent on an acceptance that change is necessary in order to improve. Without that, there’s not much room for maneuvering.14\n\nCollaboration is front and center for DevOps work. An effective shared owner‐ ship model and partner team relationships are necessary for SRE to function. Like DevOps, SRE also has strong values shared across the organization, which can make climbing out of team-based silos slightly easier.\n\nChange management is best pursued as small, continual actions, the majority of which are ideally both automatically tested and applied. The critical interaction between change and reliability makes this especially important for SRE.\n\nThe right tooling is critically important, and tooling to a certain extent deter‐ mines the scope of your acts. Yet we must not focus too hard on whether some‐ thing is achieved using some specific set of tools; at the end of the day, API orientation for system management is a more important philosophy that will outlast any particular implementation of it.\n\nMeasurement is absolutely key to how both DevOps and SRE work. For SRE, SLOs are dominant in determining the actions taken to improve the service. Of course, you can’t have SLOs without measurement (as well as cross-team debate —ideally among product, infrastructure/SRE, and the business). For DevOps, the act of measurement is often used to understand what the outputs of a process are, what the duration of feedback loops is, and so on. Both DevOps and SRE are data-oriented things, whether they are professions or philosophies.\n\nThe brute reality of managing production services means that bad things happen occasionally, and you have to talk about why. SRE and DevOps both practice blameless postmortems in order to offset unhelpful, adrenaline-laden reactions.\n\nUltimately, implementing DevOps or SRE is a holistic act; both hope to make the whole of the team (or unit, or organization) better, as a function of working together in a highly specific way. For both DevOps and SRE, better velocity should be the outcome.15\n\nAs you can see, there are many areas of commonality between DevOps and SRE.\n\nYet there are significant differences as well. DevOps is in some sense a wider philoso‐ phy and culture. Because it effects wider change than does SRE, DevOps is more context-sensitive. DevOps is relatively silent on how to run operations at a detailed\n\n14 Within Google, that question is largely settled, and services change state, configuration, ownership, direction, and so on, all the time. To a certain extent, SRE at Google is the beneficiary of the “change is necessary” argu‐ ment having been fought and won a number of times in the past. But not completely evenly distributed, as William Gibson might say.\n\n15 See relevant research at https://devops-research.com/research.html.\n\n8\n\n|\n\nChapter 1: How SRE Relates to DevOps",
      "content_length": 2876,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 41,
      "content": "level. For example, it is not prescriptive around the precise management of services. It chooses instead to concentrate on breaking down barriers in the wider organiza‐ tion. This has much value.\n\nSRE, on the other hand, has relatively narrowly defined responsibilities and its remit is generally service-oriented (and end-user-oriented) rather than whole-business- oriented. As a result, it brings an opinionated intellectual framework (including con‐ cepts like error budgets) to the problem of how to run systems effectively. Although SRE is, as a profession, highly aware of incentives and their effects, it in turn is rela‐ tively silent on topics like siloization and information barriers. It would support CI and CD not necessarily because of the business case, but because of the improved operational practices involved. Or, to put it another way, SRE believes in the same things as DevOps but for slightly different reasons.\n\nOrganizational Context and Fostering Successful Adoption DevOps and SRE have a very large conceptual overlap in how they operate. As you might expect, they also have a similar set of conditions that have to be true within the organization in order for them to a) be implementable in the first place, and b) obtain the maximum benefit from that implementation. As Tolstoy almost but never quite said, effective operations approaches are all alike, whereas broken approaches are all broken in their own way. Incentives can in part explain why that is.\n\nIf an organization’s culture values the benefits of a DevOps approach and is willing to bear those costs—typically expressed as difficulties in hiring, the energy required to maintain fluidity in teams and responsibilities, and increased financial resources dedicated to compensating a skill set that is necessarily more rare—then that organi‐ zation must also make sure the incentives are correct in order to achieve the full bene‐ fit of this approach.\n\nSpecifically, the following should hold true in the context of both DevOps and SRE.\n\nNarrow, Rigid Incentives Narrow Your Success Many companies accidentally define formal incentives that undermine collective per‐ formance. To avoid this mistake, don’t structure incentives to be narrowly tied to launch-related or reliability-related outcomes. As any economist can tell you, if there is a numeric measure, people will find a way to game it to bad effect, sometimes even in a completely well-intentioned way.16 Instead, you should allow your people the freedom to find the right tradeoffs. As discussed earlier, DevOps or SRE can act as an accelerant for your product team in general, allowing the rest of the software org to\n\n16 See http://en.wikipedia.org/wiki/Goodhart%27s_law and https://skybrary.aero/bookshelf/books/2336.pdf.\n\nOrganizational Context and Fostering Successful Adoption\n\n|\n\n9",
      "content_length": 2837,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 42,
      "content": "ship features to customers in a continuous and reliable fashion. Such a dynamic also fixes one persistent problem with the traditional and divergent systems/software group approach: the lack of a feedback loop between design and production. A sys‐ tem with early SRE engagement (ideally, at design time) typically works better in pro‐ duction after deployment, regardless of who is responsible for managing the service. (Nothing slows down feature development like losing user data.)\n\nIt’s Better to Fix It Yourself; Don’t Blame Someone Else Furthermore, avoid any incentives to pass off the blame for production incidents or system failures onto other groups. In many ways, the dynamics of passing off blame is the core problem with the traditional model for engineering operations, as separat‐ ing operations and software teams allows separate incentives to emerge. Instead, con‐ sider adopting the following practices to combat blame passing at an organizational level:\n\nDon’t just allow, but actively encourage, engineers to change code and configura‐ tion when required for the product. Also allow these teams the authority to be radical within the limits of their mission, thereby eliminating incentives to pro‐ ceed more slowly.\n\nSupport blameless postmortems.17 Doing so eliminates incentives to downplay or cover up a problem. This step is crucial in fully understanding the product and actually optimizing its performance and functionality, and relies on the wisdom of production mentioned previously.\n\nAllow support to move away from products that are irredeemably operationally diffi‐ cult. The threat of support withdrawal motivates product development to fix issues both in the run-up to support and once the product is itself supported, saving every‐ one time. What it means to be “irredeemably operationally difficult” may differ depending on your context—the dynamic here should be one of mutually understood responsibilities. Pushback to other orgs might be a softer, “We think there are higher- value uses of the time of people with this skill set,” or framed within the limit of, “These people will quit if they’re tasked with too much operational work and aren’t given the opportunity to use their engineering skill set.” At Google, the practice of outright withdrawing support from such products has become institutional.\n\nConsider Reliability Work as a Specialized Role At Google, SRE and product development are separate organizations. Each group has its own focus, priorities, and management, and does not have to do the bidding of the\n\n17 See, for example, https://codeascraft.com/2012/05/22/blameless-postmortems/.\n\n10\n\n|\n\nChapter 1: How SRE Relates to DevOps",
      "content_length": 2686,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 43,
      "content": "other. However, the product development teams effectively fund the growth of SRE with new hires when a product is successful. In this way, product development has a stake in the success of SRE teams, just as SREs have a stake in the success of the prod‐ uct development teams. SRE is also fortunate to receive high-level support from man‐ agement, which ensures that engineering teams’ objections to supporting services “the SRE way” are generally short-lived. You don’t need to have an org chart to do things differently, though—you just need a different community of practice to emerge.\n\nRegardless of whether you fork your organizational chart or use more informal mechanisms, it’s important to recognize that specialization creates challenges. Practi‐ tioners of DevOps and SRE benefit from having a community of peers for support and career development, and job ladders that reward them18 for the unique skills and perspectives they bring to the table.\n\nIt’s important to note that the organizational structure employed by Google, as well as some of the aforementioned incentives, is somewhat reliant on a sizeable organiza‐ tion. For example, if your 20-person startup has only one (comparatively small) product, there’s not much sense in allowing withdrawal of operational support. It’s still possible to take a DevOps-style approach,19 but the ability to improve an opera‐ tionally poor product is undermined if literally all you can do is help it grow. Usually, though, people have more choice than they imagine about how to fulfill those growth needs versus the rate at which technical debt accumulates.20\n\nWhen Can Substitute for Whether However, when your organization or product grows beyond a certain size, you can exercise more latitude in what products to support, or how to prioritize that support. If it’s clear that support for system X is going to happen much sooner than support for system Y, the implicit conditionality can play much the same role as the choice to not support services in the SRE world.\n\nAt Google, SRE’s strong partnership with product development has proven to be crit‐ ically important: if such a relationship exists at your organization, then the decision to withdraw (or supply) support can be based on objective data about comparative operational characteristics, thereby avoiding otherwise nonproductive conversations.\n\n18 In orgs that have well-developed cultures of either. Early-stage companies likely do not have established ways\n\nto reward these job roles.\n\n19 Indeed, arguably, that’s your only choice unless you outsource operations.\n\n20 For a discussion of how to apply SRE principles in different contexts, see Chapter 20.\n\nOrganizational Context and Fostering Successful Adoption\n\n|\n\n11",
      "content_length": 2742,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 44,
      "content": "A productive relationship between SRE and product development also helps in avoiding the organizational anti-pattern in which a product development team has to ship a product or feature before it’s quite ready. Instead, SRE can work with a devel‐ opment team to improve the product before the burden of maintenance shifts away from the people with the most expertise to fix it.\n\nStrive for Parity of Esteem: Career and Financial Finally, make sure that the career incentives to do the right thing are in place: we want our DevOps/SRE organization to be held in the same esteem as their product development counterparts. Therefore, members of each team should be rated by roughly the same methods and have the same financial incentives.\n\nConclusion In many ways, DevOps and SRE sit, in both practice and philosophy, very close to each other in the overall landscape of IT operations.\n\nBoth DevOps and SRE require discussion, management support, and buy-in from the people actually doing the work to make serious progress. Implementing either of them is a journey and not a quick fix: the practice of rename-and-shame21 is a hollow one, unlikely to yield benefit. Given that it is a more opinionated implementation of how to perform operations, SRE has more concrete suggestions on how to change your work practices earlier on in that journey, albeit requiring specific adaptation. DevOps, having a wider focus, is somewhat more difficult to reason about and trans‐ late into concrete steps, but precisely because of that wider focus, is likely to meet with weaker initial resistance.\n\nBut practitioners of each use many of the same tools, the same approaches to change management, and the same data-based decision-making mindset. At the end of the day, we all face the same persistent problem: production, and making it better—no matter what we’re called.\n\nFor those interested in further reading, the following suggestions should help you develop a wider understanding of the cultural, business, and technical underpinnings of the operations revolution taking place right now:\n\nSite Reliability Engineering\n\nEffective DevOps\n\nThe Phoenix Project\n\n21 In other words, simply retitling a group DevOps or SRE with no other change in their organizational posi‐ tioning, resulting in inevitable shaming of the team when promised improvement is not forthcoming.\n\n12\n\n|\n\nChapter 1: How SRE Relates to DevOps",
      "content_length": 2399,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 45,
      "content": "The Practice of Cloud System Administration: DevOps and SRE Practices for Web Services, Volume 2\n\nAccelerate: The Science of Lean Software and DevOps\n\nConclusion\n\n|\n\n13",
      "content_length": 168,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 47,
      "content": "PART I Foundations\n\nEvery implementation guide needs to start with a common base from which to build. In this case, the basic foundations of SRE include SLOs, monitoring, alerting, toil reduction, and simplicity. Getting these basics right will set you up well to succeed on your SRE journey.\n\nThe following chapters explore techniques for turning these core principles into con‐ crete practices for your organization.",
      "content_length": 418,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 49,
      "content": "CHAPTER 2 Implementing SLOs\n\nBy Steven Thurgood and David Ferguson with Alex Hidalgo and Betsy Beyer\n\nService level objectives (SLOs) specify a target level for the reliability of your service. Because SLOs are key to making data-driven decisions about reliability, they’re at the core of SRE practices. In many ways, this is the most important chapter in this book.\n\nOnce you’re equipped with a few guidelines, setting up initial SLOs and a process for refining them can be straightforward. Chapter 4 in our first book introduced the topic of SLOs and SLIs (service level indicators), and gave some advice on how to use them.\n\nAfter discussing the motivation behind SLOs and error budgets, this chapter provides a step-by-step recipe to get you started thinking about SLOs, and also some advice about how to iterate from there. We’ll then cover how to use SLOs to make effective business decisions, and explore some advanced topics. Finally, we’ll give you some examples of SLOs for different types of services and some pointers on how to create more sophisticated SLOs in specific situations.1\n\nWhy SREs Need SLOs Engineers are a scarce resource at even the largest organizations. Engineering time should be invested in the most important characteristics of the most important serv‐ ices. Striking the right balance between investing in functionality that will win new customers or retain current ones, versus investing in the reliability and scalability that\n\n1 A note on terminology: throughout this chapter, we use the word reliability to talk about how a service is performing with regard to all of its SLIs. This could be indicative of many things, such as availability or latency.\n\n17",
      "content_length": 1692,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 50,
      "content": "will keep those customers happy, is difficult. At Google, we’ve learned that a well- thought-out and adopted SLO is key to making data-informed decisions about the opportunity cost of reliability work, and to determining how to appropriately priori‐ tize that work.\n\nSREs’ core responsibilities aren’t merely to automate “all the things” and hold the pager. Their day-to-day tasks and projects are driven by SLOs: ensuring that SLOs are defended in the short term and that they can be maintained in the medium to long term. One could even claim that without SLOs, there is no need for SREs.\n\nSLOs are a tool to help determine what engineering work to prioritize. For example, consider the engineering tradeoffs for two reliability projects: automating rollbacks and moving to a replicated data store. By calculating the estimated impact on our error budget, we can determine which project is most beneficial to our users. See the section “Decision Making Using SLOs and Error Budgets” on page 37 for more detail on this, and “Managing Risk” in Site Reliability Engineering.\n\nGetting Started As a starting point for establishing a basic set of SLOs, let’s assume that your service is some form of code that has been compiled and released and is running on net‐ worked infrastructure that users access via the web. Your system’s maturity level might be one of the following:\n\nA greenfield development, with nothing currently deployed\n\nA system in production with some monitoring to notify you when things go awry, but no formal objectives, no concept of an error budget, and an unspoken goal of 100% uptime\n\nA running deployment with an SLO below 100%, but without a common under‐ standing about its importance or how to leverage it to make continuous improvement choices—in other words, an SLO without teeth\n\nIn order to adopt an error budget-based approach to Site Reliability Engineering, you need to reach a state where the following hold true:\n\nThere are SLOs that all stakeholders in the organization have approved as being fit for the product.\n\nThe people responsible for ensuring that the service meets its SLO have agreed that it is possible to meet this SLO under normal circumstances.\n\nThe organization has committed to using the error budget for decision making and prioritizing. This commitment is formalized in an error budget policy.\n\nThere is a process in place for refining the SLO.\n\n18\n\n|\n\nChapter 2: Implementing SLOs",
      "content_length": 2434,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 51,
      "content": "Otherwise, you won’t be able to adopt an error budget–based approach to reliability. SLO compliance will simply be another KPI (key performance indicator) or reporting metric, rather than a decision-making tool.\n\nReliability Targets and Error Budgets The first step in formulating appropriate SLOs is to talk about what an SLO should be, and what it should cover.\n\nAn SLO sets a target level of reliability for the service’s customers. Above this thres‐ hold, almost all users should be happy with your service (assuming they are otherwise happy with the utility of the service).2 Below this threshold, users are likely to start complaining or to stop using the service. Ultimately, user happiness is what matters —happy users use the service, generate revenue for your organization, place low demands on your customer support teams, and recommend the service to their friends. We keep our services reliable to keep our customers happy.\n\nCustomer happiness is a rather fuzzy concept; we can’t measure it precisely. Often we have very little visibility into it at all, so how do we begin? What do we use for our first SLO?\n\nOur experience has shown that 100% reliability is the wrong target:\n\nIf your SLO is aligned with customer satisfaction, 100% is not a reasonable goal. Even with redundant components, automated health checking, and fast failover, there is a nonzero probability that one or more components will fail simultane‐ ously, resulting in less than 100% availability.\n\nEven if you could achieve 100% reliability within your system, your customers would not experience 100% reliability. The chain of systems between you and your customers is often long and complex, and any of these components can fail.3 This also means that as you go from 99% to 99.9% to 99.99% reliability, each extra nine comes at an increased cost, but the marginal utility to your customers steadily approaches zero.\n\nIf you do manage to create an experience that is 100% reliable for your custom‐ ers, and want to maintain that level of reliability, you can never update or improve your service. The number one source of outages is change: pushing new features, applying security patches, deploying new hardware, and scaling up to\n\n2 This is distinct from a service level agreement (SLA), which is a business contract that comes into effect when\n\nyour users are so unhappy you have to compensate them in some fashion.\n\n3 For more details about factoring dependencies into your service’s reliability, see Ben Treynor, Mike Dahlin, Vivek Rau, and Betsy Beyer, “The Calculus of Service Availability,” ACM Queue 15, no. 2 (2017), https:// queue.acm.org/detail.cfm?id=3096459.\n\nGetting Started\n\n|\n\n19",
      "content_length": 2681,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 52,
      "content": "meet customer demand will impact that 100% target. Sooner or later, your ser‐ vice will stagnate and your customers will go elsewhere, which is not great for anyone’s bottom line.\n\nAn SLO of 100% means you only have time to be reactive. You literally cannot do anything other than react to < 100% availability, which is guaranteed to happen. Reliability of 100% is not an engineering culture SLO—it’s an operations team SLO.\n\nOnce you have an SLO target below 100%, it needs to be owned by someone in the organization who is empowered to make tradeoffs between feature velocity and relia‐ bility. In a small organization, this may be the CTO; in larger organizations, this is normally the product owner (or product manager).\n\nWhat to Measure: Using SLIs Once you agree that 100% is the wrong number, how do you determine the right number? And what are you measuring, anyway? Here, service level indicators come into play: an SLI is an indicator of the level of service that you are providing.\n\nWhile many numbers can function as an SLI, we generally recommend treating the SLI as the ratio of two numbers: the number of good events divided by the total num‐ ber of events. For example:\n\nNumber of successful HTTP requests / total HTTP requests (success rate)\n\nNumber of gRPC calls that completed successfully in < 100 ms / total gRPC requests\n\nNumber of search results that used the entire corpus / total number of search results, including those that degraded gracefully\n\nNumber of “stock check count” requests from product searches that used stock data fresher than 10 minutes / total number of stock check requests\n\nNumber of “good user minutes” according to some extended list of criteria for that metric / total number of user minutes\n\nSLIs of this form have a couple of particularly useful properties. The SLI ranges from 0% to 100%, where 0% means nothing works, and 100% means nothing is broken. We have found this scale intuitive, and this style lends itself easily to the concept of an error budget: the SLO is a target percentage and the error budget is 100% minus the SLO. For example, if you have a 99.9% success ratio SLO, then a service that receives 3 million requests over a four-week period had a budget of 3,000 (0.1%)\n\n20\n\n|\n\nChapter 2: Implementing SLOs",
      "content_length": 2274,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 53,
      "content": "errors over that period. If a single outage is responsible for 1,500 errors, that error costs 50% of the error budget.4\n\nIn addition, making all of your SLIs follow a consistent style allows you to take better advantage of tooling: you can write alerting logic, SLO analysis tools, error budget calculation, and reports to expect the same inputs: numerator, denominator, and threshold. Simplification is a bonus here.\n\nWhen attempting to formulate SLIs for the first time, you might find it useful to fur‐ ther divide SLIs into SLI specification and SLI implementation:\n\nSLI specification\n\nThe assessment of service outcome that you think matters to users, independent of how it is measured.\n\nFor example: Ratio of home page requests that loaded in < 100 ms\n\nSLI implementation\n\nThe SLI specification and a way to measure it.\n\nFor example:\n\nRatio of home page requests that loaded in < 100 ms, as measured from the Latency column of the server log. This measurement will miss requests that fail to reach the backend.\n\nRatio of home page requests that loaded in < 100 ms, as measured by probers that execute JavaScript in a browser running in a virtual machine. This measurement will catch errors when requests cannot reach our network, but may miss issues that affect only a subset of users.\n\nRatio of home page requests that loaded in < 100 ms, as measured by instru‐ mentation in the JavaScript on the home page itself, and reported back to a dedicated telemetry recording service. This measurement will more accu‐ rately capture the user experience, although we now need to modify the code to capture this information and build the infrastructure to record it—a speci‐ fication that has its own reliability requirements.\n\nAs you can see, a single SLI specification might have multiple SLI implementations, each with its own set of pros and cons in terms of quality (how accurately they cap‐ ture the experience of a customer), coverage (how well they capture the experience of all customers), and cost.\n\n4 If you measure your SLO over a calendar period, such as a quarter-year, then you may not know how big your budget will be at the end of the quarter if it’s based upon unpredictable metrics such as traffic. See “Choosing an Appropriate Time Window” on page 29 for more discussion about reporting periods.\n\nGetting Started\n\n|\n\n21",
      "content_length": 2336,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 54,
      "content": "Your first attempt at an SLI and SLO doesn’t have to be correct; the most important goal is to get something in place and measured, and to set up a feedback loop so you can improve. (We dive deeper into this topic in “Continuous Improvement of SLO Targets” on page 34.)\n\nIn our first book, we advise against picking an SLO based upon current performance, because this can commit you to unnecessarily strict SLOs. While that advice is true, your current performance can be a good place to start if you don’t have any other information, and if you have a good process for iterating in place (which we’ll cover later). However, don’t let current performance limit you as you refine your SLO: your customers will also come to expect your service to perform at its SLO, so if your ser‐ vice returns successful requests 99.999% of the time in less than 10 ms, any signifi‐ cant regression from that baseline may make them unhappy.\n\nTo create your first set of SLOs, you need to decide upon a few key SLI specifications that matter to your service. Availability and latency SLOs are pretty common; fresh‐ ness, durability, correctness, quality, and coverage SLOs also have their place (we’ll talk more about those later).\n\nIf you are having trouble figuring out what sort of SLIs to start with, it helps to start simple:\n\nChoose one application for which you want to define SLOs. If your product com‐ prises many applications, you can add those later.\n\nDecide clearly who the “users” are in this situation. These are the people whose happiness you are optimizing.\n\nConsider the common ways your users interact with your system—common tasks and critical activities.\n\nDraw a high-level architecture diagram of your system; show the key compo‐ nents, the request flow, the data flow, and the critical dependencies. Group these components into categories listed in the following section (there may be some overlap and ambiguity; use your intuition and don’t let perfect be the enemy of the good).\n\nYou should think carefully about exactly what you select as your SLIs, but you also shouldn’t overcomplicate things. Especially if you’re just starting your SLI journey, pick an aspect of your system that’s relevant but easy to measure—you can always iterate and refine later.\n\nTypes of components\n\nThe easiest way to get started with setting SLIs is to abstract your system into a few common types of components. You can then use our list of suggested SLIs for each component to choose the ones most relevant to your service:\n\n22\n\n|\n\nChapter 2: Implementing SLOs",
      "content_length": 2550,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 55,
      "content": "Request-driven\n\nThe user creates some type of event and expects a response. For example, this could be an HTTP service where the user interacts with a browser or an API for a mobile application.\n\nPipeline\n\nA system that takes records as input, mutates them, and places the output some‐ where else. This might be a simple process that runs on a single instance in real time, or a multistage batch process that takes many hours. Examples include:\n\nA system that periodically reads data from a relational database and writes it into a distributed hash table for optimized serving\n\nA video processing service that converts video from one format to another\n\nA system that reads in log files from many sources to generate reports\n\nA monitoring system that pulls metrics from remote servers and generates time series and alerts\n\nStorage\n\nA system that accepts data (e.g., bytes, records, files, videos) and makes it avail‐ able to be retrieved at a later date.\n\nA Worked Example Consider a simplified architecture for a mobile phone game, shown in Figure 2-1.\n\nFigure 2-1. Architecture for an example mobile phone game\n\nA Worked Example\n\n|\n\n23",
      "content_length": 1136,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 56,
      "content": "The app running on the user’s phone interacts with an HTTP API running in the cloud. The API writes state changes to a permanent storage system. A pipeline peri‐ odically runs over this data to generate league tables that provide high scores for today, this week, and all time. This data is written to a separate league table data store, and the results are available via the mobile app (for in-game scores) and a web‐ site. Users can upload custom avatars, which are used both in-game via the API and in the high score website, to the User Data table.\n\nGiven this setup, we can start thinking about how users interact with the system, and what sort of SLIs would measure the various aspects of a user’s experience.\n\nSome of these SLIs may overlap: a request-driven service may have a correctness SLI, a pipeline may have an availability SLI, and durability SLIs might be viewed as a var‐ iant on correctness SLIs. We recommend choosing a small number (five or fewer) of SLI types that represent the most critical functionality to your customers.\n\nIn order to capture both the typical user experience and the long tail, we also recom‐ mend using multiple grades of SLOs for some types of SLIs. For example, if 90% of users’ requests return within 100 ms, but the remaining 10% take 10 seconds, many users will be unhappy. A latency SLO can capture this user base by setting multiple thresholds: 90% of requests are faster than 100 ms, and 99% of requests are faster than 400 ms. This principle applies to all SLIs with parameters that measure user unhappiness.\n\nTable 2-1 provides some common SLIs for different types of services.\n\nTable 2-1. Potential SLIs for different types of components\n\nType of service Request- driven Request- driven Request- driven\n\nPipeline\n\nPipeline\n\nPipeline\n\nType of SLI Description\n\nAvailability\n\nThe proportion of requests that resulted in a successful response.\n\nLatency\n\nThe proportion of requests that were faster than some threshold.\n\nQuality\n\nFreshness\n\nCorrectness\n\nCoverage\n\nIf the service degrades gracefully when overloaded or when backends are unavailable, you need to measure the proportion of responses that were served in an undegraded state. For example, if the User Data store is unavailable, the game is still playable but uses generic imagery. The proportion of the data that was updated more recently than some time threshold. Ideally this metric counts how many times a user accessed the data, so that it most accurately reflects the user experience. The proportion of records coming into the pipeline that resulted in the correct value coming out. For batch processing, the proportion of jobs that processed above some target amount of data. For streaming processing, the proportion of incoming records that were successfully processed within some time window.\n\n24\n\n|\n\nChapter 2: Implementing SLOs",
      "content_length": 2848,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 57,
      "content": "Type of service Storage\n\nType of SLI Description\n\nDurability\n\nThe proportion of records written that can be successfully read. Take particular care with durability SLIs: the data that the user wants may be only a small portion of the data that is stored. For example, if you have 1 billion records for the previous 10 years, but the user wants only the records from today (which are unavailable), then they will be unhappy even though almost all of their data is readable.\n\nMoving from SLI Specification to SLI Implementation Now that we know our SLI specifications, we need to start thinking about how to implement them.\n\nFor your first SLIs, choose something that requires a minimum of engineering work. If your web server logs are already available, but setting up probes would take weeks and instrumenting your JavaScript would take months, use the logs.\n\nYou need enough information to measure the SLI: for availability, you need the suc‐ cess/failure status; for slow requests, you need the time taken to serve the request. You may need to reconfigure your web server to record this information. If you’re using a cloud-based service, some of this information may already be available in a monitoring dashboard.\n\nThere are various options for SLI implementations for our example architecture, each with its own pros and cons. The following sections detail SLIs for the three types of components in our system.\n\nAPI and HTTP server availability and latency\n\nFor all of the considered SLI implementations, we base the response success on the HTTP status code. 5XX responses count against SLO, while all other requests are considered successful. Our availability SLI is the proportion of successful requests, and our latency SLIs are the proportion of requests that are faster than defined thresholds.\n\nYour SLIs should be specific and measurable. To summarize the list of potential can‐ didates provided in “What to Measure: Using SLIs” on page 20, your SLIs can use one or more of the following sources:\n\nApplication server logs\n\nLoad balancer monitoring\n\nBlack-box monitoring\n\nClient-side instrumentation\n\nA Worked Example\n\n|\n\n25",
      "content_length": 2135,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 58,
      "content": "Our example uses the load balancer monitoring, as the metrics are already available and provide SLIs that are closer to the user’s experience than those from the applica‐ tion server’s logs.\n\nPipeline freshness, coverage, and correctness\n\nWhen our pipeline updates the league table, it records a watermark containing the timestamp of when the data was updated. Some example SLI implementations:\n\nRun a periodic query across the league table, counting the total number of fresh records and the total number of records. This will treat each stale record as equally important, regardless of how many users saw the data.\n\nMake all clients of the league table check the watermark when they request fresh data and increment a metric counter saying that data was requested. Increment another counter if the data was fresher than a predefined threshold.\n\nFrom these two options, our example uses the client-side implementation, as it gives SLIs that are much more closely correlated with user experience and are straightfor‐ ward to add.\n\nTo calculate our coverage SLI, our pipeline exports the number of records that it should have processed and the number of records that it successfully processed. This metric may miss records that our pipeline did not know about due to misconfigura‐ tion.\n\nWe have a couple potential approaches to measure correctness:\n\nInject data with known outputs into the system, and count the proportion of times that the output matches our expectations.\n\nUse a method to calculate correct output based on input that is distinct from our pipeline itself (and likely more expensive, and therefore not suitable for our pipe‐ line). Use this to sample input/output pairs, and count the proportion of correct output records. This methodology assumes that creating such a system is both possible and practical.\n\nOur example bases its correctness SLI on some manually curated data in the game state database, with known good outputs that are tested every time the pipeline runs. Our SLI is the proportion of correct entries for our test data. In order for this SLI to be representative of the actual user experience, we need to make sure that our man‐ ually curated data is representative of real-world data.\n\nMeasuring the SLIs Figure 2-2 shows how our white-box monitoring system collects metrics from the various components of the example application.\n\n26\n\n|\n\nChapter 2: Implementing SLOs",
      "content_length": 2404,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 59,
      "content": "Figure 2-2. How our monitoring system collects SLI metrics\n\nLet’s walk through an example of using metrics from our monitoring system to calcu‐ late our starter SLOs. While our example uses availability and latency metrics, the same principles apply to all other potential SLOs. For a full list of the metrics that our system uses, see Appendix A. All of our examples use Prometheus notation.\n\nLoad balancer metrics\n\nTotal requests by backend (\"api\" or \"web\") and response code:\n\nhttp_requests_total{host=\"api\", status=\"500\"}\n\nTotal latency, as a cumulative histogram; each bucket counts the number of requests that took less than or equal to that time:\n\nhttp_request_duration_seconds{host=\"api\", le=\"0.1\"} http_request_duration_seconds{host=\"api\", le=\"0.2\"} http_request_duration_seconds{host=\"api\", le=\"0.4\"}\n\nGenerally speaking, it is better to count the slow requests than to approximate them with a histogram. But, because that information isn’t available, we use the histogram provided by our monitoring system. Another approach would be to base explicit slow\n\nA Worked Example\n\n|\n\n27",
      "content_length": 1090,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 60,
      "content": "request counts on the various slowness thresholds in the load balancer’s configura‐ tion (e.g., for thresholds of 100 ms and 500 ms). This strategy would provide more accurate numbers but require more configuration, which makes changing the thresh‐ olds retroactively harder.\n\nhttp_request_duration_seconds{host=\"api\", le=\"0.1\"} http_request_duration_seconds{host=\"api\", le=\"0.5\"}\n\nCalculating the SLIs\n\nUsing the preceding metrics, we can calculate our current SLIs over the previous seven days, as shown in Table 2-2.\n\nTable 2-2. Calculations for SLIs over the previous seven days\n\nAvailability sum(rate(http_requests_total{host=\"api\", status!~\"5..\"}[7d]))\n\n/ sum(rate(http_requests_total{host=\"api\"}[7d])\n\nLatency\n\nhistogram_quantile(0.9, rate(http_request_duration_seconds_bucket[7d])) histogram_quantile(0.99, rate(http_request_duration_seconds_bucket[7d]))\n\nUsing the SLIs to Calculate Starter SLOs We can round down these SLIs to manageable numbers (e.g., two significant figures of availability, or up to 50 ms5 of latency) to obtain our starting SLOs.\n\nFor example, over four weeks, the API metrics show:\n\nTotal requests: 3,663,253\n\nTotal successful requests: 3,557,865 (97.123%)\n\n90th percentile latency: 432 ms\n\n99th percentile latency: 891 ms\n\nWe repeat this process for the other SLIs, and create a proposed SLO for the API, shown in Table 2-3.\n\n5 50 ms because users are unlikely to perceive a 50 ms change in latency, but the appropriate window obviously\n\ndepends on the service and the users. A reporting service will be different from a real-time game.\n\n28\n\n|\n\nChapter 2: Implementing SLOs",
      "content_length": 1606,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 61,
      "content": "Table 2-3. Proposed SLOs for the API\n\nSLO type Availability Latency Latency\n\nObjective 97% 90% of requests < 450 ms 99% of requests < 900 ms\n\nAppendix A provides a full example of an SLO document. This document includes SLI implementations, which we omitted here for brevity.\n\nBased upon this proposed SLI, we can calculate our error budget over those four weeks, as shown in Table 2-4.\n\nTable 2-4. Error budget over four weeks\n\nSLO 97% availability 90% of requests faster than 450 ms 99% of requests faster than 900 ms\n\nAllowed failures 109,897 366,325 36,632\n\nChoosing an Appropriate Time Window SLOs can be defined over various time intervals, and can use either a rolling window or a calendar-aligned window (e.g., a month). There are several factors you need to account for when choosing the window.\n\nRolling windows are more closely aligned with user experience: if you have a large outage on the final day of a month, your user doesn’t suddenly forget about it on the first day of the following month. We recommend defining this period as an integral number of weeks so it always contains the same number of weekends. For example, if you use a 30-day window, some periods might include four weekends while others include five weekends. If weekend traffic differs significantly from weekday traffic, your SLIs may vary for uninteresting reasons.\n\nCalendar windows are more closely aligned with business planning and project work. For example, you might evaluate your SLOs every quarter to determine where to focus the next quarter’s project headcount. Calendar windows also introduce some element of uncertainty: in the middle of the quarter, it is impossible to know how many requests you will receive for the rest of the quarter. Therefore, decisions made mid-quarter must speculate as to how much error budget you’ll spend in the remain‐ der of the quarter.\n\nShorter time windows allow you to make decisions more quickly: if you missed your SLO for the previous week, then small course corrections—prioritizing relevant bugs, for example—can help avoid SLO violations in future weeks.\n\nChoosing an Appropriate Time Window\n\n|\n\n29",
      "content_length": 2137,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 62,
      "content": "Longer time periods are better for more strategic decisions: for example, if you could choose only one of three large projects, would you be better off moving to a high- availability distributed database, automating your rollout and rollback procedure, or deploying a duplicate stack in another zone? You need more than a week’s worth of data to evaluate large multiquarter projects; the amount of data required is roughly commensurate with the amount of engineering work being proposed to fix it.\n\nWe have found a four-week rolling window to be a good general-purpose interval. We complement this time frame with weekly summaries for task prioritization and quarterly summarized reports for project planning.\n\nIf the data source allows, you can then use this proposed SLO to calculate your actual SLO performance over that interval: if you set your initial SLO based on actual meas‐ urements, by design, you met your SLO. But we can also gather interesting informa‐ tion about the distribution. Were there any days during the past four weeks when our service did not meet its SLO? Do these days correlate with actual incidents? Was there (or should there have been) some action taken on those days in response to incidents?\n\nIf you do not have logs, metrics, or any other source of historical performance, you need to configure a data source. For example, as a low-fidelity solution for HTTP services, you can set up a remote monitoring service that performs some kind of peri‐ odic health check on the service (a ping or an HTTP GET) and reports back the num‐ ber of successful requests. A number of online services can easily implement this solution.\n\nGetting Stakeholder Agreement In order for a proposed SLO to be useful and effective, you will need to get all stake‐ holders to agree to it:\n\nThe product managers have to agree that this threshold is good enough for users —performance below this value is unacceptably low and worth spending engi‐ neering time to fix.\n\nThe product developers need to agree that if the error budget has been exhaus‐ ted, they will take some steps to reduce risk to users until the service is back in budget (as discussed in “Establishing an Error Budget Policy” on page 31).\n\nThe team responsible for the production environment who are tasked with defending this SLO have agreed that it is defensible without Herculean effort, excessive toil, and burnout—all of which are damaging to the long-term health of the team and service.\n\n30\n\n|\n\nChapter 2: Implementing SLOs",
      "content_length": 2504,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 63,
      "content": "Once all of these points are agreed upon, the hard part is done.6 You have started your SLO journey, and the remaining steps entail iterating from this starting point.\n\nTo defend your SLO you will need to set up monitoring and alerting (see Chapter 5) so that engineers receive timely notifications of threats to the error budget before those threats become deficits.\n\nEstablishing an Error Budget Policy Once you have an SLO, you can use the SLO to derive an error budget. In order to use this error budget, you need a policy outlining what to do when your service runs out of budget.\n\nGetting the error budget policy approved by all key stakeholders—the product man‐ ager, the development team, and the SREs—is a good test for whether the SLOs are fit for purpose:\n\nIf the SREs feel that the SLO is not defensible without undue amounts of toil, they can make a case for relaxing some of the objectives.\n\nIf the development team and product manager feel that the increased resources they’ll have to devote to fixing reliability will cause feature release velocity to fall below acceptable levels, then they can also argue for relaxing objectives. Remem‐ ber that lowering the SLOs also lowers the number of situations to which the SREs will respond; the product manager needs to understand this tradeoff.\n\nIf the product manager feels that the SLO will result in a bad experience for a significant number of users before the error budget policy prompts anyone to address an issue, the SLOs are likely not tight enough.\n\nIf all three parties do not agree to enforce the error budget policy, you need to iterate on the SLIs and SLOs until all stakeholders are happy. Decide how to move forward and what you need to make the decision: more data, more resources, or a change to the SLI or SLO?\n\nWhen we talk about enforcing an error budget, we mean that once you exhaust your error budget (or come close to exhausting it), you should do something in order to restore stability to your system.\n\nTo make error budget enforcement decisions, you need to start with a written policy. This policy should cover the specific actions that must be taken when a service has consumed its entire error budget for a given period of time, and specify who will take them. Common owners and actions might include:\n\n6 Disclaimer: there may be more difficult tasks in your future.\n\nGetting Stakeholder Agreement\n\n|\n\n31",
      "content_length": 2396,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 64,
      "content": "The development team gives top priority to bugs relating to reliability issues over the past four weeks.\n\nThe development team focuses exclusively on reliability issues until the system is within SLO. This responsibility comes with high-level approval to push back on external feature requests and mandates.\n\nTo reduce the risk of more outages, a production freeze halts certain changes to the system until there is sufficient error budget to resume changes.\n\nSometimes a service consumes the entirety of its error budget, but not all stakehold‐ ers agree that enacting the error budget policy is appropriate. If this happens, you need to return to the error budget policy approval stage.\n\nDocumenting the SLO and Error Budget Policy An appropriately defined SLO should be documented in a prominent location where other teams and stakeholders can review it. This documentation should include the following information:\n\nThe authors of the SLO, the reviewers (who checked it for technical accuracy), and the approvers (who made the business decision about whether it is the right SLO).\n\nThe date on which it was approved, and the date when it should next be reviewed.\n\nA brief description of the service to give the reader context.\n\nThe details of the SLO: the objectives and the SLI implementations.\n\nThe details of how the error budget is calculated and consumed.\n\nThe rationale behind the numbers, and whether they were derived from experi‐ mental or observational data. Even if the SLOs are totally ad hoc, this fact should be documented so that future engineers reading the document don’t make bad decisions based upon ad hoc data.\n\nHow often you review an SLO document depends on the maturity of your SLO cul‐ ture. When starting out, you should probably review the SLO frequently—perhaps every month. Once the appropriateness of the SLO becomes more established, you can likely reduce reviews to happen quarterly or even less frequently.\n\nThe error budget policy should also be documented, and should include the follow‐ ing information:\n\nThe policy authors, reviewers, and approvers\n\nThe date on which it was approved, and the date when it should next be reviewed\n\n32\n\n|\n\nChapter 2: Implementing SLOs",
      "content_length": 2207,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 65,
      "content": "A brief description of the service to give the reader context\n\nThe actions to be taken in response to budget exhaustion\n\nA clear escalation path to follow if there is disagreement on the calculation or whether the agreed-upon actions are appropriate in the circumstances\n\nDepending upon the audience’s level of error budget experience and expertise, it may be beneficial to include an overview of error budgets.\n\nSee Appendix A for an example of an SLO document and an error budget policy.\n\nDashboards and Reports In addition to the published SLO and error budget policy documents, it is useful to have reports and dashboards that provide in-time snapshots of the SLO compliance of your services, for communicating with other teams and for spotting problematic areas.\n\nThe report in Figure 2-3 shows the overall compliance of several services: whether they met all of their quarterly SLOs for the previous year (the numbers in parentheses indicate the number of objectives that were met, and the total number of objectives), and whether their SLIs were trending upward or downward in relation to the previ‐ ous quarter and the same quarter last year.\n\nFigure 2-3. SLO compliance report\n\nIt is also useful to have dashboards showing SLI trends. These dashboards indicate if you are consuming budget at a higher-than-usual rate, or if there are patterns or trends you need to be aware of.\n\nGetting Stakeholder Agreement\n\n|\n\n33",
      "content_length": 1424,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 66,
      "content": "The dashboard in Figure 2-4 shows the error budget for a single quarter, midway through that quarter. Here we see that a single event consumed around 15% of the error budget over the course of two days.\n\nFigure 2-4. Error budget dashboard\n\nError budgets can be useful for quantifying these events—for example, “this outage consumed 30% of my quarterly error budget,” or “these are the top three incidents this quarter, ordered by how much error budget they consumed.”\n\nContinuous Improvement of SLO Targets Every service can benefit from continuous improvement. This is one of the central service goals in ITIL, for example.\n\nBefore you can improve your SLO targets, you need a source of information about user satisfaction with your service. There are a huge range of options:\n\nYou can count outages that were discovered manually, posts on public forums, support tickets, and calls to customer service.\n\nYou can attempt to measure user sentiment on social media.\n\nYou can add code to your system to periodically sample user happiness.\n\nYou can conduct face-to-face user surveys and samples.\n\n34\n\n|\n\nChapter 2: Implementing SLOs",
      "content_length": 1128,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 67,
      "content": "The possibilities are endless, and the optimal method depends on your service. We recommend starting with a measurement that’s cheap to collect and iterating from that starting point. Asking your product manager to include reliability into their existing discussions with customers about pricing and functionality is an excellent place to start.\n\nImproving the Quality of Your SLO Count your manually detected outages. If you have support tickets, count those too. Look at periods when you had a known outage or incident. Check that these periods correlate with steep drops in error budget. Likewise, look at times when your SLIs indicate an issue, or your service fell out of SLO. Do these time periods correlate with known outages or an increase in support tickets? If you are familiar with statistical analysis, Spearman’s rank correlation coefficient can be a useful way to quantify this relationship.\n\nFigure 2-5 shows a graph of the number of support tickets raised per day versus the measured loss in our error budget on that day. While not all tickets are related to reli‐ ability issues, there is a correlation between tickets and error budget loss. We see two outliers: one day with only 5 tickets, where we lost 10% of our error budget, and one day with 40 tickets, on which we lost no error budget. Both warrant closer investiga‐ tion.\n\nFigure 2-5. Graph showing the number of support tickets per day versus the budget loss on that day\n\nIf some of your outages and ticket spikes are not captured in any SLI or SLO, or if you have SLI dips and SLO misses that don’t map to user-facing issues, this is a strong sign that your SLO lacks coverage. This situation is totally normal and should\n\nContinuous Improvement of SLO Targets\n\n|\n\n35",
      "content_length": 1745,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 68,
      "content": "be expected. Your SLIs and SLOs should change over time as realities about the ser‐ vice they represent change. Don’t be afraid to examine and refine them over time!\n\nThere are several courses of action you can take if your SLO lacks coverage:\n\nChange your SLO\n\nIf your SLIs indicated a problem, but your SLOs didn’t prompt anyone to notice or respond, you may need to tighten your SLO.\n\nIf the incident on that date was large enough that it needs to be addressed, look at the SLI values during the periods of interest. Calculate what SLO would have resulted in a notification on those dates. Apply that SLO to your historic SLIs, and see what other events this adjustment would have cap‐ tured. It’s pointless to improve the recall of your system if you lower the pre‐ cision such that the team must constantly respond to unimportant events.7\n\nLikewise, for false-positive days, consider relaxing the SLO.\n\nIf changing the SLO in either direction results in too many false positives or false negatives, then you also need to improve the SLI implementation.\n\nChange your SLI implementation\n\nThere are two ways to change your SLI implementation: either move the meas‐ urement closer to the user to improve the quality of the metric, or improve cov‐ erage so you capture a higher percentage of user interactions. For example:\n\nInstead of measuring success/latency at the server, measure it at the load bal‐ ancer or on the client.\n\nInstead of measuring availability with a simple HTTP GET request, use a health-checking handler that exercises more functionality of the system, or a test that executes all of the client-side JavaScript.\n\nInstitute an aspirational SLO\n\nSometimes you determine that you need a tighter SLO to make your users happy, but improving your product to meet that SLO will take some time. If you imple‐ ment the tighter SLO, you’ll be permanently out of SLO and subject to your error budget policy. In this situation, you can make the refined SLO an aspirational SLO—measured and tracked alongside your current SLO, but explicitly called out in your error budget policy as not requiring action. This way you can track your progress toward meeting the aspirational SLO, but you won’t be in a perpet‐ ual state of emergency.\n\n7 Recall is the proportion of significantly user-impacting events that the SLI captures. Precision is the propor‐\n\ntion of events captured by the SLI that were significantly user-impacting.\n\n36\n\n|\n\nChapter 2: Implementing SLOs",
      "content_length": 2470,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 69,
      "content": "Iterate\n\nThere are many different ways to iterate, and your review sessions will identify many potential improvements. Pick the option that’s most likely to give the high‐ est return on investment. Especially during the first few iterations, err on the side of quicker and cheaper; doing so reduces the uncertainty in your metrics and helps you determine if you need more expensive metrics. Iterate as many times as you need to.\n\nDecision Making Using SLOs and Error Budgets Once you have SLOs, you can start using them for decision making.\n\nThe obvious decisions start from what to do when you’re not meeting your SLO— that is, when you’ve exhausted your error budget. As already discussed, the appropri‐ ate course of action when you exhaust your error budget should be covered by the error budget policy. Common policies include stopping feature launches until the service is once again within SLO or devoting some or all engineering time to working on reliability-related bugs.\n\nIn extreme circumstances, a team can declare an emergency with high-level approval to deprioritize all external demands (requests from other teams, for example) until the service meets exit criteria—typically that the service is within SLO and that you’ve taken steps to decrease the chances of a subsequent SLO miss. These steps may include improving monitoring, improving testing, removing dangerous dependen‐ cies, or rearchitecting the system to remove known failure types.\n\nYou can determine the scale of the incident according to the proportion of the error budget it consumed, and use this data to identify the most critical incidents that merit closer investigation.\n\nFor example, imagine a release of a new API version causes 100% NullPointerExcep tions until the system can be reverted four hours later.8 Inspecting the raw server logs indicates that the issue caused 14,066 errors. Using the numbers from our 97% SLO earlier, and our budget of 109,897 errors, this single event used 13% of our error budget.\n\nOr perhaps the server on which our singly homed state database is stored fails, and restoring from backups takes 20 hours. We estimate (based upon historical traffic over that period) that this outage caused us 72,000 errors, or 65% of our error budget.\n\n8 It is worth reiterating here that an error budget is an approximation of user satisfaction. A four-hour outage every 30 days would probably result in fewer unhappy users than four separate one-hour outages every 30 days, which in turn would cause fewer unhappy users than a constant error rate of 0.5%, but our error budget treats them the same. These thresholds will vary between services.\n\nDecision Making Using SLOs and Error Budgets\n\n|\n\n37",
      "content_length": 2703,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 70,
      "content": "Imagine that our example company had only one server failure in five years, but typi‐ cally experiences two or three bad releases that require rollbacks per year. We can estimate that, on average, bad pushes cost twice as much error budget as database failures. The numbers prove that addressing the release problem provides much more benefit than investing resources in investigating the server failure.\n\nIf the service is running flawlessly and needs little oversight, then it may be time to move the service to a less hands-on tier of support. You might continue to provide incident response management and high-level oversight, but you no longer need to be as closely involved with the product on a day-to-day basis. Therefore, you can focus your efforts on other systems that need more SRE support.\n\nTable 2-5 provides suggested courses of action based on three key dimensions:\n\nPerformance against SLO\n\nThe amount of toil required to operate the service\n\nThe level of customer satisfaction with the service\n\nTable 2-5. SLO decision matrix\n\nSLOs\n\nToil\n\nCustomer satisfaction\n\nAction\n\nMet\n\nLow High\n\nMet Met\n\nLow Low High High\n\nHigh Low Met Low High Missed Missed Low Low Missed High High Missed High Low\n\nChoose to (a) relax release and deployment processes and increase velocity, or (b) step back from the engagement and focus engineering time on services that need more reliability. Tighten SLO. If alerting is generating false positives, reduce sensitivity. Otherwise, temporarily loosen the SLOs (or offload toil) and fix product and/or improve automated fault mitigation. Tighten SLO. Loosen SLO. Increase alerting sensitivity. Loosen SLO. Offload toil and fix product and/or improve automated fault mitigation.\n\nAdvanced Topics Once you have a healthy and mature SLO and error budget culture, you can continue to improve and refine how you measure and discuss the reliability of your services.\n\n38\n\n|\n\nChapter 2: Implementing SLOs",
      "content_length": 1941,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 71,
      "content": "Modeling User Journeys While all of the techniques discussed in this chapter will be beneficial to your organi‐ zation, ultimately SLOs should center on improving the customer experience. There‐ fore, you should write SLOs in terms of user-centric actions.\n\nYou can use critical user journeys to help capture the experience of your customers. A critical user journey is a sequence of tasks that is a core part of a given user’s experi‐ ence and an essential aspect of the service. For example, for an online shopping expe‐ rience, critical user journeys might include:\n\nSearching for a product\n\nAdding a product to a shopping cart\n\nCompleting a purchase\n\nThese tasks will almost certainly not map well to your existing SLIs; each task requires multiple complex steps that can fail at any point, and inferring the success (or failure) of these actions from logs can be extremely difficult. (For example, how do you determine if the user failed at the third step, or if they simply got distracted by cat videos in another tab?) However, we need to identify what matters to the user before we can start making sure that aspect of the service is reliable.\n\nOnce you identify user-centric events, you can solve the problem of measuring them. You might measure them by joining distinct log events together, using advanced JavaScript probing, using client-side instrumentation, or using some other process. Once you can measure an event, it becomes just another SLI, which you can track alongside your existing SLIs and SLOs. Critical user journeys can improve your recall without affecting your precision.\n\nGrading Interaction Importance Not all requests are considered equal. The HTTP request from a mobile app that checks for account notifications (where notifications are generated by a daily pipe‐ line) is important to your user, but is not as important as a billing-related request by your advertiser.\n\nWe need a way to distinguish certain classes of requests from others. You can use bucketing to accomplish this—that is, adding more labels to your SLIs, and then applying different SLOs to those different labels. Table 2-6 shows an example.\n\nTable 2-6. Bucketing by tier\n\nCustomer tier Availability SLO Premium Free\n\n99.99% 99.9%\n\nAdvanced Topics\n\n|\n\n39",
      "content_length": 2256,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 72,
      "content": "You can split requests by expected responsiveness, as shown in Table 2-7.\n\nTable 2-7. Bucketing by expected responsiveness\n\nResponsiveness Interactive (i.e., requests that block page load) CSV download\n\nLatency SLO 90% of requests complete in 100 ms 90% of downloads start within 5 s\n\nIf you have the data available to apply your SLO to each customer independently, you can track the number of customers who are in SLO at any given time. Note that this number can be highly variable—customers who send a very low number of requests will have either 100% availability (because they were lucky enough to experience no failures) or very low availability (because the one failure they experienced was a sig‐ nificant percentage of their requests). Individual customers can fail to meet their SLO for uninteresting reasons, but in aggregate, tracking problems that affect a wide num‐ ber of customers’ SLO compliance can be a useful signal.\n\nModeling Dependencies Large systems have many components. A single system may have a presentation layer, an application layer, a business logic layer, and a data persistence layer. Each of these layers may consist of many services or microservices.\n\nWhile your prime concern is implementing a user-centric SLO that covers the entire stack, SLOs can also be a useful way to coordinate and implement reliability require‐ ments between different components in the stack.\n\nFor example, if a single component is a critical dependency9 for a particularly high- value interaction, its reliability guarantee should be at least as high as the reliability guarantee of the dependent action. The team that runs that particular component needs to own and manage its service’s SLO in the same way as the overarching prod‐ uct SLO.\n\nIf a particular component has inherent reliability limitations, the SLO can communi‐ cate that limitation. If the user journey that depends upon it needs a higher level of availability than that component can reasonably provide, you need to engineer around that condition. You can either use a different component or add sufficient defenses (caching, offline store-and-forward processing, graceful degradation, etc.) to handle failures in that component.\n\nIt can be tempting to try to math your way out of these problems. If you have a ser‐ vice that offers 99.9% availability in a single zone, and you need 99.95% availability,\n\n9 A dependency is critical if its unavailability means that your service is also unavailable.\n\n40\n\n|\n\nChapter 2: Implementing SLOs",
      "content_length": 2516,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 73,
      "content": "simply deploying the service in two zones should solve that requirement. The proba‐ bility that both services will experience an outage at the same time is so low that two zones should provide 99.9999% availability. However, this reasoning assumes that both services are wholly independent, which is almost never the case. The two instan‐ ces of your app will have common dependencies, common failure domains, shared fate, and global control planes—all of which can cause an outage in both systems, no matter how carefully it is designed and managed. Unless each of these dependencies and failure patterns is carefully enumerated and accounted for, any such calculations will be deceptive.\n\nThere are two schools of thought regarding how an error budget policy should address a missed SLO when the failure is caused by a dependency that’s handled by another team:\n\nYour team should not halt releases or devote more time to reliability, as your sys‐ tem didn’t cause the issue.\n\nYou should enact a change freeze in order to minimize the chances of future out‐ ages, regardless of the cause of that outage.\n\nThe second approach will make your users happier. You have some flexibility in how you apply this principle. Depending on the nature of the outage and dependency, freezing changes may not be practical. Decide what is most appropriate for your ser‐ vice and its dependencies, and record that decision for posterity in your documented error budget. For an example of how this might work in practice, see the example error budget policy in Appendix B.\n\nExperimenting with Relaxing Your SLOs You may want to experiment with the reliability of your application and measure which changes in reliability (e.g., adding latency into page load times) have a measur‐ ably adverse impact on user behavior (e.g., percentage of users completing a pur‐ chase). We recommend performing this sort of analysis only if you are confident that you have error budget to burn. There are many subtle interactions between latency, availability, customers, business domains, and competition (or lack thereof). To make a choice to deliberately lower the perceived customer experience is a Rubicon to be crossed extremely thoughtfully, if at all.\n\nWhile this exercise might seem scary (nobody wants to lose sales!), the knowledge you can gain by performing such experiments will allow you to improve your service in ways that could lead to even better performance (and higher sales!) in the future. This process may allow you to mathematically identify a relationship between a key business metric (e.g., sales) and a measurable technical metric (e.g., latency). If it does, you have gained a very valuable piece of data you can use to make important engineering decisions for your service going forward.\n\nAdvanced Topics\n\n|\n\n41",
      "content_length": 2806,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 74,
      "content": "This exercise should not be a one-time activity. As your service evolves, so will your customers’ expectations. Make sure you regularly review the ongoing validity of the relationship.\n\nThis sort of analysis is also risky because you can misinterpret the data you get. For example, if you artificially slow your pages down by 50 ms and notice that no corre‐ sponding loss in conversions occurs, you might conclude that your latency SLO is too strict. However, your users might be unhappy, but simply lacking an alternative to your service at the moment. As soon as a competitor comes along, your users will leave. Be sure you are measuring the correct indicators, and take appropriate precautions.\n\nConclusion Every topic covered in this book can be tied back to SLOs. Now that you’ve read this chapter, we hope you’ll agree that even partly formalized SLOs (which clearly state your promises to users) offer a framework to discuss system behavior with greater clarity, and can help with pinpointing actionable remedies when services fail to meet expectations.\n\nTo summarize:\n\nSLOs are the tool by which you measure your service’s reliability.\n\nError budgets are a tool for balancing reliability with other engineering work, and a great way to decide which projects will have the most impact.\n\nYou should start using SLOs and error budgets today.\n\nFor an example SLO document and an example error budget policy, see Appendixes A and B.\n\n42\n\n|\n\nChapter 2: Implementing SLOs",
      "content_length": 1472,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 75,
      "content": "CHAPTER 3 SLO Engineering Case Studies\n\nBy Ben McCormack (Evernote) and William Bonnell (The Home Depot) with Garrett Plasky (Evernote), Alex Hidalgo, Betsy Beyer, and Dave Rensin\n\nWhile many tenets of SRE were shaped within the walls of Google, its principles have long lived outside our gates. Many standard Google SRE practices have been discov‐ ered in parallel or otherwise been adopted by many other organizations across the industry.\n\nSLOs are fundamental to the SRE model. Since we launched the Customer Reliability Engineering (CRE) team—a group of experienced SREs who help Google Cloud Plat‐ form (GCP) customers build more reliable services—almost every customer interac‐ tion starts and ends with SLOs.\n\nHere we present two stories, told by two very different companies, that outline their journeys toward adopting an SLO and error budget–based approach while working with the Google CRE team. For a more general discussion about SLOs and error budgets, see Chapter 2 in this book, and Chapter 3 in our first book.\n\nEvernote’s SLO Story by Ben McCormack, Evernote\n\nEvernote is a cross-platform app that helps individuals and teams create, assemble, and share information. With more than 220 million users worldwide, we store over 12 billion pieces of information—a mix of text-based notes, files, and attachments/ images—within the platform. Behind the scenes, the Evernote service is supported by 750+ MySQL instances.\n\n43",
      "content_length": 1436,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 76,
      "content": "We introduced the concept of SLOs to Evernote as part of a much wider technology revamp aimed at increasing engineering velocity while maintaining quality of service. Our goals included:\n\nMove engineering focus away from undifferentiated heavy lifting in datacenters and toward product engineering work that customers actually cared about. To that end, we stopped running our physical datacenters and moved to a public cloud.\n\nRevise the working model of operations and software engineers to support an increase in feature velocity while maintaining overall quality of service.\n\nRevamp how we look at SLAs to ensure that we increase focus on how failures impact our large global customer base.\n\nThese goals may look familiar to organizations across many industries. While no sin‐ gle approach to making these types of changes will work across the board, we hope that sharing our experience will provide valuable insights for others facing similar challenges.\n\nWhy Did Evernote Adopt the SRE Model? At the outset of this transition, Evernote was characterized by a traditional ops/dev split: an operations team protected the sanctity of the production environment, while a development team was tasked with developing new product features for customers. These objectives were usually in conflict: the dev team felt constrained by lengthy operational requirements, while the ops team became frustrated when new code introduced new issues in production. As we swung wildly between these two goals, the ops and dev teams developed a frustrated and strained relationship. We wanted to reach a happier medium that better balanced the varying needs of the teams involved.\n\nWe attempted to address the gaps in this traditional dichotomy in various ways over the course of five-plus years. After trying out a “You wrote it, you run it” (develop‐ ment) model, and a “You wrote it, we run it for you” (operations) model, we moved toward an SLO-centric SRE approach.\n\nSo what motivated Evernote to move in this direction?\n\nAt Evernote, we view the core disciplines of operations and development as separate professional tracks in which engineers can specialize. One track is concerned with the nearly 24/7 ongoing delivery of a service to customers. The other is concerned with the extension and evolution of that service to meet customer needs in the future. These two disciplines have moved toward each other in recent years as movements like SRE and DevOps emphasize software development as applied to operations. (This convergence has been furthered by advances in datacenter automation and the\n\n44\n\n|\n\nChapter 3: SLO Engineering Case Studies",
      "content_length": 2633,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 77,
      "content": "growth of public clouds, both of which give us a datacenter that can be fully con‐ trolled by software.) On the other side of the spectrum, full-stack ownership and con‐ tinuous deployment are increasingly applied to software development.\n\nWe were drawn to the SRE model because it fully embraces and accepts the differ‐ ences between operations and development while encouraging teams to work toward a common goal. It does not try to transform operations engineers into application developers, or vice versa. Instead, it gives both a common frame of reference. In our experience, an error budget/SLO approach has led both teams to make similar deci‐ sions when presented with the same facts, as it removes a good deal of subjectivity from the conversation.\n\nIntroduction of SLOs: A Journey in Progress The first part of our journey was the move from physical datacenters to Google Cloud Platform.1 Once the Evernote service was up and running on GCP and stabi‐ lized, we introduced SLOs. Our objectives here were twofold:\n\nAlign teams internally around Evernote SLOs, ensuring that all teams were work‐ ing within the new framework.\n\nIncorporate Evernote’s SLO into how we work with the Google Cloud team, who now had responsibility for our underlying infrastructure. Since we now had a new partner within the overall model, we needed to ensure the move to GCP did not dilute or mask our commitment to our users.\n\nAfter actively using SLOs for about nine months, Evernote is already on version 3 of its SLO practice!\n\nBefore getting into the technical details of an SLO, it is important to start the conver‐ sation from your customers’ point of view: what promises are you trying to uphold? Similar to most services, Evernote has many features and options that our users put to use in a variety of creative ways. We wanted to ensure we initially focused on the most important and common customer need: the availability of the Evernote service for users to access and sync their content across multiple clients. Our SLO journey started from that goal. We kept our first pass simple by focusing on uptime. Using this simple first approach, we could clearly articulate what we were measuring, and how.\n\n1 But that’s a story for another book—see more details at http://bit.ly/2spqgcl.\n\nEvernote’s SLO Story\n\n|\n\n45",
      "content_length": 2310,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 78,
      "content": "Our first SLOs document contained the following:\n\nA definition of the SLOs\n\nThis was an uptime measure: 99.95% uptime measured over a monthly window, set for certain services and methods. We chose this number based upon discus‐ sions with our internal customer support and product teams and—more impor‐ tantly—user feedback. We deliberately chose to bind our SLOs to a calendar month versus a rolling period to keep us focused and organized when running service reviews.\n\nWhat to measure, and how to measure it\n\nWhat to measure\n\nWe specified a service endpoint we could call to test whether the service was functioning as expected. In our case, we have a status page built into our ser‐ vice that exercises most of our stack and returns a 200 status code if all is well.\n\nHow to measure\n\nWe wanted a prober that called the status page periodically. We wanted that prober to be located completely outside of and independent from our envi‐ ronment so we could test all our components, including our load balancing stack. Our goal here was to make sure that we were measuring any and all failures of both the GCP service and the Evernote application. However, we did not want random internet issues to trigger false positives. We chose to use a third-party company that specializes in building and running such probers. We selected Pingdom, but there are many others in the market. We conduct our measurements as follows:\n\nFrequency of probe: We poll our frontend nodes every minute.\n\nLocation of probers: This setting is configurable; we currently use mul‐ tiple probes in North America and Europe.\n\nDefinition of “down”: If a prober check fails, the node is marked as Unconfirmed Down and then a second geographically separate prober performs a check. If the second check fails, the node is marked down for SLO calculation purposes. The node will continue to be marked as down as long as consecutive probe requests register errors.\n\nHow to calculate SLOs from monitoring data\n\nFinally, we carefully documented how we calculate the SLO from the raw data we received from Pingdom. For example, we specified how to account for mainte‐ nance windows: we could not assume that all of our hundreds of millions of users knew about our published maintenance windows. Uninformed users would\n\n46\n\n|\n\nChapter 3: SLO Engineering Case Studies",
      "content_length": 2328,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 79,
      "content": "therefore experience these windows as generic and unexplained downtime, so our SLO calculations treated maintenance as downtime.\n\nOnce we defined our SLOs, we had to do something with them. We wanted the SLOs to drive software and operations changes that would make our customers happier and keep them happy. How best to do this?\n\nWe use the SLO/error budget concept as a method to allocate resources going for‐ ward. For example, if we missed the SLO for last month, that behavior helps us pri‐ oritize relevant fixes, improvements, and bug fixes. We keep it simple: teams from both Evernote and Google conduct a monthly review of SLO performance. At this meeting, we review the SLO performance from the previous month and perform a deep dive on any outages. Based on this analysis of the past month, we set action items for improvements that may not have been captured through the regular root- cause-analysis process.\n\nThroughout this process, our guiding principle has been “Perfect is the enemy of good.” Even when SLOs aren’t perfect, they’re good enough to guide improvements over time. A “perfect” SLO would be one that measures every possible user interac‐ tion with our service and accounts for all edge cases. While this is a great idea on paper, it would take many months to achieve (if achieving perfection were even pos‐ sible)—time which we could use to improve the service. Instead, we selected an initial SLO that covered most, but not all, user interactions, which was a good proxy for quality of service.\n\nSince we began, we have revised our SLOs twice, according to signals from both our internal service reviews and in response to customer-impacting outages. Because we weren’t aiming for perfect SLOs at the outset, we were comfortable with making changes to better align with the business. In addition to our monthly Evernote/ Google review of SLO performance, we’ve settled on a six-month SLO review cycle, which strikes the right balance between changing SLOs too often and letting them become stale. In revising our SLOs, we’ve also learned that it’s important to balance what you would like to measure with what’s possible to measure.\n\nSince introducing SLOs, the relationship between our operations and development teams has subtly but markedly improved. The teams now have a common measure of success: removing the human interpretation of quality of service (QoS) has allowed both teams to maintain the same view and standards. To provide just one example, SLOs provided a common ground when we had to facilitate multiple releases in a compressed timeline in 2017. While we chased down a complex bug, product devel‐ opment requested that we apportion our normal weekly release over multiple sepa‐ rate windows, each of which would potentially impact customers. By applying an SLO calculation to the problem and removing human subjectivity from the scenario, we were able to better quantify customer impact and reduce our release windows from five to two to minimize customer pain.\n\nEvernote’s SLO Story\n\n|\n\n47",
      "content_length": 3038,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 80,
      "content": "Breaking Down the SLO Wall Between Customer and Cloud Provider A virtual wall between customer and cloud provider concerns might seem natural or inevitable. While Google has SLOs and SLAs (service level agreements) for the GCP platforms we run Evernote on, Evernote has its own SLOs and SLAs. It’s not always expected that two such engineering teams would be informed about each other’s SLAs.\n\nEvernote never wanted such a wall. Of course, we could have engineered to a dividing wall, basing our SLOs and SLAs on the underlying GCP metrics. Instead, from the beginning, we wanted Google to understand which performance characteristics were most important to us, and why. We wanted to align Google’s objectives with ours, and for both companies to view Evernote’s reliability successes and failures as shared responsibilities. To achieve this, we needed a way to:\n\nAlign objectives\n\nEnsure our partner (in this case, Google) really understood what’s important to us\n\nShare both successes and failures\n\nMost service providers manage to the published SLO/SLAs for their cloud services. Working within this context is important, but it can’t holistically represent how well our service is running within the cloud provider’s environment.\n\nFor example, a given cloud provider probably runs hundreds of thousands of virtual machines globally, which they manage for uptime and availability. GCP promises 99.95% availability for Compute Engine (i.e., its virtual machines). Even when GCP SLO graphs are green (i.e., above 99.95%), Evernote’s view of the same SLO might be very different: because our virtual machine footprint is only a small percentage of the global GCP number, outages isolated to our region (or isolated for other reasons) may be “lost” in the overall rollup to a global level.\n\nTo correct for scenarios like this, we share our SLO and real-time performance against SLO with Google. As a result, both the Google CRE team and Evernote work with same performance dashboards. This may seem like a very simple point, but has proven a rather powerful way to drive truly customer-focused behavior. As a result, rather than receiving generic “Service X is running slow”–type notifications, Google provides us with notifications that are more specific to our environment. For exam‐ ple, in addition to a generic “GCP load balancing environment is running slow today,” we’ll also be informed that this issue is causing a 5% impact to Evernote’s SLO. This relationship also helps teams within Google, who can see how their actions and decisions impact customers.\n\n48\n\n|\n\nChapter 3: SLO Engineering Case Studies",
      "content_length": 2611,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 81,
      "content": "This two-way relationship has also given us a very effective framework to support major incidents. Most of the time, the usual model of P1–P5 tickets and regular sup‐ port channels works well and allows us to maintain good service and a good relation‐ ship with Google. But we all know there are times when a P1 ticket (“major impact to our business”) is not enough—the times when your whole service is on the line and you face extended business impact.\n\nAt times like these, our shared SLOs and relationship with the CRE team come to fru‐ ition. We have a common understanding that if the SLO impact is high enough, both parties will treat the issue as a P1 ticket with special handling. Quite often, this means that Evernote and Google’s CRE Team rapidly mobilize on a shared conference bridge. The Google CRE team monitors the SLO we jointly defined and agreed upon, allowing us to remain in sync in terms of prioritization and appropriate responses.\n\nCurrent State After actively using SLOs for about nine months, Evernote is already on version 3 of its SLO practice. The next version of SLOs will progress from our simple uptime SLO. We plan to start probing individual API calls and accounting for the in-client view of metrics/performance so we can represent user QoS even better.\n\nBy providing a standard and defined way of measuring QoS, SLOs have allowed Ever‐ note to better focus on how our service is running. We can now have data-driven conversations—both internally, and with Google—about the impact of outages, which enables us to drive service improvements, ultimately making for more effective support teams and happier customers.\n\nThe Home Depot’s SLO Story by William Bonnell, The Home Depot\n\nThe Home Depot (THD) is the world’s largest home improvement retailer: we have more than 2,200 stores across North America, each filled with more than 35,000 unique products (and supplemented with over 1.5 million products online). Our infrastructure hosts a variety of software applications that support nearly 400,000 associates and process more than 1.5 billion customer transactions per year. The stores are deeply integrated with a global supply chain and an ecommerce website that receives more than 2 billion visits per year.\n\nIn a recent refresh to our operations approach aimed at increasing the velocity and quality of our software development, THD both pivoted to Agile software develop‐ ment and changed how we design and manage our software. We moved from cen‐ tralized support teams that supported large, monolithic software packages to a microservices architecture led by small, independently operated software develop‐\n\nThe Home Depot’s SLO Story\n\n|\n\n49",
      "content_length": 2682,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 82,
      "content": "ment teams. As a result, our system now had smaller chunks of constantly changing software, which also needed to be integrated across the stack.\n\nOur move to microservices was complemented by a move to a new “freedom and responsibility culture” of full-stack ownership. This approach gives developers free‐ dom to push code when they want, but also makes them jointly responsible for the operations of their service. For this model of joint ownership to work, operations and development teams need to speak a common language that promotes accountability and cuts across complexity: service level objectives. Services that depend upon each other need to know information like:\n\nHow reliable is your service? Is it built for three 9s, three and a half 9s, or four 9s (or better)? Is there planned downtime?\n\nWhat kind of latency can I expect at the upper bounds?\n\nCan you handle the volume of requests I am going to send? How do you handle overload? Has your service achieved its SLOs over time?\n\nIf every service could provide transparent and consistent answers to these questions, teams would have a clear view into their dependencies, which allows for better com‐ munication and increased trust and accountability between teams.\n\nThe SLO Culture Project Before we began this shift in our service model, The Home Depot didn’t have a cul‐ ture of SLOs. Monitoring tools and dashboards were plentiful, but were scattered everywhere and didn’t track data over time. We weren’t always able to pinpoint the service at the root of a given outage. Often, we began troubleshooting at the user- facing service and worked backward until we found the problem, wasting countless hours. If a service required planned downtime, its dependent services were surprised. If a team needed to build a three and a half 9s service, they wouldn’t know if the ser‐ vice they had a hard dependency on could support them with even better uptime (four 9s). These disconnects caused confusion and disappointment between our soft‐ ware development and operations teams.\n\nWe needed to address these disconnects by building a common culture of SLOs. Doing so required an overarching strategy to influence people, process, and technol‐ ogy. Our efforts spanned four general areas:\n\nCommon vernacular\n\nDefine SLOs in the context of THD. Define how to measure them in a consistent way.\n\n50\n\n|\n\nChapter 3: SLO Engineering Case Studies",
      "content_length": 2399,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 83,
      "content": "Evangelism\n\nSpread the word across the company.\n\nCreate training material to sell why SLOs matter, road shows across the com‐ pany, internal blogs, and promotional materials like t-shirts and stickers.\n\nEnlist a few early adopters to implement SLOs and demonstrate the value to others.\n\nEstablish a catchy acronym (VALET; as discussed later) to help the idea spread.\n\nCreate a training program (FiRE Academy: Fundamentals in Reliability Engineering) to train developers on SLOs and other reliability concepts.2\n\nAutomation\n\nTo reduce the friction of adoption, implement a metric collection platform to automatically collect service level indicators for any service deployed to produc‐ tion. These SLIs can later be more easily turned into SLOs.\n\nIncentive\n\nEstablish annual goals for all development managers to set and measure SLOs for their services.\n\nEstablishing a common vernacular was critical to getting everybody on the same page. We also wanted to keep this framework as simple as possible to help the idea spread faster. To get started, we took a critical look at the metrics we monitored across our various services and discovered some patterns. Every service monitored some form of its traffic volume, latency, errors, and utilization—metrics that map closely to Google SRE’s Four Golden Signals. In addition, many services monitored uptime or availability distinctly from errors. Unfortunately, across the board, all cat‐ egories of metrics were inconsistently monitored, were named differently, or had insufficient data.\n\nNone of our services had SLOs. The closest metric our production systems had to a customer-facing SLO was support tickets. The primary (and often only) way we measured the reliability of the applications deployed to our stores was by tracking the number of support calls our internal support desk receives.\n\n2 Training options range from a one-hour primer to half-day workshops to intense four-week immersion with\n\na mature SRE team, complete with a graduation ceremony and a FiRE badge.\n\nThe Home Depot’s SLO Story\n\n|\n\n51",
      "content_length": 2058,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 84,
      "content": "Our First Set of SLOs We couldn’t create SLOs for every aspect of our systems that could be measured, so we had to decide which metrics or SLIs should also have SLOs.\n\nAvailability and latency for API calls\n\nWe decided that each microservice had to have availability and latency SLOs for its API calls that were called by other microservices. For example, the Cart microservice called the Inventory microservice. For those API calls, the Inventory microservice published SLOs that the Cart microservice (and other microservices that needed Inventory) could consult to determine if the Inventory microservice could meet its reliability requirements\n\nInfrastructure utilization\n\nTeams at THD measure infrastructure utilization in different ways, but the most typi‐ cal measurement is real-time infrastructure utilization at one minute granularity. We decided against setting utilization SLOs for a few reasons. To begin with, microservi‐ ces aren’t overly concerned with this metric—your users don’t really care about uti‐ lization as long as you can handle the traffic volume, your microservice is up, it’s responding quickly, it’s not throwing errors, and you’re not in danger of running out of capacity. Additionally, our impending move to the cloud meant that utilization would be less of a concern, so cost planning would overshadow capacity planning. (We’d still need to monitor utilization and perform capacity planning, but we didn’t need to include it in our SLO framework.)\n\nTraffic volume\n\nBecause THD didn’t already have a culture of capacity planning, we needed a mecha‐ nism for software and operations teams to communicate how much volume their ser‐ vice could handle. Traffic was easy to define as requests to a service, but we needed to decide if we should track average requests per second, peak requests per second, or the volume of requests over the reporting time period. We decided to track all three and let each service select the most appropriate metric. We debated whether or not to set an SLO for traffic volume because this metric is determined by user behavior, rather than internal factors that we can control. Ultimately, we decided that as a retailer we needed to size our service for peaks like Black Friday, so we set an SLO according to expected peak capacity.\n\nLatency\n\nWe let each service define its SLO for latency and determine where to best measure it. Our only request was that a service should supplement our common white-box per‐ formance monitoring with black-box monitoring to catch issues caused by the\n\n52\n\n|\n\nChapter 3: SLO Engineering Case Studies",
      "content_length": 2594,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 85,
      "content": "network or other layers like caches and proxies that fail outside the microservice. We also decided that percentiles were more appropriate than arithmetic averages. At minimum, services needed to hit a 90th percentile target; user-facing services had a preferred target of 95th and/or 99th percentile.\n\nErrors\n\nErrors were somewhat complicated to account for. Since we were primarily dealing with web services, we had to standardize what constitutes an error and how to return errors. If a web service encountered an error, we naturally standardized on HTTP response codes:\n\nA service should not indicate an error in the body of a 2xx response; rather, it should throw either a 4xx or a 5xx.\n\nAn error caused by a problem with the service (for example, out of memory) should throw a 5xx error.\n\nAn error caused by the client (for example, sending a malformed request) should throw a 4xx error.\n\nAfter much deliberation, we decided to track both 4xx and 5xx errors, but used 5xx errors only to set SLOs. Similar to our approach for other SLO-related elements, we kept this dimension generic so that different applications could leverage it for differ‐ ent contexts. For example, in addition to HTTP errors, errors for a batch processing service might be the number of records that failed to process.\n\nTickets\n\nAs previously mentioned, tickets were originally the primary way we evaluated most of our production software. For historical reasons, we decided to continue to track tickets alongside our other SLOs. You can consider this metric as analogous to some‐ thing like “software operation level.”\n\nVALET\n\nWe summed up our new SLOs into a handy acronym: VALET.\n\nVolume (traffic)\n\nHow much business volume can my service handle?\n\nAvailability\n\nIs the service up when I need it?\n\nLatency\n\nDoes the service respond fast when I use it?\n\nThe Home Depot’s SLO Story\n\n|\n\n53",
      "content_length": 1868,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 86,
      "content": "Errors\n\nDoes the service throw an error when I use it?\n\nTickets\n\nDoes the service require manual intervention to complete my request?\n\nEvangelizing SLOs Armed with an easy-to-remember acronym, we set out to evangelize SLOs to the enterprise:\n\nWhy SLOs are important\n\nHow SLOs support our “freedom and responsibility” culture\n\nWhat should be measured\n\nWhat to do with the results\n\nSince developers were now responsible for the operation of their software, they needed to establish SLOs to demonstrate their ability to build and support reliable software, and also to communicate with the consumers of their services and product managers for customer-facing services. However, most of this audience was unfami‐ liar with concepts like SLAs and SLOs, so they needed to be educated on this new VALET framework.\n\nAs we needed to secure executive backing for our move to SLOs, our education cam‐ paign started with senior leadership. We then met with development teams one by one to espouse the values of SLOs. We encouraged teams to move from their custom metric-tracking mechanisms (which were often manual) to the VALET framework. To keep the momentum going, we sent a weekly SLO report in VALET format, which we paired with commentary around general reliability concepts and lessons learned from internal events, to senior leadership. This also helped frame business metrics like purchase orders created (Volume) or purchase orders that failed to process (Errors) in terms of VALET.\n\nWe also scaled our evangelism in a number of ways:\n\nWe set up an internal WordPress site to host blogs about VALET and reliability, outlinking to useful resources.\n\nWe conducted internal Tech Talks (including a Google SRE guest speaker) to discuss general reliability concepts and how to measure with VALET.\n\nWe conducted a series of VALET training workshops (which would later evolve into FiRE Academy), and opened the invite to whomever wanted to attend. The attendance for these workshops stayed strong for several months.\n\n54\n\n|\n\nChapter 3: SLO Engineering Case Studies",
      "content_length": 2055,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 87,
      "content": "We even created VALET laptop stickers and t-shirts to support a comprehensive internal marketing campaign.\n\nSoon everybody in the company knew VALET, and our new culture of SLOs began to take hold. SLO implementation even began to officially factor into THD’s annual performance reviews for development managers. While roughly 50 services were reg‐ ularly capturing and reporting on their SLOs on a weekly basis, we were storing the metrics ad hoc in a spreadsheet. Although the idea of VALET had caught on like wildfire, we needed to automate data collection to foster widespread adoption.\n\nAutomating VALET Data Collection While our culture of SLOs now had a strong foothold, automating VALET data col‐ lection would accelerate SLO adoption.\n\nTPS Reports\n\nWe built a framework to automatically capture VALET data for any service that was deployed to our new GCP environment. We called this framework TPS Reports, a play on the term we used for volume and performance testing (transactions per sec‐ ond), and, of course, to poke fun3 at the idea that multiple managers might want to review this data. We built the TPS Reports framework on top of GCP’s BigQuery database platform. All of the logs generated by our web-serving frontend were fed into BigQuery for processing by TPS Reports. We eventually also included metrics from a variety of other monitoring systems such as Stackdriver’s probe for availabil‐ ity.\n\nTPS Reports transformed this data into hourly VALET metrics that anyone could query. Newly created services were automatically registered into TPS Reports and therefore could be immediately queried. Since the data was all stored in BigQuery, we could efficiently report on VALET metrics across time frames. We used this data to build a variety of automated reports and alerts. The most interesting integration was a chatbot that let us directly report on the VALET of services in a commercial chat platform. For example, any service could display VALET for the last hour, VALET versus previous week, services out of SLO, and a variety of other interesting data right inside the chat channel.\n\nVALET service\n\nOur next step was to create a VALET application to store and report on SLO data. Because SLOs are best leveraged as a trending tool, the service tracks SLOs at daily, weekly, and monthly granularity. Note that our SLOs are a trending tool that we can\n\n3 As made famous in the 1999 film Office Space.\n\nThe Home Depot’s SLO Story\n\n|\n\n55",
      "content_length": 2459,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 88,
      "content": "use for error budgets, but aren’t directly connected to our monitoring systems. Instead, we have a variety of disparate monitoring platforms, each with its own alert‐ ing. Those monitoring systems aggregate their SLOs on a daily basis and publish to the VALET service for trending. The downside of this setup is that alerting thresh‐ olds set in the monitoring systems aren’t integrated with SLOs; however, we have the flexibility to change out monitoring systems as needed.\n\nAnticipating the need to integrate VALET with other applications not running in GCP, we created a VALET integration layer that provides an API to collect aggrega‐ ted VALET data for a service daily. TPS Reports was the first system to integrate with the VALET service, and we eventually integrated with a variety of on-premises appli‐ cation platforms (more than half of the services registered in VALET).\n\nVALET Dashboard\n\nThe VALET Dashboard (shown in Figure 3-1) is our UI to visualize and report on this data and is relatively straightforward. It allows users to:\n\nRegister a new service. This typically means assigning the service to one or more URLs, which may already have VALET data collected.\n\nSet SLO objectives for any of the five VALET categories.\n\nAdd new metrics types under each of the VALET categories. For example, one service may track latency at the 99th percentile, while another tracks latency at the 90th percentile (or both). Or, a backend processing system may track volume at a daily level (purchase orders created in a day), whereas a customer-serving frontend may track peak transactions per second.\n\nThe VALET Dashboard lets users report on SLOs for many services at once, and to slice and dice the data in a variety of ways. For example, a team can view stats for all of their services that missed SLO in the past week. A team seeking to review service performance can view latency across all of their services and the services they depend upon. The VALET Dashboard stores the data in a simple Cloud SQL database, and developers use a popular commercial reporting tool to build reports.\n\nThese reports became the foundation for a new best practice with developers: regular SLO reviews of their services (typically, either weekly or monthly). Based upon these reviews, developers can create action items to return a service to its SLO, or perhaps decide that an unrealistic SLO needs to be adjusted.\n\n56\n\n|\n\nChapter 3: SLO Engineering Case Studies",
      "content_length": 2451,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 89,
      "content": "Figure 3-1. The VALET Dashboard\n\nThe Proliferation of SLOs Once SLOs were firmly cemented in the organization’s collective mind and effective automation and reporting were in place, new SLOs proliferated quickly. After track‐ ing SLOs for about 50 services at the beginning of the year, by the end of the year we were tracking SLOs for 800 services, with about 50 new services per month being reg‐ istered with VALET.\n\nBecause VALET allowed us to scale SLO adoption across THD, the time effort required to develop automation was well worth it. However, other companies shouldn’t be scared away from adopting an SLO-based approach if they can’t develop similarly complex automation. While automation provided THD extra benefits, there are benefits to just writing SLOs in the first place.\n\nApplying VALET to Batch Applications As we developed robust reporting around SLOs, we discovered some additional uses for VALET. With a little adjusting, batch applications can fit into this framework as follows:\n\nThe Home Depot’s SLO Story\n\n|\n\n57",
      "content_length": 1036,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 90,
      "content": "Volume\n\nThe volume of records processed\n\nAvailability\n\nHow often (as a percentage) the job completed by a certain time\n\nLatency\n\nThe amount of time it takes for the job to run\n\nErrors\n\nThe records that failed to process\n\nTickets\n\nThe number of times an operator has to manually fix data and reprocess a job\n\nUsing VALET in Testing Since we were developing an SRE culture at the same time, we found that VALET supported our destructive testing (chaos engineering) automation in our staging environments. With the TPS Reports framework in place, we could automatically run destructive tests and record the impact (or hopefully lack of impact) to the service’s VALET data.\n\nFuture Aspirations With 800 services (and growing) collecting VALET data, we have a lot of useful operational data at our disposal. We have several aspirations for the future.\n\nNow that we are effectively collecting SLOs, we want to use this data to take action. Our next step is an error budget culture similar to Google, whereby a team stops pushing new features (other than improvements to reliability) when a service is out of SLO. To protect the velocity demands of our business, we’ll have to strive to find a good balance between the SLO reporting time frame (weekly or monthly) and the fre‐ quency of SLOs being breached. Like many companies adopting error budgets, we’re weighing the pros and cons of rolling windows versus fixed windows.\n\nWe want to further refine VALET to track detailed endpoints and the consumers of a service. Currently, even if a particular service has multiple endpoints, we track VALET only across the entire service. As a result, it’s difficult to distinguish between different operations (for example, a write to the catalog versus a read to the catalog; while we monitor and alert on these operations separately, we don’t track SLOs). Similarly, we’d also like to differentiate VALET results for different consumers of a service.\n\nAlthough we currently track latency SLOs at the web-serving layer, we’d also like to track a latency SLO for end users. This measurement would capture how factors like\n\n58\n\n|\n\nChapter 3: SLO Engineering Case Studies",
      "content_length": 2154,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 91,
      "content": "third-party tags, internet latency, and CDN caching affect how long it takes a page to start rendering and to complete rendering.\n\nWe’d also like to extend VALET data to application deployments. Specifically, we’d like to use automation to verify that VALET is within tolerance before rolling out a change to the next server, zone, or region.\n\nWe’ve started to collect information about service dependencies, and have prototy‐ ped a visual graph that shows where we’re not hitting VALET metrics along a call tree. This type of analysis will become even easier with emerging service mesh plat‐ forms.\n\nFinally, we strongly believe that the SLOs for a service should be set by the business owner of the service (often called a product manager) based on its criticality to the business. At the very least, we want the business owners to set the requirement for a service’s uptime and use that SLO as a shared objective between product manage‐ ment and development. Although technologists found VALET intuitive, the concept wasn’t so intuitive for product managers. We are striving to simplify the concepts of VALET using terminology relevant to them: we’ve both simplified the number of choices for uptime and provided example metrics. We also emphasize the significant investment required to move from one level to another. Here’s an example of simpli‐ fied VALET metrics we might provide:\n\n99.5%: Applications that are not used by store associates or an MVP of a new service\n\n99.9%: Adequate for the majority of nonselling systems at THD\n\n99.95%: Selling systems (or services that support selling systems)\n\n99.99%: Shared infrastructure services\n\nCasting metrics in business terms and sharing a visible goal (an SLO!) between prod‐ uct and development will reduce a lot of misaligned expectations about reliability often seen in large companies.\n\nSummary Introducing a new process, let alone a new culture, to a large company takes a good strategy, executive buy-in, strong evangelism, easy adoption patterns, and—most of all—patience. It might take years for a significant change like SLOs to become firmly established at a company. We’d like to emphasize that The Home Depot is a tradi‐ tional enterprise; if we can introduce such a large change successfully, you can too. You also don’t have to approach this task all at once. While we implemented SLOs piece by piece, developing a comprehensive evangelism strategy and clear incentive structure facilitated a quick transformation: we went from 0 to 800 SLO-supported services in less than a year.\n\nThe Home Depot’s SLO Story\n\n|\n\n59",
      "content_length": 2584,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 92,
      "content": "Conclusion SLOs and error budgets are powerful concepts that help address many different prob‐ lem sets. These case studies from Evernote and The Home Depot present very real examples of how implementing an SLO culture can bring product development and operations closer together. Doing so can facilitate communication and better inform development decisions. It will ultimately result in better experiences for your custom‐ ers—whether those customers are internal, external, humans, or other services.\n\nThese two case studies highlight that SLO culture is an ongoing process and not a one-time fix or solution. While they share philosophical underpinnings, THD’s and Evernote’s measurement styles, SLIs, SLOs, and implementation details are markedly different. Both stories complement Google’s own take on SLOs by demonstrating that SLO implementation need not be Google-specific. Just as these companies tail‐ ored SLOs to their own unique environments, so can other companies and organizations.\n\n60\n\n|\n\nChapter 3: SLO Engineering Case Studies",
      "content_length": 1046,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 93,
      "content": "CHAPTER 4 Monitoring\n\nBy Jess Frame, Anthony Lenton, Steven Thurgood, Anton Tolchanov, and Nejc Trdin with Carmela Quinito\n\nMonitoring can include many types of data, including metrics, text logging, struc‐ tured event logging, distributed tracing, and event introspection. While all of these approaches are useful in their own right, this chapter mostly addresses metrics and structured logging. In our experience, these two data sources are best suited to SRE’s fundamental monitoring needs.\n\nAt the most basic level, monitoring allows you to gain visibility into a system, which is a core requirement for judging service health and diagnosing your service when things go wrong. Chapter 6 in the first SRE book provides some basic monitoring definitions and explains that SREs monitor their systems in order to:\n\nAlert on conditions that require attention.\n\nInvestigate and diagnose those issues.\n\nDisplay information about the system visually.\n\nGain insight into trends in resource usage or service health for long-term planning.\n\nCompare the behavior of the system before and after a change, or between two groups in an experiment.\n\nThe relative importance of these use cases might lead you to make tradeoffs when selecting or building a monitoring system.\n\n61",
      "content_length": 1264,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 94,
      "content": "This chapter talks about how Google manages monitoring systems and provides some guidelines for questions that may arise when you’re choosing and running a monitoring system.\n\nDesirable Features of a Monitoring Strategy When choosing a monitoring system, it is important to understand and prioritize the features that matter to you. If you’re evaluating different monitoring systems, the attributes in this section can help guide your thinking about which solution(s) best suits your needs. If you already have a monitoring strategy, you might consider using some additional capabilities of your current solution. Depending on your needs, one monitoring system may address all of your use cases, or you may want to use a com‐ bination of systems.\n\nSpeed Different organizations will have different needs when it comes to the freshness of data and the speed of data retrieval.\n\nData should be available when you need it: freshness impacts how long it will take your monitoring system to page you when something goes wrong. Additionally, slow data might lead you to accidentally act on incorrect data. For example, during inci‐ dent response, if the time between cause (taking an action) and effect (seeing that action reflected in your monitoring) is too long, you might assume a change had no effect or deduce a false correlation between cause and effect. Data more than four to five minutes stale might significantly impact how quickly you can respond to an incident.\n\nIf you’re selecting a monitoring system based upon this criteria, you need to figure out your speed requirements ahead of time. Speed of data retrieval is mostly a prob‐ lem when you’re querying vast amounts of data. It might take some time for a graph to load if it has to tally up a lot of data from many monitored systems. To speed up your slower graphs, it’s helpful if the monitoring system can create and store new time series based on incoming data; then it can precompute answers to common queries.\n\nCalculations Support for calculations can span a variety of use cases, across a range of complexi‐ ties. At a minimum, you’ll probably want your system to retain data over a multi‐ month time frame. Without a long-term view of your data, you cannot analyze long- term trends like system growth. In terms of granularity, summary data (i.e., aggregated data that you can’t drill down into) is sufficient to facilitate growth plan‐ ning. Retaining all detailed individual metrics may help with answering questions\n\n62\n\n|\n\nChapter 4: Monitoring",
      "content_length": 2518,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 95,
      "content": "like, “Has this unusual behavior happened before?” However, the data might be expensive to store or impractical to retrieve.\n\nThe metrics you retain about events or resource consumption should ideally be monotonically incrementing counters. Using counters, your monitoring system can calculate windowed functions over time—for example, to report the rate of requests per second from that counter. Computing these rates over a longer window (up to a month) allows you to implement the building blocks for SLO burn-based alerting (see Chapter 5).\n\nFinally, support for a more complete range of statistical functions can be useful because trivial operations may mask bad behavior. A monitoring system that sup‐ ports computing percentiles (i.e., 50th, 95th, 99th percentiles) when recording latency will let you see if 50%, 5%, or 1% of your requests are too slow, whereas the arith‐ metic mean can only tell you—without specifics—that the request time is slower. Alternatively, if your system doesn’t support computing percentiles directly, you can achieve this by:\n\nObtaining a mean value by summing the seconds spent in requests and dividing by the number of requests\n\nLogging every request and computing the percentile values by scanning or sam‐ pling the log entries\n\nYou might want to record your raw metric data in a separate system for offline analy‐ sis—for example, to use in weekly or monthly reports, or to perform more intricate calculations that are too difficult to compute in your monitoring system.\n\nInterfaces A robust monitoring system should allow you to concisely display time-series data in graphs, and also to structure data in tables or a range of chart styles. Your dashboards will be primary interfaces for displaying monitoring, so it’s important that you choose formats that most clearly display the data you care about. Some options include heatmaps, histograms, and logarithmic scale graphs.\n\nYou’ll likely need to offer different views of the same data based upon audience; high- level management may want to view quite different information than SREs. Be spe‐ cific about creating dashboards that make sense to the people consuming the content. For each set of dashboards, displaying the same types of data consistently is valuable for communication.\n\nYou might need to graph information across different aggregations of a metric—such as machine type, server version, or request type—in real time. It’s a good idea for your team to be comfortable with performing ad hoc drill-downs on your data. By\n\nDesirable Features of a Monitoring Strategy\n\n|\n\n63",
      "content_length": 2579,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 96,
      "content": "slicing your data according to a variety of metrics, you can look for correlations and patterns in the data when you need it.\n\nAlerts It’s helpful to be able to classify alerts: multiple categories of alerts allow for propor‐ tional responses. The ability to set different severity levels for different alerts is also useful: you might file a ticket to investigate a low rate of errors that lasts more than an hour, while a 100% error rate is an emergency that deserves immediate response.\n\nAlert suppression functionality lets you avoid unnecessary noise from distracting on- call engineers. For example:\n\nWhen all nodes are experiencing the same high rate of errors, you can alert just once for the global error rate instead of sending an individual alert for every sin‐ gle node.\n\nWhen one of your service dependencies has a firing alert (e.g., a slow backend), you don’t need to alert for error rates of your service.\n\nYou also need to be able to ensure alerts are no longer suppressed once the event is over.\n\nThe level of control you require over your system will dictate whether you use a third-party monitoring service or deploy and run your own monitoring system. Goo‐ gle developed its own monitoring system in-house, but there are plenty of open source and commercial monitoring systems available.\n\nSources of Monitoring Data Your choice of monitoring system(s) will be informed by the specific sources of mon‐ itoring data you’ll use. This section discusses two common sources of monitoring data: logs and metrics. There are other valuable monitoring sources that we won’t cover here, like distributed tracing and runtime introspection.\n\nMetrics are numerical measurements representing attributes and events, typically harvested via many data points at regular time intervals. Logs are an append-only record of events. This chapter’s discussion focuses on structured logs that enable rich query and aggregation tools as opposed to plain-text logs.\n\nGoogle’s logs-based systems process large volumes of highly granular data. There’s some inherent delay between when an event occurs and when it is visible in logs. For analysis that’s not time-sensitive, these logs can be processed with a batch system, interrogated with ad hoc queries, and visualized with dashboards. An example of this workflow would be using Cloud Dataflow to process logs, BigQuery for ad hoc quer‐ ies, and Data Studio for the dashboards.\n\n64\n\n|\n\nChapter 4: Monitoring",
      "content_length": 2451,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 97,
      "content": "By contrast, our metrics-based monitoring system, which collects a large number of metrics from every service at Google, provides much less granular information, but in near real time. These characteristics are fairly typical of other logs- and metrics- based monitoring systems, although there are exceptions, such as real-time logs sys‐ tems or high-cardinality metrics.\n\nOur alerts and dashboards typically use metrics. The real-time nature of our metrics- based monitoring system means that engineers can be notified of problems very rap‐ idly. We tend to use logs to find the root cause of an issue, as the information we need is often not available as a metric.\n\nWhen reporting isn’t time-sensitive, we often generate detailed reports using logs processing systems because logs will nearly always produce more accurate data than metrics.\n\nIf you’re alerting based on metrics, it might be tempting to add more alerting based on logs—for example, if you need to be notified when even a single exceptional event happens. We still recommend metrics-based alerting in such cases: you can incre‐ ment a counter metric when a particular event happens, and configure an alert based on that metric’s value. This strategy keeps all alert configuration in one place, making it easier to manage (see “Managing Your Monitoring System” on page 67).\n\nExamples The following real-world examples illustrate how to reason through the process of choosing between monitoring systems.\n\nMove information from logs to metrics\n\nProblem. The HTTP status code is an important signal to App Engine customers debugging their errors. This information was available in logs, but not in metrics. The metrics dashboard could provide only a global rate of all errors, and did not include any information about the exact error code or the cause of the error. As a result, the workflow to debug an issue involved:\n\n1. Looking at the global error graph to find a time when an error occurred.\n\n2. Reading log files to look for lines containing an error.\n\n3. Attempting to correlate errors in the log file to the graph.\n\nThe logging tools did not give a sense of scale, making it hard to know if an error seen in one log line was occurring frequently. The logs also contained many other irrelevant lines, making it hard to track down the root cause.\n\nSources of Monitoring Data\n\n|\n\n65",
      "content_length": 2352,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 98,
      "content": "Proposed solution. The App Engine dev team chose to export the HTTP status code as a label on the metric (e.g., requests_total{status=404} versus requests_total {status=500}). Because the number of different HTTP status codes is relatively limi‐ ted, this did not increase the volume of metric data to an impractical size, but did make the most pertinent data available for graphing and alerting.\n\nOutcome. This new label meant the team could upgrade the graphs to show separate lines for different error categories and types. Customers could now quickly form con‐ jectures about possible problems based on the exposed error codes. We could now also set different alerting thresholds for client and server errors, making the alerts trigger more accurately.\n\nImprove both logs and metrics\n\nProblem. One Ads SRE team maintained ~50 services, which were written in a num‐ ber of different languages and frameworks. The team used logs as the canonical source of truth for SLO compliance. To calculate the error budget, each service used a logs processing script with many service-specific special cases. Here’s an example script to process a log entry for a single service:\n\nIf the HTTP status code was in the range (500, 599) AND the 'SERVER ERROR' field of the log is populated AND DEBUG cookie was not set as part of the request AND the url did not contain '/reports' AND the 'exception' field did not contain 'com.google.ads.PasswordException' THEN increment the error counter by 1\n\nThese scripts were hard to maintain and also used data that wasn’t available to the metrics-based monitoring system. Because metrics drove alerts, sometimes the alerts would not correspond to user-facing errors. Every alert required an explicit triage step to determine if it was user-facing, which slowed down response time.\n\nProposed solution. The team created a library that hooked into the logic of the frame‐ work languages of each application. The library decided if the error was impacting users at request time. The instrumentation wrote this decision in logs and exported it as a metric at the same time, improving consistency. If the metric showed that the service had returned an error, the logs contained the exact error, along with request- related data to help reproduce and debug the issue. Correspondingly, any SLO- impacting error that manifested in the logs also changed the SLI metrics, which the team could then alert on.\n\nOutcome. By introducing a uniform control surface across multiple services, the team reused tooling and alerting logic instead of implementing multiple custom solutions. logs All services benefited from removing the complicated, service-specific\n\n66\n\n|\n\nChapter 4: Monitoring",
      "content_length": 2701,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 99,
      "content": "processing code, which resulted in increased scalability. Once alerts were directly tied to SLOs, they were more clearly actionable, so the false-positive rate decreased significantly.\n\nKeep logs as the data source\n\nProblem. While investigating production issues, one SRE team would often look at the affected entity IDs to determine user impact and root cause. As with the earlier App Engine example, this investigation required data that was available only in logs. The team had to perform one-off log queries for this while they were responding to incidents. This step added time to incident recovery: a few minutes to correctly put together the query, plus the time to query the logs.\n\nProposed solution. The team initially debated whether a metric should replace their log tools. Unlike in the App Engine example, the entity ID could take on millions of different values, so it would not be practical as a metric label.\n\nUltimately, the team decided to write a script to perform the one-off log queries they needed, and documented which script to run in the alert emails. They could then copy the command directly into a terminal if necessary.\n\nOutcome. The team no longer had the cognitive load of managing the correct one-off log query. Accordingly, they could get the results they needed faster (although not as quickly as a metrics-based approach). They also had a backup plan: they could run the script automatically as soon as an alert triggered, and use a small server to query the logs at regular intervals to constantly retrieve semifresh data.\n\nManaging Your Monitoring System Your monitoring system is as important as any other service you run. As such, it should be treated with the appropriate level of care and attention.\n\nTreat Your Configuration as Code Treating system configuration as code and storing it in the revision control system are common practices that provide some obvious benefits: change history, links from specific changes to your task tracking system, easier rollbacks and linting checks,1 and enforced code review procedures.\n\nWe strongly recommend also treating monitoring configuration as code (for more on configuration, see Chapter 14). A monitoring system that supports intent-based\n\n1 For example, using promtool to verify that your Prometheus config is syntactically correct.\n\nManaging Your Monitoring System\n\n|\n\n67",
      "content_length": 2361,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 100,
      "content": "configuration is preferable to systems that only provide web UIs or CRUD-style APIs. This configuration approach is standard for many open source binaries that only read a configuration file. Some third-party solutions like grafanalib enable this approach for components that are traditionally configured with a UI.\n\nEncourage Consistency Large companies with multiple engineering teams who use monitoring need to strike a fine balance: a centralized approach provides consistency, but on the other hand, individual teams may want full control over the design of their configuration.\n\nThe right solution depends on your organization. Google’s approach has evolved over time toward convergence on a single framework run centrally as a service. This solution works well for us for a few reasons. A single framework enables engineers to ramp up faster when they switch teams, and makes collaboration during debugging easier. We also have a centralized dashboarding service, where each team’s dash‐ boards are discoverable and accessible. If you easily understand another team’s dash‐ board, you can debug both your issues and theirs more quickly.\n\nIf possible, make basic monitoring coverage effortless. If all your services2 export a consistent set of basic metrics, you can automatically collect those metrics across your entire organization and provide a consistent set of dashboards. This approach means that any new component you launch automatically has basic monitoring. Many teams across your company—even nonengineering teams—can use this moni‐ toring data.\n\nPrefer Loose Coupling Business requirements change, and your production system will look different a year from now. Similarly, your monitoring system needs to evolve over time as the serv‐ ices it monitors evolve through different patterns of failure.\n\nWe recommend keeping the components of your monitoring system loosely coupled. You should have stable interfaces for configuring each component and passing moni‐ toring data. Separate components should be in charge of collecting, storing, alerting, and visualizing your monitoring. Stable interfaces make it easier to swap out any given component for a better alternative.\n\nSplitting functionality into individual components is becoming popular in the open source world. A decade ago, monitoring systems like Zabbix combined all functions into a single component. Modern design usually involves separating collection and\n\n2 You can export basic metrics via a common library: an instrumentation framework like OpenCensus, or a\n\nservice mesh like Istio.\n\n68\n\n|\n\nChapter 4: Monitoring",
      "content_length": 2599,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 101,
      "content": "rule evaluation (with a solution like Prometheus server), long-term time series stor‐ age (InfluxDB), alert aggregation (Alertmanager), and dashboarding (Grafana).\n\nAs of this writing, there are at least two popular open standards for instrumenting your software and exposing metrics:\n\nstatsd\n\nThe metric aggregation daemon initially written by Etsy and now ported to a majority of programming languages.\n\nPrometheus\n\nAn open source monitoring solution with a flexible data model, support for met‐ ric labels, and robust histogram functionality. Other systems are now adopting the Prometheus format, and it is being standardized as OpenMetrics.\n\nA separate dashboarding system that can use multiple data sources provides a central and unified overview of your service. Google recently saw this benefit in practice: our legacy monitoring system (Borgmon3) combined dashboards in the same configura‐ tion as alerting rules. While migrating to a new system (Monarch), we decided to move dashboarding into a separate service (Viceroy). Because Viceroy was not a component of Borgmon or Monarch, Monarch had fewer functional requirements. Since users could use Viceroy to display graphs based on data from both monitoring systems, they could gradually migrate from Borgmon to Monarch.\n\nMetrics with Purpose Chapter 5 covers how to monitor and alert using SLI metrics when a system’s error budget is under threat. SLI metrics are the first metrics you want to check when SLO- based alerts trigger. These metrics should appear prominently in your service’s dash‐ board, ideally on its landing page.\n\nWhen investigating the cause of an SLO violation, you will most likely not get enough information from the SLO dashboards. These dashboards show that you are violating the SLO, but not necessarily why. What other data should the monitoring dashboards display?\n\nWe’ve found the following guidelines helpful in implementing metrics. These metrics should provide reasonable monitoring that allows you to investigate production issues and also provide a broad range of information about your service.\n\n3 See Chapter 10 of Site Reliability Engineering for Borgmon’s concepts and structure.\n\nMetrics with Purpose\n\n|\n\n69",
      "content_length": 2206,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 102,
      "content": "Intended Changes When diagnosing an SLO-based alert, you need to be able to move from alerting met‐ rics that notify you of user-impacting issues to metrics that tell you what is causing these issues. Recent intended changes to your service might be at fault. Add monitor‐ ing that informs you of any changes in production.4 To determine the trigger, we rec‐ ommend the following:\n\nMonitor the version of the binary.\n\nMonitor the command-line flags, especially when you use these flags to enable and disable features of the service.\n\nIf configuration data is pushed to your service dynamically, monitor the version of this dynamic configuration.\n\nIf any of these pieces of the system aren’t versioned, you should be able to monitor the timestamp at which it was last built or packaged.\n\nWhen you’re trying to correlate an outage with a rollout, it’s much easier to look at a graph/dashboard linked from your alert than to trawl through your CI/CD (continu‐ ous integration/continuous delivery) system logs after the fact.\n\nDependencies Even if your service didn’t change, any of its dependencies might change or have problems, so you should also monitor responses coming from direct dependencies.\n\nIt’s reasonable to export the request and response size in bytes, latency, and response codes for each dependency. When choosing the metrics to graph, keep the four golden signals in mind. You can use additional labels on the metrics to break them down by response code, RPC (remote procedure call) method name, and peer job name.\n\nIdeally, you can instrument the lower-level RPC client library to export these metrics once, instead of asking each RPC client library to export them.5 Instrumenting the client library provides more consistency and allows you to monitor new dependen‐ cies for free.\n\nYou will sometimes come across dependencies that offer a very narrow API, where all functionality is available via a single RPC called Get, Query, or something equally\n\n4 This is one case where monitoring via logs is appealing, particularly because production changes are relatively infrequent. Whether you use logs or metrics, these changes should be surfaced in your dashboards so they’re easily accessible for debugging production issues.\n\n5 See https://opencensus.io/ for a set of libraries that provides this.\n\n70\n\n|\n\nChapter 4: Monitoring",
      "content_length": 2341,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 103,
      "content": "unhelpful, and the actual command is specified as arguments to this RPC. A single instrumentation point in the client library falls short with this type of dependency: you will observe a high variance in latency and some percentage of errors that may or may not indicate that some part of this opaque API is failing entirely. If this depend‐ ency is critical, you have a couple of options to monitor it well:\n\nExport separate metrics to tailor for the dependency, so that the metrics can unpack requests they receive to get at the actual signal.\n\nAsk the dependency owners to perform a rewrite to export a broader API that supports separate functionality split across separate RPC services and methods.\n\nSaturation Aim to monitor and track the usage of every resource the service relies upon. Some resources have hard limits you cannot exceed, like RAM, disk, or CPU quota alloca‐ ted to your application. Other resources—like open file descriptors, active threads in any thread pools, waiting times in queues, or the volume of written logs—may not have a clear hard limit but still require management.\n\nDepending on the programming language in use, you should monitor additional resources:\n\nIn Java: The heap and metaspace size, and more specific metrics depending on what type of garbage collection you’re using\n\nIn Go: The number of goroutines\n\nThe languages themselves provide varying support to track these resources.\n\nIn addition to alerting on significant events as described in Chapter 5 you might also need to set up alerting that fires when you approach exhaustion for specific resources, such as:\n\nWhen the resource has a hard limit\n\nWhen crossing a usage threshold causes performance degradation\n\nYou should have monitoring metrics to track all resources—even resources that the service manages well. These metrics are vital in capacity and resource planning.\n\nMetrics with Purpose\n\n|\n\n71",
      "content_length": 1900,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 104,
      "content": "Status of Served Traffic It’s a good idea to add metrics or metric labels that allow the dashboards to break down served traffic by status code (unless the metrics your service uses for SLI pur‐ poses already include this information). Here are some recommendations:\n\nFor HTTP traffic, monitor all response codes, even if they don’t provide enough signal for alerting, because some can be triggered by incorrect client behavior.\n\nIf you apply rate limits or quota limits to your users, monitor aggregates of how many requests were denied due to lack of quota.\n\nGraphs of this data can help you identify when the volume of errors changes noticea‐ bly during a production change.\n\nImplementing Purposeful Metrics Each exposed metric should serve a purpose. Resist the temptation of exporting a handful of metrics just because they are easy to generate. Instead, think about how these metrics will be used. Metric design, or lack thereof, has implications.\n\nIdeally, metric values used for alerting change dramatically only when the system enters a problem state, and don’t change when a system is operating normally. On the other hand, metrics for debugging don’t have these requirements—they’re intended to provide insight about what is happening when alerts are triggered. Good debugging metrics will point at some aspect of the system that’s potentially causing the issues. When you write a postmortem, think about which additional metrics would have allowed you to diagnose the issue faster.\n\nTesting Alerting Logic In an ideal world, monitoring and alerting code should be subject to the same testing standards as code development. While Prometheus developers are discussing devel‐ oping unit tests for monitoring, there is currently no broadly adopted system that allows you to do this.\n\nAt Google, we test our monitoring and alerting using a domain-specific language that allows us to create synthetic time series. We then write assertions based upon the val‐ ues in a derived time series, or the firing status and label presence of specific alerts.\n\nMonitoring and alerting is often a multistage process, which therefore calls for multi‐ ple families of unit tests. While this area remains largely underdeveloped, should you want to implement monitoring testing at some point, we recommend a three-tiered approach, as shown in Figure 4-1.\n\n72\n\n|\n\nChapter 4: Monitoring",
      "content_length": 2374,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 105,
      "content": "Figure 4-1. Monitoring testing environment tiers\n\n1. Binary reporting: Check that the exported metric variables change in value under certain conditions as expected.\n\n2. Monitoring configurations: Make sure that rule evaluation produces expected results, and that specific conditions produce the expected alerts.\n\n3. Alerting configurations: Test that generated alerts are routed to a predeter‐ mined destination, based on alert label values.\n\nIf you can’t test your monitoring via synthetic means, or there’s a stage of your moni‐ toring you simply can’t test, consider creating a running system that exports well- known metrics, like number of requests and errors. You can use this system to validate derived time series and alerts. It’s very likely that your alerting rules will not fire for months or years after you configure them, and you need to have confidence that when the metric passes a certain threshold, the correct engineers will be alerted with notifications that make sense.\n\nConclusion Because the SRE role is responsible for the reliability of systems in production, SREs are often required to be intimately familiar with a service’s monitoring system and its features. Without this knowledge, SREs might not know where to look, how to iden‐ tify abnormal behavior, or how to find the information they need during an emergency.\n\nWe hope that by pointing out monitoring system features we find useful and why, we can help you evaluate how well your monitoring strategy fits your needs, explore some additional features you might be able to leverage, and consider changes you might want to make. You’ll probably find it useful to combine some source of metrics and logging in your monitoring strategy; the exact mix you need is highly context- dependent. Make sure to collect metrics that serve a particular purpose. That purpose may be to enable better capacity planning, assist in debugging, or directly notify you about problems.\n\nConclusion\n\n|\n\n73",
      "content_length": 1968,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 106,
      "content": "Once you have monitoring in place, it needs to be visible and useful. To this end, we also recommend testing your monitoring setup. A good monitoring system pays divi‐ dends. It is well worth the investment to put substantial thought into what solutions best meet your needs, and to iterate until you get it right.\n\n74\n\n|\n\nChapter 4: Monitoring",
      "content_length": 344,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 107,
      "content": "CHAPTER 5 Alerting on SLOs\n\nBy Steven Thurgood with Jess Frame, Anthony Lenton, Carmela Quinito, Anton Tolchanov, and Nejc Trdin\n\nThis chapter explains how to turn your SLOs into actionable alerts on significant events. Both our first SRE book and this book talk about implementing SLOs. We believe that having good SLOs that measure the reliability of your platform, as experi‐ enced by your customers, provides the highest-quality indication for when an on-call engineer should respond. Here we give specific guidance on how to turn those SLOs into alerting rules so that you can respond to problems before you consume too much of your error budget.\n\nOur examples present a series of increasingly complex implementations for alerting metrics and logic; we discuss the utility and shortcomings of each. While our exam‐ ples use a simple request-driven service and Prometheus syntax, you can apply this approach in any alerting framework.\n\nAlerting Considerations In order to generate alerts from service level indicators (SLIs) and an error budget, you need a way to combine these two elements into a specific rule. Your goal is to be notified for a significant event: an event that consumes a large fraction of the error budget.\n\nConsider the following attributes when evaluating an alerting strategy:\n\n75",
      "content_length": 1307,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 108,
      "content": "Precision\n\nThe proportion of events detected that were significant. Precision is 100% if every alert corresponds to a significant event. Note that alerting can become par‐ ticularly sensitive to nonsignificant events during low-traffic periods (discussed in “Low-Traffic Services and Error Budget Alerting” on page 86).\n\nRecall\n\nThe proportion of significant events detected. Recall is 100% if every significant event results in an alert.\n\nDetection time\n\nHow long it takes to send notifications in various conditions. Long detection times can negatively impact the error budget.\n\nReset time\n\nHow long alerts fire after an issue is resolved. Long reset times can lead to confu‐ sion or to issues being ignored.\n\nWays to Alert on Significant Events Constructing alert rules for your SLOs can become quite complex. Here we present six ways to configure alerting on significant events, in order of increasing fidelity, to arrive at an option that offers good control over the four parameters of precision, recall, detection time, and reset time simultaneously. Each of the following approaches addresses a different problem, and some eventually solve multiple prob‐ lems at the same time. The first three nonviable attempts work toward the latter three viable alerting strategies, with approach 6 being the most viable and most highly rec‐ ommended option. The first method is simple to implement but inadequate, while the optimal method provides a complete solution to defend an SLO over both the long and the short term.\n\nFor the purposes of this discussion, “error budgets” and “error rates” apply to all SLIs, not just those with “error” in their name. In the section “What to Measure: Using SLIs” on page 20, we recommend using SLIs that capture the ratio of good events to total events. The error budget gives the number of allowed bad events, and the error rate is the ratio of bad events to total events.\n\n1: Target Error Rate ≥ SLO Threshold For the most trivial solution, you can choose a small time window (for example, 10 minutes) and alert if the error rate over that window exceeds the SLO.\n\nFor example, if the SLO is 99.9% over 30 days, alert if the error rate over the previous 10 minutes is ≥ 0.1%:\n\n76\n\n|\n\nChapter 5: Alerting on SLOs",
      "content_length": 2249,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 109,
      "content": "alert: HighErrorRate expr: job:slo_errors_per_request:ratio_rate10m{job=\"myjob\"} >= 0.001\n\nThis 10-minute average is calculated in Prometheus with a Record‐ ing rule:\n\nrecord: job:slo_errors_per_request:ratio_rate10m expr: sum(rate(slo_errors[10m])) by (job) / sum(rate(slo_requests[10m])) by (job)\n\nIf you don’t export slo_errors and slo_requests from your job, you can create the time series by renaming a metric:\n\nrecord: slo_errors expr: http_errors\n\nAlerting when the recent error rate is equal to the SLO means that the system detects a budget spend of:\n\nalerting window size reporting period\n\nFigure 5-1 shows the relationship between detection time and error rate for an exam‐ ple service with an alert window of 10 minutes and a 99.9% SLO.\n\nFigure 5-1. Detection time for an example service with an alert window of 10 minutes and a 99.9% SLO\n\nTable 5-1 shows the benefits and disadvantages of alerting when the immediate error rate is too high.\n\nWays to Alert on Significant Events\n\n|\n\n77",
      "content_length": 997,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 110,
      "content": "Table 5-1. Pros and cons of alerting when the immediate error rate is too high\n\nPros Detection time is good: 0.6 seconds for a total outage. This alert fires on any event that threatens the SLO, exhibiting good recall.\n\nCons Precision is low: The alert fires on many events that do not threaten the SLO. A 0.1% error rate for 10 minutes would alert, while consuming only 0.02% of the monthly error budget. Taking this example to an extreme, you could receive up to 144 alerts per day every day, not act upon any alerts, and still meet the SLO.\n\n2: Increased Alert Window We can build upon the preceding example by changing the size of the alert window to improve precision. By increasing the window size, you spend a higher budget amount before triggering an alert.\n\nTo keep the rate of alerts manageable, you decide to be notified only if an event con‐ sumes 5% of the 30-day error budget—a 36-hour window:\n\nalert: HighErrorRate expr: job:slo_errors_per_request:ratio_rate36h{job=\"myjob\"} > 0.001\n\nNow, the detection time is:\n\n1 − SLO error ratio × alerting window size\n\nTable 5-2 shows the benefits and disadvantages of alerting when the error rate is too high over a larger window of time.\n\nTable 5-2. Pros and cons of alerting when the error rate is too high over a larger window of time\n\nPros Detection time is still good: 2 minutes and 10 seconds for a complete outage. Better precision than the previous example: by ensuring that the error rate is sustained for longer, an alert will likely represent a significant threat to the error budget.\n\nCons Very poor reset time: In the case of 100% outage, an alert will fire shortly after 2 minutes, and continue to fire for the next 36 hours. Calculating rates over longer windows can be expensive in terms of memory or I/O operations, due to the large number of data points.\n\nFigure 5-2 shows that while the error rate over a 36-hour period has fallen to a negli‐ gible level, the 36-hour average error rate remains above the threshold.\n\n78\n\n|\n\nChapter 5: Alerting on SLOs",
      "content_length": 2024,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 111,
      "content": "Figure 5-2. Error rate over a 36-hour period\n\n3: Incrementing Alert Duration Most monitoring systems allow you to add a duration parameter to the alert criteria so the alert won’t fire unless the value remains above the threshold for some time. You may be tempted to use this parameter as a relatively inexpensive way to add longer windows:\n\nalert: HighErrorRate expr: job:slo_errors_per_request:ratio_rate1m{job=\"myjob\"} > 0.001 for: 1h\n\nTable 5-3 shows the benefits and disadvantages of using a duration parameter for alerts.\n\nTable 5-3. Pros and cons of using a duration parameter for alerts\n\nPros Alerts can be higher precision. Requiring a sustained error rate before firing means that alerts are more likely to correspond to a significant event.\n\nCons Poor recall and poor detection time: Because the duration does not scale with the severity of the incident, a 100% outage alerts after one hour, the same detection time as a 0.2% outage. The 100% outage would consume 140% of the 30-day budget in that hour. If the metric even momentarily returns to a level within SLO, the duration timer resets. An SLI that fluctuates between missing SLO and passing SLO may never alert.\n\nFor the reasons listed in Table 5-3, we do not recommend using durations as part of your SLO-based alerting criteria.1\n\n1 Duration clauses can occasionally be useful when you are filtering out ephemeral noise over very short dura‐\n\ntions. However, you still need to be aware of the cons listed in this section.\n\nWays to Alert on Significant Events\n\n|\n\n79",
      "content_length": 1535,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 112,
      "content": "Figure 5-3 shows the average error rate over a 5-minute window of a service with a 10-minute duration before the alert fires. A series of 100% error spikes lasting 5 minutes every 10 minutes never triggers an alert, despite consuming 35% of the error budget.\n\nFigure 5-3. A service with 100% error spikes every 10 minutes\n\nEach spike consumed almost 12% of the 30-day budget, yet the alert never triggered.\n\n4: Alert on Burn Rate To improve upon the previous solution, you want to create an alert with good detec‐ tion time and high precision. To this end, you can introduce a burn rate to reduce the size of the window while keeping the alert budget spend constant.\n\nBurn rate is how fast, relative to the SLO, the service consumes the error budget. Figure 5-4 shows the relationship between burn rates and error budgets.\n\nThe example service uses a burn rate of 1, which means that it’s consuming error budget at a rate that leaves you with exactly 0 budget at the end of the SLO’s time window (see Chapter 4 in our first book). With an SLO of 99.9% over a time window of 30 days, a constant 0.1% error rate uses exactly all of the error budget: a burn rate of 1.\n\n80\n\n|\n\nChapter 5: Alerting on SLOs",
      "content_length": 1201,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 113,
      "content": "Figure 5-4. Error budgets relative to burn rates\n\nTable 5-4 shows burn rates, their corresponding error rates, and the time it takes to exhaust the SLO budget.\n\nTable 5-4. Burn rates and time to complete budget exhaustion\n\nBurn rate 1 2 10 1,000\n\nError rate for a 99.9% SLO Time to exhaustion 0.1% 0.2% 1% 100%\n\n30 days 15 days 3 days 43 minutes\n\nBy keeping the alert window fixed at one hour and deciding that a 5% error budget spend is significant enough to notify someone, you can derive the burn rate to use for the alert.\n\nFor burn rate–based alerts, the time taken for an alert to fire is:\n\n1 − SLO error ratio × alerting window size × burn rate\n\nThe error budget consumed by the time the alert fires is:\n\nburn rate × alerting window size period\n\nWays to Alert on Significant Events\n\n|\n\n81",
      "content_length": 795,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 114,
      "content": "Five percent of a 30-day error budget spend over one hour requires a burn rate of 36. The alerting rule now becomes:\n\nalert: HighErrorRate expr: job:slo_errors_per_request:ratio_rate1h{job=\"myjob\"} > 36 * 0.001\n\nTable 5-5 shows the benefits and limitations of alerting based on burn rate.\n\nTable 5-5. Pros and cons of alerting based on burn rate\n\nPros Good precision: This strategy chooses a significant portion of error budget spend upon which to alert. Shorter time window, which is cheaper to calculate. Good detection time. Better reset time: 58 minutes.\n\nCons Low recall: A 35x burn rate never alerts, but consumes all of the 30-day error budget in 20.5 hours. Reset time: 58 minutes is still too long.\n\n5: Multiple Burn Rate Alerts Your alerting logic can use multiple burn rates and time windows, and fire alerts when burn rates surpass a specified threshold. This option retains the benefits of alerting on burn rates and ensures that you don’t overlook lower (but still significant) error rates.\n\nIt’s also a good idea to set up ticket notifications for incidents that typically go unno‐ ticed but can exhaust your error budget if left unchecked—for example, a 10% budget consumption in three days. This rate of errors catches significant events, but since the rate of budget consumption provides adequate time to address the event, you don’t need to page someone.\n\nWe recommend 2% budget consumption in one hour and 5% budget consumption in six hours as reasonable starting numbers for paging, and 10% budget consumption in three days as a good baseline for ticket alerts. The appropriate numbers depend on the service and the baseline page load. For busier services, and depending on on-call responsibilities over weekends and holidays, you may want ticket alerts for the six- hour window.\n\nTable 5-6 shows the corresponding burn rates and time windows for percentages of SLO budget consumed.\n\nTable 5-6. Recommended time windows and burn rates for percentages of SLO budget consumed\n\nSLO budget consumption Time window Burn rate Notification 2% 5% 10%\n\n1 hour 6 hours 3 days\n\n14.4 6 1\n\nPage Page Ticket\n\n82\n\n|\n\nChapter 5: Alerting on SLOs",
      "content_length": 2150,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 115,
      "content": "The alerting configuration may look like something like:\n\nexpr: ( job:slo_errors_per_request:ratio_rate1h{job=\"myjob\"} > (14.4*0.001) or job:slo_errors_per_request:ratio_rate6h{job=\"myjob\"} > (6*0.001) ) severity: page\n\nexpr: job:slo_errors_per_request:ratio_rate3d{job=\"myjob\"} > 0.001 severity: ticket\n\nFigure 5-5 shows the detection time and alert type according to the error rate.\n\nFigure 5-5. Error rate, detection time, and alert notification\n\nMultiple burn rates allow you to adjust the alert to give appropriate priority based on how quickly you have to respond. If an issue will exhaust the error budget within hours or a few days, sending an active notification is appropriate. Otherwise, a ticket- based notification to address the alert the next working day is more appropriate.2\n\nTable 5-7 lists the benefits and disadvantages of using multiple burn rates.\n\n2 As described in the introduction to Site Reliability Engineering, pages and tickets are the only valid ways to get\n\na human to take action.\n\nWays to Alert on Significant Events\n\n|\n\n83",
      "content_length": 1056,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 116,
      "content": "Table 5-7. Pros and cons of using multiple burn rates\n\nPros Ability to adapt the monitoring configuration to many situations according to criticality: alert quickly if the error rate is high; alert eventually if the error rate is low but sustained. Good precision, as with all fixed-budget portion alert approaches. Good recall, because of the three-day window. Ability to choose the most appropriate alert type based upon how quickly someone has to react to defend the SLO.\n\nCons More numbers, window sizes, and thresholds to manage and reason about. An even longer reset time, as a result of the three-day window. To avoid multiple alerts from firing if all conditions are true, you need to implement alert suppression. For example: 10% budget spend in five minutes also means that 5% of the budget was spent in six hours, and 2% of the budget was spent in one hour. This scenario will trigger three notifications unless the monitoring system is smart enough to prevent it from doing so.\n\n6: Multiwindow, Multi-Burn-Rate Alerts We can enhance the multi-burn-rate alerts in iteration 5 to notify us only when we’re still actively burning through the budget—thereby reducing the number of false posi‐ tives. To do this, we need to add another parameter: a shorter window to check if the error budget is still being consumed as we trigger the alert.\n\nA good guideline is to make the short window 1/12 the duration of the long window, as shown in Figure 5-6. The graph shows both alerting threshold. After experiencing 15% errors for 10 minutes, the short window average goes over the alerting threshold immediately, and the long window average goes over the threshold after 5 minutes, at which point the alert starts firing. The short window average drops below the thres‐ hold 5 minutes after the errors stop, at which point the alert stops firing. The long window average drops below the threshold 60 minutes after the errors stop.\n\nFigure 5-6. Short and long windows for alerting\n\n84\n\n|\n\nChapter 5: Alerting on SLOs",
      "content_length": 2017,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 117,
      "content": "For example, you can send a page-level alert when you exceed the 14.4x burn rate over both the previous one hour and the previous five minutes. This alert fires only once you’ve consumed 2% of the budget, but exhibits a better reset time by ceasing to fire five minutes later, rather than one hour later:\n\nexpr: ( job:slo_errors_per_request:ratio_rate1h{job=\"myjob\"} > (14.4*0.001) and job:slo_errors_per_request:ratio_rate5m{job=\"myjob\"} > (14.4*0.001) ) or ( job:slo_errors_per_request:ratio_rate6h{job=\"myjob\"} > (6*0.001) and job:slo_errors_per_request:ratio_rate30m{job=\"myjob\"} > (6*0.001) ) severity: page\n\nexpr: ( job:slo_errors_per_request:ratio_rate24h{job=\"myjob\"} > (3*0.001) and job:slo_errors_per_request:ratio_rate2h{job=\"myjob\"} > (3*0.001) ) or ( job:slo_errors_per_request:ratio_rate3d{job=\"myjob\"} > 0.001 and job:slo_errors_per_request:ratio_rate6h{job=\"myjob\"} > 0.001 ) severity: ticket\n\nWe recommend the parameters listed in Table 5-8 as the starting point for your SLO- based alerting configuration.\n\nTable 5-8. Recommended parameters for a 99.9% SLO alerting configuration\n\nSeverity Page Page Ticket\n\nLong window Short window Burn rate 5 minutes 1 hour 30 minutes 6 hours 6 hours 3 days\n\n14.4 6 1\n\nError budget consumed 2% 5% 10%\n\nWe have found that alerting based on multiple burn rates is a powerful way to imple‐ ment SLO-based alerting.\n\nTable 5-9 shows the benefits and limitations of using multiple burn rates and window sizes.\n\nWays to Alert on Significant Events\n\n|\n\n85",
      "content_length": 1502,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 118,
      "content": "Table 5-9. Pros and cons of using multiple burn rates and window sizes\n\nPros A flexible alerting framework that allows you to control the type of alert according to the severity of the incident and the requirements of the organization. Good precision, as with all fixed-budget portion alert approaches. Good recall, because of the three-day window.\n\nCons Lots of parameters to specify, which can make alerting rules hard to manage. For more on managing alerting rules, see “Alerting at Scale” on page 89.\n\nLow-Traffic Services and Error Budget Alerting The multiwindow, multi-burn-rate approach just detailed works well when a suffi‐ ciently high rate of incoming requests provides a meaningful signal when an issue arises. However, these approaches can cause problems for systems that receive a low rate of requests. If a system has either a low number of users or natural low-traffic periods (such as nights and weekends), you may need to alter your approach.\n\nIt’s harder to automatically distinguish unimportant events in low-traffic services. For example, if a system receives 10 requests per hour, then a single failed request results in an hourly error rate of 10%. For a 99.9% SLO, this request constitutes a 1,000x burn rate and would page immediately, as it consumed 13.9% of the 30-day error budget. This scenario allows for only seven failed requests in 30 days. Single requests can fail for a large number of ephemeral and uninteresting reasons that aren’t necessarily cost-effective to solve in the same way as large systematic outages.\n\nThe best solution depends on the nature of the service: what is the impact3 of a single failed request? A high-availability target may be appropriate if failed requests are one- off, high-value requests that aren’t retried. It may make sense from a business per‐ spective to investigate every single failed request. However, in this case, the alerting system notifies you of an error too late.\n\nWe recommend a few key options to handle a low-traffic service:\n\nGenerate artificial traffic to compensate for the lack of signal from real users.\n\nCombine smaller services into a larger service for monitoring purposes.\n\nModify the product so that either:\n\n— It takes more requests to qualify a single incident as a failure.\n\n— The impact of a single failure is lower.\n\n3 The section “What to Measure: Using SLIs” on page 20 recommends a style of SLI that scales according to the\n\nimpact on the user.\n\n86\n\n|\n\nChapter 5: Alerting on SLOs",
      "content_length": 2483,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 119,
      "content": "Generating Artificial Traffic A system can synthesize user activity to check for potential errors and high-latency requests. In the absence of real users, your monitoring system can detect synthetic errors and requests, so your on-call engineers can respond to issues before they impact too many actual users.\n\nArtificial traffic provides more signals to work with, and allows you to reuse your existing monitoring logic and SLO values. You may even already have most of the necessary traffic-generating components, such as black-box probers and integration tests.\n\nGenerating artificial load does have some downsides. Most services that warrant SRE support are complex, and have a large system control surface. Ideally, the system should be designed and built for monitoring using artificial traffic. Even for a non‐ trivial service, you can synthesize only a small portion of the total number of user request types. For a stateful service, the greater number of states exacerbates this problem.\n\nAdditionally, if an issue affects real users but doesn’t affect artificial traffic, the suc‐ cessful artificial requests hide the real user signal, so you aren’t notified that users see errors.\n\nCombining Services If multiple low-traffic services contribute to one overall function, combining their requests into a single higher-level group can detect significant events more precisely and with fewer false positives. For this approach to work, the services must be related in some way—you can combine microservices that form part of the same product, or multiple request types handled by the same binary.\n\nA downside to combining services is that a complete failure of an individual service may not count as a significant event. You can increase the likelihood that a failure will affect the group as a whole by choosing services with a shared failure domain, such as a common backend database. You can still use longer-period alerts that even‐ tually catch these 100% failures for individual services.\n\nMaking Service and Infrastructure Changes Alerting on significant events aims to provide sufficient notice to mitigate problems before they exhaust the entire error budget. If you can’t adjust the monitoring to be less sensitive to ephemeral events, and generating synthetic traffic is impractical, you might instead consider changing the service to reduce the user impact of a single failed request. For example, you might:\n\nLow-Traffic Services and Error Budget Alerting\n\n|\n\n87",
      "content_length": 2482,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 120,
      "content": "Modify the client to retry, with exponential backoff and jitter.4\n\nSet up fallback paths that capture the request for eventual execution, which can take place on the server or on the client.\n\nThese changes are useful for high-traffic systems, but even more so for low-traffic systems: they allow for more failed events in the error budget, more signal from mon‐ itoring, and more time to respond to an incident before it becomes significant.\n\nLowering the SLO or Increasing the Window You might also want to reconsider if the impact of a single failure on the error budget accurately reflects its impact on users. If a small number of errors causes you to lose error budget, do you really need to page an engineer to fix the issue immediately? If not, users would be equally happy with a lower SLO. With a lower SLO, an engineer is notified only of a larger sustained outage.\n\nOnce you have negotiated lowering the SLO with the service’s stakeholders (for example, lowering the SLO from 99.9% to 99%), implementing the change is very simple: if you already have systems in place for reporting, monitoring, and alerting based upon an SLO threshold, simply add the new SLO value to the relevant systems.\n\nLowering the SLO does have a downside: it involves a product decision. Changing the SLO affects other aspects of the system, such as expectations around system behavior and when to enact the error budget policy. These other requirements may be more important to the product than avoiding some number of low-signal alerts.\n\nIn a similar manner, increasing the time window used for the alerting logic ensures alerts that trigger pages are more significant and worthy of attention.\n\nIn practice, we use some combination of the following methods to alert for low-traffic services:\n\nGenerating fake traffic, when doing so is possible and can achieve good coverage\n\nModifying clients so that ephemeral failures are less likely to cause user harm\n\nAggregating smaller services that share some failure mode\n\nSetting SLO thresholds commensurate with the actual impact of a failed request\n\n4 See “Overloads and Failure” in Site Reliability Engineering.\n\n88\n\n|\n\nChapter 5: Alerting on SLOs",
      "content_length": 2181,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 121,
      "content": "Extreme Availability Goals Services with an extremely low or an extremely high availability goal may require special consideration. For example, consider a service that has a 90% availability tar‐ get. Table 5-8 says to page when 2% of the error budget in a single hour is consumed. Because a 100% outage consumes only 1.4% of the budget in that hour, this alert could never fire. If your error budgets are set over long time periods, you may need to tune your alerting parameters.\n\nFor services with an extremely high availability goal, the time to exhaustion for a 100% outage is extremely small. A 100% outage for a service with a target monthly availability of 99.999% would exhaust its budget in 26 seconds—which is smaller than the metric collection interval of many monitoring services, let alone the end-to-end time to generate an alert and pass it through notification systems like email and SMS. Even if the alert goes straight to an automated resolution system, the issue may entirely consume the error budget before you can mitigate it.\n\nReceiving notifications that you have only 26 seconds of budget left isn’t necessarily a bad strategy; it’s just not useful for defending the SLO. The only way to defend this level of reliability is to design the system so that the chance of a 100% outage is extremely low. That way, you can fix issues before consuming the budget. For exam‐ ple, if you initially roll out that change to only 1% of your users, and burn your error budget at the same rate of 1%, you now have 43 minutes before you exhaust your error budget. See Chapter 16 for tactics on designing such a system.\n\nAlerting at Scale When you scale your service, make sure that your alerting strategy is likewise scala‐ ble. You might be tempted to specify custom alerting parameters for individual serv‐ ices. If your service comprises 100 microservices (or equivalently, a single service with 100 different request types), this scenario very quickly accumulates toil and cog‐ nitive load that does not scale.\n\nIn this case, we strongly advise against specifying the alert window and burn rate parameters independently for each service, because doing so quickly becomes over‐ whelming.5 Once you decide on your alerting parameters, apply them to all your services.\n\nOne technique for managing a large number of SLOs is to group request types into buckets of approximately similar availability requirements. For example, for a service\n\n5 With the exception of temporary changes to alerting parameters, which are necessary when you’re fixing an\n\nongoing outage and you don’t need to receive notifications during that period.\n\nExtreme Availability Goals\n\n|\n\n89",
      "content_length": 2672,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 122,
      "content": "with availability and latency SLOs, you can group its request types into the following buckets:\n\nCRITICAL\n\nFor request types that are the most important, such as a request when a user logs in to the service.\n\nHIGH_FAST\n\nFor requests with high availability and low latency requirements. These requests involve core interactive functionality, such as when a user clicks a button to see how much money their advertising inventory has made this month.\n\nHIGH_SLOW\n\nFor important but less latency-sensitive functionality, such as when a user clicks a button to generate a report of all advertising campaigns over the past few years, and does not expect the data to return instantly.\n\nLOW\n\nFor requests that must have some availability, but for which outages are mostly invisible to users—for example, polling handlers for account notifications that can fail for long periods of time with no user impact.\n\nNO_SLO\n\nFor functionality that is completely invisible to the user—for example, dark launches or alpha functionality that is explicitly outside of any SLO.\n\nBy grouping requests rather than placing unique availability and latency objectives on all request types, you can group requests into five buckets, like the example in Table 5-10.\n\nTable 5-10. Request class buckets according to similar availability requirements and thresholds\n\nLatency @ 90%a 100 ms 100 ms 1,000 ms None None\n\nLatency @ 99% 200 ms 200 ms 5,000 ms None NO_SLO None a Ninety percent of requests are faster than this threshold.\n\nRequest class Availability CRITICAL\n\n99.99% 99.9% 99.9% 99% None\n\nHIGH_FAST\n\nHIGH_SLOW\n\nLOW\n\nThese buckets provide sufficient fidelity for protecting user happiness, but entail less toil than a system that is more complicated and expensive to manage that probably maps more precisely to the user experience.\n\n90\n\n|\n\nChapter 5: Alerting on SLOs",
      "content_length": 1842,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 123,
      "content": "Conclusion If you set SLOs that are meaningful, understood, and represented in metrics, you can configure alerting to notify an on-caller only when there are actionable, specific threats to the error budget.\n\nThe techniques for alerting on significant events range from alerting when your error rate goes above your SLO threshold to using multiple levels of burn rate and window sizes. In most cases, we believe that the multiwindow, multi-burn-rate alerting tech‐ nique is the most appropriate approach to defending your application’s SLOs.\n\nWe hope we have given you the context and tools required to make the right configu‐ ration decisions for your own application and organization.\n\nConclusion\n\n|\n\n91",
      "content_length": 705,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 125,
      "content": "CHAPTER 6 Eliminating Toil\n\nBy David Challoner, Joanna Wijntjes, David Huska, Matthew Sartwell, Chris Coykendall, Chris Schrier, John Looney, and Vivek Rau with Betsy Beyer, Max Luebbe, Alex Perry, and Murali Suriar\n\nGoogle SREs spend much of their time optimizing—squeezing every bit of perfor‐ mance from a system through project work and developer collaboration. But the scope of optimization isn’t limited to compute resources: it’s also important that SREs optimize how they spend their time. Primarily, we want to avoid performing tasks classified as toil. For a comprehensive discussion of toil, see Chapter 5 in Site Reliability Engineering. For the purposes of this chapter, we’ll define toil as the repeti‐ tive, predictable, constant stream of tasks related to maintaining a service.\n\nToil is seemingly unavoidable for any team that manages a production service. Sys‐ tem maintenance inevitably demands a certain amount of rollouts, upgrades, restarts, alert triaging, and so forth. These activities can quickly consume a team if left unchecked and unaccounted for. Google limits the time SRE teams spend on opera‐ tional work (including both toil- and non-toil-intensive work) at 50% (for more con‐ text on why, see Chapter 5 in our first book). While this target may not be appropriate for your organization, there’s still an advantage to placing an upper bound on toil, as identifying and quantifying toil is the first step toward optimizing your team’s time.\n\n93",
      "content_length": 1477,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 126,
      "content": "What Is Toil? Toil tends to fall on a spectrum measured by the following characteristics, which are described in our first book. Here, we provide a concrete example for each toil characteristic:\n\nManual\n\nWhen the tmp directory on a web server reaches 95% utilization, engineer Anne logs in to the server and scours the filesystem for extraneous log files to delete.\n\nRepetitive\n\nA full tmp directory is unlikely to be a one-time event, so the task of fixing it is repetitive.\n\nAutomatable1\n\nIf your team has remediation documents with content like “log in to X, execute this command, check the output, restart Y if you see…,” these instructions are essentially pseudocode to someone with software development skills! In the tmp directory example, the solution has been partially automated. It would be even better to fully automate the problem detection and remediation by not requiring a human to run the script. Better still, submit a patch so that the software no longer breaks in this way.\n\nNontactical/reactive\n\nWhen you receive too many alerts along the lines of “disk full” and “server down,” they distract engineers from higher-value engineering and potentially mask other, higher-severity alerts. As a result, the health of the service suffers.\n\nLacks enduring value\n\nCompleting a task often brings a satisfying sense of accomplishment, but this repetitive satisfaction isn’t a positive in the long run. For example, closing that alert-generated ticket ensured that the user queries continued to flow and HTTP requests continued to serve with status codes < 400, which is good. However, resolving the ticket today won’t prevent the issue in the future, so the payback has a short duration.\n\nGrows at least as fast as its source\n\nMany classes of operational work grow as fast as (or faster than) the size of the underlying infrastructure. For example, you can expect time spent performing\n\n1 Whether something is automatable is the most subjective characteristic listed here; your perspective will\n\nevolve as you gain experience by automating away toil. A problem space that once seemed intractable (or too risky) will become feasible once you get comfortable with “letting the robots do the work.”\n\n94\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 2242,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 127,
      "content": "hardware repairs to increase in lock-step fashion with the size of a server fleet. Physical repair work may unavoidably scale with the number of machines, but ancillary tasks (for example, making software/configuration changes) doesn’t necessarily have to.\n\nSources of toil may not always meet all of these criteria, but remember that toil comes in many forms. In addition to the preceding traits, consider the effect a particular piece of work has on team morale. Do people enjoy doing a task and find it reward‐ ing, or is it the type of work that’s often neglected because it’s viewed as boring or unrewarding?2 Toil can slowly deflate team morale. Time spent working on toil is generally time not spent thinking critically or expressing creativity; reducing toil is an acknowledgment that an engineer’s effort is better utilized in areas where human judgment and expression are possible.\n\nExample: Manual Response to Toil\n\nby John Looney, Production Engineering Manager at Facebook, and always an SRE at heart\n\nIt’s not always clear that a certain chunk of work is toil. Sometimes, a “creative” solu‐ tion—writing a workaround—is not the right call. Ideally, your organization should reward root-cause fixes over fixes that simply mask a problem.\n\nMy first assignment after joining Google (April 2005) was to log in to broken machines, investigate why they were broken, then fix them or send them to a hard‐ ware technician. This task seemed simple until I realized there were over 20,000 bro‐ ken machines at any given time!\n\nThe first broken machine I investigated had a root filesystem that was completely full with gigabytes of nonsense logs from a Google-patched network driver. I found another thousand broken machines with the same problem. I shared my plan to address the issue with my teammate: I’d write a script to ssh into all broken machines and check if the root filesystem was full. If the filesystem was full, the script would truncate any logs larger than a megabyte in /var/log and restart syslog.\n\nMy teammate’s less-than-enthusiastic reaction to my plan gave me pause. He pointed out that it’s better to fix root causes when possible. In the medium to long term, writ‐ ing a script that masked the severity of the problem would waste time (by not fixing the actual problem) and potentially cause more problems later.\n\n2 Some engineers do not mind working on toil for a prolonged period—not everyone’s tolerance threshold for toil is the same. Over the longer term, toil causes career stagnation while promoting burnout-induced turn‐ over. A certain level of toil is unavoidable, but we recommend reducing it where feasible—for the health of the team, the service, and individuals alike.\n\nWhat Is Toil?\n\n|\n\n95",
      "content_length": 2732,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 128,
      "content": "Analysis demonstrated that each server probably cost $1 per hour. According to my train of thought, shouldn’t cost be the most important metric? I hadn’t considered that if I fixed the symptom, there would be no incentive to fix the root cause: the ker‐ nel team’s release test suite didn’t check the volume of logs these machines produced.\n\nThe senior engineer directed me at the kernel source so I could find the offensive line of code and log a bug against the kernel team to improve their test suite. My objective cost/benefit analysis showing that the problem was costing Google $1,000 per hour convinced the devs to fix the problem with my patch.\n\nMy patch was turned into a new kernel release that evening, and the next day I rolled it out to the affected machines. The kernel team updated their test suite later the fol‐ lowing week. Instead of the short-term endorphin hit of fixing those machines every morning, I now had the more cerebral pleasure of knowing that I’d fixed the problem properly.\n\nMeasuring Toil How do you know how much of your operational work is toil? And once you’ve deci‐ ded to take action to reduce toil, how do you know if your efforts were successful or justified? Many SRE teams answer these questions with a combination of experience and intuition. While such tactics might produce results, we can improve upon them.\n\nExperience and intuition are not repeatable, objective, or transferable. Members of the same team or organization often arrive at different conclusions regarding the magni‐ tude of engineering effort lost to toil, and therefore prioritize remediation efforts dif‐ ferently. Furthermore, toil reduction efforts can span quarters or even years (as demonstrated by some of the case studies in this chapter), during which time team priorities and personnel can change. To maintain focus and justify cost over the long term, you need an objective measure of progress. Usually, teams must choose a toil- reduction project from several candidates. An objective measure of toil allows your team to evaluate the severity of the problems and prioritize them to achieve maxi‐ mum return on engineering investment.\n\nBefore beginning toil reduction projects, it’s important to analyze cost versus benefit and to confirm that the time saved through eliminating toil will (at minimum) be proportional to the time invested in first developing and then maintaining an auto‐ mated solution (Figure 6-1). Projects that look “unprofitable” from a simplistic com‐ parison of hours saved versus hours invested might still be well worth undertaking because of the many indirect or intangible benefits of automation. Potential benefits could include:\n\nGrowth in engineering project work over time, some of which will further reduce toil\n\n96\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 2804,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 129,
      "content": "Increased team morale and decreased team attrition and burnout\n\nLess context switching for interrupts, which raises team productivity\n\nIncreased process clarity and standardization\n\nEnhanced technical skills and career growth for team members\n\nReduced training time\n\nFewer outages attributable to human errors\n\nImproved security\n\nShorter response times for user requests\n\nFigure 6-1. Estimate the amount of time you’ll spend on toil reduction efforts, and make sure that the benefits outweigh the cost (source: xkcd.com/1319/)\n\nMeasuring Toil\n\n|\n\n97",
      "content_length": 549,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 130,
      "content": "So how do we recommend you measure toil?\n\n1. Identify it. Chapter 5 of the first SRE book offers guidelines for identifying the toil in your operations. The people best positioned to identify toil depend upon your organization. Ideally, they will be stakeholders, including those who will perform the actual work.\n\n2. Select an appropriate unit of measure that expresses the amount of human effort applied to this toil. Minutes and hours are a natural choice because they are objective and universally understood. Be sure to account for the cost of context switching. For efforts that are distributed or fragmented, a different well- understood bucket of human effort may be more appropriate. Some examples of units of measure include an applied patch, a completed ticket, a manual produc‐ tion change, a predictable email exchange, or a hardware operation. As long as the unit is objective, consistent, and well understood, it can serve as a measure‐ ment of toil.\n\n3. Track these measurements continuously before, during, and after toil reduction efforts. Streamline the measurement process using tools or scripts so that collect‐ ing these measurements doesn’t create additional toil!\n\nToil Taxonomy Toil, like a crumbling bridge or a leaky dam, hides in the banal day to day. The cate‐ gories in this section aren’t exhaustive, but represent some common categories of toil. Many of these categories seem like “normal” engineering work, and they are. It’s helpful to think of toil as a spectrum rather than a binary classification.\n\nBusiness Processes This is probably the most common source of toil. Maybe your team manages some computing resource—compute, storage, network, load balancers, databases, and so on—along with the hardware that supplies that resource. You deal with onboarding users, configuring and securing their machines, performing software updates, and adding and removing servers to moderate capacity. You also work to minimize cost or waste of that resource. Your team is the human interface to the machine, typically interacting with internal customers who file tickets for their needs. Your organization may even have multiple ticketing systems and work intake systems.\n\nTicket toil is a bit insidious because ticket-driven business processes usually accom‐ plish their goal. Users get what they want, and because the toil is typically dispersed evenly across the team, the toil doesn’t loudly and obviously call for remediation. Wherever a ticket-driven process exists, there’s a chance that toil is quietly accumu‐ lating nearby. Even if you’re not explicitly planning to automate a process, you can\n\n98\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 2663,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 131,
      "content": "still perform process improvement work such as simplification and streamlining— the processes will be easier to automate later, and easier to manage in the meantime.\n\nProduction Interrupts Interrupts are a general class of time-sensitive janitorial tasks that keep systems run‐ ning. For example, you may need to fix an acute shortage of some resource (disk, memory, I/O) by manually freeing up disk space or restarting applications that are leaking memory. You may be filing requests to replace hard drives, “kicking” unre‐ sponsive systems, or manually tweaking capacity to meet current or expected loads. Generally, interrupts take attention away from more important work.\n\nRelease Shepherding In many organizations, deployment tools automatically shepherd releases from development to production. Even with automation, thorough code coverage, code reviews, and numerous forms of automated testing, this process doesn’t always go smoothly. Depending on the tooling and release cadence, release requests, rollbacks, emergency patches, and repetitive or manual configuration changes, releases may still generate toil.\n\nMigrations You may find yourself frequently migrating from one technology to another. You perform this work manually or with limited scripting because, hopefully, you’re only going to move from X to Y once. Migrations come in many forms, but some exam‐ ples include changes of data stores, cloud vendors, source code control systems, application libraries, and tooling.\n\nIf you approach a large-scale migration manually, the migration quite likely involves toil. You may be inclined to execute the migration manually because it’s a one-time effort. While you might even be tempted to view it as “project work” rather than “toil,” migration work can also meet many of the criteria of toil. Technically, modify‐ ing backup tooling for one database to work with another is software development, but this work is basically just refactoring code to replace one interface with another. This work is repetitive, and to a large extent, the business value of the backup tooling is the same as before.\n\nToil Taxonomy\n\n|\n\n99",
      "content_length": 2133,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 132,
      "content": "Cost Engineering and Capacity Planning Whether you own hardware or use an infrastructure provider (cloud), cost engineer‐ ing and capacity planning usually entail some associated toil. For example:\n\nEnsuring a cost-effective baseline or burstable capability for future needs across resources like compute, memory, or IOPS (input/output operations per second). This may translate into purchase orders, AWS Reserved Instances, or Cloud/ Infrastructure as a Service contract negotiation.\n\nPreparing for (and recovering from) critical high-traffic events like a product launch or holiday.\n\nReviewing downstream and upstream service levels/limits.\n\nOptimizing workload against different footprint configurations. (Do you want to buy one big box, or four smaller boxes?)\n\nOptimizing applications against the billing specifics of proprietary cloud service offerings (DynamoDB for AWS or Cloud Datastore for GCP).\n\nRefactoring tooling to make better use of cheaper “spot” or “preemptable” resources.\n\nDealing with oversubscribed resources, either upstream with your infrastructure provider or with your downstream customers.\n\nTroubleshooting for Opaque Architectures Distributed microservice architectures are now common, and as systems become more distributed, new failure modes arise. An organization may not have the resour‐ ces to build sophisticated distributed tracing, high-fidelity monitoring, or detailed dashboards. Even if the business does have these tools, they might not work with all systems. Troubleshooting may even require logging in to individual systems and writing ad hoc log analytics queries with scripting tools.\n\nTroubleshooting itself isn’t inherently bad, but you should aim to focus your energy on novel failure modes—not the same type of failure every week caused by brittle sys‐ tem architecture. With each new critical upstream dependency of availability P, avail‐ ability decreases by 1 – P due to the combined chance of failure. A four 9s service that adds nine critical four 9s dependencies is now a three 9s service.3\n\n3 In other words, if a service and its nine dependencies each have 99.99% availability, the aggregate availability of the service will be 0.999910 = 99.9%. For further reading on how dependencies factor into service availabil‐ ity, see “The Calculus of Service Availability”.\n\n100\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 2358,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 133,
      "content": "Toil Management Strategies We’ve found that performing toil management is critical if you’re operating a pro‐ duction system of any scale. Once you identify and quantify toil, you need a plan for eliminating it. These efforts may take weeks or quarters to accomplish, so it’s impor‐ tant to have a solid overarching strategy.\n\nEliminating toil at its source is the optimal solution, but if doing so isn’t possible, then you must handle the toil by other means. Before we dive into the specifics of two in-depth case studies, this section provides some general strategies to consider when you’re planning a toil reduction effort. As you’ll observe across the two stories, the nuances of toil vary from team to team (and from company to company), but regard‐ less of specificity, some common tactics ring true for organizations of any size or fla‐ vor. Each of the following patterns is illustrated in a concrete way in at least one of the subsequent case studies.\n\nIdentify and Measure Toil We recommend that you adopt a data-driven approach to identify and compare sources of toil, make objective remedial decisions, and quantify the time saved (return on investment) by toil reduction projects. If your team is experiencing toil overload, treat toil reduction as its own project. Google SRE teams often track toil in bugs and rank toil according to the cost to fix it and the time saved by doing so. See the section “Measuring Toil” on page 96 for techniques and guidance.\n\nEngineer Toil Out of the System The optimal strategy for handling toil is to eliminate it at the source. Before investing effort in managing the toil generated by your existing systems and processes, examine whether you can reduce or eliminate that toil by changing the system.\n\nA team that runs a system in production has invaluable experience with how that sys‐ tem works. They know the quirks and tedious bits that cause the most amount of toil. An SRE team should apply this knowledge by working with product development teams to develop operationally friendly software that is not only less toilsome, but also more scalable, secure, and resilient.\n\nReject the Toil A toil-laden team should make data-driven decisions about how best to spend their time and engineering effort. In our experience, while it may seem counterproductive, rejecting a toil-intensive task should be the first option you consider. For a given set of toil, analyze the cost of responding to the toil versus not doing so. Another tactic is to intentionally delay the toil so that tasks accumulate for batch or parallelized\n\nToil Management Strategies\n\n|\n\n101",
      "content_length": 2610,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 134,
      "content": "processing. Working with toil in larger aggregates reduces interrupts and helps you identify patterns of toil, which you can then target for elimination.\n\nUse SLOs to Reduce Toil As discussed in Chapter 2, services should have a documented service level objective (SLO). A well-defined SLO enables engineers to make informed decisions. For exam‐ ple, you might ignore certain operational tasks if doing so does not consume or exceed the service’s error budget. An SLO that focuses on overall service health, rather than individual devices, is more flexible and sustainable as the service grows. See Chapter 2 for guidance on writing effective SLOs.\n\nStart with Human-Backed Interfaces If you have a particularly complex business problem with many edge cases or types of requests, consider a partially automated approach as an interim step toward full auto‐ mation. In this approach, your service receives structured data—usually via a defined API—but engineers may still handle some of the resulting operations. Even if some manual effort remains, this “engineer behind the curtain” approach allows you to incrementally move toward full automation. Use customer input to progress toward a more uniform way of collecting this data; by decreasing free-form requests, you can move closer to handling all requests programmatically. This approach can save back and forth with customers (who now have clear indicators of the information you need) and save you from overengineering a big-bang solution before you’ve fully mapped and understood the domain.\n\nProvide Self-Service Methods Once you’ve defined your service offering via a typed interface (see “Start with Human-Backed Interfaces” on page 102), move to providing self-service methods for users. You can provide a web form, binary or script, API, or even just documentation that tells users how to issue pull requests to your service’s configuration files. For example, rather than asking engineers to file a ticket to provision a new virtual machine for their development work, give them a simple web form or script that trig‐ gers the provisioning. Allow the script to gracefully degrade to a ticket for specialized requests or if a failure occurs.4 Human-backed interfaces are a good start in the war against toil, but service owners should always aim to make their offerings self-service where possible.\n\n4 Of course, you won’t be able to handle some one-off cases via self-service (“you want a VM with how much RAM?”), but aim to cover the majority of use cases. Moving 80–90% of requests to self-service is still a huge reduction in workload!\n\n102\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 2638,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 135,
      "content": "Get Support from Management and Colleagues In the short term, toil reduction projects reduce the staff available to address feature requests, performance improvements, and other operational tasks. But if the toil reduction is successful, in the long term the team will be healthier and happier, and have more time for engineering improvements.\n\nIt is important for everyone in the organization to agree that toil reduction is a worthwhile goal. Manager support is crucial in defending staff from new demands. Use objective metrics about toil to make the case for pushback.\n\nPromote Toil Reduction as a Feature To create strong business cases for toil reduction, look for opportunities to couple your strategy with other desirable features or business goals. If a complementary goal —for example, security, scalability, or reliability—is compelling to your customers, they’ll be more willing to give up their current toil-generating systems for shiny new ones that aren’t as toil intentive. Then, reducing toil is just a nice side effect of help‐ ing users!\n\nStart Small and Then Improve Don’t try to design the perfect system that eliminates all toil. Automate a few high- priority items first, and then improve your solution using the time you gained by eliminating that toil, applying the lessons learned along the way. Pick clear metrics such as MTTR (Mean Time to Repair) to measure your success.\n\nIncrease Uniformity At scale, a diverse production environment becomes exponentially harder to manage. Special devices require time-consuming and error-prone ongoing management and incident response. You can use the “pets versus cattle” approach5 to add redundancy and enforce consistency in your environment. Choosing what to consider cattle depends on the needs and scale of an organization. It may be reasonable to evaluate network links, switches, machines, racks of machines, or even entire clusters as inter‐ changeable units.\n\nShifting devices to a cattle philosophy may have a high initial cost, but can reduce the cost of maintenance, disaster recovery, and resource utilization in the medium to long term. Equipping multiple devices with the same interface implies that they have\n\n5 In short, moving away from individual specialized devices toward a fleet of devices with a common interface.\n\nSee “Case Study 1: Reducing Toil in the Datacenter with Automation” on page 107 for a detailed explanation of this analogy.\n\nToil Management Strategies\n\n|\n\n103",
      "content_length": 2464,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 136,
      "content": "consistent configuration, are interchangeable, and require less maintenance. A con‐ sistent interface (to divert traffic, restore traffic, perform a shutdown, etc.) for a vari‐ ety of devices allows for more flexible and scalable automation.\n\nGoogle aligns business incentives to encourage engineering teams to unify across our ever-evolving toolkit of internal technologies and tools. Teams are free to choose their own approaches, but they have to own the toil generated by unsupported tools or legacy systems.\n\nAssess Risk Within Automation Automation can save countless hours in human labor, but in the wrong circumstan‐ ces, it can also trigger outages. In general, defensive software is always a good idea; when automation wields admin-level powers, defensive software is crucial. Every action should be assessed for its safety before execution. This includes changes that might reduce serving capacity or redundancy. When you’re implementing automa‐ tion, we recommend the following practices:\n\nHandle user input defensively, even if that input is flowing from upstream sys‐ tems—that is, be sure to validate the input carefully in context.\n\nBuild in safeguards that are equivalent to the types of indirect alerts that a human operator might receive. Safeguards might be as simple as command timeouts, or might be more sophisticated checks of current system metrics or the number of current outages. For this reason, monitoring, alerting, and instrumentation sys‐ tems should be consumable by both machine and human operators.\n\nBe aware that even read operations, naively implemented, can spike device load and trigger outages. As automation scales, these safety checks can eventually dominate workload.\n\nMinimize the impact of outages caused by incomplete safety checks of automa‐ tion. Automation should default to human operators if it runs into an unsafe condition.\n\nAutomate Toil Response Once you identify a piece of toil as automatable, it’s worthwhile to consider how to best mirror the human workflow in software. You rarely want to literally transcribe a human workflow into a machine workflow. Also note that automation shouldn’t eliminate human understanding of what’s going wrong.\n\nOnce your process is thoroughly documented, try to break down the manual work into components that can be implemented separately and used to create a composa‐ ble software library that other automation projects can reuse later. As the upcoming\n\n104\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 2482,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 137,
      "content": "datacenter repair case study illustrates, automation often provides the opportunity to reevaluate and simplify human workflows.\n\nUse Open Source and Third-Party Tools Sometimes you don’t have to do all of the work to reduce toil yourself. Many efforts like one-off migrations may not justify building their own bespoke tooling, but you’re probably not the first organization to tread this path. Look for opportunities to use or extend third-party or open source libraries to reduce development costs, or at least to help you transition to partial automation.\n\nUse Feedback to Improve It’s important to actively seek feedback from other people who interact with your tools, workflows, and automation. Your users will make different assumptions about your tools depending on their understanding of the underlying systems. The less familiar your users are with these systems, the more important it is to actively seek feedback from users. Leverage surveys, user experience (UX) studies, and other mechanisms to understand how your tools are used, and integrate this feedback to produce more effective automation in the future.\n\nHuman input is only one dimension of feedback you should consider. Also measure the effectiveness of automated tasks according to metrics like latency, error rate, rework rate, and human time saved (across all groups involved in the process). Ide‐ ally, find high-level measures you can compare before and after any automation or toil reduction efforts.\n\nLegacy Systems Most engineers with SRE-like responsibilities have encountered at least one legacy system in their work. These older systems often introduce problems with respect to user experience, security, reliability, or scalability. They tend to operate like a magical black box in that they “mostly work,” but few people understand how they work. They’re scary and expensive to modify, and keeping them running often requires a good deal of toilsome operational ritual.\n\nThe journey away from a legacy system usually follows this path:\n\n1. Avoidance: There are many reasons to not tackle this problem head on: you may not have the resources to replace this system. You judge the cost and risk to your business as not worth the cost of a replacement. There may not be any substan‐ tially better solutions commercially available. Avoidance is effectively choosing to accept technical debt and to move away from SRE principles and toward sys‐ tem administration.\n\nToil Management Strategies\n\n|\n\n105",
      "content_length": 2480,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 138,
      "content": "2. Encapsulation/augmentation: You can bring SREs on board to build a shell of abstracted APIs, automation, configuration management, monitoring, and test‐ ing around these legacy systems that will offload work from SAs. The legacy sys‐ tem remains brittle to change, but now you can at least reliably identify misbehavior and roll back when appropriate. This tactic is still avoidance, but is a bit like refinancing high-interest technical debt into low-interest technical debt. It’s usually a stopgap measure to prepare for an incremental replacement.\n\n3. Replacement/refactoring: Replacing a legacy system can require a vast amount of determination, patience, communication, and documentation. It’s best under‐ taken incrementally. One approach is to define a common interface that sits in front of and abstracts a legacy system. This strategy helps you slowly and safely migrate users to alternatives using release engineering techniques like canarying or blue-green deployments. Often, the “specification” of a legacy system is really defined only by its historical usage, so it’s helpful to build production-sized data sets of historical expected inputs and outputs to build confidence that new sys‐ tems aren’t diverging from expected behavior (or are diverging in an expected way).\n\n4. Retirement/custodial ownership: Eventually the majority of customers or func‐ tionality is migrated to one or more alternatives. To align business incentives, stragglers who haven’t migrated can assume custodial ownership of remnants of the legacy system.\n\nCase Studies The following case studies illustrate the strategies for toil reduction just discussed. Each story describes an important area of Google’s infrastructure that reached a point at which it could no longer scale sublinearly with human effort; over time, an increas‐ ing number of engineer hours resulted in smaller returns on that investment. Much of that effort you’ll now recognize as toil. For each case study, we detail how the engi‐ neers identified, assessed, and mitigated that toil. We also discuss the results and the lessons we learned along the way.\n\nIn the first case study, Google’s datacenter networking had a scaling problem: we had a massive number of Google-designed components and links to monitor, mitigate, and repair. We needed a strategy to minimize the toilsome nature of this work for datacenter technicians.\n\nThe second case study focuses on a team running their own “outlier” specialized hardware to support toil-intensive business processes that had become deeply entrenched within Google. This case study illustrates benefits of reevaluating and replacing operationally expensive business processes. It demonstrates that with a little persistence and perseverance, it’s possible to move to alternatives even when con‐ strained by the institutional inertia of a large organization.\n\n106\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 2906,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 139,
      "content": "Taken together, these case studies provide a concrete example of each toil reduction strategy covered earlier. Each case study begins with a list of relevant toil reduction strategies.\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\nToil reduction strategies highlighted in Case Study 1:\n\nEngineer toil out of the system\n\nStart small and then improve\n\nIncrease uniformity\n\nUse SLOs to reduce toil\n\nAssess risk within automation\n\nUse feedback to improve\n\nAutomate toil response\n\nBackground This case study takes place in Google’s datacenters. Similar to all datacenters, Goo‐ gle’s machines are connected to switches, which are connected to routers. Traffic flows in and out from these routers via links that in turn connect to other routers on the internet. As Google’s requirements for handling internet traffic grew, the number of machines required to serve that traffic increased dramatically. Our datacenters grew in scope and complexity as we figured out how to serve a large amount of traffic efficiently and economically. This growth changed the nature of datacenter manual repairs from occasional and interesting to frequent and rote—two signals of toil.\n\nWhen Google first began running its own datacenters, each datacenter’s network top‐ ology featured a small number of network devices that managed traffic to a large number of machines. A single network device failure could significantly impact net‐ work performance, but a relatively small team of engineers could handle trouble‐ shooting the small number of devices. At this early stage, engineers debugged problems and shifted traffic away from failed components manually.\n\nOur next-generation datacenter had significantly more machines and introduced software-defined networking (SDN) with a folded Clos topology, which greatly increased the number of switches. Figure 6-2 shows the complexity of traffic flow for a small datacenter Clos switch network. This proportionately larger number of devi‐ ces meant that a larger number of components could now fail. While each individual\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n107",
      "content_length": 2134,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 140,
      "content": "failure had less impact on network performance than before, the sheer volume of issues began to overwhelm the engineering staff.\n\nIn addition to introducing a heavy load of new problems to debug, the complex lay‐ out was confusing to technicians: Which exact links needed to be checked? Which line card6 did they need to replace? What was a Stage 2 switch, versus a Stage 1 or Stage 3 switch? Would shutting down a switch create problems for users?\n\nFigure 6-2. A small Clos network, which supports 480 machines attached below Stage 1\n\nRepairing failed datacenter line cards was one obvious growing work backlog, so we targeted this task as our first stage of creating datacenter network repair automation. This case study describes how we introduced repair automation for our first genera‐ tion of line cards (named Saturn). We then discuss the improvements we introduced with the next generation of line cards for Jupiter fabrics.\n\nAs shown in Figure 6-3, before the automation project, each fix in the datacenter line-card repair workflow required an engineer to do the following:\n\n1. Check that it was safe to move traffic from the affected switch.\n\n2. Shift traffic away from the failed device (a “drain” operation).\n\n6 A line card is a modular component that usually provides multiple interfaces to the network. It is seated in\n\nthe backplane of a chassis along with other line cards and components. Modular network switches consist of a chassis that includes a backplane, power entry modules, control card module, and one or more line cards. Each line card supports network connections either to machines or other line cards (in other switches). As with a USB network interface adapter, you can replace any line card without powering down the whole switch, provided the line card has been “drained,” meaning that the other interfaces have been told to stop sending traffic to it.\n\n108\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 1923,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 141,
      "content": "3. Perform a reboot or repair (such as replacing a line card).\n\n4. Shift traffic back to the device (an “undrain” operation).\n\nThis unvarying and repetitive work of draining, undraining, and repairing devices is a textbook example of toil. The repetitive nature of the work introduced problems of its own—for example, engineers might multitask by working on a line card while also debugging more challenging problems. As a result, the distracted engineer might accidentally introduce an unconfigured switch back to the network.\n\nFigure 6-3. Datacenter (Saturn) line-card repair workflow before automation: all steps require manual work\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n109",
      "content_length": 706,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 142,
      "content": "Problem Statement The datacenter repairs problem space had the following dimensions:\n\nWe couldn’t grow the team fast enough to keep up with the volume of failures, and we couldn’t fix problems fast enough to prevent negative impact to the fabric.\n\nPerforming the same steps repeatedly and frequently introduced too many human errors.\n\nNot all line-card failures had the same impact. We didn’t have a way to prioritize more serious failures.\n\nSome failures were transient. We wanted the option to restart the line card or reinstall the switch as a first pass at repair. Ideally, we could then programmati‐ cally capture the problem if it happened again and flag the device for replace‐ ment.\n\nThe new topology required us to manually assess the risk of isolating capacity before we could take action. Every manual risk assessment was an opportunity for human error that could result in an outage. Engineers and technicians on the floor didn’t have a good way to gauge how many devices and links would be impacted by their planned repair.\n\nWhat We Decided to Do Instead of assigning every issue to an engineer for risk assessment, drain, undrain, and validation, we decided to create a framework for automation that, when coupled with an on-site technician where appropriate, could support these operations programmatically.\n\nDesign First Effort: Saturn Line-Card Repair Our high-level goal was to build a system that would respond to problems detected on network devices, rather than relying on an engineer to triage and fix these prob‐ lems. Instead of sending a “line card down” alert to an engineer, we wrote the soft‐ ware to request a drain (to remove traffic) and create a case for a technician. The new system had a few notable features:\n\nWe leveraged existing tools where possible. As shown in Figure 6-3, our alerting could already detect problems on the fabric line cards; we repurposed that alert‐ ing to trigger an automated repair. The new workflow also repurposed our tick‐ eting system to support network repairs.\n\n110\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 2064,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 143,
      "content": "We built in automated risk assessment to prevent accidental isolation of devices during a drain and to trigger safety mechanisms where required. This eliminated a huge source of human errors.\n\nWe adopted a strike policy that was tracked by software: the first failure (or strike) only rebooted the card and reinstalled the software. A second failure trig‐ gered card replacement and full return to the vendor.\n\nImplementation The new automated workflow (shown in Figure 6-4) proceeded as follows:\n\n1. The problematic line card is detected and a symptom is added to a specific com‐ ponent in the database.\n\n2. The repair service picks up the problem and enables repairs on the switch. The service performs a risk assessment to confirm that no capacity will be isolated by the operation, and then: a. Drains traffic from the entire switch.\n\nb. Shuts down the line card.\n\nc. If this is a first failure, reboots the card and undrains the switch, restoring ser‐\n\nvice to the switch. At this point, the workflow is complete.\n\nd. If this is the second failure, the workflow proceeds to step 3.\n\n3. The workflow manager detects the new case and sends it to a pool of repair cases for a technician to claim.\n\n4. The technician claims the case, sees a red “stop” in the UI (indicating that the switch needs to be drained before repairs are started), and executes the repair in three steps: a. Initiates the chassis drain via a “Prep component” button in the technician\n\nUI.\n\nb. Waits for the red “stop” to clear, indicating that the drain is complete and the\n\ncase is actionable.\n\nc. Replaces the card and closes the case.\n\n5. The automated repair system brings the line card up again. After a pause to give the card time to initialize, the workflow manager triggers an operation to restore traffic to the switch and close the repair case.\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n111",
      "content_length": 1900,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 144,
      "content": "Figure 6-4. Saturn line-card repair workflow with automation: manual work required only to push a button and replace the line card\n\nThe new system freed the engineering team from a large volume of toilsome work, giving them more time to pursue productive projects elsewhere: working on Jupiter, the next-generation Clos topology.\n\n112\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 366,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 145,
      "content": "Design Second Effort: Saturn Line-Card Repair Versus Jupiter Line- Card Repair Capacity requirements in the datacenter continued to double almost every 12 months. As a result, our next-generation datacenter fabric, Jupiter, was more than six times larger than any previous Google fabric. The volume of problems was also six times larger. Jupiter presented scaling challenges for repair automation because thou‐ sands of fiber links and hundreds of line cards could fail in each layer. Fortunately, the increase in potential failure points was accompanied by far greater redundancy, which meant we could implement more ambitious automation. As shown in Figure 6-5, we preserved some of the general workflow from Saturn and added a few important modifications:\n\nAfter an automated drain/reboot cycle determined that we wanted to replace hardware, we sent the hardware to a technician. However, instead of requiring a technician to initiate the drain with the “Push prep button to drain switch,” we automatically drained the entire switch when it failed.\n\nWe added automation for installing and pushing the configuration that engages after component replacement.\n\nWe enabled automation for verifying that the repair was successful before undraining the switch.\n\nWe focused attention on recovering the switch without involving a technician unless absolutely necessary.\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n113",
      "content_length": 1435,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 146,
      "content": "Figure 6-5. Saturn line-card down automation (left) versus Jupiter automation (right)\n\nImplementation We adopted a simple and uniform workflow for every line-card problem on Jupiter switches: declare the switch down, drain it, and begin a repair.\n\n114\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 283,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 147,
      "content": "The automation carried out the following:\n\n1. The problem switch-down is detected and a symptom is added to the database.\n\n2. The repair service picks up the problem and enables repairs on the switch: drain the entire switch, and add a drain reason.\n\na. If this is the second failure within six months, proceed to step 4.\n\nb. Otherwise, proceed to step 3.\n\n3. Attempt (via two distinct methods) to power-cycle the switch.\n\na. If the power-cycle is successful, run automated verification, then install and configure the switch. Remove the repair reason, clear the problem from the database, and undrain the switch.\n\nb. If preceding sanity-checking operations fail, send the case to a technician with\n\nan instruction message.\n\n4. If this was the second failure, send the case directly to the technician, requesting new hardware. After the hardware change occurs, run automated verification and then install and configure the switch. Remove the repair reason, clear the problem from the database, and undrain the switch.\n\nThis new workflow management was a complete rewrite of the previous repair sys‐ tem. Again, we leveraged existing tools when possible:\n\nThe operations for configuring new switches (install and verify) were the same operations we needed to verify that a switch that had been replaced.\n\nDeploying new fabrics quickly required the ability to BERT7 and cable-audit8 programmatically. Before restoring traffic, we reused that capability to automati‐ cally run test patterns on links that had fallen into repairs. These tests further improved performance by identifying faulty links.\n\nThe next logical improvement was to automate mitigation and repair of memory errors on Jupiter switch line cards. As shown in Figure 6-6, prior to automation, this workflow depended heavily on an engineer to determine if the failure was hardware- or software-related, and then to drain and reboot the switch or arrange a repair if appropriate.\n\n7 Bit error rate test: check for unhealthy links before restoring service.\n\n8 Check for miscabled ports.\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n115",
      "content_length": 2118,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 148,
      "content": "Figure 6-6. Jupiter memory error repair workflow before automation\n\nOur automation simplified the repair workflow by no longer attempting to trouble‐ shoot memory errors (see “Sometimes imperfect automation is good enough” on page 119 for why this made sense). Instead, we treated memory errors the same way we handled failed line cards. To extend automation to memory errors, we simply had to add another symptom to a config file to make it act on the new problem type. Figure 6-7 depicts the automated workflow for memory errors.\n\n116\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 568,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 149,
      "content": "Figure 6-7. Jupiter memory error repair workflow with automation\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n117",
      "content_length": 135,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 150,
      "content": "Lessons Learned During the several years we worked to automate network repair, we learned a lot of general lessons about how to effectively reduce toil.\n\nUIs should not introduce overhead or complexity\n\nFor Saturn-based line cards, replacing a line card required draining the entire switch. Draining the entire switch early in the repair process meant losing the working capacity of all line cards on the switch while waiting for replacement parts and a tech‐ nician. We introduced a button in the UI called “Prep component” that allowed a technician to drain traffic from the entire switch right before they were ready to replace the card, thereby eliminating unnecessary downtime for the rest of the switch (see “Push prep button to drain switch” in Figure 6-5).\n\nThis aspect of the UI and repair workflow introduced a number of unexpected problems:\n\nAfter pressing the button, the technician did not get feedback on drain progress but instead simply had to wait for permission to proceed.\n\nThe button didn’t reliably sync with the actual state of the switch. As a result, sometimes a drained switch did not get repaired, or a technician interrupted traf‐ fic by acting upon an undrained switch.\n\nComponents that did not have automation enabled returned a generic “contact engineering” message when a problem arose. Newer technicians did not know the best way to reach someone who could help. Engineers who were contacted were not always immediately available.\n\nIn response to user reports and problems with regressions caused by the complexity of the feature, we designed future workflows to ensure the switch was safe and ready for repair before the technician arrived at the switch.\n\nDon’t rely on human expertise\n\nWe leaned too heavily on experienced datacenter technicians to identify errors in our system (for example, when the software indicated it was safe to proceed with repairs, but the switch was actually undrained). These technicians also had to perform several tasks manually, without being prompted by automation.\n\nExperience is difficult to replicate. In one particularly high-impact episode, a techni‐ cian decided to expedite the “press button and wait for results” experience by initiat‐ ing concurrent drains on every line card waiting for repairs at the datacenter, resulting in network congestion and user-visible packet loss. Our software didn’t anticipate and prevent this action because we didn’t test the automation with new technicians.\n\n118\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 2503,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 151,
      "content": "Design reusable components\n\nWhere possible, avoid monolithic designs. Build complex automation workflows from separable components, each of which handles a distinct and well-defined task. We could easily reuse or adapt key components of our early Jupiter automation for each successive generation of fabric, and it was easier to add new features when we could build on automation that already existed. Successive variations on Jupiter-type fabrics could leverage work done in earlier iterations.\n\nDon’t overthink the problem\n\nWe overanalyzed the memory error problem for Jupiter line cards. In our attempts at precise diagnosis, we sought to distinguish software errors (fixable by reboots) from hardware errors (which required card replacement), and also to identify errors that impacted traffic versus errors that did not. We spent nearly three years (2012–2015) collecting data on over 650 discrete memory error problems before realizing this exercise was probably overkill, or at least shouldn’t block our repair automation project.\n\nOnce we decided to act upon any error we detected, it was straightforward to use our existing repair automation to implement a simple policy of draining, rebooting, and reinstalling switches in response to memory errors. If the problem recurred, we con‐ cluded that the failure was likely hardware-based and requested component replace‐ ment. We gathered data over the course of a quarter and discovered that most of the errors were transient—most switches recovered after being rebooted and reinstalled. We didn’t need additional data to perform the repair, so the three-year delay in implementing the automation was unnecessary.\n\nSometimes imperfect automation is good enough\n\nWhile the ability to verify links with BERT before undraining them was handy, BERT tooling didn’t support network management links. We added these links into the existing link repair automation with a check that allowed them to skip verification. We were comfortable bypassing verification because the links didn’t carry customer traffic, and we could add this functionality later if verification turned out to be important.\n\nRepair automation is not fire and forget\n\nAutomation can have a very long lifetime, so make sure to plan for project continuity as people leave and join the team. New engineers should be trained on legacy systems so they can fix bugs. Due to parts shortages for Jupiter fabrics, Saturn-based fabrics lived on long after the originally targeted end-of-life date, requiring us to introduce some improvements quite late in Saturn’s overall lifespan.\n\nCase Study 1: Reducing Toil in the Datacenter with Automation\n\n|\n\n119",
      "content_length": 2660,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 152,
      "content": "Once adopted, automation may become entrenched for a long time, with positive and negative consequences. When possible, design your automation to evolve in a flexible way. Relying on inflexible automation makes systems brittle to change. Policy-based automation can help by clearly separating intent from a generic implementation engine, allowing automation to evolve more transparently.\n\nBuild in risk assessment and defense in depth\n\nAfter building new tools for Jupiter that determined the risk of a drain operation before executing it, the complexity we encountered led us to introduce a secondary check for defense in depth. The second check established an upper limit for the num‐ ber of impacted links, and another limit for impacted devices. If we exceeded either threshold, a tracking bug to request further investigation opened automatically. We tuned these limits over time to reduce false positives. While we originally considered this a temporary measure until the primary risk assessment stabilized, the secondary check has proven useful for identifying atypical repair rates due to power outages and software bugs (for one example, see “Automation: Enabling Failure at Scale” in Site Reliability Engineering).\n\nGet a failure budget and manager support\n\nRepair automation can sometimes fail, especially when first introduced. Management support is crucial in preserving the project and empowering the team to persevere. We recommend establishing an error budget for antitoil automation. You should also explain to external stakeholders that automation is essential despite the risk of fail‐ ures, and that it enables continuous improvement in reliability and efficiency.\n\nThink holistically\n\nUltimately, the complexity of scenarios to be automated is the real hurdle to over‐ come. Reexamine the system before you work on automating it—can you simplify the system or workflow first?\n\nPay attention to all aspects of the workflow you are automating, not just the aspects that create toil for you personally. Conduct testing with the people directly involved in the work and actively seek their feedback and assistance. If they make mistakes, find out how your UI could be clearer, or what additional safety checks you need. Make sure your automation doesn’t create new toil—for example, by opening unnec‐ essary tickets that need human attention. Creating problems for other teams will increase resistance to future automation endeavors.\n\n120\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 2487,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 153,
      "content": "Case Study 2: Decommissioning Filer-Backed Home Directories\n\nToil reduction strategies highlighted in Case Study 2:\n\nConsider decommissioning legacy systems\n\nPromote toil reduction as a feature\n\nGet support from management and colleagues\n\nReject the toil\n\nStart with human-backed interfaces\n\nProvide self-service methods\n\nStart small and then improve\n\nUse feedback to improve\n\nBackground In the early days of Google, the Corp Data Storage (CDS) SRE team provided home directories to all Googlers. Similar to Active Directory’s Roaming Profiles, common in Enterprise IT, Googlers could use the same home directories across workstations and platforms. The CDS team also offered “Team Shares” for cross-team collabora‐ tion in a shared storage space. We provided home directories and Team Shares via a fleet of Netapp Storage Appliances over NFS/CIFS (or “filers”). This storage was operationally expensive but provided a much-needed service to Googlers.\n\nProblem Statement As years passed, these filer solutions were mostly deprecated by other, better, storage solutions: our version control systems (Piper9/Git-on-borg10), Google Drive, Google Team Drive, Google Cloud Storage, and an internal, shared, globally distributed file‐ system called x20. These alternatives were superior for a number of reasons:\n\n9 Piper is Google’s internal version control system. For more information, see Rachel Potvin and Josh Leven‐ berg, “Why Google Stores Billions of Lines of Code in a Single Repository,” Communications of the ACM 59, no. 7 (2016): 78–87, http://bit.ly/2J4jgMi.\n\n10 Google also has scalable self-service Git hosting for code that doesn’t live in Piper.\n\nCase Study 2: Decommissioning Filer-Backed Home Directories\n\n|\n\n121",
      "content_length": 1725,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 154,
      "content": "NFS/CIFS protocols were never designed to operate over a WAN, so user experi‐ ence rapidly degraded with even a few tens of milliseconds of latency. This cre‐ ated problems for remote workers or globally distributed teams, as the data could live only in one location.\n\nCompared to alternatives, these appliances were expensive to run and scale.\n\nIt would have taken significant work to make NFS/CIFS protocols compatible with Google’s Beyond Corp11 network security model.\n\nMost relevant to this chapter, home directories and Team Shares were toil-intensive. Many facets of storage provisioning were ticket-driven. Although these workflows were often partially scripted, they represented a sizable amount of the CDS team’s toil. We spent a lot of time creating and configuring shares, modifying access, troubleshooting end user issues, and performing turnups and turndowns to manage capacity. CDS also managed the provisioning, racking, and cabling processes for this specialized hardware, in addition to their configuration, updates, and backups. Due to latency requirements, we often had to deploy in remote offices instead of Google datacenters—which sometimes required a team member to travel a substantial dis‐ tance to manage a deployment.\n\nWhat We Decided to Do First, we gathered data: CDS created a tool called Moonwalk to analyze how employ‐ ees used our services. We collected traditional business intelligence metrics like daily active users (DAU) and monthly active users (MAU), and asked questions like, “Which job families actually use their home directories?” and “Of the users who use filers every day, what kind of files do they access the most?” Moonwalk, combined with user surveys, validated that the business needs currently served by filers could be better served by alternative solutions that had lower operational overhead and cost. Another compelling business reason led us to move away from filers: if we could migrate most of our filer use cases to G Suite/GCP, then we could use the lessons we learned to improve these products, thereby enabling other large enterprises to migrate to G Suite/GCP.\n\nNo single alternative could meet all of the current filer use cases. However, by break‐ ing the problem into smaller addressable components, we found that in aggregate, a handful of alternatives could cover all of our use cases. The alternative solutions were\n\n11 Beyond Corp is an initiative to move from a traditional perimeter-based security model to a cryptographic\n\nidentity-based model. When a Google laptop connects to an internal Google service, the service verifies trust through a combination of a cryptographic certificate identifying the laptop, a second factor owned by the user (such as a USB security key), the client device config/state, and the user’s credentials.\n\n122\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 2845,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 155,
      "content": "more specialized, but each provided a better user experience than a generalized filer- powered solution. For example:\n\nx2012\n\nWas a great way for teams to globally share static artifacts like binaries\n\nG Suite Team Drive\n\nWorked well for office document collaboration, and was much more tolerant of user latency than NFS\n\nGoogle’s Colossus File System\n\nAllowed teams to share large data files more securely and scalably than NFS\n\nPiper/Git-on-Borg\n\nCould better sync dotfiles (engineers’ personalized tool preferences)\n\nA new history-as-a-service tool\n\nCould host cross-workstation command-line history\n\nAs we catalogued use cases and found alternatives, the decommissioning plan took shape.\n\nDesign and Implementation Moving away from filers was an ongoing, iterative, multiyear effort that entailed mul‐ tiple internal projects:\n\nMoira\n\nHome directory decommissioning\n\nTekmor\n\nMigrating the long tail of home directory users\n\nMigra\n\nTeam Share decommissioning\n\nAzog\n\nRetiring home directory/share infrastructure and associated hardware\n\nThis case study focuses on the first project, Moira. The subsequent projects built upon what we learned from and created for Moira.\n\nAs shown in Figure 6-8, Moira consisted of four phases.\n\n12 x20 is an internal globally shared, highly available filesystem with POSIX-like filesystem semantics.\n\nCase Study 2: Decommissioning Filer-Backed Home Directories\n\n|\n\n123",
      "content_length": 1402,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 156,
      "content": "Figure 6-8. The four stages of Project Moira\n\nThe first step to retiring a legacy system is to stop or (often more realistically) to slow or discourage new adoption. It’s much more painful to take something away from users than never offer it in the first place. Moonwalk data showed that nonengineer‐ ing Googlers used their shared home directories the least, so our initial phase targe‐ ted these users. As the phases grew in scope, so did our confidence in the alternative storage solutions and our migration processes and tooling. Each phase of the project had an associated design document that examined the proposal along dimensions like security, scalability, testing, and launch. We also paid special attention to user experience, expectations, and communication. Our goal was making sure that users affected by each phase understood the reasons for the decommissioning project and the easiest way to archive or migrate their data.\n\nKey Components\n\nMoonwalk\n\nWhile we had basic statistics about our users’ shares (share sizes, for example), we needed to understand our users’ workflows to help drive business decisions around the deprecation. We set up a system called Moonwalk to gather and report this infor‐ mation.\n\nMoonwalk stored the data about who was accessing what files and when in BigQuery, which allowed us to create reports and perform ad hoc queries to understand our users better. Using BigQuery, we summarized access patterns across 2.5 billion files using 300 terabytes of disk space. This data was owned by 60,000 POSIX users in 400 disk volumes on 124 NAS appliances in 60 geographic sites around the world.\n\n124\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 1671,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 157,
      "content": "Moira Portal\n\nOur large user base made managing the home directory decommissioning effort with a manual ticket-based process untenable. We needed to make the entire process— surveying users, communicating the reasons for the decommissioning project, and walking through either archiving their data or migrating to an alternative—as low- touch as possible. Our final requirements were:\n\nA landing page describing the project\n\nA continually updated FAQ\n\nThe status and usage information associated with the current user’s share\n\nOptions to request, deactivate, archive, delete, extend, or reactivate a share\n\nOur business logic became fairly complicated because we had to account for a num‐ ber of user scenarios. For example, a user might leave Google, go on a temporary leave, or have data under a litigation hold. Figure 6-9 provides a sample design doc state diagram illustrating this complexity.\n\nFigure 6-9. Business logic based upon user scenarios\n\nCase Study 2: Decommissioning Filer-Backed Home Directories\n\n|\n\n125",
      "content_length": 1021,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 158,
      "content": "The technology powering the portal was relatively simple. Written in Python with the Flask framework, it read and wrote to a Bigtable, and used a number of background jobs and schedulers to manage its work.\n\nArchiving and migration automation\n\nWe needed a lot of ancillary tooling to glue the portal and configuration management together, and to query and communicate with users. We also needed to be sure we identified the right users for the right communications. False positives (erroneously reporting action required) or false negatives (failing to notify a user that you were taking something away) were both unacceptable, and errors here would mean extra work in the form of lost credibility and customer service.\n\nWe worked with alternative storage system owners to add features to their roadmaps. As a result, less mature alternatives became more suitable for filer use cases as the project progressed. We could also use and extend tooling from other teams. For example, we used another team’s internally developed tool to migrate data from Goo‐ gle Cloud Storage to Google Drive as part of the Portal’s auto-archiving functionality.\n\nThe effort required substantial software development over the life of the project. We built and iterated upon each component—the Moonwalk reporting pipeline, the por‐ tal, and the automation to better manage retiring and archiving shares—in response to the next phase’s requirements and user feedback. We approached a feature- complete state only in phase three (almost two years in); and even then, we needed additional tooling to handle a “long tail” of around 800 users. This low and slow approach had definite benefits. It allowed us to:\n\nMaintain a lean team (averaging three CDS team members)\n\nReduce the disruption to user workflows\n\nLimit toil for Techstop (Google’s internal technical support organization)\n\nBuild tools on an as-needed basis to avoid wasted engineering effort\n\nAs with all engineering decisions, there were tradeoffs: the project would be long- lived, so the team had to endure filer-related operational toil while engineering these solutions.\n\nThe program officially completed in 2016. We’ve reduced home directories from 65,000 to around 50 at the time of writing. (The current Azog Project aims to retire these last users and fully decommission the filer hardware.) Our users’ experience has improved, and CDS has retired operationally expensive hardware and processes.\n\n126\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 2478,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 159,
      "content": "Lessons Learned While no one alternative could replace the filer-backed storage that Googlers had used for 14+ years, we didn’t necessarily need a wholesale replacement. By effectively moving up the stack from a generalized but limited filesystem-level solution to multi‐ ple application-specific solutions, we traded flexibility for improved scalability, latency tolerance, and security. The Moira team had to anticipate a variety of user journeys and consider alternatives in various stages of maturity. We had to manage expectations around these alternatives: in aggregate, they could provide a better user experience, but getting there wouldn’t be painless. We learned the following lessons about effectively reducing toil along the way.\n\nChallenge assumptions and retire expensive business processes\n\nBusiness requirements drift and new solutions continuously emerge, so it’s worth‐ while to periodically question toil-intensive business processes. As we discussed in “Toil Management Strategies” on page 101, rejecting toil (deciding not to perform toilsome tasks) is often the simplest way to eliminate it, even though this approach isn’t always quick or easy. Shore up your case with user analytics and business justifi‐ cations beyond mere toil reduction. The primary business justification for filer decommissioning came down to the benefits of a Beyond Corp security model. So, while Moira was a great way to reduce the CDS team’s toil, emphasizing the many security benefits of decommissioning filers made for a more compelling business case.\n\nBuild self-service interfaces\n\nWe built a custom portal for Moira (which was relatively expensive), but there are often easier alternatives. Many teams at Google manage and configure their services using version control, and process organizational requests in the form of pull requests (called changelists, or CLs). This approach requires little or no involvement from the service’s team, but gives us the benefits of code review and continuous deployment processes to validate, test, and deploy internal service configuration changes.\n\nStart with human-backed interfaces\n\nAt several points, the Moira team used an “engineer behind the curtain” approach that married automation with manual work by engineers. For example, share requests opened tracking bugs, which our automation updated as we processed the requests. The system also assigned end users bugs to remind them to address their shares. Tickets can serve as a quick and dirty GUI for automation: they keep a log of work, update stakeholders, and provide a simple human fallback mechanism if auto‐ mation goes awry. In our case, if a user needed help with their migration or if auto‐\n\nCase Study 2: Decommissioning Filer-Backed Home Directories\n\n|\n\n127",
      "content_length": 2768,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 160,
      "content": "mation couldn’t process their request, the bug was automatically routed to a queue that SREs handled manually.\n\nMelt snowflakes\n\nAutomation craves conformity. Moira’s engineers chose to retool our automation to either handle share edge cases specifically, or to delete/modify nonconforming shares to match expectations of tooling. This allowed us to approach zero-touch automation for much of the migration processes.\n\nFun Fact: At Google, this practice of changing reality to fit the code rather than the other way around is called “buying the gnome.” This phrase references a legend about Froogle, a shopping search engine from the very early days of the company.\n\nEarly in Froogle’s life, a serious search quality bug caused a search for [running shoes] to return a garden gnome (wearing running shoes) as a high-ranking result. After several unsuccessful attempts to fix the bug, someone noticed that the gnome was not a mass- produced item, but a single eBay listing with a Buy It Now option. They purchased the gnome (Figure 6-10).\n\nFigure 6-10. The garden gnome that wouldn’t go away\n\n128\n\n|\n\nChapter 6: Eliminating Toil",
      "content_length": 1127,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 161,
      "content": "Employ organizational nudges\n\nLook for ways to nudge new users to adopt better (and hopefully less toil-intensive) alternatives. In this vein, Moira required escalations for new share or quota requests and recognized users who retired their shares. It’s also important to provide good documentation around service setup, best practices, and when to use your service. Google teams frequently employ codelabs or cookbooks that teach users how to set up and use their service for common use cases. As a result, most user onboarding doesn’t require help from the team that owns the service.\n\nConclusion At minimum, the amount of toil associated with running a production service grows linearly with its complexity and scale. Automation is often the gold standard of toil elimination, and can be combined with a number of other tactics. Even when toil isn’t worth the effort of full automation, you can decrease engineering and operations workloads through strategies like partial automation or changing business processes.\n\nThe patterns and methods for eliminating toil described in this chapter can be gener‐ alized to work for a variety of other large-scale production services. Eliminating toil frees up engineering time to focus on the more enduring aspects of services, and allows teams to keep manual tasks at a minimum as the complexity and scale of modern service architectures continue to increase.\n\nIt’s important to note that eliminating toil isn’t always the best solution. As men‐ tioned throughout this chapter, you should consider the measurable costs associated with identifying, designing, and implementing processes or automation solutions around toil. Once you identify toil, it’s crucial to determine when toil reduction makes sense, using metrics, return on investment (ROI) analysis, risk assessment, and iterative development.\n\nToil usually starts small, and can rapidly grow to consume an entire team. SRE teams must be relentless in eliminating toil, because even if the task seems daunting, the benefits usually exceed the costs. Each of the projects we described required persever‐ ance and dedication from its respective teams, who sometimes battled skepticism or institutional resistance, and who always faced competing high priorities. We hope these stories encourage you to identify your toil, quantify it, and then work toward eliminating it. Even if you can’t invest in a big project today, you can start with a small proof of concept that can help change your team’s willingness to deal with toil.\n\nConclusion\n\n|\n\n129",
      "content_length": 2547,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 163,
      "content": "CHAPTER 7 Simplicity\n\nBy John Lunney, Robert van Gent, and Scott Ritchie with Diane Bates and Niall Richard Murphy\n\nA complex system that works is invariably found to have evolved from a simple system that worked.\n\n—Gall’s Law\n\nSimplicity is an important goal for SREs, as it strongly correlates with reliability: sim‐ ple software breaks less often and is easier and faster to fix when it does break. Simple systems are easier to understand, easier to maintain, and easier to test.\n\nFor SREs, simplicity is an end-to-end goal: it should extend beyond the code itself to the system architecture and the tools and processes used to manage the software life‐ cycle. This chapter explores some examples that demonstrate how SREs can measure, think about, and encourage simplicity.\n\nMeasuring Complexity Measuring the complexity of software systems is not an absolute science. There are a number of ways to measure software code complexity, most of which are quite objec‐ tive.1 Perhaps the best-known and most widely available standard is cyclomatic code complexity, which measures the number of distinct code paths through a specific set of statements. For example, a block of code with no loops or conditionals has a cyclo‐ matic complexity number (CCN) of 1. The software community is actually quite good at measuring code complexity, and there are measurement tools for a number of integrated development environments (including Visual Studio, Eclipse, and\n\n1 If you’re interested in learning more, read this recent review of trends in software complexity, or read Horst\n\nZuse, Software Complexity: Measures and Methods (Berlin: Walter de Gruyter, 1991).\n\n131",
      "content_length": 1660,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 164,
      "content": "IntelliJ). We’re less adept at understanding whether the resulting measured complex‐ ity is necessary or accidental, how the complexity of one method might influence a larger system, and which approaches are best for refactoring.\n\nOn the other hand, formal methodologies for measuring system complexity are rare.2 You might be tempted to try a CCN-type approach of counting the number of dis‐ tinct entities (e.g., microservices) and possible communication paths between them. However, for most sizable systems, that number can grow hopelessly large very quickly.\n\nSome more practical proxies for systems-level complexity include:\n\nTraining time\n\nHow long does it take a new team member to go on-call? Poor or missing docu‐ mentation can be a significant source of subjective complexity.\n\nExplanation time\n\nHow long does it take to explain a comprehensive high-level view of the service to a new team member (e.g., diagram the system architecture on a whiteboard and explain the functionality and dependencies of each component)?\n\nAdministrative diversity\n\nHow many ways are there to configure similar settings in different parts of the system? Is configuration stored in a centralized place, or in multiple locations?\n\nDiversity of deployed configurations\n\nHow many unique configurations are deployed in production (including binar‐ ies, binary versions, flags, and environments)?\n\nAge\n\nHow old is the system? Hyrum’s Law states that over time, the users of an API depend on every aspect of its implementation, resulting in fragile and unpredict‐ able behaviors.\n\nWhile measuring complexity is occasionally worthwhile, it’s difficult. However, there seems to be no serious opposition to the observations that:\n\nIn general, complexity will increase in living software systems unless there is a countervailing effort.\n\nProviding that effort is a worthwhile thing to do.\n\n2 Although there are examples of it—for example, “Automated Formal Reasoning about AWS Systems”.\n\n132\n\n|\n\nChapter 7: Simplicity",
      "content_length": 1997,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 165,
      "content": "Simplicity Is End-to-End, and SREs Are Good for That Generally, production systems are not designed in a holistic fashion; rather, they grow organically. They accumulate components and connections over time as teams add new features and launch new products. While a single change might be relatively simple, every change impacts the components around it. Therefore, overall complex‐ ity can quickly become overwhelming. For example, adding retries in one component might overload a database and destabilize the whole system, or make it harder to rea‐ son about the path a given query follows through the system.\n\nFrequently, the cost of complexity does not directly affect the individual, team, or role that introduces it—in economic terms, complexity is an externality. Instead, complexity impacts those who continue to work in and around it. Thus, it is impor‐ tant to have a champion for end-to-end system simplicity.\n\nSREs are a natural fit for this role because their work requires them to treat the sys‐ tem as a whole.3 In addition to supporting their own services, SREs must also have insight into the systems their service interacts with. Google’s product development teams often don’t have visibility on production-wide issues, so they find it valuable to consult SREs for advice on the design and operation of their systems.\n\nReader action: Before an engineer goes on-call for the first time, encourage them to draw (and redraw) system diagrams. Keep a canonical set of diagrams in your documentation: they’re useful to new engineers and help more experienced engineers keep up with changes.\n\nIn our experience, product developers usually end up working in a narrow subsystem or component. As a result, they don’t have a mental model for the overall system, and their teams don’t create system-level architecture diagrams. These diagrams are use‐ ful because they help team members visualize system interactions and articulate issues using a common vocabulary. More often than not, we find the SRE team for the service draws the system-level architecture diagrams.\n\nReader action: Ensure that an SRE reviews all major design docs, and that the team documents show how the new design affects the system architecture. If a design adds complexity, the SRE might be able to suggest alternatives that simplify the system.\n\n3 As a result, SRE may be a useful investment for product development leads who wish to attack complexity as\n\na proxy for technical debt, but find it hard to justify that work within the scope of their existing team.\n\nSimplicity Is End-to-End, and SREs Are Good for That\n\n|\n\n133",
      "content_length": 2607,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 166,
      "content": "Case Study 1: End-to-End API Simplicity\n\nBackground\n\nIn a previous role, one of the chapter authors worked at a startup that used a key/ value bag data structure in its core libraries. RPCs (remote procedure calls) took a bag and returned a bag; actual parameters were stored as key/value pairs inside the bag. The core libraries supported common operations on bags, such as serialization, encryption, and logging. All of the core libraries and APIs were extremely simple and flexible—success, right?\n\nSadly, no: the clients of the libraries ended up paying a penalty for the abstract nature of the core APIs. The set of keys and values (and value types) needed to be carefully documented for each service, but usually weren’t. In addition, maintaining back‐ ward/forward compatibility became difficult as parameters were added, removed, or changed over time.\n\nLessons learned\n\nStructured data types like Google’s Protocol Buffers or Apache Thrift might seem more complex than their abstract general-purpose alternatives, but they result in sim‐ pler end-to-end solutions because they force upfront design decisions and documen‐ tation.\n\nCase Study 2: Project Lifecycle Complexity When you review the tangled spaghetti of your existing system, it might be tempting to replace it wholesale with a new, clean, simple system that solves the same problem. Unfortunately, the cost of creating a new system while maintaining the current one might not be worthwhile.\n\nBackground\n\nBorg is Google’s internal container management system. It runs huge numbers of Linux containers and has a wide variety of usage patterns: batch versus production, pipelines versus servers, and more. Over the years, Borg and its surrounding ecosys‐ tem grew as hardware changed, features were added, and its scale increased.\n\nOmega was intended to be a more principled, cleaner version of Borg that supported the same use cases. However, the planned switch from Borg to Omega had a few seri‐ ous problems:\n\n134\n\n|\n\nChapter 7: Simplicity",
      "content_length": 2008,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 167,
      "content": "Borg continued to evolve as Omega was developed, so Omega was always chasing a moving target.\n\nEarly estimates of the difficulty of improving Borg proved overly pessimistic, while the expectations for Omega proved overly optimistic (in practice, the grass isn’t always greener).\n\nWe didn’t fully appreciate how difficult it would be to migrate from Borg to Omega. Millions of lines of configuration code across thousands of services and many SRE teams meant that the migration would be extremely costly in terms of engineering and calendar time. During the migration period, which would likely take years, we’d have to support and maintain both systems.\n\nWhat we decided to do\n\nEventually, we fed some of the ideas that emerged while designing Omega back into Borg. We also used many of Omega’s concepts to jump-start Kubernetes, an open source container management system.\n\nLessons learned\n\nWhen considering a rewrite, think about the full project lifecycle, including develop‐ ment toward a moving target, a full migration plan, and extra costs you might incur during the migration time window. Wide APIs with lots of users are very hard to migrate. Don’t compare the expected result to your current system. Instead, compare the expected result to what your current system would look like if you invested the same effort in improving it. Sometimes a rewrite is the best way forward, but make sure you’ve weighed the costs and benefits and that you don’t underestimate the costs.\n\nRegaining Simplicity Most simplification work consists of removing elements from a system. Sometimes simplification is direct (e.g., removing a dependency on an unused piece of data fetched from a remote system). Other times, simplification requires redesign. For example, two parts of a system might need access to the same remote data. Rather than fetch it twice, a simpler system might fetch the data once and forward the result.\n\nWhatever the work, leadership must ensure that simplification efforts are celebrated and explicitly prioritized. Simplification is efficiency—instead of saving compute or network resources, it saves engineering time and cognitive load. Treat successful sim‐ plification projects just as you treat useful feature launches, and measure and cele‐\n\nRegaining Simplicity\n\n|\n\n135",
      "content_length": 2289,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 168,
      "content": "brate code addition and removal equally.4 For example, Google’s intranet displays a “Zombie Code Slayer” badge for engineers that delete significant amounts of code.\n\nSimplification is a feature. You need to prioritize and staff simplification projects and reserve time for SREs to work on them. If product developers and SREs do not see simplification projects as beneficial to their careers, they won’t undertake these projects. Consider making simplicity an explicit goal for particularly complex sys‐ tems or overloaded teams. Create a separate bucket of time to do this work. For example, reserve 10% of engineering project time for “simplicity” projects.5\n\nReader action: Have engineers brainstorm known complexities in the system and discuss ideas to reduce them.\n\nAs a system grows in complexity, there is a temptation to split SRE teams, focusing each new team on smaller parts of the system. While this is sometimes necessary, the reduced scope of the new teams might lessen their motivation or ability to drive larger simplification projects. Consider designating a small rotating group of SREs who maintain working knowledge of the entire stack (likely with less depth), and can push for conformity and simplification across it.\n\nAs previously mentioned, the act of diagramming your system can help you identify deeper design problems that hinder your ability to understand the system and predict its behavior. For example, when diagramming your system, you might look for the following:\n\nAmplification\n\nWhen a call returns an error or times out and is retried on several levels, it causes the total number of RPCs to multiply.\n\nCyclic dependencies\n\nWhen a component depends on itself (often indirectly), system integrity can be gravely compromised—in particular, a cold start of the whole system might become impossible.\n\n4 As Dijkstra said, “If we wish to count lines of code, we should not regard them as ‘lines produced’ but as ‘lines\n\nspent.’”\n\n5 Reserving some portion of time for simplicity projects (10%, for example) doesn’t mean the team has a green light to introduce complexity with the other 90%. It just means you are setting aside some effort with the specific goal of simplification.\n\n136\n\n|\n\nChapter 7: Simplicity",
      "content_length": 2242,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 169,
      "content": "Case Study 3: Simplification of the Display Ads Spiderweb\n\nBackground\n\nGoogle’s Display Ads business has many related products, including some that origi‐ nated from acquisitions (DoubleClick, AdMob, Invite Media, etc.). These products had to be adapted to work with Google infrastructure and existing products. For example, we wanted a website using DoubleClick for Publishers to be able to show ads chosen by Google’s AdSense; similarly, we wanted bidders using DoubleClick Bid Manager to have access to the real-time auctions run on Google’s Ad Exchange.\n\nThese independently developed products formed a system of interconnected back‐ ends that was difficult to reason about. Observing what happened to traffic as it passed through components was difficult, and provisioning the right amount of capacity for each piece was inconvenient and imprecise. At one point, we added tests to make sure we had removed all infinite loops in the query flow.\n\nWhat we decided to do\n\nAds serving SREs were the natural drivers for standardization: while each component had a specific developer team, SREs were on-call for the entire stack. One of our first undertakings was to draft uniformity standards and work with developer teams to incrementally adopt them. These standards:\n\nEstablished a single way to copy large data sets\n\nEstablished a single way to perform external data lookups\n\nProvided common templates for monitoring, provisioning, and configuration\n\nBefore this initiative, separate programs provided frontend and auction functionality for each product. As shown in Figure 7-1, when an ad request might hit two targeting systems, we rewrote the request to meet the expectations of the second system. This required additional code and processing, and it also opened the possibility of unde‐ sirable loops.\n\nRegaining Simplicity\n\n|\n\n137",
      "content_length": 1837,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 170,
      "content": "Figure 7-1. Previously, an ad request might hit both the AdMob and AdSense systems\n\nTo simplify the system, we added logic to common programs that satisfied all of our use cases, along with flags to guard the programs. Over time, we removed the flags and consolidated the functionality into fewer server backends.\n\nOnce the servers were unified, the auction server could talk to both targeting servers directly. As shown in Figure 7-2, when multiple targeting servers needed data look‐ ups, the lookup needed to happen only once in the unified auction server.\n\nFigure 7-2. The unified auction server now performs a data lookup only once\n\n138\n\n|\n\nChapter 7: Simplicity",
      "content_length": 667,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 171,
      "content": "Lessons learned\n\nIt’s best to integrate an already running system into your own infrastructure incre‐ mentally.\n\nJust as the presence of very similar functions in a single program represents a “code smell” that indicates deeper design problems, redundant lookups in a single request represent a “system smell.”\n\nWhen you create well-defined standards with buy-in from SRE and developers, you can provide a clear blueprint for removing complexity that managers are more likely to endorse and reward.\n\nCase Study 4: Running Hundreds of Microservices on a Shared Platform by Mike Curtis\n\nBackground\n\nOver the past 15 years, Google has developed multiple successful product verticals (Search, Ads, and Gmail, to name a few) and produced a steady stream of new and refactored systems. Many of these systems have a dedicated SRE team and a corre‐ sponding domain-specific production stack that includes a bespoke development workflow, continuous integration and continuous delivery (CI/CD) software cycles, and monitoring. These unique production stacks incur significant overhead in terms of maintenance, development costs, and independent SRE engagement. They also make it harder to move services (or engineers!) between teams, or to add new serv‐ ices.\n\nWhat we decided to do\n\nA set of SRE teams in the social networking space worked to converge the production stacks for their services into a single managed microservices platform, managed by a single group of SREs. The shared platform is compliant with best practices, and it bundles and automatically configures many previously underused features that improve reliability and facilitate debugging. Regardless of their SRE engagement level, new services within the scope of the SRE team were required to use the com‐ mon platform, and legacy services had to either migrate to the new platform or be phased out.\n\nAfter its success in the social network space, the shared platform is gaining adoption with other SRE and non-SRE teams across Google.\n\nRegaining Simplicity\n\n|\n\n139",
      "content_length": 2026,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 172,
      "content": "Design\n\nWe used microservices so we could quickly update and deploy features—a single monolithic service changes slowly. Services are managed, not hosted: rather than removing control and responsibility from individual teams, we empower them to manage their services effectively themselves. We provide workflow tools that service teams can use to release, monitor, and more.\n\nThe tools we provide include a UI, API, and a command-line interface that SREs and developers use to interact with their stack. The tools make the developer experience feel unified, even when it involves many underlying systems.\n\nOutcomes\n\nThe platform’s high quality and feature set had an unexpected benefit: developer teams can run hundreds of services without any deep SRE engagement.\n\nThe common platform also changed the SRE-developer relationship. As a result, tiered SRE engagement is becoming common at Google. Tiered engagement includes a spectrum of SRE involvement, ranging from light consulting and design reviews to deep engagement (i.e., SREs share on-call duties).\n\nLessons learned\n\nShifting from sparse or ill-defined standards to a highly standardized platform is a long-term investment. Each step might feel incremental, but ultimately, these steps reduce overhead and make running services at scale possible.\n\nIt’s important that developers see the value in such a transition. Aim for incremental productivity wins that are unlocked at each stage of development. Don’t try to con‐ vince people to perform a huge refactor that pays off only at the very end.\n\nCase Study 5: pDNS No Longer Depends on Itself\n\nBackground\n\nWhen a client in Google production wants to look up the IP address for a service, it often uses a lookup service called Svelte. In the past, to find the IP address for Svelte, the client used a Google naming service called pDNS (Production DNS). The pDNS service is accessed through a load balancer, which looks up the IP addresses for the actual pDNS servers…using Svelte.\n\nProblem statement\n\npDNS had a transitive dependency on itself, which was unintentionally introduced at some point and only later identified as a reliability concern. Lookups normally didn’t run into issues because the pDNS service is replicated, and the data needed to break\n\n140\n\n|\n\nChapter 7: Simplicity",
      "content_length": 2294,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 173,
      "content": "out of the dependency loop was always available somewhere in Google production. However, a cold start would have been impossible. In the words of one SRE, “We were like cave dwellers who could only light fires by running with a torch lit from the last campfire.”\n\nWhat we decided to do\n\nWe modified a low-level component in Google production to maintain a list of cur‐ rent IP addresses for nearby Svelte servers in local storage for all Google production machines. In addition to breaking the circular dependency described earlier, this change also eliminated an implicit dependency on pDNS for most other Google serv‐ ices.\n\nTo avoid similar issues, we also introduced a method for whitelisting the set of serv‐ ices allowed to communicate with pDNS, and slowly worked to reduce that set. As a result, each service lookup in production now has a simpler and more reliable path through the system.\n\nLessons learned\n\nBe careful about your service’s dependencies—use an explicit whitelist to prevent accidental additions. Also, be on the lookout for circular dependencies.\n\nConclusion Simplicity is a natural goal for SREs because simple systems tend to be reliable and easy to run. It’s not easy to quantitatively measure simplicity (or its inverse, complex‐ ity) for distributed systems, but there are reasonable proxies, and it’s worth picking some and working to improve them.\n\nBecause of their end-to-end understanding of a system, SREs are in an excellent posi‐ tion to identify, prevent, and fix sources of complexity, whether they are found in software design, system architecture, configuration, deployment processes, or else‐ where. SREs should be involved in design discussions early on to provide their unique perspective about the costs and benefits of alternatives, with a particular eye toward simplicity. SREs can also proactively develop standards to homogenize pro‐ duction.\n\nAs an SRE, pushing for simplicity is an important part of your job description. We strongly recommend that SRE leadership empower SRE teams to push for simplicity, and to explicitly reward these efforts. Systems inevitably creep toward complexity as they evolve, so the fight for simplicity requires continuous attention and commit‐ ment—but it is very much worth pursuing.\n\nConclusion\n\n|\n\n141",
      "content_length": 2286,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 175,
      "content": "PART II Practices\n\nBuilding upon the solid foundation of SRE principles covered in Part I, Part II dives deep into how to conduct SRE-related activities that Google has found important for operating at scale.\n\nSome of these topics, such as data processing pipelines and managing load, won’t apply to all organizations. Other topics, such as safely handling changes with configu‐ ration and canarying, on-call practices, and what to do when things go wrong, con‐ tain valuable lessons for any SRE team.\n\nThis part also introduces an important SRE skill—Non-Abstract Large System Design (NALSD)—and presents a detailed example of how to practice this design process.\n\nAs we move from SRE foundations to practices, we wanted to provide a bit more context on the relationship between operational duties and project work, and the engineering it takes to accomplish both strategically.",
      "content_length": 879,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 176,
      "content": "Defining Operational Work (Versus Project Work and Overhead) Before we move from foundations to practices, we wanted to touch on the difference between operational and project work, and how these two types of work inform each other. The topic is an area of philosophical debate in the SRE community, so this interlude presents how we define the two types of work in the context of this book.\n\nSRE practices apply software engineering solutions to operational problems. Because our SRE teams are responsible for the day-to-day functioning of the systems we sup‐ port, our engineering work often focuses on tasks that might be operations elsewhere: we automate release processes instead of performing them manually; we implement sharding to make our services more reliable and less demanding of human attention; we utilize algorithmic approaches to capacity planning so that engineers don’t have to perform error-prone manual calculations.\n\nWhile engineering and operational work do inform each other, we can conceptualize the work any given SRE team performs as two separate categories, as shown in Figure II-1. Over the years, we’ve worked toward ways to maximize the efficiency and scalability of each bucket of work.\n\nFigure II-1. The two categories of SRE work\n\nWe can break down operational work into four general categories:\n\nOn-call work\n\nCustomer requests (most commonly, tickets)\n\nIncident response\n\nPostmortems",
      "content_length": 1419,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 177,
      "content": "Each of these categories receives its own detailed treatment in both our first book (Chapter 11; Chapter 14; Chapter 15) and this one (Chapter 6; Chapter 8; Chapter 9; Chapter 10). Here, we show how all four are interconnected, and why it’s important to consider these types of work as closely related.\n\nWhat types of work are not included in operational work? As shown in Figure II-1, project work is the other main bucket of SRE work. When a team’s interrupt work is well managed, they have time for longer-term engineering work to achieve stability, reliability, and availability goals. This might include software engineering projects aimed at improving the reliability of a service, or systems engineering projects like safely rolling out a new feature to a globally replicated service.\n\nAlso shown in Figure II-1, overhead is the administrivia necessary to working at a company: meetings, training, responding to emails, tracking your accomplishments, filling out paperwork, and so on. Overhead isn’t immediately important to the discus‐ sion at hand, but all team members spend time on it.\n\nYou might notice that we don’t specifically call out documentation as a separate activity. This is because we believe that healthy documentation procedures embed themselves into all of your work. You don’t need to think about documenting code, playbooks, and service features—or even making sure that tickets and bugs contain all of the information they should—as separate from your project or operational tasks. It’s simply another facet of those tasks.\n\nAt Google, we specify that SREs should spend at least 50% of their time on project work; anything less makes for unsustainable engineering and burned-out, unhealthy teams. While every team and organization needs to find its own healthy balance, we’ve found that about one-third of time spent on operational tasks and two-thirds of time spent on project work is just about right (this ratio also informs an ideal on-call rotation size, where your engineers are only on-call one-third of the time).\n\nWe encourage teams to conduct periodic reviews to track whether you’re striking the appropriate balance between types of work. At Google, we conduct regular Produc‐ tion Excellence (ProdEx) Reviews, which allow senior SRE leadership a view into the state of every SRE team using a clearly defined rubric. You’ll need to determine the appropriate time intervals and rubric according to your own constraints and organi‐ zational maturity, but the key here is to generate metrics about team health that you can track over time.\n\nRemember one caveat when finding your ideal balance: a team that spends too little of its time on operational tasks risks operational underload. In this situation, engi‐ neers might start to forget crucial aspects of the service they are responsible for. You can counter operational underload by taking more risks and moving faster—for example, shorten your release cycles, push more features per release, or perform more disaster recovery testing. If your team is perpetually underloaded, consider onboard‐ ing related services or handing back a service that no longer needs SRE support to the development team (for more discussion of team size, see Chapter 8).",
      "content_length": 3240,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 178,
      "content": "The Relationship Between Operational Work and Project Work\n\nWhile they are different classes of work, operational and project work aren’t entirely separate concerns. In fact, the issues raised in the former should feed into the latter: SRE project work should be strategic initiatives that make the system more efficient, scalable, and reliable, and/or that reduce operational load and toil. As shown in Figure II-1, there should be a continuous feedback loop between the sources of opera‐ tional load and the project work that systematically improves production. This longer-term work might involve moving to more robust storage systems, redesigning frameworks to reduce brittleness or maintenance load, or addressing systemic sources of outages and incidents. These initiatives are developed and implemented via projects, defined as temporary endeavors (with a clear beginning and end) that deliver a specified objective or deliverable.",
      "content_length": 938,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 179,
      "content": "CHAPTER 8 On-Call\n\nBy Ollie Cook, Sara Smollett, Andrea Spadaccini, Cara Donnelly, Jian Ma, and Garrett Plasky (Evernote) with Stephen Thorne and Jessie Yang\n\nBeing on-call means being available during a set period of time, and being ready to respond to production incidents during that time with appropriate urgency. Site Reli‐ ability Engineers (SREs) are often required to take part in on-call rotations. During on-call shifts, SREs diagnose, mitigate, fix, or escalate incidents as needed. In addi‐ tion, SREs are regularly responsible for nonurgent production duties.\n\nAt Google, being on-call is one of the defining characteristics of SRE. SRE teams miti‐ gate incidents, repair production problems, and automate operational tasks. Since most of our SRE teams have not yet fully automated all their operational tasks, escala‐ tions need human points of contact—on-call engineers. Depending on how critical the supported systems are, or the state of development the systems are in, not all SRE teams may need to be on-call. In our experience, most SRE teams staff on-call shifts.\n\nOn-call is a large and complex topic, saddled with many constraints and a limited margin for trial and error. Chapter 11 of our first book (Site Reliability Engineering), “Being On-Call,” already explored this topic. This chapter addresses specific feedback and questions we received about that chapter. These include the following:\n\n“We are not Google; we’re much smaller. We don’t have as many people in the rotation, and we don’t have sites in different time zones. What you described in your first book is irrelevant to me.”\n\n“We have a mixture of developers and DevOps for on-call rotation. What’s the best way to organize them? Split the responsibilities?”\n\n147",
      "content_length": 1753,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 180,
      "content": "“Our on-call engineer gets paged about a hundred times in a typical 24-hour shift. A lot of pages get ignored, while the real problems are buried under the pile. Where should we start?”\n\n“We have a high turnover rate for on-call rotations. How do you address the knowledge gap within the team?”\n\n“We want to reorg our DevOps team into SRE.1 What’s the difference between SRE on-call, DevOps on-call, and developers on-call? Please be specific, because the DevOps team is very concerned about this.”\n\nWe offer practical advice for these situations. Google is a large company with a mature SRE organization, but much of what we’ve learned over the years can be applied to any company or organization, regardless of size or maturity. Google has hundreds of on-call rotations across services of all sizes, and various on-call setups from simple to complicated. On-call is not exclusively an SRE function: many devel‐ oper teams are directly on-call for their service. Each on-call setup meets the need of a particular service.\n\nThis chapter describes on-call setups both within Google and outside of Google. While your setup and situation will likely differ from our specific examples, the essential concepts we cover are widely applicable.\n\nWe then delve into the anatomy of pager load, explaining what causes pager load. We suggest strategies to optimize on-call setup and minimize that load.\n\nFinally, we share two examples of practices inside Google: on-call flexibility and on- call team dynamics. These practices show that no matter how mathematically sound an on-call setup is, you cannot solely rely on logistics of the on-call setup. Incentives and human nature play an important role, and should also be taken into account.\n\nRecap of “Being On-Call” Chapter of First SRE Book Site Reliability Engineering, in “Being On-Call”, explains the principles behind on-call rotations at Google. This section discusses the main points of that chapter.\n\nAt Google, the overall goal of being on-call is to provide coverage for critical services, while making sure that we never achieve reliability at the expense of an on-call engi‐ neer’s health. As a result, SRE teams strive for balance. SRE work should be a healthy mix of duties: on-call and project work. Specifying that SREs spend at least 50% of their time on project work means that teams have time to tackle the projects required\n\n1 Note that this example is often a red flag situation for organizations that aren’t actually practicing DevOps, in\n\nwhich case, a name change won’t fix more structural problems.\n\n148\n\n|\n\nChapter 8: On-Call",
      "content_length": 2591,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 181,
      "content": "to strategically address any problems found in production. Team staffing must be adequate to ensure time for project work.\n\nWe target a maximum of two incidents per on-call shift,2 to ensure adequate time for follow-up. If the pager load gets too high, corrective action is warranted. (We explore pager load later in this chapter.)\n\nPsychological safety3 is vital for effective on-call rotations. Since being on-call can be daunting and highly stressful, on-call engineers should be fully supported by a series of procedures and escalation paths to make their lives easier.\n\nOn-call usually implies some amount of out-of-hours work. We believe this work should be compensated. While different companies may choose to handle this in dif‐ ferent ways, Google offers time-off-in-lieu or cash compensation, capped at some proportion of the overall salary. The compensation scheme provides an incentive for being part of on-call, and ensures that engineers do not take on too many on-call shifts for economic reasons.\n\nExample On-Call Setups Within Google and Outside Google This section describes real-world examples of on-call setups at Google and Evernote, a California company that develops a cross-platform app that helps individuals and teams create, assemble, and share information. For each company, we explore the reasoning behind on-call setups, general on-call philosophy, and on-call practices.\n\nGoogle: Forming a New Team\n\nInitial scenario\n\nA few years ago, Sara, an SRE at Google Mountain View, started a new SRE team that needed to be on-call within three months. To put this in perspective, most SRE teams at Google do not expect new hires to be ready for on-call before three to nine months. The new Mountain View SRE team would support three Google Apps serv‐ ices that were previously supported by an SRE team in Kirkland, Washington (a two- hour flight from Mountain View). The Kirkland team had a sister SRE team in London, which would continue to support these services alongside the new Moun‐ tain View SRE team, and distributed product development teams.4\n\n2 One “incident” is defined as one “problem,” no matter how many alerts have been fired for the same “prob‐\n\nlem.” One shift is 12 hours.\n\n3 There is more on this topic in Seeking SRE by David Blank-Edelman (O’Reilly).\n\n4 SRE teams at Google are paired across time zones for service continuity.\n\nExample On-Call Setups Within Google and Outside Google\n\n|\n\n149",
      "content_length": 2435,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 182,
      "content": "The new Mountain View SRE team came together quickly, assembling seven people:\n\nSara, an SRE tech lead\n\nMike, an experienced SRE from another SRE team\n\nA transfer from a product development team who was new to SRE\n\nFour new hires (“Nooglers”)\n\nEven when a team is mature, going on-call for new services is always challenging, and the new Mountain View SRE team was a relatively junior team. Nonetheless, the new team was able to onboard the services without sacrificing service quality or project velocity. They made immediate improvements to the services, including lowering machine costs by 40%, and fully automating release rollouts with canarying and other safety checks. The new team also continued to deliver reliable services, targeting 99.98% availability, or roughly 26 minutes of downtime per quarter.\n\nHow did the new SRE team bootstrap themselves to accomplish so much? Through starter projects, mentoring, and training.\n\nTraining roadmap\n\nAlthough the new SRE team didn’t know much about their services, Sara and Mike were familiar with Google’s production environment and SRE. As the four Nooglers completed company orientation, Sara and Mike compiled a checklist of two dozen focus areas for people to practice before going on-call, such as:\n\nAdministering production jobs\n\nUnderstanding debugging info\n\n“Draining” traffic away from a cluster\n\nRolling back a bad software push\n\nBlocking or rate-limiting unwanted traffic\n\nBringing up additional serving capacity\n\nUsing the monitoring systems (for alerting and dashboards)\n\nDescribing the architecture, various components, and dependencies of the services\n\nThe Nooglers found some of this information on their own by researching existing documentation and codelabs (guided, hands-on coding tutorials) and gained under‐ standing on relevant topics by working on their starter projects. When a team mem‐ ber learned about specific topics relevant to the Nooglers’ starter projects, that person led a short, impromptu session to share that information with the rest of the team. Sara and Mike covered the remaining topics. The team also held lab sessions to\n\n150\n\n|\n\nChapter 8: On-Call",
      "content_length": 2146,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 183,
      "content": "perform common debugging and mitigation tasks to help everyone build muscle memory and gain confidence in their abilities.\n\nIn addition to the checklist, the new SRE team ran a series of “deep dives” to dig into their services. The team browsed monitoring consoles, identified running jobs, and tried debugging recent pages. Sara and Mike explained that an engineer didn’t need years of expertise with each of the services to become reasonably proficient. They coached the team to explore a service from first principles, and encouraged Nooglers to become familiar with the services. They were open about the limits of their knowl‐ edge, and taught others when to ask for help.\n\nThroughout the ramp-up, the new SRE team wasn’t alone. Sara and Mike traveled to meet the other SRE teams and product developers and learn from them. The new SRE team met with the Kirkland and London teams by holding video conferences, exchanging email, and chatting over IRC. In addition, the team attended weekly pro‐ duction meetings, read daily on-call handoffs and postmortems, and browsed exist‐ ing service documentation. A Kirkland SRE visited to give talks and answer questions. A London SRE put together a thorough set of disaster scenarios and ran them during Google’s disaster recovery training week (see the section “Preparedness and Disaster Testing” in Site Reliability Engineering, Chapter 33).\n\nThe team also practiced being on-call through “Wheel of Misfortune” training exerci‐ ses (see the section “Disaster Role Playing” in Site Reliability Engineering, Chapter 28), where they role-played recent incidents to practice debugging production prob‐ lems. During these sessions, all SREs were encouraged to offer suggestions on how to resolve mock production failures. After everyone ramped up, the team still held these sessions, rotating through each team member as the session leader. The team recor‐ ded these for future reference.\n\nBefore going on-call, the team reviewed precise guidelines about the responsibilities of on-call engineers. For example:\n\nAt the start of each shift, the on-call engineer reads the handoff from the previ‐ ous shift.\n\nThe on-call engineer minimizes user impact first, then makes sure the issues are fully addressed.\n\nAt the end of the shift, the on-call engineer sends a handoff email to the next engineer on-call.\n\nThe guidelines also specified when to escalate to others, and how to write postmor‐ tems for large incidents.\n\nFinally, the team read and updated on-call playbooks. Playbooks contain high-level instructions on how to respond to automated alerts. They explain the severity and impact of the alert, and include debugging suggestions and possible actions to take to\n\nExample On-Call Setups Within Google and Outside Google\n\n|\n\n151",
      "content_length": 2775,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 184,
      "content": "mitigate impact and fully resolve the alert. In SRE, whenever an alert is created, a cor‐ responding playbook entry is usually created. These guides reduce stress, the mean time to repair (MTTR), and the risk of human error.\n\nMaintaining Playbooks Details in playbooks go out of date at the same rate as production environment changes. For daily releases, playbooks might need an update on any given day. Writ‐ ing good documentation, like any form of communication, is hard. So how do you maintain playbooks?\n\nSome SREs at Google advocate keeping playbook entries general so they change slowly. For example, they may have just one entry for all “RPC Errors High” alerts, for a trained on-call engineer to read, in conjunction with an architecture diagram for the currently alerting service. Other SREs advocate for step-by-step playbooks to reduce human variability and drive down MTTR. If your team has conflicting views about playbook content, the playbooks might get pulled in many directions.\n\nThis is a contentious topic. If you agree on nothing else, at least decide with your team what minimal, structured details your playbooks must have, and try to notice when your playbooks have accumulated a lot of information beyond these structured details. Pencil in a project to turn new, hard-won, production knowledge into auto‐ mation or monitoring consoles. If your playbooks are a deterministic list of com‐ mands that the on-call engineer runs every time a particular alert fires, we recommend implementing automation.\n\nAfter two months, Sara, Mike, and the SRE transfer shadowed the on-call shifts of the outgoing Kirkland SRE team. At three months, they became the primary on-call, with the Kirkland SREs as backup. That way, they could easily escalate to the Kirkland SREs if needed. Next, the Nooglers shadowed the more experienced, local SREs and joined the rotation.\n\nGood documentation and the various strategies discussed earlier all helped the team form a solid foundation and ramp up quickly. Although on-call can be stressful, the teams’ confidence grew enough to take action without second-guessing themselves. There was psychological safety in knowing that their responses were based on the team’s collective knowledge, and that even when they escalated, the on-call engineers were still regarded as competent engineers.\n\nAfterword\n\nWhile the Mountain View SREs were ramping up, they learned that their experi‐ enced, sister SRE team in London would be moving on to a new project, and a new team was being formed in Zürich to support the services previously supported by the\n\n152\n\n|\n\nChapter 8: On-Call",
      "content_length": 2622,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 185,
      "content": "London SRE team. For this second transition, the same basic approach the Mountain View SREs used proved successful. The previous investment by Mountain View SREs in developing onboarding and training materials helped the new Zürich SRE team ramp up.\n\nWhile the approach used by the Mountain View SREs made sense when a cohort of SREs were becoming a team, they needed a more lightweight approach when only one person joined the team at a given time. In anticipation of future turnover, the SREs created service architecture diagrams and formalized the basic training check‐ list into a series of exercises that could be completed semi-independently with mini‐ mal involvement from a mentor. These exercises included describing the storage layer, performing capacity increases, and reviewing how HTTP requests are routed.\n\nEvernote: Finding Our Feet in the Cloud\n\nMoving our on-prem infrastructure to the cloud\n\nWe didn’t set out to reengineer our on-call process, but as with many things in life, necessity is the mother of invention. Prior to December 2016, Evernote ran only on on-prem datacenters, built to support our monolithic application. Our network and servers were designed with a specific architecture and data flow in mind. This, com‐ bined with a host of other constraints, meant we lacked the flexibility needed to sup‐ port a horizontal architecture. Google Cloud Platform (GCP) provided a concrete solution to our problem. However, we still had one major hurdle to surmount: migrating all our production and supporting infrastructure to GCP. Fast-forward 70 days. Through a Herculean effort and many remarkable feats (for example, moving thousands of servers and 3.5 PB of data), we were happily settled in our new home. At this point, though, our job still wasn’t done: how were we going to monitor, alert, and—most importantly—respond to issues in our new environment?\n\nAdjusting our on-call policies and processes\n\nThe move to the cloud unleashed the potential for our infrastructure to grow rapidly, but our on-call policies and processes were not yet set up to handle such growth. Once the migration wrapped up, we set out to remedy the problem. In our previous physical datacenter, we built redundancy into nearly every component. This meant that while component failure was common given our size, generally no individual component was capable of negatively impacting users. The infrastructure was very stable because we controlled it—any small bump would inevitably be due to a failure somewhere in the system. Our alerting policies were structured with that in mind: a few dropped packets, resulting in a JDBC (Java Database Connectivity) connection exception, invariably meant that a VM (virtual machine) host was on the verge of failing, or that the control plane on one of our switches was on the fritz. Even before our first day in the cloud, we realized that this type of alert/response system was not\n\nExample On-Call Setups Within Google and Outside Google\n\n|\n\n153",
      "content_length": 2995,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 186,
      "content": "tenable going forward. In a world of live migrations and network latency, we needed to take a much more holistic approach to monitoring.\n\nReframing paging events in terms of first principles, and writing these principles down as our explicit SLOs (service level objectives), helped give the team clarity regarding what was important to alert on and allowed us to trim the fat from our monitoring infrastructure. Our focus on higher-level indicators such as API respon‐ siveness, rather than lower-level infrastructure such as InnoDB row lock waits in MySQL, meant we could focus more time on the real pain our users experience dur‐ ing an outage. For our team, this meant less time spent chasing transient problems. This translated into more sleep, effectiveness, and ultimately, job satisfaction.\n\nRestructuring our monitoring and metrics\n\nOur primary on-call rotation is staffed by a small but scrappy team of engineers who are responsible for our production infrastructure and a handful of other business sys‐ tems (for example, staging and build pipeline infrastructure). We have a weekly, 24/7 schedule with a well-oiled handoff procedure, alongside a morning review of inci‐ dents at a daily stand-up. Our small team size and comparatively large scope of responsibility necessitates that we make every effort to keep the process burden light, and focus on closing the alert/triage/remediation/analysis loop as quickly as possible. One of the ways we achieve this is to keep our signal-to-noise ratio low by maintain‐ ing simple but effective alerting SLAs (service level agreements). We classify any event generated by our metrics or monitoring infrastructure into three categories:\n\nP1: Deal with immediately\n\nShould be immediately actionable\n\nPages the on-call\n\nLeads to event triage\n\nIs SLO-impacting\n\nP2: Deal with the next business day\n\nGenerally is not customer-facing, or is very limited in scope\n\nSends an email to team and notifies event stream channel\n\nP3: Event is informational only\n\nInformation is gathered in dashboards, passive email, and the like\n\nIncludes capacity planning–related information\n\n154\n\n|\n\nChapter 8: On-Call",
      "content_length": 2144,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 187,
      "content": "Any P1 or P2 event has an incident ticket attached to it. The ticket is used for obvious tasks like event triage and tracking remediation actions, as well as for SLO impact, number of occurrences, and postmortem doc links, where applicable.\n\nWhen an event pages (category P1), the on-call is tasked with assessing the impact to users. Incidents are triaged into severities from 1 to 3. For severity 1 (Sev 1) incidents, we maintain a finite set of criteria to make the escalation decision as straightforward as possible for the responder. Once the event is escalated, we assemble an incident team and begin our incident management process. The incident manager is paged, a scribe and communications lead is elected, and our communication channels open. After the incident is resolved, we conduct an automatic postmortem and share the results far and wide within the company. For events rating Sev 2 or Sev 3, the on-call responder handles the incident lifecycle, including an abbreviated postmortem for incident review.\n\nOne of the benefits of keeping our process lightweight is that we can explicitly free the on-call from any expectations of project work. This empowers and encourages the on-call to take immediate follow-up action, and also to identify any major gaps in tooling or process after completing the post-incident review. In this way, we achieve a constant cycle of improvement and flexibility during every on-call shift, keeping pace with the rapid rate of change in our environment. The goal is to make every on-call shift better than the last.\n\nTracking our performance over time\n\nWith the introduction of SLOs, we wanted to track performance over time, and share that information with stakeholders within the company. We implemented a monthly service review meeting, open to anyone who’s interested, to review and discuss the previous month of the service. We have also used this forum to review our on-call burden as a barometer of team health, and discuss remediation actions when we exceed our pager budget. This forum has the dual purpose of spreading the impor‐ tance of SLOs within the company and keeping the technical organization accounta‐ ble for maintaining the health and wellness of our service and team.\n\nEngaging with CRE\n\nExpressing our objectives in terms of SLOs provides a basis for engaging with Goo‐ gle’s Customer Reliability Engineering (CRE) team. After we discussed our SLOs with CRE to see if they were realistic and measurable, both teams decided CRE would be paged alongside our own engineers for SLO-impacting events. It can be difficult to pinpoint root causes that are hidden behind layers of cloud abstraction, so having a Googler at our side take the guesswork out of black-box event triaging was helpful. More importantly, this exercise further reduced our MTTR, which is ultimately what our users care about.\n\nExample On-Call Setups Within Google and Outside Google\n\n|\n\n155",
      "content_length": 2926,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 188,
      "content": "Sustaining a self-perpetuating cycle\n\nRather than spending all our time in the triage/root-cause analysis/postmortem cycle, we now have more time as a team to think about how we move the business forward. Specifically, this translates into projects such as improving our microservices plat‐ form and establishing production readiness criteria for our product development teams. The latter includes many of the principles we followed in restructuring our on-call, which is particularly helpful for teams in their first “carry the pager” rodeo. Thus, we perpetuate the cycle of improving on-call for everyone.\n\nPractical Implementation Details So far, we’ve discussed details about on-call setups, both within Google and outside of Google. But what about specific considerations of being on-call? The following sections discuss these implementation details in more depth:\n\nPager load—what it is, how it works, and how to manage it\n\nHow to factor flexibility into on-call scheduling to create a healthier work/life balance for SREs\n\nStrategies for improving team dynamics, both within a given SRE team, and with partner teams\n\nAnatomy of Pager Load Your pager is noisy and it’s making your team unhappy. You’ve read through Chap‐ ter 31 in Site Reliability Engineering, and run regular production meetings, both with your team and the developer teams you support. Now everyone knows that your on- call engineers are unhappy. What next?\n\nPager load is the number of paging incidents that an on-call engineer receives over a typical shift length (such as per day or per week). An incident may involve more than one page. Here, we’ll walk through the impact of various factors on pager load, and suggest techniques for minimizing future pager load.\n\nAppropriate Response Times Engineers shouldn’t have to be at a computer and working on a problem within minutes of receiving a page unless there is a very good reason to do so. While a com‐ plete outage of a customer-facing, revenue-generating service typically requires an immediate response, you can deal with less severe issues (for example, failing back‐ ups) within a few hours.\n\n156\n\n|\n\nChapter 8: On-Call",
      "content_length": 2155,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 189,
      "content": "We recommend checking your current paging setup to see if you actually should be paged for everything that currently triggers a page. You may be paging for issues that would be better served by automated repair (as it’s generally better for a computer to fix a problem than requiring a human to fix it) or a ticket (if it’s not actually high priority). Table 8-1 shows some sample events and appropriate responses.\n\nTable 8-1. Examples of realistic response times\n\nIncident description Revenue-impacting network outage\n\nCustomer order batch processing system stuck Backups of a database for a pre- launch service are failing\n\nResponse time 5 minutes\n\n30 minutes\n\nTicket (response during work hours)\n\nSRE impact SRE needs to be within arm’s reach of a charged and authenticated laptop with network access at all times; cannot travel; must heavily coordinate with secondary at all times SRE can leave their home for a quick errand or short commute; secondary does not need to provide coverage during this time None\n\nScenario: A team in overload\n\nThe (hypothetical) Connection SRE Team, responsible for frontend load balancing and terminating end-user connections, found itself in a position of high pager load. They had an established pager budget of two paging incidents per shift, but for the past year they had regularly been receiving five paging incidents per shift. Analysis revealed that fully one-third of shifts were exceeding their pager budget. Members of the team heroically responded to the daily onslaught of pages but couldn’t keep up; there simply was not enough time in the day to find the root cause and properly fix the incoming issues. Some engineers left the team to join less operationally burdened teams. High-quality incident follow-up was rare, since on-call engineers only had time to mitigate immediate problems.\n\nThe team’s horizon wasn’t entirely bleak: they had a mature monitoring infrastruc‐ ture that followed SRE best practices. Alerting thresholds were set to align with their SLO, and paging alerts were symptom-based in nature, meaning they fired only when customers were impacted. When senior management were approached with all of this information, they agreed that the team was in operational overload and reviewed the project plan to bring the team back to a healthy state.\n\nIn less positive news, over time the Connection team had taken ownership of soft‐ ware components from more than 10 developer teams and had hard dependencies on Google’s customer-facing edge and backbone networks. The large number of inter‐ group relationships was complex and had quietly grown difficult to manage.\n\nDespite the team following best practices in structuring their monitoring, many of the pages that they faced were outside their direct control. For example, a black-box probe may have failed due to congestion in the network, causing packet loss. The\n\nPractical Implementation Details\n\n|\n\n157",
      "content_length": 2922,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 190,
      "content": "only action the team could take to mitigate congestion in the backbone was to esca‐ late to the team directly responsible for that network.\n\nOn top of their operational burden, the team needed to deliver new features to the frontend systems, which would be used by all Google services. To make matters worse, their infrastructure was being migrated from a 10-year-old legacy framework and cluster management system to a better-supported replacement. The team’s serv‐ ices were subject to an unprecedented rate of change, and the changes themselves caused a significant portion of the on-call load.\n\nThe team clearly needed to combat this excessive pager load using a variety of techni‐ ques. The technical program manager and the people manager of the team approached senior management with a project proposal, which senior management reviewed and approved. The team turned their full attention to reducing their pager load, and learned some valuable lessons along the way.\n\nPager load inputs\n\nThe first step in tackling high pager load is to determine what is causing it. Pager load is influenced by three main factors: bugs5 in production, alerting, and human pro‐ cesses. Each of these factors has several inputs, some of which we discuss in more detail in this section.\n\nFor production:\n\nThe number of existing bugs in production\n\nThe introduction of new bugs into production\n\nThe speed with which newly introduced bugs are identified\n\nThe speed with which bugs are mitigated and removed from production\n\nFor alerting:\n\nThe alerting thresholds that trigger a paging alert\n\nThe introduction of new paging alerts\n\nThe alignment of a service’s SLO with the SLOs of the services upon which it depends\n\n5 A “bug” in this context is any undesirable system behavior resulting from software or configuration error.\n\nLogic errors in code, incorrect configuration of a binary, incorrect capacity planning, misconfigured load bal‐ ancers, or newly discovered vulnerabilities are all valid examples of “production bugs” that contribute to pager load.\n\n158\n\n|\n\nChapter 8: On-Call",
      "content_length": 2070,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 191,
      "content": "For human processes:\n\nThe rigor of fixes and follow-up on bugs\n\nThe quality of data collected about paging alerts\n\nThe attention paid to pager load trends\n\nHuman-actuated changes to production\n\nPreexisting bugs. No system is perfect. There will always be bugs in production: in your own code, the software and libraries that you build upon, or the interfaces between them. The bugs may not be causing paging alerts right now, but they are def‐ initely present. You can use a few techniques to identify or prevent bugs that haven’t yet caused paging alerts:\n\nEnsure systems are as complicated as they need to be, and no more (see Chap‐ ter 7).\n\nRegularly update the software or libraries that your system is built upon to take advantage of bug fixes (however, see the next section about new bugs).\n\nPerform regular destructive testing or fuzzing (for example, using Netflix’s Chaos Monkey).\n\nPerform regular load testing in addition to integration and unit testing.\n\nNew bugs. Ideally, the SRE team and its partner developer teams should detect new bugs before they even make it into production. In reality, automated testing misses many bugs, which are then launched to production.\n\nSoftware testing is a large topic well covered elsewhere (e.g., Martin Fowler on Test‐ ing). However, software testing techniques are particularly useful in reducing the number of bugs that reach production, and the amount of time they remain in pro‐ duction:\n\nImprove testing over time. In particular, for each bug you discover in produc‐ tion, ask “How could we have detected this bug preproduction?” Make sure the necessary engineering follow-up occurs (see “Rigor of follow-up” on page 164).\n\nDon’t ignore load testing, which is often treated as lower priority than functional testing. Many bugs manifest only under particular load conditions or with a par‐ ticular mix of requests.\n\nRun staging (testing with production-like but synthetic traffic) in a production- like environment. We briefly discuss generating synthetic traffic in Chapter 5 of this book.\n\nPerform canarying (Chapter 16) in a production environment.\n\nPractical Implementation Details\n\n|\n\n159",
      "content_length": 2148,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 192,
      "content": "Have a low tolerance to new bugs. Follow a “detect, roll back, fix, and roll for‐ ward” strategy rather than a “detect, continue to roll forward despite identifying the bug, fix, and roll forward again” strategy. (See “Mitigation delay” on page 162 for more details.)\n\nThis kind of rollback strategy requires predictable and frequent releases so that the cost of rolling back any one release is small. We discuss this and related topics in Site Reliability Engineering, in “Release Engineering”.\n\nSome bugs may manifest only as the result of changing client behavior. For example:\n\nBugs that manifest only under specific levels of load—for example, September back-to-school traffic, Black Friday, Cyber Monday, or that week of the year when Daylight Saving Time means Europe and North America are one hour closer, meaning more of your users are awake and online simultaneously.\n\nBugs that manifest only with a particular mix of requests—for example, servers closer to Asia experiencing a more expensive traffic mix due to language encod‐ ings for Asian character sets.\n\nBugs that manifest only when users exercise the system in unexpected ways—for example, Calendar being used by an airline reservation system! Therefore, it is important to expand your testing regimen to test behaviors that do not occur every day.\n\nWhen a production system is plagued by several concurrent bugs, it’s much more dif‐ ficult to identify if a given page is for an existing or new bug. Minimizing the number of bugs in production not only reduces pager load, it also makes identifying and clas‐ sifying new bugs easier. Therefore, it is critical to remove production bugs from your systems as quickly as possible. Prioritize fixing existing bugs above delivering new features; if this requires cross-team collaboration, see Chapter 18.\n\nArchitectural or procedural problems, such as automated health checking, self- healing, and load shedding, may need significant engineering work to resolve. Remember, for simplicity’s sake we’ll consider these problems “bugs,” even if their size, their complexity, or the effort required to resolve them is significant.\n\nChapter 3 of Site Reliability Engineering describes how error budgets are a useful way to manage the rate at which new bugs are released to production. For example, when a service’s SLO violations exceed a certain fraction of its total quarterly error budget —typically agreed in advance between the developer and SRE teams—new feature development and feature-related rollouts can be halted temporarily to focus on stabi‐ lizing the system and reducing the frequency of pages.\n\nThe Connection team from our example adopted a strict policy requiring every out‐ age to have a tracking bug. This enabled the team’s technical program manager to\n\n160\n\n|\n\nChapter 8: On-Call",
      "content_length": 2807,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 193,
      "content": "examine the root cause of their new bugs in aggregate. This data revealed that human error was the second most common cause of new bugs in production.\n\nBecause humans are error-prone, it’s better if all changes made to production systems are made by automation informed by (human-developed) intent configuration. Before you make a change to production, automation can perform additional testing that humans cannot. The Connection team was making complex changes to produc‐ tion semimanually. Not surprisingly, the team’s manual changes went wrong some‐ times; the team introduced new bugs, which caused pages. Automated systems making the same changes would have determined that the changes were not safe before they entered production and became paging events. The technical program manager took this data to the team and convinced them to prioritize automation projects.\n\nIdentification delay. It’s important to promptly identify the cause(s) of alerts because the longer it takes to identify the root cause of a page, the more opportunity it has to recur and page again. For example, given a page that manifests only under high load, say at daily peak, if the problematic code or configuration is not identified before the next daily peak, it is likely that the problem will happen again. There are several tech‐ niques you might use to reduce identification delays:\n\nUse good alerts and consoles\n\nEnsure pages link to relevant monitoring consoles, and that consoles highlight where the system is operating out of specification. In the console, correlate black- box and white-box paging alerts together, and do the same with their associated graphs. Make sure playbooks are up to date with advice on responding to each type of alert. On-call engineers should update the playbook with fresh informa‐ tion when the corresponding page fires.\n\nPractice emergency response\n\nRun “Wheel of Misfortune” exercises (described in Site Reliability Engineering) to share general and service-specific debugging techniques with your colleagues.\n\nPerform small releases\n\nIf you perform frequent, smaller releases instead of infrequent monolithic changes, correlating bugs with the corresponding change that introduced them is easier. Canarying releases, described in Chapter 16 gives a strong signal about whether a new bug is due to a new release.\n\nLog changes\n\nAggregating change information into a searchable timeline makes it simpler (and hopefully quicker) to correlate new bugs with the corresponding change that introduced them. Tools like the Slack plug-in for Jenkins can be helpful.\n\nPractical Implementation Details\n\n|\n\n161",
      "content_length": 2621,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 194,
      "content": "Ask for help\n\nIn Site Reliability Engineering, “Managing Incidents”, we talked about working together to manage large outages. The on-call engineer is never alone; encourage your team to feel safe when asking for help.\n\nMitigation delay. The longer it takes to mitigate a bug once it’s identified, the more opportunity it has to recur and page again. Consider these techniques for reducing mitigation delays:\n\nRoll back changes\n\nIf the bug was introduced in a recent code or configuration rollout, promptly remove the bug from production with a rollback, if safe and appropriate (a roll‐ back alone may be necessary but is not sufficient if the bug caused data corrup‐ tion, for example). Remember that even a “quick fix” needs time to be tested, built, and rolled out. Testing is vital to making sure the quick fix actually fixes the bug, and that it doesn’t introduce additional bugs or other unintended conse‐ quences. Generally, it is better to “roll back, fix, and roll forward” rather than “roll forward, fix, and roll forward again.”\n\nIf you aim for 99.99% availability, you have approximately 15 minutes of error budget per quarter. The build step of rolling forward may take much longer than 15 minutes, so rolling back impacts your users much less. (99.999% availability affords an error budget of 80 seconds per quarter. At this point, systems may need self-healing properties, which is out of scope for this chapter.)\n\nIf at all possible, avoid changes that can’t be rolled back, such as API- incompatible changes and lockstep releases.\n\nUse feature isolation\n\nDesign your system so that if feature X goes wrong, you can disable it via, for example, a feature flag without affecting feature Y. This strategy also improves release velocity, and makes disabling feature X a much simpler decision—you don’t need to check that your product managers are comfortable with also disa‐ bling feature Y.\n\nDrain requests away\n\nDrain requests (i.e., redirect customer requests) away from the elements of your system that exhibit the bug. For example, if the bug is the result of a code or con‐ fig rollout, and you roll out to production gradually, you may have the opportu‐ nity to drain the elements of your infrastructure that have received the update. This allows you to mitigate the customer impact in seconds, rather than rolling back, which may take minutes or longer.\n\n162\n\n|\n\nChapter 8: On-Call",
      "content_length": 2403,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 195,
      "content": "Alerting. Google SRE’s maximum of two distinct incidents per 12-hour shift encour‐ ages us to be thoughtful and cautious about how we configure paging alerts and how we introduce new ones. Site Reliability Engineering, “Monitoring Distributed Sys‐ tems”, describes Google’s approach to defining the thresholds for paging alerts. Strictly observing these guidelines is critical to maintaining a healthy on-call rotation.\n\nIt is worth highlighting some key elements discussed in that chapter:\n\nAll alerts should be immediately actionable. There should be an action we expect a human to take immediately after they receive the page that the system is unable to take itself. The signal-to-noise ratio should be high to ensure few false posi‐ tives; a low signal-to-noise ratio raises the risk for on-call engineers to develop alert fatigue.\n\nIf a team fully subscribes to SLO-based alerting, or paging only when error budget is burned (see the section “Black-Box Versus White-Box” in Site Reliabil‐ ity Engineering), it is critical that all teams involved in developing and maintain‐ ing the service agree about the importance of meeting the SLO and prioritize their work accordingly.\n\nIf a team fully subscribes to SLO-based and symptom-based alerting, relaxing alert thresholds is rarely an appropriate response to being paged.\n\nJust like new code, new alerts should be thoroughly and thoughtfully reviewed. Each alert should have a corresponding playbook entry.\n\nReceiving a page creates a negative psychological impact. To minimize that impact, only introduce new paging alerts when you really need them. Anyone on the team can write a new alert, but the whole team reviews proposed alert additions and can suggest alternatives. Thoroughly test new alerts in production to vet false positives before they are upgraded to paging alerts. For example, you might email the alert’s author when the alert fires, rather than paging the on-call engineer.\n\nNew alerts may find problems in production that you weren’t aware of. After you address these production bugs, alerting will only page on new bugs, effectively func‐ tioning like regression tests.\n\nBe sure to run the new alerts in test mode long enough to experience typical periodic production conditions, such as regular software rollouts, maintenance events by your Cloud provider, weekly load peaks, and so on. A week of testing is probably about right. However, this appropriate window depends on the alert and the system.\n\nFinally, use the alert’s trigger rate during the testing period to predict the expected consumption of your pager budget as a result of the new alert. Explicitly approve or disallow the new alert as a team. If introducing a new paging alert causes your service to exceed its paging budget, the stability of the system needs additional attention.\n\nPractical Implementation Details\n\n|\n\n163",
      "content_length": 2864,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 196,
      "content": "Rigor of follow-up. Aim to identify the root cause of every page. “Root causes” extend out of the machine and into the team’s processes. Was an outage caused by a bug that would have been caught by a unit test? The root cause might not be a bug in the code, but rather a bug in the team’s processes around code review.\n\nIf you know the root cause, you can fix and prevent it from ever bothering you or your colleagues again. If your team cannot figure out the root cause, add monitoring and/or logging that will help you find the root cause of the page the next time it occurs. If you don’t have enough information to identify the bug, you can always do something to help debug the page further next time. You should rarely conclude that a page is triggered by “cause unknown.” Remember that as an on-call engineer, you are never alone, so ask a colleague to review your findings and see if there’s anything you missed. Typically, it’s easiest to find the root cause of an alert soon after the alert has triggered and fresh evidence is available.\n\nExplaining away a page as “transient,” or taking no action because the system “fixed itself” or the bug inexplicably “went away,” invites the bug to happen again and cause another page, which causes trouble for the next on-call engineer.\n\nSimply fixing the immediate bug (or making a “point” fix) misses a golden opportu‐ nity to prevent similar alerts in the future. Use the paging alert as an chance to sur‐ face engineering work that improves the system and obviates an entire class of possible future bugs. Do this by filing a project bug in your team’s production com‐ ponent, and advocate to prioritize its implementation by gathering data about how many individual bugs and pages this project would remove. If your proposal will take 3 working weeks or 120 working hours to implement, and a page costs on average 4 working hours to properly handle, there’s a clear break-even point after 30 pages.\n\nFor example, imagine a situation where there are too many servers on the same fail‐ ure domain, such as a switch in a datacenter, causing regular multiple simultaneous failures:\n\nPoint fix\n\nRebalance your current footprint across more failure domains and stop there.\n\nSystemic fix\n\nUse automation to ensure that this type of server, and all other similar servers, are always spread across sufficient failure domains, and that they rebalance auto‐ matically when necessary.\n\nMonitoring (or prevention) fix\n\nAlert preemptively when the failure domain diversity is below the expected level, but not yet service-impacting. Ideally, the alert would be a ticket alert, not a page, since it doesn’t require an immediate response. The system is still serving hap‐ pily, albeit at a lower level of redundancy.\n\n164\n\n|\n\nChapter 8: On-Call",
      "content_length": 2782,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 197,
      "content": "To make sure you’re thorough in your follow-up to paging alerts, consider the fol‐ lowing questions:\n\nHow can I prevent this specific bug from happening again?\n\nHow can I prevent bugs like this from happening again, both for this system and other systems I’m responsible for?\n\nWhat tests could have prevented this bug from being released to production?\n\nWhat ticket alerts could have triggered action to prevent the bug from becoming critical before it paged?\n\nWhat informational alerts could have surfaced the bug on a console before it became critical?\n\nHave I maximized the impact of the fixes I’m making?\n\nOf course, it’s not enough for an on-call engineer to just file bugs related to the pages that occur on their shift. It’s incredibly important that bugs identified by the SRE team are dealt with swiftly, to reduce the possibility of them recurring. Make sure resource planning for both the SRE and developer teams consider the effort required to respond to bugs.\n\nWe recommend reserving a fraction of SRE and developer team time for responding to production bugs as they arise. For example, a Google on-caller typically doesn’t work on projects during their on-call shift. Instead, they work on bugs that improve the health of the system. Make sure that your team routinely prioritizes production bugs above other project work. SRE managers and tech leads should make sure that production bugs are promptly dealt with, and escalate to the developer team decision makers when necessary.\n\nWhen a paging event is serious enough to warrant a postmortem, it’s even more important to follow this methodology to catalog and track follow-up action items. (See Chapter 10 for more details.)\n\nData quality. Once you identify bugs in your system that caused pages, a number of questions naturally arise:\n\nHow do you know which bug to fix first?\n\nHow do you know which component in your system caused most of your pages?\n\nHow do you determine what repetitive, manual action on-call engineers are tak‐ ing to resolve the pages?\n\nHow do you tell how many alerts with unidentified root causes remain?\n\nHow do you tell which bugs are truly, not just anecdotally, the worst?\n\nPractical Implementation Details\n\n|\n\n165",
      "content_length": 2209,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 198,
      "content": "The answer is simple: collect data!\n\nWhen building up your data collection processes, you might track and monitor the patterns in on-call load, but this effort doesn’t scale. It’s far more sustainable to file a placeholder bug for each paging alert in your bug tracking system (e.g., Jira, Issue‐ Tracker), and for the on-call engineer to create a link between the paging alerts from your monitoring system and the relevant bug in the bug tracking system, as and when they realize that each alert is symptomatic of a preexisting issue. You will end up with a list of as-yet-not-understood bugs in one column, and a list of all of the pages that each bug is believed to have caused in the next.\n\nOnce you have structured data about the causes of the pages, you can begin to ana‐ lyze that data and produce reports. Those reports can answer questions such as:\n\nWhich bugs cause the most pages? Ideally we’d roll back and fix bugs immedi‐ ately, but sometimes, finding the root cause and deploying the fix takes a long time, and sometimes silencing key alerts isn’t a reasonable option. For example, the aforementioned Connection SRE Team might experience ongoing network congestion that isn’t immediately resolvable but still needs to be tracked. Collect‐ ing data on which production issues are causing the most pages and stress to the team supports data-driven conversations about prioritizing your engineering effort systematically.\n\nWhich component of the system is the cause of most pages (payments gateway, authentication microservice, etc.)?\n\nWhen correlated with your other monitoring data, do particular pages corre‐ spond to other signals (peaks in request rate, number of concurrent customer sessions, number of signups, number of withdrawals, etc.)?\n\nTying structured data to bugs and the root causes of your pages has other benefits:\n\nYou can automatically populate a list of existing bugs (that is, known issues), which may be useful for your support team.\n\nYou can automatically prioritize fixing bugs based on the number of pages each bug causes.\n\nThe quality of the data you collect will determine the quality of the decisions either humans or automata can make. To ensure high-quality data, consider the following techniques:\n\nDefine and document your team’s policy and expectations on data collection for pages.\n\n166\n\n|\n\nChapter 8: On-Call",
      "content_length": 2356,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 199,
      "content": "Set up nonpaging alerts from the monitoring system to highlight where pages were not handled according to those expectations. Managers and tech leads should make sure that the expectations are met.\n\nTeammates should follow up with each other when handoffs don’t adhere to expectations. Positive comments such as, “Maybe this could be related to bug 123,” “I’ve filed a bug with your findings so we can follow up in more detail,” or “This looks a lot like what happened on my shift last Wednesday: <link to page, bug>” powerfully reinforce the expected behaviors and ensure that you maximize opportunities for improvement. No one wants to be paged for the same issue that paged their teammate in the previous shift.\n\nVigilance. All too often, teams fall into operational overload by a thousand cuts. To avoid boiling the frog, it is important to pay attention to the health of on-call engi‐ neers over time, and ensure that production health is consistently and continuously prioritized by both SRE and developer teams.\n\nThe following techniques can help a team keep a watchful eye on pager load:\n\nAt production meetings (see the section “Communications: Production Meet‐ ings” in Site Reliability Engineering, Chapter 31), regularly talk about trends in pager load based on the structured data collected. We’ve found a 21-day trailing average to be useful.\n\nSet up ticket alerts, possibly targeted at tech leads or managers, for when pager load crosses a “warning” threshold that your team agrees on beforehand.\n\nHold regular meetings between the SRE team and developer team to discuss the current state of production and the outstanding production bugs that are paging SRE.\n\nOn-Call Flexibility\n\nShift Length An on-call rotation that has to handle one or more pages per day must be structured in a sustainable way: we recommend limiting shift lengths to 12 hours. Shorter shifts are better for the mental health of your engineers. Team members run the risk of exhaustion when shifts run long, and when people are tired, they make mistakes. Most humans simply can’t produce high-quality work if they’re on-call continuously. Many countries have laws about maximum working hours, breaks, and working con‐ ditions.\n\nPractical Implementation Details\n\n|\n\n167",
      "content_length": 2254,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 200,
      "content": "While spreading on-call shifts across a team’s daylight hours is ideal, a 12-hour shift system doesn’t necessitate a globally distributed team. Being on-call overnight for 12 hours is preferable to being on-call for 24 hours or more. You can make 12-hour shifts work even in a single location. For example, instead of asking a single engineer to be on-call for 24 hours a day across an entire week-long shift, it would be better for two engineers to split a week of on-call, with one person on-call during the day and one on-call overnight.\n\nIn our experience, 24 hours of on-call duty without reprieve isn’t a sustainable setup. While not ideal, occasional overnight 12-hour shifts at least ensure breaks for your engineers. Another option is to shorten shifts to last less than a week—something like 3 days on, 4 days off.\n\nScenario: A change in personal circumstances\n\nImagine you are a member of an on-call team for a large service that has a 24/7 follow-the-sun model split across two sites. The arrangement works well for you. While you’re not thrilled about the possibility of a 6 a.m. page, you are happy with the work you and the team are doing to keep the operational load manageable while improving the reliability of the service.\n\nAll is well…until one day you realize that the on-call schedule and the demands of your personal life are starting to clash. There are many potential reasons why—for example, becoming a parent, needing to travel on short notice and take a leave from work, or illness.\n\nYou need your on-call duties to coexist with your new personal schedule.\n\nMany teams and organizations face this challenge as they mature. People’s needs change over time, and maintaining a healthy balance of diverse teammate back‐ grounds leads to an on-call rotation characterized by diverse needs. The key to keep‐ ing a healthy, fair, and equitable balance of on-call work and personal life is flexibility.\n\nThere are a number of ways that you can apply flexibility to on-call rotations to meet the needs of team members while still ensuring coverage for your services or prod‐ ucts. It is impossible to write down a comprehensive, one-size-fits-all set of guide‐ lines. We encourage embracing flexibility as a principle rather than simply adopting the examples listed here.\n\nAutomate on-call scheduling. As teams grow, accounting for scheduling constraints— vacation plans, distribution of on-call weekdays versus weekends, individual prefer‐ ences, religious requirements, and so on—becomes increasingly difficult. You can’t manage this task manually; it’s hard to find any solution at all, much less a fair one.\n\n168\n\n|\n\nChapter 8: On-Call",
      "content_length": 2658,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 201,
      "content": "“Fairness” doesn’t mean a completely uniform distribution of each type of shift across team members. Different people have different needs and different preferen‐ ces. Therefore, it’s important for the team to share those preferences and try to meet them in an intelligent way. Team composition and preferences dictate whether your team prefers a uniform distribution, or a more customized way of meeting schedul‐ ing preferences.\n\nUsing an automated tool to schedule on-call shifts makes this task much easier. This tool should have a few basic characteristics:\n\nIt should rearrange on-call shifts to accommodate the changing needs of team members.\n\nIt should automatically rebalance on-call load in response to any changes.\n\nIt should do its best to ensure fairness by factoring in personal preferences such as “no primary during weekends in April,” as well as historical information such as recent on-call load per engineer.\n\nSo that on-call engineers can plan around their on-call shifts, it must never change an already generated schedule.\n\nSchedule generation can be either fully automated or scheduled by a human. Like‐ wise, some teams prefer to have members explicitly sign off on the schedule, while others are comfortable with a fully automated process. You might opt to develop your own tool in-house if your needs are complex, but there are a number of commercial and open source software packages that can aid in automating on-call scheduling.\n\nPlan for short-term swaps. Requests for short-term changes in the on-call schedule happen frequently. No one can promise on Monday that they won’t have the flu on Thursday. Or you might need to run an unforeseen urgent errand in the middle of your on-call shift.\n\nYou may also want to facilitate on-call swaps for nonurgent reasons—for example, to allow on-callers to attend sports training sessions. In this situation, team members can swap a subset of the on-call day (for example, half of Sunday). Nonurgent swaps are typically best-effort.\n\nTeams with a strict pager response SLO need to take commute coverage into account. If your pager response SLO is 5 minutes, and your commute is 30 minutes, you need to make sure that someone else can respond to emergencies while you get to work.\n\nTo achieve these goals in flexibility, we recommend giving team members the ability to update the on-call rotation. Also, have a documented policy in place describing how swaps should work. Decentralization options range from a fully centralized pol‐ icy, where only the manager can change the schedule, to a fully decentralized one,\n\nPractical Implementation Details\n\n|\n\n169",
      "content_length": 2626,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 202,
      "content": "where any team member can change the policy independently. In our experience, instituting peer review of changes provides a good tradeoff between safety and flexibility.\n\nPlan for long-term breaks. Sometimes team members need to stop serving in the on- call rotation because of changes in personal circumstances or burnout. It’s important that teams are structured to allow on-callers to temporarily leave the rotation.\n\nIdeally, team size should allow for a (temporary) staff reduction without causing the rest of the team to suffer too much operational load. In our experience, you need a bare minimum of five people per site to sustain on-call in a multisite, 24/7 configura‐ tion, and eight people in a single-site, 24/7 configuration. Therefore, it is safe to assume each site will need one extra engineer as protection against staff reduction, bringing the minimum staffing to six engineers per site (multisite) or nine per site (single-site).\n\nPlan for part-time work schedules. Being on-call with part-time working schedules may seem incompatible, but we’ve found that on-call and part-time work arrangements are compatible if you take certain precautions. The following discussion assumes that if a member of your on-call rotation works part-time, they’ll be unavailable for on- call shifts outside of their part-time working week.\n\nThere are two main models of part-time working:\n\nWorking a reduced amount of full days per week—for example, four 8-hour days a week, instead of five\n\nWorking a reduced amount of time each day—for example, 6 hours a day, instead of 8 hours a day\n\nBoth models are compatible with on-call work, but require different adjustments to on-call scheduling.\n\nThe first model easily coexists with on-call work, especially if the nonworking day(s) are constant over time. In response, you can adopt an on-call shift length of fewer than seven days a week (for example, Monday through Thursday, or Friday through Sunday) and configure the automated scheduler not to schedule the part-time engi‐ neer(s) to be on-call on the days they don’t work.\n\nThe second model is possible in a couple ways:\n\nSplit on-call hours with another engineer, so that no one is on-call when they are not supposed to be. For example, if an on-call engineer needs to work from 9 a.m. to 4 p.m., you can assign the first half of the shift (9 a.m. to 3 p.m.) to them. Rotate the second half (3 p.m. to 9 p.m.) within the team the same way you rotate other on-call shifts.\n\n170\n\n|\n\nChapter 8: On-Call",
      "content_length": 2504,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 203,
      "content": "The part-time engineer can work full hours on their on-call days, which may be feasible if the on-call shift is not too frequent.\n\nAs mentioned in Chapter 11 of Site Reliability Engineering, Google SRE compensates support outside of regular hours with a reduced hourly rate of pay or time off, according to local labor law and regulations. Take a part-time engineer’s reduced schedule into account when determining on-call compensation.\n\nIn order to maintain a proper balance between project time and on-call time, engi‐ neers working reduced hours should receive a proportionately smaller amount of on- call work. Larger teams absorb this additional on-call load more easily than smaller teams.\n\nOn-Call Team Dynamics Our first book touched upon how stress factors like high pager load and time pres‐ sure can force on-call engineers to adopt decision strategies based on intuition and heuristics rather than reason and data (see the section “Feeling Safe” in Chapter 11 of that book). Working from this discussion of team psychology, how do you go about building a team with positive dynamics? Consider an on-call team with the following set of hypothetical problems.\n\nScenario: A culture of “survive the week”\n\nA company begins with a couple of founders and a handful of employees, all feature developers. Everyone knows everyone else, and everyone takes pagers.\n\nThe company grows bigger. On-call duty is limited to a smaller set of more experi‐ enced feature developers who know the system better.\n\nThe company grows even bigger. They add an ops role to tackle reliability. This team is responsible for production health, and the job role is focused on operations, not coding. The on-call becomes a joint rotation between feature developers and ops. Feature developers have the final say in maintaining the service, and ops input is limited to operational tasks. By this time, there are 30 engineers in the on-call rota‐ tion: 25 feature developers and 5 ops, all located at the same site.\n\nThe team is plagued by high pager volume. Despite following the recommendations described earlier in this chapter to minimize pager load, the team is suffering from low morale. Because the feature developers prioritize developing new features, on-call follow-up takes a long time to implement.\n\nTo make matters worse, the feature developers are concerned about their own sub‐ system’s health. One feature developer insists on paging by error rate rather than error ratio for their mission-critical module, despite complaints from others on the team. These alerts are noisy, and return many false positives or unactionable pages.\n\nPractical Implementation Details\n\n|\n\n171",
      "content_length": 2666,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 204,
      "content": "Other members of the on-call rotation aren’t especially bothered by the high pager volume. Sure, there are a lot of pages, but most of them don’t take much time to resolve. As one on-call engineer puts it: “I take a quick look at the page subject and know they are duplicates. So I just ignore them.”\n\nSound familiar?\n\nSome Google teams experienced similar problems during their earlier days of matur‐ ity. If not handled carefully, these problems have the potential to tear the feature developer and ops teams apart and hinder on-call operation. There’s no silver bullet to solve these problems, but we found a couple of approaches particularly helpful. While your methodology may differ, your overall goal should be the same: build pos‐ itive team dynamics, and carefully avoid tailspin.\n\nProposal one: Empower your ops engineers. You can remodel the operations organiza‐ tion according to the guidelines outlined in this book and Site Reliability Engineering, perhaps even including a change of name (SRE, or similar) to indicate the change of role. Simply retitling your ops organization is not a panacea, but it can be helpful in communicating an actual change in responsibilities away from the old ops-centric model. Make it clear to the team and the entire company that SREs own the site oper‐ ation. This includes defining a shared roadmap for reliability, driving the full resolu‐ tion of issues, maintaining monitoring rules, and so on. Feature developers are necessary collaborators but don’t own these endeavors.\n\nTo return to our hypothetical team, this announcement ushered in the following operational changes:\n\nAction items are assigned only to the five DevOps engineers—who are now SREs. SREs work with subject experts—many of them feature developers—to accomplish these tasks. SREs take on the previously mentioned “error rate versus error ratio” debate by negotiating a change in alerting with the feature develop‐ ers.\n\nSREs are encouraged to dive into the code to make the changes themselves, if possible. They send code reviews to the subject experts. This has the benefit of building a sense of ownership among SREs, as well as upgrading their skills and authority for future occasions.\n\nWith this arrangement, feature developers are explicit collaborators on reliability fea‐ tures, and SREs are given the responsibility to own and improve the site.\n\nProposal two: Improve team relations. Another possible solution is to build stronger team bonds between team members. Google designates a “fun budget” specifically for organizing offsite activities to strengthen team bonds.\n\n172\n\n|\n\nChapter 8: On-Call",
      "content_length": 2626,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 205,
      "content": "We’ve found that more robust team relationships create a spirit of increased under‐ standing and collaboration among teammates. As a result, engineers are more likely to fix bugs, finish action items, and help out their colleagues. For example, say you turned off a nightly pipeline job, but forgot to turn off the monitoring that checked if the pipeline ran successfully. As a result, you accidentally page a colleague at 3 a.m. If you’ve spent a little time with that colleague, you’d feel much worse about what hap‐ pened, and strive to be considerate by being more careful in the future. The mentality of “I protect my colleagues” translates to a more productive work atmosphere.\n\nWe’ve also found that making all members of the on-call rotation sit together, regardless of job title and function area, helps improve team relations tremendously. Encourage teams to eat lunch with each other. Don’t underestimate the power of rel‐ atively straightforward changes like these. It plays directly into team dynamics.\n\nConclusion SRE on-call is different than traditional ops roles. Rather than focusing solely on day- to-day operations, SRE fully owns the production environment, and seeks to better it through defining appropriate reliability thresholds, developing automation, and undertaking strategic engineering projects. On-call is critical for site operations, and handling it right is crucial to the company’s bottom line.\n\nOn-call is a source of much tension, both individually and collectively. But if you’ve stared into the eyes of the monster long enough, there is wisdom to be found. This chapter illustrates some of the lessons about on-call that we learned the hard way; we hope that our experience can help others avoid or tackle similar issues.\n\nIf your on-call team is drowning in endless alerts, we recommend taking a step back to observe the situation from a higher level. Compare notes with other SRE and part‐ ner teams. Once you’ve gathered the necessary information, address the problems in a systematic way. Thoughtfully structuring on-call is time well spent for on-call engi‐ neers, on-call teams, and the whole company.\n\nConclusion\n\n|\n\n173",
      "content_length": 2166,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 207,
      "content": "CHAPTER 9 Incident Response\n\nBy Jennifer Mace, Jelena Oertel, Stephen Thorne, and Arup Chakrabarti (PagerDuty) with Jian Ma and Jessie Yang\n\nEveryone wants their services to run smoothly all the time, but we live in an imper‐ fect world in which outages do occur. What happens when a not-so-ordinary, urgent problem requires multiple individuals or teams to resolve it? You are suddenly faced with simultaneously managing the incident response and resolving the problem.\n\nResolving an incident means mitigating the impact and/or restoring the service to its previous condition. Managing an incident means coordinating the efforts of respond‐ ing teams in an efficient manner and ensuring that communication flows both between the responders and to those interested in the incident’s progress. Many tech companies, including Google, have adopted and adapted best practices for managing incidents from emergency response organizations, which have been using these prac‐ tices for many years.\n\nThe basic premise of incident management is to respond to an incident in a struc‐ tured way. Large-scale incidents can be confusing; a structure that teams agree on beforehand can reduce chaos. Formulating rules about how to communicate and coordinate your efforts before disaster strikes allows your team to concentrate on resolving an incident when it occurs. If your team has already practiced and familiar‐ ized themselves with communication and coordination, they don’t need to worry about these factors during an incident.\n\nSetting up an incident response process doesn’t need to be a daunting task. There are a number of widely available resources that can provide some guidance, such as Man‐ aging Incidents in the first SRE Book. The basic principles of incident response include the following:\n\n175",
      "content_length": 1799,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 208,
      "content": "Maintain a clear line of command.\n\nDesignate clearly defined roles.\n\nKeep a working record of debugging and mitigation as you go.\n\nDeclare incidents early and often.\n\nThis chapter shows how incident management is set up at Google and PagerDuty, and gives examples of where we got this process right and where we didn’t. The sim‐ ple checklist in “Putting Best Practices into Practice” on page 191 can help you get started on creating your own incident response practice, if you don’t already have one.\n\nIncident Management at Google Incident response provides a system for responding to and managing an incident. A framework and set of defined procedures allow a team to respond to an incident effectively and scale up their response. Google’s incident response system is based on the Incident Command System (ICS).\n\nIncident Command System ICS was established in 1968 by firefighters as a way to manage wildfires. This frame‐ work provides standardized ways to communicate and fill clearly specified roles dur‐ ing an incident. Based upon the success of the model, companies later adapted ICS to respond to computer and system failures. This chapter explores two such frame‐ works: PagerDuty’s Incident Response process and Incident Management At Google (IMAG).\n\nIncident response frameworks have three common goals, also known as the “three Cs” (3Cs) of incident management:\n\nCoordinate response effort.\n\nCommunicate between incident responders, within the organization, and to the outside world.\n\nMaintain control over the incident response.\n\nWhen something goes wrong with incident response, the culprit is likely in one of these areas. Mastering the 3Cs is essential for effective incident response.\n\n176\n\n|\n\nChapter 9: Incident Response",
      "content_length": 1742,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 209,
      "content": "Main Roles in Incident Response The main roles in incident response are the Incident Commander (IC), Communica‐ tions Lead (CL), and Operations or Ops Lead (OL). IMAG organizes these roles into a hierarchy: the IC leads the incident response, and the CL and OL report to the IC.\n\nWhen disaster strikes, the person who declares the incident typically steps into the IC role and directs the high-level state of the incident. The IC concentrates on the 3Cs and does the following:\n\nCommands and coordinates the incident response, delegating roles as needed. By default, the IC assumes all roles that have not been delegated yet.\n\nCommunicates effectively.\n\nStays in control of the incident response.\n\nWorks with other responders to resolve the incident.\n\nThe IC may either hand off their role to someone else and assume the OL role, or assign the OL role to someone else. The OL works to respond to the incident by applying operational tools to mitigate or resolve the incident.\n\nWhile the IC and OL work on mitigating and resolving the incident, the CL is the public face of the incident response team. The CL’s main duties include providing periodic updates to the incident response team and stakeholders, and managing inquiries about the incident.\n\nBoth the CL and OL may lead a team of people to help manage their specific areas of incident response. These teams can expand or contract as needed. If the incident becomes small enough, the CL role can be subsumed back into the IC role.\n\nCase Studies The following four large-scale incidents illustrate how incident response works in practice. Three of these case studies are from Google, and the last is a case study from PagerDuty, which provides perspective on how other organizations use ICS-derived frameworks. The Google examples start with an incident that wasn’t managed effec‐ tively, and progress to incidents that were managed well.\n\nCase Study 1: Software Bug—The Lights Are On but No One’s (Google) Home This example shows how failing to declare an incident early on can leave a team without the tools to respond to an incident quickly and efficiently. While this inci‐ dent was resolved without major calamity, early escalation would have produced a quicker, more organized response, and a better outcome.\n\nCase Studies\n\n|\n\n177",
      "content_length": 2291,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 210,
      "content": "Context\n\nGoogle Home is a smart speaker and home assistant that responds to voice com‐ mands. The voice commands interact with Google Home’s software, which is called Google Assistant.\n\nInteracting with Google Home starts when a user says a hotword, a given phrase that triggers Google Assistant. Multiple users can use the same Google Home device by training the assistant to listen for a given hotword. The hotword model that identifies speakers is trained on the client, but the training data (i.e., the speaker recognition files) is stored on the server. The server handles bidirectional streaming of data. To handle overload during busy times, the server has a quota policy for Google Assis‐ tant. In order to protect servers from overly large request values, the quota limit is significantly higher than the baseline usage for Google Assistant on a given device.\n\nA bug in Google Assistant version 1.88 caused speaker recognition files to be fetched 50 times more often than expected, exceeding this quota. Initially, Google Home users in the central United States experienced only small traffic losses. As the rollout increased progressively to all Google Home devices, however, users lost half of their requests during the weekend of June 3, 2017.\n\nIncident\n\nAt 11:48 a.m. PST on Monday, May 22, Jasper, the developer on-call for Google Home, happened to be looking at the queries per second (QPS) graphs and noticed something strange: Google Assistant had been pinging training data every 30 minutes, instead of once per day as expected. He stopped the release of version 1.88, which had rolled out to 25% of users. He raised a bug—let’s call it bug 12345—with Google’s bug tracking system to explore why this was happening. On the bug, he noted that Google Assistant was pinging data 48 times a day, causing it to exceed its QPS capacity.\n\nAnother developer, Melinda, linked the issue to a previously reported bug, which we’ll call bug 67890: any time an app refreshed the device authentication and enroll‐ ment state, the speech processor restarted. This bug was slated to be fixed after the version 1.88 release, so the team requested a temporary increase in quota for the model to mitigate the overload from extra queries.\n\nThe version 1.88 release was started again and continued to roll out, reaching 50% of users by Wednesday, May 31. Unfortunately, the team later learned that bug 67890, while responsible for some extra traffic, was not the actual root cause of the more fre‐ quent fetches that Jasper had noticed.\n\nThat same morning, customers started reporting an issue to Google’s support team: any time someone said “OK Google” (or any other hotword to activate Google Home), the device responded with an error message. This issue prevented users from\n\n178\n\n|\n\nChapter 9: Incident Response",
      "content_length": 2811,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 211,
      "content": "giving commands to Google Assistant. The team began to investigate what could be causing the errors that users reported. They suspected quota issues, so they requested another increase to the quota, which seemed to mitigate the problem.\n\nMeanwhile, the team continued to investigate bug 12345 to see what was triggering the errors. Although the quota connection was established early in the debugging process, miscommunication between the client and server developers had led devel‐ opers down the wrong path during troubleshooting, and the full solution remained out of reach.\n\nThe team also puzzled over why Google Assistant’s traffic kept hitting quota limits. The client and server developers were confused by client-side errors that didn’t seem to be triggered by any problems on the server side. The developers added logging to the next release to help the team understand the errors better, and hopefully make progress in resolving the incident.\n\nBy Thursday, June 1, users reported that the issue had been resolved. No new issues were reported, so the version 1.88 release continued to roll out. However, the root cause of the original issue had not yet been identified.\n\nBy early Saturday morning, June 3, the version 1.88 release rollout surpassed 50%. The rollout was happening on a weekend, when developers were not readily available. The team had not followed the best practice of performing rollouts only during busi‐ ness days to ensure developers are around in case something goes wrong.\n\nWhen the version 1.88 release rollout reached 100% on Saturday, June 3, the client once more hit server limits for Google Assistant traffic. New reports from customers started coming in. Google employees reported that their Google Home devices were throwing errors. The Google Home support team received numerous customer phone calls, tweets, and Reddit posts about the issue, and Google Home’s help forum displayed a growing thread discussing the issue. Despite all the user reports and feed‐ back, the bug wasn’t escalated to a higher priority.\n\nOn Sunday, June 4, as the number of customer reports continued to increase, the support team finally raised the bug priority to the highest level. The team did not declare an incident, but continued to troubleshoot the issue via “normal” methods, using the bug tracking system for communication. The on-call developer noticed error rates in one of the datacenter clusters and pinged SRE, asking them to drain it. At the same time, the team submitted another request for a quota increase. After‐ ward, an engineer on the developer team noticed the drain had pushed errors into other cells, which provided additional evidence of quota issues. At 3:33 p.m., the developer team manager increased the quota for Google Assistant once again, and the impact on users stopped. The incident was over. The team identified the root cause (see the previous “Context” section) shortly thereafter.\n\nCase Studies\n\n|\n\n179",
      "content_length": 2957,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 212,
      "content": "Review\n\nSome aspects of incident handling went really well, while others had room for improvement.\n\nFirst, the developers rallied on the weekend and provided valuable input to resolve the issue. This was both good and bad. While the team valued the time and effort these individuals contributed over the weekend, successful incident management shouldn’t rely on heroic efforts of individuals. What if the developers had been unreachable? At the end of the day, Google supports a good work-life balance—engi‐ neers shouldn’t be tapped during their free time to fix work-related problems. Instead, we should have conducted rollouts during business hours or organized an on-call rotation that provided paid coverage outside of business hours.\n\nNext, the team worked to mitigate the issue. Google always aims to first stop the impact of an incident, and then find the root cause (unless the root cause just hap‐ pens to be identified early on). Once the issue is mitigated, it’s just as important to understand the root cause in order to prevent the issue from happening again. In this case, mitigation successfully stopped the impact on three separate occasions, but the team could only prevent the issue from recurring when they discovered the root cause. After the first mitigation, it would have been better to postpone the rollout until the root cause was fully determined, avoiding the major disruption that hap‐ pened over the weekend.\n\nFinally, the team did not declare an incident when problems first appeared. Our experience shows that managed incidents are resolved faster. Declaring an incident early ensures that:\n\nMiscommunication between the client and server developers is prevented.\n\nRoot-cause identification and incident resolution occur sooner.\n\nRelevant teams are looped in earlier, making external communications faster and smoother.\n\nCentralized communication is an important principle of the IMAG protocol. For example, when disaster strikes, SREs typically gather in a “war room.” The war room can be a physical location like a conference room, or it can be virtual: teams might gather on an IRC channel or Hangout. The key here is to gather all the incident res‐ ponders in one place and to communicate in real time to manage—and ultimately resolve—an incident.\n\nCase Study 2: Service Fault—Cache Me If You Can The following incident illustrates what happens when a team of experts tries to debug a system with so many interactions that no single person can grasp all the details. Sound familiar?\n\n180\n\n|\n\nChapter 9: Incident Response",
      "content_length": 2556,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 213,
      "content": "Context\n\nKubernetes is an open source container management system built collaboratively by many companies and individual contributors. Google Kubernetes Engine, or GKE, is a Google-managed system that creates, hosts, and runs Kubernetes clusters for users. This hosted version operates the control plane, while users upload and manage work‐ loads in the way that suits them best.\n\nWhen a user first creates a new cluster, GKE fetches and initializes the Docker images their cluster requires. Ideally, these components are fetched and built internally so we can validate them. But because Kubernetes is an open source system, new dependen‐ cies sometimes slip in through the cracks.\n\nIncident\n\nOne Thursday at 6:41 a.m. PST, London’s on-call SRE for GKE, Zara, was paged for CreateCluster prober failures across several zones. No new clusters were being suc‐ cessfully created. Zara checked the prober dashboard and saw that failures were above 60% for two zones. She verified this issue was affecting user attempts to create new clusters, though traffic to existing clusters was not affected. Zara followed GKE’s documented procedure and declared an incident at 7:06 a.m.\n\nInitially, four people were involved in the incident:\n\nZara, who first noticed the problem, and was therefore the designated default Incident Commander\n\nTwo of Zara’s teammates\n\nRohit, the customer support engineer paged by the incident procedure\n\nSince Rohit was based in Zurich, Zara (the IC) opened a GKE Panic IRC channel where the team could debug together. While the other two SREs dug into monitoring and error messages, Zara explained the outage and its impact to Rohit. By 7:24 a.m., Rohit posted a notice to users that CreateCluster was failing in the Europe-West region. This was turning into a large incident.\n\nBetween 7 a.m. and 8:20 a.m., Zara, Rohit, and the others worked on troubleshooting the issue. They examined cluster startup logs, which revealed an error:\n\nerror: failed to run Kubelet: cannot create certificate signing request: Post https://192.0.2.53/apis/certificates.k8s.io/v1beta1/certificatesigningrequests\n\nThey needed to determine which part of the certificate creation failed. The SREs investigated the network, resource availability, and the certificate signing process. All seemed to work fine separately. At 8:22 a.m., Zara posted a summary of the investiga‐ tion to the incident management system, and looked for a developer who could help her.\n\nCase Studies\n\n|\n\n181",
      "content_length": 2476,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 214,
      "content": "Thankfully, GKE had a developer on-call who could be paged for emergencies. The developer, Victoria, joined the channel. She asked for a tracking bug and requested that the team escalate the issue to the infrastructure on-call team.\n\nIt was now 8:45 a.m. The first Seattle SRE, Il-Seong, arrived at the office, lightly caf‐ feinated and ready for the day. Il-Seong was a senior SRE with many years of experi‐ ence in incident response. When he was informed about the ongoing incident, he jumped in to help. First, Il-Seong checked the day’s release against the timing of the alerts, and determined that the day’s release did not cause the incident. He then started a working document1 to collect notes. He suggested that Zara escalate the incident to the infrastructure, cloud networking, and compute engine teams to possi‐ bly eliminate those areas as root causes. As a result of Zara’s escalation, additional people joined the incident response:\n\nThe developer lead for GKE nodes\n\nCloud Networking on-call\n\nCompute Engine on-call\n\nHerais, another Seattle SRE\n\nAt 9:10 a.m., the incident channel had a dozen participants. The incident was 2.5 hours old, with no root cause and no mitigation. Communication was becoming a challenge. Normally, on-call handover from London to Seattle occurred at 10 a.m., but Zara decided to hand over incident command to Il-Seong before 10 a.m., since he had more experience with IMAG.\n\nAs Incident Commander, Il-Seong set up a formal structure to address the incident. He then designated Zara as Ops Lead and Herais as Communications (Comms) Lead. Rohit remained the External Communications Lead. Herais immediately sent an “all hands on deck” email to several GKE lists, including all developer leads, and asked experts to join the incident response.\n\nSo far, the incident responders knew the following:\n\nCluster creation failed where nodes attempted to register with the master.\n\nThe error message indicated the certificate signing module as the culprit.\n\nAll cluster creation in Europe was failing; all other continents were fine.\n\nNo other GCP services in Europe were seeing network or quota problems.\n\n1 When three or more people work on an incident, it’s useful to start a collaborative document that lists work‐ ing theories, eliminated causes, and useful debugging information, such as error logs and suspect graphs. The document preserves this information so it doesn’t get lost in the conversation.\n\n182\n\n|\n\nChapter 9: Incident Response",
      "content_length": 2480,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 215,
      "content": "Thanks to the call for all hands on deck, Puanani, a GKE Security team member, joined the effort. She noticed the certificate signer was not starting. The certificate signer was trying to pull an image from DockerHub, and the image appeared to be corrupted. Victoria (the on-call GKE developer) ran Docker’s pull command for the image in two geographic locations. It failed when it ran on a cluster in Europe and succeeded on a cluster in the US. This indicated that the European cluster was the problem. At 9:56 a.m., the team had identified a plausible root cause.\n\nBecause DockerHub was an external dependency, mitigation and root causing would be especially challenging. The first option for mitigation was for someone at Docker to quickly fix the image. The second option was to reconfigure the clusters to fetch the image from a different location, such as Google Container Registry (GCR), Goo‐ gle’s secure image hosting system. All the other dependencies, including other refer‐ ences to the image, were located in GCR.\n\nIl-Seong assigned owners to pursue both options. He then delegated a team to inves‐ tigate fixing the broken cluster. Discussion became too dense for IRC, so detailed debugging moved to the shared document, and IRC became the hub for decision making.\n\nFor the second option, pushing a new configuration meant rebuilding binaries, which took about an hour. At 10:59 a.m., when the team was 90% done rebuilding, they dis‐ covered another location that was using the bad image fetch path. In response, they had to restart the build.\n\nWhile the engineers on IRC worked on the two mitigation options, Tugay, an SRE, had an idea. Instead of rebuilding the configuration and pushing it out (a cumber‐ some and risky process), what if they intercepted Docker’s pull requests and substi‐ tuted the response from Docker with an internal cached image? GCR had a mirror for doing precisely this. Tugay reached out to contacts on GCR’s SRE team, and they confirmed that the team could set --registry-mirror=https://mirror.gcr.io on the Docker configuration. Tugay started setting up this functionality and discovered that the mirror was already in place!\n\nAt 11:29 a.m., Tugay reported to IRC that these images were being pulled from the GCR mirror, not DockerHub. At 11:37 a.m., the Incident Commander paged GCR on- call. At 11:59 a.m., GCR on-call purged the corrupt image from their European stor‐ age layer. By 12:11 p.m., all European zones had fallen to 0% error.\n\nThe outage was over. All that remained was cleanup, and writing a truly epic post‐ mortem.\n\nCreateCluster had failed in Europe for 6 hours and 40 minutes before it was fixed. In IRC, 41 unique users appeared throughout the incident, and IRC logs stretched to 26,000 words. The effort spun up seven IMAG task forces at various times, and as many as four worked simultaneously at any given time. On-calls were summoned\n\nCase Studies\n\n|\n\n183",
      "content_length": 2925,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 216,
      "content": "from six teams, not including those from the “all hands on deck” call. The postmor‐ tem contained 28 action items.\n\nReview\n\nThe GKE CreateCluster outage was a large incident by anyone’s standards. Let’s explore what went well, and what could have been handled better.\n\nWhat went well? The team had several documented escalation paths and was familiar with incident response tactics. Zara, the GKE on-call, quickly verified that the impact was affecting actual customers. She then used an incident management system pre‐ pared beforehand to bring in Rohit, who communicated the outage to customers.\n\nWhat could have been handled better? The service itself had some areas of concern. Complexity and dependence on specialists were problematic. Logging was insuffi‐ cient for diagnosis, and the team was distracted by the corruption on DockerHub, which was not the real issue.\n\nAt the beginning of the incident, the Incident Commander didn’t put a formal inci‐ dent response structure in place. While Zara assumed this role and moved the con‐ versation to IRC, she could have been much more proactive in coordinating information and making decisions. As a result, a handful of first responders pursued their own investigations without coordination. Il-Seong put a formal incident response structure in place two hours after the first page.\n\nFinally, the incident revealed a gap in GKE’s disaster readiness: the service didn’t have any early generic mitigations that would reduce user pain. Generic mitigations are actions that first responders take to alleviate pain, even before the root cause is fully understood. For example, responders could roll back a recent release when an outage is correlated with the release cycle, or reconfigure load balancers to avoid a region when errors are localized. It’s important to note that generic mitigations are blunt instruments and may cause other disruptions to the service. However, while they may have broader impact than a precise solution, they can be put in place quickly to stop the bleeding while the team discovers and addresses the root cause.\n\nLet’s look at the timeline of this incident again to see where a generic mitigation might have been effective:\n\n7 a.m. (Assessed impact). Zara confirmed that users were affected by the outage.\n\n9:56 a.m. (Found possible cause). Puanani and Victoria identified a rogue image.\n\n10:59 a.m. (Bespoke mitigation). Several team members worked on rebuilding binaries to push a new configuration that would fetch images from a different location.\n\n184\n\n|\n\nChapter 9: Incident Response",
      "content_length": 2570,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 217,
      "content": "11:59 a.m. (Found root cause and fixed the issue). Tugay and GCR on-call dis‐ abled GCR caching and purged a corrupt image from their European storage layer.\n\nA generic mitigation after step 2 (found possible cause) would have been very useful here. If the responders had rolled back all images to a known good state once they discovered the issue’s general location, the incident would have been mitigated by 10 a.m. To mitigate an incident, you don’t have to fully understand the details—you only need to know the location of the root cause. Having the ability to mitigate an outage before its cause is fully understood is crucial for running robust services with high availability.\n\nIn this case, the responders would have benefited from some sort of tool that facilita‐ ted rollbacks. Mitigation tools do take engineering time to develop. The right time to create general-purpose mitigation tools is before an incident occurs, not when you are responding to an emergency. Browsing postmortems is a great way to discover mitigations and/or tools that would have been useful in retrospect, and build them into services so that you can better manage incidents in the future.\n\nIt’s important to remember that first responders must prioritize mitigation above all else, or time to resolution suffers. Having a generic mitigation in place, such as roll‐ back and drain, speeds recovery and leads to happier customers. Ultimately, custom‐ ers do not care whether or not you fully understand what caused an outage. What they want is to stop receiving errors.\n\nWith mitigation as top priority, an active incident should be addressed as follows:\n\n1. Assess the impact of the incident.\n\n2. Mitigate the impact.\n\n3. Perform a root-cause analysis of the incident.\n\n4. After the incident is over, fix what caused the incident and write a postmortem.\n\nAfterward, you can run incident response drills to exercise the vulnerabilities in the system, and engineers can work on projects to address these vulnerabilities.\n\nCase Study 3: Power Outage—Lightning Never Strikes Twice… Until It Does The previous examples showed what can go wrong when you don’t have good inci‐ dent response strategies in place. The next example illustrates an incident that was successfully managed. When you follow a well-defined and clear response protocol, you can handle even rare or unusual incidents with ease.\n\nCase Studies\n\n|\n\n185",
      "content_length": 2401,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 218,
      "content": "Context\n\nPower grid events, such as lightning strikes, cause the power coming into a datacen‐ ter facility to vary wildly. Lightning strikes affecting the power grid are rare, but not unexpected. Google protects against sudden, unexpected power outages with backup generators and batteries, which are well tested and known to work in these scenarios.\n\nMany of Google’s servers have a large number of disks attached to them, with the disks located on a separate tray above or below the server. These trays have their own uninterruptible power supply (UPS) battery. When a power outage occurs, the backup generators activate but take a few minutes to start. During this period, the backup batteries attached to the servers and disk trays provide power until the backup generators are fully running, thereby preventing power grid events from impacting datacenter operation.\n\nIncident\n\nIn mid-2015, lightning struck the power grid near a Google datacenter in Belgium four times within two minutes. The datacenter’s backup generators activated to sup‐ ply power to all the machines. While the backup generators were starting up, most of the servers ran on backup batteries for a few minutes.\n\nThe UPS batteries in the disk trays did not swap power usage to the backup batteries on the third and fourth lightning strikes because the strikes were too closely spaced. As a result, the disk trays lost power until the backup generators kicked in. The servers did not lose power, but were unable to access the disks that had power cycled.\n\nLosing a large number of disk trays on persistent disk storage resulted in read and write errors for many virtual machine (VM) instances running on Google Compute Engine (GCE). The Persistent Disk SRE on-call was immediately notified of these errors. Once the Persistent Disk SRE team established the impact, a major incident was declared and announced to all affected parties. The Persistent Disk SRE on-call assumed the role of Incident Commander.\n\nAfter an initial investigation and communication between stakeholders, we estab‐ lished that:\n\nEach machine that lost a disk tray because of the temporary power outage needed to be rebooted.\n\nWhile waiting for the reboot, some customer VMs had trouble reading and writ‐ ing to their disks.\n\nAny host that had both a disk tray and customer VMs could not simply be “rebooted” without losing the customer VMs that hadn’t been affected. Persistent Disk SRE asked GCE SRE to migrate unaffected VMs to other hosts.\n\n186\n\n|\n\nChapter 9: Incident Response",
      "content_length": 2527,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 219,
      "content": "The Persistent Disk SRE’s primary on-call retained the IC role, since that team had the best visibility into customer impact.\n\nOperations team members were tasked with the following objectives:\n\nSafely restore power to use grid power instead of backup generators.\n\nRestart all machines that were not hosting VMs.\n\nCoordinate between Persistent Disk SRE and GCE SRE to safely move VMs away from the affected machines before restarting them.\n\nThe first two objectives were clearly defined, well understood, and documented. The datacenter ops on-call immediately started working to safely restore power, providing regular status reports to the IC. Persistent Disk SRE had defined procedures for restarting all machines not hosting virtual machines. A team member began restart‐ ing those machines.\n\nThe third objective was more vague and wasn’t covered by any existing procedures. The Incident Commander assigned a dedicated operations team member to coordi‐ nate with GCE SRE and Persistent Disk SRE. These teams collaborated to safely move VMs away from the affected machines so the affected machines could be rebooted. The IC closely monitored their progress and realized that this work called for new tools to be written quickly. The IC organized more engineers to report to the opera‐ tions team so they could create the necessary tools.\n\nThe Communications Lead observed and asked questions about all incident-related activities, and was responsible for reporting accurate information to multiple audiences:\n\nCompany leaders needed information about the extent of the problem, and assurance that the problem was being addressed.\n\nTeams with storage concerns needed to know when their storage would be fully available again.\n\nExternal customers needed to be proactively informed about the problem with their disks in this cloud region.\n\nSpecific customers who had filed support tickets needed more information about the problems they were seeing, and advice on workarounds and timelines.\n\nAfter we mitigated the initial customer impact, we needed to do some follow-up, such as:\n\nDiagnosing why the UPS used by the disk trays failed, and making sure that it doesn’t happen again.\n\nReplacing the batteries in the datacenter that failed.\n\nCase Studies\n\n|\n\n187",
      "content_length": 2258,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 220,
      "content": "Manually clearing “stuck” operations caused by losing so many storage systems simultaneously.\n\nPost-incident analysis revealed that only a small number of writes—the writes pend‐ ing on the machines that lost power during the incident—weren’t ever written to disk. Since Persistent Disk snapshots and all Cloud Storage data are stored in multi‐ ple datacenters for redundancy, only 0.000001% of data from running GCE machines was lost, and only data from running instances was at risk.\n\nReview\n\nBy declaring the incident early and organizing a response with clear leadership, a carefully managed group of people handled this complex incident effectively.\n\nThe Incident Commander delegated the normal problems of restoring power and rebooting servers to the appropriate Operations Lead. Engineers worked on fixing the issue and reported their progress back to the Operations Lead.\n\nThe more complex problem of meeting the needs of both GCE and Persistent Disk required coordinated decision making and interaction among multiple teams. The Incident Commander made sure to assign appropriate operations team members from both teams to the incident, and worked directly with them to drive toward a solution. The Incident Commander wisely focused on the most important aspect of the incident: addressing the needs of the impacted customers as quickly as possible.\n\nCase Study 4: Incident Response at PagerDuty by Arup Chakrabarti of PagerDuty\n\nPagerDuty has developed and refined our internal incident response practices over the course of several years. Initially, we staffed a permanent, company-wide Incident Commander and dedicated specific engineers per service to take part in incident response. As PagerDuty grew to over 400 employees and dozens of engineering teams, our Incident Response processes also changed. Every few months, we take a hard look at our processes, and update them to reflect business needs. Nearly every‐ thing we have learned is documented at https://response.pagerduty.com. Our Incident Response processes are purposefully not static; they change and evolve just as our business does.\n\nMajor incident response at PagerDuty\n\nTypically, small incidents require only a single on-call engineer to respond. When it comes to larger incidents, we place heavy emphasis on teamwork. An engineer shouldn’t feel alone in high-stress and high-impact scenarios. We use the following techniques to help promote teamwork:\n\n188\n\n|\n\nChapter 9: Incident Response",
      "content_length": 2470,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 221,
      "content": "Participating in simulation exercises\n\nOne way we teach teamwork is by participating in Failure Friday. PagerDuty drew inspiration from Netflix’s Simian Army to create this program. Originally, Failure Friday was a manual failure injection exercise aimed at learning more about the ways our systems could break. Today, we also use this weekly exercise to recreate common problems in production and incident response scenarios.\n\nBefore Failure Friday starts, we nominate an Incident Commander (typically, a person training to become an IC). They are expected to behave and act like a real IC while conducting failure injection exercises. Throughout the drill, subject- matter experts use the same processes and vernacular they would use during an actual incident. This practice both familiarizes new on-call engineers with inci‐ dent response language and processes and provides more seasoned on-call engi‐ neers with a refresher.\n\nPlaying time-bound simulation games\n\nWhile Failure Friday exercises go a long way toward training engineers on differ‐ ent roles and processes, they can’t fully replicate the urgency of actual major inci‐ dents. We use simulation games with a time-bound urgency to capture that aspect of incident response.\n\n“Keep Talking and Nobody Explodes” is one game we’ve leveraged heavily. It requires players to work together to defuse bombs within time limits. The stress‐ ful and communication-intensive nature of the game forces players to cooperate and work together effectively.\n\nLearning from previous incidents\n\nLearning from previous incidents helps us respond better to major incidents in the future. To this end, we conduct and regularly review postmortems.\n\nPagerDuty’s postmortem process involves open meetings and thorough docu‐ mentation. By making this information easily accessible and discoverable, we aim to reduce the resolution time of future incidents, or prevent a future incident from happening altogether.\n\nWe also record all of the phone calls involved in a major incident so we can learn from the real-time communication feed.\n\nLet’s look at a recent incident in which PagerDuty had to leverage our incident response process. The incident occurred on October 6, 2017, and lasted more than 10 hours, but had very minimal customer impact.\n\n7:53 p.m. A member of the PagerDuty SRE team was alerted that PagerDuty internal NTP servers were exhibiting clock drift. The on-call SRE validated that all automated recovery actions had been executed, and completed the mitigation\n\nCase Studies\n\n|\n\n189",
      "content_length": 2539,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 222,
      "content": "steps in relevant runbooks. This work was documented in the SRE team’s dedica‐ ted Slack channel.\n\n8:20 p.m. A member of PagerDuty Software Team A received an automated alert about clock drift errors in their services. Software Team A and the SRE team worked toward resolving the problem.\n\n9:17 p.m. A member of PagerDuty Software Team B received an automated alert about clock drift errors on their services. The engineer from Team B joined the Slack channel where the issue was already being triaged and debugged.\n\n9:49 p.m. The SRE on-call declared a major incident and alerted the Incident Commander on-call.\n\n9:55 p.m. The IC assembled the response team, which included every on-call engineer that had a service dependent on NTP, and PagerDuty’s customer sup‐ port on-call. The IC had the response team join the dedicated conference call and Slack channel. For the next eight hours, the response team worked on addressing and mitigating the issue. When the procedures in our runbooks didn’t resolve the issue, the response team started trying new recovery options in a methodical manner.\n\nDuring this time, we rotated on-call engineers and the IC every four hours. Doing so encouraged engineers to get rest and brought new ideas into the response team.\n\n5:33 a.m. The on-call SRE made a configuration change to the NTP servers.\n\n6:13 a.m. The IC validated that all services had recovered with their respective on-call engineers. Once validation was complete, the IC shut off the conference call and Slack channel and declared the incident complete. Given the wide impact of the NTP service, a postmortem was warranted. Before closing out the incident, the IC assigned the postmortem analysis to the SRE team on-call for the service.\n\nTools used for incident response\n\nOur Incident Response processes leverage three main tools:\n\nPagerDuty\n\nWe store all of our on-call information, service ownership, postmortems, inci‐ dent metadata, and the like, in PagerDuty. This allows us to rapidly assemble the right team when something goes wrong.\n\nSlack\n\nWe maintain a dedicated channel (#incident-war-room) as a gathering place for all subject-matter experts and Incident Commanders. The channel is used mostly\n\n190\n\n|\n\nChapter 9: Incident Response",
      "content_length": 2245,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 223,
      "content": "as an information ledger for the scribe, who captures actions, owners, and time‐ stamps.\n\nConference calls\n\nWhen asked to join any incident response, on-call engineers are required to dial in to a static conference call number. We prefer that all coordination decisions are made in the conference call, and that decision outcomes are recorded in Slack. We found this was the fastest way to make decisions. We also record every call to make sure that we can recreate any timeline in case the scribe misses important details.\n\nWhile Slack and conference calls are our communication channels of choice, you should use the communication method that works best for your company and its engineers.\n\nAt PagerDuty, how we handle incident response relates directly to the success of the company. Rather than facing such events unprepared, we purposefully prepare for incidents by conducting simulation exercises, reviewing previous incidents, and choosing the right tools to help us be resilient to any major incident that may come our way.\n\nPutting Best Practices into Practice We’ve seen examples of incidents that were handled well, and some that were not. By the time a pager alerts you to a problem, it’s too late to think about how to manage the incident. The time to start thinking about an incident management process is before an incident occurs. So how do you prepare and put theory into practice before disaster strikes? This section provides some recommendations.\n\nIncident Response Training We highly recommend training responders to organize an incident so they have a pattern to follow in a real emergency. Knowing how to organize an incident, having a common language to use throughout the incident, and sharing the same expectations reduce the chance of miscommunication.\n\nThe full Incident Command System approach may be more than you need, but you can develop a framework for handling incidents by selecting the parts of the incident management process that are important to your organization. For example:\n\nLet on-calls know they can delegate and escalate during an incident.\n\nEncourage a mitigation-first response.\n\nDefine Incident Commander, Communications Lead, and Operations Lead roles.\n\nPutting Best Practices into Practice\n\n|\n\n191",
      "content_length": 2248,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 224,
      "content": "You can adapt and summarize your incident response framework, and create a slide deck to present to new team members. We’ve learned that people are more receptive to incident response training when they can connect the theory of incident response to actual scenarios and concrete actions. Therefore, be sure to include hands-on exer‐ cises and share what happened in past incidents, analyzing what went well and what didn’t go so well. You might also consider using external agencies that specialize in incident response classes and training.\n\nPrepare Beforehand In addition to incident response training, it helps to prepare for an incident before‐ hand. Use the following tips and strategies to be better prepared.\n\nDecide on a communication channel\n\nDecide and agree on a communication channel (Slack, a phone bridge, IRC, HipChat, etc.) beforehand—no Incident Commander wants to make this decision during an incident. Practice using it so there are no surprises. If possible, pick a communica‐ tions channel the team is already familiar with so that everyone on the team feels comfortable using it.\n\nKeep your audience informed\n\nUnless you acknowledge that an incident is happening and actively being addressed, people will automatically assume nothing is being done to resolve the issue. Similarly, if you forget to call off the response once the issue has been mitigated or resolved, people will assume the incident is ongoing. You can preempt this dynamic by keep‐ ing your audience informed throughout the incident with regular status updates. Having a prepared list of contacts (see the next tip) saves valuable time and ensures you don’t miss anyone.\n\nThink ahead about how you’ll draft, review, approve, and release public blog posts or press releases. At Google, teams seek guidance from the PR team. Also, prepare two or three ready-to-use templates for sharing information, making sure the on-call knows how to send them. No one wants to write these announcements under extreme stress with no guidelines. The templates make sharing information with the public easy and minimally stressful.\n\nPrepare a list of contacts\n\nHaving a list of people to email or page prepared beforehand saves critical time and effort. In “Case Study 2: Service Fault—Cache Me If You Can” on page 180, the Comms Lead made an “all hands on deck” call by sending an email to several GKE lists that were prepared beforehand.\n\n192\n\n|\n\nChapter 9: Incident Response",
      "content_length": 2449,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 225,
      "content": "Establish criteria for an incident\n\nSometimes it’s clear that a paging issue is truly an incident. Other times, it’s not so clear. It’s helpful to have an established list of criteria for determining if an issue is indeed an incident. A team can come up with a solid list of criteria by looking at past outages, taking known high-risk areas into consideration.\n\nIn summary, it’s important to establish common ground for coordination and com‐ munication when responding to incidents. Decide on ways to communicate the inci‐ dent, who your audience is, and who is responsible for what during an incident. These guidelines are easy to set up and have high impact on shortening the resolution time of an incident.\n\nDrills The final step in the incident management process is practicing your incident man‐ agement skills. By practicing during less critical situations, your team develops good habits and patterns of behavior for when lightning strikes—figuratively and literally. After introducing the theory of incident response through training, practice ensures that your incident response skills stay fresh.\n\nThere are several ways to conduct incident management drills. Google runs company-wide resilience testing (called Disaster Recovery Testing, or DiRT; see Kripa Krishnan’s article “Weathering the Unexpected”2), in which we create a con‐ trolled emergency that doesn’t actually impact customers. Teams respond to the con‐ trolled emergency as if it were a real emergency. Afterward, the teams review the emergency response procedures and discuss what happened. Accepting failure as a means of learning, finding value in gaps identified, and getting our leadership on board were key to successfully establishing the DiRT program at Google. On a smaller scale, we practice responding to specific incidents using exercises like Wheel of Misfortune (see “Disaster Role Playing” in Site Reliability Engineering).\n\nYou can also practice incident response by intentionally treating minor problems as major ones requiring a large-scale response. This lets your team practice with the procedures and tools in a real-world situation with lower stakes.\n\nDrills are a friendly way of trying out new incident response skills. Anyone on your team who could get swept into incident response—SREs, developers, and even cus‐ tomer support and marketing partners—should feel comfortable with these tactics.\n\nTo stage a drill, you can invent an outage and allow your team to respond to the inci‐ dent. You can also create outages from postmortems, which contain plenty of ideas\n\n2 Kripa Krishan, “Weathering the Unexpected,” Communications of the ACM 10, no. 9 (2012), https://\n\nqueue.acm.org/detail.cfm?id=2371516.\n\nPutting Best Practices into Practice\n\n|\n\n193",
      "content_length": 2748,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 226,
      "content": "for incident management drills. Use real tools as much as possible to manage the incident. Consider breaking your test environment so the team can perform real troubleshooting using existing tools.\n\nAll these drills are far more useful if they’re run periodically. You can make drills impactful by following up each exercise with a report detailing what went well, what didn’t go well, and how things could have been handled better. The most valuable part of running a drill is examining their outcomes, which can reveal a lot about any gaps in incident management. Once you know what they are, you can work toward closing them.\n\nConclusion Be prepared for when disaster strikes. If your team practices and refreshes your inci‐ dent response procedures regularly, you won’t panic when the inevitable outage occurs.\n\nThe circle of people you need to collaborate with during an incident expands with the size of the incident. When you’re working with people you don’t know, procedures help create the structure you need to quickly move toward a resolution. We strongly recommend establishing these procedures ahead of time when the world is not on fire. Regularly review and iterate on your incident management plans and playbooks.\n\nThe Incident Command System is a simple concept that is easily understood. It scales up or down according to the size of the company and the incident. Although it’s sim‐ ple to understand, it isn’t easy to implement, especially in the middle of an incident when panic suddenly overtakes you. Staying calm and following the response struc‐ ture during an emergency takes practice, and practice builds “muscle memory.” This gives you the confidence you’ll need for a real emergency.\n\nWe strongly recommend carving out some time in your team’s busy schedule to practice incident management on a regular basis. Secure support from leadership for dedicated practice time, and make sure they understand how incident response works in case you need to involve them in a real incident. Disaster preparedness can shave off valuable minutes or hours from response time and gives you a competitive edge. No company gets it right all the time—learn from your mistakes, move on, and do better the next time.\n\n194\n\n|\n\nChapter 9: Incident Response",
      "content_length": 2263,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 227,
      "content": "CHAPTER 10 Postmortem Culture: Learning from Failure\n\nBy Daniel Rogers, Murali Suriar, Sue Lueder, Pranjal Deo, and Divya Sudhakar with Gary O’Connor and Dave Rensin\n\nOur experience shows that a truly blameless postmortem culture results in more reli‐ able systems—which is why we believe this practice is important to creating and maintaining a successful SRE organization.\n\nIntroducing postmortems into an organization is as much a cultural change as it is a technical one. Making such a shift can seem daunting. The key takeaway from this chapter is that making this change is possible, and needn’t seem like an insurmounta‐ ble challenge. Don’t emerge from an incident hoping that your systems will eventu‐ ally remedy themselves. You can start small by introducing a very basic postmortem procedure, and then reflect and tune your process to best suit your organization—as with many things, there is no one size that fits all.\n\nWhen written well, acted upon, and widely shared, postmortems can be a very effec‐ tive tool for driving positive organizational change and preventing repeat outages. To illustrate the principles of good postmortem writing, this chapter presents a case study of an actual outage that happened at Google. An example of a poorly written postmortem highlights the reasons why “bad” postmortem practices are damaging to an organization that’s trying to create a healthy postmortem culture. We then com‐ pare the bad postmortem with the actual postmortem that was written after the inci‐ dent, highlighting the principles and best practices of a high-quality postmortem.\n\nThe second part of this chapter shares what we’ve learned about creating incentives for nurturing of a robust postmortem culture and how to recognize (and remedy) the early signs that the culture is breaking down.\n\n195",
      "content_length": 1818,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 228,
      "content": "Finally, we provide tools and templates that you can use to bootstrap a postmortem culture.\n\nFor a comprehensive discussion on blameless postmortem philosophy, see Chapter 15 in our first book, Site Reliability Engineering.\n\nCase Study This case study features a routine rack decommission that led to an increase in ser‐ vice latency for our users. A bug in our maintenance automation, combined with insufficient rate limits, caused thousands of servers carrying production traffic to simultaneously go offline.\n\nWhile the majority of Google’s servers are located in our proprietary datacenters, we also have racks of proxy/cache machines in colocation facilities (or “colos”). Racks in colos that contain our proxy machines are called satellites. Because satellites undergo regular maintenance and upgrades, a number of satellite racks are being installed or decommissioned at any point in time. At Google, these maintenance processes are largely automated.\n\nThe decommission process overwrites the full content of all drives in the rack using a process we call diskerase. Once a machine is sent to diskerase, the data it once stored is no longer retrievable. The steps for a typical rack decommission are as follows:\n\n# Get all active machines in \"satellite\" machines = GetMachines(satellite)\n\n# Send all candidate machines matching \"filter\" to decom SendToDecom(candidates=GetAllSatelliteMachines(), filter=machines)\n\nOur case study begins with a satellite rack that was marked for decommissioning. The diskerase step of the decommission process finished successfully, but the auto‐ mation responsible for the remainder of the machine decommission failed. To debug the failure, we retried the decommission process. The second decommission ran as follows:\n\n# Get all active machines in \"satellite\" machines = GetMachines(satellite)\n\n# \"machines\" is an empty list, because the decom flow has already run. # API bug: an empty list is treated as \"no filter\", rather than \"act on no # machines\"\n\n# Send all candidate machines matching \"filter\" to decom SendToDecom(candidates=GetAllSatelliteMachines(), filter=machines)\n\n# Send all machines in \"candidates\" to diskerase.\n\n196\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 2231,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 229,
      "content": "Within minutes, the disks of all satellite machines, globally, were erased. The machines were rendered inert and could no longer accept connections from users, so subsequent user connections were routed directly to our datacenters. As a result, users experienced a slight increase in latency. Thanks to good capacity planning, very few of our users noticed the issue during the two days it took us to reinstall machines in the affected colo racks. Following the incident, we spent several weeks auditing and adding more sanity checks to our automation to make our decommission work‐ flow idempotent.\n\nThree years after this outage, we experienced a similar incident: a number of satellites were drained, resulting in increased user latency. The action items implemented from the original postmortem dramatically reduced the blast radius and rate of the second incident.\n\nSuppose you were the person responsible for writing the postmortem for this case study. What would you want to know, and what actions would you propose to pre‐ vent this outage from happening again?\n\nLet’s start with a not-so-great postmortem for this incident.\n\nBad Postmortem\n\nPostmortem: All Satellite Machines Sent to Diskerase\n\n2014-August-11\n\nOwner: Shared with: Status: Incident date: Published:\n\nmaxone@, logantwo@, sydneythree@, dylanfour@ satellite-infra-team@ Final 2014-August-11 2014-December-30\n\nExecutive Summary\n\nImpact: Root cause:\n\nAll Satellite machines are sent to diskerase, which practically wiped out Google Edge. dylanfour@ ignored the automation setup and ran the cluster turnup logic manually, which triggered an existing bug.\n\nProblem Summary\n\nDuration of problem: Product(s) affected:\n\n40min satellite-infra-team\n\nBad Postmortem\n\n|\n\n197",
      "content_length": 1735,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 230,
      "content": "% of product affected: All satellite clusters. User impact:\n\nAll queries that normally go to satellites were served from the core instead, causing increased latency. Some ads were not served due to the lost queries. Exact revenue impact unknown at this time. Monitoring alert. Diverting traffic to core followed by manual repair of edge clusters.\n\nRevenue impact:\n\nDetection: Resolution:\n\nBackground (optional)\n\nImpact\n\nUser impact\n\nAll queries that normally go to satellites were instead served from the core, caus‐ ing increased latency to user traffic.\n\nRevenue impact\n\nSome ads were not served due to the lost queries.\n\nRoot Causes and Trigger\n\nCluster turnup/turndown automation is not meant to be idempotent. The tool has safeguards to ensure that certain steps cannot be run more than once. Unfortunately, there is nothing to stop someone from running the code manually as many times as they want. None of the documentation mentioned this gotcha. As a result, most team members think it’s okay to run the process multiple times if it doesn’t work.\n\nThis is exactly what happened during a routine decommissioning of a rack. The rack was being replaced with a new Iota-based satellite. dylanfour@ completely ignored the fact that the turnup had already executed once and was stuck in the first attempt. Due to careless ignorance, they triggered a bad interaction that assigned all the satel‐ lite machines to the diskerase team.\n\nRecovery Efforts\n\nLessons Learned\n\nThings that went well\n\nAlerting caught the issue immediately.\n\nIncident management went well.\n\n198\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 1626,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 231,
      "content": "Things that went poorly\n\nThe team (especially maxone@, logantwo@) never wrote any documentation to tell SREs not to run the automation multiple times, which is ridiculous.\n\nOn-call did not act soon enough to prevent most satellite machines from being erased. This is not the first time that on-call failed to react in time.\n\nWhere we got lucky\n\nCore was able to serve all the traffic that normally would have gone to the Edge. I can’t believe we survived this one!!!\n\nAction Items\n\nAction item Make automation better. Improve paging and alerting. sydneythree@ needs to learn proper cross-site handoff protocol so nobody has to work on duplicate issues. Train humans not to run unsafe commands.\n\nType mitigate detect mitigate\n\nprevent\n\nPriority Owner P2 P2 P2\n\nlogantwo@\n\nP2\n\nTracking bug\n\nBUG6789\n\nGlossary\n\nWhy Is This Postmortem Bad? The example “bad” postmortem contains a number of common failure modes that we try to avoid. The following sections explain how to improve upon this postmortem.\n\nMissing context\n\nFrom the outset, our example postmortem introduces terminology that’s specific to traffic serving (e.g., “satellites”) and lower layers of machine management automa‐ tion at Google (e.g., “diskerase”). If you need to provide additional context as part of the postmortem, use the Background and/or Glossary sections (which can link to longer documents). In this case, both sections were blank.\n\nIf you don’t properly contextualize content when writing a postmortem, the docu‐ ment might be misunderstood or even ignored. It’s important to remember that your audience extends beyond the immediate team.\n\nBad Postmortem\n\n|\n\n199",
      "content_length": 1639,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 232,
      "content": "Key details omitted\n\nMultiple sections contain high-level summaries but lacked important details. For example:\n\nProblem summary\n\nFor outages affecting multiple services, you should present numbers to give a consistent representation of impact. The only numerical data our example pro‐ vides is the duration of the problem. We don’t have enough details to estimate the size or impact of the outage. Even if there is no concrete data, a well- informed estimate is better than no data at all. After all, if you don’t know how to measure it, then you can’t know it’s fixed!\n\nRoot causes and trigger\n\nIdentifying the root causes and trigger is one of the most important reasons to write a postmortem. Our example contains a small paragraph that describes the root causes and trigger, but it doesn’t explore the lower-level details of the issue.\n\nRecovery efforts\n\nA postmortem acts as the record of an incident for its readers. A good postmor‐ tem will let readers know what happened, how the issue was mitigated, and how users were impacted. The answers to many of these questions are typically found in the Recovery Efforts section, which was left empty in our example.\n\nIf an outage merits a postmortem, you should also take the time to accurately capture and document the necessary details. The reader should get a complete view of the outage and, more importantly, learn something new.\n\nKey action item characteristics missing\n\nThe Action Items (AIs) section of our example is missing the core aspects of an actionable plan to prevent recurrence. For example:\n\nThe action items are mostly mitigative. To minimize the likelihood of the outage recurring, you should include some preventative action items and fixes. The one “preventative” action item suggests we “make humans less error-prone.” In gen‐ eral, trying to change human behavior is less reliable than changing automated systems and processes. (Or as Dan Milstein once quipped: “Let’s plan for a future where we’re all as stupid as we are today.”)\n\nAll of the action items have been tagged with an equal priority. There’s no way to determine which action to tackle first.\n\nThe first two action items in the list use ambiguous phrases like “Improve” and “Make better.” These terms are vague and open to interpretation. Using unclear language makes it difficult to measure and understand success criteria.\n\n200\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 2425,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 233,
      "content": "Only one action item was assigned a tracking bug. Without a formal tracking process, action items from postmortems are often forgotten, resulting in outages.\n\nIn the words of Ben Treynor Sloss, Google’s VP for 24/7 Opera‐ tions: “To our users, a postmortem without subsequent action is indistinguishable from no postmortem. Therefore, all postmortems which follow a user-affecting outage must have at least one P[01] bug associated with them. I personally review exceptions. There are very few exceptions.”\n\nCounterproductive finger pointing\n\nEvery postmortem has the potential to lapse into a blameful narrative. Let’s take a look at some examples:\n\nThings that went poorly\n\nThe entire team is blamed for the outage, while two members (maxone@ and logantwo@) are specifically called out.\n\nAction items\n\nThe last item in the list targets sydneythree@ for succumbing to pressure and mismanaging the cross-site handoff.\n\nRoot causes and trigger\n\ndylanfour@ is held solely responsible for the outage.\n\nIt may seem like a good idea to highlight individuals in a postmortem. Instead, this practice leads team members to become risk-averse because they’re afraid of being publicly shamed. They may be motivated to cover up facts critical to understanding and preventing recurrence.\n\nAnimated language\n\nA postmortem is a factual artifact that should be free from personal judgments and subjective language. It should consider multiple perspectives and be respectful of oth‐ ers. Our example postmortem contains multiple examples of undesirable language:\n\nRoot causes and trigger\n\nSuperfluous language (e.g., “careless ignorance”)\n\nThings that went poorly\n\nAnimated text (e.g., “which is ridiculous”)\n\nWhere we got lucky\n\nAn exclamation of disbelief (e.g., “I can’t believe we survived this one!!!”)\n\nBad Postmortem\n\n|\n\n201",
      "content_length": 1815,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 234,
      "content": "Animated language and dramatic descriptions of events distract from the key mes‐ sage and erode psychological safety. Instead, provide verifiable data to justify the severity of a statement.\n\nMissing ownership\n\nDeclaring official ownership results in accountability, which leads to action. Our example postmortem contains several examples of missing ownership:\n\nThe postmortem lists four owners. Ideally, an owner is a single point of contact who is responsible for the postmortem, follow-up, and completion.\n\nThe Action Items section has little or no ownership for its entries. Actions items without clear owners are less likely to be resolved.\n\nIt’s better to have a single owner and multiple collaborators.\n\nLimited audience\n\nOur example postmortem was shared only among members of the team. By default, the document should have been accessible to everyone at the company. We recom‐ mend proactively sharing your postmortem as widely as possible—perhaps even with your customers. The value of a postmortem is proportional to the learning it creates. The more people that can learn from past incidents, the less likely they are to be repeated. A thoughtful and honest postmortem is also a key tool in restoring shaken trust.\n\nAs your experience and comfort grows, you will also likely expand your “audience” to nonhumans. Mature postmortem cultures often add machine-readable tags (and other metadata) to enable downstream analytics.\n\nDelayed publication\n\nOur example postmortem was published four months after the incident. In the interim, had the incident recurred (which in reality, did happen), team members likely would have forgotten key details that a timely postmortem would have cap‐ tured.\n\n202\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 1764,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 235,
      "content": "Good Postmortem\n\nThis is an actual postmortem. In some cases, we fictionalized names of individuals and teams. We also replaced actual values with placeholders to protect sensitive capacity information. In the postmortems that you create for your internal consumption, you should absolutely include specific numbers!\n\nPostmortem: All Satellite Machines Sent to Diskerase\n\n2014-August-11\n\nOwner:\n\nPostmortem: maxone@, logantwo@ Datacenter Automation: sydneythree@ Network: dylanfour@ Server Management: finfive@ all_engineering_employees@google.com Final\n\nShared with: Status: Incident date: Mon, August 11, 2014, 17:10 to 17:50 PST8PDT Published:\n\nFri, August 15, 2014\n\nExecutive Summary\n\nImpact:\n\nRoot cause:\n\nFrontend queries dropped Some ads were not served There was a latency increase for all services normally served from satellite for nearly two days A bug in turndown automation caused all satellite machines, instead of just one rack of satellite machines, to be sent to diskerase. This resulted in all satellite machines entering the decom workflow, which wiped their disks. The result was a global satellite frontend outage.\n\nProblem Summary\n\nDuration of problem:\n\nProduct(s) affected: % of product affected:\n\nMain outage: Mon, August 11, 17:10 to 17:50 PST8PDT Reconstruction work and residual pains through Wed, August 13, 07:46 PST8PDT, then the incident was closed. Frontend Infrastructure, specifically all satellite locations.\n\nGlobal—all traffic normally served from satellites (typically 60% of global queries).\n\nGood Postmortem\n\n|\n\n203",
      "content_length": 1555,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 236,
      "content": "User impact:\n\nRevenue impact: Detection:\n\nResolution:\n\n[Value redacted] frontend queries dropped over a period of 40 minutes ([value redacted] QPS averaged over the period, [value redacted] % of global traffic). Latency increase for all services normally served from satellite for nearly two days. The exact revenue impact unknown at this time. Blackbox alerting: traffic-team was paged with “satellite a12bcd34 failing too many HTTP requests” for ~every satellite in the world. The outage itself was rapidly mitigated by moving all of Google’s frontend traffic to core clusters, at the cost of additional latency for user traffic.\n\nBackground (optional)\n\nIf you’re unfamiliar with frontend traffic serving and the lower layers of serving auto‐ mation at Google, read the glossary before you continue.\n\nImpact\n\nUser impact\n\n[Value redacted] frontend queries dropped over a period of [value redacted] minutes. [Value redacted] QPS averaged over the period, [value redacted] % of global traffic. Our monitoring suggests a much larger crater; however, the data was unreliable as it ceased monitoring satellites that were still serving, thinking they were turned down. The appendix describes how the above numbers were estimated.\n\nThere was a latency increase for all services normally served from satellite for nearly two days:\n\n— [Value redacted] ms RTT spikes for countries near core clusters\n\n— Up to+[value redacted] ms for locations relying more heavily on satellites\n\n(e.g., Australia, New Zealand, India)\n\nRevenue impact\n\nSome ads were not served due to the lost queries. The exact revenue impact is unknown at this time:\n\nDisplay and video: The data has very wide error bars due to day-on-day fluctua‐ tions, but we estimate between [value redacted] % and [value redacted] % of rev‐ enue loss on the day of the outage.\n\nSearch: [Value redacted] % to [value redacted] % loss between 17:00 to 18:00, again with wide error bars.\n\n204\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 1993,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 237,
      "content": "Team impact\n\nThe Traffic team spent ~48 hours with all hands on deck rebuilding satellites.\n\nNST had a higher-than-normal interrupt/pager load because they needed to traffic-engineer overloaded peering links.\n\nSome services may have seen increased responses served at their frontends due to reduced cache hit rate in the GFEs.\n\n— For example, see this thread [link] about [cache-dependent service].\n\n— [Cache-dependent service] saw their cache hit rate at the GFEs drop from\n\n[value redacted ] % to [value redacted] % before slowly recovering.\n\nIncident document\n\n[The link to our incident tracking document has been redacted.]\n\nRoot Causes and Trigger\n\nA longstanding input validation bug in the Traffic Admin server was triggered by the manual reexecution of a workflow to decommission the a12bcd34 satellite. The bug removed the machine constraint on the decom action, sending all satellite machines to decommission.\n\nFrom there, datacenter automation executed the decom workflow, wiping the hard drives of the majority of satellite machines before this action could be stopped.\n\nThe Traffic Admin server provides a ReleaseSatelliteMachines RPC. This handler initiates satellite decommission using three MDB API calls:\n\nLook up the rack name associated with the edge node (e.g., a12bcd34 -> <rack name>).\n\nLook up the machine names associated with the rack (<rack> -> <machine 1>, <machine 2>, etc.).\n\nReassign those machines to diskerase, which indirectly triggers the decommis‐ sion workflow.\n\nThis procedure is not idempotent, due to a known behavior of the MDB API com‐ bined with a missing safety check. If a satellite node was previously successfully sent to decom, step 2 above returns an empty list, which is interpreted in step 3 as the absence of a constraint on a machine hostname.\n\nThis dangerous behavior has been around for a while, but was hidden by the work‐ flow that invokes the unsafe operation: the workflow step invoking the RPC is marked “run once,” meaning that the workflow engine will not reexecute the RPC once it has succeeded.\n\nGood Postmortem\n\n|\n\n205",
      "content_length": 2082,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 238,
      "content": "However, “run once” semantics don’t apply across multiple instances of a workflow. When the Cluster Turnup team manually started another run of the workflow for a12bcd34, this action triggered the admin_server bug.\n\nTimeline/Recovery Efforts\n\n[The link to our Timeline log has been elided for book publication. In a real postmor‐ tem, this information would always be included.]\n\nLessons Learned\n\nThings that went well\n\nEvacuating the edge. GFEs in core are explicitly capacity-planned to allow this to happen, as is the production backbone (aside from peering links; see the Outage list in the next section). This edge evacuation allowed the Traffic team to mitigate promptly without fear.\n\nAutomatic mitigation of catastrophic satellite failure. Cover routes automatically pull traffic from failing satellites back to core clusters, and satellites drain them‐ selves when abnormal churn is detected.\n\nSatellite decom/diskerase worked very effectively and rapidly, albeit as a con‐ fused deputy.\n\nThe outage triggered a quick IMAG response via OMG and the tool proved use‐ ful for ongoing incident tracking. The cross-team response was excellent, and OMG further helped keep everyone talking to each other.\n\nThings that went poorly\n\nOutage\n\nThe Traffic Admin server lacked the appropriate sanity checks on the commands it sent to MDB. All commands should be idempotent, or at least fail-safe on repeat invocations.\n\nMDB did not object to the missing hostname constraint in the ownership change request.\n\nThe decom workflow doesn’t cross-check decom requests with other data sour‐ ces (e.g., planned rack decoms). As a result, there were no objections to the request to trash (many) geographically diverse machines.\n\nThe decom workflow is not rate-limited. Once the machines entered decom, disk erase and other decom steps proceeded at maximum speed.\n\nSome peering links between Google and the world were overloaded as a result of the egress traffic shifting to different locations when satellites stopped serving, and their queries were instead served from core. This resulted in short bursts of\n\n206\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 2159,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 239,
      "content": "congestion to select peers until satellites were restored, and mitigation work by NST to match.\n\nRecovery\n\nReinstalls of satellite machines were slow and unreliable. Reinstallations use TFTP to transmit data, which works poorly when transmitting to satellites at the end of high-latency links.\n\nThe Autoreplacer infrastructure was not able to handle the simultaneous setup of [value redacted] of GFEs at the time of the outage. Matching the velocity of auto‐ mated setups required the labor of many SREs working in parallel performing manual setups. The factors below contributed to the initial slowness of the auto‐ mation: — Overly strict SSH timeouts prevented reliable Autoreplacer operation on very\n\nremote satellites.\n\n— A slow kernel upgrade process was executed regardless of whether the\n\nmachine already had the correct version.\n\n— A concurrency regression in Autoreplacer prevented running more than two\n\nmachine setup tasks per worker machine.\n\n— Confusion about the behavior of the Autoreplacer wasted time and effort.\n\nThe monitoring configuration delta safety checks (25% change) did not trigger when 23% of the targets were removed, but did trigger when the same contents (29% of what remained) were readded. This caused a 30-minute delay in reena‐ bling monitoring of the satellites.\n\n“The installer” has limited staffing. As a result, making changes is difficult and slow.\n\nUse of superuser powers to claw machines back from diskerase left a lot of zom‐ bie state, causing ongoing cleanup pain.\n\nWhere we got lucky\n\nGFEs in core clusters are managed very differently from satellite GFEs. As a result, they were not affected by the decom rampage.\n\nSimilarly, YouTube’s CDN is run as a distinct piece of infrastructure, so You‐ Tube video serving was not affected. Had this failed, the outage would have been much more severe and prolonged.\n\nAction Items\n\nDue to the wide-reaching nature of this incident, we split action items into five themes:\n\nGood Postmortem\n\n|\n\n207",
      "content_length": 1985,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 240,
      "content": "1. Prevention/risk education\n\n2. Emergency response\n\n3. Monitoring/alerting\n\n4. Satellite/edge provisioning\n\n5. Cleanup/miscellaneous\n\nTable 10-1. Prevention/risk education\n\nAction items\n\nType\n\nPriority Owner\n\nTracking bug\n\nAudit all systems capable of turning live servers into paperweights (i.e., not just repairs and diskerase workflow). File bugs to track implementation of bad input rejection to all systems identified in BUG1234. Disallow any single operation from affecting servers spanning namespace/class boundaries. Traffic admin server needs a safety check to not operate on more than [value redacted] number of nodes. Traffic admin server should ask <safety check service> to approve destructive work. MDB should reject operations that do not provide values for an expected-present constraint.\n\ninvestigate\n\nprevent\n\nmitigate\n\nmitigate\n\nprevent\n\nprevent\n\nP1\n\nP1\n\nP1\n\nP1\n\nP0\n\nP0\n\nsydneythree@ BUG1234\n\nsydneythree@ BUG1235\n\nmaxone@\n\nBUG1236\n\ndylanfour@\n\nBUG1237\n\nlogantwo@\n\nBUG1238\n\nlouseven@\n\nBUG1239\n\nTable 10-2. Emergency response\n\nAction items Ensure that serving from core does not overload egress network links. Ensure decom workflow problems are noted under [the link to our emergency stop doc has been redacted] and [the link to our escalations contact page has been redacted]. Add a big-red-buttona disable approach to decom workflows. a A general term for a shut-down switch (e.g., an emergency power-off button) to be used in catastrophic circumstances to avert further damage.\n\nType repair\n\nPriority Owner P2\n\nTracking bug BUG1240\n\nrileysix@\n\nmitigate\n\nP2\n\nlogantwo@ BUG1241\n\nmitigate\n\nP0\n\nmaxone@\n\nBUG1242\n\n208\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 1692,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 241,
      "content": "Table 10-3. Monitoring/alerting\n\nAction items\n\nType\n\nPriority Owner\n\nTracking bug\n\nMonitoring target safety checks should not allow you to push a change that cannot be rolled back. Add an alert when more than [value redacted] % of our machines have been taken away from us. Machines were taken from satellites at 16:38 while the world started paging only at around 17:10.\n\nmitigate\n\ndetect\n\nP2\n\nP1\n\ndylanfour@ BUG1243\n\nrileysix@\n\nBUG1244\n\nTable 10-4. Satellite/edge provisioning\n\nAction items Use iPXE to use HTTPS to make reinstalls more reliable/ faster.\n\nType mitigate\n\nPriority Owner P2\n\nTracking bug\n\ndylanfour@ BUG1245\n\nTable 10-5. Cleanup/miscellaneous\n\nAction items Review MDB-related code in our tools and bring the admin server backup to unwedge turnups/turndowns. Schedule DiRT tests:\n\nType repair\n\nmitigate\n\nPriority Owner P2\n\nrileysix@\n\nTracking bug BUG1246\n\nP2\n\nlouseven@ BUG1247\n\nBring back satellite after diskerase.\n\nDo the same for YouTube CDN.\n\nGlossary\n\nAdmin server\n\nAn RPC server that enables automation to execute privileged operations for frontend serving infrastructure. The automation server is most visibly involved in the implementation of PCRs and cluster turnups/turndowns.\n\nAutoreplacer\n\nA system that moves non-Borgified servers from machine to machine. It’s used to keep services running in the face of machine failures, and also to support fork‐ lifts and colo reconfigs.\n\nBorg\n\nA cluster management system designed to manage tasks and machine resources on a massive scale. Borg owns all of the machines in a Borg cell, and assigns tasks to machines that have resources available.\n\nGood Postmortem\n\n|\n\n209",
      "content_length": 1639,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 242,
      "content": "Decom\n\nAn abbreviation of decommissioning. Decom of equipment is a process that is relevant to many operational teams.\n\nDiskerase\n\nA process (and associated hardware/software systems) to securely wipe produc‐ tion hard drives before they leave Google datacenters. Diskerase is a step in the decom workflow.\n\nGFE (Google Front End)\n\nThe server that the outside world connects to for (almost) all Google services.\n\nIMAG (Incident Management at Google)\n\nA program that establishes a standard, consistent way to handle all types of inci‐ dents—from system outages to natural disasters—and organize an effective response.\n\nMDB (Machine Database)\n\nA system that stores all sorts of information about the state of Google machine inventory.\n\nOMG (Outage Management at Google)\n\nAn incident management dashboard/tool that serves as a central place for track‐ ing and managing all ongoing incidents at Google.\n\nSatellites\n\nSmall, inexpensive racks of machine that serve only nonvideo, frontend traffic from the edge of Google’s network. Almost none of the traditional production cluster infrastructure is available for satellites. Satellites are distinct from the CDN that serves YouTube video content from the edge of Google’s network, and from other places on the wider internet. YouTube CDN was not affected by this incident.\n\nAppendix\n\nWhy is ReleaseSatelliteMachines not idempotent? [The response to this question has been elided.]\n\nWhat happened after the Admin Server assigned all satellites to the diskerase-team?\n\n[The response to this question has been elided.]\n\nWhat was the true QPS loss during the outage?\n\n[The response to this question has been elided.]\n\nIRC logs\n\n[The IRC logs have been elided.]\n\n210\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 1764,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 243,
      "content": "Graphs\n\nFaster latency statistics—what have satellites ever done for us?\n\nEmpirically from this outage, satellites shave [value redacted] ms latency off many locations near core clusters, and up to [value redacted] ms off locations further from our backbone:\n\n[The explanation of the graphs has been elided.]\n\nCore vs. Edge serving load\n\nA nice illustration of the reconstruction effort. Being able to once again serve 50% of traffic from the edge took about 36 hours, and returning to the normal traffic balance took an additional 12 hours (see Figure 10-1 and Figure 10-2).\n\nPeering strain from traffic shifts\n\n[Graph elided.]\n\nThe graph shows packet loss aggregated by network region. There were a few short spikes during the event itself, but the majority of the loss occurred as vari‐ ous regions entered peak with little/no satellite coverage.\n\nPerson vs. Machine, the GFE edition\n\n[Graph explanation of human vs. automated machine setup rates elided.]\n\nFigure 10-1. Core vs. Edge QPS breakdown\n\nGood Postmortem\n\n|\n\n211",
      "content_length": 1025,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 244,
      "content": "Figure 10-2. Core vs. Edge QPS breakdown (alternate representation)\n\nWhy Is This Postmortem Better? This postmortem exemplifies several good writing practices.\n\nClarity\n\nThe postmortem is well organized and explains key terms in sufficient detail. For example:\n\nGlossary\n\nA well-written glossary makes the postmortem accessible and comprehensible to a broad audience.\n\nAction items\n\nThis was a large incident with many action items. Grouping action items by theme makes it easier to assign owners and priorities.\n\n212\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 575,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 245,
      "content": "Quantifiable metrics\n\nThe postmortem presents useful data on the incident, such as cache hit ratios, traffic levels, and duration of the impact. Relevant sections of the data are pre‐ sented with links back to the original sources. This data transparency removes ambiguity and provides context for the reader.\n\nConcrete action items\n\nA postmortem with no action items is ineffective. These action items have a few nota‐ ble characteristics:\n\nOwnership\n\nAll action items have both an owner and a tracking number.\n\nPrioritization\n\nAll action items are assigned a priority level.\n\nMeasurability\n\nThe action items have a verifiable end state (e.g., “Add an alert when more than X% of our machines have been taken away from us”).\n\nPreventative action\n\nEach action item “theme” has Prevent/Mitigate action items that help avoid out‐ age recurrence (for example, “Disallow any single operation from affecting servers spanning namespace/class boundaries”).\n\nBlamelessness\n\nThe authors focused on the gaps in system design that permitted undesirable failure modes. For example:\n\nThings that went poorly\n\nNo individual or team is blamed for the incident.\n\nRoot cause and trigger\n\nFocuses on “what” went wrong, not “who” caused the incident.\n\nAction items\n\nAre aimed at improving the system instead of improving people.\n\nDepth\n\nRather than only investigating the proximate area of the system failure, the postmor‐ tem explores the impact and system flaws across multiple teams. Specifically:\n\nGood Postmortem\n\n|\n\n213",
      "content_length": 1505,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 246,
      "content": "Impact\n\nThis section contains lots of details from various perspectives, making it bal‐ anced and objective.\n\nRoot cause and trigger\n\nThis section performs a deep dive on the incident and arrives at a root cause and trigger.\n\nData-driven conclusions\n\nAll of the conclusions presented are based on facts and data. Any data used to arrive at a conclusion is linked from the document.\n\nAdditional resources\n\nThese present further useful information in the form of graphs. Graphs are explained to give context to readers who aren’t familiar with the system.\n\nPromptness\n\nThe postmortem was written and circulated less than a week after the incident was closed. A prompt postmortem tends to be more accurate because information is fresh in the contributors’ minds. The people who were affected by the outage are waiting for an explanation and some demonstration that you have things under control. The longer you wait, the more they will fill the gap with the products of their imagination. That seldom works in your favor!\n\nConciseness\n\nThe incident was a global one, impacting multiple systems. As a result, the postmor‐ tem recorded and subsequently parsed a lot of data. Lengthy data sources, such as chat transcripts and system logs, were abstracted, with the unedited versions linked from the main document. Overall, the postmortem strikes a balance between verbo‐ sity and readability.\n\nOrganizational Incentives Ideally, senior leadership should support and encourage effective postmortems. This section describes how an organization can incentivize a healthy postmortem culture. We highlight warning signs that the culture is failing and offer some solutions. We also provide tools and templates to streamline and automate the postmortem process.\n\nModel and Enforce Blameless Behavior To properly support postmortem culture, engineering leaders should consistently exemplify blameless behavior and encourage blamelessness in every aspect of post‐\n\n214\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 2013,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 247,
      "content": "mortem discussion. You can use a few concrete strategies to enforce blameless behav‐ ior in an organization.\n\nUse blameless language\n\nBlameful language stifles collaboration between teams. Consider the following sce‐ nario:\n\nSandy missed a service Foo training and wasn’t sure how to run a particular update command. The delay ultimately prolonged an outage.\n\nSRE Jesse [to Sandy’s manager]: “You’re the manager; why aren’t you making sure that everyone finishes the training?”\n\nThe exchange includes a leading question that will instantly put the recipient on the defensive. A more balanced response would be:\n\nSRE Jesse [to Sandy’s manager]: “Reading the postmortem, I see that the on-caller missed an important training that would have allowed them to resolve the outage more quickly. Maybe team members should be required to complete this training before joining the on-call rotation? Or we could remind them that if they get stuck to please quickly escalate. After all, escalation is not a sin—especially if it helps lower customer pain! Long term, we shouldn’t really rely so much on training, as it’s easy to forget in the heat of the moment.”\n\nInclude all incident participants in postmortem authoring\n\nIt can be easy to overlook key contributing factors to an outage when the postmortem is written in isolation or by a single team.\n\nGather feedback\n\nA clear review process and communication plan for postmortems can help prevent blameful language and perspectives from propagating within an organization. For a suggested structured review process, see the section “Postmortem checklist” on page 221.\n\nReward Postmortem Outcomes When well written, acted upon, and widely shared, postmortems are an effective vehicle for driving positive organizational change and preventing repeat outages. Consider the following strategies to incentivize postmortem culture.\n\nReward action item closeout\n\nIf you reward engineers for writing postmortems, but not for closing the associated action items, you risk an unvirtuous cycle of unclosed postmortems. Ensure that incentives are balanced between writing the postmortem and successfully implement‐ ing its action plan.\n\nOrganizational Incentives\n\n|\n\n215",
      "content_length": 2199,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 248,
      "content": "Reward positive organizational change\n\nYou can incentivize widespread implementation of postmortem lessons by present‐ ing postmortems as an opportunity to expand impact across an organization. Reward this level of impact with peer bonuses, positive performance reviews, promotion, and the like.\n\nHighlight improved reliability\n\nOver time, an effective postmortem culture leads to fewer outages and more reliable systems. As a result, teams can focus on feature velocity instead of infrastructure patching. It’s intrinsically motivating to highlight these improvements in reports, presentations, and performance reviews.\n\nHold up postmortem owners as leaders\n\nCelebrating postmortems through emails or meetings, or by giving the authors an opportunity to present lessons learned to an audience, can appeal to individuals that appreciate public accolades. Setting up the owner as an “expert” on a type of failure and its avoidance can be rewarding for many engineers who seek peer acknowledg‐ ment. For example, you might hear someone say, “Talk to Sara, she’s an expert now. She just coauthored a postmortem where she figured out how to fix that gap!”\n\nGamification\n\nSome individuals are incentivized by a sense of accomplishment and progress toward a larger goal, such as fixing system weaknesses and increasing reliability. For these individuals, a scoreboard or burndown of postmortem action items can be an incen‐ tive. At Google, we hold “FixIt” weeks twice a year. SREs who close the most post‐ mortem action items receive small tokens of appreciation and (of course) bragging rights. Figure 10-3 shows an example of a postmortem leaderboard.\n\n216\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 1711,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 249,
      "content": "Figure 10-3. Postmortem leaderboard\n\nShare Postmortems Openly In order to maintain a healthy postmortem culture within an organization, it’s important to share postmortems as widely as possible. Implementing even one of the following tactics can help.\n\nShare announcements across the organization\n\nAnnounce the availability of the postmortem draft on your internal communication channels, email, Slack, and the like. If you have a regular company all-hands, make it a practice to share a recent postmortem of interest.\n\nOrganizational Incentives\n\n|\n\n217",
      "content_length": 553,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 250,
      "content": "Conduct cross-team reviews\n\nConduct cross-team reviews of postmortems. In these reviews, a team walks though their incident while other teams ask questions and learn vicariously. At Google, sev‐ eral offices have informal Postmortem Reading Clubs that are open to all employees.\n\nIn addition, a cross-functional group of developers, SREs, and organizational leaders reviews the overall postmortem process. These folks meet monthly to review the effectiveness of the postmortem process and template.\n\nHold training exercises\n\nUse the Wheel of Misfortune when training new engineers: a cast of engineers reenacts a previous postmortem, assuming roles laid out in the postmortem. The original Incident Commander attends to help make the experience as “real” as possi‐ ble.\n\nReport incidents and outages weekly\n\nCreate a weekly outage report containing the incidents and outages from the past seven days. Share the report with as wide an audience as possible. From the weekly outages, compile and share a periodic greatest hits report.\n\nRespond to Postmortem Culture Failures The breakdown of postmortem culture may not always be obvious. The following are some common failure patterns and recommended solutions.\n\nAvoiding association\n\nDisengaging from the postmortem process is a sign that postmortem culture at an organization is failing. For example, suppose SRE Director Parker overhears the fol‐ lowing conversation:\n\nSWE Sam: Wow, did you hear about that huge blow-up?\n\nSWE Riley: Yeah, it was terrible. They’ll have to write a postmortem now.\n\nSWE Sam: Oh no! I’m so glad I’m not involved with that.\n\nSWE Riley: Yeah, I really wouldn’t want to be in the meeting where that one is discussed.\n\nEnsuring that high-visibility postmortems are reviewed for blameful prose can help prevent this kind of avoidance. In addition, sharing high-quality examples and dis‐ cussing how those involved were rewarded can help reengage individuals.\n\n218\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 1996,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 251,
      "content": "Failing to reinforce the culture\n\nResponding when a senior executive uses blameful language can be challenging. Con‐ sider the following statement made by senior leadership at a meeting about an outage:\n\nVP Ash: I know we are supposed to be blameless, but this is a safe space. Someone must have known beforehand this was a bad idea, so why didn’t you listen to that person?\n\nMitigate the damage by moving the narrative in a more constructive direction. For example:\n\nSRE Dana: Hmmm, I’m sure everyone had the best intent, so to keep it blameless, maybe we ask generically if there were any warning signs we could have heeded, and why we might have dismissed them.\n\nIndividuals act in good faith and make decisions based on the best information avail‐ able. Investigating the source of misleading information is much more beneficial to the organization than assigning blame. (If you have encountered Agile principles, this should be familiar to you.)\n\nLacking time to write postmortems\n\nQuality postmortems take time to write. When a team is overloaded with other tasks, the quality of postmortems suffers. Subpar postmortems with incomplete action items make a recurrence far more likely. Postmortems are letters you write to future team members: it’s very important to keep a consistent quality bar, lest you acciden‐ tally teach future teammates a bad lesson. Prioritize postmortem work, track the postmortem completion and review, and allow teams adequate time to implement the associated action plan. The tooling we discuss in the section “Tools and Tem‐ plates” on page 220 can help with these activities.\n\nRepeating incidents\n\nIf teams are experiencing failures that mirror previous incidents, it’s time to dig deeper. Consider asking questions like:\n\nAre action items taking too long to close?\n\nIs feature velocity trumping reliability fixes?\n\nAre the right action items being captured in the first place?\n\nIs the faulty service overdue for a refactor?\n\nAre people putting Band-Aids on a more serious problem?\n\nOrganizational Incentives\n\n|\n\n219",
      "content_length": 2052,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 252,
      "content": "If you uncovered a systemic process or technical problem, it’s time to take a step back and consider the overall service health. Bring the postmortem collaborators from each similar incident together to discuss the best course of action to prevent repeats.\n\nTools and Templates A set of tools and templates can bootstrap a postmortem culture by making writing postmortems and managing the associated data easier. There are a number of resour‐ ces from Google and other companies that you can leverage in this space.\n\nPostmortem Templates Templates make it easier to write complete postmortems and share them across an organization. Using a standard format makes postmortems more accessible for read‐ ers outside the domain. You can customize the template to fit your needs. For exam‐ ple, it may be useful to capture team-specific metadata like hardware make/model for a datacenter team, or Android versions affected for a mobile team. You can then add customizations as the team matures and performs more sophisticated postmortems.\n\nGoogle’s template\n\nGoogle has shared a version of our postmortem template in Google Docs format at http://g.co/SiteReliabilityWorkbookMaterials. Internally, we primarily use Docs to write postmortems because it facilitates collaboration via shared editing rights and comments. Some of our internal tools prepopulate this template with metadata to make the postmortem easier to write. We leverage Google Apps Script to automate parts of the authoring, and capture a lot of the data into specific sections and tables to make it easier for our postmortem repository to parse out data for analysis.\n\nOther industry templates\n\nSeveral other companies and individuals have shared their postmortem templates:\n\nPager Duty\n\nAn adaptation of the original Google Site Reliability Engineering book template\n\nA list of four templates hosted on GitHub\n\nGitHub user Julian Dunn\n\nServer Fault\n\n220\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 1973,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 253,
      "content": "Postmortem Tooling As of this writing, Google’s postmortem management tooling is not available for external use (check our blog for the latest updates). We can, however, explain how our tools facilitate postmortem culture.\n\nPostmortem creation\n\nOur incident management tooling collects and stores a lot of useful data about an incident and pushes that data automatically into the postmortem. Examples of data we push includes:\n\nIncident Commander and other roles\n\nDetailed incident timeline and IRC logs\n\nServices affected and root-cause services\n\nIncident severity\n\nIncident detection mechanisms\n\nPostmortem checklist\n\nTo help authors ensure a postmortem is properly completed, we provide a postmor‐ tem checklist that walks the owner through key steps. Here are just a few example checks on the list:\n\nPerform a complete assessment of incident impact.\n\nConduct sufficiently detailed root-cause analysis to drive action item planning.\n\nEnsure action items are vetted and approved by the technical leads of the service.\n\nShare the postmortem with the wider organization.\n\nThe full checklist is available at http://g.co/SiteReliabilityWorkbookMaterials.\n\nPostmortem storage\n\nWe store postmortems in a tool called Requiem so it’s easy for any Googler to find them. Our incident management tool automatically pushes all postmortems to Requiem, and anyone in the organization can post their postmortem for all to see. We have thousands of postmortems stored, dating back to 2009. Requiem parses out metadata from individual postmortems and makes it available for searching, analysis, and reporting.\n\nTools and Templates\n\n|\n\n221",
      "content_length": 1623,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 254,
      "content": "Postmortem follow-up\n\nOur postmortems are stored in Requiem’s database. Any resulting action items are filed as bugs in our centralized bug tracking system. Consequently, we can monitor the closure of action items from each postmortem. With this level of tracking, we can ensure that action items don’t slip through the cracks, leading to increasingly unsta‐ ble services. Figure 10-4 shows a mockup of postmortem action item monitoring enabled by our tooling.\n\nFigure 10-4. Postmortem action item monitoring\n\nPostmortem analysis\n\nOur postmortem management tool stores its information in a database for analysis. Teams can use the data to write reports about their postmortem trends and identify their most vulnerable systems. This helps us uncover underlying sources of instability or incident management dysfunctions that may otherwise go unnoticed. For exam‐ ple, Figure 10-5 shows charts that were built with our analysis tooling. These charts show us trends like how many postmortems we have per month per organization, incident mean duration, time to detect, time to resolve, and blast radius.\n\n222\n\n|\n\nChapter 10: Postmortem Culture: Learning from Failure",
      "content_length": 1162,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 255,
      "content": "Figure 10-5. Postmortem analysis\n\nOther industry tools\n\nHere are some third-party tools that can help you create, organize, and analyze postmortems:\n\nPager Duty Postmortems\n\nMorgue by Etsy\n\nVictorOps\n\nAlthough it’s impossible to fully automate every step of writing postmortems, we’ve found that postmortem templates and tooling make the process run more smoothly. These tools free up time, allowing authors to focus on the critical aspects of the post‐ mortem, such as root-cause analysis and action item planning.\n\nConclusion Ongoing investment in cultivating a postmortem culture pays dividends in the form of fewer outages, a better overall experience for users, and more trust from the people that depend on you. Consistent application of these practices results in better system design, less downtime, and more effective and happier engineers. If the worst does happen and an incident recurs, you will suffer less damage and recover faster and have even more data to continue reinforcing production.\n\nConclusion\n\n|\n\n223",
      "content_length": 1025,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 257,
      "content": "CHAPTER 11 Managing Load\n\nBy Cooper Bethea, Gráinne Sheerin, Jennifer Mace, and Ruth King with Gary Luo and Gary O’Connor\n\nNo service is 100% available 100% of the time: clients can be inconsiderate, demand can grow fifty-fold, a service might crash in response to a traffic spike, or an anchor might pull up a transatlantic cable. There are people who depend upon your service, and as service owners, we care about our users. When faced with these chains of out‐ age triggers, how can we make our infrastructure as adaptive and reliable as possible?\n\nThis chapter describes Google’s approach to traffic management with the hope that you can use these best practices to improve the efficiency, reliability, and availability of your services. Over the years, we have discovered that there’s no single solution for equalizing and stabilizing network load. Instead, we use a combination of tools, tech‐ nologies, and strategies that work in harmony to help keep our services reliable.\n\nBefore we dive in to this chapter, we recommend reading the philosophies discussed in Chapters 19 (“Load Balancing at the Frontend”) and 20 (“Load Balancing in the Datacenter”) of our first SRE book.\n\nGoogle Cloud Load Balancing These days, most companies don’t develop and maintain their own global load bal‐ ancing solutions, instead opting to use load balancing services from a larger public cloud provider. We’ll discuss Google Cloud Load Balancer (GCLB) as a concrete example of large-scale load balancing, but nearly all of the best practices we describe also apply to other cloud providers’ load balancers.\n\nGoogle has spent the past 18 years building infrastructure to make our services fast and reliable. Today we use these systems to serve YouTube, Maps, Gmail, Search, and many other products and services. GCLB is our publicly consumable global load\n\n225",
      "content_length": 1849,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 258,
      "content": "balancing solution, and is the externalization of one of our internally developed global load balancing systems.\n\nThis section describes the components of GCLB and how they work together to serve user requests. We trace a typical user request from its creation to delivery at its desti‐ nation. The Niantic Pokémon GO case study provides a concrete implementation of GCLB in the real world.\n\nChapter 19 of our first SRE book described how DNS-based load balancing is the simplest and most effective way to balance load before the user’s connection even starts. We also discussed an endemic problem of this approach: it relies on client cooperation to properly expire and refetch DNS records. For this reason, GCLB does not use DNS load balancing.\n\nInstead, we use anycast, a method for sending clients to the closest cluster without relying on DNS geolocation. Google’s global load balancer knows where the clients are located and directs packets to the closest web service, providing low latency to users while using a single virtual IP (VIP). Using a single VIP means we can increase the time to live (TTL) of our DNS records, which further reduces latency.\n\nAnycast Anycast is a network addressing and routing methodology. It routes datagrams from a single sender to the topologically nearest node in a group of potential receivers, which are all identified by the same destination IP address. Google announces IPs via Border Gateway Protocol (BGP) from multiple points in our network. We rely on the BGP routing mesh to deliver packets from a user to the closest frontend location that can terminate a transmission control protocol (TCP) session. This deployment elimi‐ nates the problems of unicast IP proliferation and finding the closest frontend for a user. Two main issues remain:\n\nToo many nearby users can overwhelm a frontend site.\n\nBGP route calculation might reset connections.\n\nConsider an ISP that frequently recalculates its BGP routes such that one of its users prefers either of two frontend sites. Each time the BGP route “flaps,” all in-progress TCP streams are reset as the unfortunate user’s packets are directed to a new front‐ end with no TCP session state. To address these problems, we have leveraged our connection-level load balancer, Maglev (described shortly), to cohere TCP streams even when routes flap. We refer to this technique as stabilized anycast.\n\nStabilized anycast\n\nAs shown in Figure 11-1, Google implements stabilized anycast using Maglev, our custom load balancer. To stabilize anycast, we provide each Maglev machine with a\n\n226\n\n|\n\nChapter 11: Managing Load",
      "content_length": 2604,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 259,
      "content": "way to map client IPs to the closest Google frontend site. Sometimes Maglev pro‐ cesses a packet destined for an anycast VIP for a client that is closer to another front‐ end site. In this case, Maglev forwards that packet to another Maglev on a machine located at the closest frontend site for delivery. The Maglev machines at the closest frontend site then simply treat the packet as they would any other packet, and route it to a local backend.\n\nFigure 11-1. Stabilized anycast\n\nMaglev Maglev, shown in Figure 11-2, is Google’s custom distributed packet-level load bal‐ ancer. An integral part of our cloud architecture, Maglev machines manage incoming traffic to a cluster. They provide stateful TCP-level load balancing across our front‐ end servers. Maglev differs from other traditional hardware load balancers in a few key ways:\n\nAll packets destined for a given IP address can be evenly spread across a pool of Maglev machines via Equal-Cost Multi-Path (ECMP) forwarding. This enables us to boost Maglev capacity by simply adding servers to a pool. Spreading pack‐ ets evenly also enables Maglev redundancy to be modeled as N + 1, enhancing availability and reliability over traditional load balancing systems (which typi‐ cally rely on active/passive pairs to give 1 + 1 redundancy).\n\nMaglev is a Google custom solution. We control the system end-to-end, which allows us to experiment and iterate quickly.\n\nGoogle Cloud Load Balancing\n\n|\n\n227",
      "content_length": 1452,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 260,
      "content": "Maglev runs on commodity hardware in our datacenters, which greatly simplifies deployment.\n\nFigure 11-2. Maglev\n\nMaglev packet delivery uses consistent hashing and connection tracking. These techni‐ ques coalesce TCP streams at our HTTP reverse proxies (also known as Google Front Ends, or GFEs), which terminate TCP sessions. Consistent hashing and connection tracking are key to Maglev’s ability to scale by packet rather than by number of con‐ nections. When a router receives a packet destined for a VIP hosted by Maglev, the router forwards the packet to any Maglev machine in the cluster through ECMP. When a Maglev receives a packet, it computes the packet’s 5-tuple hash1 and looks up the hash value in its connection tracking table, which contains routing results for recent connections. If Maglev finds a match and the selected backend service is still healthy, it reuses the connection. Otherwise, Maglev falls back to consistent hashing to choose a backend. The combination of these techniques eliminates the need to share connection state among individual Maglev machines.\n\n1 5-tuple includes the following: source address, destination address, source port, destination port, and the\n\ntransport protocol type.\n\n228\n\n|\n\nChapter 11: Managing Load",
      "content_length": 1257,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 261,
      "content": "Global Software Load Balancer GSLB is Google’s Global Software Load Balancer. It allows us to balance live user traf‐ fic between clusters so that we can match user demand to available service capacity, and so we can handle service failures in a way that’s transparent to users. As shown in Figure 11-3, GSLB controls both the distribution of connections to GFEs and the dis‐ tribution of requests to backend services. GSLB allows us to serve users from back‐ ends and GFEs running in different clusters. In addition to load balancing between frontends and backends, GSLB understands the health of backend services and can automatically drain traffic away from failed clusters.\n\nFigure 11-3. GSLB\n\nGoogle Front End As shown in Figure 11-4, the GFE sits between the outside world and various Google services (web search, image search, Gmail, etc.) and is frequently the first Google server a client HTTP(S) request encounters. The GFE terminates the client’s TCP and SSL sessions and inspects the HTTP header and URL path to determine which back‐ end service should handle the request. Once the GFE decides where to send the request, it reencrypts the data and forwards the request. For more information on how this encryption process works, see our whitepaper “Encryption in Transit in Google Cloud”.\n\nThe GFE is also responsible for health-checking its backends. If a backend server returns a negative acknowledgment (“NACKs” the request) or times out health checks, GFEs stop sending traffic to the failed backend. We use this signal to update GFE backends without impacting uptime. By putting GFE backends into a mode in which they fail health checks while continuing to respond to in-flight requests, we can gracefully remove GFE backends from service without disrupting any user\n\nGoogle Cloud Load Balancing\n\n|\n\n229",
      "content_length": 1820,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 262,
      "content": "requests. We call this “lame duck” mode and we discuss it in more detail in Chapter 20 of the first SRE book.\n\nFigure 11-4. GFE\n\nThe GFEs also maintain persistent sessions to all their recently active backends so that a connection is ready to use as soon as a request arrives. This strategy helps reduce latency for our users, particularly in scenarios when we use SSL to secure the connection between GFE and the backend.\n\nGCLB: Low Latency Our network provisioning strategy aims to reduce end-user latency to our services. Because negotiating a secure connection via HTTPS requires two network round trips between client and server, it’s particularly important that we minimize the latency of this leg of the request time. To this end, we extended the edge of our net‐ work to host Maglev and GFE. These components terminate SSL as close to the user as possible, then forward requests to backend services deeper within our network over long-lived encrypted connections.\n\nWe built GCLB atop this combined Maglev/GFE-augmented edge network. When customers create a load balancer, we provision an anycast VIP and program Maglev\n\n230\n\n|\n\nChapter 11: Managing Load",
      "content_length": 1161,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 263,
      "content": "to load-balance it globally across GFEs at the edge of our network. GFE’s role is to terminate SSL, accept and buffer HTTP requests, forward those requests to the cus‐ tomer’s backend services, and then proxy the responses back to users. GSLB provides the glue between each layer: it enables Maglev to find the nearest GFE location with available capacity, and enables GFE to route requests to the nearest VM instance group with available capacity.\n\nGCLB: High Availability In the interest of providing high availability to our customers, GCLB offers an availa‐ bility SLA2 of 99.99%. In addition, GCLB provides support tools that enable our cus‐ tomers to improve and manage the availability of their own applications. It’s useful to think of the load balancing system as a sort of traffic manager. During normal opera‐ tion, GCLB routes traffic to the nearest backend with available capacity. When one instance of your service fails, GCLB detects the failure on your behalf and routes traf‐ fic to healthy instances.\n\nCanarying and gradual rollouts help GCLB maintain high availability. Canarying is one of our standard release procedures. As described in Chapter 16 this process involves deploying a new application to a very small number of servers, then gradu‐ ally increasing traffic and carefully observing system behavior to verify that there are no regressions. This practice reduces the impact of any regressions by catching them early in the canary phase. If the new version crashes or otherwise fails health checks, the load balancer routes around it. If you detect a nonfatal regression, you can administratively remove the instance group from the load balancer without touching the main version of the application.\n\nCase Study 1: Pokémon GO on GCLB Niantic launched Pokémon GO in the summer of 2016. It was the first new Pokémon game in years, the first official Pokémon smartphone game, and Niantic’s first project in concert with a major entertainment company. The game was a runaway hit and more popular than anyone expected—that summer you’d regularly see players gath‐ ering to duel around landmarks that were Pokémon Gyms in the virtual world.\n\nPokémon GO’s success greatly exceeded the expectations of the Niantic engineering team. Prior to launch, they load-tested their software stack to process up to 5x their most optimistic traffic estimates. The actual launch requests per second (RPS) rate was nearly 50x that estimate—enough to present a scaling challenge for nearly any software stack. To further complicate the matter, the world of Pokémon GO is highly\n\n2 See the Google Cloud Platform blog post “SLOs, SLIs, SLAs, Oh My—CRE Life Lessons” for an explanation of\n\nthe difference between SLOs and SLAs.\n\nGoogle Cloud Load Balancing\n\n|\n\n231",
      "content_length": 2767,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 264,
      "content": "interactive and globally shared among its users. All players in a given area see the same view of the game world and interact with each other inside that world. This requires that the game produce and distribute near-real-time updates to a state shared by all participants.\n\nScaling the game to 50x more users required a truly impressive effort from the Nian‐ tic engineering team. In addition, many engineers across Google provided their assis‐ tance in scaling the service for a successful launch. Within two days of migrating to GCLB, the Pokemon GO app became the single largest GCLB service, easily on par with the other top 10 GCLB services.\n\nAs shown in Figure 11-5, when it launched, Pokémon GO used Google’s regional Network Load Balancer (NLB) to load-balance ingress traffic across a Kubernetes cluster. Each cluster contained pods of Nginx instances, which served as Layer 7 reverse proxies that terminated SSL, buffered HTTP requests, and performed routing and load balancing across pods of application server backends.\n\nFigure 11-5. Pokémon GO (pre-GCLB)\n\nNLB is responsible for load balancing at the IP layer, so a service that uses NLB effec‐ tively becomes a backend of Maglev. In this case, relying on NLB had the following implications for Niantic:\n\n232\n\n|\n\nChapter 11: Managing Load",
      "content_length": 1302,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 265,
      "content": "The Nginx backends were responsible for terminating SSL for clients, which required two round trips from a client device to Niantic’s frontend proxies.\n\nThe need to buffer HTTP requests from clients led to resource exhaustion on the proxy tier, particularly when clients were only able to send bytes slowly.\n\nLow-level network attacks such as SYN flood could not be effectively ameliorated by a packet-level proxy.\n\nIn order to scale appropriately, Niantic needed a high-level proxy operating on a large edge network. This solution wasn’t possible with NLB.\n\nMigrating to GCLB\n\nA large SYN flood attack made migrating Pokémon GO to GCLB a priority. This migration was a joint effort between Niantic and the Google Customer Reliability Engineering (CRE) and SRE teams. The initial transition took place during a traffic trough and, at the time, was unremarkable. However, unforeseen problems emerged for both Niantic and Google as traffic ramped up to peak. Both Google and Niantic discovered that the true client demand for Pokémon GO traffic was 200% higher than previously observed. The Niantic frontend proxies received so many requests that they weren’t able to keep pace with all inbound connections. Any connection refused in this way wasn’t surfaced in the monitoring for inbound requests. The backends never had a chance.\n\nThis traffic surge caused a classic cascading failure scenario. Numerous backing serv‐ ices for the API—Cloud Datastore, Pokémon GO backends and API servers, and the load balancing system itself—exceeded the capacity available to Niantic’s cloud project. The overload caused Niantic’s backends to become extremely slow (rather than refuse requests), manifesting as requests timing out to the load balancing layer. Under this circumstance, the load balancer retried GET requests, adding to the sys‐ tem load. The combination of extremely high request volume and added retries stressed the SSL client code in the GFE at an unprecedented level, as it tried to recon‐ nect to unresponsive backends. This induced a severe performance regression in GFE such that GCLB’s worldwide capacity was effectively reduced by 50%.\n\nAs backends failed, the Pokémon GO app attempted to retry failed requests on behalf of users. At the time, the app’s retry strategy was a single immediate retry, followed by constant backoff. As the outage continued, the service sometimes returned a large number of quick errors—for example, when a shared backend restarted. These error responses served to effectively synchronize client retries, producing a “thundering herd” problem, in which many client requests were issued at essentially the same time. As shown in Figure 11-6, these synchronized request spikes ramped up enor‐ mously to 20× the previous global RPS peak.\n\nGoogle Cloud Load Balancing\n\n|\n\n233",
      "content_length": 2810,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 266,
      "content": "Figure 11-6. Traffic spikes caused by synchronous client retries\n\nResolving the issue\n\nThese request spikes, combined with the GFE capacity regression, resulted in queu‐ ing and high latency for all GCLB services. Google’s on-call Traffic SREs acted to reduce collateral damage to other GCLB users by doing the following:\n\n1. Isolating GFEs that could serve Pokémon GO traffic from the main pool of load balancers.\n\n2. Enlarging the isolated Pokémon GO pool until it could handle peak traffic despite the performance regression. This action moved the capacity bottleneck from GFE to the Niantic stack, where servers were still timing out, particularly when client retries started to synchronize and spike.\n\n3. With Niantic’s blessing, Traffic SRE implemented administrative overrides to limit the rate of traffic the load balancers would accept on behalf of Pokémon GO. This strategy contained client demand enough to allow Niantic to reestab‐ lish normal operation and commence scaling upward.\n\nFigure 11-7 shows the final network configuration.\n\n234\n\n|\n\nChapter 11: Managing Load",
      "content_length": 1081,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 267,
      "content": "Figure 11-7. Pokémon GO GCLB\n\nFuture-proofing\n\nIn the wake of this incident, Google and Niantic both made significant changes to their systems. Niantic introduced jitter and truncated exponential backoff3 to their clients, which curbed the massive synchronized retry spikes experienced during cas‐ cading failure. Google learned to consider GFE backends as a potentially significant source of load, and instituted qualification and load testing practices to detect GFE performance degradation caused by slow or otherwise misbehaving backends. Finally, both companies realized they should measure load as close to the client as possible. Had Niantic and Google CRE been able to accurately predict client RPS demand, we would have preemptively scaled up the resources allocated to Niantic even more than we did before conducting the switch to GCLB.\n\n3 For more information on this topic, see Chapter 22 of the first SRE book.\n\nGoogle Cloud Load Balancing\n\n|\n\n235",
      "content_length": 960,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 268,
      "content": "Autoscaling Tools like GCLB can help you balance load efficiently across your fleet, making your service more stable and reliable. Sometimes you simply don’t have enough resources reserved to manage your existing traffic. You can use autoscaling to scale your fleet strategically. Whether you increase the resources per machine (vertical scaling) or increase the total number of machines in the pool (horizontal scaling), autoscaling is a powerful tool and, when used correctly, can enhance your service availability and utilization. Conversely, if misconfigured or misused, autoscaling can negatively impact your service. This section describes some best practices, common failure modes, and current limitations of autoscaling.\n\nHandling Unhealthy Machines Autoscaling normally averages utilization over all instances regardless of their state, and assumes that instances are homogeneous in terms of request processing effi‐ ciency. Autoscaling runs into problems when machines are not serving (known as unhealthy instances) but are still counted toward the utilization average. In this sce‐ nario, autoscaling simply won’t occur. A variety of issues can trigger this failure mode, including:\n\nInstances taking a long time to get ready to serve (e.g., when loading a binary or warming up)\n\nInstances stuck in a nonserving state (i.e., zombies)\n\nWe can improve this situation using a variety of tactics. You can make the following improvements in combination or individually:\n\nLoad balancing\n\nAutoscale using a capacity metric as observed by the load balancer. This will automatically discount unhealthy instances from the average.\n\nWait for new instances to stabilize before collecting metrics\n\nYou can configure autoscaler to collect information about new instances only once new instances become healthy (GCE refers to this period of inactivity as a cool-down period).\n\nAutoscale and autoheal\n\nAutohealing monitors your instances and attempts to restart them if they are unhealthy. Typically, you configure your autohealer to monitor a health metric exposed by your instances. If autohealer detects that an instance is down or unhealthy, it will attempt a restart. When configuring your autohealer, it’s\n\n236\n\n|\n\nChapter 11: Managing Load",
      "content_length": 2241,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 269,
      "content": "important to ensure you leave sufficient time for your instances to become healthy after a restart.\n\nUsing a mix of these solutions, you can optimize horizontal autoscaling to keep track only of healthy machines. Remember that when running your service, autoscaler will continuously adjust the size of your fleet. Creating new instances is never instant.\n\nWorking with Stateful Systems A stateful system sends all requests in a user session consistently to the same backend server. If these pathways are overburdened, adding more instances (i.e., horizontal scaling) won’t help. Intelligent, task-level routing that spreads the load around (e.g., using consistent hashing4) is a better strategy for stateful systems.\n\nVertical autoscaling can be useful in stateful systems. When used in combination with task-level balancing to even out load on your system, vertical autoscaling can help absorb short-term hotspots. Use this strategy with caution: because vertical autoscaling is typically uniform across all instances, your low-traffic instances may grow unnecessarily large.\n\nConfiguring Conservatively Using autoscaling to scale up is more important and less risky than using it to scale down since a failure to scale up can result in overload and dropped traffic. By design, most autoscaler implementations are intentionally more sensitive to jumps in traffic than to drops in traffic. When scaling up, autoscalers are inclined to add extra serving capacity quickly. When scaling down, they are more cautious and wait longer for their scaling condition to hold true before slowly reducing resources.\n\nThe load spikes you can absorb increase as your service moves further away from a bottleneck. We recommend configuring your autoscaler to keep your service far from key system bottlenecks (such as CPU). Autoscaler also needs adequate time to react, particularly when new instances cannot turn up and serve instantly. We recommend that user-facing services reserve enough spare capacity for both overload protection and redundancy.5\n\nSetting Constraints Autoscaler is a powerful tool; if misconfigured, it can scale out of control. You might inadvertently trigger serious consequences by introducing a bug or changing a set‐ ting. For example, consider the following scenarios:\n\n4 See Site Reliability Engineering, Chapter 19.\n\n5 For more info about redundancy in capacity planning, see Site Reliability Engineering, Appendix B.\n\nAutoscaling\n\n|\n\n237",
      "content_length": 2453,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 270,
      "content": "You configured autoscaling to scale based on CPU utilization. You release a new version of your system, which contains a bug causing the server to consume CPU without doing any work. Autoscaler reacts by upsizing this job again and again until all available quota is wasted.\n\nNothing has changed in your service, but a dependency is failing. This failure causes all requests to get stuck on your servers and never finish, consuming resources all the while. Autoscaler will scale up the jobs, causing more and more traffic to get stuck. The increased load on your failing dependency can prevent the dependency from recovering.\n\nIt’s useful to constrain the work that your autoscaler is allowed to perform. Set a min‐ imum and maximum bound for scaling, making sure that you have enough quota to scale to the set limits. Doing so prevents you from depleting your quota and helps with capacity planning.\n\nIncluding Kill Switches and Manual Overrides It’s a good idea to have a kill switch in case something goes wrong with your autoscaling. Make sure your on-call engineers understand how to disable autoscaling and how to manually scale if necessary. Your autoscaling kill switch functionality should be easy, obvious, fast, and well documented.\n\nAvoiding Overloading Backends A correctly configured autoscaler will scale up in response to an increase in traffic. An increase in traffic will have consequences down the stack. Backend services, such as databases, need to absorb any additional load your servers might create. Therefore, it’s a good idea to perform a detailed dependency analysis on your backend services before deploying your autoscaler, particularly as some services may scale more line‐ arly than others. Ensure your backends have enough extra capacity to serve increased traffic and are able to degrade gracefully when overloaded. Use the data from your analysis to inform the limits of your autoscaler configuration.\n\nService deployments commonly run a variety of microservices that share quota. If a microservice scales up in response to a traffic spike, it might use most of the quota. If increased traffic on a single microservice means increased traffic on other microservi‐ ces, there will be no available quota for the remaining microservices to grow. In this scenario, a dependency analysis can help guide you toward preemptively implement‐ ing limited scaling. Alternatively, you can implement separate quotas per microser‐ vice (which may entail splitting your service into separate projects).\n\n238\n\n|\n\nChapter 11: Managing Load",
      "content_length": 2555,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 271,
      "content": "Avoiding Traffic Imbalance Some autoscalers (e.g., AWS EC2, GCP) can balance instances across regional groups of instances (RMiGs). In addition to regular autoscaling, these autoscalers run a sepa‐ rate job that constantly attempts to even out the size of each zone across the region. Rebalancing traffic in this way avoids having one large zone. If the system you’re using allocates quota per zone, this strategy evens out your quota usage. In addition, autoscaling across regions provides more diversity for failure domains.\n\nCombining Strategies to Manage Load If your system becomes sufficiently complex, you may need to use more than one kind of load management. For example, you might run several managed instance groups that scale with load but are cloned across multiple regions for capacity; there‐ fore, you also need to balance traffic between regions. In this case, your system needs to use both load balancing and load-based autoscaling.\n\nOr maybe you run a website across three colocated facilities around the world. You’d like to serve locally for latency, but since it takes weeks to deploy more machines, overflow capacity needs to spill over to other locations. If your site gets popular on social media and suddenly experiences a five-fold increase in traffic, you’d prefer to serve what requests you can. Therefore, you implement load shedding to drop excess traffic. In this case, your system needs to use both load balancing and load shedding.\n\nOr perhaps your data processing pipeline lives in a Kubernetes cluster in one cloud region. When data processing slows significantly, it provisions more pods to handle the work. However, when data comes in so fast that reading it causes you to run out of memory, or slows down garbage collection, your pods may need to shed that load temporarily or permanently. In this case, your system needs to use both load-based autoscaling and load shedding techniques.\n\nLoad balancing, load shedding, and autoscaling are all systems designed for the same goal: to equalize and stabilize the system load. Since the three systems are often implemented, installed, and configured separately, they seem independent. However, as shown in Figure 11-8, they’re not entirely independent. The following case study illustrates how these systems can interact.\n\nCombining Strategies to Manage Load\n\n|\n\n239",
      "content_length": 2350,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 272,
      "content": "Figure 11-8. A full traffic management system\n\nCase Study 2: When Load Shedding Attacks Imagine a fictional company, Dressy, that sells dresses online via an app. As this is a traffic-driven service, the development team at Dressy deployed their app across three regions. This deployment allows their app to respond quickly to user requests and weather single-zone failures—or so they thought.\n\nThe customer service team at Dressy starts receiving complaints that customers can’t access the app. Dressy’s development teams investigate and notice a problem: their load balancing is inexplicably drawing all user traffic into region A, even though that region is full-to-overflowing and both B and C are empty (and equally large). The timeline of events (see Figure 11-9) is as follows:\n\n1. At the beginning of the day, the traffic graphs showed all three clusters steady at 90 RPS.\n\n2. At 10:46 a.m., traffic started to rise in all three regions as eager shoppers began hunting for bargains.\n\n3. At 11:00 a.m., region A reached 120 RPS just before regions B and C.\n\n4. At 11:10 a.m., region A continued to grow to 400 RPS, while B and C dipped to 40 RPS.\n\n5. The load balancer settled at this state.\n\n6. The majority of requests hitting region A were returning 503 errors.\n\n7. Users whose requests hit this cluster started to complain.\n\n240\n\n|\n\nChapter 11: Managing Load",
      "content_length": 1369,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 273,
      "content": "Figure 11-9. Regional traffic\n\nIf the development team had consulted their load balancer’s fullness graphs, they would have seen something very strange. The load balancer was utilization-aware: it was reading CPU utilization from Dressy’s containers and using this information to estimate fullness. As far as it could tell, per-request CPU utilization was 10 times lower in region A than either B or C. The load balancer determined that all regions were equally loaded, and its job was done.\n\nWhat was happening?\n\nEarlier in the week, to protect against cascading overload, the team enabled load shedding. Whenever CPU utilization reached a certain threshold, a server would return an error for any new requests it received rather than attempting to process them. On this particular day, region A reached this threshold slightly ahead of the other regions. Each server began rejecting 10% of requests it received, then 20% of requests, then 50%. During this time frame, CPU usage remained constant.\n\nAs far as the load balancer system was concerned, each successive dropped request was a reduction in the per-request CPU cost. Region A was far more efficient than regions B and C. It was serving 240 RPS at 80% CPU (the shedding cap), while B and C were managing only 120 RPS. Logically, it decided to send more requests to A.\n\nCombining Strategies to Manage Load\n\n|\n\n241",
      "content_length": 1371,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 274,
      "content": "What went wrong?\n\nIn brief, the load balancer didn’t know that the “efficient” requests were errors because the load shedding and load balancing systems weren’t communicating. Each system was added and enabled separately, likely by different engineers. No one had examined them as one unified load management system.\n\nLessons learned\n\nTo effectively manage system load, we need to be deliberate—both in the configura‐ tion of our individual load management tools and in the management of their inter‐ actions. For example, in the Dressy case study, adding error handling to the load balancer logic would have fixed the problem. Let’s say each “error” request counts as 120% CPU utilization (any number over 100 will work). Now region A looks overloa‐ ded. Requests will spread to B and C, and the system will equalize.\n\nYou can use similar logic to extrapolate this example to any combination of load management tactics. When adopting a new load management tool, carefully examine how it interacts with other tools your system is already using and instrument their intersection. Add monitoring to detect feedback loops. Make sure your emergency shutdown triggers can be coordinated across your load management systems, and consider adding automatic shutdown triggers if these systems are behaving wildly out of control. If you don’t take appropriate precautions up front, you’ll likely have to do so in the wake of a postmortem.\n\nIt is easy to say “take precautions.” More specifically, here are some precautions you might consider, depending on the kind of load management you deploy:\n\nLoad balancing\n\nLoad balancing minimizes latency by routing to the location closest to the user. Autoscaling can work together with load balancing to increase the size of loca‐ tions close to the user and then route more traffic there, creating a positive feed‐ back loop.\n\nIf demand is primarily closest to one location, that location will grow in size until all serving capacity is in one spot. If this location goes down, the remaining loca‐ tions will become overloaded and traffic may be dropped. Scaling these locations up will not be instant. You can avoid this situation by setting a minimum num‐ ber of instances per location to keep spare capacity for failover.\n\nLoad shedding\n\nIt’s a good idea to set your thresholds such that your system autoscales before load shedding kicks in. Otherwise, your system might start shedding traffic it could have served had it scaled up first.\n\n242\n\n|\n\nChapter 11: Managing Load",
      "content_length": 2510,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 275,
      "content": "Managing load with RPC\n\nHandling the right requests is important for efficiency: you don’t want to auto‐ scale up to serve requests that won’t benefit users, or shed load unnecessarily because you’re processing unimportant requests. When using both autoscaling and load shedding, it’s important that you set deadlines on your RPC requests.\n\nProcesses hold resources for all in-flight requests, and release those resources when the requests are completed. In the absence of a specific deadline, the system will hold resources for all in-progress requests, up to the maximum possible limit. By default, this deadline is a very large number (which depends on the lan‐ guage implementation—some language APIs work in terms of a fixed point in time, and others with a duration of time). This behavior causes clients, and ulti‐ mately users, to experience higher latency. The service is also at risk of running out of resources (like memory) and crashing.\n\nTo handle this scenario gracefully, we recommend that the server terminates requests that take too long, and that clients cancel requests that are no longer useful to them. For example, a server shouldn’t start an expensive search opera‐ tion if the client already returned an error to the user. To set behavior expecta‐ tions for a service, you could simply provide a comment in the API’s .proto file to suggest a default deadline. Also, set deliberate deadlines for the client (for exam‐ ples, see our blog post “gRPC and Deadlines”).\n\nConclusion In Google’s experience, there are no perfect traffic management configurations. Autoscaling is a powerful tool, but it’s easy to get wrong. Unless carefully configured, autoscaling can result in disastrous consequences—for example, potentially cata‐ strophic feedback cycles between load balancing, load shedding, and autoscaling when these tools are configured in isolation. As the Pokémon GO case study illus‐ trates, traffic management works best when it’s based upon a holistic view of the interactions between systems.\n\nTime and time again, we’ve seen that no amount of load shedding, autoscaling, or throttling will save our services when they all fail in sync. For example, in the Poké‐ mon GO case study, we had a “thundering herd” of synchronized client retries com‐ bined with load balancers that waited for unresponsive backend servers. To fail your services gracefully, you need to plan ahead to mitigate potential problems. Your miti‐ gation strategy might involve setting flags, changing default behaviors, enabling expensive logging, or exposing the current value of parameters the traffic manage‐ ment system uses for decisions.\n\nWe hope the strategies and insights provided in this chapter can help you manage traffic for your own services and keep your users happy.\n\nConclusion\n\n|\n\n243",
      "content_length": 2803,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 277,
      "content": "CHAPTER 12 Introducing Non-Abstract Large System Design\n\nBy Salim Virji, James Youngman, Henry Robertson, Stephen Thorne, Dave Rensin, and Zoltan Egyed with Richard Bondi\n\nWith responsibilities that span production operations and product engineering, SRE is in a unique position to align business case requirements and operational costs. Product engineering teams may not be aware of the maintenance cost of systems they design, especially if that product team is building a single component that factors into a greater production ecosystem.\n\nBased on Google’s experience developing systems, we consider reliability to be the most critical feature of any production system. We find that deferring reliability issues during design is akin to accepting fewer features at higher costs. By following an iterative style of system design and implementation, we arrive at robust and scala‐ ble designs with low operational costs. We call this style Non-Abstract Large System Design (NALSD).\n\nWhat Is NALSD? This chapter presents a NALSD approach: we begin with the problem statement, gather requirements, and iterate through designs that become increasingly sophisti‐ cated until we reach a viable solution. Ultimately, we arrive at a system that defends against many failure modes and satisfies both the initial requirements and additional details that emerged as we iterated.\n\nNALSD describes a skill critical to SRE: the ability to assess, design, and evaluate large systems. Practically, NALSD combines elements of capacity planning, compo‐\n\n245",
      "content_length": 1542,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 278,
      "content": "nent isolation, and graceful system degradation that are crucial to highly available production systems. Google SREs are expected to be able to start resource planning with a basic whiteboard diagram of a system, think through the various scaling and failure domains, and focus their design into a concrete proposal for resources. Because these systems change over time, it’s vitally important that an SRE is able to analyze and evaluate the key aspects of the system design.\n\nWhy “Non-Abstract”? All systems will eventually have to run on real computers in real datacenters using real networks. Google has learned (the hard way) that the people designing dis‐ tributed systems need to develop and continuously exercise the muscle of turning a whiteboard design into concrete estimates of resources at multiple steps in the pro‐ cess. Without this rigor, it’s too tempting to create systems that don’t quite translate in the real world.\n\nThis extra bit of work up front typically leads to fewer last-minute system design changes to account for some unforeseen physical constraint.\n\nPlease note that while we drive these exercises to discrete results (e.g., number of machines), examples of sound reasoning and assumption making are more impor‐ tant than any final values. Early assumptions heavily influence calculation results, and making perfect assumptions isn’t a requirement for NALSD. The value of this exercise is in combining many imperfect-but-reasonable results into a better under‐ standing of the design.\n\nAdWords Example The Google AdWords service displays text advertisements on Google Web Search. The click-through rate (CTR) metric tells advertisers how well their ads are perform‐ ing. CTR is the ratio of times the ad is clicked versus the number of times the ad is shown.\n\nThis AdWords example aims to design a system capable of measuring and reporting an accurate CTR for every AdWords ad. The data we need to calculate CTR is recor‐ ded in logs of the search and ad serving systems. These logs record the ads that are shown for each search query and the ads that are clicked, respectively.\n\nDesign Process Google uses an iterative approach to design systems that meet our goals. Each itera‐ tion defines a potential design and examines its strengths and weaknesses. This anal‐ ysis either feeds into the next iteration or indicates when the design is good enough to recommend.\n\n246\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design",
      "content_length": 2463,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 279,
      "content": "In broad strokes, the NALSD process has two phases, each with two to three questions.\n\nIn the basic design phase, we try to invent a design that works in principle. We ask two questions:\n\nIs it possible?\n\nIs the design even possible? If we didn’t have to worry about enough RAM, CPU, network bandwidth, and so on, what would we design to satisfy the require‐ ments?\n\nCan we do better?\n\nFor any such design, we ask, “Can we do better?” For example, can we make the system meaningfully faster, smaller, more efficient? If the design solves the prob‐ lem in O(N) time, can we solve it more quickly—say, O(ln(N))?\n\nIn the next phase, we try to scale up our basic design—for example, by dramatically increasing a requirement. We ask three questions:\n\nIs it feasible?\n\nIs it possible to scale this design, given constraints on money, hardware, and so on? If necessary, what distributed design would satisfy the requirements?\n\nIs it resilient?\n\nCan the design fail gracefully? What happens when this component fails? How does the system work when an entire datacenter fails?\n\nCan we do better?\n\nWhile we generally cover these phases and questions in this approximate order, in practice, we bounce around between the questions and phases. For example, during the basic design phase, we often have growth and scaling in the back of our minds.\n\nThen we iterate. One design may successfully pass most of the phases, only to flounder later. When that happens, we start again, modifying or replacing compo‐ nents. The final design is the end of a story of twists and turns.\n\nWith these concepts in mind, let’s walk through the iterative NALSD process.\n\nInitial Requirements Each advertiser may have multiple advertisements. Each ad is keyed by ad_id and is associated with a list of search terms selected by the advertiser.\n\nWhen displaying a dashboard to an advertiser, we need to know the following for each ad and search term:\n\nAdWords Example\n\n|\n\n247",
      "content_length": 1941,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 280,
      "content": "How often this search term triggered this ad to be shown\n\nHow many times the ad was clicked by someone who saw the ad\n\nWith this information, we can calculate the CTR: the number of clicks divided by the number of impressions.\n\nWe know our advertisers care about two things: that the dashboard displays quickly, and that the data is recent. Therefore, when iterating on the design, we will consider our requirements in terms of SLOs (see Chapter 2 for more details):\n\n99.9% of dashboard queries complete in < 1 second.\n\n99.9% of the time, the CTR data displayed is less than 5 minutes old.\n\nThese SLOs provide a reasonable goal that we should be able to consistently meet. They also provide an error budget (see Chapter 4 in Site Reliability Engineering), which we will compare our solution against in each iteration of the design.\n\nWe aim to create a system that can meet our SLOs and also support millions of advertisers who want to see their CTRs on a dashboard. For transaction rates, let’s assume 500,000 search queries per second and 10,000 ad clicks per second.\n\nOne Machine The simplest starting point is to consider running our entire application on a single computer.\n\nFor every web search query, we log:\n\ntime\n\nThe time the query occurred\n\nquery_id\n\nA unique query identifier (query ID)\n\nsearch_term\n\nThe query content\n\nad_id\n\nThe ad IDs of all the AdWords advertisements shown for the search\n\nTogether, this information forms the query log. Every time a user clicks an ad, we log the time of the click, the query ID, and the ad ID in the click log.\n\nYou may be wondering why we don’t simply add the search_term to the click log to reduce complexity. In the arbitrarily reduced scope of our example, this could be feasible. However, in practice, CTR is actually only one of many insights calculated\n\n248\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design",
      "content_length": 1875,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 281,
      "content": "from these logs. Click logs are derived from URLs, which have inherent size limita‐ tions, making the separate query log a more scalable solution. Instead of proving this point by adding extra CTR-like requirements to the exercise, we will simply acknowl‐ edge this assumption and move forward.\n\nDisplaying a dashboard requires the data from both logs. We need to be able to show that we can achieve our SLO of displaying fresh data on the dashboard in under a second. Achieving this SLO requires that the speed of calculating a CTR remains con‐ stant as the system handles large amounts of clicks and queries.\n\nTo meet our SLO of displaying our dashboard in under one second, we need quick lookups of the number of clicked and shown query_ids per search_term for a given ad_id. We can extract the breakdown of shown query_ids per search_term and ad_id from the query log. A CTR dashboard needs all records from both the query log and the click log for the ad_ids.\n\nIf we have more than a few advertisers, scanning through the query log and the click log to generate the dashboard will be very inefficient. Therefore, our design calls for our one machine to create an appropriate data structure to allow fast CTR calcula‐ tions as it receives the logs. On a single machine, using an SQL database with indexes on query_id and search_term should be able to provide answers in under a second. By joining these logs on query_id and grouping by search_term, we can report the CTR for each search.\n\nCalculations\n\nWe need to calculate how many resources we need to parse all these logs. To deter‐ mine our scaling limits, we need to make some assumptions, starting with the size of the query log:\n\ntime\n\n64-bit integer, 8 bytes\n\nquery_id\n\n64-bit integer, 8 bytes\n\nad_id\n\nThree 64-bit integers, 8 bytes\n\nsearch_term\n\nA long string, up to 500 bytes\n\nOther metadata\n\n500–1,000 bytes of information, such as which machine served the ads, which language the search was in, and how many results the search term returned\n\nAdWords Example\n\n|\n\n249",
      "content_length": 2031,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 282,
      "content": "To make sure we don’t prematurely hit a limit, we aggressively round up to treat each query log entry as 2 KB. Click log volume should be considerably smaller than query log volume: because the average CTR is 2% (10,000 clicks / 500,000 queries), the click log will have 2% as many records as the query log. Remember that we chose big num‐ bers to illustrate that these principles scale to arbitrarily large implementations. These estimations seem large because they’re supposed to be.\n\nFinally, we can use scientific notation to limit errors caused by arithmetic on incon‐ sistent units. The volume of query logs generated in a 24-hour period will be:\n\n(5 × 105 queries/sec) × (8.64 × 104 seconds/day) × (2 × 103 bytes) = 86.4 TB/day\n\nBecause we receive 2% as many clicks as queries, and we know that our database indexes will add some reasonable amount of overhead, we can round our 86.4 TB/day up to 100 TB of space required to store one day’s worth of log data.\n\nWith an aggregate storage requirement of ~100 TB, we have some new assumptions to make. Does this design still work with a single machine? While it is possible to attach 100 TB of disks to a single machine, we’ll likely be limited by the machine’s ability to read from and write to disk.\n\nFor example, a common 4 TB HDD might be able to sustain 200 input/output opera‐ tions per second (IOPS). If every log entry can be stored and indexed in an average of one disk write per log entry, we see that IOPS is a limiting factor for our query logs:\n\n(5 × 105 queries/sec) / (200 IOPS/disk) = 2.5 × 103 disks or 2,500 disks\n\nEven if we can batch our queries in a 10:1 ratio to limit the operations, in a best-case scenario we’d need several hundred HDDs. Considering that query log writes are only one component of the design’s IO requirements, we need to use a solution that handles high IOPS better than traditional HDDs.\n\nFor simplicity’s sake, we’ll move straight to evaluating RAM and skip the evaluation of other storage media, such as solid state disk (SSD). A single machine can’t handle a 100 TB footprint entirely in RAM: assuming we have a standard machine footprint of 16 cores, 64 GB RAM, and 1 Gbps network throughput available, we’ll need:\n\n(100 TB) / (64 GB RAM/machine) = 1,563 machines\n\nEvaluation\n\nIgnoring our calculations for a moment and imagining we could fit this design in a single machine, would we actually want to? If we test our design by asking what hap‐ pens when this component fails, we identify a long list of single points of failure (e.g.,\n\n250\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design",
      "content_length": 2602,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 283,
      "content": "CPU, memory, storage, power, network, cooling). Can we reasonably support our SLOs if one of these components fails? Almost certainly not—even a simple power cycle would significantly impact our users.\n\nReturning to our calculations, our one-machine design once again looks unfeasible, but this step hasn’t been a waste of time. We’ve discovered valuable information about how to reason about the constraints of the system and its initial requirements. We need to evolve our design to use more than one machine.\n\nDistributed System The search_terms we need are in the query log, and the ad_ids are in the click log. Now that we know we’ll need multiple machines, what’s the best design to join them?\n\nMapReduce\n\nWe can process and join the logs with a MapReduce. We can periodically grab the accumulated query logs and click logs, and the MapReduce will produce a data set organized by ad_id that displays the number of clicks each search_term received.\n\nMapReduce works as a batch processor: its inputs are a large data set, and it can use many machines to process that data via workers and produce a result. Once all machines have processed their data, their output can be combined—the MapReduce can directly create summaries of every CTR for every AdWords ad and search term. We can use this data to create the dashboards we need.\n\nEvaluation. MapReduce is a widely used model of computation that we are confident will scale horizontally. No matter how big our query log and click log inputs are, adding more machines will always allow the process to complete successfully without running out of disk space or RAM.\n\nUnfortunately, this type of batch process can’t meet our SLO of joined log availability within 5 minutes of logs being received. To serve results within 5 minutes, we’d need to run MapReduce jobs in small batches—just a few minutes of logs at a time.\n\nThe arbitrary and nonoverlapping nature of the batches makes small batches imprac‐ tical. If a logged query is in batch 1, and its click is in batch 2, the click and query will never be joined. While MapReduce handles self-contained batches well, it’s not opti‐ mized for this kind of problem. At this point, we could try to figure out potential workarounds using MapReduce. For simplicity’s sake, however, we’ll move on to examine another solution.\n\nAdWords Example\n\n|\n\n251",
      "content_length": 2345,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 284,
      "content": "LogJoiner\n\nThe number of ads that users click is significantly smaller than the number of ads served. Intuitively, we need to focus on scaling the larger of the two: query logs. We do this by introducing a new distributed system component.\n\nRather than looking for the query_id in small batches, as in our MapReduce design, what if we created a store of all queries that we can look up by query_id on demand? We’ll call it the QueryStore. It holds the full content of the query logs, keyed by query_id. To avoid repetition, we’ll assume that our calculations from the one- machine design will apply to the QueryStore and we’ll limit the review of QueryStore to what we’ve already covered. For a deeper discussion on how a component like this might work, we recommend reading about Bigtable.1\n\nBecause click logs also have the query_id, the scale of our processing loop is now much smaller: it only needs to loop over the click logs and pull in the specific queries referenced. We’ll call this component the LogJoiner.\n\nLogJoiner takes a continuous stream of data from the click logs, joins it with the data in QueryStore, and then stores that information, organized by ad_id. Once the quer‐ ies that were clicked on are stored and indexed by ad_id, we have half the data required to generate the CTR dashboard. We will call this the ClickMap, because it maps from ad_id to the clicks.\n\nIf we don’t find a query for a click (there may be a slowdown in receiving the query logs), we put it aside for some time and retry, up to a time limit. If we can’t find a query for it by that time limit, we discard that click.\n\nThe CTR dashboard needs two components for each ad_id and search_term pair: the number of impressions, and the number of ads clicked on. ClickMap needs a partner to hold the queries, organized by ad_id. We’ll call this QueryMap. QueryMap is directly fed all the data from the query log, and also indexes entries by ad_id.\n\nFigure 12-1 depicts how data flows through the system.\n\nThe LogJoiner design introduces several new components: LogJoiner, QueryStore, ClickMap, and QueryMap. We need to make sure these components can scale.\n\n1 Fay Chang et al., “Bigtable: A Distributed Storage System for Structured Data,” ACM Transactions on Com‐\n\nputer Systems (TOCS) 26, no. 2 (2008), http://bit.ly/2J22BZv.\n\n252\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design",
      "content_length": 2382,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 285,
      "content": "Figure 12-1. Basic LogJoiner design; the click data is processed and stored so the dash‐ board can retrieve it\n\nCalculations. From the calculations we performed in previous iterations, we know the QueryStore will be around 100 TB of data for a day of logs. We can delete data that’s too old to be of value.\n\nThe LogJoiner should process clicks as they come in and retrieve the corresponding query logs from the QueryStore.\n\nThe amount of network throughput LogJoiner needs to process the logs is based on how many clicks per second we have in our logs, multiplied by the 2 KB record size:\n\n(104 clicks/sec) × (2 × 103 bytes) = 2 × 107 = 20 MB/sec = 160 Mbps\n\nThe QueryStore lookups incur additional network usage. For each click log record, we look up the query_id and return a full log record:\n\n(104 clicks/sec) × (8 bytes) = 8 × 104 = 80 KB/sec = 640 Kbps • (104 clicks/sec) * (2 × 103 bytes) = 2 × 107 = 20 MB/sec = 160 Mbps\n\nAdWords Example\n\n|\n\n253",
      "content_length": 952,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 286,
      "content": "LogJoiner will also send results to ClickMap. We need to store the query_id, ad_id, and time. search_term. time and query_id are both 64-bit integers, so that data will be less than 1 KB:\n\n(104 clicks/sec) × (103 bytes) = 107 = 10 MB/sec = 80 Mbps\n\nAn aggregate of ~400 Mbps is a manageable rate of data transfer for our machines.\n\nThe ClickMap has to store the time and the query_id for each click, but does not need any additional metadata. We’ll ignore ad_id and search_term because they are a small linear factor (e.g., number of advertisers × number of ads × 8 bytes). Even 10 million advertisers with 10 ads each is only ~800 MB. A day’s worth of ClickMap is:\n\n(104 clicks/sec) × (8.64 × 104 seconds/day) × (8 bytes + 8 bytes) = 1.4 × 1010 = 14 GB/day for ClickMap\n\nWe’ll round ClickMap up to 20 GB/day to account for any overhead and our ad_ids.\n\nAs we fill out the QueryMap, we need to store the query_id for each ad that is shown. Our storage need increases because there are potentially three ad_ids that could be clicked on for each search query, so we’ll need to record the query_id in up to three entries:\n\n3 × (5 × 105 queries/sec) × (8.64 × 104 seconds/day) × (8 bytes + 8 bytes) = 2 × 1012 = 2 TB/day for QueryMap\n\n2 TB is small enough to be hosted on a single machine using HDDs, but we know from our one-machine iteration that the individual small writes are too frequent to store on a hard drive. While we could calculate the impact of using higher IOPS drives (e.g., SSD), our exercise is focused on demonstrating that the system can scale to an arbitrarily large size. In this case, we need to design around a single machine’s IO limitations. Therefore, the next step in scaling the design is to shard the inputs and outputs: to divide the incoming query logs and click logs into multiple streams.\n\nSharded LogJoiner\n\nOur goal in this iteration is to run multiple LogJoiner instances, each on a different shard of the data.2 To this end, we need to think about several factors:\n\n2 This section is based on Rajagopal Ananthanarayanan et al., “Photon: Fault-tolerant and Scalable Joining of\n\nContinuous Data Streams,” in SIGMOD ’13: Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data (New York: ACM, 2013), http://bit.ly/2Jse3Ns.\n\n254\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design",
      "content_length": 2345,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 287,
      "content": "Data management\n\nTo join the query logs and click logs, we must match each click log record with its corresponding query log record on the query_id. The design should prevent network and disk throughput from constraining our design as we scale.\n\nReliability\n\nWe know a machine can fail at any time. When a machine running LogJoiner fails, how do we make sure we don’t lose the work that was in progress?\n\nEfficiency\n\nCan we scale up without being wasteful? We need to use the minimum resources that meet our data management and reliability concerns.\n\nOur LogJoiner design showed that we can join our query logs and click logs, but the resulting volume of data is very large. If we divide the work into shards based on query_id, we can run multiple LogJoiners in parallel.\n\nProvided a reasonable number of LogJoiner instances, if we distribute the logs evenly, each instance receives only a trickle of information over the network. As the flow of clicks increases, we scale horizontally by adding more LogJoiner instances, instead of scaling vertically by using more CPU and RAM.\n\nAs shown in Figure 12-2, so that the LogJoiners receive the right messages, we intro‐ duce a component called a log sharder, which will direct each log entry to the correct destination. For every record, our click log sharders do the following:\n\n1. Hash the record’s query_id.\n\n2. Modulo the result with N (the number of shards) and add 1 to arrive at a number between 1 and N.\n\n3. Send the record to the shard number in step 2.\n\nFigure 12-2. How should sharding work?\n\nAdWords Example\n\n|\n\n255",
      "content_length": 1573,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 288,
      "content": "Now each LogJoiner will get a consistent subset of the incoming logs broken up by query_id, instead of the full click log.\n\nThe QueryMap needs to be sharded as well. We know that it will take many hard drives to sustain the IOPS required of QueryMap, and that the size of one day’s Quer‐ yMap (2 TB) is too large for our 64 GB machines to store in RAM. However, instead of sharding by query_id like the LogJoiner, we will shard on ad_id. The ad_id is known before any read or write, so using the same hashing approach as the LogJoiner and CTR dashboard will provide a consistent view of the data.\n\nTo keep implementations consistent, we can reuse the same log sharder design for the ClickMap as the QueryMap, since the ClickMap is smaller than the QueryMap.\n\nNow that we know our system will scale, we can move on to address the system’s reli‐ ability. Our design must be resilient to LogJoiner failures. If a LogJoiner fails after receiving log messages but before joining them, all its work must be redone. This delays the arrival of accurate data to the dashboard, which will affect our SLO.\n\nIf our log sharder process sends duplicate log entries to two shards, the system can continue to perform at full speed and process accurate results even when a LogJoiner fails (likely because the machine it is on fails).\n\nBy replicating the work in this way, we reduce (but do not eliminate) the chance of losing those joined logs. Two shards might break at the same time and lose the joined logs. By distributing the workload to ensure no duplicate shards land on the same machine, we can mitigate much of that risk. If two machines fail concurrently and we lose both copies of the shard, the system’s error budget (see Chapter 4 from the first SRE book) can cover the remaining risk. When a disaster does occur, we can reproc‐ ess the logs. The dashboard will show only data that’s a bit older than 5 minutes for a brief window of time.\n\nFigure 12-3 shows our design for a shard and its replica, where the LogJoiner, Click‐ Map, and QueryMap are built on both shards.\n\nFrom the joined logs, we can construct a ClickMap on each of the LogJoiner machines. To display our user dashboards, all ClickMaps need to be combined and queried.\n\nEvaluation. Hosting the sharded components in one datacenter creates a single point of failure: if either the right unlucky pair of machines or the datacenter is disconnec‐ ted, we lose all the ClickMap work, and user dashboards stop working entirely! We need to evolve our design to use more than one datacenter.\n\n256\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design",
      "content_length": 2611,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 289,
      "content": "Figure 12-3. Sharding of logs with same query_id to duplicate shards\n\nMultidatacenter\n\nDuplicating data across datacenters in different geographic locations allows our serv‐ ing infrastructure to withstand catastrophic failures. If one datacenter is down (e.g., because of a multiday power or network outage), we can fail over to another datacen‐ ter. For failover to work, ClickMap data must be available in all datacenters where the system is deployed.\n\nIs such a ClickMap even possible? We don’t want to multiply our compute require‐ ments by the number of datacenters, but how can we efficiently synchronize work between sites to ensure sufficient replication without creating unnecessary duplica‐ tion?\n\nWe’ve just described an example of the well-known consensus problem in distributed systems engineering. There are a number of complex algorithms for solving this problem, but the basic idea is:\n\n1. Make three or five replicas of the service you want to share (like ClickMap).\n\n2. Have the replicas use a consensus algorithm such as Paxos to ensure that we can reliably store the state of the calculations if a datacenter-sized failure occurs.\n\n3. Implement at least one network round-trip time between the participating nodes to accept a write operation. This requirement places a limit on the sequential throughput for the system. We can still parallelize some of the writes to the dis‐ tributed consensus-based map.\n\nAdWords Example\n\n|\n\n257",
      "content_length": 1451,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 290,
      "content": "Following the steps just listed, the multidatacenter design now seems workable in principle. Will it also work in practice? What types of resources do we need, and how many of them do we need?\n\nCalculations. The latency of executing the Paxos algorithm with fault-isolated data‐ centers means that each operation needs roughly 25 milliseconds to complete. This latency assumption is based upon datacenters at least a few hundred kilometers apart. Therefore, in terms of sequential processes, we can only perform one operation per 25 milliseconds or 40 operations per second. If we need to perform sequential pro‐ cesses 104 times per second (click logs), we need at least 250 processes per datacenter, sharded by ad_id, for the Paxos operations. In practice, we’d want to add more pro‐ cesses to increase parallelism—to handle accumulated backlog after any downtime or traffic spikes.\n\nBuilding on our previous calculations for ClickMap and QueryMap, and using the estimate of 40 sequential operations per second, how many new machines do we need for our multidatacenter design?\n\nBecause our sharded LogJoiner design introduces a replica for each log record, we’ve doubled the number of transactions per second to create the ClickMap and Query‐ Map: 20,000 clicks/second and 1,000,000 queries/second.\n\nWe can calculate the minimum number of processes, or tasks, required by dividing the total queries per second by our maximum operations per second:\n\n(1.02 × 106 queries/sec) / (40 operations/sec) = 25,500 tasks\n\nThe amount of memory for each task (two copies of 2 TB QueryMap):\n\n(4 × 1012 bytes) / (25,500 tasks) = 157 MB/task\n\nTasks per machine:\n\n(6.4 × 1010 bytes) / (1.57 × 108 bytes) = 408 tasks/machine\n\nWe know we can fit many tasks on a single machine, but we need to ensure that we won’t be bottlenecked by IO. The total network throughput for ClickMap and Query‐ Map (using a high estimate of 2 KB per entry):\n\n(1.02 × 106 queries/sec) × (2 × 103 bytes) = 2.04 GB/sec = 16 Gbps\n\nThroughput per task:\n\n16 Gbps / 25,500 tasks = 80 KB/sec = 640 Kbps/task\n\n258\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design",
      "content_length": 2128,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 291,
      "content": "Throughput per machine:\n\n408 tasks × 640 Kbps/task = 256 Mbps\n\nOur combination of 157 MB memory and 640 Kbps per task is manageable. We need approximately 4 TB of RAM in each datacenter to host the sharded ClickMap and QueryMap. If we have 64 GB of RAM per machine, we can serve the data from just 64 machines, and will use only 25% of each machine’s network bandwidth.\n\nEvaluation. Now that we’ve designed a multidatacenter system, let’s review if the dataflow makes sense.\n\nFigure 12-4 shows the entire system design. You can see how each search query and ad click is communicated to the servers, and how the logs are collected and pushed into each component.\n\nWe can check this system against our requirements:\n\n10,000 ad clicks per second\n\nThe LogJoiner can scale horizontally to process all log clicks, and store the result in the ClickMap.\n\n500,000 search queries per second\n\nThe QueryStore and QueryMap have been designed to handle storing a full day of data at this rate.\n\n99.9% of dashboard queries complete in < 1 second\n\nThe CTR dashboard fetches data from QueryMap and ClickMap, which are keyed by ad_id, making this transaction fast and simple.\n\n99.9% of the time, the CTR data displayed is less than 5 minutes old\n\nEach component is designed to scale horizontally, meaning that if the pipeline is too slow, adding more machines will decrease the end-to-end pipeline latency.\n\nWe believe this system architecture scales to meet our requirements for throughput, performance, and reliability.\n\nAdWords Example\n\n|\n\n259",
      "content_length": 1528,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 292,
      "content": "Figure 12-4. Multidatacenter design\n\nConclusion NALSD describes the iterative process of system design that Google uses for produc‐ tion systems. By breaking down software into logical components and placing these components into a production ecosystem with reliable infrastructure, we arrive at systems that provide reasonable and appropriate targets for data consistency, system availability, and resource efficiency. The practice of NALSD allows us to improve our design without starting anew for each iteration. While various design iterations\n\n260\n\n|\n\nChapter 12: Introducing Non-Abstract Large System Design",
      "content_length": 613,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 293,
      "content": "presented in this chapter satisfied our original problem statement, each iteration revealed new requirements, which we could meet by extending our previous work.\n\nThroughout this process, we separated software components based on how we expected the system to grow. This strategy allowed us to scale different parts of the system independently and removed dependencies on single pieces of hardware or single instances of software, thereby producing a more reliable system.\n\nThroughout the design process, we continued to improve upon each iteration by ask‐ ing the four key NALSD questions:\n\nIs it possible?\n\nCan we build it without “magic”?\n\nCan we do better?\n\nIs it as simple as we can reasonably make it?\n\nIs it feasible?\n\nDoes it fit within our practical constraints (budget, time, etc.)?\n\nIs it resilient?\n\nWill it survive occasional but inevitable disruptions?\n\nNALSD is a learned skill. As with any skill, you need to practice it regularly to main‐ tain your proficiency. Google’s experience has shown that the ability to reason from an abstract requirement to a concrete approximation of resources is critical to build‐ ing healthy and long-lived systems.\n\nConclusion\n\n|\n\n261",
      "content_length": 1183,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 295,
      "content": "CHAPTER 13 Data Processing Pipelines\n\nBy Rita Sodt and Igor Maravić (Spotify) with Gary Luo, Gary O’Connor, and Kate Ward\n\nData processing is a complex field that’s constantly evolving to meet the demands of larger data sets, intensive data transformations, and a desire for fast, reliable, and inexpensive results. The current landscape features data sets that are generated and collected from a variety of sources—from mobile usage statistics to integrated sensor networks to web application logs, and more. Data processing pipelines can turn these often unbounded, unordered, global-scale data sets into structured, indexed storage that can help inform crucial business decisions or unlock new product features. In addition to providing insight into system and user behavior, data processing is often business-critical. Delayed or incorrect data in your pipeline can manifest in user- facing issues that are expensive, labor-intensive, and time-consuming to fix.\n\nThis chapter starts by using product examples to examine some common types of applications of big data processing pipelines. We then explore how to identify pipe‐ line requirements and design patterns, and enumerate some best practices of manag‐ ing data processing pipelines throughout the development lifecycle. We cover tradeoffs you can make to optimize your pipeline and techniques for measuring the important signals of pipeline health. For a service to remain healthy and reliable once it’s deployed, SREs (as well as developers) should be able to navigate all of these tasks. Ideally, SREs should be involved in this work from its early stages: Google’s SRE teams regularly consult with teams developing a data processing pipeline to ensure that the pipeline can be easily released, modified, and run without causing issues for customers.\n\n263",
      "content_length": 1818,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 296,
      "content": "Finally, the Spotify case study provides an overview of their event delivery processing pipeline, which uses a combination of in-house, Google Cloud, and other third-party solutions to manage a complex, business-critical data processing pipeline. Whether you own a pipeline directly, or own another service that depends on the data that a pipeline produces, we hope you can use the information in this chapter to help make your pipelines (and services) more reliable.\n\nFor a comprehensive discussion of Google’s philosophies on data processing pipe‐ lines, see Chapter 25 of our first SRE book.\n\nPipeline Applications There is a wide variety of pipeline applications, each with its own strengths and use cases. A pipeline can involve multiple stages; each stage is a separate process with dependencies on other stages. One pipeline might contain multiple stages, which are abstracted away with a high-level specification. An example of this is in Cloud Data‐ flow: a user writes the business logic with a relatively high-level API, and the pipeline technology itself translates this data into a series of steps or stages where one’s output is the input of another. To give you an idea of the breadth of pipeline applications, next we describe several pipeline applications and their recommended uses. We use two example companies with different pipeline and implementation requirements to demonstrate different ways of meeting their respective data needs. These examples illustrate how your specific use case defines your project goals, and how you can use these goals to make an informed decision on what data pipeline works best for you.\n\nEvent Processing/Data Transformation to Order or Structure Data The Extract Transform Load (ETL) model is a common paradigm in data processing: data is extracted from a source, transformed, and possibly denormalized, and then “reloaded” into a specialized format. In more modern applications, this might look like a cognitive process: data acquisition from some kind of sensor (live or playback) and a selection and marshalling phase, followed by “training” of a specialized data structure (like a machine learning network).\n\nETL pipelines work in a similar way. Data is extracted from a single (or multiple) sources, transformed, and then loaded (or written) into another data source. The transformation phase can serve a variety of use cases, such as:\n\nMaking changes to the data format to add or remove a field\n\nAggregating computing functions across data sources\n\nApplying an index to the data so it has better characteristics for serving jobs that consume the data\n\n264\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 2657,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 297,
      "content": "Typically, an ETL pipeline prepares your data for further analysis or serving. When used correctly, ETL pipelines can perform complex data manipulations and ulti‐ mately increase the efficiency of your system. Some examples of ETL pipelines include:\n\nPreprocessing steps for machine learning or business intelligence use cases\n\nComputations, such as counting how many times a given event type occurs within a specific time interval\n\nCalculating and preparing billing reports\n\nIndexing pipelines like the ones that power Google’s web search\n\nData Analytics Business intelligence refers to technologies, tools, and practices for collecting, inte‐ grating, analyzing, and presenting large volumes of information to enable better deci‐ sion making.1 Whether you have a retail product, a mobile game, or Internet of Things–connected sensors, aggregating data across multiple users or devices can help you identify where things are broken or working well.\n\nTo illustrate the data analytics use case, let’s examine a fictional company and their recently launched mobile and web game, Shave the Yak. The owners want to know how their users interact with the game, both on their mobile devices and on the web. As a first step, they produce a data analytics report of the game that processes data about player events. The company’s business leaders have requested monthly reports on the most used features of the game so they can plan new feature development and perform market analysis. The mobile and web analytics for the game are stored in Google Cloud BigQuery tables that are updated three times a day by Google Analyt‐ ics. The team set up a job that runs whenever new data is added to these tables. On completion, the job makes an entry in the company’s daily aggregate table.\n\nMachine Learning Machine learning (ML) applications are used for a variety of purposes, like helping predict cancer, classifying spam, and personalizing product recommendations for users. Typically, an ML system has the following stages:\n\n1 See Umeshwar Dayal et al., “Data Integration Flows for Business Intelligence,” in Proceedings of the 12th\n\nInternational Conference on Extending Database Technology: Advances in Database Technology (New York: ACM, 2000), 1–11.\n\nPipeline Applications\n\n|\n\n265",
      "content_length": 2274,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 298,
      "content": "1. Data features and their labels are extracted from a larger data set.\n\n2. An ML algorithm trains a model on the extracted features.\n\n3. The model is evaluated on a test set of data.\n\n4. The model is made available (served) to other services.\n\n5. Other systems make decisions using the responses served by the model.\n\nTo demonstrate an ML pipeline in action, let’s consider an example of a fictional company, Dressy, that sells dresses online. The company wants to increase their reve‐ nue by offering targeted recommendations to their users. When a new product is uploaded to the site, Dressy wants their system to start incorporating that product into user recommendations within 12 hours. Ultimately, Dressy would like to present users with near-real-time recommendations as they interact with the site and rate dresses. As a first step in their recommender system, Dressy investigates the follow‐ ing approaches:\n\nCollaborative\n\nShow products that are similar to each other.\n\nClustering\n\nShow products that have been liked by a similar user.\n\nContent-based\n\nShow products that are similar to other products that the user has viewed or liked.\n\nAs an online shop, Dressy has a data set of user profile information and reviews, so they opt to use a clustering filter. New products that are uploaded to their system don’t have structured data or consistent labels (e.g., some vendors may include extra information about color, size, and features of the dress using different categories and formats). Consequently, they need to implement a pipeline to preprocess the data into a format compatible with TensorFlow that joins both the product information and user profile data. The ML system includes pipelines to preprocess data from mul‐ tiple sources needed to train the model. Using the training data, Dressy’s develop‐ ment team creates a TensorFlow model to serve the appropriate recommendations to customers. Figure 13-1 shows the full ML solution. We detail each step afterward.\n\n266\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 2031,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 299,
      "content": "Figure 13-1. ML data processing pipeline\n\n1. The development team elects to use a streaming dataflow pipeline, Google Cloud Dataflow, to preprocess the data into a format of labeled dresses by sending images to an image classification service that returns a list of characteristics.\n\n2. The team preprocesses data from multiple sources that will be used to train a model that returns the top five most similar dresses. Their workflow generates an ML model from the dress product data and purchase history from customer pro‐ files stored in BigQuery.\n\n3. They choose to use a streaming Dataflow pipeline to preprocess the data into a format of customer personalization profiles. These profiles are used as input to train a TensorFlow model. The trained TensorFlow model binary is stored in a Google Cloud Storage (GCS) bucket. Before being promoted to production, the team ensures the model passes accuracy checks when evaluated against a test set of the preprocessed data used for model evaluation.\n\n4. A service provides the recommendations for a given customer, which the web and mobile frontends use. The team uses TensorFlow with the Cloud ML online prediction service.\n\nPipeline Applications\n\n|\n\n267",
      "content_length": 1204,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 300,
      "content": "5. A customer-facing, frontend service for making purchases serves the user data based on the up-to-date dress recommendations from the prediction service.\n\nDressy has noticed that occasionally a new model doesn’t get published for over 24 hours, and the recommendations trigger intermittent errors. This is a common issue when a new model is deployed for the first time; however, there are some simple steps you can take to resolve this problem. If you start to notice that decisions, classi‐ fications, or recommendations either aren’t being surfaced or are stale or incorrect, ask yourself:\n\nIs data stuck coming into the pipeline before it can be preprocessed to train the model?\n\nDo we have a poor ML model caused by a software bug? Is there a lot of spam? Are the features used to train the model poorly chosen?\n\nHas a new version of the ML model been recently generated, or is a stale version of the model running in production?\n\nLuckily, Dressy has a set of tools to monitor and detect an issue before their custom‐ ers experience any problems. If and when an outage occurs, these tools can help them to quickly repair or roll back any offending code. For more details on implementing monitoring and alerting, see Chapter 4.\n\nPipeline Best Practices The following pipeline best practices apply to pipelines that are run as a service (i.e., pipelines that are responsible for correctly processing data in a timely manner for consumption by other systems). Multiple steps are required to properly deploy a pipeline as a service. These steps range from defining and measuring your customer needs with an SLO, to gracefully responding to degradations and failures, to writing documentation and creating a development lifecycle that catches issues before they reach production.\n\nDefine and Measure Service Level Objectives It’s important to automatically detect when your pipeline is unhealthy and if you are failing to meet your customer’s needs. Receiving notifications when you’re in danger of exceeding your error budget (for more details on error budget, see Chapter 2) helps to minimize customer impact. At the same time, it’s important to strike a com‐ fortable balance between reliability and feature launches—your customers care about both. The remainder of this section provides examples of pipeline SLOs and how to maintain them.\n\n268\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 2390,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 301,
      "content": "Data freshness\n\nMost pipeline data freshness SLOs are in one of the following formats:\n\nX% of data processed in Y [seconds, days, minutes].\n\nThe oldest data is no older than Y [seconds, days, minutes].\n\nThe pipeline job has completed successfully within Y [seconds, days, minutes].\n\nFor example, the Shave the Yak mobile game could choose to target an SLO requiring 99% of all user actions that impact the user score to be reflected in the scoreboard within 30 minutes.\n\nData correctness\n\nCreating SLOs for data correctness ensures that you are alerted about potential data errors in your pipeline. For example, a correctness error in a billing pipeline could result in customers being charged too much or too little. A correctness target can be difficult to measure, especially if there is no predefined correct output. If you don’t have access to such data, you can generate it. For example, use test accounts to calcu‐ late the expected output. Once you have this “golden data,” you can compare expected and actual output. From there, you can create monitoring for errors/ discrepancies and implement threshold-based alerting as test data flows through a real production system.\n\nAnother data correctness SLO involves backward-looking analysis. For example, you might set a target that no more than 0.1% of your invoices are incorrect per quarter. You might set another SLO target for the number of hours/days that bad data or errors are served from the pipeline output data. The notion of data correctness varies by product and application.\n\nData isolation/load balancing\n\nSometimes you will have segments of data that are higher in priority or that require more resources to process. If you promise a tighter SLO on high-priority data, it’s important to know that this data will be processed before lower-priority data if your resources become constrained. The implementation of this support varies from pipe‐ line to pipeline, but often manifests as different queues in task-based systems or dif‐ ferent jobs. Pipeline workers can be configured to take the highest available priority task. There could be multiple pipeline applications or pipeline worker jobs running with different configurations of resources—such as memory, CPU, or network tiers— and work that fails to succeed on lower provisioned workers could be retried on higher provisioned ones. In times of resource or system constraints, when it’s impos‐ sible to process all data quickly, this separation allows you to preferentially process higher-priority items over lower ones.\n\nPipeline Best Practices\n\n|\n\n269",
      "content_length": 2581,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 302,
      "content": "End-to-end measurement\n\nIf your pipeline has a series of stages, it can be tempting to measure a per-stage or per-component SLO. However, measuring SLOs in this fashion doesn’t capture your customer’s experience or the end-to-end health of your system. For example, imagine you have an event-based pipeline such as Google Analytics. The end-to-end SLO includes log input collection and any number of pipeline steps that happen before data reaches the serving state. You could monitor each stage individually and offer an SLO on each one, but customers only care about the SLO for the sum of all stages. If you’re measuring SLOs for each stage, you would be forced to tighten your per- component alerting, which could result in more alerts that don’t model the user experience.\n\nAdditionally, if you measure data correctness only per stage, you could miss end-to- end data corruption bugs. For example, each stage in your pipeline could report that all is well, but one stage introduces a field that it expects a downstream job to process. This upstream stage assumes that the extra data has been processed and used to serve requests to users. A downstream job doesn’t expect the additional field, so it drops the data. Both jobs think they are correct, but the user doesn’t see the data.\n\nPlan for Dependency Failure Once you define your SLO, it’s good practice to confirm that you aren’t overdepend‐ ing on the SLOs/SLAs of other products that fail to meet their commitments. Many products, such as Google Cloud Platform, list their SLA promises on their sites. Once you identify any third-party dependencies, at a minimum, design for the largest fail‐ ure accounted for in their advertised SLAs. For example, when defining an SLO, the owner of a pipeline that reads or writes data to Cloud Storage would ensure that the uptimes and guarantees advertised are appropriate. If the single-region uptime guar‐ antee was less than required by the pipeline to meet its SLO on data processing time, the pipeline owner may choose to replicate the data across regions to get the higher availability.\n\nWhen a service provider’s infrastructure breaks its SLAs, the result can negatively impact dependent pipelines. If your pipeline depends on more strict guarantees than the service provider advertises, your service could fail even if the service provider remains within their SLA. Sometimes, realistically planning for dependency failure can mean accepting a lower level of reliability and offering a looser SLA to your customers.2\n\n2 For more details about factoring dependencies into your service’s reliability, see Ben Treynor et al., “The Cal‐ culus of Service Availability,” ACM Queue 15, no. 2 (2017), https://queue.acm.org/detail.cfm?id=3096459.\n\n270\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 2791,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 303,
      "content": "At Google, to encourage pipeline development with dependency failure in mind, we stage planned outages. For example, many pipelines at Google depend on the availa‐ bility of the datacenter where they run. Our Disaster Recovery Testing (DiRT) fre‐ quently targets these systems, simulating a regional outage. When a regional outage occurs, pipelines that have planned for failure automatically fail over to another region. Other pipelines are delayed until the operator of the failed pipeline is alerted by their monitoring and manually fails over. Successful manual failover assumes that the pipeline can obtain enough resources to bring up a production stack in another region. In a best-case scenario, an unsuccessful manual failover prolongs an outage. In a worst-case scenario, processing jobs may have continued processing stale data, which introduces out-of-date or incorrect data in any downstream pipelines. Recov‐ ery tactics from an incident like this vary depending on your setup. For example, if correct data was overwritten with incorrect data, you may have to restore data from a previous backup version and reprocess any missing data.\n\nIn summary, it’s good practice to prepare for the day when the systems you depend on are unavailable. Even the best products will fail and experience outages. Regularly practice disaster recovery scenarios to ensure your systems are resilient to common and uncommon failures. Assess your dependencies and automate your system responses as much as possible.\n\nCreate and Maintain Pipeline Documentation When well written and maintained, system documentation can help engineers visual‐ ize the data pipeline and its dependencies, understand complex system tasks, and potentially shorten downtime in an outage. We recommend three categories of docu‐ mentation for your pipeline.\n\nSystem diagrams\n\nSystem diagrams, similar to Figure 13-2, can help on-call engineers quickly find potential failure points. At Google, we encourage teams to draw system diagrams that show each component (both pipeline applications and data stores), and the transfor‐ mations that happen at each step. Each of the components and transformations shown in your diagram can get stuck, causing data to stop flowing through the sys‐ tem. Each component can also introduce a software or application configuration bug that impacts data correctness.\n\nA system diagram should contain quick links to other monitoring and debugging information at different pipeline stages. Ideally, these links should pull from live monitoring information, displaying the current status of each stage (e.g., waiting for dependent job to finish/processing/complete). Displaying historical runtime infor‐ mation can also indicate if a pipeline stage is taking longer than expected. This delay can foreshadow performance degradation or an outage.\n\nPipeline Best Practices\n\n|\n\n271",
      "content_length": 2875,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 304,
      "content": "Finally, even in complex systems, a system diagram makes it easier for developers to analyze data dependencies they should be aware of during feature launches.\n\nFigure 13-2. Pipeline system diagram (PII = personally identifiable information)\n\nProcess documentation\n\nIt’s important to document how to perform common tasks, such as releasing a new version of a pipeline or introducing a change to the data format. Ideally, you should also document less common (often manual) tasks, such as initial service turnup or final service turndown in a new region. Once your tasks are documented, investigate the possibility of automating away any manual work. If the tasks and system are auto‐ mated, consider generating your documentation directly from the source so you can keep both in sync.\n\nPlaybook entries\n\nEach alert condition in your system should have a corresponding playbook entry that describes the steps to recovery. At Google, we find it useful to link this documenta‐ tion in any alert messages sent to on-call engineers. Playbook entries are discussed in more detail in Chapter 11 of our first book.\n\nMap Your Development Lifecycle As shown in Figure 13-3, the development lifecycle of a pipeline (or a change to a pipeline) isn’t too different from the development lifecycle of other systems. This sec‐ tion follows a typical release flow through each stage of the pipeline development lifecycle.\n\nFigure 13-3. Pipeline development lifecycle with release workflow\n\n272\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 1518,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 305,
      "content": "Prototyping\n\nThe first phase of development involves prototyping your pipeline and verifying semantics. Prototyping ensures that you can express the business logic necessary to execute your pipeline. You may discover that one programming language allows you to better express your business logic, or that a particular language more easily inte‐ grates with your existing libraries. A particular programming model may suit your specific use case (e.g., Dataflow versus MapReduce, batch versus streaming). For an example of a completed programming model comparison, see our blog post “Data‐ flow/Beam & Spark: A Programming Model Comparison”. If you are adding a feature to an existing pipeline, we recommend adding your code and running unit tests in the prototype stage.\n\nTesting with a 1% dry run\n\nOnce you have completed your prototype, it’s helpful to run a small setup on the full stack using production data. For example, run your pipeline using an experimental set, or a 1% dry run of production data in a nonproduction environment. Gradually scale up, tracking your pipeline performance to ensure you don’t encounter any bot‐ tlenecks. When your product has launched to customers, run performance tests. These tests are an integral development step that helps prevent outages caused by new feature rollouts.\n\nStaging\n\nBefore deploying to production, it’s useful to run your system in a preproduction (or staging) environment. The data in your staging environment should be as close to actual production data as possible. We recommend keeping a full copy of production data or at least a representative subset. Unit tests won’t catch all pipeline issues, so it’s important to let the data flow through the system end-to-end to catch integration issues.\n\nIntegration tests can also identify errors. Using both unit and integration tests, run an A/B comparison of your newly generated data to previously generated known good data. For example, check your previous release for expected or unexpected differ‐ ences before certifying the release and marking it ready to move to production.\n\nCanarying\n\nPipeline testing and verification requires more time and care than stateless jobs—the data is persisted and the transformations are often complex. If something goes wrong in your production release, it’s important to catch the issue early so you can limit the impact. Canarying your pipeline can help! Canarying is a process whereby you parti‐ ally deploy your service (in this case, the pipeline application) and monitor the results. For a more detailed discussion of canarying, see Chapter 16. Canarying is tied\n\nPipeline Best Practices\n\n|\n\n273",
      "content_length": 2649,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 306,
      "content": "to the entire pipeline rather than a single process. During a canary phase, you may choose to process the same real production data as the live pipeline but skip writes to production storage; techniques such as two-phase mutation can help (see the section “Idempotent and Two-Phase Mutations” on page 279). Often, you’ll have to wait for the complete cycle of processing to finish before you can discover any customer- impacting issues. After your dry run (or two-phase mutation), compare the results of your canary pipeline with your live pipeline to confirm their health and check for data differences.\n\nSometimes it is possible to progress through the canary by gradually updating tasks of a job or by updating first in one region and then another, but this is not always possible with pipelines. Pipelines that use replicated data, such as Dataproc3 and Dataflow,4 support regional endpoints5 and prevent this kind of canary progression— you can’t reload one cell in isolation from another. If you run a multihomed pipeline, it may not be possible to deploy to a single region (or a percentage of servers) like you might with a serving job. Instead, perform a rollout for a small percentage of data first, or as described earlier, roll out in dry-run mode first.\n\nDuring verification of your canary or preproduction environment, it is important to assess the health of your pipeline. Usually, you can use the same metrics you use to track your SLOs. Verifying your canary is a task that lends itself well to automation.\n\nPerforming a partial deployment\n\nIn addition to canarying your changes, you may also want to perform a partial deployment, particularly if there is a major feature launch or change that could impact system performance and resource usage. It can be difficult to predict the impact of these kinds of launches without first testing your changes on a subset of real traffic. You can implement a partial deployment as a flag or configuration option in your pipeline that accepts an allowed subset of data. Consider first processing your new features on one or two accounts, then gradually ramping up the amount of data (e.g., ~1%, ~10%, ~50%, and finally, 100% of your sample data).\n\n3 Cloud Dataproc is a fully managed cloud service for running Apache Spark and Apache Hadoop clusters.\n\n4 Cloud Dataflow is a fully managed cloud service for transforming data in stream and batch modes, with equal\n\nreliability and expressiveness.\n\n5 Regional endpoints control workers, and store and handle metadata for a Cloud Dataflow job.\n\n274\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 2592,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 307,
      "content": "There are a number of ways your partial deployment can go wrong: the input data might be incorrect or delayed, your data processing might have a bug, or your final storage might have an error. Any of these issues can result in an outage. Avoid promoting a corrupt set of data to your low-latency frontends. Aim to catch these types of issues as early as possible, before they reach your users.\n\nDeploying to production\n\nOnce you have fully promoted your new pipeline binaries and/or config to produc‐ tion, you should be reasonably confident that you’ve vetted any potential issues (and if an issue does occur, that your monitoring will alert you). If your deployment goes wrong, be able to quickly restore from a known good state (e.g., roll back the binar‐ ies) and mark any potentially broken data as bad (e.g., replace the bad data with data from a previous backup version, make sure no jobs read the affected data, and/or reprocess the data if necessary).\n\nReduce Hotspotting and Workload Patterns Hotspotting happens when a resource becomes overloaded from excessive access, resulting in an operation failure. Pipelines are susceptible to workload patterns—both through reads and writes—that can cause delays in isolated regions of data. Some common examples of hotspotting include:\n\nErrors thrown because multiple pipeline workers are accessing a single serving task, causing overload.\n\nCPU exhaustion due to concurrent access to a piece of data that is available on only one machine. Often, the internals of your data storage have a lowest level of granularity that may become unavailable if accessed heavily (e.g., a Spanner tab‐ let can become overloaded due to a problematic section of data even though most of the data storage is fine).\n\nLatency due to row-level lock contention in a database.\n\nLatency due to concurrent access to a hard drive, which exceeds the physical abil‐ ity of the drive head to move fast enough to quickly locate the data. In this case, consider using solid state drives.\n\nA large work unit that requires many resources.\n\nHotspotting can be isolated to a subset of data. To combat hotspotting, you can also block fine-grained data such as individual records. If that data is blocked, the rest of the pipeline can progress. Typically, your infrastructure can provide this functional‐ ity. If a chunk of processing work is consuming a disproportionate amount of resour‐ ces, the pipeline framework can dynamically rebalance by breaking the work into smaller pieces. To be safe, it’s still best to build an emergency shutdown into your\n\nPipeline Best Practices\n\n|\n\n275",
      "content_length": 2602,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 308,
      "content": "client logic to allow you to stop processing and isolate fine-grained chunks of pro‐ cessing work characterized by large resource usage or errors. For example, you should be able to quickly set a flag or push a config that allows you to skip input data that matches a certain pattern or problematic user.\n\nOther strategies to reduce hotspotting include:\n\nRestructuring your data or access patterns to spread the load evenly\n\nReducing the load (e.g., statically allocate some or all of your data)\n\nReducing lock granularity to avoid data lock contention\n\nImplement Autoscaling and Resource Planning Spikes in workload are common and can lead to service outages if you’re unprepared for them. Autoscaling can help you handle these spikes. By using autoscaling, you don’t have to provision for peak load 100% of the time (for more details on autoscal‐ ing, see Chapter 11). Constantly running the number of workers required for peak capacity is an expensive and inefficient use of resources. Autoscaling turns down idle workers so you won’t pay for resources you don’t need. This strategy is particularly important for streaming pipelines and workloads that are variable. Batch pipelines may run simultaneously and will consume as many resources as are available.\n\nPredicting the future growth of your system and allocating capacity accordingly ensures that your service won’t run out of resources. It’s also important to weigh the cost of resources against the engineering effort needed to make the pipeline more efficient. When conducting resource planning with an estimate of future growth, keep in mind that costs may not be isolated to just running your pipeline job. You may also be paying the data storage and network bandwidth costs for replicating data across regions or cross-region writes and reads. Additionally, some data store systems are more expensive than others. Even though unit storage costs are low, these costs can quickly add up for very large data sets or expensive data access patterns that use a lot of computing resources on the storage servers. It’s good practice to help drive down costs by periodically examining your data set and pruning unused content.\n\nAlthough the effectiveness of a series of pipeline stages should be measured according to its end-to-end SLO, the pipeline efficiency and resource usage should be measured at each individual stage. For example, imagine that you have many jobs using Big‐ Query and notice a significant increase in BigQuery resource usage after a release. If you can quickly determine which jobs are responsible, you can focus your engineer‐ ing effort on those jobs to drive down costs.\n\n276\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 2699,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 309,
      "content": "Adhere to Access Control and Security Policies Data flows through your system and is often persisted along the way. When manag‐ ing any persisted data, we recommend you adhere to the following privacy, security, and data integrity principles:\n\nAvoid storing personally identifiable information (PII) in temporary storage. If you’re required to store PII temporarily, make sure the data is properly encrypted.\n\nRestrict access to the data. Grant each pipeline stage only the minimal access it needs to read the output data from the previous stage.\n\nPut time to live (TTL) limits on logs and PII.\n\nConsider a BigQuery instance that is tied to a GCP project whose access permissions can be managed with Google Cloud Identity and Access Management (e.g., the Dressy example described earlier). Creating different projects and instances per func‐ tion allows more fine-grained scoping to restrict access. Tables can have a master project and cross-create views among client projects to allow them controlled access. For example, Dressy has restricted access to tables containing sensitive customer information for jobs from specific project roles.\n\nPlan Escalation Paths It is important to design your pipeline to be resilient so that a system failure (like a machine or zonal outage) never triggers an SLO violation page. By the time you get paged, you need to manually intervene because all automated measures have been exhausted. If you have well-defined SLOs and reliable metrics and alert detection, you’ll be alerted before your customers notice or report issues. When an SLO is viola‐ ted, it’s important to respond quickly and send proactive communication to your customers.\n\nPipeline Requirements and Design Today’s market provides many pipeline technology and framework options, and it can be overwhelming to identify which one best suits your use case. Some platforms provide fully managed pipelines. Others give you more flexibility but require more hands-on management. In SRE, we often take a significant amount of time during the design phase to assess which technology is the best fit. We compare and contrast the various design options based on user needs, product requirements, and system con‐ straints. This section discusses tools you can use to both assess your pipeline technol‐ ogy options and make improvements to existing pipelines.\n\nPipeline Requirements and Design\n\n|\n\n277",
      "content_length": 2394,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 310,
      "content": "What Features Do You Need? Table 13-1 provides a list of features we recommend you optimize for when manag‐ ing a data processing pipeline. Some of these features may already be present in your existing pipeline technology (e.g., via managed pipeline platforms, client application logic, or operational tools). Your application may not need some of these features— for example, you don’t need “exactly once” semantics if your work units are idempo‐ tent and can be performed more than once for the same result.\n\nTable 13-1. Recommended data pipeline features\n\nPipeline item Latency\n\nData correctness\n\nFeature Use an API that supports streaming, batch, or both. Streaming processing is generally better than batch processing at supporting lower-latency applications. If you choose batch but might at some point want streaming, an API that is interchangeable may reduce the migration cost later. Exactly-once semantics globally. You can require that data is processed (at most) once to get correct results. Two-phase mutations. Windowing functions for event processing and aggregations. You may want fixed time, session, or sliding windows to divide data (since data is not always processed in the order in which it’s received). You may also want in-order guarantees. Black-box monitoring. The ability to control the flow of multiple jobs or stages of your pipeline. This control should allow you to gate a job until another completes so the job does not process incomplete data.\n\nHigh availability\n\nMultihoming. Autoscaling.\n\nMean Time to Resolve (MTTR) incidents in data processing\n\nMean Time to Detect (MTTD) outages Development lifecycle to prevent errors from reaching production Inspect and predict resource usage or cost Ease of development\n\nTie your code changes to a release, which allows for fast rollbacks. Have tested data backup and restore procedures in place. In the event of an outage, ensure that you can easily drain a region from serving or processing. Have useful alert messages, dashboards, and logs for debugging. In particular, your monitoring should be quick to identify the reason(s) why a pipeline is delayed and/or why data is corrupt. Use data checkpointing to help recover faster when a pipeline is interrupted. Ensure you have SLO monitoring in place. Monitoring out-of-SLO alerts allows you to detect issues that impact your customers. Alerting on the symptom (versus the cause) reduces monitoring gaps. We recommend running any changes in a canary environment before deploying to production. This strategy lowers the possibility of a change impacting SLOs in production.\n\nCreate (or use an existing) resource accounting dashboard. Be sure to include resources like storage and network. Create a metric that allows you to correlate or predict growth.\n\nSupport a language that best fits your use case. Often pipeline technologies limit your options to one or two languages. Use a simple API for defining data transformations and expressing your pipeline logic. Consider the tradeoff between simplicity and flexibility. Reuse base libraries, metrics, and reporting. When you’re creating a new pipeline, reusable resources allow you to focus development on any new business logic.\n\n278\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 3253,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 311,
      "content": "Pipeline item Ease of operation\n\nFeature Use existing automation and operational tools as much as possible. Doing so reduces operational costs, as you don’t need to maintain your own tools. Automate as many operational tasks as possible. Larger tasks that are performed infrequently may include a chain of dependencies and prerequisites that can be too numerous or complex for a human to assess in a timely manner (e.g., moving your data and pipeline stack from region A to region B, then turning down region A). To ease a transition like this, consider investing in automation. Perhaps introduce some pipeline health checks on the pipeline stack in region B before putting it into production.\n\nIdempotent and Two-Phase Mutations Pipelines can process large amounts of data. When a pipeline fails, some data must be reprocessed. You can use the idempotent mutations design pattern to prevent storing duplicate or incorrect data. An idempotent mutation is a type of mutation that can be applied multiple times with the same result. Implementing this design pattern allows separate executions of a pipeline with the same input data to always produce the same result.\n\nWhen testing or canarying a pipeline, you need to know if your applied mutations are acceptable to the pipeline owner according to the expected output. The two-phase mutation design pattern can help here. Typically, the data is read from a source and transformed, and then a mutation is applied. With two-phase mutation, the muta‐ tions themselves are stored in a temporary location. A separate verification step (or pipeline) can run against these potential mutations to validate them for correctness. A follow-up pipeline step applies the verified mutations only after the mutations pass validation. Figure 13-4 shows an example of two-phase mutation.\n\nFigure 13-4. Two-phase mutation\n\nCheckpointing Typically, pipelines are long-running processes that analyze or mutate large amounts of data. Without special consideration, pipelines that are terminated early will lose their state, requiring the entire pipeline to be executed again. This is especially true\n\nPipeline Requirements and Design\n\n|\n\n279",
      "content_length": 2169,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 312,
      "content": "for pipelines that create AI models, as each iteration of the model calculation relies on previous calculations. Checkpointing is a technique that enables long-running pro‐ cesses like pipelines to periodically save partial state to storage so that they can resume the process later.\n\nWhile checkpointing is often used for the failure case, it’s also useful when a job needs to be preempted or rescheduled (e.g., to change CPU or RAM limits). The job can be cleanly shut down, and upon rescheduling, it’s able to detect which work units have already been processed. Checkpointing has the added advantage of enabling a pipeline to skip potentially expensive reads or computations because it already knows the work is done.\n\nCode Patterns Some common code patterns can make your pipelines more efficient to manage and reduce the effort required to make changes or updates.\n\nReusing code\n\nIf you operate multiple similar pipelines and want to implement a new monitoring capability or metric, you have to instrument each separate system. This common workflow isn’t difficult if you use the right strategy. Implementing reusable code libraries allows you to add a metric for monitoring in one place and share it across multiple pipelines or stages. Shared libraries allow you to:\n\nGain insight across all data pipelines in a standard way.\n\nReuse other data analytics systems for each pipeline (e.g., a traffic report that works for all of your pipelines).\n\nAlert on the same metric for multiple jobs, such as a generic data freshness alert.\n\nUsing the microservice approach to creating pipelines\n\nWhen using microservices, it’s important to have a service perform a single task and do it well. It’s easier to operate a group of microservices that use the same core libra‐ ries, varying only in their business logic, than it is to operate many custom services. A similar pattern can apply to pipelines. Instead of creating one monolithic pipeline application, create smaller pipelines that you can release and monitor separately. In doing so, you will get the same benefits as you get from a microservices architecture.\n\n280\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 2160,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 313,
      "content": "Pipeline Production Readiness As discussed in Chapter 18, a PRR (Production Readiness Review) is the process that Google SRE teams use to onboard a new service. In the same spirit, we use a pipeline maturity matrix when consulting on the choice or design of a pipeline technology.\n\nPipeline maturity matrix\n\nThe matrix in Table 13-2 measures five key characteristics (but you can extend the matrix to measure other characteristics you wish to optimize or standardize for):\n\nFailure tolerance\n\nScalability\n\nMonitoring and debugging\n\nTransparency and ease of implementation\n\nUnit and integration testing\n\nThe maturity matrix represents the collective knowledge of many pipeline experts at Google. These individuals are responsible for running pipelines across multiple Goo‐ gle products and productionizing the associated systems.\n\nEach characteristic is measured on a scale of 1 to 5, where 1 represents “Chaotic” (unplanned, ad hoc, risky, fully manual) and 5 represents “Continuous improve‐ ment.” To score your system, read the descriptions for each characteristic below, and select the best matching milestone. If more than one milestone applies, use the score in the middle (i.e., 2 or 4). A completed scoresheet will give you a clear picture of where your system needs improvement.\n\nWe recommend that you spend the time to make improvements in any weak areas identified by the matrix. Instrumenting monitoring, alerting, and other tooling rec‐ ommended by the matrix can be time-intensive. When making improvements, you can start by looking for existing products or open source tools that fit your needs instead of creating your own. At Google, we encourage teams to use existing pipeline technologies or tools that provide out-of-the-box pipeline support and features. The more tools and processes that can be reused, the better.\n\nPipeline Requirements and Design\n\n|\n\n281",
      "content_length": 1877,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 314,
      "content": "Table 13-2. Pipeline maturity matrix, with example milestones for beginning, medium, and advanced maturity\n\n1. Chaotic\n\n3. Functional\n\n5. Continuous improvement\n\nFailure tolerance Failover\n\nGlobal work scheduling\n\nFailed task management\n\nNo support for failover\n\nNo support for global work scheduling, multihoming, or failover\n\nNo support for failed work units\n\nSome support for work unit retries (even if manual) Support for hot/hot/hot processing (process same work in all three regions so if any region is unavailable, there is at least one still running) —\n\nMultihomed with automatic failover\n\nSupport for effective warm/warm/ warm processing (distribute work in all three regions and store work centrally to deal with any region loss)\n\nAutomatic retries for failed work units Automatic quarantine of bad work units\n\nScalability Automatic scaling of available worker pool\n\nAutomatic dynamic resharding to effect balanced load across the pool Load shedding/task prioritization\n\nNo autoscaling; manual intervention required\n\nWork units are fixed with no ability to make changes\n\nNo work unit prioritization exists\n\nAutoscaling works with the use of additional manual tools\n\nSupports manual resharding of work, or resharding can be achieved automatically with additional code Some capability for work unit prioritization\n\nBuilt-in automatic autoscaling support with no requirement for configuration inside a third-party tool Built-in support for dynamic subsharding to balance work across the available worker pool\n\nAn easy-to-use feature for work unit prioritization exists Built-in support for load shedding Workers understand preemption notification, after which a worker will clean up (finish work/mitigate)\n\nMonitoring and debugging Debugging tools and capabilities\n\nNo logs; no way to identify or track failed work units\n\nThere is a solution to identify a failed work unit and extract associated logs\n\nThere is a solution that allows a user to access logs for the time at which the work unit failed; this data is retrieved directly from the failed work unit There is a solution to automatically quarantine and replay a failed work unit\n\n282\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 2189,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 315,
      "content": "Dashboards and visualizations\n\n1. Chaotic No dashboards or visualization solutions that support the display of pipeline information\n\n3. Functional There is an easy-to-configure dashboard showing the following information:\n\nNumber of work units in various stages of completion\n\nLatency and aging\n\ninformation for each stage\n\nEase of implementation and transparency No feature for Discoverability discoverability (a list of the pipelines that are running and their status) Significant setup cost for using the technology\n\nSome support for discoverability; manual setup might be required, or not all pipelines are discoverable Some reusable components available\n\nCode\n\n5. Continuous improvement A fine-grained visualization of the entire execution map for a pipeline A visualization for delays up to each stage A visualization and rationale for throttling and pushback Information about limiting factors due to resource usage Information about the distribution of internal state worker machines (e.g., stack graph) Information about how many work units are failing, stuck, or slow Historical run statistics are presented and preserved Built-in support for automatic discoverability; a global data registry service that allows the listing of configured pipelines Base frameworks are available and require minimum code The pipeline can be configured in machine-readable format Zero config Libraries with semantics similar to other pipeline solutions that are most heavily used in related teams\n\nDocumentation and best practices\n\nSparse or outdated documentation\n\nMinimal setup documentation for each component\n\nComprehensive and up-to-date documentation Training examples for new users\n\nUnit and integration testing Unit testing framework\n\nNo support or unit testing framework\n\nTests take a long time to run and frequently time out Too many resource requirements No code coverage support Easy to switch data sources to test a resource\n\nRuns with sanitizers (ASAN, TSAN, etc.) The build dependency graph is as small as possible Code coverage support Provides debugging info and results No external dependencies Built-in test data generation library\n\nPipeline Requirements and Design\n\n|\n\n283",
      "content_length": 2184,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 316,
      "content": "Ease of configuration (this has direct relevance to the scalability aspect of the pipeline)\n\nSupport for integration testing frameworks (this describes how well a pipeline should interact and support various integration testing methodologies, which are not necessarily part of the pipeline itself)\n\n1. Chaotic Test configuration is not supported or requires a significant amount of time to learn, in addition to learning about the pipeline itself—for example, testing uses a different programming language and a different API than the pipeline Using Cloud or third-party open source tools for diffing, monitoring, integration testing, and so on, can be difficult to implement and/or resource-intensive; requires in-house tools or tools do not exist\n\n3. Functional The first integration test requires significant setup, but subsequent tests are either a copy/paste or an extension to the first with minimal overrides —for example, a test data generator could be minimally tweaked to support collecting test data for many different pipeline applications Minimal documentation and examples of integration testing tools and methodologies used in conjunction with the pipeline Large amount of time required even for data sets with minimal input Difficult to trigger on-demand execution for testing scenarios Difficult to separate production from nonproduction concerns (e.g., all event logs go to production logging service)\n\n5. Continuous improvement Decoupling from production configuration, while not preventing reuse; easier to define integration test configuration and reuse relevant parts of prod configuration\n\nBuilt-in support for scaled-down input data Support for diffing of output data (e.g., persisting output test data) Configurable monitoring for test run validation Ample documentation and examples of integration tests built for the pipeline\n\nPipeline Failures: Prevention and Response A pipeline can fail for many reasons, but the most common culprits are data delay and data corruption. When an outage occurs, finding and repairing the issue quickly will greatly reduce its impact. At Google, when an outage or SLO violation occurs, we track metrics for MTTD and MTTR. Tracking these metrics indicates how effective we are at detecting and repairing an issue. In the postmortem that follows any outage at Google, we analyze the cause of the outage to elicit any patterns and address sour‐ ces of operational toil.\n\nThis section describes some common failure modes, methods to effectively respond to pipeline failures, and strategies to help you prevent future pipeline failures.\n\nPotential Failure Modes\n\nDelayed data\n\nA pipeline can fail if its input or output is delayed. Without the proper precautions, a downstream job may start running even though it doesn’t have the necessary data. Stale data is almost always better than incorrect data. If your pipeline processes incomplete or corrupt data, errors will propagate downstream. Restoring or reproc‐ essing bad data takes time and can prolong an outage. Instead, if your pipeline stalls,\n\n284\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 3102,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 317,
      "content": "waits for data, and then resumes once the data becomes available, the data remains high quality. Creating data dependencies that are respected by all stages is important.\n\nDepending on the type of pipeline, the impact of delayed data can range from stale application data to stalled pipelines. In batch processing pipelines, each stage waits for its predecessor to finish before it begins. Streaming systems are more flexible: using event-time processing, such as Dataflow, a downstream stage can start a por‐ tion of work as soon as the corresponding upstream portion completes, rather than waiting for all portions to complete.\n\nWhen an outage of this nature occurs, you will likely need to notify any dependent services. If the outage is user-visible, you may also have to notify your customers. When you’re debugging pipeline outages, it’s helpful to see the progress of current and past pipeline runs, and to have direct links to log files and a diagram of the flow of data. It’s also useful to be able to trace a unit of work through the system while analyzing its counters and statistics.\n\nCorrupt data\n\nIf undetected, corrupt pipeline data (input and/or output) can cause user-facing issues. You can circumvent many user-facing issues by having tests that identify corrupt data in place, and using logic that alerts you to potential corruption. For example, pipeline systems can implement blocking policies and abuse/spam detection to automatically or manually filter out bad sources of data.\n\nCorrupt data can have many causes: software bugs, data incompatibility, unavailable regions, configuration bugs, and so on. There are two main steps involved in fixing corrupt data:\n\n1. Mitigate the impact by preventing further corrupt data from entering the system.\n\n2. Restore your data from a previously known good version, or reprocess to repair the data.\n\nIf a single region is serving corrupt data, you may need to drain your serving jobs and/or data processing from that region. If a software or configuration bug is at fault, you may need to quickly roll back the relevant binary. Often, data corruption can cause windows of data that are incorrect and need to be reprocessed once the under‐ lying issue has been fixed, such as fixing a software bug in a pipeline binary. To reduce the cost of reprocessing, consider selective reprocessing—read in and process only the user or account information impacted by the data corruption. Alternatively, you could persist some intermediate data that can serve as a checkpoint to avoid reprocessing a pipeline from end to end.\n\nIf the output of your pipeline is corrupt, downstream jobs may propagate the corrupt data or serving jobs may serve incorrect data. Even with the best testing, develop‐\n\nPipeline Failures: Prevention and Response\n\n|\n\n285",
      "content_length": 2798,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 318,
      "content": "ment, and release practices in place, a software or configuration bug can introduce data corruption. We recommend that you plan for this eventuality and have the abil‐ ity to quickly reprocess and restore your data. Recovering from this kind of data cor‐ ruption is labor-intensive and difficult to automate.\n\nPotential Causes\n\nPipeline dependencies\n\nWhen you’re trying to determine the cause of an outage, it’s useful to investigate pipeline dependencies, such as storage, network systems, or other services. These dependencies may be throttling your requests/traffic or, if they are out of resources, refusing any new data. The rate of input/output can slow for a variety of reasons:\n\nThe output sink or storage could be refusing writes of a piece of data.\n\nThere could be a particular hotspot data range that cannot complete.\n\nThere might be a storage bug.\n\nSome pipeline dependency issues won’t resolve themselves. It’s important to file a ticket or bug, and to allow for enough time to add more resources or address traffic patterns. Implementing load balancing and dropping low-priority data may help mit‐ igate the impact.\n\nPipeline application or configuration\n\nA pipeline failure could be the result of a bottleneck, a bug in your pipeline jobs, or a bug in the configurations themselves (e.g., CPU-intensive processing, performance regression, out-of-memory failures, abusive data prone to hotspotting, or configs that point to the incorrect input/output locations). Depending on the cause, there are sev‐ eral possible solutions:\n\nRoll back the binary/config, cherry-pick a fix, or repair any permission issues.\n\nConsider restructuring the data that’s causing the issue.\n\nApplication or configuration errors can introduce data incorrectness or lead to delayed data. These kinds of errors are the most common causes of outages. We rec‐ ommend spending time on pipeline development and ensuring that new binaries and configurations perform well in a nonproduction environment before they are fully deployed.\n\nUnexpected resource growth\n\nA sudden and unplanned jump in system load may cause a pipeline to fail. You may need additional unplanned resources to keep your service running. Automatic scaling\n\n286\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 2257,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 319,
      "content": "of your application jobs can help meet the demand of new load, but you should also be aware that an increased pipeline load can also put a strain on downstream depen‐ dencies—you may also need to plan for more storage and/or network resources.\n\nGood resource planning and accurate growth prediction can help in these cases, but such predictions may not always be correct. We recommend becoming familiar with the process of requesting additional emergency resources. Depending on the nature of your pipeline’s deployment and the quantity of resources required, the time needed to acquire these resources can be substantial. Therefore, we recommend pre‐ paring interim solutions to keep your service up and running—for example, priori‐ tize different classes of data through your pipeline.\n\nRegion-level outage\n\nA regional outage is bad for all pipelines, but singly homed pipelines are particularly vulnerable. If your pipeline runs in a single region that suddenly becomes unavail‐ able, the pipeline will stop until the region comes back up. If you have multihomed pipelines with automatic failover, your response may be as simple as draining pro‐ cessing or serving from an affected region until the outage is over. When a region is down, data can become stranded or delayed, resulting in incorrect output from your pipeline. As a result, the correctness of the data output from any dependent jobs or services may be compromised.\n\nCase Study: Spotify by Igor Maravić\n\nSpotify is the leading music streaming company in the world. Every day, tens of mil‐ lions of people use Spotify to listen to their favorite songs, share music with their friends, and discover new artists.\n\nThis case study describes our event delivery system, which is responsible for reliably collecting instrumentation data generated from Spotify applications. The data pro‐ duced by this system helps us to better understand our end users and to provide them with the right music at the right time.\n\nIn this case study, a “customer” refers to the development teams within Spotify that use data from the event delivery system. “End user” refers to individuals that use the Spotify service to listen to music.\n\nCase Study: Spotify\n\n|\n\n287",
      "content_length": 2209,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 320,
      "content": "Event Delivery We refer to end-user interactions as events. Every time a user listens to a song, clicks an ad, or follows a playlist, we record an event. Spotify captures and publishes hun‐ dreds of billions of events (of multiple types) to our servers daily. These events have many uses at Spotify, from A/B test analysis to showing play counts to powering per‐ sonalized discovery playlists. Most importantly, we pay royalties to artists based on delivered events.6 It’s imperative that we have a reliable means of event storage and delivery.\n\nBefore we can process event data, that data needs to be collected and delivered to per‐ sistent storage. We use an event delivery system to reliably collect and persist all pub‐ lished events. The event delivery system is one of the core pillars of our data infrastructure, as almost all of our data processing depends—either directly or indi‐ rectly—on the data it delivers.\n\nAll delivered events are partitioned by type and publishing time. As shown in Figure 13-5, events published during any given hour are grouped together and stored in a designated directory, called a delivered hourly bucket. These buckets are then grouped into event-type directories. This partitioning scheme simplifies data access control, ownership, retention, and consumption at Spotify.\n\nFigure 13-5. Delivered hourly buckets\n\n6 Delivered events are events that have been delivered to persistent storage and are exposed in such a way that\n\nthey can be consumed by customers of the event delivery system (e.g., data jobs).\n\n288\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 1594,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 321,
      "content": "Hourly buckets are the only interface our data jobs have with the event delivery sys‐ tem. As a result, we measure performance and define SLOs for our event delivery system based on how well we deliver hourly buckets per event type.\n\nEvent Delivery System Design and Architecture Our hourly buckets reside on Google Cloud Storage (GCS). Early in the design pro‐ cess, we decided to decouple data collection from data delivery within the system. To achieve this, we used a globally distributed persistent queue, Google Cloud Pub/Sub, as an intermediate layer. Once decoupled, data collection and delivery act as inde‐ pendent failure domains, which limits the impact of any production issues and results in a more resilient system. Figure 13-6 depicts the architecture of our event delivery system.\n\nFigure 13-6. Event delivery system architecture\n\nData collection\n\nProduced events7 are grouped by event types. Each event type describes a user action in the Spotify application. For example, one event type could refer to a user subscrib‐ ing to a playlist, while another event type could refer to a user starting playback of a song. To ensure that separate event types don’t impact each other, the system has full event type isolation. Individual events from different event types are published to their allocated topics in Google Cloud Pub/Sub. Publishing is performed by our microservices, which run both in Spotify datacenters and on Google Compute Engine (GCE). In order to be delivered, each published event stream is handled by a dedica‐ ted instance of an ETL process.\n\n7 Produced events are both the events that have been delivered and the events that are currently flowing\n\nthrough the event delivery system.\n\nCase Study: Spotify\n\n|\n\n289",
      "content_length": 1746,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 322,
      "content": "Extract Transform Load\n\nThe ETL process is responsible for delivering published events to the correct hourly buckets on GCS. The ETL process has three steps/components:\n\n1. A dedicated microservice consumes events from the event stream.\n\n2. Another microservice assigns events to their hourly partitions.\n\n3. A batch data job running on Dataproc deduplicates events from their hourly par‐ titions and persists them to their final location on GCS.\n\nEach ETL component has a single responsibility, which makes the components easier to develop, test, and operate.\n\nData delivery\n\nEvent type delivery is dynamically enabled or disabled directly by our customers (other engineering teams at Spotify). Delivery is controlled via simple configuration. In the configuration, customers define which event types should be delivered. As delivery of each event type is turned on or off, a microservice dynamically acquires and releases the Google GCE resources on which the ETL runs. The following code shows an example event type that a customer can enable/disable:\n\nevents: -CollectionUpdate -AddedToCollection -RemovedFromCollection\n\nWhen a customer enables delivery of a new event type, we don’t know in advance what quantity of resources are required to guarantee the delivery. Consequently, manually determining necessary resources is very expensive. To achieve optimal resource utilization for delivery of different event types, we use GCE Autoscaler.\n\nEvent Delivery System Operation Defining and communicating SLOs for our event delivery system helps in three ways:\n\nDesign and development\n\nWhen developing our systems, having clear SLOs in place gives us goals to work toward. These goals help us make pragmatic design choices and optimize our systems for simplicity.\n\nIdentify performance issues\n\nOnce our systems are deployed in production, SLOs help us to identify which parts of the system aren’t performing well and where we need to focus our efforts.\n\n290\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 2001,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 323,
      "content": "Set customer expectations\n\nSLOs allow us to manage our customer expectations and avoid unnecessary sup‐ port requests. When the limits of our system are clear to our customers, they are empowered to decide how to design, build, and operate their own systems that depend on our data.\n\nWe provide our customers with three SLO types for our event delivery system: timeli‐ ness, completeness, and skewness (discussed next). These SLOs are based on hourly data buckets provided by GCS. To be as objective as possible and to avoid bloating event delivery with features that have nothing to do with it, we measure all SLOs using independent external systems (e.g., Datamon, a data visualization tool explained in the next section).\n\nTimeliness\n\nOur timeliness SLO is defined as the maximum delay of delivering an hourly bucket of data. Delivery delay is calculated as the time difference between when the bucket was delivered and the earliest theoretical time the bucket could have been closed. Figure 13-7 provides an example of this delivery delay. The diagram shows the buck‐ ets for hours 12, 13, and 14. If the bucket for hour 13 was closed at 14:53, we would say the closing delay was 53 minutes.\n\nFigure 13-7. Event time partitioning\n\nTimeliness of data delivery is the metric we use to evaluate the performance of our data pipelines. To measure and visualize timeliness, we use a tool called Datamon, our internal data monitoring tool that was built around the notion of hourly buckets. Figure 13-8 shows a typical Datamon UI. Each green rectangle (in grayscale, the vast majority of the rectangles) represents an on-time hourly bucket. Gray rectangles (clustered here on the righthand side) indicate buckets that have not been delivered, while red rectangles (3 dark rectangles on the very top row) indicate buckets that weren’t delivered within the required SLO. Days when all hours were successfully delivered are shown as a single green rectangle.\n\nCase Study: Spotify\n\n|\n\n291",
      "content_length": 1981,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 324,
      "content": "Figure 13-8. Datamon for Spotify’s data monitoring system\n\nDownstream data jobs can’t start their processing until the hourly buckets on which they depend are delivered. Each data job periodically checks the delivery status of its dependencies before processing the data. Any delay in delivery affects the timeliness of downstream jobs. Our customers care deeply about having data delivered in a timely fashion. To help us prioritize delivery of events during an incident, our event delivery system’s timeliness SLO is split into three priority tiers: high, normal, and low. Our customers configure to the appropriate tier for their event type.\n\nSkewness\n\nWe define our skewness SLO as the maximal percentage of data that can be mis‐ placed on a daily basis. Skewness (and completeness) are concepts specific to our event delivery system and are not present in our other data pipelines. Defining an SLO for these concepts was a key requirement when we were designing our event delivery system, as it processes (among other event types) finance-bearing events. For all other events, best-effort delivery is good enough and we don’t expose a corre‐ sponding SLO. Whether or not an event is finance-bearing is determined by cus‐ tomer configuration.\n\nTo determine when an hourly bucket should be delivered, our event delivery system uses heuristics. By definition, heuristics aren’t always completely correct. As a result, undelivered events from previously delivered buckets might be delivered to an incor‐ rect future hourly bucket. This misplaced event is referred to as a skew. A skew can negatively impact jobs, since they might first underreport and then overreport values for some time periods. Figure 13-9 shows an example of skewed data delivery.\n\n292\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 1799,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 325,
      "content": "Figure 13-9. Delivery of skewed data\n\nCompleteness\n\nEvents can be lost in a distributed system in many ways—for example, a new release of our software may contain a bug, a cloud service may go down, or a developer might accidentally delete some persisted events. To ensure we are alerted about data loss, we measure completeness. We define completeness as the percentage of events that are delivered after they are successfully published to the system.\n\nWe report on skewness and completeness daily. To measure these values, we use an internal auditing system that compares the counts for all published and delivered events. Any mismatch is reported, and we take appropriate action.\n\nIn order to have timeliness, skewness, and completeness SLO guarantees, we assign events to our hourly buckets at the time they were received at our servers, not when they were produced on the clients. If our users are in offline mode, produced events can be buffered for up to 30 days on the clients before being published. Additionally, users can modify the system time on their device, which can result in inaccurately timestamped events. For these reasons, we use the timestamp from Spotify servers.\n\nWe don’t provide any SLOs regarding the data quality or accuracy of events delivered via our event delivery system. We observed that in a majority of cases, quality depends on the content of each event, which is populated by the business logic of our customers. To allow our system to scale with the number of customers, we keep it focused exclusively on delivering data. In this regard, we use the analogy that event delivery should behave like a postal service: your mail should be delivered on time, intact, and unopened. We leave the responsibility of providing quality SLOs to our internal teams that own the business logic and therefore understand the contents of the data.\n\nCustomer Integration and Support Many Spotify teams interact with the event delivery system daily. To encourage adoption and decrease the learning curve, we took the following steps to simplify user interaction with the event delivery system:\n\nCase Study: Spotify\n\n|\n\n293",
      "content_length": 2141,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 326,
      "content": "Event delivery as a fully managed service\n\nWe wanted to avoid exposing the complexity of the system to our customers, allowing them to focus on the specific problems they’re trying to solve. We strived to hide any system complexities behind a well-defined and easy-to- understand API.\n\nLimited functionality\n\nTo keep our APIs simple, we support only a limited set of functionalities. Events can be published only in a specific in-house format, and can be delivered only to hourly buckets with a single serialization format. These simple APIs cover the majority of our use cases.\n\nDelivery of each event needs to be explicitly enabled\n\nWhen a customer enables delivery of an event, they define whether the event is financial-bearing and its associated timeliness requirements. Furthermore, event ownership needs to be explicitly defined as part of the enabling process. We strongly believe that holding our internal teams accountable for events they produce results in higher data quality. Explicit ownership of the events also gives us a clear channel of communication during incidents.\n\nDocumentation\n\nNo matter how simple interacting with the system is, good documentation is required to provide a good customer experience. Subpar and stale documentation is a common problem in fast-paced companies like Spotify. To address this, we treat our documentation like any other software product: all support requests that come to our team are treated either as issues with our documentation or as issues in the actual product. Most support requests are related to the system’s public APIs. Some exam‐ ples of questions we try to answer when writing our documentation include:\n\nHow is the delivery of an event type enabled?\n\nWhere is the data delivered?\n\nHow is the data partitioned?\n\nWhat are our SLOs?\n\nWhat kind of support should our customers expect during incidents?\n\nOur goal is to minimize the amount of support requests we receive as our customer base grows.\n\nSystem monitoring\n\nMonitoring our SLOs provides high-level insights into the general health of the sys‐ tem. Our reliable catch-all monitoring solution ensures we always get alerted when something goes wrong. The main problem with using an SLO violation as criteria for\n\n294\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 2279,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 327,
      "content": "monitoring is that we get alerted after our customers have been affected. To avoid this, we need sufficient operational monitoring of our system to resolve or mitigate issues before an SLO is broken.\n\nWe monitor the various components of our system separately, starting with basic sys‐ tem metrics, then building to more complex ones. For example, we monitor CPU usage as a signal for instance health. CPU usage is not always the most critical resource, but it works well as a basic signal.\n\nSometimes system monitoring is insufficient when we’re trying to understand and fix production issues. To supplement our monitoring data, we also maintain application logs. These logs contain important information related to the operation and health of the component they describe. We take great care to ensure we gather only the correct amount of logging data, as it’s easy for irrelevant logs to drown useful ones. For example, a bad logging implementation might log all the incoming requests for a high-volume component that deals with incoming requests. Assuming that most of the requests are similar, logging every request doesn’t add much value. Additionally, when too many requests are logged, it becomes difficult to find other log entries, disk fills up faster, and the overall performance of our service starts to degrade. A better approach is to either rate-limit the amount of logged requests, or to log only interest‐ ing requests (like the ones that result in unhandled exceptions).\n\nDebugging components in production by reading through application logs is chal‐ lenging, and should be a last resort.\n\nCapacity planning\n\nReliable round-the-clock operation of the event delivery system requires the correct amount of allocated resources, especially since the components are deployed into a single GCP project and they share a common quota pool. We use capacity planning to determine how many resources each system component needs.\n\nFor the majority of our system components, capacity planning is based on CPU usage. We provision each component to have 50% of CPU usage during peak hours. This provision acts as a safety margin that allows our system to handle unexpected bursts of traffic. When Spotify ran its own datacenters, we provided each component with static resources. This led to a waste of resources during off-peak hours and an inability to handle large bursts in traffic. To improve resource utilization, we use GCE Autoscaler for some of our stateless components.\n\nWe had some growing pains in the early days of implementing Autoscaler; under cer‐ tain conditions, Autoscaler can cause failures. For example, we use CPU usage as a metric to perform autoscaling. Autoscaler itself depends on a strong correlation between CPU usage and the amount of work performed by each component instance. If the relationship is broken—either through the addition of CPU-hungry daemons\n\nCase Study: Spotify\n\n|\n\n295",
      "content_length": 2919,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 328,
      "content": "to each component instance or due to component instances extensively burning CPU without doing any work—Autoscaler will start far too many instances.\n\nWhen Autoscaler is presented with constantly increasing CPU usage that has no cor‐ relation with the amount of work performed, it will scale indefinitely until it uses all of the resources it can find. To prevent Autoscaler from using up all of our quota, we implemented some workarounds:\n\nWe limit the maximum number of instances Autoscaler can use.\n\nWe heavily restrict the CPU usage of all daemons running on an instance.\n\nWe aggressively throttle a component’s CPU usage as soon as we detect that no useful work is being done.\n\nEven when using Autoscaler, we need to conduct capacity planning. We need to ensure that we have enough quota, and that the maximum number of instances Autoscaler can use is set high enough to serve traffic during peaks, but low enough to limit the impact of “runaway” autoscaling.\n\nDevelopment process\n\nTo ship new features and improvements swiftly, we developed the event delivery sys‐ tem (shown in Figure 13-10) following the continuous integration and continuous delivery (CI/CD) process. According to this process, valid, proven, or reviewed sys‐ tem changes are deployed as soon as they’re made. Having sufficient test coverage is a prerequisite for each change to be successfully deployed without negatively impacting our SLOs.\n\nWe write tests following a “testing pyramid” philosophy. This means that for each of our components, we have plenty of unit tests that focus on components’ inner work‐ ings—in addition to a smaller number of integration tests that focus on components’ public API. At the highest level of the testing pyramid, we have a system-wide, end- to-end test. In this end-to-end test, all components are treated as black boxes so the system in the test environment resembles the one in production as much as possible.\n\nAfter initial development, every change goes through a peer review. As a part of the review process, all tests are executed on a shared CI/CD server, and the results are presented to the developers. Changes can be merged only after the reviewers approve the change and all the tests have successfully passed. As soon as the change is merged, the deployment process is triggered.\n\nThe event delivery system is a critical component in Spotify’s infrastructure. If it stopped delivering data, all data processing in Spotify would stall. For this reason, we decided to take a more conservative approach to deployments and deploy each change in stages. We require a manual approval before a deployment can move from one stage to another.\n\n296\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 2708,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 329,
      "content": "Figure 13-10. Development process\n\nDuring the first deployment stage, the change is deployed to the staging environ‐ ment. This low-risk staging system doesn’t handle production traffic. For testing pur‐ poses, a representative fraction of production traffic is mirrored in the staging system, which is a replica of the system running in production. At the second deploy‐ ment stage, the change is deployed to a small subset of production instances, or cana‐ ries. We perform a full production deployment only after we ensure that everything went well, both in staging and canaries (see Chapter 16).\n\nIncident handling\n\nWhen dealing with an incident, our first priority is to mitigate the damage and return the system to a stable previous state. To avoid making the situation worse, we refrain from deploying any major changes to our components during an incident. The exception to this rule is if we conclude that the incident was caused by recently deployed new code. In such cases, we immediately roll the system back to a previous working version.\n\nToday, the most common operational failures we encounter are caused either by a system malfunction (e.g., we introduce a software bug or a performance regression) or a failure with an external service on which we depend (e.g., an update to a service API isn’t backward-compatible or a service breaks its SLO). We use many battle- tested Google Cloud and internal Spotify services, like Cloud Pub/Sub and Helios, to speed up development of our system and to reduce our operational load. In the event\n\nCase Study: Spotify\n\n|\n\n297",
      "content_length": 1580,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 330,
      "content": "of an incident caused by an external service, we have a dedicated on-call team8 who provides support. One drawback of using external services is that we can’t do much to mitigate the problem ourselves. Furthemore, communicating the issue to a third party takes valuable time during an incident. Nevertheless, we believe that the ability to delegate responsibility is worth the occasional feeling of powerlessness.\n\nUnexpected system behavior under heavy load is another common source of opera‐ tional failure. Testing services under exact production conditions is impossible, so it’s hard to predict all of the edge cases that can happen. It can also be difficult to emulate the load our components face in production. Heavy load in combination with unforeseen edge cases can lead to interesting failure scenarios, such as the Autoscaler example described earlier in “Capacity planning” on page 295.\n\nOperational system failures can cause our SLOs to break. If our data freshness SLO is broken, no customer action is expected; customers must simply wait for their data to arrive. However, if our skewness or completeness SLOs are breached, we might need to involve customers, as data quality is compromised. When we detect either com‐ pleteness or skewness issues, the impacted events require reprocessing to be delivered correctly:\n\nTo deal with incompleteness, events need to be redelivered from the last check‐ point known to be good.\n\nTo deal with excessive skewness, already delivered events are reshuffled and assigned to their correct hourly buckets.\n\nBoth redelivery and reshuffling of events are done manually. After the delivered events are modified, we strongly advise our customers to reprocess them to produce data of sufficient quality.\n\nSummary Spotify’s event delivery system has evolved over the years. Because previous iterations were far less reliable, our engineers were paged every few nights. We spent the major‐ ity of our development sprints on incident remediations and postmortems. When designing the current incarnation, we focused on building a modularized system that does one core thing well: deliver events. Additionally, we wanted to provide event delivery as a product to the rest of Spotify. To achieve this, we needed to define and meet SLOs so that we could set clear expectations for our customers.\n\nWe employ a range of strategies to keep the service up and running—from well- documented on-call procedures to using well-proven external services (such as Goo‐\n\n8 The external service provider guarantees SLAs and has its own on-call team to ensure the product is meeting\n\nthese SLAs.\n\n298\n\n|\n\nChapter 13: Data Processing Pipelines",
      "content_length": 2668,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 331,
      "content": "gle Cloud Pub/Sub). Furthermore, a single team is responsible for the development and operation of the system throughout its entire lifecycle. This development struc‐ ture allows us to use the team experience we gain from maintaining the system to continually improve it.\n\nAs a result of these efforts, we now have a reliable system that allows us to focus our time on meeting more ambitious completeness, skewness, and timeliness SLOs. This results in better usability and a better overall customer experience.\n\nConclusion Applying SRE best practices to pipelines can help you make smart design choices and develop automation tools so that pipelines are easy to operate, scale more effectively, and are more reliable. Spotify’s event delivery system is an example of a pipeline built and operated with core SRE principles in mind, using a variety of technologies—from in-house, Google Cloud, and third parties—chosen to meet the customer’s need for timely data processing. Without proper care for operational best practices, pipelines may be more prone to failure and require a lot of manual work, especially during periods of growth, migrations, feature launches, or cleanup after outages. As with any complex system design, it is important to know your requirements and the SLOs you have chosen to keep, assess the available technology, and document the design and how to perform common tasks.\n\nConclusion\n\n|\n\n299",
      "content_length": 1416,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 333,
      "content": "CHAPTER 14 Configuration Design and Best Practices\n\nBy Štěpán Davidovič with Niall Richard Murphy, Christophe Kalt, and Betsy Beyer\n\nConfiguring systems is a common SRE task everywhere. It can be a tiring and frus‐ tratingly detailed activity, particularly if the engineer isn’t deeply familiar with the system they’re configuring or the configuration hasn’t been designed with clarity and usability in mind. Most commonly, you perform configuration in one of two scenar‐ ios: during initial setup when you have plenty of time, or during an emergency recon‐ figuration when you need to handle an incident.\n\nThis chapter examines configuration from the perspective of someone who designs and maintains an infrastructure system. It describes our experiences and strategies for designing configuration in a safe and sustainable way.\n\nWhat Is Configuration? When we deploy software systems, we do not think of them as fixed and never- changing. Ever-evolving business needs, infrastructure requirements, and other fac‐ tors mean that systems are constantly in flux. When we need to change system behavior quickly, and the change process requires an expensive, lengthy rebuild and redeployment process, a code change won’t suffice. Instead, configuration—which we can loosely define as a human-computer interface for modifying system behavior— provides a low-overhead way to change system functionality. SREs take advantage of this on a regular basis, when deploying systems and tuning their performance, as well as during incident response.\n\n301",
      "content_length": 1541,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 334,
      "content": "We can reason about systems as having three key components:\n\nThe software\n\nThe data set that the system works with\n\nThe system configuration\n\nWhile we can intuitively identify each of these components, they are often far from clearly separated. For example, many systems use programming languages for config‐ uration, or at least have the capability to reference programming languages. Examples include Apache and modules, such as mod_lua and its request hooks, or the window manager XMonad and its Haskell-based configuration. Similarly, data sets might contain code, such as stored SQL procedures, which can amount to complex applica‐ tions.\n\nA good configuration interface allows quick, confident, and testable configuration changes. When users don’t have a straightforward way to update configuration, mis‐ takes are more likely. Users experience increased cognitive load and a significant learning curve.\n\nConfiguration and Reliability Because our systems are ultimately managed by humans, humans are responsible for configuration. The quality of the human-computer interface of a system’s configura‐ tion impacts an organization’s ability to run that system reliably. The impact of a well-crafted (or poorly crafted) configuration interface is similar to the impact of code quality on system maintainability over time.\n\nHowever, configuration tends to differ meaningfully from code in several aspects. Changing a system’s capabilities via code is typically a lengthy and involved process, involving small incremental changes, code reviews, and testing. In contrast, changing a single configuration option can have dramatic changes on functionality—for exam‐ ple, one bad firewall configuration rule may lock you out of your own system. Unlike code, configuration often lives in an untested (or even untestable) environment.\n\nSystem configuration changes may need to be made under significant pressure. Dur‐ ing an incident, a configuration system that can be simply and safely adjusted is essential. Consider the interface design of early airplanes: confusing controls and indicators led to accidents. Research at the time showed that operator failures were frequent, regardless of pilot skill or experience.1 The link between usability and relia‐ bility translates to computing systems. Consider what happens if we swap a control stick and dial indicators for .conf files and monitoring graphs.\n\n1 Kim Vicente, The Human Factor (New York: Routledge, 2006), 71–6.\n\n302\n\n|\n\nChapter 14: Configuration Design and Best Practices",
      "content_length": 2530,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 335,
      "content": "Separating Philosophy and Mechanics We usually discuss configuration when designing new software or assembling a new system out of existing software components. How will we configure it? How will the configuration load? We’ll separate the overarching topic of configuration into two parts: configuration philosophy and configuration mechanics.\n\nConfiguration philosophy pertains to aspects of configuration that are completely independent of the chosen language and other mechanics. Our discussion of philoso‐ phy encompasses how to structure the configuration, how to achieve the correct level of abstraction, and how to support diverging use cases seamlessly.\n\nOur discussion of mechanics covers topics like language design, deployment strate‐ gies, and interactions with other systems. This chapter focuses less on mechanics, partly because topics like language choice are already being discussed across the industry. Additionally, because a given organization may already have strong outside requirements like preexisting configuration infrastructure, configuration mechanics aren’t easily generalizable. The following chapter on Jsonnet gives a practical example of configuration mechanics—in particular, language design—in existing software.\n\nDiscussing philosophy and mechanics separately allows us to reason more clearly about configuration. In practice, implementation details like configuration language (be it XML or Lua) don’t matter if configuration requires a huge amount of user input that’s difficult to understand. Conversely, even the simplest configuration inputs can cause problems if they must be entered into a very cumbersome interface. Consider the (very) old Linux kernel configuration process: configuration updates had to be made through a command-line terminal that required a sequence of com‐ mands to set each parameter. To make even the simplest correction, users had to start the configuration process from scratch.2\n\nConfiguration Philosophy This section discusses aspects of configuration that are completely independent of implementation, so these topics generalize across all implementations.\n\nIn the following philosophy, our ideal configuration is no configuration at all. In this ideal world, the system automatically recognizes the correct configuration based on deployment, workload, or pieces of configuration that already existed when the new system was deployed. Of course, for many systems, this ideal is unlikely to be attaina‐\n\n2 While clearly a hyperbole, a Reddit thread about the worst volume control interface can provide insight into the difference between good and bad mechanics of answering the same question, “What should the volume be?”\n\nConfiguration Philosophy\n\n|\n\n303",
      "content_length": 2726,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 336,
      "content": "ble in practice. However, it highlights the desirable direction of configuration: away from a large number of tunables and toward simplicity.\n\nHistorically, mission-critical systems offered a large amount of controls (which amount to system configuration), but also required significant human operator train‐ ing. Consider the complex array of operator controls in the NASA spacecraft control center in Figure 14-1. In modern computer systems, such training is no longer feasi‐ ble for the majority of the industry.\n\nFigure 14-1. Control panel in the NASA spacecraft control center, illustrating possibly very complex configuration\n\nWhile this ideal reduces the amount of control we can exercise over a system, it decreases both the surface area for error and cognitive load on the operator. As the complexity of systems grows, operator cognitive increasingly important.\n\nload becomes\n\nWhen we’ve applied these principles in practical systems at Google, they typically resulted in easy, broad adoption and low cost for internal user support.\n\n304\n\n|\n\nChapter 14: Configuration Design and Best Practices",
      "content_length": 1102,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 337,
      "content": "Configuration Asks Users Questions Regardless of what you’re configuring and how you’re configuring it, the human- computer interaction ultimately boils down to an interface that asks users questions, requesting inputs on how the system should operate. This model of conceptualization holds true regardless of whether users are editing XML files or using a configuration GUI wizard.\n\nIn modern software systems, we can approach this model from two different perspectives:\n\nInfrastructure-centric view\n\nIt’s useful to offer as many configuration knobs as possible. Doing so enables users to tune the system to their exact needs. The more knobs, the better, because the system can be tuned to perfection.\n\nUser-centric view\n\nConfiguration asks questions about infrastructure that the user must answer before they can get back to working on their actual business goal. The fewer knobs, the better, because answering configuration questions is a chore.\n\nDriven by our initial philosophy of minimizing user inputs, we favor the user-centric view.\n\nThe implications of this software design decision extend beyond configuration. Focusing configuration on the user means that your software needs to be designed with a particular set of use cases for your key audience. This requires user research. In contrast, an infrastructure-centric approach means that your software effectively pro‐ vides base infrastructure, but turning it into a practical system requires considerable configuration from the user. These models are not in strict conflict, but attempting to reconcile them can be quite difficult. Perhaps counterintuitively, limited configura‐ tion options can lead to better adoption than extremely versatile software—onboard‐ ing effort is substantially lower because the software mostly works “out of the box.”\n\nSystems that begin from an infrastructure-centric view may move toward a more user-centric focus as the system matures, by removing some configuration knobs via various means (some of which are discussed in subsequent sections).\n\nQuestions Should Be Close to User Goals As we follow the philosophy of user-centric configuration, we want to make sure users can easily relate to the questions we ask. We can think of the nature of user inputs on a spectrum: on one end, the user describes their needs in their own terms (fewer configuration options); on the other end, the user describes exactly how the system should implement their needs (more configuration options).\n\nConfiguration Philosophy\n\n|\n\n305",
      "content_length": 2514,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 338,
      "content": "Let’s use making tea as an analogy to configuring a system. With fewer configuration options, a user can ask for “hot green tea” and get roughly what they want. On the opposite end of the spectrum, a user can specify the whole process: water volume, boiling temperature, tea brand and flavor, steeping time, tea cup type, and tea volume in the cup. Using more configuration options might be closer to perfection, but the effort required to adhere to such detail might cost more than the marginal benefit of a near-perfect drink.\n\nThis analogy is helpful both to the users and the developers who work on the config‐ uration system. When a user specifies exact steps, the system needs to follow them. But when the user instead describes their high-level goals, the system can evolve over time and improve how it implements these goals. A good upfront understanding of user goals for the system is a necessary first step here.\n\nFor a practical illustration of how this spectrum plays out, consider job scheduling. Imagine you have a one-off analytical process to run. Systems like Kubernetes or Mesos enable you to meet your actual goal of running analysis, without burdening you with minute details like deciding which physical machine(s) your analytical pro‐ cess should run on.\n\nMandatory and Optional Questions A given configuration setup might contain two types of questions: mandatory and optional. Mandatory questions must be answered for the configuration to provide any functionality at all. One example might be who to charge for an operation. Optional questions don’t dictate core functionality, but answering them can improve the quality of the function—for example, setting a number of worker processes.\n\nIn order to remain user-centric and easy to adopt, your system should minimize the number of mandatory configuration questions. This is not an easy task, but it’s important. While one might argue that adding one or two small steps incurs little cost, the life of an engineer is often an endless chain of individually small steps. The principled reduction of these small steps can dramatically improve productivity.\n\nAn initial set of mandatory questions often includes the questions you thought about when designing the system. The easiest path to reduce mandatory questions is to convert them to optional questions, which means providing default answers that apply safely and effectively to most, if not all, users. For example, instead of requiring the user to define whether an execution should be dry-run or not, we can simply do dry-run by default.\n\nWhile this default value is often a static, hardcoded value, it doesn’t have to be. It can be dynamically determined based on other properties of the system. Taking advan‐ tage of dynamic determination can further simplify your configuration.\n\n306\n\n|\n\nChapter 14: Configuration Design and Best Practices",
      "content_length": 2873,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 339,
      "content": "For context, consider the following examples of dynamic defaults. A computationally intensive system might typically decide how many computation threads to deploy via a configuration control. Its dynamic default deploys as many threads as the system (or container) has execution cores. In this case, a single static default isn’t useful. Dynamic default means we don’t need to ask the user to determine the right number of threads for the system to deploy on a given platform. Similarly, a Java binary deployed alone in a container could automatically adjust its heap limits depending on memory available in the container. These two examples of dynamic defaults reflect common deployments. If you need to restrict resource usage, it’s useful to be able to override dynamic defaults in the configuration.\n\nThe implemented dynamic defaults might not work out for everyone. Over time, users might prefer different approaches and ask for greater control over the dynamic defaults. If a significant portion of configuration users report problems with dynamic defaults, it’s likely that your decision logic no longer matches the requirements of your current user base. Consider implementing broad improvements that enable your dynamic defaults to run without requiring additional configuration knobs. If only a small fraction of users are unhappy, they may be better off manually setting configuration options. Implementing more complexity in the system creates more work for users (e.g., increased cognitive load to read documentation).\n\nWhen choosing default answers for optional questions, regardless of whether you opt for static or dynamic defaults, think carefully about the impact of your choice. Expe‐ rience shows that most users will use the default, so this is both a chance and a responsibility. You can subtly nudge people in the right direction, but designating the wrong default will do a lot of harm. For example, consider configuration defaults and their impact outside of computer science. Countries where the default for organ donors is opt-in (and individuals can opt out if they’re so inclined) have dramatically greater ratios of organ donors than countries with an opt-out default.3 Simply select‐ ing a specific default has a profound impact on medical options throughout the entire system.\n\nSome optional questions start without a clear use case. You may want to remove these questions altogether. A large number of optional questions might confuse the user, so you should add configuration knobs only when motivated by a real need. Finally, if your configuration language happens to use the concept of inheritance, it is useful to be able to revert to the default value for any optional question in the leaf configurations.\n\n3 Full text: http://www.dangoldstein.com/papers/DefaultsScience.pdf.\n\nConfiguration Philosophy\n\n|\n\n307",
      "content_length": 2847,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 340,
      "content": "Escaping Simplicity Thus far, we’ve discussed reducing the configuration of a system to its simplest form. However, the configuration system may need to account for power users as well. To return to our tea analogy, what if we really need to steep the tea for a particular duration?\n\nOne strategy to accommodate power users is to find the lowest common denomina‐ tor of what regular users and power users require, and settle on that level of complex‐ ity as the default. The downside is that this decision impacts everyone; even the simplest use cases now need to be considered in low-level terms.\n\nBy thinking about configuration in terms of optional overrides of default behavior, the user configures “green tea,” and then adds “steep the tea for five minutes.” In this model, the default configuration is still high-level and close to the user’s goals, but the user can fine-tune low-level aspects. This approach is not novel. We can draw paral‐ lels to high-level programming languages like C++ or Java, which enable program‐ mers to include machine (or VM) instructions in code otherwise written in the high- level language. In some consumer software, we see screens with advanced options that can offer more fine-grained control than the typical view.\n\nIt’s useful to think about optimizing for the sum of hours spent configuring across the organization. Consider not only the act of configuration itself, but also the deci‐ sion paralysis users might experience when presented with many options, the time it takes to correct the configuration after taking a wrong turn, the slower rate of change due to lower confidence, and more. When you are considering configuration design alternatives, the option that accomplishes a complex configuration in fewer but sig‐ nificantly harder steps may be preferable if it makes supporting the most common use cases significantly easier.\n\nIf you find that more than a small subset of your users need a complex configuration, you may have incorrectly identified the common use cases. If so, revisit the initial product assumptions for your system and conduct additional user research.\n\nMechanics of Configuration Our discussion up to this point has covered configuration philosophy. This section shifts focus to the mechanics of how a user interacts with the configuration.\n\nSeparate Configuration and Resulting Data Which language to store the configuration in is an inevitable question. You could choose to have pure data like in an INI, YAML, or XML file. Alternatively, the con‐ figuration could be stored in a higher-level language that allows for much more flexi‐ ble configuration.\n\n308\n\n|\n\nChapter 14: Configuration Design and Best Practices",
      "content_length": 2692,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 341,
      "content": "Fundamentally, all questions the user is asked boil down to static information. This may include obviously static answers to questions like “How many threads should be used?” But even “What function should be used for every request?” is just a static ref‐ erence to a function.\n\nTo answer the age-old question of whether configuration is code or data, our experi‐ ence has shown that having both code and data, but separating the two, is optimal. The system infrastructure should operate on plain static data, which can be in for‐ mats like Protocol Buffers, YAML, or JSON. This choice does not imply that the user needs to actually interact with pure data. Users can interact with a higher-level inter‐ face that generates this data. This data format can, however, be used by APIs that allow further stacking of systems and automation.\n\nThis high-level interface can be almost anything. It can be a high-level language like Python-based Domain-Specific Language (DSL), Lua, or purpose-built languages, such as Jsonnet (which we will discuss in more detail in Chapter 15). We can think of such an interface as a compilation, similar to how we treat C++ code.4 The high-level interface might also be no language at all, with the configuration ingested by a web UI.\n\nStarting with a configuration UI that’s deliberately separated from its static data rep‐ resentation means the system has flexibility for deployment. Various organizations may have different cultural norms or product requirements (such as using specific languages within the company or needing to externalize configuration to end users), and a system this versatile can be adapted to support diverse configuration require‐ ments. Such a system can also effortlessly support multiple languages.5 See Figure 14-2.\n\nThis separation can be completely invisible to the user. The user’s common path may be to edit files in the configuration language while everything else happens behind the scenes. For example, once the user submits changes to the system, the newly stored configuration is automatically compiled into raw data.6\n\n4 Jsonnet is used to compile into Kubernetes YAML, providing a real-world illustration for this parallel. See\n\nhttp://ksonnet.heptio.com/.\n\n5 This can be useful when an organization performs migrations to new technologies, integrates acquisitions, or focuses on shared infrastructure but otherwise has divergent development and system management practices.\n\n6 There are various practical ways to automate compiling a new configuration into raw data. For example, if\n\nyou store your configuration in a version control system, a post-commit hook can facilitate this. Alternatively, a periodic update process can perform this, at the cost of some delay.\n\nMechanics of Configuration\n\n|\n\n309",
      "content_length": 2776,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 342,
      "content": "Figure 14-2. Configuration flow with a separate configuration interface and configura‐ tion data infrastructure. Note the web UI typically also displays the current configura‐ tion, making the relationship bidirectional.\n\nOnce the static configuration data is obtained, it can also be used in data analysis. For instance, if the generated configuration data is in JSON format, it can be loaded into PostgreSQL and analyzed with database queries. As the infrastructure owner, you can then quickly and easily query for which configuration parameters are being used and by whom. This query is useful for identifying features you can remove or measuring the impact of a buggy option.\n\nWhen consuming the final configuration data, you will find it useful to also store metadata about how the configuration was ingested. For example, if you know the data came from a configuration file in Jsonnet or you have the full path to the origi‐ nal before it was compiled into data, you can track down the configuration authors.\n\nIt is also acceptable for the configuration language to be static data. For example, both your infrastructure and interface might use plain JSON. However, avoid tight coupling between the data format you use as the interface and the data format you use internally. For example, you may use a data structure internally that contains the data structure consumed from configuration. The internal data structure might also contain completely implementation-specific data that never needs to be surfaced out‐ side of the system.\n\nImportance of Tooling Tooling can make the difference between a chaotic nightmare and a sustainable and scalable system, but it is often overlooked when configuration systems are designed. This section discusses the key tools that should be available for an optimal configura‐ tion system.\n\n310\n\n|\n\nChapter 14: Configuration Design and Best Practices",
      "content_length": 1891,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 343,
      "content": "Semantic validation\n\nWhile most languages offer syntax validation out of the box, don’t overlook semantic validation. Even if your configuration is syntactically valid, is it likely to do useful things? Or did the user reference a nonexistent directory (due to a typo), or need a thousand times more RAM than they actually have (because units aren’t what the user expected)?\n\nValidating that the configuration is semantically meaningful, to the maximum extent possible, can help prevent outages and decrease operational costs. For every possible misconfiguration, we should ask ourselves if we could prevent it at the moment the user commits the configuration, rather than after changes are submitted.\n\nConfiguration syntax\n\nWhile it’s key to ensure that configuration accomplishes what the user wants, it is also important to remove mechanical obstacles. From a syntax perspective, the con‐ figuration language should offer the following:\n\nSyntax highlighting in editors (used within the company)\n\nOften, you’ve already solved this by reusing an existing language. However, domain-specific languages may have additional “syntactic sugar” that can benefit from specialized highlighting.\n\nLinter\n\nUse a linter to identify common inconsistencies in language use. Pylint is one popular language example.\n\nAutomatic syntax formatter\n\nBuilt-in standardization minimizes relatively unimportant discussions about for‐ matting and decreases cognitive load as contributors switch projects. Standard formatting may also allow for easier automatic editing, which is helpful in sys‐ tems used broadly within a large organization. Examples of autoformatters in existing languages include clang-format7 and autopep8.\n\nThese tools enable users to write and edit configuration with confidence that their syntax is correct.8 Incorrect indentation in whitespace-oriented configs can have potentially great consequences—some of which standard formatting can prevent.\n\n7 Although C++ is unlikely to be used for configuration, clang-format nicely demonstrates that even a language\n\nmore complex than most languages used for configuration can in fact be fully autoformatted.\n\n8 In very large organizations, it is also useful to be able to annotate pieces of a broadly reused configuration that has been deprecated. When a replacement is available, automatic rewriting tools facilitate centralized changes, helping to avoid legacy issues.\n\nMechanics of Configuration\n\n|\n\n311",
      "content_length": 2451,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 344,
      "content": "Ownership and Change Tracking Because configuration can potentially impact critical systems of companies and insti‐ tutions, it’s important to ensure good user isolation, and to understand what changes happened in the system. As mentioned in Chapter 10, an effective postmortem cul‐ ture avoids blaming individuals. However, it’s helpful both during an incident and while you’re conducting a postmortem to know who changed a configuration, and to understand how the configuration change impacted the system. This holds true whether the incident is due to an accident or a malicious actor.\n\nEach configuration snippet for the system should have a clear owner. For example, if you use configuration files, their directories might be owned by a single production group. If files in a directory can only have one owner, it’s much easier to track who makes changes.\n\nVersioning configuration, regardless of how it is performed, allows you to go back in time to see what the configuration looked like at any given point in time. Checking configuration files into a versioning system, such as Subversion or Git, is a common practice nowadays, but this practice is equally important for configuration ingested by web UI or remote APIs. You may also wish to have tighter coupling between the configuration and the software being configured. By doing so, you can avoid inadver‐ tently configuring features that are either not yet available or no longer supported in the software.\n\nOn a related note, it is useful (and sometimes required) to log both changes to the configuration and the resulting application to the system. The simple act of commit‐ ting a new version of a configuration does not always mean that the configuration is directly applied (more on that later). When a system configuration change is suspec‐ ted as the culprit during an incident response, it is useful to be able to quickly deter‐ mine the full set of configuration edits that went into the change. This enables confident rollbacks, and the ability to notify parties whose configurations were impacted.\n\nSafe Configuration Change Application As discussed earlier, configuration is an easy way to make large changes to system functionality, but it is often not unit-tested or even easily testable. Since we want to avoid reliability incidents, we should inspect what the safe application of a configura‐ tion change means.\n\nFor a configuration change to be safe, it must have three main properties:\n\nThe ability to be deployed gradually, avoiding an all-or-nothing change\n\nThe ability to roll back the change if it proves dangerous\n\n312\n\n|\n\nChapter 14: Configuration Design and Best Practices",
      "content_length": 2660,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 345,
      "content": "Automatic rollback (or at a minimum, the ability to stop progress) if the change leads to loss of operator control\n\nWhen deploying a new configuration, it is important to avoid a global all-at-once push. Instead, push the new configuration out gradually—doing so allows you to detect issues and abort a problematic push before causing a 100% outage. This is one reason why tools such as Kubernetes use a rolling update strategy for updating soft‐ ware or configuration instead of updating every pod all at once. (See Chapter 16 for related discussions.)\n\nThe ability to roll back is important for decreasing incident duration. Rolling back the offending configuration can mitigate an outage much more quickly than attempt‐ ing to patch it with a temporary fix—there is inherently lower confidence that a patch will improve things.\n\nIn order to be able to roll forward and roll back configuration, it must be hermetic. Configuration that requires external resources that can change outside of its hermetic environment can be very hard to roll back. For example, configuration stored in a version control system that references data on a network filesystem is not hermetic.\n\nLast but not least, the system should be especially careful when handling changes that might lead to sudden loss of operator control. On desktop systems, screen resolution changes often prompt a countdown and reset if a user does not confirm changes. This is because an incorrect monitor setting might prevent the user from reverting the change. Similarly, it is common for system admins to accidentally firewall them‐ selves out of the system that they are currently setting up.\n\nThese principles are not unique to configuration and apply to other methods of changing deployed systems, such as upgrading binaries or pushing new data sets.\n\nConclusion Trivial configuration changes can impact a production system in dramatic ways, so we need to deliberately design configuration to mitigate these risks. Configuration design carries aspects of both API and UI design and should be purposeful—not just a side effect of system implementation. Separating configuration into philosophy and mechanics helps us gain clarity as we design internal systems, and enables us to scope discussion correctly.\n\nApplying these recommendations takes time and diligence. For an example of how we’ve applied these principles in practice, see the ACM Queue article on Canary Analysis Service. When designing this practical internal system, we spent about a\n\nConclusion\n\n|\n\n313",
      "content_length": 2529,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 346,
      "content": "month trying to reduce mandatory questions and finding good answers for optional questions. Our efforts created a simple configuration system. Because it was easy to use, it was widely adopted internally. We’ve seen little need for user support—since users can easily understand the system, they can make changes with confidence. Of course, we have not eliminated misconfigurations and user support entirely, nor do we ever expect to.\n\n314\n\n|\n\nChapter 14: Configuration Design and Best Practices",
      "content_length": 495,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 347,
      "content": "CHAPTER 15 Configuration Specifics\n\nBy Dave Cunningham and Misha Brukman with Christophe Kalt and Betsy Beyer\n\nManaging production systems is one of the many ways SREs provide value to an organization. The task of configuring and running applications in production requires insight into how those systems are put together and how they work. When things go wrong, the on-call engineer needs to know exactly where the configurations are and how to change them. This responsibility can become a burden if a team or organization hasn’t invested in addressing configuration-related toil.\n\nThis book covers the subject of toil at length (see Chapter 6). If your SRE team is bur‐ dened with a lot of configuration-related toil, we hope that implementing some of the ideas presented in this chapter will help you reclaim some of the time you spend making configuration changes.\n\nConfiguration-Induced Toil At the start of a project’s lifecycle, configuration is usually relatively lightweight and straightforward. You might have a few files in a data-only format like INI, JSON, YAML, or XML. Managing these files requires little toil. As the number of applica‐ tions, servers, and variations increases over time, configuration can become very complex and verbose. For example, you might have originally “changed a setting” by editing one configuration file, but now you have to update configuration files in mul‐ tiple locations. Reading such configuration is also hard, as important differences are hidden in a sea of irrelevant duplicated details. We can characterize this configuration-related toil as replication toil: the mundane task of managing configu‐ ration replicated across a system. This kind of toil isn’t limited to large organizations and huge systems—it’s especially common to microservice architectures with many independently configured components.\n\n315",
      "content_length": 1865,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 348,
      "content": "Engineers often respond to replication toil by building automation or a configuration framework. They aim to remove duplication in the config system, and to make con‐ figuration easier to understand and maintain. Reusing techniques from software engineering, this approach often makes use of a “configuration language.” Google SRE has created a number of configuration languages with the aim of reducing toil for our largest and most complex production systems.\n\nUnfortunately, this tactic doesn’t necessarily eliminate configuration toil. Freed from an overwhelming number of individual configs, the project (and its config corpus) grows with renewed energy. Inevitably, you run up against complexity toil: the chal‐ lenging and frustrating task of dealing with the emergent and sometimes undesirable behaviors of complex automation. This kind of toil typically materializes in larger organizations (10+ engineers) and compounds with growth. The earlier you can tackle complexity toil, the better; the size and complexity of configuration will only grow over time.\n\nReducing Configuration-Induced Toil If your project is riddled with configuration-related toil, you have a few basic strate‐ gies for improving the situation.\n\nIn rare cases, and if your application is custom-built, you might opt to remove the configuration altogether. The application may be naturally better than a configura‐ tion language at handling certain aspects of configuration: it might make sense for the application to assign defaults because it has access to information about the machine, or to vary some values dynamically because it can scale according to load.\n\nIf removing configuration is not an option, and replication toil is becoming a prob‐ lem, consider automation to reduce the duplication in your configuration corpus. You might integrate a new configuration language, or you might need to improve or replace your existing configuration setup.1 The next section, “Critical Properties and Pitfalls of Configuration Systems” on page 317, provides some guidance on choosing or designing that system.\n\nIf you go the route of setting up a new configuration framework, you’ll need to inte‐ grate the configuration language with the application that needs to be configured. “Integrating an Existing Application: Kubernetes” on page 322 uses Kubernetes as an example of an existing application to be integrated, and “Integrating Custom Appli‐ cations (In-House Software)” on page 326 gives some more general advice. These sections walk through some examples using Jsonnet (which we chose as a representa‐ tive configuration language for illustration purposes).\n\n1 Note that you may be able to write software to convert your old configuration language to the new language;\n\nhowever, if your original source language is nonstandard or broken, this isn’t a viable option.\n\n316\n\n|\n\nChapter 15: Configuration Specifics",
      "content_length": 2898,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 349,
      "content": "Once you have a configuration system in place to help with replication toil—whether you’re already committed to your existing solution, or you choose to implement a new configuration language—the best practices in “Effectively Operating a Configu‐ ration System” on page 329, “When to Evaluate Configuration” on page 331, and “Guarding Against Abusive Configuration” on page 333 should be helpful in optimiz‐ ing your setup, no matter which language you’re using. Adopting those processes and tools can help minimize complexity toil.\n\nCritical Properties and Pitfalls of Configuration Systems Chapter 14 outlined some critical properties of any configuration system. In addition to generic ideal requirements like lightweightness, ease of learning, simplicity, and expressive power, an efficient configuration system must:\n\nSupport configuration health, engineer confidence, and productivity via tooling for managing the config files (linters, debuggers, formatters, IDE integration, etc.).\n\nProvide hermetic evaluation of configuration for rollbacks and general replayability.\n\nSeparate config and data to allow for easy analysis of the config and a range of configuration interfaces.\n\nIt is not widely understood that these properties are critical, and arriving at our cur‐ rent understanding was indeed a journey. During this journey, Google invented sev‐ eral configuration systems that lacked these critical properties. We were not alone, either. Despite the great variety of popular configuration systems, it is difficult to find one that does not fall foul of at least one of the following pitfalls.\n\nPitfall 1: Failing to Recognize Configuration as a Programming Language Problem If you’re not intentionally designing a language, then it’s highly unlikely the “lan‐ guage” you’ll end up with is a good one.\n\nWhile configuration languages describe data rather than behavior, they still have the other characteristics of programming languages. If our configuration strategy starts with the objective of using a data-only format, programming language features tend to creep through the back door. Rather than remaining a data-only language, the for‐ mat becomes an esoteric and complex programming language.\n\nFor example, some systems add a count attribute to the schema of a virtual machine (VM) being provisioned. This attribute is not a property of the VM itself, but instead indicates that you want more than one of them. While useful, this is a feature of a\n\nCritical Properties and Pitfalls of Configuration Systems\n\n|\n\n317",
      "content_length": 2534,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 350,
      "content": "programming language, not a data format, because it requires an external evaluator or interpreter. A classical programming language approach would use logic outside the artifact, such as a for loop or list comprehension, to generate more VMs as required.\n\nAnother example is a configuration language that accrues string interpolation rules instead of supporting general expressions. The strings appear to be “just data,” although they can actually contain complex code, including data structure opera‐ tions, checksums, base64 encoding, and so on.\n\nThe popular YAML + Jinja solution also has drawbacks. Simple pure-data formats such as XML, JSON, YAML, and text-formatted protocol buffers are excellent choices for pure-data use cases. Likewise, textual templating engines such as Jinja2 or Go templates are excellent for HTML templating. But when combined in a configuration language, they become difficult for both humans and tools to maintain and analyze. In all of these cases, this pitfall leaves us with a complex esoteric “language” that isn’t suited to tooling.\n\nPitfall 2: Designing Accidental or Ad Hoc Language Features SREs typically feel configuration usability problems when operating systems at scale. A new language won’t have good tooling support (IDE support, good linters), and developing custom tooling is painful if the language has undocumented or esoteric semantics.\n\nAdding ad hoc programming language features to a simple config format over time might create a feature-complete solution, but ad hoc languages are more complex and usually have less expressive power than their formally designed equivalents. They also risk developing gotchas and idiosyncrasies because their authors couldn’t con‐ sider the interaction between features ahead of time.\n\nInstead of hoping your configuration system won’t grow complex enough to need simple programming constructs, it’s better to consider these requirements at the ini‐ tial design phase.\n\nPitfall 3: Building Too Much Domain-Specific Optimization The smaller the user base is for a new domain-specific solution, the longer you have to wait to accumulate enough users to justify building tooling. Engineers are unwill‐ ing to spend time understanding the language properly because it has little applicabil‐ ity outside this domain. Learning resources like Stack Overflow are less likely to be available.\n\n318\n\n|\n\nChapter 15: Configuration Specifics",
      "content_length": 2418,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 351,
      "content": "Pitfall 4: Interleaving “Configuration Evaluation” with “Side Effects” Side effects include either making changes to external systems, or consulting out-of- band data sources (DNS, VM IDs, latest build versions) during configuration runs.\n\nSystems that allow these side effects violate hermeticity, and also prevent the separa‐ tion of config from data. In an extreme case, it is impossible to debug your config without spending money by reserving cloud resources. In order to allow separation of config and data, first evaluate the config, then make the resulting data available to the user to analyze, and only then allow for side effects.\n\nPitfall 5: Using an Existing General-Purpose Scripting Language Like Python, Ruby, or Lua This seems like a trivial way to avoid the first four pitfalls, but implementations that use a general-purpose scripting language are heavyweight and/or need intrusive sandboxing to ensure hermeticity. Since general-purpose languages can access the local system, security considerations may also call for sandboxing.\n\nAdditionally, we can’t assume that the people maintaining configuration will be familiar with all of these languages.\n\nThe desire to avoid these pitfalls led to the development of reusable domain-specific languages (DSLs) for configuration, such as HOCON, Flabbergast, Dhall, and Jsonnet. We recommend using an existing DSL for configuration. Even if a DSL seems too powerful for your needs, you may need the additional functionality at some point, and you can always restrict the functionality of the language using an in- house style guide.\n\nA Very Quick Introduction to Jsonnet Jsonnet is a hermetic open source DSL that can be used as a library or command-line tool to provide configuration for any application. It is used widely both inside and outside Google.2\n\nThe language is designed to be familiar to programmers: it uses Python-like syntax, object orientation, and functional constructs. It is an extension of JSON, meaning that a JSON file is simply a Jsonnet program that outputs itself. Jsonnet is more per‐ missive with quotes and commas than JSON, and supports comments. More impor‐ tantly, it adds computational constructs.\n\n2 While fields from computational biology to video games use Jsonnet, the most enthusiastic adopters are from the Kubernetes community. Box.com uses Jsonnet to describe the workloads that run on their Kubernetes- based internal infrastructure platform. Databricks and Bitnami also use the language extensively.\n\nCritical Properties and Pitfalls of Configuration Systems\n\n|\n\n319",
      "content_length": 2570,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 352,
      "content": "While you don’t need to be particularly familiar with Jsonnet syntax to follow the rest of this chapter, spending just a few moments reading the online tutorial can help ori‐ ent you.\n\nThere is no dominant configuration language at Google or among our reader base, but we needed to choose some language that allows us to provide examples. This chapter uses Jsonnet to show practical examples of the recommendations we provide in Chap‐ ter 14.\n\nIf you aren’t already committed to a particular configuration lan‐ guage and want to use Jsonnet, you can directly apply the examples in this chapter. In all cases, we’ve done our best to make it as easy as possible for you to abstract the underlying lesson from the code examples.\n\nAdditionally, some of the examples explore concepts (like Turing completeness) that you might expect to find in a programming book. We have taken great care to dive only as deep as required to explain a subtlety that has actually bitten us in production. In most complex systems—and certainly with respect to configurations— the failures are at the edges.\n\nIntegrating a Configuration Language This section uses Jsonnet to discuss how to integrate a configuration language with the application you need to configure, but the same techniques also transfer to other configuration languages.\n\nGenerating Config in Specific Formats A configuration language might natively output in the correct format. For example, Jsonnet outputs JSON, which is compatible with many applications. JSON is also suf‐ ficient for consumers of languages that extend JSON, such as JavaScript, YAML, or HashiCorp’s Configuration Language. If this is your situation, you don’t need to per‐ form any further integration work.\n\nFor other configuration formats that are not natively supported:\n\n1. You need to find a way to represent configuration data within the configuration language. Usually, this is not hard because configuration values like maps, lists, strings, and other primitive values are generic and available in all languages.\n\n2. Once this data is represented in the config language, you can use the constructs of that language to reduce duplication (and thus, toil).\n\n320\n\n|\n\nChapter 15: Configuration Specifics",
      "content_length": 2224,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 353,
      "content": "3. You need to write (or reuse) a serialization function for the necessary output for‐ mat. For example, the Jsonnet standard library has functions for outputting INI and XML from its internal JSON-like representation. If configuration data resists representation within the configuration language (for example, a Bash script), you can use basic string templating techniques as a last resort. You can find prac‐ tical examples at http://bit.ly/2La0zDe.\n\nDriving Multiple Applications Once you can drive arbitrary existing applications from the config language, you might be able to target several applications from the same config. If your applications use different config formats, you’ll need to perform some conversion work. Once you’re able to generate configuration in the necessary formats, you can easily unify, synchronize, and eliminate repetition across your entire config corpus. Given the prevalence of JSON and JSON-based formats, you may not even have to generate dif‐ ferent formats—for example, this is true if you use a deployment architecture that uses GCP Deployment Manager, AWS Cloud Formation, or Terraform for base infrastructure, plus Kubernetes for containers.\n\nAt this point, you can:\n\nOutput an Nginx web server configuration and a Terraform firewall configura‐ tion from a single Jsonnet evaluation that defines the port only once.\n\nConfigure your monitoring dashboards, retention policies, and alert notification pipelines from the same files.\n\nManage the performance tradeoff between VM startup scripts and disk image- building scripts by moving initialization commands from one list to another.\n\nAfter you unite disparate configs in one place, you have many opportunities to refine and abstract the config. Configs can even be nested—for example, a Cassandra config may be embedded inside the Deployment Manager config of its base infrastructure or inside a Kubernetes ConfigMap. A good configuration language can handle any awk‐ ward string quoting and generally make this operation natural and simple.\n\nTo make it easy to write many different files for various applications, Jsonnet has a mode that expects config execution to yield a single JSON object that maps filenames to file content (formatted as needed). You can simulate this facility in other configu‐ ration languages by emitting a map from string to string and using a postprocessing step or wrapper script to write the files.\n\nIntegrating a Configuration Language\n\n|\n\n321",
      "content_length": 2467,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 354,
      "content": "Integrating an Existing Application: Kubernetes Kubernetes makes for an interesting case study for a couple of reasons:\n\nJobs running on Kubernetes need to be configured, and their configuration can become complex.\n\nKubernetes does not come with a bundled configuration language (not even an ad hoc one, thankfully).\n\nKubernetes users with minimally complex objects simply use YAML. Users with larger infrastructure extend their Kubernetes workflow with languages like Jsonnet to provide the abstraction facilities needed at that scale.\n\nWhat Kubernetes Provides Kubernetes is an open source system for orchestrating containerized workloads on a cluster of machines. Its API allows you to manage the containers themselves and many important details, such as communication between containers, communication in/out of the cluster, load balancing, storage, progressive rollout, and autoscaling. Each item of configuration is represented with a JSON object that can be managed via an API endpoint. The command-line tool kubectl lets you read these objects from disk and send them to the API.\n\nOn disk, the JSON objects are actually encoded as YAML streams.3 YAML is easily readable and converts easily to JSON via commonly available libraries. The out-of- the-box user experience involves writing YAML files that represent Kubernetes objects and running kubectl to deploy them to a cluster.\n\nTo learn about best practices for configuring Kubernetes, see the Kubernetes docu‐ mentation on that topic.\n\nExample Kubernetes Config YAML, the user interface to Kubernetes configuration, provides some simple features like comments, and has a concise syntax that most people prefer to raw JSON. How‐ ever, YAML falls short when it comes to abstraction: it only provides anchors,4 which are rarely useful in practice and are not supported by Kubernetes.\n\n3 A YAML stream is a file that contains many YAML documents separated by \"---\".\n\n4 YAML Specification §6.9.2.\n\n322\n\n|\n\nChapter 15: Configuration Specifics",
      "content_length": 1997,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 355,
      "content": "Suppose you want to replicate a Kubernetes object four times with different name‐ spaces, labels, and other minor variations. Following the best practices of immutable infrastructure, you store the config of all four variants, duplicating the other identical aspects of the configuration. The following code snippet presents one variant (for the sake of brevity, we omit the other three files):\n\n# example1.yaml apiVersion: v1 kind: Service metadata: labels: app: guestbook tier: frontend name: frontend namespace: prod spec: externalTrafficPolicy: Cluster ports: - port: 80 protocol: TCP targetPort: 80 selector: app: guestbook tier: frontend sessionAffinity: None type: NodePort\n\nThe variants are hard to read and maintain because the important differences are obscured.\n\nIntegrating the Configuration Language As discussed in “Configuration-Induced Toil” on page 315, managing a large number of YAML files can take a significant amount of time. A configuration language can help simplify this task. The most straightforward approach is to emit a single Kuber‐ netes object from each execution of Jsonnet, then pipe the resulting JSON directly into kubectl, which processes the JSON as if it’s YAML. Alternatively, you could emit a YAML stream (a sequence of such objects5) or a single kubectl list object, or have Jsonnet emit multiple files from the same config. For further discussion, see the Jsonnet website.\n\nDevelopers should be aware that in general, YAML allows you to write configs that are not expressible in JSON (and therefore, can’t be generated by Jsonnet). YAML configs can contain exceptional IEEE floating-point values like NaN, or objects with nonstring fields like arrays, other objects, or null. In practice, these features are very\n\n5 In the YAML specification, objects are known as documents.\n\nIntegrating an Existing Application: Kubernetes\n\n|\n\n323",
      "content_length": 1874,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 356,
      "content": "rarely used, and Kubernetes doesn’t allow them because the config must be JSON- encoded when sent to the API.\n\nThe following snippet shows what our example Kubernetes configuration would look like in Jsonnet:\n\n// templates.libsonnet { MyTemplate:: { local service = self, tier:: error 'Needs tier', apiVersion: 'v1', kind: 'Service',\n\nlocal selector_labels = { app: 'guestbook', tier: service.tier },\n\nmetadata: { labels: selector_labels, name: 'guestbook-' + service.tier, namespace: 'default', },\n\nspec: { externalTrafficPolicy: 'Cluster', ports: [{ port: 80, protocol: 'TCP', targetPort: 80, }], selector: selector_labels, sessionAffinity: 'None', type: 'NodePort', }, }, }\n\n// example1.jsonnet local templates = import 'templates.libsonnet';\n\ntemplates.MyTemplate { tier: 'frontend', }\n\n// example2.jsonnet local templates = import 'templates.libsonnet';\n\ntemplates.MyTemplate { tier: 'backend', metadata+: { namespace: 'prod', }, }\n\n324\n\n|\n\nChapter 15: Configuration Specifics",
      "content_length": 981,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 357,
      "content": "// example3.jsonnet local templates = import 'templates.libsonnet';\n\ntemplates.MyTemplate { tier: 'frontend', metadata+: { namespace: 'prod', labels+: { foo: 'bar' }, }, }\n\n// example4.jsonnet local templates = import 'templates.libsonnet';\n\ntemplates.MyTemplate { tier: 'backend', }\n\nNote the following:\n\nWe express all four variants by instantiating an abstract template four times, but you could also use functional abstractions.\n\nWhile we use a separate Jsonnet file for each instance, you might also consolidate them in a single file.\n\nIn the abstract template, the namespace defaults to default and the tier must be overridden.\n\nAt first glance, the Jsonnet is slightly more verbose, but reduces toil as the num‐ ber of template instantiations grows.\n\nWithin MyTemplate, the local keyword defines a variable service, which is initial‐ ized to self (a reference to the closest enclosing object). This allows you to refer to the object from within nested objects, where self is redefined.\n\nThe tier field has two colons (rather than the regular JSON single colon) and is hid‐ den (not output) in the generated JSON. Otherwise, Kubernetes will reject tier as an unrecognized field. Hidden fields can still be overridden and referenced—in this case, as service.tier.\n\nThe template cannot be used by itself because referencing service.tier triggers the error construct, which raises a runtime error with the given text. To avoid the error, each instance of the template overrides the tier field with some other expression. In other words, this pattern expresses something similar to a pure virtual/abstract method.\n\nUsing functions for abstraction means that config can only be parameterized. In con‐ trast, templates allow you to override any field from the parent. As described in\n\nIntegrating an Existing Application: Kubernetes\n\n|\n\n325",
      "content_length": 1840,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 358,
      "content": "Chapter 14, while simplicity should be fundamental to your design, the ability to escape simplicity is important. Template overrides provide a useful escape hatch to change specific details that might normally be considered too low-level. For example:\n\ntemplates.MyTemplate { tier: 'frontend', spec+: { sessionAffinity: 'ClientIP', }, }\n\nHere’s a typical workflow to convert an existing template to Jsonnet:\n\n1. Convert one of the YAML variants to JSON.\n\n2. Run the resulting JSON through the Jsonnet formatter.\n\n3. Manually add Jsonnet constructs to abstract and instantiate the code (as shown in the example).\n\nThe example showed how to remove duplication while retaining certain fields that were different. Using a configuration language becomes more compelling as differ‐ ences become more subtle (e.g., strings are slightly different) or challenging to express (e.g., configuration has structural differences like additional elements in arrays, or the same difference applied across all elements of an array).\n\nIn general, abstracting commonalities across different configurations promotes sepa‐ ration of concerns and has the same benefits as modularity in programming lan‐ guages. You can take advantage of abstraction capabilities for a number of different use cases:\n\nA single team might need to create multiple versions of their configuration that are almost (but not quite) the same—for example, when managing deployments across varied environments (prod/stage/dev/test), tuning deployments on differ‐ ent architectures, or adjusting capacity in different geographies.\n\nAn organization might have an infrastructure team that maintains reusable com‐ ponents—API serving frameworks, cache servers, or MapReduces—that are used by the application teams. For each component, the infrastructure team can main‐ tain a template that defines the Kubernetes objects needed to run that compo‐ nent at scale. Each application team can instantiate that template to add the particulars of their application.\n\nIntegrating Custom Applications (In-House Software) If your infrastructure utilizes any custom applications (i.e., software developed in- house, as opposed to off-the-shelf solutions), then you can design those applications\n\n326\n\n|\n\nChapter 15: Configuration Specifics",
      "content_length": 2274,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 359,
      "content": "to coexist with a reusable configuration language. The suggestions in this section should improve the overall user configuration experience when you are writing con‐ fig files or interacting with the generated config data (e.g., for debugging purposes, or when integrating with other tools). They should also simplify the application’s design and separate configuration from data.\n\nYour broad strategy for approaching custom applications should be to:\n\nLet the config language handle what it’s designed for: the language aspect of the problem.\n\nLet your application handle all other functionality.\n\nThe following best practices include examples that use Jsonnet, but the same recom‐ mendations apply to other languages:\n\nConsume a single pure data file, and let the config language split the config into files using imports. This means the config language implementation only has to emit (and the application only has to consume) a single file. Also, since applica‐ tions can combine files in different ways, this strategy explicitly and clearly delin‐ eates how the files are combined to form the application configuration.\n\nRepresent collections of named entities using objects, where the field contains the object name and the value contains the rest of the entity. Avoid using an array of objects where each element has a name field. Bad JSON: [ { \"name\": \"cat\", ... }, { \"name\": \"dog\", ... } ]\n\nGood JSON:\n\n{ \"cat\": { ... }, \"dog\": { ... } }\n\nThis strategy makes the collection (and individual animals) easier to extend, and you can reference entities by name (e.g., animals.cat) instead of referencing brittle indexes (e.g., animals[0]).\n\nAvoid grouping entities by type at the top level. Structure the JSON so that logi‐ cally related configuration is grouped in the same subtree. This allows abstrac‐ tion (at the config language level) to follow functional boundaries.\n\nIntegrating Custom Applications (In-House Software)\n\n|\n\n327",
      "content_length": 1938,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 360,
      "content": "Bad JSON: { \"pots\": { \"pot1\": { ... }, \"pot2\": { ... } }, \"lids\": { \"lid1\": { ... }, \"lid2\": { ... } } }\n\nGood JSON:\n\n{ \"pot_assembly1\": { \"pot\": { ... }, \"lid\": { ... } }, \"pot_assembly2\": { \"pot\": { ... }, \"lid\": { ... } } }\n\nAt the config language level, this strategy enables abstractions like the following:\n\nlocal kitchen = import 'kitchen.libsonnet'; { pot_assembly1: kitchen.CrockPot, pot_assembly2: kitchen.SaucePan { pot+: { color: 'red' } }, }\n\nGenerally keep the data representation design simple:\n\n— Avoid embedding language features in the data representation (as mentioned in “Pitfall 1: Failing to Recognize Configuration as a Programming Language Problem” on page 317). These types of abstractions will be underpowered and only create confusion, since they force users to decide whether to use the abstraction features in the data representation or in the configuration language.\n\n— Don’t worry about overly verbose data representation. Solutions to reduce verbosity introduce complexity, and the problem can be managed in the con‐ figuration language.\n\n— Avoid interpreting custom string interpolation syntax, such as conditionals or placeholder references in strings, in your application. Sometimes interpreta‐ tion is unavoidable—for example, when you need to describe actions that are performed after the pure data version of the config is generated (alerts, han‐ dlers, etc.). But otherwise, let the config language do as much of the language- level work as possible.\n\nAs mentioned earlier, if you can remove configuration altogether, doing so is always your best option. Although the configuration language can hide the complexity of the underlying model by using templates with default values, the generated config data is not completely hidden—it may be processed by tools, inspected by humans, or loaded into config databases. For the same reason, don’t rely on the configuration language to fix inconsistent naming, plurals, or mistakes in the underlying model— fix them in the model itself. If you can’t fix inconsistencies in the model, it is better to live with them at the language level to avoid even more inconsistency.\n\n328\n\n|\n\nChapter 15: Configuration Specifics",
      "content_length": 2197,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 361,
      "content": "In our experience, configuration changes tend to dominate outage root causes over time in a system (see our list of top causes of outages in Appendix C). Validating your config changes is a key step to maintaining reliability. We recommend validating the generated config data immediately after configuration execution. Syntactic validation alone (i.e., checking whether JSON is parsable) won’t find many bugs. After generic schema validation, check properties that are specific to your application’s domain— for example, whether required fields are present, referenced filenames exist, and pro‐ vided values are within allowed ranges.\n\nYou can validate Jsonnet’s JSON with JSONschema. For applications using protocol buffers, you can easily generate the canonical JSON form of these buffers from Json‐ net, and the protocol buffer implementation will validate during deserialization.\n\nNo matter how you decide to validate, do not ignore unrecognized field names, as they may indicate a typo at the configuration language level. Jsonnet can mask fields that should not be output using the :: syntax. It’s also a good idea to perform the same validation in a precommit hook.\n\nEffectively Operating a Configuration System When implementing “configuration as code” in any language, we recommend fol‐ lowing the discipline and processes that aid software engineering generally.\n\nVersioning Configuration languages usually trigger engineers to write libraries of templates and utility functions. Often, one team maintains these libraries, but many other teams may consume them. When you need to make a breaking change to the library, you have two choices:\n\nCommit a global update of all client code, refactoring the code so that it still works (this may not be organizationally possible).\n\nVersion the library so that different consumers can use different versions and migrate independently. Consumers who opt to use deprecated versions won’t get the benefits of the new versions and will incur technical debt—someday, they will have to refactor their code to use the new library.\n\nMost languages, including Jsonnet, do not provide any specific support for version‐ ing; instead, you can easily use directories. For a practical example in Jsonnet, see the ksonnet-lib repository, where the version is the first component of the imported path:\n\nlocal k = import 'ksonnet.beta.2/k.libsonnet';\n\nEffectively Operating a Configuration System\n\n|\n\n329",
      "content_length": 2439,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 362,
      "content": "Source Control Chapter 14 advocates keeping a historical record of config changes (including who made them) and ensuring that rollbacks are easy and reliable. Checking configura‐ tion into source control brings all these capabilities, plus the ability to code review config changes.\n\nTooling Consider how you will enforce style and lint your configurations, and investigate if there’s an editor plug-in that integrates these tools into your workflow. Your goals here are to maintain a consistent style across all authors, to improve readability, and to detect errors. Some editors support post-write hooks that can run formatters and other external tools for you. You can also use precommit hooks to run the same tools to ensure checked-in config is high quality.\n\nTesting We recommend implementing unit tests for upstream template libraries. Make sure the libraries generate the expected concrete configuration when instantiated in vari‐ ous ways. Similarly, libraries of functions should include unit tests so they can be maintained with confidence.\n\nIn Jsonnet, you can write tests as Jsonnet files that:\n\n1. Import the library to be tested.\n\n2. Exercise the library. 3. Use either the assert statement or the standard library assertEqual function to validate its output. The latter presents any mismatching values in its error messages.\n\nThe following example tests the joinName function and MyTemplate:\n\n// utils_test.jsonnet local utils = import 'utils.libsonnet';\n\nstd.assertEqual(utils.joinName(['foo', 'bar']), 'foo-bar') && std.assertEqual(utils.MyTemplate { tier: 'frontend' }, { ... })\n\nFor larger test suites, you can take advantage of a more comprehensive unit test framework developed by Jsonnet community members. You can use this framework to define and run suites of tests in a structured manner—for example, to report the set of all failing tests instead of aborting execution at the first failing assertion.\n\n330\n\n|\n\nChapter 15: Configuration Specifics",
      "content_length": 1972,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 363,
      "content": "When to Evaluate Configuration Our critical properties include hermeticity; that is, configuration languages must gen‐ erate the same config data regardless of where or when they execute. As described in Chapter 14 a system can be hard or impossible to roll back if it depends on resources that can change outside of its hermetic environment. Generally, hermeticism means that Jsonnet code is always interchangeable with the expanded JSON it represents. Accordingly, you can generate JSON from Jsonnet at any time between when the Jsonnet is updated and when you need the JSON—even each time you need the JSON.\n\nWe recommend storing configuration in version control. Then your earliest opportu‐ nity to validate the config is before check-in. At the other extreme, an application can evaluate the config when it needs the JSON data. As a middle-of-the-road option, you can evaluate at build time. Each of these options has various tradeoffs, and you should optimize according to the specifics of your use case.\n\nVery Early: Checking in the JSON You can generate JSON from the Jsonnet code before checking both in to version control. The typical workflow is as follows:\n\n1. Modify the Jsonnet files.\n\n2. Run the Jsonnet command-line tool (perhaps wrapped in a script) to regenerate JSON files.\n\n3. Use a precommit hook to ensure that the Jsonnet code and JSON output are always consistent.\n\n4. Package everything into a pull request for a code review.\n\nPros\n\nThe reviewer can sanity-check the concrete changes—for example, a refactoring should not affect the generated JSON at all.\n\nYou can inspect line annotations by multiple authors across different versions at both the generated and abstracted level. This is useful for auditing changes.\n\nYou don’t need to run Jsonnet at runtime, which can help to limit complexity, binary size, and/or risk exposure.\n\nWhen to Evaluate Configuration\n\n|\n\n331",
      "content_length": 1895,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 364,
      "content": "Cons\n\nThe generated JSON is not necessarily readable—for example, if it embeds long strings.\n\nThe JSON may not be suitable for checking into version control for other reasons —for example, if it’s too large or contains secrets.\n\nMerge conflicts may arise if many concurrent edits to separate Jsonnet files con‐ verge to a single JSON file.\n\nMiddle of the Road: Evaluate at Build Time You can avoid checking JSON into source control by running the Jsonnet command- line utility at build time and embedding the generated JSON into the release artifact (e.g., as a tarball). The application code simply reads the JSON file from disk at initi‐ alization time. If you’re using Bazel, you can easily achieve this using the Jsonnet Bazel rules. At Google, we commonly favor this approach because of the pros listed next.\n\nPros\n\nYou have the ability to control runtime complexity, binary size, and risk expo‐ sure without having to rebuild the JSON files in each pull request.\n\nThere’s no risk of desynchronization between originating Jsonnet code and resulting JSON.\n\nCons\n\nThe build is more complex.\n\nIt’s harder to evaluate the concrete change during code review.\n\nLate: Evaluate at Runtime Linking the Jsonnet library allows the application itself to interpret the config at any time, yielding an in-memory representation of the generated JSON config.\n\nPros\n\nIt’s simpler, as you don’t need a prior evaluation.\n\nYou gain the ability to evaluate Jsonnet code provided by the user during execution.\n\n332\n\n|\n\nChapter 15: Configuration Specifics",
      "content_length": 1537,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 365,
      "content": "Cons\n\nAny linked library increases the footprint and risk exposure.\n\nConfiguration bugs may be discovered at runtime, which is too late.\n\nIf the Jsonnet code is untrusted, you must take special care. (We discuss why in “Guarding Against Abusive Configuration” on page 333.)\n\nTo follow our running example, when should you run Jsonnet if you’re generating Kubernetes objects?\n\nThe answer depends on your implementation. If you’re building something like ksonnet (a client-side command-line tool that runs Jsonnet code from the local file‐ system), the easiest solution is to link the Jsonnet library into the tool and evaluate the Jsonnet in process. Doing so is safe because code runs on the author’s own machine.\n\nBox.com’s infrastructure uses Git hooks to push configuration changes to produc‐ tion. To avoid executing Jsonnet on the server, the Git hooks act on generated JSON that’s kept in the repository. For a deployment management daemon like Helm or Spinnaker, your only choice is to evaluate the Jsonnet on the server at runtime (with the caveats described in the next section).\n\nGuarding Against Abusive Configuration Unlike long-running services, configuration execution should quickly terminate with the resulting config. Unfortunately, due to bugs or deliberate attacks, configuration may take an arbitrary amount of CPU time or memory. To illustrate why, consider the following nonterminating Jsonnet program:\n\nlocal f(x) = f(x + 1); f(0)\n\nA program that uses unbounded memory is similar:\n\nlocal f(x) = f(x + [1]); f([])\n\nYou can write equivalent examples using objects instead of functions, or in other configuration languages.\n\nYou might try to avoid overconsuming resources by restricting the language so that it is no longer Turing complete. However, enforcing that all configurations terminate doesn’t necessarily prevent overconsuming resources. It’s easy to write a program that consumes enough time or memory to be practically nonterminating. For example:\n\nlocal f(x) = if x == 0 then [] else [f(x - 1), f(x - 1)]; f(100)\n\nIn fact, such programs exist even with simple config formats like XML and YAML.\n\nGuarding Against Abusive Configuration\n\n|\n\n333",
      "content_length": 2173,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 366,
      "content": "In practice, the risk of these scenarios depends on the situation. On the less problem‐ atic side, suppose a command-line tool uses Jsonnet to build Kubernetes objects and then deploys those objects. In this case, the Jsonnet code is trusted: accidents that produce nontermination are rare, and you can use Ctrl-C to mitigate them. Acciden‐ tal memory exhaustion is extremely unlikely. At the other extreme, with a service like Helm or Spinnaker, which accepts arbitrary config code from an end user and evalu‐ ates it in a request handler, you must be very careful to avoid DOS attacks that might tie up request handlers or exhaust memory.\n\nIf you evaluate untrusted Jsonnet code in a request handler, you can avoid such attacks by sandboxing the Jsonnet execution. One easy strategy is to use a separate process and ulimit (or its non-UNIX equivalent). Typically, you need to fork to the command-line executable instead of linking the Jsonnet library. As a result, programs that do not complete within given resources fail safely and inform the end user. For additional defense against C++ memory exploits, you can use the native Go imple‐ mentation of Jsonnet.\n\nConclusion Whether you use Jsonnet, adopt another configuration language, or develop your own, we hope that you can apply these best practices to manage the complexity and operational load required to configure your production system with confidence.\n\nAt a minimum, the critical properties of a configuration language are good tooling, hermetic configurations, and separation of configuration and data.\n\nYour system may not be complex enough to need a configuration language. Transi‐ tioning to a domain-specific language like Jsonnet is a strategy to consider when your complexity increases. Doing so will allow you to provide a consistent and well- structured interface, and will free up your SRE team’s time to work on other impor‐ tant projects.\n\n334\n\n|\n\nChapter 15: Configuration Specifics",
      "content_length": 1959,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 367,
      "content": "CHAPTER 16 Canarying Releases\n\nBy Alec Warner and Štěpán Davidovič with Alex Hidalgo, Betsy Beyer, Kyle Smith, and Matt Duftler\n\nRelease engineering is a term we use to describe all the processes and artifacts related to getting code from a repository into a running production system. Automating releases can help avoid many of the traditional pitfalls associated with release engi‐ neering: the toil of repetitive and manual tasks, the inconsistency of a nonautomated process, the inability of knowing the exact state of a rollout, and the difficulty of roll‐ ing back. The automation of release engineering has been well covered in other litera‐ ture—for example, books on continuous integration and continuous delivery (CI/CD).1\n\nWe define canarying as a partial and time-limited deployment of a change in a service and its evaluation. This evaluation helps us decide whether or not to proceed with the rollout. The part of the service that receives the change is “the canary,” and the remainder of the service is “the control.” The logic underpinning this approach is that usually the canary deployment is performed on a much smaller subset of produc‐ tion, or affects a much smaller subset of the user base than the control portion. Can‐ arying is effectively an A/B testing process.\n\nWe’ll first cover the basics of release engineering and the benefits of automating releases to establish a shared vocabulary.\n\n1 The authors of this chapter are fans of Jez Humble and David Farley’s book Continuous Delivery: Reliable\n\nSoftware Releases Through Build, Test, and Deployment Automation (Boston: Pearson, 2011).\n\n335",
      "content_length": 1620,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 368,
      "content": "Release Engineering Principles The basic principles of release engineering are as follows:\n\nReproducible builds\n\nThe build system should be able to take the build inputs (source code, assets, and so on) and produce repeatable artifacts. The code built from the same inputs last week should produce the same output this week.\n\nAutomated builds\n\nOnce code is checked in, automation should produce build artifacts and upload them to a storage system.\n\nAutomated tests\n\nOnce the automated build system builds artifacts, a test suite of some kind should ensure they function.\n\nAutomated deployments\n\nDeployments should be performed by computers, not humans.\n\nSmall deployments\n\nBuild artifacts should contain small, self-contained changes.\n\nThese principles provide specific benefits to operators:\n\nReducing operational load on engineers by removing manual and repetitive tasks.\n\nEnforcing peer review and version control, since automation is generally code-based.\n\nEstablishing consistent, repeatable, automated processes, resulting in fewer mistakes.\n\nEnabling monitoring of the release pipeline, allowing for measurement and con‐ tinuous improvement by addressing questions like:\n\n— How long does it take a release to reach production?\n\n— How often are releases successful? A successful release is a release made avail‐\n\nable to customers with no severe defects or SLO violations.\n\n— What changes can be made to catch defects as early in the pipeline as\n\npossible?\n\n— Which steps can be parallelized or further optimized?\n\nCI/CD coupled with release automation can deliver continuous improvements to the development cycle, as shown in Figure 16-1. When releases are automated, you can\n\n336\n\n|\n\nChapter 16: Canarying Releases",
      "content_length": 1722,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 369,
      "content": "release more often. For software with a nontrivial rate of change, releasing more often means fewer changes are bundled in any given release artifact. Smaller, self-contained release artifacts make it cheaper and easier to roll back any given release artifact in the event of a bug. Quicker release cadences mean that bug fixes reach users faster.\n\nFigure 16-1. The virtuous cycle of CI/CD\n\nBalancing Release Velocity and Reliability Release velocity (hereafter called “shipping”) and reliability are often treated as opposing goals. The business wants to ship new features and product improvements as quickly as possible with 100% reliability! While that goal is not achievable (as 100% is never the right target for reliability; see Chapter 2), it is possible to ship as quickly as possible while meeting specific reliability goals for a given product.\n\nThe first step toward this goal is understanding the impact of shipping on software reliability. In Google’s experience, a majority of incidents are triggered by binary or configuration pushes (see Appendix C). Many kinds of software changes can result in a system failure—for example, changes in the behavior of an underlying component, changes in the behavior of a dependency (such as an API), or a change in configura‐ tion like DNS.\n\nDespite the risk inherent in making changes to software, these changes—bug fixes, security patches, and new features—are necessary for the business to succeed. Instead of advocating against change, you can use the concept of SLOs and error budgets to measure the impact of releases on your reliability. Your goal should be to ship soft‐ ware as quickly as possible while meeting the reliability targets your users expect. The following section discusses how you can use a canary process to achieve these goals.\n\nSeparating Components That Change at Different Rates Your services are composed of multiple components with different rates of change: binaries or code, environments such as JVM, kernel/OS, libraries, service config or flags, feature/experiment config, and user config. If you have only one way to deploy\n\nBalancing Release Velocity and Reliability\n\n|\n\n337",
      "content_length": 2162,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 370,
      "content": "changes, actually allowing these components to change independently may be difficult.\n\nFeature flag or experiment frameworks like Gertrude, Feature, and PlanOut allow you to separate feature launches from binary releases. If a binary release includes multiple features, you can enable them one at a time by changing the experiment configuration. That way, you don’t have to batch all of these changes into one big change or perform an individual release for each feature. More importantly, if only some of the new features don’t behave as expected, you can selectively disable those features until the next build/release cycle can deploy a new binary.\n\nYou can apply the principles of feature flags/experiments to any type of change to your service, not just software releases.\n\nWhat Is Canarying? The term canarying refers to the practice of bringing canaries into coal mines to determine if the mine is safe for humans. Because the birds are smaller and breathe faster than humans, they are intoxicated by dangerous gases faster than their human handlers.\n\nEven if your release pipeline is fully automated, you won’t be able to detect all release-related defects until real traffic is hitting the service. By the time a release is ready to be deployed to production, your testing strategy should instill reasonable confidence that the release is safe and works as intended. However, your test environ‐ ments aren’t 100% identical to production, and your tests probably don’t cover 100% of possible scenarios. Some defects will reach production. If a release deploys instantly everywhere, any defects will deploy in the same way.\n\nThis scenario might be acceptable if you can detect and resolve the defects quickly. However, you have a safer alternative: initially expose just some of your production traffic to the new release using a canary. Canarying allows the deployment pipeline to detect defects as quickly as possible with as little impact to your service as possible.\n\nRelease Engineering and Canarying When deploying a new version of a system or its key components (such as configura‐ tion or data), we bundle changes—changes that typically have not been exposed to real-world inputs, such as user-facing traffic or batch processing of user-supplied data. Changes bring new features and capabilities, but they also bring risk that is exposed at the time of deployment. Our goal is to mitigate this risk by testing each change on a small portion of traffic to gain confidence that it has no ill effects. We will discuss evaluation processes later in this chapter.\n\n338\n\n|\n\nChapter 16: Canarying Releases",
      "content_length": 2613,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 371,
      "content": "The canary process also lets us gain confidence in our change as we expose it to larger and larger amounts of traffic. Introducing the change to actual production traffic also enables us to identify problems that might not be visible in testing frameworks like unit testing or load testing, which are often more artificial.\n\nWe will examine the process of canarying and its evaluation using a worked example, while steering clear of a deep dive into statistics. Instead, we focus on the process as a whole and typical practical considerations. We use a simple application on App Engine to illustrate various aspects of the rollout.\n\nRequirements of a Canary Process Canarying for a given service requires specific capabilities:\n\nA method to deploy the canary change to a subset of the population of the service.2\n\nAn evaluation process to evaluate if the canaried change is “good” or “bad.”\n\nIntegration of the canary evaluations into the release process.\n\nUltimately, the canary process demonstrates value when canaries detect bad release candidates with high confidence, and identify good releases without false positives.\n\nOur Example Setup We’ll use a simple frontend web service application to illustrate some canarying con‐ cepts. The application offers an HTTP-based API that consumers can use to manipu‐ late various data (simple information like the price of a product). The example application has some tunable parameters that we can use to simulate various produc‐ tion symptoms, to be evaluated by the canary process. For example, we can make the application return errors for 20% of requests, or we can stipulate that 5% of requests take at least two seconds.\n\nWe illustrate the canary process using an application deployed on Google App Engine, but the principles apply to any environment. While the example application is fairly contrived, in real-world scenarios, similar applications share common signals with our example that can be used in a canary process.\n\nOur example service has two potential versions: live and release candidate. The live version is the version currently deployed in production, and the release candidate is a newly built version. We use these versions to illustrate various rollout concepts and how to implement canaries to make the rollout process safer.\n\n2 The fraction of total service load you run on the canary should be proportional to the size of the canary\n\npopulation.\n\nRelease Engineering and Canarying\n\n|\n\n339",
      "content_length": 2462,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 372,
      "content": "A Roll Forward Deployment Versus a Simple Canary Deployment Let’s first look at a deployment with no canary process, so we can later compare it to a canaried deployment in terms of error budget savings and general impact when a breakage occurs. Our deployment process features a development environment. Once we feel the code is working in the development environment, we deploy that version in the production environment.\n\nShortly after our deployment, our monitoring starts reporting a high rate of errors (see Figure 16-2, where we intentionally configured our sample application to fail 20% of requests to simulate a defect in the example service). For the sake of this example, let’s say that our deployment process doesn’t provide us the option to roll back to a previously known good configuration. Our best option to fix the errors is to find defects in the production version, patch them, and deploy a new version during the outage. This course of action will almost certainly prolong the user impact of the bug.\n\nFigure 16-2. High rate of errors after deployment\n\n340\n\n|\n\nChapter 16: Canarying Releases",
      "content_length": 1112,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 373,
      "content": "To improve upon this initial deployment process, we can utilize canaries in our roll‐ out strategy to reduce the impact of a bad code push. Instead of deploying to produc‐ tion all at once, we need a way to create a small segment of production that runs our release candidate. Then we can send a small portion of the traffic to that segment of production (the canary) and compare it against the other segment (the control). Using this method, we can spot defects in the release candidate before all of produc‐ tion is affected.\n\nThe simple canary deployment in our App Engine example splits traffic between spe‐ cific labeled versions of our application. You can split traffic using App Engine, or any number of other methods, such as backend weights on a load balancer, proxy configurations, or round-robin DNS records.\n\nFigure 16-3 shows that the impact of the change is greatly reduced when we use a canary; in fact, the errors are barely visible! This raises an interesting issue: the canary evaluation is difficult to see and track compared to the overall traffic trend.\n\nFigure 16-3. Error rate of canary deployment; because the canary population is a small subset of production, the overall error rate is reduced\n\nTo get a clearer picture of the errors we need to track at a reasonable scale, we can look at our key metric (HTTP response codes) by App Engine application version, as\n\nA Roll Forward Deployment Versus a Simple Canary Deployment\n\n|\n\n341",
      "content_length": 1458,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 374,
      "content": "shown in Figure 16-4. When we look at per-version breakdown, we can plainly see the errors the new version introduces. We can also observe from Figure 16-4 that the live version is serving very few errors.\n\nWe can now tune our deployment to automatically react based on the HTTP error rate by App Engine version. If the error rate of the canary metric is too far from the control error rate, this signals the canary deployment is “bad.” In response, we should pause and roll back the deployment, or perhaps contact a human to help trouble‐ shoot the issue. If the error ratios are similar, we can proceed with the deployment as normal. In the case of Figure 16-4, our canary deployment is clearly bad and we should roll it back.\n\nFigure 16-4. HTTP response codes by App Engine version; the release candidate serves the vast majority of the errors, while the live version produces a low number of errors at a steady state (note: the graph uses a base-10 log scale)\n\nCanary Implementation Now that we’ve seen a fairly trivial canary deployment implementation, let’s dig deeper into the parameters that we need to understand for a successful canary process.\n\n342\n\n|\n\nChapter 16: Canarying Releases",
      "content_length": 1194,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 375,
      "content": "Minimizing Risk to SLOs and the Error Budget Chapter 2 discusses how SLOs reflect business requirements around service availabil‐ ity. These requirements also apply to canary implementations. The canary process risks only a small fragment of our error budget, which is limited by time and the size of the canary population.\n\nGlobal deployment can place the SLO at risk fairly quickly. If we deploy the candidate from our trivial example, we would risk failing 20% of requests. If we instead use a canary population of 5%, we serve 20% errors for 5% of traffic, resulting in a 1% over‐ all error rate (as seen earlier in Figure 16-3). This strategy allows us to conserve our error budget—impact on the budget is directly proportional to the amount of traffic exposed to defects. We can assume that detection and rollback take about the same time for both the naive deployment and the canary deployment, but when we inte‐ grate a canary process into our deployment, we learn valuable information about our new version at a much lower cost to our system.\n\nThis is a very simple model that assumes uniform load. It also assumes that we can spend our entire error budget (beyond what we’ve already included in the organic measurement of current availability) on canaries. Rather than actual availability, here we consider only unavailability introduced by new releases. Our model also assumes a 100% failure rate because this is a worst-case scenario.3 It is likely that defects in the canary deployment will not affect 100% of system usage. We also allow overall system availability to go below SLO for the duration of the canary deployment.4\n\nThis model has clear flaws, but is a solid starting point that you can adjust to match business needs.5 We recommend using the simplest model that meets your technical and business objectives. In our experience, focusing on making the model as techni‐ cally correct as possible often leads to overinvestment in modeling. For services with high rates of complexity, overly complex models can lead to incessant model tuning for no real benefit.\n\nChoosing a Canary Population and Duration When choosing an appropriate canary duration, you need to factor in development velocity. If you release daily, you can’t let your canary last for a week while running\n\n3 At least as far as availability is concerned. This analysis obviously does not cover the impact of incidents, such\n\nas a data leak.\n\n4 For a sufficiently small canary, where the fraction of service equals the difference between actual availability\n\nand SLO, we can canary nonstop with confidence. This is our use of the error budget.\n\n5 As British statistician George Box said, “Essentially, all models are wrong, but some are useful.” George E. P. Box and Norman R. Draper, Empirical Model-Building and Response Surfaces (New York: John Wiley and Sons, 1987).\n\nCanary Implementation\n\n|\n\n343",
      "content_length": 2888,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 376,
      "content": "only one canary deployment at a time. If you deploy weekly, you have time to per‐ form fairly long canaries. If you deploy continuously (for example, 20 times in a day), your canary duration must be significantly shorter. On a related note, while we can run multiple canary deployments simultaneously, doing so adds significant mental effort to track system state. This can become problematic during any nonstandard circumstances, when reasoning about the system’s state quickly is important. Run‐ ning simultaneous canaries also increases the risk of signal contamination if the cana‐ ries overlap. We strongly advise running only one canary deployment at a time.\n\nFor basic evaluation, we do not need a terribly large canary population in order to detect key critical conditions.6 However, a representative canary process requires decisions across many dimensions:\n\nSize and duration\n\nIt should be sizeable and last long enough to be representative of the overall deployment. Terminating a canary deployment after receiving just a handful of queries doesn’t provide a useful signal for systems characterized by diverse quer‐ ies with varied functionality. The higher the processing rate, the less time is required to get a representative sample in order to ensure the observed behavior is actually attributable to the canaried change, and not just a random artifact.\n\nTraffic volume\n\nWe need to receive enough traffic on the system to ensure it has handled a repre‐ sentative sample, and that the system has a chance to react negatively to the inputs. Typically, the more homogeneous the requests, the less traffic volume you need.\n\nTime of day\n\nPerformance defects typically manifest only under heavy load,7 so deploying at an off-peak time likely wouldn’t trigger performance-related defects.\n\nMetrics to evaluate\n\nThe representativeness of a canary is tightly connected to the metrics we choose to evaluate (which we’ll discuss later in this chapter). We can evaluate trivial met‐ rics like query success quickly, but other metrics (such as queue depth) may need more time or a large canary population to provide a clear signal.\n\nFrustratingly, these requirements can be mutually at odds. Canarying is a balancing act, informed both by cold analysis of worst-case scenarios and the past realistic track record of a system. Once you’ve gathered metrics from past canaries, you can choose\n\n6 See a discussion of real-world outages at http://bit.ly/2LgorFz.\n\n7 For example, consider resource contention problems, such as database write conflicts or locking in multi‐\n\nthreaded applications.\n\n344\n\n|\n\nChapter 16: Canarying Releases",
      "content_length": 2632,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 377,
      "content": "canary parameters based upon typical canary evaluation failure rates rather than hypothetical worst-case scenarios.\n\nSelecting and Evaluating Metrics So far, we have been looking at the success ratio, a very clear and obvious metric for canary evaluation. But intuitively, we know this single metric is not sufficient for a meaningful canary process. If we serve all requests at 10 times the latency, or use 10 times as much memory while doing so, we might also have a problem. Not all metrics are good candidates for evaluating a canary. What properties of metrics are best suited for evaluating whether a canary is good or bad?\n\nMetrics Should Indicate Problems First and foremost, the metric needs to be able to indicate problems in the service. This is tricky because what constitutes a “problem” isn’t always objective. We can probably consider a failed user request problematic.8 But what if a request takes 10% longer, or the system requires 10% more memory? We typically recommend using SLIs as a place to start thinking about canary metrics. Good SLIs tend to have strong attribution to service health. If SLIs are already being measured to drive SLO compli‐ ance, we can reuse that work.\n\nAlmost any metric can be problematic when taken to the extreme, but there’s also a cost to adding too many metrics to your canary process. We need to correctly define a notion of acceptable behavior for each of the metrics. If the idea of acceptable behavior is overly strict, we will get lots of false positives; that is, we will think a can‐ ary deployment is bad, even though it isn’t. Conversely, if a definition of acceptable behavior is too loose, we will be more likely to let a bad canary deployment go unde‐ tected. Choosing what’s acceptable behavior correctly can be an expensive process— it’s time-consuming and requires analysis. When it’s done poorly, however, your results can completely mislead you. Also, you need to reevaluate expectations on a regular basis as the service, its feature set, and its behavior evolve.\n\nWe should stack-rank the metrics we want to evaluate based on our opinion of how well they indicate actual user-perceivable problems in the system. Select the top few metrics to use in canary evaluations (perhaps no more than a dozen). Too many met‐ rics can bring diminishing returns, and at some point, the returns are outweighed by the cost of maintaining them, or the negative impact on trust in the release process if they are not maintained.\n\n8 A failed user request isn’t necessarily problematic. User requests can fail because the user requested some‐\n\nthing unreasonable, such as accessing a nonexistent URL. We need to be disciplined in distinguishing errors like these from problems in the systems.\n\nSelecting and Evaluating Metrics\n\n|\n\n345",
      "content_length": 2786,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 378,
      "content": "To make this guideline more tangible, let’s look at our example service. It has many metrics we might evaluate: CPU usage, memory footprint, HTTP return codes (200s, 300s, etc.), latency of response, correctness, and so on. In this case, our best metrics are likely the HTTP return codes and latency of response because their degradation most closely maps to an actual problem that impacts users. In this scenario, metrics for CPU usage aren’t as useful: an increase in resource usage doesn’t necessarily impact a service and may result in a flaky or noisy canary process. This can result in the canary process being disabled or ignored by operators, which can defeat the point of having a canary process in the first place. In the case of frontend services, we intui‐ tively know that being slower or failing to respond are typically reliable signals that there are problems in the service.\n\nHTTP return codes contain interesting tricky cases, such as code 404, which tells us the resource was not found. This could happen because users get the wrong URL (imagine a broken URL getting shared on a popular discussion board), or because the server incorrectly stops serving a resource. Often we can work around problems like this by excluding 400-level codes from our canary evaluation and adding black-box monitoring to test for the presence of a particular URL. We can then include the black-box data as part of our canary analysis to help isolate our canary process from odd user behaviors.\n\nMetrics Should Be Representative and Attributable The source of changes in the observed metrics should be clearly attributable to the change we are canarying, and should not be influenced by external factors.\n\nIn a large population (for example, many servers or many containers), we are likely to have outliers—oversubscribed machines, machines running different kernels with different performance characteristics, or machines on an overloaded segment of the network. The difference between the canary population and the control is just as much a function of the change we have deployed as the difference between the two infrastructures on which we deploy.\n\nManaging canaries is a balancing act between a number of forces. Increasing the size of the canary population is one way to decrease impact of this problem (as discussed earlier). When we reach what we consider a reasonable canary population size for our system, we need to consider whether the metrics we have chosen could show high variance.\n\nWe should also be aware of shared failure domains between our canary and control environments; a bad canary could negatively impact the control, while bad behavior in the system might lead us to incorrectly evaluate the canary. Similarly, make sure that your metrics are well isolated. Consider a system that runs both our application and other processes. A dramatic increase in CPU usage of the system as a whole would make for a poor metric, as other processes in the system (database load, log\n\n346\n\n|\n\nChapter 16: Canarying Releases",
      "content_length": 3033,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 379,
      "content": "rotation, etc.) might be causing that increase. A better metric would be CPU time spent as the process served the request. An even better metric would be CPU time spent serving the request over the window of time the serving process was actually scheduled on a CPU. While a heavily oversubscribed machine colocated with our process is obviously a problem (and monitoring should catch it!), it isn’t caused by the change we’re canarying, so it should not be flagged as a canary deployment failure.\n\nCanaries also need to be attributable; that is, you should also be able to tie the canary metric to SLIs. If a metric can change wildly with no impact to service, it’s unlikely to make a good canary metric.\n\nBefore/After Evaluation Is Risky A before/after canary process is an extension of the attribution problem. In this pro‐ cess, the old system is fully replaced by the new system, and your canary evaluation compares system behavior before and after the change over a set period of time. One might call this process a “canary deployment in time-space,” where you choose the A/B groups by segmenting time instead of segmenting the population by machines, cookies, or other means. Because time is one of the biggest sources of change in observed metrics, it is difficult to assess degradation of performance with before/after evaluation.\n\nWhile the canary deployment might have caused the degradation, the degradation may very well have happened in the control system too. This scenario becomes even more problematic if we attempt to run a canary deployment over a longer period of time. For example, if we perform a release on Monday, we may be comparing behav‐ ior during a business day to behavior during a weekend, introducing a large amount of noise. In this example, users may use the service very differently over the weekend, thereby introducing noise in the canary process.\n\nThe before/after process itself introduces a question of whether a big error spike (as introduced by a before/after evaluation) is better than a small but possibly longer rate of errors (as introduced by a small canary). If the new release is completely broken, how quickly can we detect and revert? A before/after canary may detect the problem faster, but the overall time to recovery may still be quite substantial and similar to a smaller canary. During that time, users suffer.\n\nUse a Gradual Canary for Better Metric Selection Metrics that don’t meet our ideal properties may still bring great value. We can intro‐ duce these metrics by using a more nuanced canary process.\n\nInstead of simply evaluating a single canary stage, we can use a canary containing multiple stages that reflect our ability to reason about the metrics. In the first stage,\n\nSelecting and Evaluating Metrics\n\n|\n\n347",
      "content_length": 2779,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 380,
      "content": "we have no confidence or knowledge about the behavior of this release. We therefore want to use a small stage in order to minimize negative impact. In a small canary, we prefer metrics that are the clearest indication of a problem—application crashes, request failures, and the like. Once this stage passes successfully, the next stage will have a larger canary population to increase confidence in our analysis of the impact of the changes.\n\nDependencies and Isolation The system being tested will not operate in a complete vacuum. For practical reasons, the canary population and the control may share backends, frontends, networks, data stores, and other infrastructure. There may even be extremely nonobvious interac‐ tions with the client. For example, imagine two consecutive requests sent by a single client. The first request may be handled by the canary deployment. The response by the canary may change the content of the second request, which may land on the control, altering the control’s behavior.\n\nImperfect isolation has several consequences. Most importantly, we need to be aware that if the canarying process provides results that indicate we should stop a produc‐ tion change and investigate the situation, the canary deployment isn’t necessarily at fault. This fact is true of canarying in general, but in practice, it’s frequently enforced by isolation issues.\n\nAdditionally, imperfect isolation means that bad behavior of the canary deployment can also negatively impact the control. Canarying is an A/B comparison, and it’s pos‐ sible that both A and B can change in tandem; this may cause confusion in the canary evaluation. It is important to also use absolute measures, such as defined SLOs, to ensure the system is operating correctly.\n\nCanarying in Noninteractive Systems The chapter has focused on an interactive request/response system, which in many ways is the simplest and most commonly discussed system design. Other systems, such as asynchronous processing pipelines, are equally important, but have different canarying considerations, which we’ll enumerate briefly. For more information on canarying as related to data processing pipelines, see Chapter 13.\n\nFirst and foremost, the duration and deployment of the canary inherently depends on the duration of work unit processing. We’ve ignored this factor when it comes to interactive systems, assuming work unit processing will take no more than a few sec‐ onds, which is shorter than the canary duration. Work unit processing in noninterac‐ tive systems, such as rendering pipelines or video encoding, can take much longer. Accordingly, make sure the canary duration at minimum spans the duration of a sin‐ gle work unit.\n\n348\n\n|\n\nChapter 16: Canarying Releases",
      "content_length": 2749,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 381,
      "content": "Isolation can become more complex for noninteractive systems. Many pipeline sys‐ tems have a single work assigner and a fleet of workers with the application code. In multistage pipelines, a work unit is processed by a worker, then returned to the pool for the same or another worker to perform the next stage of processing. It is helpful for canary analysis to ensure that the workers processing a particular unit of work are always pulled from the same pool of workers—either the canary pool or the control pool. Otherwise, the signals get increasingly mixed (for more about the need to untangle signals, see “Requirements on Monitoring Data” on page 349).\n\nFinally, metric selection can be more complicated. We may be interested in end-to- end time to process the work unit (similar to latency in interactive systems), as well as quality of the processing itself (which is, of course, completely application-specific).\n\nGiven these caveats, the general concept of canarying remains viable, and the same high-level principles apply.\n\nRequirements on Monitoring Data When conducting canary evaluation, you must be able to compare the canary signals to the control signals. Often, this requires some care in structuring the monitoring system—effective comparisons are straightforward and produce meaningful results.\n\nConsider our earlier example of a canary deployment to 5% of the population that runs at a 20% error rate. Because monitoring likely looks at the system as a whole, it will detect an overall error rate of only 1%. Depending on the system, this signal might be indistinguishable from other sources of errors (see Figure 16-3).\n\nIf we break down metrics by population servicing the request (the canary versus the control), we can observe the separate metrics (see Figure 16-4). We can plainly see the error rate in the control versus the canary, a stark illustration of what a full deployment would bring. Here we see that monitoring that reasons well about an entire service isn’t sufficient to analyze our canary. When collecting monitoring data, it is important to be able to perform fine-grained breakdowns that enable you to dif‐ ferentiate metrics between the canary and control populations.\n\nAnother challenge with collecting metrics is that canary deployments are time- limited by design. This can cause problems when metrics are aggregated over specific periods. Consider the metric errors per hour. We can calculate this metric by sum‐ ming the requests over the past hour. If we use this metric to evaluate our canary, we might encounter problems, as described in the following timeline:\n\nRequirements on Monitoring Data\n\n|\n\n349",
      "content_length": 2654,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 382,
      "content": "1. An unrelated event causes some errors to occur.\n\n2. A canary is deployed to 5% of the population; the canary duration is 30 minutes.\n\n3. The canary system starts to watch the errors-per-hour metric to see if the deploy‐ ment is good or bad.\n\n4. The deployment is detected as bad because the errors-per-hour metric is signifi‐ cantly different from the errors per hour of the control population.\n\nThis scenario is a result of using a metric that is computed hourly to evaluate a deployment that is only 30 minutes long. As a result, the canary process provides a very muddied signal. When using metrics to evaluate canary success, make sure the intervals of your metrics are either the same as or less than your canary duration.\n\nRelated Concepts Often, our conversations with customers touch upon using blue/green deployment, artificial load generation, and/or traffic teeing in production. These concepts are sim‐ ilar to canarying, so while they’re not strictly canary processes, they might be used as such.\n\nBlue/Green Deployment Blue/green deployment maintains two instances of a system: one that is serving traf‐ fic (green), and another that is ready to serve traffic (blue). After deploying a new release in the blue environment, you can then move traffic to it. The cutover doesn’t require downtime, and rollback is a trivial reversal of the router change. One down‐ side is that this setup uses twice as many resources as a more “traditional” deploy‐ ment. In this setup, you are effectively performing a before/after canary (discussed earlier).\n\nYou can use blue/green deployments more or less as normal canaries by utilizing both blue and green deployments simultaneously (rather than independently). In this strategy, you can deploy the canary to the blue (standby) instance and slowly split traffic between green and blue environments. Both your evaluations and the metrics that compare the blue environment to the green environment should be tied to traffic control. This setup resembles an A/B canary, where the green environment is the control, the blue environment is the canary deployment, and the canary population is controlled by the amount of traffic sent to each.\n\nArtificial Load Generation Instead of exposing live user traffic to a canary deployment, it may be tempting to err on the side of safety and use artificial load generation. Often, you can run load tests in multiple deployment stages (QA, preproduction, and even in production). While\n\n350\n\n|\n\nChapter 16: Canarying Releases",
      "content_length": 2514,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 383,
      "content": "these activities don’t qualify as canarying according to our definition, they are still viable approaches to finding defects with some caveats.\n\nTesting with synthetic load does a good job of maximizing code coverage, but doesn’t provide good state coverage. It can be especially hard to artificially simulate load in mutable systems (systems with caches, cookies, request affinity, etc.). Artificial load also might not accurately model organic traffic shifts that happen in a real system. Some regressions may manifest only during events not included in the artificial load, leading to gaps in coverage.\n\nArtificial load also works poorly in mutable systems. For example, it may be down‐ right dangerous to attempt to generate artificial load on a billing system: the system might start sending callouts to credit card providers, which would then start actively charging customers. While we can avoid testing dangerous code paths, the lack of testing on these paths reduces our test coverage.\n\nTraffic Teeing If artificial load is not representative, we could copy the traffic and send it to both the production system and the system in the test environment. This technique is referred to as teeing. While the production system serves the actual traffic and delivers responses to users, the canary deployment serves the copy and discards the responses. You might even compare the canary responses to the actual responses and run fur‐ ther analysis.\n\nThis strategy can provide representative traffic, but is often more complicated to set up than a more straightforward canary process. Traffic teeing also doesn’t adequately identify risk in stateful systems; copies of traffic may introduce unexpected influences between the seemingly independent deployments. For example, if the canary deploy‐ ment and production systems share a cache, an artificially inflated cache hit rate would invalidate performance measurements for the canary metrics.\n\nConclusion You can use a number of tools and approaches to automate your releases and intro‐ duce canarying into your pipeline. No single testing methodology is a panacea, and testing strategies should be informed by the requirements and behavior of the system. Canarying can be a simple, robust, and easily integratable way to supplement testing. When you catch system defects early, users are minimally impacted. Canarying can also provide confidence in frequent releases and improve development velocity. Just as testing methodology must evolve alongside system requirements and design, so must canarying.\n\nConclusion\n\n|\n\n351",
      "content_length": 2574,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 385,
      "content": "PART III Processes\n\nSRE is more than just a collection of technical practices—it’s a culture that requires consistent and logical processes. This section addresses some important elements of processes as applied in SRE: managing operations and development work, recovering from overload, structuring and managing your relationships with development part‐ ners and customers, and implementing practical change management.\n\nIf you are an SRE leader, this section is your how-to guide for creating the space and environment your teams need to successfully implement the practices covered in Part II.",
      "content_length": 596,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 387,
      "content": "CHAPTER 17 Identifying and Recovering from Overload\n\nBy Maria-Hendrike Peetz, Luis Quesada Torres, and Marilia Melo with Diane Bates\n\nWhen an SRE team is running smoothly, team members should feel like they can comfortably handle all of their work. They should be able to work on tickets and still have time to work on long-term projects that make it easier to manage the service in the future.\n\nBut sometimes circumstances get in the way of a team’s work goals. Team members take time off for long-term illnesses or move to new teams. Organizations hand down new production-wide programs for SRE. Changes to the service or the larger system introduce new technical challenges. As workload increases, team members start working longer hours to handle tickets and pages and spend less time on engineering work. The whole team starts to feel stressed and frustrated as they work harder but don’t feel like they are making progress. Stress, in turn, causes people to make more mistakes, impacting reliability and, ultimately, end users. In short, the team loses its ability to regulate its daily work and effectively manage the service.\n\nAt this point, the team needs to find a way out of this overloaded state. They need to rebalance their workload so that team members can focus on essential engineering work.\n\nOperational load (or operational workload) is a term that describes the ongoing main‐ tenance tasks that keep systems and services running at optimal performance. There are three distinct types of operational load: pages, tickets, and ongoing operational responsibilities. Pages typically require immediate attention, and tickets related to urgent problems can have tight deadlines. Both pages and urgent tickets interrupt SREs from working on engineering projects that support the team’s operational responsibilities. For that reason, we refer to them as interrupts. Chapter 29 of Site\n\n355",
      "content_length": 1901,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 388,
      "content": "Reliability Engineering discusses techniques to manage the interrupts that naturally arise when a team is maintaining a complex system in a functional state.\n\nWhen operational load outstrips a team’s ability to manage it, the team ends up in a state of operational overload (also called work overload). A team is in a state of opera‐ tional overload when it can’t make progress toward key priorities because urgent issues continually preempt project work. In addition to detracting from the team’s priorities and service improvements, overload can increase the chance that engineers make errors.1\n\nThe threshold of operational overload can vary from team to team. Google SRE teams cap operational work at 50% of an engineer’s time. A successful SRE team must have confidence that over the long term, they will be able to complete the engineering projects required to reduce the operational load for the services they manage.\n\nThis chapter describes how teams at Google progressed from a difficult situation characterized by operational overload to a well-managed workload. Two case studies show the detrimental effect of operational overload on team health, and how the teams made changes to their daily tasks so they could focus on long-term impactful projects. In Case Study 1, overload results when remaining members on a shrinking team are unable to keep up with the workload. In Case Study 2, a team suffers from perceived overload—a state that has the same effects as operational overload, but starts as a misperception of the real workload.\n\nWhile these case studies highlight specific actions that worked for two Google SRE teams, the section “Strategies for Mitigating Overload” on page 366 provides practices for identifying and mitigating overload that apply to any company or organization. Therefore, this chapter should be useful to managers of overloaded teams, or any SRE team concerned about overload.\n\nFrom Load to Overload Regardless of its origin, overload is an occupational stress that can cripple productiv‐ ity. Left unchecked, it can cause serious illness. For SRE teams, operational load is typically a combination of cognitively difficult tasks (like debugging memory leaks or segmentation faults) and many small tasks that require frequent context switches (working through quota requests, starting binary rollouts, etc.).\n\nWork overload often happens when a team doesn’t have enough time to handle all these tasks—an objective reality when the number of tasks assigned to a team can’t be\n\n1 Kara A. Latorella, Investigating Interruptions: Implications for Flightdeck Performance (Hampton, VA: Langley\n\nResearch Center, 1999), https://go.nasa.gov/2Jc50Nh; NTSB, Aircraft Accident Report: NWA DC-9-82 N312RC, Detroit Metro, 16 August 1987 (No. NTSB/AAR-88/05) (Washington, DC: National Transportation Safety Board, 1988), http://libraryonline.erau.edu/online-full-text/ntsb/aircraft-accident-reports/AAR88-05.pdf.\n\n356\n\n|\n\nChapter 17: Identifying and Recovering from Overload",
      "content_length": 3001,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 389,
      "content": "completed within the given deadline for each task. Perceived overload is more subjec‐ tive, and happens when individuals on the team feel that they have too much work. This usually happens when several organizational or work changes take place over a short period of time, but the team has little opportunity to communicate with leader‐ ship about the changes.\n\nIt’s never clear what problems will develop when you’re on-call, or what your work‐ load will be. On the one hand, a single, seemingly innocent ticket about running out of disk space might lead to an in-depth investigation of a recurring garbage collection job. On the other hand, a pager storm with 20+ pages might turn out to be a case of bad monitoring. When it’s hard to estimate or predict your workload, you can easily fall victim to cognitive biases and misjudge your workload—for example, you might gauge a ticket queue as too large to finish during your on-call shift. Even if you can finish all the tickets quickly and the actual workload is low, you feel overloaded when you first look at the ticket queue. This perceived overload2 itself has a psychological component that affects your approach and attitude toward your work. If you don’t start your day with the preconception that there’s too much work, you’re more likely to dive in and start working your way through the ticket queue. Perhaps you work all day and don’t finish your workload (thus facing work overload), but you make a lot more progress than if you had started your day feeling overwhelmed.\n\nAccumulating many interrupts can lead to work overload, but it doesn’t have to. But when frequent interruptions are paired with external stress factors, a large workload (or even a small workload) can easily turn into perceived overload. This stress might stem from the fear of disappointing other team members, job insecurity, work- related or personal conflicts, illness, or health-related issues like the lack of sleep or exercise.\n\nIf your work isn’t properly prioritized, every task can seem equally urgent, leading to both actual and perceived overload. In the case of actual overload, the urgency of tickets and alerts might cause team members to work until they resolve the problem, even if doing so means continuous long hours. When a team faces perceived over‐ load, reprioritizing can help decrease the amount of urgent work, creating space for them to tackle the sources of overload through project work.\n\nWhen analyzing your specific situation, you shouldn’t necessarily assume that the workload itself needs to change. Instead, we recommend first quantifying the work\n\n2 Emmanuelle Brun and Malgorzata Milczarek, Expert Forecast on Emerging Psychosocial Risks Related to Occu‐ pational Safety and Health (Bilbao, Spain: European Agency for Safety and Health at Work, 2007), https:// osha.europa.eu/en/tools-and-publications/publications/reports/7807118; M. Melchior, I. Niedhammer, L. F. Berkman, and M. Goldberg, “Do Psychosocial Work Factors and Social Relations Exert Independent Effects on Sickness Absence? A Six-Year Prospective Study of the GAZEL Cohort,” Journal of Epidemiology and Community Health 57, no. 4 (2003): 285–93, http://jech.bmj.com/content/jech/57/4/285.full.pdf.\n\nFrom Load to Overload\n\n|\n\n357",
      "content_length": 3265,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 390,
      "content": "your team faces, and how it has (or hasn’t) changed over time. For example, you might measure workload by the number of tickets and pages the team handles. If your workload hasn’t actually changed over time, the team might feel overloaded simply because they perceive the work as overwhelming. To get a more holistic view of the team’s current workload, you can collect a one-time snapshot by asking every member to list all the work tasks they face. Then take a look at psychological stress factors your team faces, such as organizational changes or reprioritization. Once you’ve done your research, you have a stable basis for making decisions about chang‐ ing the workload.\n\n“Strategies for Mitigating Overload” on page 366 talks more about how to identify overload, both real and perceived. First, we present two case studies of teams that rec‐ ognized that they were in overload and took steps to alleviate it.\n\nCase Study 1: Work Overload When Half a Team Leaves\n\nBackground One of Google’s internal storage SRE teams was in charge of backends for multiple services, including Gmail, Google Drive, and Google Groups, and many other inter‐ nal or user-facing services. We experienced a crisis in mid-2016 when two-thirds of the team—including the most senior engineer (the manager)—transferred to other opportunities within a relatively short window, for genuinely entirely unrelated rea‐ sons. This event obviously led to a huge workload management problem: fewer SREs available to cover the same operational and project work quickly resulted in overload. Our work was also bottlenecked because each team member’s expertise was siloed to a different area of production. While the addition of new team members and three interns would improve our workload in the long term, ramping up those engineers would take a serious investment of time and energy.\n\nProblem Statement The preceding factors significantly decreased team productivity. We started to fall behind on project work, and tickets related to the many services we managed began to pile up. We didn’t have the bandwidth to address this backlog, as all of our work was consumed by higher-priority tasks. It wouldn’t be long before we weren’t able to undertake all of the critical and urgent work we needed to. Meanwhile, our team was slated to receive more high-priority work soon.\n\nIf we didn’t move some work off our plate, it was only a matter of time before we accidentally began to drop important work. However, as soon as we started offload‐ ing work, we hit some psychological barriers:\n\n358\n\n|\n\nChapter 17: Identifying and Recovering from Overload",
      "content_length": 2617,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 391,
      "content": "Dropping any work that was in progress felt like we had just wasted our efforts. Most of the backlog seemed to be either critical or worth the effort to us, so it just didn’t feel right to cancel or delay projects indefinitely. We didn’t realize we were in the grip of a sunk cost fallacy.\n\nPutting effort into automating processes or fixing the root cause of the workload was not as critical as immediately dealing with high-priority interrupts. When this work was added to the top of an already huge pile, all of the work felt overwhelming.\n\nWhat We Decided to Do We gathered the team in a room and listed all the team’s responsibilities, including project backlog, operational work, and tickets. Then we triaged every list item. View‐ ing every single one of our work tasks (even though the list barely fit on the white‐ board) helped us identify and redefine our actual priorities. We were then able to find ways to minimize, hand off, or eliminate lower-priority work items.\n\nImplementation We identified low-effort automation that, while not critical, would significantly reduce operational load once deployed.\n\nWe also identified common problems that we could document that would enable self-service. Writing the procedures our customers needed didn’t take long, and removed some repetitive work from our queue.\n\nWe closed as many of our backlogged tickets as we reasonably could. Most of these tickets turned out to be obsolete, redundant, or not as urgent as they claimed. Some tickets were monitoring artifacts that were nonactionable, so we fixed the relevant monitoring. In some cases, we were actively addressing issues that weren’t critical. We set these issues aside to work on more urgent tickets, but first documented our progress so we wouldn’t lose context before we were able to work on them again.\n\nWhen in doubt, we dropped a task, but marked it for a second phase of triage. Once our plates were (almost) empty, we revisited this tentative list to decide what tasks to resume. It turned out that almost none of these tasks were impactful or important enough to resume.\n\nIn two days—one day of intensive triage plus one day of documenting processes and implementing automation—our much smaller team addressed a backlog of several months of interrupts. We could then deal with the few remaining interrupts, which were related to active issues in production.\n\nCase Study 1: Work Overload When Half a Team Leaves\n\n|\n\n359",
      "content_length": 2439,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 392,
      "content": "Lessons Learned Our team learned that identifying and scoping overload is the first step toward fixing it. We needed to get everyone in a room and reevaluate the backlog before we could help our team get back to a healthy state.\n\nIn order to avoid a new pile-up of interrupts, we started triaging interrupts once every two weeks. Our technical lead periodically checks the task queue and evaluates whether the team is at risk of becoming overloaded. We decided that each team member should have 10 or fewer open tickets to avoid overload. If the team lead noti‐ ces that team members have more than 10 tickets, they can do one or some combina‐ tion of the following:\n\nRemind the team to close out stale tickets.\n\nSync with overloaded team members and offload tickets from them.\n\nPrompt individual team members to address their ticket queue.\n\nOrganize a team-wide one-day ticket fix-it.\n\nAssign work to fix the sources of tickets, or operational work to reduce future tickets.\n\nCase Study 2: Perceived Overload After Organizational and Workload Changes\n\nBackground The Google SRE team in this case study was split between two locations, with six or seven on-call engineers at each site (for more discussion on team size, see Chapter 11 of Site Reliability Engineering. While the Sydney team was operationally healthy, the Zürich team was overloaded.\n\nBefore the Zürich team went into overload, we were stable and content. The number of services we managed was relatively stable, and each was varied and high mainte‐ nance. While the SLOs of the services we supported were mismatched with the SLOs of their external dependencies, this mismatch hadn’t caused any issues. We were working on a number of projects to improve the services we managed (for example, improving load balancing).\n\nSimultaneous triggers sent the Zürich team into overload: we started onboarding new services that were noisier and less integrated into Google’s general infrastructure, and the technical lead manager and another team member left our team, leaving it two people short. The combination of the additional workload and knowledge drain trig‐ gered more problems:\n\n360\n\n|\n\nChapter 17: Identifying and Recovering from Overload",
      "content_length": 2204,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 393,
      "content": "Untuned monitoring for the new services and the migration-related monitoring resulted in more pages per shift. This buildup was gradual, so we didn’t notice the uptick as it occurred.\n\nSREs felt relatively helpless with the new services. We didn’t know enough about them to react appropriately, and often needed to ask the development team ques‐ tions. While the overload perhaps warranted handing a service back to develop‐ ers, our team had never handed back a service, so we didn’t really consider this a viable option.\n\nA smaller on-call rotation of five people cut into the hours we normally spent on operational work.\n\nNew ticket alerts were surfacing problems that existed before the recent team changes. While we had simply ignored these problems in the past, we were now required to move ignored email alerts to tickets. Project planning hadn’t taken this new source of technical debt into account.\n\nA new ticket SLO required us to handle tickets within three days, meaning that on-callers had to resolve tickets created during their on-call shift much sooner.3 The SLO aimed to reduce the number of tickets being added to our (mostly ignored) backlog, but created a side effect that was perhaps even worse. Now SREs felt that they couldn’t get the rest they needed after a shift because they had to immediately tackle follow-up work. The higher priority placed on these tickets also meant that SREs didn’t have enough time for other operational work.\n\nDuring this time, our team was assigned to a new manager who also managed two other teams. The new manager was not part of the on-call rotation and therefore didn’t directly feel the stress team members were experiencing. When the team explained the situation to the manager, nothing changed. Team members felt that they weren’t being heard, which left them feeling distant from the management team.\n\nThe overload from tickets continued for months, making team members grumpy, until a cascade of unhappiness spread across the team.\n\nProblem Statement After losing two people and receiving additional and varied work, our team felt over‐ loaded. When we tried to communicate this feeling to our direct manager, the man‐ ager disagreed. As the long hours continued, exhaustion set in. Productivity was declining and tasks started accruing faster than the team could resolve them. The per‐ ceived overload now became objective overload, making the situation worse.\n\n3 For context, according to estimates, an SRE needed at least one additional day of ticket follow-up per shift.\n\nCase Study 2: Perceived Overload After Organizational and Workload Changes\n\n|\n\n361",
      "content_length": 2620,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 394,
      "content": "The emotional stress caused by overload was lowering morale and causing some team members to burn out. As individuals dealt with the physical effects from overwork (illness and lower productivity), other people on the team had to pick up more work. The work assigned in weekly team meetings wasn’t getting done.\n\nWe then started assuming we couldn’t depend on other people to get their work done, which eroded feelings of trust and dependability within the team. As a result, we did not feel safe about interpersonal risk taking, an important factor in psychologi‐ cal safety (see Chapter 11 in Site Reliability Engineering). Team members didn’t feel accepted and respected by other team members, so they didn’t freely collaborate with each other. As psychological safety diminished on the team, collaboration stopped, slowing down information sharing and causing further inefficiencies.\n\nTeam surveys also revealed a loss of psychological safety—team members said they didn’t feel like they belonged on the team. They no longer cared about their own career development, and the promotion rate on the team dropped to an all-time low.\n\nWe finally hit a breaking point when upper management assigned us new mandatory company-wide projects. At this point, we renewed our conversations with manage‐ ment about overload with renewed vigor. A series of discussions revealed that our unhappy situation wasn’t just a result of too much work—our perceptions of team safety led us to stop trusting and collaborating with each other.\n\nWhat We Decided to Do Upper management assigned our team a new manager who wasn’t shared among three teams. The new manager used a participatory management style to improve psychological safety on the team so that we could once again collaborate. This method empowers team members to actively participate in solving team problems. The entire team, including our direct manager, engaged in a set of simple team- building exercises to improve the effectiveness of our team (some of which were as simple as drinking tea together).4 As a result, we were able to draft a set of goals:\n\nShort term\n\nRelieve stress and improve psychological safety to establish a healthy work atmosphere.\n\nMedium term\n\nBuild confidence of individual team members through training.\n\nFind the root cause of the issues that are causing overload.\n\n4 We used the Google program based on Project Aristotle: http://bit.ly/2LPemR2.\n\n362\n\n|\n\nChapter 17: Identifying and Recovering from Overload",
      "content_length": 2485,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 395,
      "content": "Long term\n\nResolve ongoing problems that contributed to the cascade.\n\nIn order to set these goals, we had to first achieve some kind of baseline psychological safety within the team. As morale improved, we began to share knowledge and build on each other’s ideas to figure out ways to get our workload under control.\n\nImplementation\n\nShort-term actions\n\nLong-term stress, whether caused by overwork or perceptions of team safety, decrea‐ ses productivity and impacts people’s health. Therefore, our most important short- term action was to provide stress relief and improve trust and psychological safety. Once relieved of some stress, team members could think more clearly and participate in driving the whole team forward. Within a month of identifying the overload, we implemented the following:\n\nStarted a semiregular round table to discuss issues. The team released frustra‐ tion and brainstormed possible causes of the overload.\n\nFound a better metric for measuring load. We decided to improve upon our original metric of number of pages. We auto-assigned tickets to on-callers, and the on-caller was responsible for these tickets even after their shift ended. Our new metric measured how much time an on-caller needed to resolve a ticket after their shift.\n\nAudited and removed spamming alerts. We reviewed alerts and removed the ones that didn’t represent user-facing problems.\n\nSilenced alerts generously. The team deliberately didn’t try to find the source for every single alert, but focused on relieving the stress from being paged and ticketed continuously for issues we already knew about. We used the following strategy: — Alerts that surfaced were silenced until they were fixed.\n\n— Alerts could be silenced only for a limited period of time (typically a day,\n\nsometimes up to a week). Otherwise, they might mask outages.\n\n— Alerts that couldn’t be fixed within a few minutes were assigned to a tracking\n\nticket.\n\nAdded a direct manager dedicated to a single team. Making a well-respected team member the new manager reestablished trust in management. Rather than managing three teams, the new manager could focus more time on the individual team and its members.\n\nCase Study 2: Perceived Overload After Organizational and Workload Changes\n\n|\n\n363",
      "content_length": 2263,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 396,
      "content": "Rebalanced the team. We introduced a new perspective and on-call relief by adding technically experienced SREs that didn’t have preconceptions about the team or organization. Finding appropriate people was by no means an easy task, but was well worth the effort.\n\nInstituted team events like lunches and board game sessions. Talking about non-work-related topics and laughing together eased tension on the team and improved psychological safety.\n\nMid-term actions\n\nShort-term solutions alone wouldn’t sustain a healthy atmosphere—for example, one of our short-term tactics was to silence alerts without actually fixing the cause. Within three months, we also took the following actions:\n\nLimited operational work to on-call time as much as possible (see Chapter 29 in Site Reliability Engineering) so the team could concentrate on permanent fixes and project work.\n\nReturned responsibility for one service back to its development team.\n\nTrained each other (and new team members). While training requires an investment of time and energy, disseminating knowledge meant that all team members (and future hires) could troubleshoot and fix issues more quickly in the future. Training coworkers improved our confidence, because we came to realize that we actually knew quite a bit about the services. As they gained knowledge, team members started to find new ways to manage services, improving their reli‐ ability and reducing overload.\n\nBrought in SREs from the remote team to staff some of our on-call shifts and participate in training. They noticed the strain on the team and provided some valuable new perspective.\n\nBackfilled the two open roles on the team.\n\nTackled each alert as the silences expired. We discussed repetitive pages and pages that resulted in no action at length in the weekly production meeting, which led us to tune alerts and/or fix the underlying problems. While these were important (and obvious) actions, we only had the space to analyze and take action once the alert was silenced and not creating constant noise.\n\nOrganized listening events. Management (including the skip-level manager and team leads) made a conscious effort to listen to the team’s pain points and to find a team-driven solution.\n\n364\n\n|\n\nChapter 17: Identifying and Recovering from Overload",
      "content_length": 2287,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 397,
      "content": "Added perspective. Hope is not a strategy, but it certainly helps team morale. With the promise of new members joining the on-call rotation, a shift to clearer priorities, and an end to noise-generating projects, the team’s mood improved.\n\nLong-term actions\n\nTo help maintain our newfound stability, we are currently aligning our SLOs with the SLOs of their service backends, and working toward making the services more uni‐ form. Uniformity has a double benefit: it decreases cognitive load for SREs and makes it easier to write automation that can be used across services. We’re also reviewing services that have been around for a long time and updating them to cur‐ rent production standards. For example, some services are operating poorly under load that’s increased significantly over the years. Some services need to be updated per changes to their backend services’ policies. Other services simply haven’t been updated for several years.\n\nEffects A few months after our first brainstorming meeting, results began to surface: on-call shifts became quieter, and our team managed to quickly and efficiently deal with a difficult incident collaboratively as a group. A bit later, new team members arrived. When we discussed psychological safety during a round-table session, the new mem‐ bers said they couldn’t imagine that the team ever had such problems. In fact, they saw our team as a warm and safe place to work. About one year after the original escalation, little of the original overload remained and an anonymous survey showed that team members now felt the team was effective and safe.\n\nLessons Learned Workplace changes can have a psychological impact on the people on the team— after all, your teammates are not machines. You need to attend to the team’s stress levels so that people start trusting each other enough to work together; otherwise, the team can enter a vicious cycle of overload that causes stress, which in turn prevents you from tackling overload.\n\nPerceived overload is, in fact, overload, and has as much impact to a team as work overload caused by other factors. In our case, our sister team in Sydney didn’t experi‐ ence the same issues, and the number of pages we fielded didn’t actually change very much compared to previous years. Instead, the loss of two team members, increased cognitive load, increased ticket noise, and a new three-day SLO on tickets led the team to perceive overload. In the end, the difference between objective and perceived overload didn’t matter: the perceived overload of a few team members can very quickly lead to overload for the whole team.\n\nCase Study 2: Perceived Overload After Organizational and Workload Changes\n\n|\n\n365",
      "content_length": 2695,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 398,
      "content": "Strategies for Mitigating Overload An outside perspective can sometimes quite easily identify when a team is overloa‐ ded. Similarly, it’s easy to comment on what actions should have been taken in retro‐ spect. But how do you identify overload when you’re in the middle of experiencing it? The path toward a healthy, friendly, and happy work atmosphere can be hard to visu‐ alize when you’re mired in overload. This section describes practices for both identi‐ fying and mitigating overload on your team.\n\nRecognizing the Symptoms of Overload It’s pretty easy to identify an overloaded team if you know the symptoms of overload:\n\nDecreased team morale\n\nOverload might manifest as rants and complaints. Surveys on relevant topics (job conditions, work satisfaction, projects, peers, and managers) usually reflect team morale and yield more negative results when a team is overloaded. Regular active listening sessions with team leaders can surface issues that you weren’t aware of. An essential element of active listening is to listen without judgment.\n\nTeam members working long hours, and/or working when sick\n\nWorking overtime without compensation can be a psychosocial stressor. Leaders should set a good example: work contractual hours and stay home when sick.\n\nMore frequent illness5\n\nOverworked team members tend to get run down and sick more often.\n\nAn unhealthy tasks queue\n\nWe recommend regularly reviewing your team’s tasks queue to see how many tickets are backlogged, who is dealing with which issues, and what tasks can be delayed or dropped. If the team is missing deadlines, or if urgent matters prevent you from performing this review regularly, the team is very likely accumulating interrupts faster than it can attend to them.\n\nImbalanced metrics\n\nA few key metrics might indicate that your team is overloaded:\n\nLong time periods to close a single issue\n\nHigh proportion of time spent on toil\n\nLarge number of days to close issues originating from an on-call session\n\n5 Kurt G. I. Wahlstedt and Christer Edling, “Organizational Changes at a Postal Sorting Terminal—Their Effects Upon Work Satisfaction, Psychosomatic Complaints and Sick Leave,” Work and Stress 11, no. 3 (1997): 279–91.\n\n366\n\n|\n\nChapter 17: Identifying and Recovering from Overload",
      "content_length": 2267,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 399,
      "content": "The team should work together to decide what measures to use. There is no one-size- fits-all approach; every team’s overload is reflected in different ways. As a manager, don’t impose a measure on the team without getting an idea of each individual’s workload and work habits. Team members might feel that you don’t understand the work if you insist on using a specific measure. For example, if you’re evaluating load by the number of days it takes to fix an issue, one person might work a full day fixing an issue, while another person might distribute the work across several days, along with other work.\n\nReducing Overload and Restoring Team Health After reading through the criteria, you might think your team is already overloaded. Don’t despair! This section provides a list of ideas to get your team back to a healthy state.\n\nIn general, giving team members more control and power reduces perceived over‐ load.6 While managers might be tempted to resort to micro-management in stressful situations, it’s important to keep the team in the loop and work on prioritization together in order to increase the level of performance and job satisfaction.7 This model assumes a baseline of a functional team, where you have (at minimum) a somewhat healthy relationship between management and team members, and between team members.\n\nIdentify and alleviate psychosocial stressors\n\nWhen it comes to fixing a dysfunctional team, first and foremost, individual team members need to regain their sense of psychological safety. A team can function only as well as its individual members.\n\nYou can start by identifying and alleviating psychosocial stressors8 for each individual and the team as a whole. Which of these factors do you actually have control over? You can’t control whether or not a team member has a major illness, but you can control the size of your team’s backlog (as seen in Case Study 1) or silence pages (as in Case Study 2).\n\n6 Robert A. Karasek Jr., “Job Demands, Job Decision Latitude, and Mental Strain—Implications for Job Rede‐\n\nsign,” Administrative Science Quarterly 24, no. 2 (1979): 285–308.\n\n7 Frank W. Bond and David Bunce, “Job Control Mediates Change in a Work Reorganization Intervention for Stress Reduction,” Journal of Occupational Health Psychology 6, no. 4 (2001): 290–302; Toby D. Wall, Paul R. Jackson, and Keith Davids, “Operator Work Design and Robotics System Performance: A Serendipitous Field Study,” Journal of Applied Psychology 77, no. 3 (1992): 353–62.\n\n8 Brun and Malgorzata, Expert Forecast.\n\nStrategies for Mitigating Overload\n\n|\n\n367",
      "content_length": 2580,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 400,
      "content": "Communicate with your partner product developer teams, and let them know your team is overloaded. They might be able to give a helping hand, provide compassion, or even take over entire projects.\n\nWhen your team members rely on each other and achieve a certain level of psycho‐ logical safety (such that they’re able to take interpersonal risks), you can give more responsibility to individual team members. Uncovering areas of expertise and assign‐ ing point people and technical leads to specific technologies increases their self- confidence and therefore enables them to take risks.\n\nDecision making should be transparent and, if possible, democratic. Each team mem‐ ber should have a feeling of control over the situation. For example, the brainstorm‐ ing session in Case Study 2 helped the team identify and discuss issues.\n\nPrioritize and triage within one quarter\n\nA healthy team can prioritize and triage issues. Case Study 1 provides a good example of this exercise: the team sat together in a room and reviewed their backlog. The review helped them realize they were overloaded. They reprioritized their work, and worked on the tasks that would quickly reduce some of the overload. The team in Case Study 2 now meets at the end of each quarter to plan and prioritize existing and future work together.\n\nIf possible, we recommend that SREs schedule interrupt-free time (no on-call) on their calendars, so that they have time to work on qualitatively difficult tasks like developing automation and investigating the root causes of interrupts. In Case Study 2, when the remote team gave the on-call some relief, team members then had pre‐ cious time to focus on their projects.\n\nIf absolutely necessary, drop work: in Case Study 2, the team dropped on-call support for one of their services by returning this responsibility to the development team.\n\nProtect yourself in the future\n\nWe strongly recommend establishing metrics to evaluate the team’s workload. Regu‐ larly review the metrics to make sure they are measuring the right things.\n\nOnce your team emerges from overload, you can prevent future overload by taking steps to monitor or resolve the underlying problems. For example, the team in Case Study 1 now maintains a lightweight triage process to detect a growing backlog of tasks. The team in Case Study 2 is currently working on a long-term plan to align backend and service SLOs.\n\nWhen your team is in overload, prioritize project work that pays down repetitive toil even more than you would if you weren’t overloaded. You will profit in the future.\n\n368\n\n|\n\nChapter 17: Identifying and Recovering from Overload",
      "content_length": 2632,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 401,
      "content": "Finally, everyone on the team should feel responsible for the early warning signs (see “Recognizing the Symptoms of Overload” on page 366) that indicate a possible over‐ load situation. Managers should sit down and talk with team members if they feel that the team is moving toward overload.\n\nConclusion In a perfect world, SRE teams would always be able to manage interrupts with the tactics described in our first book. But we’re only human, and sometimes our teams don’t reach that ideal. This chapter examined some of the ways that overload can consume a team and discussed how to detect and respond when it does.\n\nParticularly when it comes to operational work, excessive interrupts can very easily cause a team to slip from a normal workload to overload. Frequent interrupts can lead to overload, and overload negatively affects health and productivity. Overload creates psychosocial stressors for team members, which impacts work even further, causing a self-enforcing cycle.\n\nPerceived overload is a special form of overload that can’t be measured by the amount of toil or operational work. It is hard to pinpoint and to eliminate.\n\nIn order to keep a team’s workload in balance, it’s important to constantly monitor (perceived or nonperceived) overload. To better serve your users and do good work, you need to first show respect to yourself and your team. Maintaining a healthy bal‐ ance in your daily work goes a long way in helping you and your team accomplish that goal.\n\nConclusion\n\n|\n\n369",
      "content_length": 1503,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 403,
      "content": "CHAPTER 18 SRE Engagement Model\n\nBy Michael Wildpaner, Gráinne Sheerin, Daniel Rogers, and Surya Prashanth Sanagavarapu (New York Times) with Adrian Hilton and Shylaja Nukala\n\nChapter 32 in our first SRE book describes technical and procedural approaches that an SRE team can take to analyze and improve the reliability of a service. These strate‐ gies include Production Readiness Reviews (PRRs), early engagement, and continu‐ ous improvement.\n\nSimply put, SRE principles aim to maximize the engineering velocity of developer teams while keeping products reliable. This two-fold goal is good for the product users and good for the company. But there’s a limit to how much even the best SRE team can accomplish, and the SRE model is less effective when the domain is too large and overly complex. The current microservices movement makes this dynamic even more acute—a small company can easily have more microservices than a single SRE team can handle. Given a large production landscape, and with the knowledge that they can’t cover every service, an SRE team must decide where to focus their attention to achieve the best results. Product development and SRE teams can collab‐ orate to identify the correct point of focus.\n\nThis chapter adopts the perspective of an SRE team that’s intending to provide sup‐ port for a new service. We look at how to engage most effectively with the service, and with the developer and product teams who own it. Although SRE engagement often builds around one or more services, the engagement entails much more than the services themselves—it focuses on understanding the aims of developer and prod‐ uct teams and finding the right way to support them.\n\nMost of this discussion is applicable regardless of your organization’s scale. While we use the word team frequently, a team could theoretically start off as a single person (although that person would be quite busy). Regardless of your team’s size, it’s\n\n371",
      "content_length": 1949,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 404,
      "content": "important to proactively define the role of SRE and manage communication and col‐ laboration with product development.\n\nThe Service Lifecycle As described in the preface to the first SRE book, an SRE team’s contributions to ser‐ vice reliability happen throughout all phases of the service lifecycle. Their application of production knowledge and experience can substantially improve the reliability of a service well before any SRE picks up the pager for the service.\n\nFigure 18-1 shows the ideal levels of SRE engagement over the course of a service’s life. However, an SRE team might begin their engagement with a service at any stage in the lifecycle. For example, if the development team begins planning a replacement service for an SRE-supported service, SRE might be involved in the new service very early on. Alternatively, an SRE team might formally engage with a service once it has been generally available for months or years and is now facing reliability or scaling challenges. This section provides guidance on how SRE teams can effectively contrib‐ ute at each phase.\n\nFigure 18-1. Level of SRE engagement during the service lifecycle\n\nPhase 1: Architecture and Design SRE can influence the architecture and design of a software system in different ways:\n\nCreating best practices, such as resilience to various single points of failure, that a developer team can employ when building a new product\n\n372\n\n|\n\nChapter 18: SRE Engagement Model",
      "content_length": 1454,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 405,
      "content": "Documenting the dos and don’ts of particular infrastructure systems (based upon prior experience) so developers can choose their building blocks wisely, use them correctly, and avoid known pitfalls\n\nProviding early engagement consulting to discuss specific architectures and design choices in detail, and to help validate assumptions with the help of targe‐ ted prototypes\n\nJoining the developer team and participating in development work\n\nCodesigning part of the service\n\nFixing architectural mistakes becomes more difficult later in the development cycle. Early SRE engagement can help avoid costly redesigns that become necessary when systems interact with real-world users and need to scale in response to service growth.\n\nPhase 2: Active Development As the product takes shape during active development, SREs can start productioniz‐ ing the service—getting it in shape to be released into production. Productionaliza‐ tion typically includes capacity planning, setting up extra resources for redundancy, planning for spike and overload handling, implementing load balancing, and putting in place sustainable operational practices like monitoring, alerting, and performance tuning.\n\nPhase 3: Limited Availability As a service progresses toward Beta, the number of users, variety of use cases, inten‐ sity of usage, and availability and performance demands increase. At this stage, SRE can help measure and evaluate reliability. We strongly recommend defining SLOs before general availability (GA) so that the service teams have an objective measure of how reliable the service is. The product team still has the option to withdraw a product that can’t meet its target reliability.\n\nDuring this phase, the SRE team can also help scale the system by building a capacity model, acquiring resources for upcoming launch phases, and automating turnups and in-place service resizing. SRE can ensure proper monitoring coverage and help create alerts that ideally match the upcoming service SLOs.\n\nWhile service usage is still changing, the SRE team can expect an increased amount of work during incident response and operational duties because the teams are still learning how the service works and how to manage its failure modes. We recom‐ mend sharing this work between the developer and SRE teams. That way, the devel‐ oper team gains operational experience with the service and the SREs gain experience\n\nThe Service Lifecycle\n\n|\n\n373",
      "content_length": 2434,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 406,
      "content": "with the service in general. Operational work and incident management will inform the system changes and updates the service owners need to make before GA.\n\nPhase 4: General Availability In this phase, the service has passed the Production Readiness Review (see Chapter 32 in Site Reliability Engineering for more details) and is accepting all users. While SRE typically performs the majority of operational work, the developer team should continue to field a small part of all operational and incident response work so they don’t lose perspective on these aspects of the service. They might permanently include one developer in the on-call rotation to help the developers keep track of operational load.\n\nIn the early phase of GA, as the developer team focuses on maturing the service and launching the first batches of new features, it also needs to stay in the loop to under‐ stand system properties under real load. In the later stages of GA, the developer team provides small incremental features and fixes, some of which are informed by opera‐ tional needs and any production incidents that occur.\n\nPhase 5: Deprecation No system runs forever. If and when a better replacement system is available, the existing system is closed for new users and all engineering focuses on transitioning users from the existing system to the new one. SRE operates the existing system mostly without involvement from the developer team, and supports the transition with development and operational work.\n\nWhile SRE effort required for the existing system is reduced, SRE is effectively sup‐ porting two full systems. Headcount and staffing should be adjusted accordingly.\n\nPhase 6: Abandoned Once a service is abandoned, the developer team typically resumes operational sup‐ port. SRE supports service incidents on a best-effort basis. For a service with internal users, SRE hands over service management to any remaining users. This chapter pro‐ vides two case studies of how SRE can hand back a service to developer teams.\n\nPhase 7: Unsupported There are no more users, and the service has been shut down. SRE helps to delete references to the service in production configurations and in documentation.\n\n374\n\n|\n\nChapter 18: SRE Engagement Model",
      "content_length": 2234,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 407,
      "content": "Setting Up the Relationship A service does not exist in a vacuum: the SRE team engages with the developer team that builds the service and the product team that determines how it should evolve. This section recommends some strategies and tactics for building and maintaining good working relationships with those teams.\n\nCommunicating Business and Production Priorities Before you can help someone, you need to understand their needs. To that end, SREs need to understand what the product developers expect the SRE engagement to ach‐ ieve. When engaging with a developer team, SREs should build a deep understanding of the product and business goals. SREs should be able to articulate their role and how SRE engagement can enable developers to execute toward these goals.\n\nTeams need to regularly talk with each other about business and production priori‐ ties. The SRE and developer leadership teams should ideally work as a unit, meeting regularly and exchanging views about technical and prioritization challenges. Some‐ times SRE leads join the product development leadership team.\n\nIdentifying Risks Because an SRE team is focused on system reliability, they are well positioned to identify potential risks. Gauging the likelihood and potential impact of those risks as accurately as possible is important, as the cost of disrupting regular development and feature flow is significant to the product and to engineers.\n\nAligning Goals The developer and SRE teams both care about reliability, availability, performance, scalability, efficiency, and feature and launch velocity. However, SRE operates under different incentives, mainly favoring service long-term viability over new feature launches.\n\nIn our experience, developer and SRE teams can strike the right balance here by maintaining their individual foci but also explicitly supporting the goals of the other group. SREs can have an explicit goal to support the developer team’s release velocity and ensure the success of all approved launches. For example, SRE might state, “We will support you in releasing as quickly as is safe,” where “safe” generally implies stay‐ ing within error budget. Developers should then commit to dedicating a reasonable percentage of engineering time to fixing and preventing the things that are breaking reliability: resolving ongoing service issues at the design and implementation level, paying down technical debt, and including SREs in new feature development early so that they can participate in design conversations.\n\nSetting Up the Relationship\n\n|\n\n375",
      "content_length": 2555,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 408,
      "content": "Shared Goals: SRE Engagements at the New York Times\n\nby Surya Prashanth Sanagavarapu (New York Times)\n\nIn our organization, SRE resources are in high demand when it comes to cloud migrations, production ramp-ups, and applications moving toward containers. In addition, SRE teams have their own backlogs to tackle. In the face of limited resour‐ ces, these competing priorities define success for the SRE team. While hiring SREs is one obvious way to address the demand for SRE time, not every team has the luxury, experience, or time to do so.\n\nThe core mission of the SRE function at the New York Times is to empower product development teams with tools and processes to maximize reliability and resilience in applications that support our newsroom, thus enabling distribution of high-quality journalism to readers. We adopted a shared goals model to achieve a balance between reducing the automation backlog and engaging with other teams.\n\nBefore engaging with teams, we review our overall backlog for the current quarter/ year and clearly define its work items and categories. For instance, our backlog items might include:\n\nAdd automation to set up baseline monitoring and alerting by hitting service sta‐ tus endpoints for applications.\n\nImplement more reliable and/or faster build pipelines.\n\nWhen teams approach SREs for help, one of the factors we consider when prioritizing a request is whether a joint engagement might help reduce our backlog.\n\nDefining the Engagement\n\nOur SREs work with product development teams according to two different models:\n\nA full-time basis\n\nA part-time basis for fairly brief and constrained projects\n\nWe define the type of engagement based upon the SRE team’s bandwidth. For full- time engagements, we prefer to embed an SRE in a product development team. This helps provide focus and time to relieve some burden from the product engineering teams. The SRE and product teams have maximum time to learn about each other as the developers ramp up on SRE skills and capabilities. For long-term engagements, we prioritize applications that best fit into our company strategy.\n\nWhen defining the engagement scope, we attempt to gauge the maturity of the team or the application in relation to SRE practices. We find that various teams are at dif‐ ferent levels of maturity when it comes to thinking about SRE practices and princi‐ ples. We are working on applying an application maturity model to help here.\n\n376\n\n|\n\nChapter 18: SRE Engagement Model",
      "content_length": 2484,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 409,
      "content": "Setting Shared Goals and Expectations\n\nSetting the right expectations is critical for meeting deadlines and task completion. To this end, we work according to the following principles:\n\nWe emphasize that the application owners, not SREs, are directly responsible for making changes to an application.\n\nSRE engagement is for company-wide benefit. Any new automation or tooling should improve common tools and automation used across the company and avoid one-off script development.\n\nSREs should give the developer team a heads up about any new processes the engagement might introduce (for example, load testing).\n\nThe engagements may involve Application Readiness Reviews (ARRs) and Pro‐ duction Readiness Reviews (PRRs), as described in Chapter 32 of Site Reliability Engineering. Proposed changes from ARR and PRR must be prioritized jointly by the developers and the SREs.\n\nSREs are not traditional operations engineers. They do not support manual work such as running a job for deployment.\n\nWhen we set shared goals, we write them jointly with the development team and divide the goals into milestones. If you are an Agile-based company, you might write epics or stories. The SRE team can then map those goals into their own backlog.\n\nOur common pattern when setting goals is to:\n\n1. Define the scope of the engagement.\n\nExample 1: In the next quarter, I want all members of my team to handle GKE/GAE deployments, become comfortable with production environments, and be able to handle a production outage.\n\nExample 2: In the next quarter, I want SRE to work with the dev team to stabi‐ lize the app in terms of scaling and monitoring, and to develop runbooks and automation for outages.\n\n2. Identify the end result success story, and call it out explicitly.\n\nExample: After the engagement, the product development team can handle our service outages in Google Kubernetes Engine without escalation.\n\nSprints and Communication\n\nAny engagement with product development teams begins with a kickoff and planning meeting. Prior to kickoff, our SRE team reviews the application architecture and our shared goal to verify that the expected outcome is realistic within the given time\n\nSetting Up the Relationship\n\n|\n\n377",
      "content_length": 2215,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 410,
      "content": "frame. A joint planning meeting that creates epics and stories can be a good starting point for the engagement.\n\nA roadmap for this engagement might be:\n\n1. Review the application architecture.\n\n2. Define shared goals.\n\n3. Hold the kickoff and planning session.\n\n4. Implement development cycles to reach milestones.\n\n5. Set up retrospectives to solicit engagement feedback.\n\n6. Conduct Production Readiness Reviews.\n\n7. Implement development cycles to reach milestones.\n\n8. Plan and execute launches.\n\nWe require that the teams define a feedback method and agree on its frequency. Both the SRE and development teams need feedback on what is working and what is not. For these engagements to be successful, we have found that providing a constant feedback loop outside of Agile sprint reviews via an agreed-upon method is useful— for example, setting up a biweekly retrospective or check-in with team managers. If an engagement isn’t working, we expect teams to not shy away from planning for disengagement.\n\nMeasuring Impact\n\nWe have found it important to measure the impact of the engagement to make sure that SREs are doing high-value work. We also measure the maturity level of each partner team so that the SREs can determine the most effective ways to work with them. One approach we adopted from working with Google’s Customer Reliability Engineering (CRE) team is to conduct a point-in-time assessment with leads of the product engineering team before starting the engagement.\n\nA point-in-time assessment consists of walking through a maturity matrix, gauging the maturity of the service along the various axes of concern to SRE (as described in Chapter 32 of Site Reliability Engineering), and agreeing on scores for functional areas such as observability, capacity planning, change management, and incident response. This also helps tailor the engagement more appropriately after we learn more about the team’s strengths, weaknesses, and blind spots.\n\nAfter the engagement ends and the development team is performing on its own, we perform the assessment again to measure the value SRE added. If we have a maturity model in place, we measure against the model to see if the engagement results in a higher level of maturity. As the engagement comes to an end, we plan for a celebra‐ tion!\n\n378\n\n|\n\nChapter 18: SRE Engagement Model",
      "content_length": 2338,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 411,
      "content": "Setting Ground Rules At Google, every SRE team has two major goals:\n\nShort term\n\nFulfill the product’s business needs by providing an operationally stable system that is available and scales with demand, with an eye on maintainability.\n\nLong term\n\nOptimize service operations to a level where ongoing human work is no longer needed, so the SRE team can move on to work on the next high-value engagement.\n\nTo this end, the teams should agree upon some principles of cooperation, such as:\n\nDefinitions of (and a hard limit on) operational work.\n\nAn agreed-upon and measured SLO for the service that is used to prioritize engi‐ neering work for both the developer and SRE teams. You can start without an SLO in place, but our experience shows that not establishing this context from the beginning of the relationship means you’ll have to backtrack to this step later. For an example of how engineering work proceeds less than ideally in the absence of an SLO, see “Case Study 1: Scaling Waze—From Ad Hoc to Planned Change” on page 427.\n\nAn agreed-upon quarterly error budget that determines release velocity and other safety parameters, such as excess service capacity to handle unexpected usage growth.\n\nDeveloper involvement in daily operations to ensure that ongoing issues are visi‐ ble, and that fixing their root causes is prioritized.\n\nPlanning and Executing Proactive planning and coordinated execution ensure that SRE teams meet expecta‐ tions and product goals while optimizing operations and reducing operational cost. We suggest planning at two (connected) levels:\n\nWith developer leadership, set priorities for products and services and publish yearly roadmaps.\n\nReview and update roadmaps on a regular basis, and derive goals (quarterly or otherwise) that line up with the roadmap.\n\nRoadmaps ensure that each team has a long-term time horizon of clear, high-impact work. There can be good reasons to forego roadmaps (for example, if the develop‐ ment organization is changing too quickly). However, in a stable environment, the\n\nSetting Up the Relationship\n\n|\n\n379",
      "content_length": 2075,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 412,
      "content": "absence of a roadmap may be a signal that the SRE team can merge with another team, move service management work back to the development teams, expand scope, or dissolve.\n\nHolding ongoing strategy conversations with developer leadership helps to quickly identify shifts in focus, discuss new opportunities for SRE to add value to the busi‐ ness, or stop activities that are not cost-effective for the product.\n\nRoadmaps can focus on more than just improving the product. They can also address how to apply and improve common SRE technologies and processes to drive down operational cost.\n\nSustaining an Effective Ongoing Relationship Healthy and effective relationships require ongoing effort. The strategies outlined in this section have worked well for us.\n\nInvesting Time in Working Better Together The simple act of spending time with each other helps SREs and developers collabo‐ rate more effectively. We recommend that SREs meet regularly with their counter‐ parts for the services they run. It’s also a good idea for SREs to meet periodically with other SRE teams who run services that either send traffic to the service or provide common infrastructure that the service uses. The SRE team can then escalate confi‐ dently and quickly during outages or disagreements because the teams know each other and have already set expectations of how escalations should be initiated and managed.\n\nMaintaining an Open Line of Communication In addition to the day-to-day communication between teams, we’ve found a couple methods of more formal information exchange to be particularly helpful over the course of the engagement.\n\nSREs can give a quarterly “state of production” talk to product development leader‐ ship to help them understand where they should invest resources and how exactly SRE is helping their product or service. In a similar vein, developers can give a peri‐ odic “state of the product” talk to the SRE team or involve SRE in the developer team’s executive presentations. This gives the SRE team an overview of what the developer team has accomplished over the last quarter (and lets the SREs see how their own work enabled that). It also provides an update on where the product is going over the next few quarters, and where the product lead sees SRE engaging to make that happen.\n\n380\n\n|\n\nChapter 18: SRE Engagement Model",
      "content_length": 2340,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 413,
      "content": "Performing Regular Service Reviews As the decision makers for the service’s future, the SRE and developer team leads responsible for the service should meet face-to-face at least once a year. Meeting more frequently than this can be challenging—for example, because it may involve intercontinental travel. During this meeting, we typically share our roadmaps for the next 12–18 months and discuss new projects and launches.\n\nSRE teams sometimes facilitate a retrospective exercise, where the leads discuss what the teams want to stop doing, keep doing, and start doing. Items can appear in more than one area, and all opinions are valid. These sessions need active facilitation because the best results come from full-team participation. This is often rated the most useful session in the service meeting because it yields details that can drive sig‐ nificant service changes.\n\nReassessing When Ground Rules Start to Slip If cooperation in any of the agreed-upon areas (see “Setting Ground Rules” on page 379) begins to regress, both developers and SRE need to change priorities to get the service back in shape. We have found that, depending on the urgency, this can mean any of the following:\n\nThe teams identify specific engineers who must drop their lower-priority tasks to focus on the regression.\n\nBoth teams call a “reliability hackathon,” but usual team priorities continue out‐ side of the hackathon days.\n\nA feature freeze is declared and the majority of both teams focus on resolving the regression.\n\nTechnical leadership determines that the reliability of the product is at acute risk, and the teams call an “all hands on deck” response.\n\nAdjusting Priorities According to Your SLOs and Error Budget The subtle art of crafting a well-defined SLO helps a team prioritize appropriately. If a service is in danger of missing the SLO or has exhausted the error budget, both teams can work with high priority to get the service back into safety. They can address the situation through both tactical measures (for example, overprovisioning to address traffic-related performance regressions) and more strategic software fixes (such as optimizations, caching, and graceful degradation).\n\nIf a service is well within SLO and has ample error budget left, we recommend using the spare error budget to increase feature velocity rather than spending overpropor‐ tional efforts on service improvements.\n\nSustaining an Effective Ongoing Relationship\n\n|\n\n381",
      "content_length": 2455,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 414,
      "content": "Handling Mistakes Appropriately Humans inevitably make mistakes. Consistent with our postmortem culture, we don’t blame people, and instead focus on system behavior. Your mileage may vary, but we have had success with the following tactics.\n\nSleep on it\n\nIf possible, don’t conduct follow-up conversations when you’re tired or emotions are high. During high-stress situations, people can easily misinterpret tone in written communication like emails. Readers will remember how the words made them feel, not necessarily what was written. When you’re communicating across locations, it’s often worth the time to set up a video chat so that you can see facial expressions and hear the tone of voice that helps disambiguate words.\n\nMeet in person (or as close to it as possible) to resolve issues\n\nInteractions conducted solely via code reviews or documentation can quickly become drawn out and frustrating. When a behavior or decision from another team is at odds with our expectations, we talk with them about our assumptions and ask about miss‐ ing context.\n\nBe positive\n\nThank people for their positive behaviors. Doing so can be simple—for example, dur‐ ing code reviews, design reviews, and failure scenario training, we ask engineers to call out what was good and explain why. You might also recognize good code com‐ ments or thank people for their time when they invest in a rigorous design review.\n\nUnderstand differences in communication\n\nDifferent teams have different internal expectations for how information is dissemi‐ nated. Understanding these differences can help strengthen relationships.\n\nScaling SRE to Larger Environments The scenarios we’ve discussed so far involve a single SRE team, a single developer team, and one service. Larger companies, or even small companies that use a micro‐ services model, may need to scale some or all of these numbers.\n\nSupporting Multiple Services with a Single SRE Team Because SREs have specialized skills and are a scarce resource, Google generally maintains an SRE-to-developer ratio of < 10%. Therefore, one SRE team commonly works with multiple developer teams in their product area (PA).\n\n382\n\n|\n\nChapter 18: SRE Engagement Model",
      "content_length": 2188,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 415,
      "content": "If SREs are scarce relative to the number of services that merit SRE support, an SRE team can focus their efforts on one service, or on a few services from a small number of developer teams.\n\nIn our experience, you can scale limited SRE resources to many services if those serv‐ ices have the following characteristics:\n\nServices are part of a single product. This provides end-to-end ownership of the user experience and alignment with the user.\n\nServices are built on similar tech stacks. This minimizes cognitive load and ena‐ bles effective reuse of technical skills.\n\nServices are built by the same developer team or a small number of related devel‐ oper teams. This minimizes the number of relationships and makes it easier to align priorities.\n\nStructuring a Multiple SRE Team Environment If your company is big enough to have multiple SRE teams, and perhaps multiple products, you need to choose a structure for how SRE and the product groups relate.\n\nWithin Google, we support a complex developer organization. As shown in Figure 18-2, each PA consists of multiple product groups that each contain multiple products. The SRE organization shadows the developer organization hierarchically, with shared priorities and best practices at each level. This model works when all teams in a group, or all groups in a PA, share the same or similar specific business goals, and when every product group has both a product leader and an SRE lead.\n\nFigure 18-2. Large-scale developer-to-SRE team relationships (per product area)\n\nScaling SRE to Larger Environments\n\n|\n\n383",
      "content_length": 1569,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 416,
      "content": "If your organization has multiple SRE teams, you’ll need to group them in some way. The two main approaches we’ve seen work well are:\n\nGroup the teams within a product, so they don’t have to coordinate with too many different developer teams.\n\nGroup the teams within a technology stack (e.g., “storage” or “networking”).\n\nTo prevent churn in SRE teams during developer reorgs, we recommend organizing SRE teams according to technology rather than developer PA reporting structure. For example, many teams that support storage systems are structured and operate in the same way. Grouping storage systems in technology-focused product groups may make more sense even if they come from different parts of the developer organiza‐ tion.\n\nAdapting SRE Team Structures to Changing Circumstances If you need to modify the structure of your SRE teams to reflect changing PA needs, we recommend creating, splitting (sharding), merging, and dissolving SRE teams based on service needs and engineering and operational load. Each SRE team should have a clear charter that reflects their services, technology, and operations. When a single SRE team has too many services, rather than building new teams from scratch, we prefer to shard the existing team into multiple teams to transfer culture and grow existing leadership. Changes like this are inevitably disruptive to existing teams, so we’d recommend that you restructure teams only when necessary.\n\nRunning Cohesive Distributed SRE Teams If you need to ensure 24/7 coverage and business continuity, and you have a global presence, it’s worth trying to distribute your SRE teams around the globe to provide even coverage. If you have a number of globally distributed teams, we recommend colocating teams based upon adjacency and upon similarity of services and shared technology. We’ve found that singleton teams are generally less effective and more vulnerable to the effects of reorgs outside the team—we create such teams only if clearly defined business needs call for them and we’ve considered all other options.\n\nMany companies don’t have the resources for full global coverage, but even if you’re split only across buildings (never mind continents), it’s important to create and maintain a two-location arrangement.\n\nIt’s also important to create and maintain organizational standards that drive plan‐ ning and execution and foster and maintain a shared team culture. To this end, we find it useful to gather the entire team in one physical location periodically—for example, at an org-wide summit every 12–18 months.\n\n384\n\n|\n\nChapter 18: SRE Engagement Model",
      "content_length": 2606,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 417,
      "content": "Sometimes it doesn’t make sense for everyone on the team to own certain responsi‐ bilities—for example, conducting regular test restores from backups or implementing cross-company technical mandates. When balancing these responsibilities between a team’s distributed sites, keep the following strategies in mind:\n\nAssign individual responsibilities to single locations, but rotate them regularly (e.g., yearly).\n\nShare every responsibility between locations, making an active effort to balance the involvement and workload.\n\nDon’t lock a responsibility to a single location for multiple years. We’ve found that the costs of this configuration ultimately outweigh the benefits. Although that location will tend to become really good at executing those responsibilities, this fosters an “us versus them” mentality, hinders distribution of knowledge, and presents a risk for business continuity.\n\nAll of these strategies require locations to maintain tactical and strategic communica‐ tion.\n\nEnding the Relationship SRE engagements aren’t necessarily indefinite. SREs provide value by doing impact‐ ful engineering work. If the work is no longer impactful (i.e., the value proposition of an SRE engagement goes away), or if the majority of the work is no longer on the engineering (versus operations) side, you may need to revisit the ongoing SRE engagement. In general, individual SREs will move away from toil-heavy teams to teams with more interesting engineering work.\n\nOn a team level, you might hand back a service if SRE no longer provides sufficient business value to merit the costs. For example:\n\nIf a service has been optimized to a level where ongoing SRE engagement is no longer necessary\n\nIf a service’s importance or relevance has diminished\n\nIf a service is reaching end of life\n\nThe following case studies demonstrate how two Google SRE engagement models ended. The first ends with largely positive results, while the other ends with a more nuanced outcome.\n\nCase Study 1: Ares Google’s Abuse SRE and Common Abuse Tool (CAT) teams provided anti-abuse protection for most Google properties and worked with customer-facing products to\n\nEnding the Relationship\n\n|\n\n385",
      "content_length": 2179,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 418,
      "content": "keep users safe. The Abuse SRE team applied engineering work to lower CAT’s operational support burden so that the developers were able to take a direct role in supporting their users. These users were the Googlers operating the properties defen‐ ded by CAT, who had high expectations about the efficacy of CAT and its response time to problems or new threats.\n\nEfficient abuse fighting requires constant attention, rapid adaptive changes, and nim‐ ble flexibility in the face of new threats and attacks. These requirements clashed with the common SRE goals of reliable and planned feature development. CAT teams rou‐ tinely needed to implement fast development and deploy new protections to proper‐ ties under attack. However, Abuse SRE pushed back on requested changes, requesting more in-depth analysis of the consequences each new protection would have on the overall production system. Time constraints on consultations between teams and reviews compounded this tension.\n\nTo hopefully improve the situation, Abuse SRE and CAT leadership engaged in a multiyear project to create a dedicated infrastructure team within CAT. The newly formed “Ares” team had a mandate to unify abuse-fighting infrastructure for Google properties. This team was staffed by CAT engineers who had production infrastruc‐ ture knowledge and experience building and running large services. The teams started an exchange program to transfer production management knowledge from Abuse SRE to the CAT infrastructure team members.\n\nAbuse SREs taught the Ares team that the easiest way to launch a new service in pro‐ duction (when you’re already running large distributed services) is to minimize the additional cognitive load that the service imposes. To reduce this cognitive load, sys‐ tems should be as homogeneous as possible. Deploying and managing a collection of production services together means they can share the same release structure, capacity planning, subservices for accessing storage, and so on. Following this advice, Ares redesigned the whole abuse-fighting stack, applying modularity concepts to shift toward a microservice model. They also built a new layer that provided abstractions for developers so that they didn’t have to worry about lower-level production details like monitoring, logging, and storage.\n\nAt this point, the Ares team started to act more like an SRE team for CAT by admin‐ istering the new abuse-fighting infrastructure. Meanwhile, Abuse SRE focused on the production deployment and efficient day-to-day operation of the overall abuse- fighting infrastructure.\n\nCollaboration between the Ares engineers and Abuse SRE resulted in the following improvements:\n\nBecause the CAT team now had “in-house” production experts that were also experts in abuse fighting, Abuse SRE no longer had to vet new feature integra‐ tion. This greatly reduced time to production for new features. At the same time,\n\n386\n\n|\n\nChapter 18: SRE Engagement Model",
      "content_length": 2953,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 419,
      "content": "the CAT team’s developer velocity increased because the new infrastructure abstracted away production management details.\n\nThe Abuse SRE team now had many fewer requests from the CAT team to launch new features, as most of the requests did not require infrastructure changes. The team also needed less knowledge to evaluate the impact of a new feature, since infrastructure changes were rarely required. When infrastructure changes were necessary, Abuse SRE only needed to clarify the implications on the infrastructure rather than specific feature functionality.\n\nProducts that needed to integrate with abuse-fighting infrastructure had a faster and more predictable turnaround time since a product integration was now equivalent in effort to a feature launch.\n\nAt the end of this project, Abuse SREs disengaged from directly supporting CAT, focusing instead on the underlying infrastructure. This did not compromise CAT’s reliability or overburden the CAT team with additional operational work; instead, it increased CAT’s overall development velocity.\n\nCurrently, Ares protects users across a large number of Google properties. Since the team’s inception, SREs and product development have partnered to make collabora‐ tive decisions on how infrastructure will work in production. This partnership was only possible because the Ares effort created a sense of shared destiny.\n\nCase Study 2: Data Analysis Pipeline Sometimes the cost of maintaining an SRE support relationship is higher than the value (perceived or measured) that SREs provide. In these cases, it makes sense to end the relationship by disbanding the SRE team.1\n\nWhen the value of a relationship declines over time, it is extremely difficult to iden‐ tify a point in time when it makes sense to terminate that relationship. Two teams at Google that supported a revenue-critical data analysis pipeline had to face this chal‐ lenge. Figuring out that a parting of the ways was appropriate was not a trivial task, especially after a decade of cooperation. In retrospect, we were able to identify several patterns within the team interaction that were strong indicators that we needed to reconsider the relationship between the SRE team and the product team.\n\nThe pivot\n\nThree years before the turndown, all involved parties recognized that their primary data analysis pipeline was running into scaling limitations. At that time, the devel‐ oper team decided to start planning their new system and dedicated a small number\n\n1 Google HR supports employees by finding new opportunities when such transitions occur.\n\nEnding the Relationship\n\n|\n\n387",
      "content_length": 2609,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 420,
      "content": "of engineers to the new effort. As that effort began to coalesce, it made sense to deprioritize development of large, complex, or risky features for the existing system in favor of work on the new system. This had two important effects over time:\n\nAn informal rule was applied to new projects: if the project’s complexity or the risk involved in modifying the existing system to accommodate the project was sufficiently high, then it was better to make that investment in the new system.\n\nAs resources shifted to developing the new system, even relatively conservative changes to the existing system became more difficult. Nevertheless, usage contin‐ ued to grow at an extremely high rate.\n\nCommunication breakdown\n\nKeeping an existing system operational while a replacement system is simultaneously designed, built, and launched is challenging for any engineering team. Stresses natu‐ rally build between the people focused on new versus old systems, and teams need to make difficult prioritization decisions. These difficulties can be compounded when the teams are separated organizationally—for example, an SRE team focused on maintaining and operating an existing system and a developer team working on the next-generation system.\n\nRegular, open, and cooperative communication is vital throughout this entire cycle in order to maintain and preserve a good working relationship across teams. In this example, a gap in communication led to a breakdown in the working relationship between teams.\n\nDecommission\n\nIt took some time to realize that the disconnectedness between the SRE and devel‐ oper teams was insurmountable. Ultimately, the simplest solution was to remove the organizational barrier and give the developer team full control over prioritizing work on old and new systems. The systems were expected to overlap for 18–24 months before the old system was fully phased out.\n\nCombining SRE and product development functions into a single team allowed upper management to be maximally responsive to their areas of accountability. Meanwhile, the team could decide how to balance operational needs and velocity. Although decommissioning two SRE teams was not a pleasant experience, doing so resolved the continual tension over where to invest engineering effort.\n\nDespite the inevitable extra operational load on the developer team, realigning own‐ ership of the old system with people who had greater knowledge of service internals provided the opportunity to more quickly address operational problems. This team also had more insight into potential causes of outages, which generally resulted in\n\n388\n\n|\n\nChapter 18: SRE Engagement Model",
      "content_length": 2647,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 421,
      "content": "more effective troubleshooting and quicker issue resolution. However, there were some unavoidable negative impacts while the developer team learned about the nuances of the operational work needed to support the service in a short amount of time. The SRE team’s final job was to make the transfer of this knowledge as smooth as possible, equipping the developer team to take on the work.\n\nIt is worth noting that if the working relationship were healthier—with teams work‐ ing together effectively to solve problems—SRE would have handed production work back to the developer team for a short period of time. After the system was restabi‐ lized and hardened for expected growth needs, SRE would normally reassume responsibility of the system. SRE and development teams need to be willing to address issues head on and identify points of tension that need resetting. Part of SRE’s job is to help maintain production excellence in the face of changing business needs, and often this means engaging with developers to find solutions to challenging problems.\n\nConclusion The form of an SRE team’s engagement changes over the various phases of a service’s lifecycle. This chapter provided advice specific to each phase. Examples from both the Google and the New York Times SRE teams show that effectively managing the engagement is just as important as making good technical design decisions. Some‐ times an SRE engagement should reach a natural conclusion. Case studies from Ares and a data analysis pipeline team provided examples of how this can happen, and how best to end the engagement.\n\nWhen it comes to best practices for setting up an effective relationship between SRE and product development teams, a shared sense of purpose and goals with regular and open communication is key. You can scale an SRE team’s impact in a number of ways, but these principles for relationship management should always hold true. For sustaining the long-term success of an engagement, investing in aligning team goals and understanding each other’s objectives is as important as defending SLOs.\n\nConclusion\n\n|\n\n389",
      "content_length": 2099,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 423,
      "content": "CHAPTER 19 SRE: Reaching Beyond Your Walls\n\nBy Dave Rensin with Betsy Beyer, Niall Richard Murphy, and Liz Fong-Jones\n\nIt has been 14 years since we started practicing SRE at Google. Some of what has come in that time seems obvious in retrospect, while other developments came as something of a shock. The past two years since the publication of our first SRE book have been especially interesting. The number of companies now practicing the SRE discipline and the amount of time we spend talking about it at conferences and with customers has grown beyond anything we previously imagined.\n\nThat change in particular—the rapid expansion of the non-Google ecosystem around SRE—is the most exciting development, but it makes predicting the future of the SRE profession more difficult. Still, in our own SRE work at Google we are starting to see some trends that might inform an outline of the profession’s future. This chapter rep‐ resents our effort to share what we, along with our SRE coworkers around the globe, have seen, and what we have concluded so far.\n\nTruths We Hold to Be Self-Evident The only way to make any useful sense of the future is to start with a set of principles and work forward. Some of what follows should be uncontroversial. Other bits, not so much. In every case, though, these principles are based on real things we’re seeing in the world.\n\nReliability Is the Most Important Feature People don’t normally disagree much with us when we assert that “reliability is the most important feature of any system”—as long as we take care to point out that “reliability” often covers a wide area.\n\n391",
      "content_length": 1618,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 424,
      "content": "The argument is simple enough:\n\nIf a system isn’t reliable, users won’t trust it.\n\nIf users don’t trust a system, when given a choice, they won’t use it.\n\nSince all software systems are governed by network effects, if a system has no users, it’s worth nothing.\n\nYou are what you measure, so choose your metrics carefully.\n\nYour Users, Not Your Monitoring, Decide Your Reliability Since the value of a system is related to its users, it stands to reason that the only measure of reliability that matters is how your users experience reliability. If your user is worried that your platform is responsible for instability they’re experiencing, then telling them “our monitoring looks fine; the problem must be on your end” won’t make them any less grumpy. They’re experiencing your system as unstable, and that’s what they will remember when the time comes to choose between you and your competitor. (This phenomenon is called the peak-end rule.)\n\nYour monitoring, logs, and alerting are valuable only insofar as they help you notice problems before your customers do.\n\nIf You Run a Platform, Then Reliability Is a Partnership If the only way for someone to use your system is via a visual user interface (e.g., a web page) and your system is consumed only by actual human beings (as opposed to machines), then the reliability your users experience is almost exclusively tied to the job you do as an SRE keeping your system healthy.\n\nHowever, once you add an API and some of your “users” are actually other machines, you are running a platform and the rules change.\n\nWhen your product acts as a platform, the reliability your users experience isn’t limi‐ ted to the choices you make. Reliability becomes a partnership. If your users build or operate a system on your platform that never achieves better than 99% availability— even if you’re running your platform at 99.999% availability—then their best-case experience is 98.99901%.\n\nThe choices these users make directly affect the experience they have and associate with your service. You might not like it, but they will hold you accountable for what‐ ever they experience—even if it’s not “your fault.”\n\n392\n\n|\n\nChapter 19: SRE: Reaching Beyond Your Walls",
      "content_length": 2206,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 425,
      "content": "Everything Important Eventually Becomes a Platform Since the value of your system increases with the number of people using it, you will want to find ways to reach other large established user pools. As you attract more users, other software systems will want to reach your audience, too.\n\nThis is when other companies start making their machines talk to your machines via APIs. If your system is even remotely popular, integration is an inevitable step in your evolution.\n\nEven if you decide that you don’t care about other user communities, and decide to never create a machine-consumable API, you still won’t be able to avoid this future. Other people will simply wrap your UI into a machine API and consume it. The only difference is that you’ll have no control over the outcome.\n\nOnce your system becomes a gateway to a large collection of users, it becomes valua‐ ble. APIs—official or unofficial—will be a part of your future.\n\nWhen Your Customers Have a Hard Time, You Have to Slow Down When your customers have a hard time, their frustration turns into friction for you. Even if you don’t have traditional modes of support (trouble tickets, email, phone, etc.), you will still spend time triaging questions and responding to complaints via StackOverflow, or even Twitter, Facebook, and other social platforms.\n\nWhatever energy you put into helping users past their difficult moments is energy you can’t invest in advancing your system. We have seen many teams (and compa‐ nies) allow their time to be slowly absorbed by break/fix customer problems—leaving an ever-diminishing innovation budget. These teams are consumed by toil.\n\nOnce in this state, it’s hard to dig out (see Chapter 6). A better plan is to get ahead of the impending toil. You might be reading this and thinking, Gee, I’m on an internal platform team. This doesn’t apply to me!\n\nWe’re sorry to inform you that this doubly applies to you! In your case, your custom‐ ers are the consumers of your system within your company.\n\nThis leads us to the next conclusion.\n\nYou Will Need to Practice SRE with Your Customers If you want your customers to design and operate reliable systems using your plat‐ form, you have to teach them how to do it. Yes, this includes your internal customers, too. Just because you work on an internal platform team doesn’t mean you escape this dynamic—in fact, you’re likeliest to run into it first.\n\nEven if you could perfectly distill that information into highly scaled one-to-many forms (books, blog posts, architecture diagrams, videos, etc.), you still need a way to\n\nTruths We Hold to Be Self-Evident\n\n|\n\n393",
      "content_length": 2616,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 426,
      "content": "figure out what content and training to include. As you grow and improve your plat‐ form, those lessons will change. You will always need a way to keep these resources from getting stale.\n\nThe best way to learn these lessons is to “do SRE” with your customers.\n\nThat doesn’t necessarily mean you need to take the pagers for your customers’ sys‐ tems, but you do need to undertake most of the work that normally leads up to pager handoff (meaning the system has met certain minimum viable reliability require‐ ments), with at least a representative sample of your users.\n\nHow to: SRE with Your Customers The idea of walking an SRE journey with your customers might seem a little daunt‐ ing. You’re probably reading this book because you’re not entirely sure how to walk it yourself! No worries. It’s possible to do both at the same time. In fact, the former can help you accelerate the latter.\n\nHere are the steps we like to follow. They work pretty well for us, and we think they’ll be useful for you, too.\n\nStep 1: SLOs and SLIs Are How You Speak You want your customers to perceive your system as reliable. Otherwise, you risk los‐ ing them. It stands to reason, therefore, that you should care a lot about how they form those opinions. What do they measure? How do they measure it? Most impor‐ tantly, what promises are they making to their customers?\n\nYour life will be a lot better if your customers measure SLIs and alert on SLOs, and if they share those measurements with you. Otherwise, you will spend a lot of energy in conversations like this:\n\nCustomer: API call X usually takes time T, but now it’s taking time U. I think you are having a problem. Please look into it and get back to me immediately.\n\nYou: That performance seems in line with what we expect, and everything looks fine on our end. Is it a problem if API call X takes this long?\n\nCustomer: I don’t know. It doesn’t usually take this long, so obviously something has changed and we’re worried about it.\n\nThis conversation will go round in circles and never reach a satisfactory answer. You will either spend a lot of time convincing your customer that they shouldn’t care, or you will spend a lot of time root-causing the change so you can convince your customer they shouldn’t care. In either case, you’re spending a lot of effort that you could be using elsewhere.\n\nThe root cause of this problem is that the customer isn’t using SLOs to figure out if they should care about the performance they’re seeing. They’re just noticing an unex‐\n\n394\n\n|\n\nChapter 19: SRE: Reaching Beyond Your Walls",
      "content_length": 2567,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 427,
      "content": "pected change and deciding to worry about it. Remember, in the absence of a stated SLO, your customer will inevitably invent one and not tell you until you don’t meet it! You’d much rather have this conversation:\n\nCustomer: We’re burning through our SLO for application FOO too quickly and the application is in jeopardy. SLIs X and Y seem to have fallen off a cliff. They both depend on your API X.\n\nYou: Okay. Let me look into how API X is performing in our system and/or how it’s performing specific to you.\n\nThat’s a much more productive conversation because (a) it will happen only when the SLO is threatened, and (b) it relies on mutually understood metrics (SLIs) and targets (SLOs).\n\nIf you’re running your systems using SRE practices, then you are speaking SLOs internally. Your life will be better and your customers will be happier if they are speaking SLOs, too, because it makes it easier for the two of you to talk.\n\nWe recommend a simple exercise to make your working relationship with a customer a lot better: sit down with your customer. Explain SLOs, SLIs, and error budgets— and especially how you practice them in your teams. Then help them describe the critical applications they’ve built on your platform in those terms.\n\nStep 2: Audit the Monitoring and Build Shared Dashboards Once your customers have picked some basic SLOs for their application, the next question is if they are measuring the right things to determine whether or not they’re meeting those goals. You should help them figure out if the measurements they’re using are appropriate.\n\nIn our experience, up to half of the things your customer is measuring (and alerting on) have zero impact on their SLOs. Your life will be better when you point this out to them and they turn off the offending alerting. It will mean fewer pages for them, and for you!\n\nThe remaining measurements are useful candidate SLIs. Help your customer assem‐ ble those measurements to calculate their SLOs.\n\nOnce you begin this exercise, you’ll quickly find that parts of the SLOs are uncovered —there aren’t relevant measurements in place to say anything useful about these dimensions. You should help your customer cover these parts of their SLOs, too.\n\nNow, your customers can start to say something about their application’s SLO per‐ formance on your platform.\n\nFinally, build a set of shared SLO dashboards with your customer. You should be able to see their application SLOs, and you should share any information you have that’s relevant to how they’re experiencing your system performance. Your goal is that\n\nHow to: SRE with Your Customers\n\n|\n\n395",
      "content_length": 2618,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 428,
      "content": "whenever your customer contacts you because their SLO seems threatened, you shouldn’t have to swap much additional information. All of that information should be in the shared monitoring.\n\nStep 3: Measure and Renegotiate Once you sort the measurements out, you should collect data for a month or two. Be prepared for the likelihood that your customer is in for a rude awakening. The appli‐ cation they thought was operating at “five 9s” (99.999%; everybody thinks they’re get‐ ting five 9s) is probably achieving only 99.5%–99.9% when measured against their shiny new SLOs.\n\nAfter the initial shock wears off, this is a great time to point out that their users aren’t yelling all the time, so they probably never needed the five 9s they haven’t really been getting.\n\nThe key question is, how satisfied are their users with the application’s performance? If their users are happy, and there’s no evidence that improving performance or availability will increase user adoption/retention/usage, then you’re done. You should periodically ask yourself this question to make sure that your budgets and priorities are still correct. (See Chapter 2 for a more in-depth treatment of this topic.)\n\nIf the customer thinks they still need to make things a little better, move on to the next step.\n\nStep 4: Design Reviews and Risk Analysis Sit down with your customer and really understand how their application is designed and operated. Do they have any hidden single point of failures (SPOFs)? Are their rollouts and rollbacks manual? Basically, conduct the same exercise you conduct for your own internal applications.\n\nNext, rank the issues you find by how much of their error budget each item con‐ sumes. (Read more about how to do that on the Google Cloud Platform Blog.) Pay attention to which items your customer chooses to fix in order to “earn back the 9s” they want (e.g., to move from 99.5% to 99.9%).\n\nWhat you learn from these reviews will tell you:\n\nHow your customers consume your platform\n\nWhat reliability mistakes they make when doing so\n\nWhich tradeoffs they choose when trying to improve\n\nThis exercise will also help your customer set realistic expectations around the relia‐ bility they should experience with their current application. Their expectations will\n\n396\n\n|\n\nChapter 19: SRE: Reaching Beyond Your Walls",
      "content_length": 2323,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 429,
      "content": "affect their perceptions, so setting them appropriately can only be helpful in earning and keeping their trust.\n\nStep 5: Practice, Practice, Practice The final step is to create some operational rigor with your customer. Practice simu‐ lated problems (Wheel of Misfortune exercises, disaster and recovery testing, paper game days, etc.).\n\nDevelop a healthy muscle memory between the teams for effective ways to communi‐ cate during a crisis. It’s a great way to build trust, lower the MTTR, and learn about weird operational edge cases that you can integrate as enhancements into your plat‐ form features.\n\nWhen an incident does occur, don’t just share your postmortems with your cus‐ tomer. Actually conduct some joint postmortems. Doing so will also build trust and teach you some invaluable lessons.\n\nBe Thoughtful and Disciplined It will quickly become impossible to carry out these steps with more than a small per‐ centage of your customers. Please don’t try extending this model to everyone. Instead, make some principled decisions about how you will make selections. Here are some common approaches:\n\nRevenue coverage\n\nSelect the minimum number of customers to account for XX% of your revenue. If your revenue is heavily weighted to a few large customers, then this might be the right choice for you.\n\nFeature coverage\n\nSelect the minimum number of customers to cover more than XX% of your plat‐ form features. If you run a highly diverse platform with a long tail of customers doing a lot of different things, then this approach will help you avoid surprises.\n\nWorkload coverage\n\nYour platform’s usage may be dominated by a few distinct use cases or customer types. Perhaps no individual customer in those types is dominant, but you can easily group them into cohorts. In that case, sampling one or two customers from each cohort is a good way to get platform coverage and discover operational dif‐ ferences between the use cases.\n\nWhatever approach you choose, stick to it. Mixing and matching will confuse your stakeholders and quickly overwhelm your team.\n\nHow to: SRE with Your Customers\n\n|\n\n397",
      "content_length": 2108,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 430,
      "content": "Conclusion Over the last few years, the SRE profession and role has spread widely outside the walls of Google. Although we never expected this, we are nonetheless thrilled by it. We might be able to say something credible about how we think the discipline will evolve inside Google, but in the wild—well, that’s an “uncomfortably exciting” prop‐ osition.\n\nOne thing we feel pretty sure about is that as you adopt SRE principles into your organization, you will cross many of the same inflection points we did (and some we have not!)—including the need to blur the lines more between where your customers end and where you start.\n\nEngaging with individual customers at this level of operational depth is a rewarding new frontier for us, and we’re still very much on the path. (You can follow along online at the Google Cloud Platform Blog.) The further we go, however, the more certain we are that this is a journey that you, too, will need to take.\n\n398\n\n|\n\nChapter 19: SRE: Reaching Beyond Your Walls",
      "content_length": 1001,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 431,
      "content": "CHAPTER 20 SRE Team Lifecycles\n\nBy David Ferguson and Prashant Labhane with Shylaja Nukala\n\nThe Preface to this book set a goal to “dispel the idea that SRE is implementable only at ‘Google scale’ or in ‘Google culture.’” This chapter lays out a roadmap for matur‐ ing an SRE organization from unstaffed but aspirational, through various stages of maturity, to a robust and (potentially) globally distributed set of SRE teams. Regard‐ less of where you are in your journey as an SRE organization, this chapter will help you identify strategies for evolving your SRE organization.\n\nWe discuss the SRE principles that need to be in place at each stage of this journey. While your own journey will vary depending on the size, nature, and geographic dis‐ tribution of your organization, the path we describe to successfully apply SRE princi‐ ples and implement SRE practices should be generalizable to many different types of organizations.\n\nSRE Practices Without SREs Even if you don’t have SREs, you can adopt SRE practices by using SLOs. As dis‐ cussed in Chapter 2, SLO are the foundations for SRE practices. As such, they inform our first principle of SRE:\n\nPrinciple #1\n\nSRE needs SLOs with consequences.\n\nThe performance of your service relative to SLOs should guide your business decisions.\n\n399",
      "content_length": 1299,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 432,
      "content": "We believe that the following practices—which you can achieve without even having a single SRE—are the crucial steps toward implementing SRE practices:\n\nAcknowledge that you don’t want 100% reliability.\n\nSet a reasonable SLO target. This SLO should measure the reliability that is most important to your users.\n\nAgree on an error budget policy that will help defend your user experience. Use the error budget to help guide:\n\n— Tactical actions to mitigate outages or to manage changes that return your\n\nsystem to a reliable state\n\n— Longer-term prioritization of work to make the system more reliable and use\n\nless of the error budget\n\nMeasure the SLO and commit to following the error budget policy. This commit‐ ment requires agreement from company leadership.\n\nEven if an organization doesn’t have SRE staff, we believe that it is worthwhile to set SLOs for critical customer applications and to implement an error budget policy, if only because an implicit 100% SLO means a team can only ever be reactive. This SRE principle allows you to make data-informed decisions about how to ensure the relia‐ bility of your application.\n\nStarting an SRE Role\n\nFinding Your First SRE It’s possible that your first SRE employees won’t have explicit experience as an SRE. We’ve found the following areas to be relevant to the SRE role, and therefore appro‐ priate to cover in interviews:\n\nOperations\n\nRunning applications in production gives invaluable insights that cannot be easily gained otherwise.\n\nSoftware engineering\n\nSREs need to understand the software they are supporting, and be empowered to improve it.\n\nMonitoring systems\n\nSRE principles require SLOs that can be measured and accounted for.\n\nProduction automation\n\nScaling operations requires automation.\n\n400\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "content_length": 1799,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 433,
      "content": "System architecture\n\nScaling the application requires good architecture.\n\nYour first SRE will likely occupy a difficult and ambiguous position between velocity and reliability goals. They will need to be resilient and flexible in order to provide the right balance between enabling product development and defending the customer experience.\n\nPlacing Your First SRE Once you’ve hired your first SRE, you now need to decide where to embed them in your organization. You have three main choices:\n\nIn a product development team\n\nIn an operations team\n\nIn a horizontal role, consulting across a number of teams\n\nWe recommend that you evaluate the pros and cons of each of these three options after reading this chapter, taking into account:\n\nYour own role and sphere of influence.\n\nIf you’re able to effectively influence product development team(s), then embed‐ ding an SRE in operations or horizontal work can help iron out gnarly produc‐ tion issues early.\n\nThe immediate challenges that you face.\n\nIf the challenges require hands-on work to mitigate a technical problem or busi‐ ness risk, then embedding an SRE in an operations or product team can be advantageous. Doing so removes organizational silos and facilitates easy commu‐ nication between team members.\n\nThe challenges you expect to face in the next 12 months.\n\nFor example, if you’re focusing on launches, embedding the SRE within a prod‐ uct development team might make sense. If you’re focusing on infrastructure changes, embedding the SRE with an operations team might make more sense.\n\nYour plan for how you want to change your organization.\n\nIf you plan to move toward a centralized SRE organization, you might not want to embed SREs in product development teams initially—it might be hard to remove them from these teams later.\n\nThe person you have identified as your first SRE.\n\nDecide where this first SRE would be most productive based upon their back‐ ground and skills.\n\nStarting an SRE Role\n\n|\n\n401",
      "content_length": 1970,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 434,
      "content": "It might make sense to experiment with different models as you figure out which approach works best for you. However, we strongly recommend sticking with one stable and coherent model in the long term; otherwise, the instability will undermine the effectiveness of SRE.\n\nBootstrapping Your First SRE Your first SRE’s initial mission is to get up to speed on the service. In order to have a positive impact, an SRE needs to understand the service’s current problems, its required toil (see Chapter 6) and the engineering required to keep the system within SLOs. If your organization doesn’t already have SLOs and error budgets as per Prin‐ ciple #1, your first SRE needs to perform the engineering required to design and implement these tools. At this point, our second SRE principle comes into play:\n\nPrinciple #2\n\nSREs must have time to make tomorrow better than today.\n\nWithout this principle, toil will only increase as service usage increases and the sys‐ tem becomes correspondingly larger and more complex. A healthy balance between operational responsibilities and project work is essential—if toil becomes too burden‐ some, talented engineers will flee the team. For more guidance on how an SRE team might obtain that balance, see Chapter 17.\n\nInitial project work might focus on one of the following:\n\nImproving monitoring so you can better understand the system when things go wrong.\n\nAddressing any high-priority actions identified in recent postmortems (see Chapter 10).\n\nImplementing automation to reduce a specific element of toil required to run the service.\n\nIt is vital that the SRE has a distinctive role and that their projects benefit the whole team. Look out for signs that the SRE work is not going well:\n\nTheir mix of work is indistinguishable from other engineering work.\n\nIf your first SRE is on a product development team, they are doing more than their fair share of operational work, or they are the only person working on ser‐ vice configuration changes.\n\n402\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "content_length": 2024,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 435,
      "content": "The SLOs are not being taken seriously, and the SRE isn’t making progress in measuring and defending the customer experience.\n\nDistributed SREs If your organization doesn’t have (or doesn’t plan to have) a discrete SRE team (or teams), it’s important to construct a community for distributed SREs. This commu‐ nity should advocate the SRE’s distinctive role and drive consistent changes in reliability-focused technology or practices across teams. Without a social grouping, individual SREs may feel very isolated.\n\nYour First SRE Team You might start an SRE team in a number of ways. Approaches we’ve used at Google, from least to most complex, include:\n\nCreating a new team as part of a major project\n\nEstablishing a horizontal SRE team\n\nConverting an existing team (for example, an operations team)\n\nThe approach that’s best for your organization is highly situational. A team needs enough SREs to handle the operational tasks required to run the service. Addressing that workload brings us to our third principle:\n\nPrinciple #3\n\nSRE teams have the ability to regulate their workload.\n\nOutside of a large SRE organization, a team likely can’t embrace this concept from day one. This principle is open to interpretation and can be difficult to put into prac‐ tice organizationally. It’s also the most subtle of our three principles, and bears some unpacking. The following sections walk through the stages of building a team, using Tuckman’s performance model and stages of forming, storming, norming, and performing.1\n\n1 Bruce W. Tuckman, “Developmental Sequence in Small Groups,” Psychological Bulletin 63, no. 6 (1965):\n\n384–99.\n\nYour First SRE Team\n\n|\n\n403",
      "content_length": 1662,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 436,
      "content": "Forming The team you assemble should have combined experience and expertise that includes the following:\n\nMaking changes to application software to improve reliability and performance.\n\nWriting software to:\n\n— Expedite the detection and mitigation of problems in production.\n\n— Automate manual processes.\n\nEstablishing and using strong software practices and standards to facilitate long- term maintainability.\n\nHaving a methodical and careful approach to making operational changes: be able to describe why certain practices are reliable.\n\nUnderstanding system architecture (distributed systems design and operation).\n\nIdeally, your team will be ready to adopt a new way of working, and have a balance of skills and established personal relationships with other teams. If possible, we recom‐ mend that you seed the team with internal transfers. This can reduce the time it takes your team to get up and running.\n\nCreating a new team as part of a major project\n\nYou might create a new SRE team for a major project that is large enough to justify new headcount, and for which reliability and operational capability have been identi‐ fied as project risks. Examples might include the creation of a new service or a sub‐ stantial change in your technology (e.g., migration to a public cloud).\n\nAssembling a horizontal SRE team\n\nIn this approach (well documented in Chapter 27 of our first book), a small team of SREs consults across a number of teams. This team might also establish best practices and tools for configuration management, monitoring, and alerting.\n\nConverting a team in place\n\nYou might be able to convert an existing team into an SRE team. The existing team likely isn’t a product development team; typical candidates include an operations team or a team responsible for managing a popular open source component that your organization uses heavily. Be careful to avoid renaming a team from “Operations” to “SRE” without first applying SRE practices and principles! If your rebranding effort fails, your organization may be poisoned against the entire concept of SRE in the future.\n\n404\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "content_length": 2135,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 437,
      "content": "Storming Once assembled, the team needs to start working collaboratively: the team members need to work well with each other, and also with other teams.\n\nYou might employ any number of tactics to promote this type of cohesion. At Goo‐ gle, we’ve had success providing a regular forum for learning and discussing SRE practices and reflecting on how the team is performing. For example, you might hold a regular television lunch, where you show a video from SREcon, or a book club, where you all preread some relevant content and then discuss how you can apply it.\n\nDuring this phase, encourage your new SRE team to stretch themselves. Your new SREs should be comfortable speaking out about SRE practices that don’t fit within your organization, and whether it’s worth making the change so they fit.\n\nRisks and mitigations\n\nDuring this nascent phase of the SRE journey, there are a number of ways the team might fail. Next we present some risks and possible mitigation strategies, broken down by how the new team formed. You might use one or more of the mitigation strategies for each risk.\n\nNew team as part of a major project\n\nRisks\n\nThe team:\n\nSpreads itself too thin by taking responsibility for too many services at once.\n\n— A team that is constantly firefighting doesn’t have time to address risk in\n\na more permanent way.\n\nBecomes too introspective trying to understand SRE principles and how to implement them. As a result, it underdelivers.\n\n— For example, the team might become consumed with developing the per‐ fect SLO definition, neglecting the needs of the service in the meantime.\n\nDoesn’t examine its work thoroughly. As a result, service management reverts to previous behaviors.\n\n— The team is paged 100 times a day. Since the pages don’t indicate that\n\nimmediate intervention is required, they ignore the pages.\n\nAbandons SRE principles and practices in order to meet product milestones.\n\n— Reliability improvements to defend the SLO, such as architectural changes, may never be implemented because they set back development timelines.\n\nYour First SRE Team\n\n|\n\n405",
      "content_length": 2081,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 438,
      "content": "Gets distracted by conflict with existing teams that perceive a loss of influ‐ ence or power as a result of the new SRE team.\n\nDoes not have the necessary breadth of skills, so delivers only part of the necessary improvements.\n\n— Without the ability to, for example, program, SREs may be unable to\n\ninstrument the product to measure reliability.\n\nMitigations\n\nThe team:\n\nEngages initially on a single important service.\n\nEngages as early as possible on the project, ideally at the design stage.\n\nHas input into the design, with a particular focus on defining SLOs and ana‐ lyzing reliability risks inherent in the design.\n\nPartners with the product development team and works on features specific to reliability and integration with existing operational platforms.\n\nIs not expected to have operational responsibility on day one. Instead, this responsibility initially sits with the product development team or project team. This may be a significant cultural change that needs support from management.\n\nHas clear agreement on the conditions that a service must meet to be onboarded by SRE (see Chapter 32 of Site Reliability Engineering).\n\nIn addition:\n\nIf the project involves a migration, the team should have a solid understand‐ ing of the current and future environments. If you need to recruit team members externally, consider candidates who have knowledge of software engineering and the future environment.\n\nContinue to keep the number of new hires to less than a third of the team so that the training effort doesn’t overwhelm existing team members.\n\nHorizontal SRE team\n\nRisks\n\nThe team is perceived as a new “gating” organization that does no real work or adds no real value.\n\nMitigations\n\nThe team:\n\n406\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "content_length": 1751,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 439,
      "content": "Is seeded with respected engineers who have relevant subject matter expertise.\n\nUndertakes project work that focuses on delivering tools (for monitoring, alerting, rollouts, best practices, checklists). These tools should have a short- term beneficial impact on at least two other teams.\n\nCommunicates successes and benefits. An SRE team that makes an efficiency breakthrough, automates away toil, or permanently eliminates a source of system unreliability should be celebrated.\n\nSees themselves as enablers, not gatekeepers. Focus on solutions, not just problems.\n\nA team converted in place\n\nRisks\n\nThe team:\n\nPerceives that the conversion process is the start of a slow journey to job los‐ ses as automation replaces humans.\n\nDoesn’t support the change to an SRE team.\n\nHas no slack capacity they can leverage to change the team’s day-to-day activities.\n\nSees no benefit to their day-to-day routine after a few months.\n\nWorks with systems that do not support scripting or automation.\n\nDoesn’t have the software engineering skills to automate their current workload.\n\nDoesn’t consistently have the skills needed to evolve toward SRE, or an inter‐ est in acquiring the skills.\n\nMitigations\n\nThe team:\n\nSecures senior leadership support for the change.\n\nRenegotiates responsibilities to create the slack needed to effect change.\n\nManages communication of the change very carefully.\n\nHas access to robust personal and technical support throughout the transition.\n\nDeals with the concern about job losses head on. In a lot of environments, automation eliminates portions of work, but not jobs as a whole; while this might be a step on the path to job losses, it does at least have the virtue of\n\nYour First SRE Team\n\n|\n\n407",
      "content_length": 1720,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 440,
      "content": "freeing up time to do something better (and more sellable to a future employer) than nonautomated toil.\n\nCan escape operational overload and have more significant impact. If engi‐ neers reduce the volume of toil enough to necessitate a smaller team, then their experience should be highly reusable elsewhere in your organization. If their experience can’t be used internally, it should provide an advantage in seeking work elsewhere.\n\nReceives training to acquire the skills SREs need. Your product development team can provide product training, while SRE orientation can make use of this book and other external resources.\n\nChanges how performance is evaluated—the metrics that assess both the team and individuals. The former should be aligned with SLOs and adoption of other SRE practices; the latter should be aligned with evidence of SRE skills.\n\nAdds an experienced SRE or developer to the team.\n\nHas the freedom (budget or time) to identify and introduce new open source or cloud-based monitoring and alerting systems to enable automation. Determining whether the existing systems are sufficient should be an early priority.\n\nRegularly reviews progress internally and with stakeholders.\n\nNorming Norming entails working past the issues raised in “Risks and mitigations” on page 405 and reaching broad agreement on best practices for the organization’s SRE teams. Teams need to agree on an acceptable level of toil, appropriate alerting thresh‐ olds, and important and relevant SRE practices. Teams also need to become self- sufficient at proactively identifying the challenges ahead of the service and setting medium- and long-term goals to improve the service.\n\nTeams should reach the following levels of maturity during the norming phase:\n\nSLOs and error budgets are in place, and the error budget policy is exercised fol‐ lowing significant incidents. Leadership is interested in SLO measurements.\n\nOn-call rotations are established and sustainable (see Chapter 8). On-call engi‐ neers are compensated for their on-call time. There is sufficient tooling, docu‐ mentation,2 and training to support any team member during a significant incident.\n\n2 Shylaja Nukala and Vivek Rau, “Why SRE Documents Matter,” ACM Queue (May–June 2018): forthcoming.\n\n408\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "content_length": 2295,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 441,
      "content": "Toil is documented, bounded, and managed. As a result, SREs complete impact‐ ful projects that improve reliability and efficiency.\n\nPostmortem culture is well established. (See Chapter 10.)\n\nThe team exhibits most of the tenets listed in Chapter 1.\n\nAs the team solves initial issues listed in “Storming” on page 405, they capture what they learned and prevent repeating problems. The team regularly runs training exercises, such as Wheel of Misfortune or DiRT (Disaster Recovery Testing). (For more information on on-call training, see Chapter 11 in our first book and Chapter 18 in this book.)\n\nThe product development team benefits from remaining involved in the on-call rotation.\n\nThe team produces regular reports (e.g., quarterly) for their stakeholders that cover the highlights, lowlights, and key metrics of the reporting period.\n\nTransforming an Existing Team into an SRE Team\n\nby Brian Balser, New York Times\n\nWhen the New York Times formed its Delivery and Site Reliability Engineering department, we assembled SRE teams from engineers who had SRE-type skills, such as building tooling and operating production systems. Some teams were “greenfield”: they were designed with SRE in mind with respect to talent, vision, and responsibility. Other teams had existed for several years, and had ended up running production architecture due to a combination of skill sets, interests, and chance.\n\nChallenges\n\nOne of the existing teams transitioning into SRE was in a very challenging position. Over the years, the team had gained ownership and responsibility for managing con‐ figurations, change requests, and operations of a core component of our site-wide architecture. They effectively became a service team supporting all of our product development teams. Their work was driven by tickets and production issues, and they were in a continuous reactive mode. They didn’t have time to make improvements, innovate, or do other higher-value strategic work.\n\nWhile the team had many great ideas, it was overloaded with toil and a number of high-priority “blocker” service requests that were typically tied to product launches. This model was not sustainable, and the team would need to grow linearly with prod‐ ucts to keep up with this support burden. To exacerbate this situation, the small team had a wealth of institutional knowledge that had accumulated over the years. A high volume of interrupts from teams who needed that information compounded the team’s overload, and a bus factor loomed over the team.\n\nYour First SRE Team\n\n|\n\n409",
      "content_length": 2545,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 442,
      "content": "Working from First Principles\n\nOne guiding principle of our SRE organization is to remove ourselves from the criti‐ cal path and to empower product development teams with self-service solutions. With that in mind, our goal became clear: invert the responsibility model to enable the product development teams to push their own changes. This strategy would both:\n\nSpeed up delivery.\n\nFree SREs from managing configuration churn, allowing them to make real improvements to the system as a whole.\n\nProcess Improvement\n\nWe improved our processes through several stages of change:\n\n1. We embedded an SRE in the development team to help relieve pressure.\n\n2. To enable product development teams to take ownership of their service config‐ uration in isolation, we broke out each service configuration into a team-based repo.\n\n3. We migrated each service from the legacy CI system to our standard Drone CI/CD pipeline. The developer-friendly workflow was completely driven by GitHub events.\n\n4. We onboarded each of the product teams to the new tooling and workflow so they could submit their own change requests without being blocked by a service ticket.\n\nWhile these improvements were a big step forward, we hadn’t yet reached our ideal end state. Reviewing pull requests still often required SRE expertise. To make inter‐ rupts for time-consuming reviews more manageable, we scheduled daily office hours. This consistent practice allowed us to batch questions and discussions in a more pre‐ dictive manner, and also provided a venue for sharing knowledge with teams under‐ going onboarding.\n\nEnd Result and Next Steps\n\nThe SRE team is now meeting its initial goal of > 50% project work (versus support- related work). The team still has a wealth of institutional knowledge, but that knowl‐ edge is now being propagated more broadly, gradually improving the bus factor and reducing interrupts.\n\nNow that we have breathing room for project work, our next steps are to focus on adding more advanced capabilities such as canary deploys, better test tooling, and observability and resilience features. Doing so will give product development teams more confidence in exercising full autonomy over their service configurations without depending on SREs for change management.\n\n410\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "content_length": 2304,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 443,
      "content": "Establishing a healthy relationship with your product development team forms the basis of many of these mitigation strategies. Teams should plan work together per your organization’s planning cycle.\n\nBefore moving on to the next step: pause, celebrate this success, and write a retro‐ spective that covers your journey so far.\n\nPerforming The SRE team’s experience with production and work up to this point should have earned the respect and attention of the wider organization, and laid the foundation for strategically moving forward. In the final stage of Tuckman’s performance model, performing, you should expect to:\n\nPartner on all architecture design and change.\n\nFrom the initial design phase onward, SRE should define the patterns for how software is built and structured for reliability.\n\nHave complete workload self-determination.\n\nTeams should consistently apply Principle 3 with a view toward the holistic health of the system.\n\nPartnering on architecture\n\nThe product development team should start to reach out to its partner SRE team for advice on all significant service changes. The SRE team now has the opportunity to have some of its greatest impact.\n\nFor example, the SRE team might provide early input into the design of new service architecture to reduce the likelihood of high-cost reengineering at a later date. The product development and SRE teams can acknowledge their differences in perspec‐ tive on architectural decisions to arrive at a good design process. A successful engage‐ ment can add value through:\n\nImproved reliability, scalability, and operability\n\nBetter reuse of existing patterns\n\nSimpler migration (if required)\n\nSelf-regulating workload\n\nWhereas architectural partnerships should emerge somewhat organically over time, an SRE team must clearly assert Principle #3 to its partners. Doing so requires strong team leadership and clear, upfront commitment from senior management. The abil‐ ity to regulate its own workload secures the SRE team’s position as an engineering\n\nYour First SRE Team\n\n|\n\n411",
      "content_length": 2043,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 444,
      "content": "team that works on the organization’s most important services, equal to its product development team peers.\n\nIn practice, how an SRE team goes about determining its own workload depends on the teams with which SREs interface. At Google, SRE teams most commonly interact with a distinct product development team. In this case, the relationship has the fol‐ lowing characteristics:\n\nAn SRE team chooses if and when to onboard a service (see Chapter 32 of Site Reliability Engineering).\n\nIn the event of operational overload, the team can reduce toil by:\n\n— Reducing the SLO\n\n— Transferring operational work to another team (e.g., a product development\n\nteam)\n\nIf it becomes impossible to operate a service at SLO within agreed toil con‐ straints, the SRE team can hand back the service to the product development team.\n\nSRE engagement is not perpetual—it feeds itself by solving problems at scale and improving the reliability of services. If an SRE team has solved all such problems for a service, you need to either: — Intentionally consider what other reliability challenges the SRE team needs to\n\ntackle.\n\n— Make an intentional decision to hand back the service to the product develop‐\n\nment team.\n\nOtherwise, your team risks attrition as SREs move on to more interesting oppor‐ tunities. The slow bleed from attrition can put production at risk.\n\nNot all SRE teams have partner product development teams. Some SRE teams are also responsible for developing the systems they run. Some SRE teams package third- party software, hardware, or services (e.g., open source packages, network equip‐ ment, something-as-a-service), and turn those assets into internal services. In this case, you don’t have the option to transfer work back to another team. Instead, con‐ sider the following tactics:\n\nIf the service does not conform to its SLO, stop feature-related project work in favor of reliability-focused project work.\n\nIf it becomes impossible to operate a service at SLO within agreed toil con‐ straints, reduce your SLOs—unless management provides more capacity (people or infrastructure) to deal with the situation.\n\n412\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "content_length": 2158,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 445,
      "content": "Making More SRE Teams Once your first SRE team is up and running, you may want to form an additional SRE team. You might do so for one of the following reasons:\n\nService complexity\n\nAs a service gains users and features, it becomes more complex and harder for a single SRE team to support effectively. You might want to split the team into subteams that specialize in parts of the service.\n\nSRE rollout\n\nIf your first SRE team has been successful and made a clear difference, there may be an organizational interest in adopting this approach across more services.\n\nGeographically split\n\nYou want to split the team into two halves in different time zones and move to 12-hour on-call shifts.\n\nWhen you’re creating a new SRE team, we recommend that you do the following:\n\nRead any postmortems written after other teams were established. Identify and repeat what went well and fix and explore alternatives for things that didn’t go well.\n\nSeed the new team with SREs from the existing team—some of your best SREs and highest-potential SREs who can rise to the challenge. In our experience, finding qualified SRE candidates is difficult, so growing a team quickly with new hires often isn’t realistic.\n\nStandardize the framework for establishing teams and onboarding services (see Chapter 18).\n\nMake changes to the on-call responsibilities slowly. For example:\n\n— To avoid a sudden loss of skilled on-call engineers, keep team members on-\n\ncall for their previous team’s systems for a transitional period.\n\n— After the teams split, wait three to six months to split the on-call rotations.\n\nService Complexity\n\nWhere to split\n\nIf a service becomes too complex for a single team to manage, there are a number of ways to split the work. Consider the following options to simplify the cognitive load on team members:\n\nMaking More SRE Teams\n\n|\n\n413",
      "content_length": 1838,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 446,
      "content": "Architectural splits\n\nFor example, compute, storage, and network; frontend and backend; frontend and database; client and server; frontend and pipelines.\n\nLanguage splits\n\nSRE principles are not dependent on programming languages. However, if your SREs are deeply involved in your source code, there may be some benefit in a split along these lines.\n\nLocation splits\n\nIf your organization’s engineering spans multiple offices, you might want to align SRE team placement with application development.\n\nPitfalls\n\nWhen a team splits, sometimes none of the new teams pick up responsibility for a component owned by the original team. To mitigate this risk, you can:\n\nDesignate one team as responsible for everything not covered in the second team’s charter.\n\nAppoint a senior SRE to an overarching technical lead role across both teams.\n\nSRE Rollout If your initial SRE team(s) are successful, your organization may want more of them. We recommend carefully prioritizing the services that receive SRE support. Consider the following points:\n\nPrioritize services for which reliability has a high financial or reputational impact. The higher the impact, the higher the priority.\n\nDefine the minimal viable set of services that need to be up in order for the prod‐ uct to function. Prioritize those services and make sure that other services degrade gracefully.\n\nA service should not be a priority for SRE simply because it’s unreliable. SRE should be applied tactically where it is most relevant for the business. You also don’t want to allow your developers to ignore reliability until after SREs are engaged.\n\nGeographical Splits As described in Chapter 11 of our first book, Google commonly staffs sister SRE teams on different continents. We do this for a number of reasons:\n\n414\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "content_length": 1813,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 447,
      "content": "Service reliability\n\nIf a major incident (e.g., natural disaster) prevents one team from operating, the other team can continue to support a service.\n\nOn-call stress\n\nSplitting the pager rotation into 12-hour shifts allows proper breaks for on-call engineers.\n\nRecruiting and retaining talent\n\nAn on-call shift that overlaps the normal working day broadens the base of engi‐ neers that we can recruit into SRE roles, and underlines the engineering part of our role.\n\nProduction maturity\n\nSplitting service responsibility across two offices tends to lead to an improvement in maturity as the need for documentation, training, and standardization become more important.\n\nIf your organization is lucky enough to already have engineering teams on multiple continents, we recommend staffing multisite SRE teams. It’s possible to have an SRE team in a different office than the development team, but in our experience, coloca‐ tion provides benefits in the form of a healthy and robust interteam dialog. Other‐ wise, it’s harder for SREs to understand how the services evolve or how the technical infrastructure is used, and it’s harder for product developers to be optimistic about infrastructure improvements.\n\nPlacement: How many time zones apart should the teams be?\n\nAssuming you have some choice, time zone separation is an important consideration in deciding where to locate the two teams. Unfortunately, the objectives are mutually exclusive:\n\nMinimizing the number of hours that on-callers have to work outside of normal office hours\n\nMaximizing the overlap time when both teams are online so that they can inter‐ act with each other regularly\n\nThe situation is complicated by Daylight Saving Time.\n\nIn our experience, staffing teams in time zones that are six to eight hours apart works well and avoids 12 a.m. to 6 a.m. on-call shifts. You can use online resources like https://www.timeanddate.com/worldclock/meeting.html to visualize time zone over‐ laps for various locations.\n\nMaking More SRE Teams\n\n|\n\n415",
      "content_length": 2014,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 448,
      "content": "People and projects: Seeding the team\n\nWhen you split a team geographically, the first SRE team in a new office will set the norms for future SRE teams. Your likelihood of success will be much higher if you can identify one or more SREs who are willing to relocate from the original site on a temporary or long-term basis to establish SRE practices and recruit and train the new team. The new team should also undertake a high-value project that fosters collabo‐ ration within the team and requires interaction with their sister team.\n\nParity: Distributing Work Between Offices and Avoiding a “Night Shift”\n\nOften, one of two sister SRE teams is colocated (or at least in the same time zone) with the product development team (we’ll call this “Office 1”). If this is the case, be vigilant to ensure that the team that is not colocated (“Office 2”) doesn’t become a night shift that has little contact with the product development team, takes more than its fair share of toil, or is assigned only the less interesting or impactful projects.\n\nThe workloads of the two offices will have some natural differences:\n\nYour service likely has a daily peak, and one office will be on-call during that peak. As a result, the on-call experience of the two sites will differ.\n\nYour development process will produce new releases with a particular cadence. One office will likely take more of the burden associated with rollouts and rollbacks.\n\nOffice 1 is more likely to be interrupted during their working day by questions from the product development team.\n\nIt’s easier for Office 1 to undertake project work associated with major releases. Conversely, it’s easier for Office 2 to undertake project work decoupled from immediate product goals.\n\nYou can help maintain balance by using the following practices:\n\nBalance the on-call load between offices. Designate a higher percentage of tickets to the office that fields the lower percentage of pages.\n\nAssociate development areas with SRE teams in a particular office. This could be short term (e.g., according to project) or longer term (e.g., according to service). Otherwise, the product development team will likely lean on Office 1, and not effectively engage with SREs in Office 2.\n\nAssign a higher percentage of internal service improvement projects (that are likely to require less involvement with the product development team) to Office 2.\n\nSpread the most interesting and impactful projects fairly between the two offices.\n\nMaintain a similar team size and seniority mix between the two offices.\n\n416\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "content_length": 2585,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 449,
      "content": "Split projects across the two sites to deliberately foster interoffice interactions between SREs. While running a major project from a single office might gain some efficiencies, splitting projects across the two sites both helps spread knowl‐ edge and builds trust between offices.\n\nAllow engineers to travel to the other office regularly. This enables creating bet‐ ter rapport and, hence, willingness to do work for the other side.\n\nPlacement: What about having three shifts?\n\nOur attempts at splitting SRE teams across three sites resulted in various issues:\n\nIt is impossible to have an interoffice production meeting that all SREs can attend (see Chapter 31 of our first book).\n\nIt is harder to ensure parity of knowledge, capability, and operational response across three offices.\n\nIf all on-call duties take place only during office hours, there’s less of an incentive to automate low-level toil and low-value pages. Being the hero that fixes easy problems is fun during office hours. But if it has some amount of personal cost, the motivation to make sure it never happens again is sharp and immediate.\n\nTiming: Should both halves of the team start at the same time?\n\nYou might spin up sister teams using any of the following models:\n\nBoth halves start at the same time.\n\nSet up the site that is colocated with the product development team first. This allows SREs to get involved earlier in the product lifecycle.\n\nSet up the site that is not colocated with the product development team first or, if a service has been in production for some time, the SRE team and the product development team can share the pager.\n\nStart making changes according to where the right people are at the right time.\n\nFinance: Travel budget\n\nIt is very important to create opportunities for high-quality interactions between the two halves of the team. Despite the effectiveness of video conferencing for day-to-day meetings, we’ve found that regular face-to-face interactions go a long way toward facilitating healthy relationships and trust. We recommend that:\n\nEvery SRE, product development manager, and technical lead in Site 1 visit Site 2 annually (at a minimum), and vice versa.\n\nMaking More SRE Teams\n\n|\n\n417",
      "content_length": 2205,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 450,
      "content": "Every SRE in a management or technical leadership role at Site 1 visit Site 2 at least twice a year, and vice versa.\n\nAll SREs convene at least once a year.\n\nLeadership: Joint ownership of a service\n\nIf you have multiple SRE sites, you likely have decision makers in each office. These parties should meet regularly face-to-face and by video conference. Only by establish‐ ing a strong personal relationship can they:\n\nDebate solutions to challenges that the team faces.\n\nResolve differences of opinion and agree on a joint path forward.\n\nAdvocate on behalf of each other’s team (to prevent an “us versus them” mentality).\n\nSupport the health of each other’s team.\n\nSuggested Practices for Running Many Teams New challenges arise as your organization accumulates more SREs and SRE teams. For example, you’ll have to:\n\nEnsure you provide SREs with the career opportunities they need.\n\nEncourage consistency of practices and tooling.\n\nDeal with services that don’t justify a full SRE engagement.\n\nThis section describes a number of the practices that we have adopted at Google to deal with these concerns. Depending on the specifics of your organization, some or many may work for you too.\n\nMission Control Google’s Mission Control program gives engineers from product development teams the opportunity to spend six months embedded in an SRE team. We typically match these engineers to SRE teams working in a distinctly different area from their exper‐ tise. The software engineer is trained in production systems and practices and even‐ tually goes on-call for that service. After six months, some engineers decide to stay in SRE; others return to their old teams with a much better appreciation for the produc‐ tion environment and SRE practices. SRE teams benefit from additional engineering resources and gain valuable insight into gaps and inaccuracies in training material and documentation.\n\n418\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "content_length": 1936,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 451,
      "content": "SRE Exchange Google’s SRE Exchange program lets an SRE spend a week working alongside a dif‐ ferent SRE team. The visiting SRE observes how the host team works and shares practices from their home team that might be useful to the host team. At the end of the exchange, the visiting SRE writes a trip report describing their week, their obser‐ vations, and their recommendations for both teams. This program is useful at Google because our SRE teams are highly specialized.\n\nTraining Training is critical to SRE’s ability to operate systems. While most of this is delivered in-team (see “Training roadmap” on page 150 in Chapter 8), consider establishing a standard training curriculum for all SREs. At Google, all new SREs attend SRE EDU, an immersive weeklong training that introduces key concepts, tooling, and platforms that almost all SREs work with. This provides a baseline level of knowledge across all new SREs, and simplifies team-specific and service-specific training objectives. The SRE EDU team also runs a second series of classes a few months later that covers the common tools and processes that we use for managing major incidents. Our perfor‐ mance management process specifically recognizes SREs who facilitate this training.\n\nHorizontal Projects Because SRE teams are tightly aligned with a set of services, there is a temptation for teams to build proprietary solutions to deal with the challenges they encounter—for example, monitoring, software rollout, and configuration tools. This can lead to sig‐ nificant duplication of efforts across teams. While there is value in allowing a number of solutions to compete for “market” adoption, at some point, it makes sense to con‐ verge upon a standard solution that:\n\nMeets most teams’ requirements\n\nProvides a stable and scalable platform upon which the next layer of innovation can be built\n\nGoogle approaches these efforts by using horizontal teams, which are often staffed by experienced SREs. These horizontal teams build and run a standard solution and partner with other SRE teams to ensure smooth adoption. (For more information on horizontal software development, see “Case Study 2: Common Tooling Adoption in SRE” on page 432 in Chapter 21.)\n\nSRE Mobility Google does its best to ensure that engineers actively want to be part of their respec‐ tive teams. To this end, we make sure that SREs are able to (and aware that they’re\n\nSuggested Practices for Running Many Teams\n\n|\n\n419",
      "content_length": 2456,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 452,
      "content": "able to) transfer between teams. Assuming there are no performance issues, SREs are free to transfer to other SRE teams with open headcount. SREs who also passed our hiring bar for software engineer roles are free to transfer to product development teams (see http://bit.ly/2xyQ4aD).\n\nThis level of mobility is very healthy for individuals and teams for a number of reasons:\n\nEngineers are able to identify and occupy roles of interest.\n\nIf personal circumstances change and on-call responsibilities become impracti‐ cal, SREs can explore opportunities on teams with less demanding on-call duties. They can obtain this information by talking to other teams and reviewing team on-call stats.\n\nSREs who move between teams broaden the experience of the teams they join.\n\nSREs who move between offices help build or maintain cultural consistency between different offices.\n\nSREs are not compelled to work on services that are unhealthy, or for managers who aren’t supportive of their personal development.\n\nThis policy also has the side effect of keeping your SRE managers focused on healthy and happy services and teams.\n\nTravel In addition to the travel required to keep geographically split teams healthy (see the section “Finance: Travel budget” on page 417), consider funding for:\n\nBuilding internal company communities of interest that include SREs from a number of offices. Such groups can largely collaborate via email and video con‐ ferencing, but meet face-to-face at least annually.\n\nAttending and presenting at industry-wide SRE and SRE-related conferences to broaden knowledge, learn how other organizations tackle similar problems, and, hopefully, be inspired and energized.\n\nLaunch Coordination Engineering Teams As described in Chapter 27 of our first book, a Launch Coordination Engineering (LCE) team can apply SRE principles to a broader set of product development teams —teams that build services that don’t require the level of attention that merits SRE engagement. Just like any other SRE team, an LCE team should be actively engaged in automating its daily operations. For example, developing standard tooling and\n\n420\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "content_length": 2173,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 453,
      "content": "frameworks enable product development teams to design, build, and launch their ser‐ vice in a production environment.\n\nProduction Excellence As the number of SRE teams at your organization grows, a number of best practices will emerge. Every SRE team evolves differently, so evaluating them requires senior SREs with insight into multiple teams.\n\nAt Google, we run a regular service review called Production Excellence. On a regular basis, senior SRE leaders review every SRE team, assessing them on a number of stan‐ dard measures (e.g., pager load, error budget usage, project completion, bug closure rates). The review both applauds outstanding performance and provides suggestions for underperforming teams.\n\nExperienced SREs are equipped to evaluate nuanced scenarios. For example, it can be challenging to tease out a drop in project completion rate caused by a team merger or split versus genuine team performance issues. If a team is at risk of becoming over‐ whelmed, the reviewers can and should to use their organizational position to sup‐ port the team’s leadership in rectifying the situation.\n\nSRE Funding and Hiring At Google, we use two practices to make sure that every SRE contributes significant value:\n\nMuch of SRE funding comes from the same source as product development team funding. Similar to testing or security, reliability is a core pillar of product devel‐ opment, and is funded as such.\n\nIn our experience, the supply of SREs is always smaller than the demand for them. This dynamic ensures that we regularly review and prioritize the services that receive SRE support.\n\nIn short, you should have fewer SREs than the organization would like, and only enough SREs to accomplish their specialized work.\n\nAt Google, the ratio of SREs to engineers on product development teams ranges from around 1:5 (e.g., low-level infrastructure services) to around 1:50 (e.g., consumer- facing applications with a large number of microservices built using standard frame‐ works). Many services fall in the middle of this range, at a ratio of around 1:10.\n\nConclusion We believe an organization of any size can implement SRE practices by applying the following three principles:\n\nConclusion\n\n|\n\n421",
      "content_length": 2210,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 454,
      "content": "SRE needs SLOs with consequences.\n\nSREs must have time to make tomorrow better than today.\n\nSRE teams have the ability to regulate their workload.\n\nSince Google started talking publicly about SRE, it has grown from Google-specific production practices into a profession practiced in many companies. These principles have often proven true—both over our years of direct experience at scale, and during our more recent experience of working with our customers to adopt SRE practices. Because we’ve seen these practices work both within and outside of Google, we feel these recommendations should prove useful across a range of organizations of differ‐ ent types and sizes.\n\n422\n\n|\n\nChapter 20: SRE Team Lifecycles",
      "content_length": 711,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 455,
      "content": "CHAPTER 21 Organizational Change Management in SRE\n\nBy Alex Bramley, Ben Lutch, Michelle Duffy, and Nir Tarcic with Betsy Beyer\n\nIn the introduction to the first SRE Book, Ben Treynor Sloss describes SRE teams as “characterized by both rapid innovation and a large acceptance of change,” and speci‐ fies organizational change management as a core responsibility of an SRE team. This chapter examines how theory can apply in practice across SRE teams. After reviewing some key change management theories, we explore two case studies that demonstrate how different styles of change management have played out in concrete ways at Goo‐ gle.\n\nNote that the term change management has two interpretations: organizational change management and change control. This chapter examines change management as a collective term for all approaches to preparing and supporting individuals, teams, and business units in making organizational change. We do not discuss this term within a project management context, where it may be used to refer to change control processes, such as change review or versioning.\n\nSRE Embraces Change More than 2,000 years ago, the Greek philosopher Heraclitus claimed change is the only constant. This axiom still holds true today—especially in regards to technology, and particularly in rapidly evolving internet and cloud sectors.\n\nProduct teams exist to build products, ship features, and delight customers. At Goo‐ gle, most change is fast-paced, following a “launch and iterate” approach. Executing on such change typically requires coordination across systems, products, and globally distributed teams. Site Reliability Engineers are frequently in the middle of this com‐ plicated and rapidly shifting landscape, responsible for balancing the risks inherent in\n\n423",
      "content_length": 1786,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 456,
      "content": "change with product reliability and availability. Error budgets (see Chapter 2) are a primary mechanism for achieving this balance.\n\nIntroduction to Change Management Change management as an area of study and practice has grown since foundational work in the field by Kurt Lewin in the 1940s. Theories primarily focus on developing frameworks for managing organizational change. In-depth analysis of particular the‐ ories is beyond the scope of this book, but to contextualize them within the realm of SRE, we briefly describe some common theories and how each might be applicable in an SRE-type organization. While the formal processes implicit in these theoretical frameworks have not been applied by SRE at Google, considering SRE activities through the lens of these frameworks has helped us refine our approach to managing change. Following this discussion, we will introduce some case studies that demon‐ strate how elements of some of these theories apply to change management activities led by Google SRE.\n\nLewin’s Three-Stage Model Kurt Lewin’s “unfreeze–change–freeze” model for managing change is the oldest of the relevant theories in this field. This simple three-stage model is a tool for manag‐ ing process review and the resulting changes in group dynamics. Stage 1 entails per‐ suading a group that change is necessary. Once they are amenable to the idea of change, Stage 2 executes that change. Finally, when the change is broadly complete, Stage 3 institutionalizes the new patterns of behavior and thought. The model’s core principle posits the group as the primary dynamic instrument, arguing that individ‐ ual and group interactions should be examined as a system when the group is plan‐ ning, executing, and completing any period of change. Accordingly, Lewin’s work is most useful for planning organizational change at the macro level.\n\nMcKinsey’s 7-S Model McKinsey’s seven S’s stand for structure, strategy, systems, skills, style, staff, and shared values. Similar to Lewin’s work, this framework is also a toolset for planned organizational change. While Lewin’s framework is generic, 7-S has an explicit goal of improving organizational effectiveness. Application of both theories begins with an analysis of current purpose and processes. However, 7-S also explicitly covers both business elements (structure, strategy, systems) and people-management elements (shared values, skills, style, staff). This model could be useful for a team considering change from a traditional systems administration focus to the more holistic Site Reli‐ ability Engineering approach.\n\n424\n\n|\n\nChapter 21: Organizational Change Management in SRE",
      "content_length": 2655,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 457,
      "content": "Kotter’s Eight-Step Process for Leading Change Time magazine named John P. Kotter’s 1996 book Leading Change (Harvard Busi‐ ness School Press) one of the Top 25 Most Influential Business Management Books of all time. Figure 21-1 depicts the eight steps in Kotter’s change management process.\n\nFigure 21-1. Kotter’s model of change management (source: https://www.kotterinc.com/ 8-steps-process-for-leading-change/)\n\nKotter’s process is particularly relevant to SRE teams and organizations, with one small exception: in many cases (e.g., the upcoming Waze case study), there’s no need to create a sense of urgency. SRE teams supporting products and systems with accel‐ erating growth are frequently faced with urgent scaling, reliability, and operational challenges. The component systems are often owned by multiple development teams, which may span several organizational units; scaling issues may also require coordi‐ nation with teams ranging from physical infrastructure to product management. Because SRE is often on the front line when problems occur, it is uniquely motivated to lead the change needed to ensure products are available 24/7/365. Much of SRE work (implicitly) embraces Kotter’s process to ensure the continued availability of supported products.\n\nThe Prosci ADKAR Model The Prosci ADKAR model focuses on balancing both the business and people aspects of change management. ADKAR is an acronym for the goals individuals must ach‐\n\nIntroduction to Change Management\n\n|\n\n425",
      "content_length": 1493,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 458,
      "content": "ieve for successful organizational change: awareness, desire, knowledge, ability, and reinforcement.\n\nIn principle, ADKAR provides a useful, thoughtful, people-centric framework. How‐ ever, its applicability to SRE is limited because operational responsibilities quite often impose considerable time constraints. Proceeding iteratively through ADKAR’s stages and providing the necessary training or coaching requires pacing and invest‐ ment in communication, which are difficult to implement in the context of globally distributed, operationally focused teams. That said, Google has successfully used ADKAR-style processes for introducing and building support for high-level changes —for example, introducing global organizational change to the SRE management team while preserving local autonomy for implementation details.\n\nEmotion-Based Models The Bridges Transition Model describes people’s emotional reactions to change. While a useful management tool for people managers, it’s not a framework or process for change management. Similarly, the Kübler-Ross Change Curve describes ranges of emotions people may feel when faced with change. Developed from Elisabeth Kübler-Ross’s research on death and dying,1 it has been applied to understanding and anticipating employee reactions to organizational change. Both models can be useful in maintaining high employee productivity throughout periods of change, since unhappy people are rarely productive.\n\nThe Deming Cycle Also known as the Plan-Do-Check-Act (or PDCA) Cycle, this process from statisti‐ cian Edward W. Deming is commonly used in DevOps environments for process improvements—for example, adoption of continuous integration/continuous deliv‐ ery techniques. It is not suited to organizational change management because it does not cover the human side of change, including motivations and leadership styles. Deming’s focus is to take existing processes (mechanical, automated, or workflow) and cyclically apply continuous improvements. The case studies we refer to in this chapter deal with larger, organizational changes where iteration is counterproductive: frequent, wrenching org-chart changes can sap employee confidence and negatively impact company culture.\n\n1 Elisabeth Kübler-Ross, On Death and Dying: What the Dying Have to Teach Doctors, Nurses, Clergy and Their\n\nOwn Families (New York: Scribner, 1969).\n\n426\n\n|\n\nChapter 21: Organizational Change Management in SRE",
      "content_length": 2438,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 459,
      "content": "How These Theories Apply to SRE No change management model is universally applicable to every situation, so it’s not surprising that Google SRE hasn’t exclusively standardized on one model. That said, here’s how we like to think about applying these models to common change manage‐ ment scenarios in SRE:\n\nKotter’s Eight-Step Process is a change management model for SRE teams who necessarily embrace change as a core responsibility.\n\nThe Prosci ADKAR model is a framework that SRE management may want to consider to coordinate change across globally distributed teams.\n\nAll individual SRE managers will benefit from familiarity with both the Bridges Transition Model and the Kübler-Ross Change Curve, which provide tools to sup‐ port employees in times of organizational change.\n\nNow that we’ve introduced the theories, let’s look at two case studies that show how change management has played out at Google.\n\nCase Study 1: Scaling Waze—From Ad Hoc to Planned Change\n\nBackground Waze is a community-based navigation app acquired by Google in 2013. After the acquisition, Waze entered a period of significant growth in active users, engineering staff, and computing infrastructure, but continued to operate relatively autono‐ mously within Google. The growth introduced many challenges, both technical and organizational.\n\nWaze’s autonomy and startup ethos led them to meet these challenges with a grass‐ roots technical response from small groups of engineers, rather than management- led, structured organizational change as implied by the formal models discussed in the previous section. Nevertheless, their approach to propagating changes through‐ out the organization and infrastructure significantly resembles Kotter’s model of change management. This case study examines how Kotter’s process (which we apply retroactively) aptly describes a sequence of technical and organizational challenges Waze faced as they grew post-acquisition.\n\nThe Messaging Queue: Replacing a System While Maintaining Reliability Kotter’s model begins the cycle of change with a sense of urgency. Waze’s SRE team needed to act quickly and decisively when the reliability of Waze’s message queueing\n\nCase Study 1: Scaling Waze—From Ad Hoc to Planned Change\n\n|\n\n427",
      "content_length": 2246,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 460,
      "content": "system regressed badly, leading to increasingly frequent and severe outages. As shown in Figure 21-2, the message queueing system was critical to operations because every component of Waze (real time, geocoding, routing, etc.) used it to communi‐ cate with other components internally.\n\nFigure 21-2. Communication paths between Waze components\n\nAs throughput on the message queue grew significantly, the system simply couldn’t cope with the ever-increasing demands. SREs needed to manually intervene to pre‐ serve system stability at shorter and shorter intervals. At its worst, the entire Waze SRE team spent most of a two-week period firefighting 24/7, eventually resorting to restarting some components of the message queue hourly to keep messages flowing and tens of millions of users happy.\n\nBecause SRE was also responsible for building and releasing all of Waze’s software, this operational load had a noticeable impact on feature velocity—when SREs spent all of their time fighting fires, they hardly had time to support new feature rollouts. By highlighting the severity of the situation, engineers convinced Waze’s leadership to reevaluate priorities and dedicate some engineering time to reliability work. A guiding coalition of two SREs and a senior engineer came together to form a strategic vision of a future where SRE toil was no longer necessary to keep messages flowing. This small team evaluated off-the-shelf message queue products, but quickly decided that they could only meet Waze’s scaling and reliability requirements with a custom- built solution.\n\n428\n\n|\n\nChapter 21: Organizational Change Management in SRE",
      "content_length": 1634,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 461,
      "content": "Developing this message queue in-house would be impossible without some way to maintain operations in the meantime. The coalition removed this barrier to action by enlisting a volunteer army of developers from the teams who used the current mes‐ saging queue. Each team reviewed the codebase for their service to identify ways to cut the volume of messages they published. Trimming unnecessary messages and rolling out a compression layer on top of the old queue reduced some load on the system. The team also gained some more operational breathing room by building a dedicated messaging queue for one particular component that was responsible for over 30% of system traffic. These measures yielded enough of a temporary opera‐ tional reprieve to allow for a two-month window to assemble and test a prototype of the new messaging system.\n\nMigrating a message queue system that handles tens of thousands of messages per second is a daunting task even without the pressure of imminent service meltdown. But gradually reducing the load on the old system would relieve some of this pres‐ sure, affording the team a longer time window to complete the migration. To this end, Waze SRE rebuilt the client libraries for the message queue so they could publish and receive messages using either or both systems, using a centralized control surface to switch the traffic over.\n\nOnce the new system was proven to work, SRE began the first phase of the migration: they identified some low-traffic, high-importance message flows for which messaging outages were catastrophic. For these flows, writing to both messaging systems would provide a backup path. A couple of near misses, where the backup path kept core Waze services operating while the old system faltered, provided the short-term wins that justified the initial investment.\n\nMass migration to the new system required SRE to work closely with the teams who use it. The team needed to figure out both how to best support their use cases and how to coordinate the traffic switch. As the SRE team automated the process of migrating traffic and the new system supported more use cases by default, the rate of migrations accelerated significantly.\n\nKotter’s change management process ends with instituting change. Eventually, with enough momentum behind the adoption of the new system, the SRE team could declare the old system deprecated and no longer supported. They migrated the last stragglers a few quarters later. Today, the new system handles more than 1000 times the load of the previous one, and requires little manual intervention from SREs for ongoing support and maintenance.\n\nThe Next Cycle of Change: Improving the Deployment Process The process of change as a cycle was one of Kotter’s key insights. The cyclical nature of meaningful change is particularly apparent when it comes to the types of technical changes that face SRE. Eliminating one bottleneck in a system often highlights\n\nCase Study 1: Scaling Waze—From Ad Hoc to Planned Change\n\n|\n\n429",
      "content_length": 3008,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 462,
      "content": "another one. As each change cycle is completed, the resulting improvements, stand‐ ardization, and automation free up engineering time. Engineering teams now have the space to more closely examine their systems and identify more pain points, trig‐ gering the next cycle of change.\n\nWhen Waze SRE could finally take a step back from firefighting problems related to the messaging system, a new bottleneck emerged, bringing with it a renewed sense of urgency: SRE’s sole ownership of releases was noticeably and seriously hindering development velocity. The manual nature of releases required a significant amount of SRE time. To exacerbate an already suboptimal situation, system components were large, and because releases were costly, they were relatively infrequent. As a result, each release represented a large delta, significantly increasing the possibility that a major defect would necessitate a rollback.\n\nImprovements toward a better release process happened incrementally, as Waze SRE didn’t have a master plan from square one. To slim down system components so the team could iterate each more rapidly, one of the senior Waze developers created a framework for building microservices. This provided a standard “batteries included” platform that made it easy for the engineering organization to start breaking their components apart. SRE worked with this developer to include some reliability- focused features—for example, a common control surface and a set of behaviors that were amenable to automation. As a result, SRE could develop a suite of tools to man‐ age the previously costly parts of the release process. One of these tools incentivized adoption by bundling all of the steps needed to create a new microservice with the framework.\n\nThese tools were quick-and-dirty at first—the initial prototypes were built by one SRE over the course of several days. As the team cleaved more microservices from their parent components, the value of the SRE-developed tools quickly became appa‐ rent to the wider organization. SRE was spending less time shepherding the slimmed- down components into production, and the new microservices were much less costly to release individually.\n\nWhile the release process was already much improved, the proliferation of new microservices meant that SRE’s overall burden was still concerning. Engineering leadership was unwilling to assume responsibility for the release process until releases were less burdensome.\n\nIn response, a small coalition of SREs and developers sketched out a strategic vision to shift to a continuous deployment strategy using Spinnaker, an open source, multi‐ cloud, continuous delivery platform for building and executing deployment work‐ flows. With the time saved by our bootstrap tooling, the team now was able to engineer this new system to enable one-click builds and deployments of hundreds or thousands of microservices. The new system was technically superior to the previous system in every way, but SRE still couldn’t persuade development teams to make the\n\n430\n\n|\n\nChapter 21: Organizational Change Management in SRE",
      "content_length": 3102,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 463,
      "content": "switch. This reluctance was driven by two factors: the obvious disincentive of having to push their own releases to production, plus change aversion driven by poor visibil‐ ity into the release process.\n\nWaze SRE tore down these barriers to adoption by showing how the new process added value. The team built a centralized dashboard that displayed the release status of binaries and a number of standard metrics exported by the microservice frame‐ work. Development teams could easily link their releases to changes in those metrics, which gave them confidence that deployments were successful. SRE worked closely with a few volunteer systems-oriented development teams to move services to Spin‐ naker. These wins proved that the new system could not only fulfill its requirements, but also add value beyond the original release process. At this point, engineering leadership set a goal for all teams to perform releases using the new Spinnaker deployment pipelines.\n\nTo facilitate the migration, Waze SRE provided organization-wide Spinnaker training sessions and consulting sessions for teams with complex requirements. When early adopters became familiar with the new system, their positive experiences sparked a chain reaction of accelerating adoption. They found the new process faster and less painful than waiting for SRE to push their releases. Now, engineers began to put pres‐ sure on dependencies that had not moved, as they were the impediment to faster development velocity—not the SRE team!\n\nToday, more than 95% of Waze’s services use Spinnaker for continuous deployment, and changes can be pushed to production with very little human involvement. While Spinnaker isn’t a one-size-fits-all solution, configuring a release pipeline is trivial if a new service is built using the microservices framework, so new services have a strong incentive to standardize on this solution.\n\nLessons Learned Waze’s experience in removing bottlenecks to technical change contains a number of useful lessons for other teams attempting engineering-led technical or organizational change. To begin with, change management theory is not a waste of time! Viewing this development and migration process through the lens of Kotter’s process demon‐ strates the model’s applicability. A more formal application of Kotter’s model at the time could have helped streamline and guide the process of change.\n\nChange instigated from the grass roots requires close collaboration between SRE and development, as well as support from executive leadership. Creating a small, focused group with members from all parts of the organization—SRE, developers, and man‐ agement—was key to the team’s success. A similar collaboration was vital to institut‐ ing the change. Over time, these ad hoc groups can and should evolve into more formal and structured cooperation, where SREs are automatically involved in design\n\nCase Study 1: Scaling Waze—From Ad Hoc to Planned Change\n\n|\n\n431",
      "content_length": 2956,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 464,
      "content": "discussions and can advise on best practices for building and deploying robust appli‐ cations in a production environment throughout the entire product lifecycle.\n\nIncremental change is much easier to manage. Jumping straight to the “perfect” solu‐ tion is too large a step to take all at once (not to mention probably infeasible if your system is about to collapse), and the concept of “perfect” will likely evolve as new information comes to light during the change process. An iterative approach can demonstrate early wins that help an organization buy into the vision of change and justify further investment. On the other hand, if early iterations don’t demonstrate value, you’ll waste less time and fewer resources when you inevitably abandon the change. Because incremental change doesn’t happen all at once, having a master plan is invaluable. Describe the goals in broad terms, be flexible, and ensure that each iter‐ ation moves toward them.\n\nFinally, sometimes your current solutions can’t support the requirements of your strategic vision. Building something new has a large engineering cost, but can be worthwhile if the project pushes you out of a local maxima and enables long-term growth. As a thought experiment, figure out where bottlenecks might arise in your systems and tooling as your business and organization grow over the next few years. If you suspect any elements don’t scale horizontally, or have superlinear (or worse, exponential) growth with respect to a core business metric such as daily active users, you may need to consider redesigning or replacing them.\n\nWaze’s development of a new in-house message queue system shows that it is possi‐ ble for small groups of determined engineers to institute change that moves the nee‐ dle toward greater service reliability. Mapping Kotter’s model onto the change shows that some consideration of change management strategy can help provide a formula for success even in small, engineering-led organizations. And, as the next case study also demonstrates, when changes promote standardizing technology and processes, the organization as a whole can reap considerable efficiency gains.\n\nCase Study 2: Common Tooling Adoption in SRE\n\nBackground SREs are opinionated about the software they can and should use to manage produc‐ tion. Years of experience, observing what goes well and what doesn’t, and examining the past through the lens of the postmortem, have given SREs a deep background coupled with strong instincts. Specifying, building, and implementing software to automate this year’s job away is a core value in SRE. In particular, Google SRE recently focused our efforts on horizontal software. Adoption of the same solution by a critical mass of users and developers creates a virtuous cycle and reduces reinven‐ tion of wheels. Teams who otherwise might not interact share practices and policies that are automated using the same software.\n\n432\n\n|\n\nChapter 21: Organizational Change Management in SRE",
      "content_length": 2984,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 465,
      "content": "This case study is based on an organizational evolution, not a response to a systems scaling or reliability issue (as discussed in the Waze case study). Hence, the Prosci ADKAR model (shown in Figure 21-3) is a better fit than Kotter’s model, as it recog‐ nizes both explicit organizational/people management characteristics and technical considerations during the change.\n\nFigure 21-3. Prosci ADKAR model of change management\n\nProblem Statement A few years ago, Google SRE found itself using multiple independent software solu‐ tions for approximately the same problem across multiple problem spaces: monitor‐ ing, releases and rollouts, incident response, capacity management, and so on.\n\nThis end state arose in part because the people building tools for SRE were dissoci‐ ated from their users and their requirements. The tool developers didn’t always have a current view of the problem statement or the overall production landscape—the production environment changes very rapidly and in new ways as new software, hardware, and use cases are brought to life almost daily. Additionally, the consumers of tools were varied, sometimes with orthogonal needs (“this rollout has to be fast; approximate is fine” versus “this rollout has to be 100% correct; okay for it to go slowly”).\n\nAs a result, none of these long-term projects fully addressed anyone’s needs, and each was characterized by varying levels of development effort, feature completeness, and ongoing support. Those waiting for the big use case—a nonspecific, singing-and- dancing solution of the future—waited a long time, got frustrated, and used their own\n\nCase Study 2: Common Tooling Adoption in SRE\n\n|\n\n433",
      "content_length": 1675,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 466,
      "content": "software engineering skills to create their own niche solution. Those who had smaller, specific needs were loath to adopt a broader solution that wasn’t as tailored to them. The long-term, technical, and organizational benefits of more universal sol‐ utions were clear, but customers, services, and teams were not staffed or rewarded for waiting. To compound this scenario, requirements of both large and small customer teams changed over time.\n\nWhat We Decided to Do To scope this scenario as one concrete problem space, we asked ourselves: What if all Google SREs could use a common monitoring engine and set of dashboards, which were easy to use and supported a wide variety of use cases without requiring customi‐ zation?\n\nLikewise, we could extend this model of thinking to releases and rollouts, incident response, capacity management, and beyond. If the initial configuration of a product captured a wide representation of approaches to address the majority of our func‐ tional needs, our general and well-informed solutions would become inevitable over time. At some point, the critical mass of engineers who interact with production would outgrow whatever solution they were using and self-select to migrate to a com‐ mon, well-supported set of tools and automation, abandoning their custom-built tools and their associated maintenance costs.\n\nSRE at Google is fortunate that many of its engineers have software engineering back‐ grounds and experience. It seemed like a natural first step to encourage engineers who were experts and opinionated about specific problems—from load balancing to rollout tooling to incident management and response—to work as a virtual team, self-selected by a common long-term vision. These engineers would translate their vision into working, real software that would eventually be adopted across all of SRE, and then all of Google, as the basic functions of production.\n\nTo return to the ADKAR model for change management, the steps discussed so far— identifying a problem and acknowledging an opportunity—are textbook examples of ADKAR’s initiating awareness step. The Google SRE leadership team agreed on the need (desire) and had sufficient knowledge and ability to move to designing solutions fairly quickly.\n\nDesign Our first task was to converge upon a number of topics that we agreed were central, and that would benefit greatly from a consistent vision: to deliver solutions and adop‐ tion plans that fit most use cases. Starting from a list of 65+ proposed projects, we spent multiple months collecting customer requirements, verifying roadmaps, and performing market analysis, ultimately scoping our efforts toward a handful of vetted topics.\n\n434\n\n|\n\nChapter 21: Organizational Change Management in SRE",
      "content_length": 2755,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 467,
      "content": "Our initial design created a virtual team of SRE experts around these topics. This vir‐ tual team would contribute a significant percentage of their time, around 80%, to these horizontal projects. The idea behind 80% time and a virtual team was to ensure we did not design or build solutions without constant contact with production. How‐ ever, we (maybe predictably) discovered a few pain points with this approach:\n\nCoordinating a virtual team—whose focus was broken by being on-call regularly, across multiple time zones—was very difficult. There was a lot of state to be swapped between running a service and building a serious piece of software.\n\nEverything from gathering consensus to code reviews was affected by the lack of a central location and common time.\n\nHeadcount for horizontal projects initially had to come from existing teams, who now had fewer engineering resources to tackle their own projects. Even at Goo‐ gle, there’s tension between delegating headcount to support the system as is ver‐ sus delegating headcount to build future-looking infrastructure.\n\nWith enough data in hand, we realized we needed to redesign our approach, and set‐ tled on the more familiar centralized model. Most significantly, we removed the requirement that team members split their time 80/20 between project work and on- call duties. Most SRE software development is now done by small groups of senior engineers with plenty of on-call experience, but who are heads-down focused on building software based on those experiences. We also physically centralized many of these teams by recruiting or moving engineers. Small group (6–10 people) develop‐ ment is simply more efficient within one room (however, this argument doesn’t apply to all groups—for example, remote SRE teams). We can still meet our goal of collecting requirements and perspectives across the entire Google engineering orga‐ nization via videoconference, email, and good old-fashioned travel.\n\nSo our evolution of design actually ended up in a familiar place—small, agile, mostly local, fast-moving teams—but with the added emphasis on selecting and building automation and tools for adoption by 60% of Google engineers (the figure we deci‐ ded was a reasonable interpretation of the goal of “almost everyone at Google”). Suc‐ cess means most of Google is using what SRE has built to manage their production environment.\n\nThe ADKAR model maps the implementation phase of the change project between the people-centric stages of knowledge and ability. This case study bears out that mapping. We had many engaged, talented, and knowledgeable engineers, but we were asking people who had been focused on SRE concerns to act like product soft‐ ware development engineers by focusing on customer requirements, product road‐ maps, and delivery commitments. We needed to revisit the implementation of this change to enable engineers to demonstrate their abilities with respect to these new attributes.\n\nCase Study 2: Common Tooling Adoption in SRE\n\n|\n\n435",
      "content_length": 3016,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 468,
      "content": "Implementation: Monitoring To return to the monitoring space mentioned in the previous section, Chapter 31 in the first SRE book described how Viceroy—Google SRE’s effort to create a single monitoring dashboard solution suitable for everyone—addressed the problem of dis‐ parate custom solutions. Several SRE teams worked together to create and run the initial iteration, and as Viceroy grew to become the de facto monitoring and dash‐ boarding solution at Google, a dedicated centralized SRE development team assumed ownership of the project.\n\nBut even when the Viceroy framework united SRE under a common framework, there was a lot of duplicated effort as teams built complex custom dashboards specific to their services. While Viceroy provided a standard hosted method to design and build visual displays of data, it still required each team to decide what data to display and how to organize it.\n\nThe now-centralized software development team began a second parallel effort to provide common dashboards, building an opinionated zero-config system on top of the lower-level “custom” system. This zero-config system provided a standard set of comprehensive monitoring displays based on the assumption that a given service was organized in one of a handful of popular styles. Over time, most services migrated to using these standard dashboards instead of investing in custom layouts. Very large, unique, or otherwise special services can still deploy custom views in the hosted sys‐ tem if they need to.\n\nReturning to the ADKAR model, the consolidation of monitoring tools at Google began as a grassroots effort, and the resulting improvements in operational efficien‐ cies provided a quantifiable basis (awareness and desire) to initiate a broader effort: SRE self-funded a software development team to build production management tool‐ ing for all of Google.\n\nLessons Learned Designing a migration of interdependent pieces is often more complicated than a blank-sheet design. But in real life, the hardest engineering work ends up being the evolution of many small/constrained systems into fewer, more general systems— without disturbing already running services that many customers depend on. In the meantime, alongside the existing systems, new small systems are added—some of which eventually surprise us by growing into large systems. There is an intellectual attraction to starting anew with the big design, only backing into constraints that are really necessary, but the migration of systems and teams turns out to be the most dif‐ ficult work by far.\n\nDesigning horizontal software requires a lot of listening to prospective end users, and, in many ways, the tasks of building and adoption look much like the role of a\n\n436\n\n|\n\nChapter 21: Organizational Change Management in SRE",
      "content_length": 2791,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 469,
      "content": "product manager. In order for this effort to achieve success, we had to make sure that we absorbed and prioritized priorities. Meeting customer needs—of both SREs and other production users—was also a critical element of success. It is important to acknowledge that the move toward common tooling is still a work in progress. We iterated on the structure and staffing of the teams building our shared technologies to better enable meeting customer needs, and we added product management and user experience talent (addressing missing knowledge).\n\nIn the past year or two, we have seen uptake of these SRE-designed and -built prod‐ ucts across a broad swath of teams at Google. We have learned that to achieve suc‐ cess, the cost of migration (from older, fragmented but specialized solutions) needs to be small relative to the net benefits of the new common solution. Otherwise, the migration itself becomes a barrier to adoption. We continue to work with the indi‐ vidual teams building these products to reinforce the behaviors needed to delight cus‐ tomers with the common solutions the teams are delivering.\n\nOne common theme we discovered across horizontal software development projects was that no matter how good new software and products were, the cost of migration —away from something that was already working to something new—was always perceived as very high. Despite the allure of easier management and less specific deep knowledge, the costs of migrating away from the familiar (with all its warts and toil) were generally a barrier. In addition, individual engineers often had a similar internal monologue: “I’m not improving or changing the system; I’m swapping out one work‐ ing piece for another working piece.” ADKAR describes this resistance as the “knowledge-to-ability gap.” On the human side, in order to recognize and embrace change, people need time, coaching, and training in new tools and skills. On the tech‐ nical side, implementing change requires understanding adoption costs and includ‐ ing work to minimize these costs as part of the launch process.\n\nAs a result, migration costs need to be nearly zero (“just recompile and you pick up new $thing”) and the benefits need to be clear (“now you’re protected from $foo vul‐ nerability”) to the team, to individuals, and to the company.\n\nSRE commonly used to build products that we committed to in a “best effort” way, meaning that the amount of time we gave the product fit into the cracks between everything else we were doing (managing primary services, capacity planning, deal‐ ing with outages, etc.). As a result, our execution was not very reliable; it was impos‐ sible to predict when a feature or service would be available. By extension, consumers of our products had less trust in the end result since it felt perpetually delayed and was staffed by a rotating cast of product managers and individual engineers. When individual SREs or SRE teams built tools for their own use, the focus was on solving individual problems to reduce the cost of maintaining SLOs for supported systems. In endeavoring to build common tooling for most use cases at Google, we needed to shift the focus to measuring the success of this effort in terms of product adoption.\n\nCase Study 2: Common Tooling Adoption in SRE\n\n|\n\n437",
      "content_length": 3294,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 470,
      "content": "Owing to both our organizational culture and our wealth of resources, we approached this project in a bottom-up, rather than top-down, fashion. Instead of mandating that users migrated to our new monitoring system, we sought to win over users by demonstrating that our new offering was better than existing solutions.\n\nOver time, we learned that how we conducted our development process would inform how potential internal users perceived the end result. These projects gained real traction only when staffed by production-experienced engineers 100% dedicated to building software, with schedules and support identical to the rest of Google’s soft‐ ware development. Building common software transparently, like clockwork, with great communication (“We’ll have X done by Y date”), greatly improved the speed of migration to the new system. People already trusted the new system because they could observe how it was developed from an early stage. Perceptions of how the saus‐ age is made turned out to be more important than we anticipated from the get-go. Our initial thought that “if you build something great, people will naturally flock to it” didn’t hold true. Rather, these projects had to be clearly defined, well advertised in advance, evaluated against a multitude of user cases (targeted to the grumpiest adopt‐ ers first), leaps and bounds better than existing options, and adoptable with little to no effort.\n\nThe more consumers you have for common tooling and adoption, the more time you actually have to spend doing things other than writing code. This may sound obvious in retrospect, but clear end goals, believable dates, regular updates, and constant con‐ tact with consumers is paramount. Often skeptical consumers will ask, “If my current one-off shell script works okay, do I really need this?” Adoption of common software or processes is analogous to reliability as a feature—you may build the best thing in the world, but if people don’t adopt it (or can’t use it if it’s not reliable), it’s not useful to anyone. Having a plan for adoption—from champions to beta testers to executive sponsors to dedicated engineers who understand the importance of minimizing bar‐ riers to adoption—is both the end goal and the starting point when it comes to build‐ ing and adopting common tools and practices.\n\nThis is because adoption drives a network effect: as the scale and reach of common software tools increases, incremental improvements to those tools are more valuable to the organization. As the value of the tools increases, development effort dedicated to them also tends to increase. Some of this development effort naturally goes toward further reducing migration costs, incentivizing greater adoption. Broad adoption encourages building organization-wide improvements in a consistent, product-like fashion, and justifies staffing full teams to support the tools for the long term. These tools should be characterized by rapid development, feature stability, common con‐ trol surfaces, and automatable APIs.\n\nWhen it comes to measuring the impact of such efforts, we can ask questions similar to the following:\n\n438\n\n|\n\nChapter 21: Organizational Change Management in SRE",
      "content_length": 3195,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 471,
      "content": "How quickly can a new product developer build and manage a world-scale service?\n\nEnabled by common tools and practices, how easily can an SRE in one domain move to another domain?\n\nHow many services can be managed with the same primitives, as end-to-end user experiences versus separate services?\n\nThese are all possible and highly valuable ways to measure impact, but our first meas‐ urement must be adoption.\n\nConclusion As demonstrated by the Waze and horizontal software case studies, even within a sin‐ gle company, SRE change management may need to tackle a variety of problem spaces and organizational context. As a result, there’s likely no single formal model of change management that will neatly apply to the spectrum of changes any given organization may tackle. However, these frameworks, particularly Kotter’s eight-step process and the Prosci ADKAR model, can provide useful insights for approaching change. One commonality across any change necessary in an environment as dynamic as SRE is constant reevaluation and iteration. While many changes may start organically in a grassroots fashion, most can benefit from structured coordina‐ tion and planning as the changes mature.\n\nConclusion\n\n|\n\n439",
      "content_length": 1212,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 473,
      "content": "Conclusion\n\nBy Dave Rensin, Betsy Beyer, Niall Richard Murphy, Stephen Thorne, and Kent Kawahara\n\nOnward… The American economist Edgar Fiedler used to say that “[h]e who lives by the crystal ball soon learns to eat ground glass.” Predicting the future is dangerous.\n\nNonetheless, we’re going to risk the broken glass and try to say a few useful words about what we think comes after this book.\n\nThe Future Belongs to the Past Our experiences since the publication of the first SRE book and the process of assem‐ bling this volume have clearly demonstrated a huge pent-up demand for SRE from enterprises both large and small. From this, some interesting observations emerge.\n\nFirst, large enterprises tend to have correspondingly large appetites to adopt SRE practices in a robust way. The familiar meme that large enterprises are slow to change is decidedly not true in this case. We expect to see a lot of interesting innovation in the SRE space from these firms over the next year, and that’s really exciting.\n\nNext, smaller firms are finding ways to adopt SRE practices regardless of whether or not they can staff a full-blown, globally distributed SRE team. We’ve long speculated that although the substance and sequence of the dishes are vitally important, people don’t have to eat the whole SRE meal at once. We are now seeing that notion put into good practice, and that’s also really exciting because it allows everyone to participate.\n\nFinally, if you are reading this book and wondering if there’s a market opportunity for you to offer services or build products that help firms adopt SRE, then the answer is a resounding yes. In fact, if that’s something you decide to do, please let us know through O’Reilly at bookquestions@oreilly.com. We’d like to keep up with your progress.\n\nConclusion\n\n|\n\n441",
      "content_length": 1810,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 474,
      "content": "SRE + <Insert Other Discipline> We heard from many thoughtful people that SRE principles and practices seem like they should also apply to other disciplines—particularly security. We didn’t cover the SRE/security overlap in the first book (or this book), but this is clearly a quickly bur‐ geoning area of focus. If you’re wondering why we didn’t cover it in any depth in this volume, it’s because we’re not sure what we want to say about it (yet).\n\nAt the time of this writing (early spring 2018) we’re already seeing the emergence of the term DevSecOps—a recognition that development, security, and operations are all interdependent—in the marketplace. If you’re an SRE looking for a useful and unex‐ plored space in which to spend some time, that’s a really good candidate!\n\nIn general, we think this is the start of a trend toward asking, “How would SRE be applied to <insert other discipline>?” It certainly stands to reason that some SRE principles and practices could have value in other domains.\n\nWe’re pretty excited to see where that leads…\n\nTrickles, Streams, and Floods The number of people offering to contribute content to this volume was much larger than the previous volume. That seems easy enough to explain—the first book was pretty popular, so people were keen to contribute to the second one. However, the variety of people offering to pitch in has been interesting. The types and range of the content proposals we evaluated surprised us. For example, a team of lawyers approached us about how they might incorporate error budgets into nontechnical legal agreements. How SRE applies to the legal profession is a topic clearly out of scope for this book, but is probably really interesting to a whole other professional population.\n\nBecause of this variety, we decided that this volume will not just be an implementa‐ tion companion to the previous book. It will also be a launching point for whole new streams of SRE-related content. That means more books, articles, podcasts, videos, and who knows what else. This volume is a beginning, not an end.\n\nSRE Belongs to All of Us When we started work on the first book, our primary motivation was to explain SRE—this interesting thing we do to make Google work well for our users. It seemed useful to spread that knowledge around.\n\nIn our enthusiasm to explain our view of the world, we anchored on our direct expe‐ riences. As a result, we unintentionally alienated some in the larger DevOps commu‐ nity and beyond, who felt we ignored other organizations’ contributions to the field.\n\n442\n\n|\n\nConclusion",
      "content_length": 2571,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 475,
      "content": "This volume aims to correct that mistake by devoting considerable space to discus‐ sing DevOps and SRE and why they are not at odds.\n\nTo our great joy, SRE is a growing community of practitioners that now extends very far outside of Google. In fact, it’s likely that the number of non-Google SREs will sig‐ nificantly outnumber Google SREs by the time you read this.\n\nWhatever its history, SRE is now a global community of which Google is one mem‐ ber. It belongs to all of us, and that’s a good thing. It’s already abundantly clear, via conferences like SREcon, meetups, and other publications, that we all have a lot to share with and learn from each other. To that end, we hope this book further expands that ongoing conversation.\n\nOn Gratitude This volume has been a labor of love for us, and we are deeply grateful that you deci‐ ded to read it. This process has taught each of us some surprising lessons about what SRE has become and made us all very excited to see what comes next.\n\n(And since we are SREs, we’ll be starting a lengthy postmortem on this process. Who knows, maybe you’ll even see it in a blog post one of these days…)\n\nMay your queries flow and your pagers stay silent. —Dave, Betsy, Niall, Stephen, and Kent\n\nConclusion\n\n|\n\n443",
      "content_length": 1251,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 477,
      "content": "APPENDIX A Example SLO Document\n\nThis document describes the SLOs for the Example Game Service.\n\nStatus Author Date Reviewers Approvers Approval Date Revisit Date\n\nPublished Steven Thurgood 2018-02-19 David Ferguson Betsy Beyer 2018-02-20 2019-02-01\n\nService Overview The Example Game Service allows Android and iPhone users to play a game with each other. The app runs on users’ phones, and moves are sent back to the API via a REST API. The data store contains the states of all current and previous games. A score pipeline reads this table and generates up-to-date league tables for today, this week, and all time. League table results are available in the app, via the API, and also on a public HTTP server.\n\nThe SLO uses a four-week rolling window.\n\nExample SLO Document\n\n|\n\n445",
      "content_length": 783,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 478,
      "content": "SLIs and SLOs\n\nCategory API Availability\n\nSLI\n\nThe proportion of successful requests, as measured from the load balancer metrics. Any HTTP status other than 500–599 is considered successful. count of \"api\" http_requests which do not have a 5XX status code divided by count of all \"api\" http_requests\n\nLatency\n\nThe proportion of sufficiently fast requests, as measured from the load balancer metrics. “Sufficiently fast” is defined as < 400 ms, or < 850 ms. count of \"api\" http_requests with a duration less than or equal to \"0.4\" seconds divided by count of all \"api\" http_requests\n\ncount of \"api\" http_requests with a duration less than or equal to \"0.85\" seconds divided by count of all \"api\" http_requests\n\nHTTP server Availability\n\nThe proportion of successful requests, as measured from the load balancer metrics. Any HTTP status other than 500–599 is considered successful. count of \"web\" http_requests which do not have a 5XX status code divided by count of all \"web\" http_requests\n\nLatency\n\nThe proportion of sufficiently fast requests, as measured from the load balancer metrics. “Sufficiently fast” is defined as < 200 ms, or < 1,000 ms. count of \"web\" http_requests with a duration less than or equal to \"0.2\" seconds divided by count of all \"web\" http_requests\n\ncount of \"web\" http_requests with a duration less than or equal to \"1.0\" seconds divided by count of all \"web\" http_requests\n\n446\n\n| Appendix A: Example SLO Document\n\nSLO\n\n97% success\n\n90% of requests < 400 ms 99% of requests < 850 ms\n\n99%\n\n90% of requests < 200 ms 99% of requests < 1,000 ms",
      "content_length": 1566,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 479,
      "content": "Category SLI Score pipeline Freshness\n\nThe proportion of records read from the league table that were updated recently. “Recently” is defined as within 1 minute, or within 10 minutes. Uses metrics from the API and HTTP server: count of all data_requests for \"api\" and \"web\" with freshness less than or equal to 1 minute divided by count of all data_requests\n\nSLO\n\n90% of reads use data written within the previous 1 minute. 99% of reads use data written within the previous 10 minutes.\n\ncount of all data_requests for \"api\" and \"web\" with freshness less than or equal to 10 minutes divided by count of all data_requests\n\nCorrectness\n\nThe proportion of records injected into the state table by a correctness prober that result in the correct data being read from the league table. A correctness prober injects synthetic data, with known correct outcomes, and exports a success metric: count of all data_requests which were correct divided by count of all data_requests\n\n99.99999% of records injected by the prober result in the correct output.\n\nCompleteness\n\nThe proportion of hours in which 100% of the games in the data store were processed (no records were skipped). Uses metrics exported by the score pipeline: count of all pipeline runs that processed 100% of the records divided by count of all pipeline runs\n\n99% of pipeline runs cover 100% of the data.\n\nRationale Availability and latency SLIs were based on measurement over the period 2018-01-01 to 2018-01-28. Availability SLOs were rounded down to the nearest 1% and latency SLO timings were rounded up to the nearest 50 ms. All other numbers were picked by the author and the services were verified to be running at or above those levels.\n\nNo attempt has yet been made to verify that these numbers correlate strongly with user experience.1\n\n1 Even if the numbers in the SLO are not strongly evidence-based, it is necessary to document this so that\n\nfuture readers can understand this fact, and make their decisions appropriately. They may decide that it is worth the investment to collect more evidence.\n\nExample SLO Document\n\n|\n\n447",
      "content_length": 2094,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 480,
      "content": "Error Budget Each objective has a separate error budget, defined as 100% minus (–) the goal for that objective. For example, if there have been 1,000,000 requests to the API server in the previous four weeks, the API availability error budget is 3% (100% – 97%) of 1,000,000: 30,000 errors.\n\nWe will enact the error budget policy (see Appendix B) when any of our objectives has exhausted its error budget.\n\nClarifications and Caveats\n\nRequest metrics are measured at the load balancer. This measurement may fail to accurately measure cases where user requests didn’t reach the load balancer.\n\nWe only count HTTP 5XX status messages as error codes; everything else is counted as success.\n\nThe test data used by the correctness prober contains approximately 200 tests, which are injected every 1s. Our error budget is 48 errors every four weeks.\n\n448\n\n| Appendix A: Example SLO Document",
      "content_length": 884,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 481,
      "content": "APPENDIX B Example Error Budget Policy\n\nStatus Author Date Reviewers Approvers Approval date Revisit date\n\nPublished Steven Thurgood 2018-02-19 David Ferguson Betsy Beyer 2018-02-20 2019-02-01\n\nService Overview The Example Game Service allows Android and iPhone users to play a game with each other. New releases of the backend code are pushed daily. New releases of clients are pushed weekly. This policy applies both to backend and client releases.\n\nGoals The goals of this policy are to:\n\nProtect customers from repeated SLO misses\n\nProvide an incentive to balance reliability with other features\n\nNon-Goals This policy is not intended to serve as a punishment for missing SLOs. Halting change is undesirable; this policy gives teams permission to focus exclusively on\n\nExample Error Budget Policy\n\n|\n\n449",
      "content_length": 808,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 482,
      "content": "reliability when data indicates that reliability is more important than other product features.\n\nSLO Miss Policy If the service is performing at or above its SLO, then releases (including data changes) will proceed according to the release policy.\n\nIf the service has exceeded its error budget for the preceding four-week window, we will halt all changes and releases other than P01 issues or security fixes until the ser‐ vice is back within its SLO.\n\nDepending upon the cause of the SLO miss, the team may devote additional resour‐ ces to working on reliability instead of feature work.\n\nThe team must work on reliability if:\n\nA code bug or procedural error caused the service itself to exceed the error budget.\n\nA postmortem reveals an opportunity to soften a hard dependency.\n\nMiscategorized errors fail to consume budget that would have caused the service to miss its SLO.\n\nThe team may continue to work on non-reliability features if:\n\nThe outage was caused by a company-wide networking problem.\n\nThe outage was caused by a service maintained by another team, who have them‐ selves frozen releases to address their reliability issues.\n\nThe error budget was consumed by users out of scope for the SLO (e.g., load tests or penetration testers).\n\nMiscategorized errors consume budget even though no users were impacted.\n\nOutage Policy If a single incident consumes more than 20% of error budget over four weeks, then the team must conduct a postmortem. The postmortem must contain at least one P0 action item to address the root cause.\n\n1 P0 is the highest priority of bug: all hands on deck; drop everything else until this is fixed.\n\n450\n\n| Appendix B: Example Error Budget Policy",
      "content_length": 1685,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 483,
      "content": "If a single class of outage consumes more than 20% of error budget over a quarter, the team must have a P0 item on their quarterly planning document2 to address the issues in the following quarter.\n\nEscalation Policy In the event of a disagreement between parties regarding the calculation of the error budget or the specific actions it defines, the issue should be escalated to the CTO to make a decision.\n\nBackground\n\nThis section is boilerplate, intended to give a succinct overview of error budgets to those unfamiliar with them.\n\nError budgets are the tool SRE uses to balance service reliability with the pace of innovation. Changes are a major source of instability, representing roughly 70% of our outages, and development work for features competes with development work for stability. The error budget forms a control mechanism for diverting attention to stability as needed.\n\nAn error budget is 1 minus the SLO of the service. A 99.9% SLO service has a 0.1% error budget.\n\nIf our service receives 1,000,000 requests in four weeks, a 99.9% availability SLO gives us a budget of 1,000 errors over that period.\n\n2 At Google, quarterly planning is public, and teams are held accountable to their plans.\n\nExample Error Budget Policy\n\n|\n\n451",
      "content_length": 1246,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 485,
      "content": "APPENDIX C Results of Postmortem Analysis\n\nAt Google, we have a standard postmortem template that allows us to consistently capture the incident root cause and trigger, which enables trend analysis. We use this trend analysis to help us target improvements that address systemic root-cause types, such as faulty software interface design or immature change deployment planning. Table C-1 shows the breakdown of our top eight triggers for outages, based on a sam‐ ple of thousands of postmortems over the last seven years.\n\nTable C-1. Top eight outage triggers, 2010–2017\n\nBinary push Configuration push User behavior change Processing pipeline Service provider change Performance decay Capacity management Hardware\n\n37% 31% 9% 6% 5% 5% 5% 2%\n\nTable C-2 presents the top five contributing root-cause categories.\n\nTable C-2. Top five root-cause categories for outages\n\nSoftware Development process failure Complex system behaviors Deployment planning Network failure\n\n41.35% 20.23% 16.90% 6.74% 2.75%\n\nResults of Postmortem Analysis\n\n|\n\n453",
      "content_length": 1038,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 487,
      "content": "A abandoned phase (service lifecycle), SRE\n\nengagement in, 374\n\nAbuse SRE and Common Abuse Tool (CAT)\n\nteams, Ares case study, 385-387\n\naccess control policies for data processing pipe‐\n\nlines, 277\n\naccidents, view in DevOps, 3 ACM Queue article on Canary Analysis service,\n\n313\n\naction items in postmortems, 200\n\ngamification of postmortem action items,\n\n216\n\nin good postmortem example, 212\n\nblamelessness of, 213 concrete action items, 213\n\nmonitoring tool for, 222 rewarding closeout of, 215\n\nactive development phase (service lifecycle),\n\nSRE engagement in, 373\n\nADKAR, 426, 433\n\n(see also Prosci ADKAR model) AdMob and AdSense systems, 137 AdWords NALSD example, 246-259\n\ndesign process, 246 distributed system, 251-259\n\nLogJoiner, 252 MapReduce, evaluating, 251\n\ninitial requirements, 247 running application on one machine, 248 scaling resources for parsing logs, 249\n\nalerts\n\nalert suppression, 64 alerting on SLOs, 75-91\n\nIndex\n\nburn rate for error budgets, 80 considerations in, 75 increased alert window, 78 incrementing alert duration, 79 low-traffic services and error budget\n\nalerting, 86-89\n\nmaking sure alerting is scalable, 89 multiple burn rate alarms, 82 multiwindow, multi-burn-rate alerts, 84 services with extreme availability goals,\n\n89\n\ntarget error rate SLO threshold, 76\n\ncontributors to high pager load, 158 paging alerts, defining thresholds for, 163 provided by monitoring system, 64\n\nin metrics-based and logs-based systems,\n\n65\n\nseparating alerting in monitoring systems,\n\n68\n\ntesting alerting logic in monitoring system,\n\n72\n\nusing good alerts and consoles to identify\n\ncause of pages, 161 analysis of postmortems, 222, 453 animated (undesirable) language in postmor‐\n\ntems, 201 anycast, 226\n\nstabilized, implementation of, 226\n\nAPIs\n\navailability and latency for API calls, Home\n\nDepot case study, 52\n\navailability and latency SLIs, 25 case study, end-to-end API simplicity, 134 machine consumable, 393\n\nIndex\n\n|\n\n455",
      "content_length": 1951,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 488,
      "content": "proposed SLOs for the API, 28\n\napplication errors in data processing pipeline,\n\n286\n\nApplication Readiness Reviews (ARRs), 377 architecture and design phase (service lifecy‐\n\ncle), SRE engagement in, 372\n\narchitecture and design, SRE team partnering\n\non, 411\n\narchitectures (opaque), troubleshooting for,\n\n100\n\nartificial load generation, 350 aspirational SLOs, 36 authoring of postmortems, including all partic‐\n\nipants in, 215 autohealing, 236 automated builds, 336 automated health checking, 160 automation\n\narchiving and migration, in filer-backed\n\nhome directory decommissioning, 126\n\nassessing risks of, 104 automating this year’s job away, 6 automating toil response, 104 increasing uniformity in production envi‐\n\nronment, 103\n\nmeasuring effectiveness of automated tasks,\n\n105\n\npartial automation with human-backed\n\ninterfaces, 102, 127\n\nusing to reduce toil in datacenter, case\n\nstudy, 107-120 autoscaling, 236-239\n\navoiding overloading backends, 238 avoiding traffic imbalance, 239 configuring conservatively, 237 handling unhealthy machines, 236 implementing for data processing pipelines,\n\n276\n\nin Spotify case study, 295 including kill switches and manual over‐\n\nrides, 238\n\nload-based, using with load balancing, 239 load-based, using with load shedding, 239 setting constraints on the autoscaler, 237 using with load balancing and load shed‐\n\nding, precautions with, 242 working with stateful systems, 237\n\navailability\n\n456\n\n|\n\nIndex\n\nalerting on services with extreme availability\n\ngoals, 89\n\nduring canary deployment, 343 Evernote’s goal for, 45 factoring dependencies into, 100 for API calls, SLOs in Home Depot case\n\nstudy, 52\n\ngrouping request types into buckets of simi‐\n\nlar availability requirements, 89\n\nhigh availability with GCLB, 231\n\navailability SLI, 24\n\nAPI and HTTP server availability, 25 measuring availability with health-checking\n\nhandler, 36\n\nB backend services, avoiding overloading in\n\nautoscaling, 238\n\nbalance between on-call and project work for\n\nSREs, 148\n\nbaseline of a functional team, 367 Beyond Corp network security protocol, 122 BGP (Border Gateway Protocol), 226 blameful language, mitigating damage of, 219 blameless language, 215 blameless postmortems, 8, 10, 195\n\n(see also postmortems) blamelessness in good postmortem exam‐\n\nple, 213\n\nmodeling and enforcing blameless behavior,\n\n214\n\nresponding to culture failures in, 218\n\nblue/green deployment, 350 boiling the frog, 167 Borg, 134 breaks (long-term) in on-call scheduling, 170 Bridges Transition Model, 426, 427 bucketing, using with SLIs, 39 bugs\n\nbug tracking systems, 166 new bugs in production environment, 159 preexisting bugs in production environ‐\n\nment, 159\n\ntracking new bugs in production, 160\n\nburn rate (error budgets)\n\nalerting on, 80 multiple alerts on, 82 multiwindow multi-burn-rate alerts, 84\n\nbusiness intelligence, 265",
      "content_length": 2844,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 489,
      "content": "business priorities, communicating between\n\nSRE and developer teams, 375 business processes producing toil, 98\n\nquestioning, 127\n\nC calculations support (monitoring systems), 62 CALMS (Culture, Automation, Lean, Measure‐\n\nment, and Sharing), 2\n\ncanarying releases, 161, 335-351\n\nbalancing release velocity and reliability,\n\n337\n\ncanary implementation, 342-345\n\nchoosing canary population and dura‐\n\ntion, 343\n\nminimizing risk to SLOs and error\n\nbudget, 343 canarying, defined, 338 dependencies and isolation, 348 for data processing pipeline, 273 in noninteractive systems, 348 related concepts, 350\n\nartificial load generation, 350 blue/green deployment, 350 traffic teeing, 351\n\nrelease engineering and canarying, 338\n\nexample setup, 339 requirements of canary process, 339 release engineering principles, 336-337 requirements on monitoring data, 349 roll forward deployment vs. simple canary\n\ndeployment, 340-342\n\nselecting and evaluating metrics, 345-348\n\nbefore/after evaluation, riskiness of, 347 metrics indicating problems, 345 representative and attributable metrics,\n\n346\n\nusing gradual canary for better metric\n\nselection, 347\n\nseparating components that change at dif‐\n\nferent rates, 337\n\nwith GCLB, 231 capacity planning, 100\n\nfor data processing pipeline, 276 in Spotify case study, 295 setting traffic volume SLOs in Home Depot\n\ncase study, 52\n\nCCN (cyclomatic complexity number), 131 change control, 423\n\nchange management\n\nin DevOps and SRE, 8 organizational change management in SRE,\n\n423-439 case study, common tooling adoption in\n\nSRE, 432-439\n\ncase study, scaling Waze, 427-432 emotion-based models, 426 how change management theories apply\n\nto SRE, 427\n\nKotter’s eight-step process, 425 Lewin’s three-stage model, 424 McKinsey’s 7-S model, 424 Prosci ADKAR model, 425 SRE embracing change, 423\n\nchanges\n\navoiding changes that can’t be rolled back,\n\n162\n\nchange tracking for configurations, 312 gradual change in DevOps, 3 monitoring intended changes in services, 70 safe configuration change application, 312\n\nchecklist for new SRE team training, 150 checklist for postmortems, 221 checkpointing in data processing pipelines, 279 clarity in good postmortem example, 212 click-through rate (CTR), 246\n\ncalculating, 247\n\nClickMap (AdWords example), 252 in multidatacenter design, 257 scaling, calculations for, 254\n\nin multidatacenter design, 258 client behavior changes, resulting in bugs, 160 Clos network topology, 107 cloud environment\n\nbreaking down SLO wall between GCP and\n\nEvernote, 48\n\nEvernote, on-call setup for cloud datacen‐\n\nters, 153-156\n\nGoogle Cloud Platform (GCP), 43\n\ncode\n\ncode patterns for data processing pipelines,\n\n280\n\nconfiguration as code or data, 309 cyclomatic code complexity, 131\n\ncodelabs, 150 collaboration in DevOps and SRE, 8 colocation facilities (colos), racks of proxy/\n\ncache machines in, 196\n\nIndex\n\n|\n\n457",
      "content_length": 2866,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 490,
      "content": "communication\n\nbetween teams, understanding differences\n\nin, 382\n\nin incident response, 176\n\ndeciding on communication channel,\n\n192\n\nfailure in Google Home incident, 180 keeping your audience informed, 192 maintaining open line between SRE and\n\nother teams, 380\n\nCommunications Lead (CL), 187 completeness SLO (Spotify case study), 293 complexity\n\ncase study, project lifecycle complexity, 134 measuring, 131-132\n\ncomplexity toil, 316 components\n\nseparating components that change at dif‐\n\nferent rates, 337\n\ntypes of, 22\n\nSLIs for different types, 24\n\nCompute Engine, 48 conciseness in postmortems, 214 configuration, 301-314\n\nabout, 301 and reliability, 302 configuration-induced toil, 315\n\nreducing, 316\n\ncritical properties and pitfalls of configura‐\n\ntion systems, 317-320 building too much domain-specific opti‐\n\nmization, 318\n\ndesigning accidental or ad hoc language\n\nfeatures, 318\n\nfailing to recognize configuration as pro‐ gramming language problem, 317 interleaving configuration evaluation\n\nwith side effects, 319\n\nusing general-purpose scripting lan‐\n\nguages, 319\n\ndata processing pipeline, causing failures,\n\n286\n\neffectively operating a configuration system,\n\n329-330 testing, 330 using source control, 330 versioning, 329\n\nguarding against abusive configuration, 333 integrating a configuration language, 320\n\n458\n\n|\n\nIndex\n\ndriving multiple applications, 321 generating config in specific formats,\n\n320\n\nintegrating custom applications, 327-329 integrating existing application, Kubernetes,\n\n322-326 example Kubernetes config, 322 integrating the configuration language,\n\n323\n\nmechanics of, 308-313\n\nimportance of tooling, 310 ownership and change tracking, 312 safe configuration change application,\n\n312\n\nseparating configuration and resulting\n\ndata, 308\n\nmonitoring system, treating as code, 67 philosophy of, 303-308\n\nconfiguration asks users questions, 305 escaping simplicity, 308 mandatory and optional questions, 306 questions should be close to user goals,\n\n305\n\nseparating philosophy and mechanics, 303 when to evaluate, 331-333\n\nearly evaluation, checking in the JSON,\n\n331\n\nlate evaluation at runtime, 332 middle of the road, evaluation at build\n\ntime, 332\n\nconfiguration syntax, tooling for, 311 connection tracking, 228 consensus algorithms, 257 consistent hashing, 228\n\nusing with stateful systems, 237 contacts, preparing for an incident, 192 context, missing, in bad postmortem, 199 continuous integration and continuous delivery\n\n(CI/CD), 3, 335 coupled with release automation, virtuous\n\ncycle of, 336\n\ncoordination of incident response effort, 176 correctness SLI, 24 correctness SLOs, 269 corrupt data (in data processing pipeline), 285 cost engineering, 100 coverage SLI, 24\n\nimplementation for pipeline coverage, 26,\n\n26",
      "content_length": 2761,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 491,
      "content": "coverage, SLO lacking, 35 CRE (see Google’s Customer Reliability Engi‐\n\nneering (CRE) team) CRITICAL requests, 90 cross-team reviews of postmortems, 218 CRUD-style APIs, monitoring system configu‐\n\nration, 68\n\nCs of incident management (coordinate, com‐\n\nmunicate, control), 176 CTR (see click-through rate) culture\n\nand tooling in DevOps, 3 learning from failure in postmortems (see\n\npostmortems)\n\nresponding to postmortem culture failures,\n\n218\n\nSLO culture project at Home Depot, 50\n\ncustomers\n\nhaving a hard time, 393 practicing SRE with, 393 SRE with, how to, 394-397 cyclomatic code complexity, 131\n\nD dashboards\n\nbuilding shared SLO dashboards with cus‐\n\ntomers, 395\n\nfor data processing pipeline, 283 providing for SLOs, 33 separate dashboarding system in monitor‐\n\ning, 69\n\nshowing SLI trends, 33 VALET dashboard, Home Depot case study,\n\n56\n\ndata analysis pipeline, case study, 387-389 data analytics, 265 data collection to monitor causes in on-call\n\nload, 165\n\ndata correctness, 269 data formats for configuration information, 309 data freshness, 269 data isolation, 269\n\ncanarying releases and, 348 in noninteractive systems, 349 data processing pipelines, 263-299\n\nbest practices, 268-277\n\nadhering to access control and security\n\npolicies, 277\n\ncreating and maintaining pipeline docu‐\n\nmentation, 271\n\ndefining and measuring service level\n\nobjectives, 268-270\n\nimplementing autoscaling and resource\n\nplanning, 276\n\nmapping your development lifecycle,\n\n272-275\n\nplanning escalation paths, 277 planning for dependency failure, 270 reducing hotspotting and workload pat‐\n\nterns, 275\n\ncase study, Spotify, 287-299\n\ncustomer integration and support,\n\n293-298\n\nevent delivery, 288 event delivery system design and archi‐\n\ntecture, 289\n\nevent delivery system operation, 290-293\n\nfailures, prevention and response, 284-287\n\npotential causes, 286 potential failure modes, 284 pipeline applications, 264-268\n\ndata analytics, 265 event processing and data transforma‐\n\ntion, 264\n\nmachine learning, 265\n\nrequirements and design, 277-280\n\ncheckpointing, 279 code patterns, 280 features, 278 idempotent and two-phase mutations,\n\n279\n\npipeline production readiness, 281-284\n\ndata-only languages (configuration), 317 datacenters\n\nmultidatacenter in AdWords example, 257 using automation to reduce toil, case study,\n\n107-120 debugging, 68\n\nfor data processing pipeline, 282 in App Engine errors, 65 metrics for, 72\n\ndelayed data (in data processing pipeline), 284 Deming Cycle, 426 dependencies\n\ncanarying releases and, 348 circular dependency, pDNS, 140 effects on availability, 100\n\nIndex\n\n|\n\n459",
      "content_length": 2595,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 492,
      "content": "external dependencies and incident\n\nresponse, 183\n\nin data processing pipeline, causing failures,\n\n286\n\nmodeling, 40 monitoring system metrics from, 70 planning for failure in data processing pipe‐\n\nlines, 270\n\ndeployments\n\nautomated, 336 blue/green, 350 continuous, 3\n\n(see also continuous integration and\n\ncontinuous delivery)\n\ndeploying data processing pipeline to pro‐\n\nduction, 275\n\npartial, performing for data processing\n\npipelines, 274\n\nroll forward deployment vs. simple canary\n\ndeployment, 340-342\n\nsmall, 336\n\ndeprecation phase (service lifecycle), SRE\n\nengagement in, 374 depth in postmortems, 213 design phase (service lifecycle), SRE engage‐\n\nment in, 372\n\ndesign process (NALSD), 246 destructive testing or fuzzing, 159 detection time (SLO alerts), 76 development\n\ndevelopment process in Spotify case study,\n\n296\n\nmapping data processing pipeline develop‐\n\nment lifecycle, 272-275\n\npartnership with SRE, critical importance\n\nof, 11\n\nplacing your first SRE in development team,\n\n401\n\nsetting up relationship between SRE and\n\ndevelopment team, 375-380 aligning goals, 375-378 communicating business and produc‐\n\ntion priorities, 375 identifying risks, 375 planning and executing, 379 setting ground rules, 379\n\nSRE teams having responsibility for, 412 SRE-to-developer ratio and support of mul‐ tiple services by single SRE team, 382\n\n460\n\n|\n\nIndex\n\nSREs sharing ownership with developers, 6 sustaining an effective ongoing relationship between SRE and development teams, 380-382\n\nDevOps\n\nabout, 2 accidents, view of, 3 comparing and contrasting with SRE, 7 elimination of silos, 2 gradual change, 3 implementation by SRE, 4 interrelation of tooling and culture, 3 measurement as crucial, 4 organizational context and fostering suc‐\n\ncessful adoption, 9-12\n\ndisaster and recovery testing, practicing with\n\ncustomers, 397\n\ndisaster recovery testing (DiRT) at Google, 193,\n\n271\n\ndiskerase, 196 Display Ads Spiderweb, simplification of (case\n\nstudy), 137\n\ndistributed SRE teams, running, 384 distributed SREs, 403 documentation\n\ncreating and maintaining for data process‐\n\ning pipelines, 271\n\nSpotify case study, customer integration and\n\nsupport, 294\n\ndomain-specific languages (DSLs) for configu‐\n\nration, 319\n\ndomain-specific optimization (excessive) in\n\nconfigurations, 318\n\ndraining requests away from buggy system ele‐\n\nments, 162\n\ndrills (incident management), 193 dropping work, 368 durability SLI, 25 duration parameter (alerts), incrementing, 79\n\nE ease of implementation and transparency for data processing pipeline, 283 emergency response, practicing, 161 emotion-based models for change manage‐\n\nment, 426\n\nend-to-end measurement for data processing\n\npipeline SLOs, 270\n\nending SRE engagements, 385-389",
      "content_length": 2726,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 493,
      "content": "case study, Ares, 386-387 case study, data analysis pipeline, 387 Equal-Cost Multi-Path (ECMP) forwarding,\n\n227\n\nerror budgets, 47\n\n(see also service level objectives) addressing missed SLO caused by a depend‐\n\nency, 41\n\nadjusting priorities according to, 381 agreed-upon by SRE and development\n\nteams for a service, 379\n\nalerting on burn rate, 80 multiple alarms, 82 multiwindow, multi-burn-rate alerts, 84\n\ncalculating, 20 dashboard showing error budget consump‐\n\ntion, 34\n\ndecision making using, 37-38 documenting error budget policy, 32 establishing error budget policy, 31 example policy, 449-451 for example game service, 448 low-traffic services and error budget alert‐\n\ning, 86-89 combining services, 87 generating artificial traffic, 87 lowering the SLO or increasing the win‐\n\ndow, 88\n\nmaking service and infrastructure\n\nchanges, 87\n\nminimizing risk to by canarying releases,\n\n343\n\nprerequisites for adopting as SRE approach,\n\n18\n\nreliability targets and, 19 rolling back recent changes and, 162 support tickets per day vs. measured loss in\n\nbudget, 35\n\nerrors\n\nalerting for target error rate over SLO thres‐\n\nhold, 76\n\ndebugging in different monitoring systems,\n\n65\n\ndefining SLOs for in Home Depot case\n\nstudy, 53\n\nerrors per hour metric in canary deploy‐\n\nment, 349\n\nincreased alert window for SLO errors, 78 measurement in Home Depot case study, 51\n\nevangelism, SLOs at Home Depot, 51, 54 events\n\nevent delivery in Spotify case study, 288 event processing to order or structure data,\n\n265\n\nEvernote, SLO case study, 43-49\n\ncurrent state of SLO use and practice, 49 introduction of SLOs, journey in progress,\n\n45-47\n\nwhy Evernote adopted SRE model, 44 extract, transform, load (ETL) model, 264\n\nETL pipelines, 264 in Spotify case study, 290\n\nF failures, 3\n\ndata processing pipeline, prevention and\n\nresponse, 284-287 potential causes, 286 potential failure modes, 284\n\ndependency failure in data processing pipe‐\n\nline, 270\n\nfailure tolerance in data processing pipeline,\n\n282\n\nhandling mistakes appropriately, 382 not passing off blame for, 10 reducing cost of, 6 feature isolation, 162 features\n\nfeature coverage in SRE with customers, 397 planning for data processing pipelines, 278 separating feature launches from binary\n\nreleases, 338\n\ntradeoffs between feature velocity and relia‐\n\nbility, 19\n\nfeedback from users, toil management with,\n\n105\n\nfinger pointing in postmortems, 201 follow-up to pager alerts, rigor in, 164 follow-up to postmortems, 222 forming your first SRE team, 404 Four Golden Signals, 51, 70 freshness\n\ndata freshness SLOs for data processing\n\npipeline, 269\n\nof data in monitoring system, 62\n\nfreshness SLI, 24\n\nimplementation for pipeline freshness, 26\n\nfunding and hiring (SREs), 421\n\nIndex\n\n|\n\n461",
      "content_length": 2739,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 494,
      "content": "future protection from overload, 368\n\nG G Suite Team Drive, 123 GCE (see Google Compute Engine) GCLB (Google Cloud Load Balancer), 225 (see also Google Cloud Load Balancing) general availability phase (service lifecycle),\n\nSRE engagement in, 374\n\ngeneric mitigations, 184\n\nuseful, in GKE CreateCluster failure case\n\nstudy, 184\n\ngeographical splits (SRE teams), 414\n\nfinance, travel budget, 417 leadership, joint ownership of a service, 418 parity, distributing work and avoiding a\n\nnight shift, 416\n\npeople and projects, seeding the team, 416 placement, and having three shifts, 417 placement, time zones apart, 415 should both halves of the team start at the\n\nsame time, 417\n\nGlobal Software Load Balancer (GSLB), 229 glossary in good postmortem example, 209, 212 goals, aligning between SRE and development\n\nteams, 375-378\n\ngolden signals (see Four Golden Signals) Google AdWords (see AdWords NALSD\n\nexample)\n\nGoogle Analytics, 265 Google Apps Script, 220 Google Assistant (version 1.88), bug in, 178 Google Cloud Load Balancer (GCLB), 225\n\nhigh availability with, 231\n\nGoogle Cloud Load Balancing, 225-235\n\nanycast network addressing and routing,\n\n226 stabilized anycast, 226\n\ncase study, Pokémon GO on GCLB, 231-235\n\nfuture-proofing, 235 migrating to GCLB, 233 resolving issue with request spikes and\n\nGFE, 234\n\nGlobal Software Load Balancer (GSLB), 229 Google Front End (GFE), 229 low latency with GCLB, 230 Maglev packet-level load balancer, 227\n\nGoogle Cloud Platform (GCP), 43, 153\n\n462\n\n|\n\nIndex\n\nbreaking down SLO wall between GCP and\n\nEvernote, 48\n\nGoogle Compute Engine (GCE), 289\n\nAutoscaler, 290, 295 losing large number of disk trays, incident\n\nresponse case study, 186-188 Google Front Ends (GFE), 228, 229\n\ncapacity reduction caused by synchronous\n\nclient retries, 233\n\nGoogle Home software bug incident response\n\ncase study, 177-180\n\nGoogle Kubernetes Engine (GKE), CreateClus‐\n\nter failure case study, 180-185 Google’s Colossus File System, 123 Google’s Customer Reliability Engineering\n\n(CRE) team, 43, 155\n\nGoogle’s template for postmortems, 220 GSLB (Global Software Load Balancer), 229\n\nH HashiCorp Configuration Language, 320 health checking, automated, problems with,\n\n160\n\nhelp, asking for, 162 HIGH_FAST requests, 90 HIGH_SLOW requests, 90 Home Depot, SLO case study, 49-59\n\napplying VALET to batch applications, 57 automating VALET data collection, 55 evangelizing SLOs, 54 first set of SLOs, 52-54 future aspirations, 58 proliferation of SLOs, 57 using VALET in testing, 58\n\nhorizontal projects, 419 horizontal SRE team, 404\n\nrisks and mitigations for, 406\n\nhotspotting, reducing in data processing pipe‐\n\nline, 275 HTTP requests\n\ngrading importance of, 39 success of, SLIs for, 20\n\nHTTP servers, availability and latency, 25 HTTP status codes, 53, 65, 448\n\nincluding in metrics-based monitoring, 66 monitoring system metrics on served traffic,\n\n72\n\nhuman error causing new bugs in production,\n\n161",
      "content_length": 2927,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 495,
      "content": "human processes in pager load, 159 human-backed interfaces, starting with, 102,\n\n127\n\nHyrum’s Law, 132\n\nI IC (Incident Commander), 177 ICS (Incident Command System), 176 idempotent mutations, 279 identification delay for causes of pages, 161 incentives\n\nfor SLO setting and measuring at Home\n\nDepot, 51\n\nfor successful adoption of DevOps and SRE,\n\n9-12 avoiding passing of blame, 10 narrow incentives narrowing success, 9 striving for parity of esteem, 12\n\nincident response, 175-194 basic principles, 175 best practices, using, 191-194\n\ndrills, 193 preparing beforehand, 192 training, 191\n\ncase study, Google Home software bug and\n\nfailure to communicate, 177-180 incident, 178 review, 180\n\ncase study, Google Kubernetes Engine\n\n(GKE), cluster creation failure, 180-185 incident, 181 responses that needed improvement, 184 responses that went well, 184\n\ncase study, incident response at PagerDuty,\n\n188-191 major incident response, 188 tools used, 190\n\ncase study, lightning strikes at Google data‐\n\ncenter, 185-188 incident, 186 review, 188\n\nincident management at Google, 176-177 Incident Command System (ICS), 176 main roles in incident response, 177\n\npracticing in SRE with customers, 397\n\nincidents\n\nestablishing criteria for, 193 finding causes of repeating incidents, 219 incident handling in Spotify case study, 297\n\nroot cause and trigger, in postmortem anal‐\n\nysis results, 453 weekly reporting of, 218\n\ninfrastructure-centric view (configuration), 305 intent-based configuration, monitoring system,\n\n68\n\ninterpersonal risk taking, 362 interrupts, 355 triaging, 360 work overload and, 357\n\niterations for SLO quality improvement, 37\n\nJ JavaScript, 320 jitter, 235 JSON, 320\n\nconfiguration data in, 310 configuration items in Kubernetes repre‐\n\nsented as JSON objects, 322\n\nexamples of bad and good JSON output by\n\nJsonnet, 327\n\nJsonnet, 310, 320, 327\n\nconverting existing template to, 326 generating JSON for configuration evalua‐\n\ntion, 331-333\n\nguarding against abusive configurations in,\n\n333\n\nlibrary functions for outputting INI and\n\nXML, 321\n\nquick introduction to, 319 using with Kubernetes configurations, 323 validating JSON with JSONschema, 329 versioning in, 329 writing tests as Jsonnet files, 330\n\nK key details omitted in bad postmortem, 200 kill switches and manual overrides in autoscal‐\n\ning, 238\n\nKotter’s eight-step process for leading change,\n\n425, 427 in Waze case study, 427\n\nKubernetes, 135, 322-326 capabilities of, 322 example Kubernetes config, 322 GKE CreateCluster failure, incident response case study, 180-185\n\nintegrating the configuration language, 323\n\nIndex\n\n|\n\n463",
      "content_length": 2610,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 496,
      "content": "using Jsonnet to build and deploy objects,\n\n334\n\nKübler-Ross Change Curve, 426, 427\n\nL languages, configuration\n\nchoosing language to store configuration in,\n\n308\n\nconfiguration syntax features, 311 failing to recognize configuration as pro‐ gramming language problem, 317 integrating a configuration language, 320 integrating in Kubernetes, 323 semantic validation, 311 using existing general-purpose scripting languges for configuration, 319\n\nlatency\n\ncalculations for multidatacenter design in\n\nAdWords example, 258\n\nfor API calls in Home Depot case study, 52 low latency with GCLB, 230 measurement in Home Depot case study, 51 SLOs in Home Depot case study, 52\n\nlatency SLI, 24\n\nAPI and HTTP server latency, 25 Launch Coordination Engineering (LCE)\n\nteams, 420\n\nleadership in geographically split SRE teams,\n\n418\n\nlegacy systems, 105\n\ndecommissioning filer-backed home direc‐\n\ntories, case study, 121-129 Lewin’s three-stage model for managing\n\nchange, 424\n\nlimited audience in bad postmortem example,\n\n202\n\nlimited availability phase (service lifecycle),\n\nSRE engagement in, 373\n\nline-card repair\n\ndesign first effort, Saturn line-card repair,\n\n110\n\nSaturn automated line-card repair work‐\n\nflow, 111\n\nSaturn vs. Jupiter line-card repair, 112 workflow before automation, 108\n\nlinters, 311 live version, 339 load\n\nartificial generation of, 350\n\n464\n\n|\n\nIndex\n\nbugs manifesting only at specific levels of\n\nload, 160\n\nload-based autoscaling, 239 testing, 159\n\nload balancer monitoring, 25 load balancing\n\ncombining strategies to manage load,\n\n239-240 precautions with, 242\n\nfor priority items in data processing pipe‐\n\nlines, 269\n\nGoogle Cloud, 225-235\n\ncase study, Pokémon GO on GCLB,\n\n231-235\n\nGCLB, high availability with, 231 GCLB, low latency with, 230 Global Software Load Balancer (GSLB),\n\n229\n\nGoogle Front End, 229 Maglev load balancer, 227 using anycast, 226\n\ntask-level, using with autoscaling on stateful\n\nsystems, 237\n\nusing with autoscaling, 236\n\nload shedding, 160, 239\n\ncase study, when load shedding attacks,\n\n240-243 precautions with load shedding, 242\n\nLogJoiner (AdWords example), 252\n\nscaling, calculations, 253 sharded, 254\n\nlogs, 64\n\nchoosing between log-based and metrics-\n\nbased monitoring systems, 65 logging change information, 161 logs-based monitoring systems, 64\n\nlong term goals (SRE team), 379 LOW (availability) requests, 90 low-traffic services, error budget alerting on,\n\n86-89 combining services, 87 generating artificial traffic, 87 lowering the SLO or increasing the window,\n\n88\n\nmaking service and infrastructure changes,\n\n87\n\nM machine learning, 265",
      "content_length": 2591,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 497,
      "content": "example machine learning data processing\n\npipeline, 266\n\nMaglev, 226\n\nimplementing stabilized anycast with, 226 packet delivery using consistent hashing\n\nand connection tracking, 228 major incident response at PagerDuty, 188 manual overrides and kill switches in autoscal‐\n\ning, 238\n\nMapReduce, evaluating for use in AdWords\n\ndistributed system, 251\n\nmaturity matrix for data processing pipeline,\n\n281-284\n\nMcKinsey’s 7-S change management model,\n\n424\n\nmean time to repair (MTTR), 6 measurements\n\ndecision on what/how to measure for SLOs\n\nat Evernote, 46\n\neffectiveness of automated tasks, 105 end-to-end measurement for data process‐\n\ning pipeline SLOs, 270 importance in DevOps, 4 in DevOps and SRE, 8 in SRE with customers, 396 measurability in action items in postmor‐\n\ntems, 213\n\nmeasuring the SLIs, 26-28 measuring toil, 96-98, 101 metrics for Home Depot services, 51 sources of, for API and HTTP sever availa‐\n\nbility and latency SLI, 25\n\nwith service level indicators (SLIs), 20\n\nmeeting in person to resolve issues, 382 metrics, 64\n\n(see also measurements) choosing between metrics-based and logs-\n\nbased monitoring systems, 65\n\ncollecting in canary deployments, time lim‐\n\nits on, 349\n\nestablishing to evaluate team workload, 368 indicating work overload, 366 metric-based monitoring system, 65 quantifiable, in good postmortem example,\n\n213\n\nrestructuring at Evernote for cloud datacen‐\n\nters, 154\n\nselecting and evaluating for canary deploy‐\n\nments, 345-348\n\nselection for canarying in noninteractive\n\nsystems, 349\n\nvisible and useful, from monitoring system,\n\n69-72 dependencies, 70 implementing purposeful metrics, 72 intended changes to your service, 70 on resource usage saturation, 71 status of served traffic, 72\n\nmicroservices\n\ncombining for low-traffic services and error\n\nbudget alerting, 87\n\nlimiting how much an SRE team can\n\naccomplish, 371\n\nrunning hundreds on a shared platform,\n\ncase study, 139\n\nusing microservice approach to creating\n\ndata processing pipelines, 280\n\nmigrations, 99\n\nautomation in filer-backed home directory\n\ndecommissioning, 126\n\nMission Control program (SRE teams), 418 mistakes, handling appropriately, 382 mitigation delays, reducing, 162 mitigation in incident response, 184\n\nprioritizing mitigation above all else, 185\n\nmobility for SREs, 419 Moira portal, 125 monitoring, 61-74\n\nauditing and building shared dashboards in\n\nSRE with customers, 395 calculating SLOs from data, 46 choosing between monitoring systems,\n\nexamples, 65\n\ncovering in interviews with SREs, 400 data collection for causes of on-call paging,\n\n165\n\ndecisions on reliability and, 392 desirable features of monitoring strategy,\n\n62-64 alerts, 64 calculations support, 62 interfaces for data display, 63 speed of data retrieval, 62 for data processing pipeline, 282 implementation in common tooling adop‐\n\ntion in SRE case study, 436\n\nmanaging monitoring systems, 67-69 encouraging consistency, 68\n\nIndex\n\n|\n\n465",
      "content_length": 2933,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 498,
      "content": "loose coupling of components, 68 treating configuration as code, 67\n\nof release pipeline, 336 or prevention fixes for pager alerts, 164 providing visible and useful metrics, 69-72 implementing purposeful metrics, 72 on dependencies, 70 on resource usage saturation, 71 status of served traffic, 72\n\nrequirements in canary evaluation, 349 restructuring at Evernote for cloud datacen‐\n\nters, 154\n\nsources of data, 64 system monitoring in Spotify case study,\n\n294\n\ntesting alerting logic, 72\n\nMoonwalk, 124 multidatacenter design (AdWords example),\n\n257 evaluating dataflow, 259 scaling, calculations for, 258\n\nMurphy-Beyer effect, 6 mutations, idempotent and two-phase, 279\n\nN NALSD (see non-abstract large system design) negative acknowledgments (NACKs), 229 NFS/CIFS protocols, 121 non-abstract large system design (NALSD),\n\n245-261 about, 245 AdWords example, 246-259 design process, 246 distributed system, designing, 251-259 initial requirements, 247 running application on one machine,\n\n248\n\nkey questions in design iterations, 261 why non-abstract, 246\n\nnoninteractive systems, canarying in, 348 norming (SRE teams), 408 NO_SLO requests, 90\n\nO Omega, 134 on-call, 147-173\n\nactions in incident response, 191 balancing between geographically split SRE\n\nteams, 416\n\n466\n\n|\n\nIndex\n\nexample setup within Google, 149-153 example setups, Evernote case study,\n\n153-156\n\nflexibility in, 167-171\n\nscenario, a change in personal circum‐\n\nstances, 168-171\n\npager load, 156-167\n\nappropriate response times for pages,\n\n156\n\ncontributors to high pager load, 158 scenario, a team in overload, 157\n\nrecap from first SRE book, 148 team dynamics, 171-173\n\nscenario, a survive the week culture,\n\n171-173\n\noperational load (or operational workload), 355 operational overload (or work overload), 356 operations, 1\n\nand separation between development and\n\nproduction, 6\n\nbenefits provided by release engineering\n\nprinciples, 336\n\ncovering in interviews with SREs, 400 creating operational rigor with customers,\n\n397\n\ndeveloper involvement in, 379 empowering ops engineers in SRE, 172 placing your first SRE in operations team,\n\n401\n\nOperations or Ops Lead (OL), 177 organizational change (positive), rewarding,\n\n216\n\norganizational change management in SRE,\n\n423-439 case study, common tooling adoption in\n\nSRE, 432-439\n\ncase study, scaling Waze, 427-432 introduction to change management,\n\n424-427 Deming Cycle, 426 emotion-based models, 426 how the theories apply to SRE, 427 Kotter’s eight-step process, 425 Lewin’s three-stage model, 424 McKinsey’s 7-S model, 424 Prosci ADKAR model, 425\n\nSRE embraces change, 423\n\noutages\n\nproblem summary in postmortems, 200",
      "content_length": 2645,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 499,
      "content": "reporting weekly, 218 top triggers of, 453\n\noverload, identifying and recovering from,\n\n355-369 case study, perceived overload after organi‐ zational and workload changes, 360-365 decision on the solution, 362 lessons learned, 365 long-term actions to address, 365 mid-term actions to address, 364 problem statement, 361 results of actions, 365 short-term actions to address, 363\n\ncase study, work overload when half a team\n\nleaves, 358-360 decision on the solution, 359 implementation of the solution, 359 lessons learned, 360 problem statement, 358 from load to overload, 356-358 mitigation strategies, 366-369\n\nrecognizing symptoms of overload, 366 reducing overload and restoring team\n\nhealth, 367\n\nownership\n\naction items in good postmortem example,\n\n213\n\nmissing, in bad postmortem example, 202 of a service in geographically split SRE\n\nteam, 418\n\nof configurations, 312 viewing postmortem owners as leaders, 216\n\nP pager load, 156-167\n\nappropriate response times, 156 determining causes of high load, 158\n\nalerting, 163 data quality, 165 identification delay for root cause of\n\npages, 161\n\nmitigation delay, 162 new bugs in production, 159 preexisting bugs, 159 rigor of follow-up, 164 vigilance, 167\n\nscenario, a team in overload, 157 PagerDuty, incident response case study,\n\n188-191\n\npart-time work schedules for on-call engineers,\n\n170\n\nparticipatory management, 362 Paxos consensus algorithm, 257 pDNS (Production DNS), eliminating depend‐\n\nency on itself (case study), 140\n\npeak-end rule, 392 perceived overload, 356, 357\n\nafter organizational and workload changes,\n\ncase study, 360-365\n\nreducing by giving team members more\n\ncontrol and power, 367\n\nperformance\n\ncurrent performance as determinant of\n\nSLOs, 22\n\nKPI (key performance indicator), SLO com‐\n\npliance as, 19 performing (SRE team), 411\n\npartnering on architecture, 411 self-regulating workload, 411\n\npets vs. cattle approach, 103 pipeline components, 23\n\nSLIs for freshness, coverage, and correct‐\n\nness, 26\n\npipelines, data processing (see data processing\n\npipelines)\n\nPiper/Git-on-Borg version control system, 123 Plan-Do-Check-Act (or PDCA) Cycle, 426 planning by SRE and development teams, 379 platforms\n\neverything important becomes a platform,\n\n393\n\nrunning, reliability and, 392\n\nplaybooks, maintaining, 152\n\nentries for data processing pipelines, 272\n\npoint fixes for paging alerts, 164 Pokémon GO on GCLB, case study, 231-235 positive behaviors, 382 postmortems, 195-223\n\nbad postmortem example, 197-199\n\nflaws in, 199-202\n\nblameless, 8, 10 case study, rack decommission leading to\n\nservice latency, 196-197\n\nconducting joint postmortems with custom‐\n\ners, 397\n\ngood postmortem example, 203-212 good writing practices used, 212 organizational incentives for, 214-220\n\nIndex\n\n|\n\n467",
      "content_length": 2764,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 500,
      "content": "modeling and enforcing blameless\n\nbehavior, 214\n\nresponding to postmortem culture fail‐\n\nures, 218\n\nrewarding postmortem outcomes, 215 sharing postmortems openly, 217\n\nresults of postmortem analysis, 453 templates for, 220\n\nGoogle template, 220 other industry templates, 220\n\ntools for, 221\n\nchecklist, 221 follow-up on postmortems, 222 other industry tools, 223 postmortem analysis, 222 postmortem creation, 221 storage, 221 precision in SLO alerts, 76 preparations for incidents, 192 preventative actions in postmortems, 200, 213 priorities\n\nadjusting according to SLOs and error\n\nbudget, 381\n\nbusiness and production, understanding,\n\n375\n\nprioritizing and triaging issues, 368 probers, 21, 46, 87\n\nuse at Evernote in monitoring, 46 problem summary (postmortems), 200 problems (simulated), practicing with custom‐\n\ners, 397\n\nprocess documentation for data processing\n\npipelines, 272\n\nproduction\n\nautomation, covering in interviews with\n\nSREs, 400\n\nboundaries between application develop‐\n\nment and, 6\n\ncontributors to high pager load, 158\n\npreexisting bugs, 159\n\ndata processing pipeline readiness for,\n\n281-284\n\nmanaging services in DevOps and SRE, 8 priorities, communication by SRE and\n\ndeveloper teams, 375\n\nproduction excellence reviews, 421 wisdom from, 5\n\nproduction interrupts, 99\n\n468\n\n|\n\nIndex\n\nProduction Readiness Reviews (PRRs), 281,\n\n371, 377\n\nproductionizing a service, 373 programming languages\n\nconfiguration as code, 309 designing accidental or ad hoc language fea‐\n\ntures in configuration system, 318 failing to recognize configuration as pro‐ gramming language problem, 317\n\nuse for configuration, 302 using existing general-purpose scripting languages for configuration, 319\n\nproject lifecycle complexity, case study, 134 Prometheus monitoring system, 69 Prosci ADKAR model, 425, 427, 433, 434\n\nmapping implementation phase of change\n\nproject, 435 protocol buffers, 318, 329 psychological safety\n\nin on-call rotations, 149 interpersonal risk taking, 362 regaining by identifying and alleviating psy‐\n\nchological stressors, 367 publication of postmortems, 202, 214\n\nQ quality of service (QoS)\n\nagreement on definition at Evernote, 47 maintaining while increasing feature veloc‐\n\nity, 44\n\nquality SLI, 24 QueryMap (AdWords example), 252\n\nscaling, calculations for\n\nin multidatacenter design, 258 QueryStore (AdWords example), 252 scaling, calculations for, 253\n\nR recall (SLO alerts), 76 recovery efforts (in postmortems), 200 region-level outages in data processing pipe‐\n\nline, 287\n\nregional groups of instances (RMiGs), autoscal‐\n\ners balancing instances across, 239 relationships, sustaining between SRE and\n\nother teams, 380-382 release candidate version, 339 release engineering, 335 and canarying, 338",
      "content_length": 2729,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 501,
      "content": "principles, 336-337\n\nreleases\n\nbenefits of frequent, smaller releases, 161 canarying (see canarying releases) shepherding, 99\n\nreliability\n\nas a partnership if you run a platform, 392 as most important feature, 391 balancing release velocity and, 337 configuration and, 302 considering work on as specialized role, 10 decided by users, not monitoring, 392 experimenting with relaxing SLOs, 41 improvements in, resulting from postmor‐\n\ntems, 216\n\nreliability hackathon for products at risk,\n\n381\n\nreliability targets and error budgets, 19\n\nrename-and-shame, 12 repeating incidents, finding causes of, 219 replication toil, 315\n\nautomating for configuration, 316\n\nreports on SLO compliance, 33 reproducible builds, 336 request-driven components, 23 requests\n\ngrouping request types into buckets of simi‐\n\nlar availability requirements, 89\n\nspecific mix of, bugs manifesting with, 160\n\nRequiem (postmortem storage tool), 221 reset time (SLO alerts), 76 resources\n\nmetrics about resource consumption, 63 monitoring resource usage, 71 resource planning for data processing pipe‐\n\nlines, 276\n\nunexpected growth in data processing pipe‐\n\nline, causing failures, 286\n\nresponse times to pages, 156 reusing code in data processing pipelines, 280 revenue coverage, 397 reviews, designing in SRE with customers, 396 revision control system, storing monitoring\n\nsystem configuration in, 67\n\nrisk analysis in SRE with customers, 396 risks and mitigations for first SRE team, 405 risks, identifying by SRE team to developer\n\nteam, 375 roadmaps, 379\n\nroll forward deployment vs. simple canary\n\ndeployment, 340-342\n\nrollback strategy for releases, 160 configuration changes, 313 promptly removing bugs from production,\n\n162\n\nrolling update strategy, 313 root causes and trigger (in postmortems), 200,\n\n213 routing\n\nanycast methodology, 226 RPCs (remote procedure calls) managing load with, 243 monitoring system metrics on, 70\n\nS satellites, 196 scaling, 236\n\n(see also autoscaling) calculations for AdWords NALSD example,\n\n249\n\ncalculations for LogJoiner, QueryStore,\n\nClickMap,, and QueryMap in AdWords example, 253\n\nduring limited availability phase of service\n\nlifecycle, 373\n\nof SRE to larger environments, 382-385 scalability of data processing pipeline, 282 Waze case study, 427-432\n\nscheduling on-call engineers, 167-171\n\nscenario, a change in personal circumstan‐\n\nces, 168-171 automating on-call scheduling, 168 planning for long-term breaks, 170 planning for part-time work schedules,\n\n170\n\nplanning for short-term swaps, 169 scripting languages, general-purpose, using for\n\nconfiguration system, 319\n\nsecurity policies for data processing pipeline,\n\nadhering to, 277\n\nself-healing, 160 self-regulating workload (SRE team), 411 self-service methods for users, 102, 127 semantic validation (configuration), 311 service complexity and forming more SRE\n\nteams, 413 pitfalls of team splits, 414 where to split the work, 413\n\nIndex\n\n|\n\n469",
      "content_length": 2928,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 502,
      "content": "service level agreements (SLAs)\n\nand dependency failures in data processing\n\npipelines, 270\n\nGoogle and Evernote, 48 service level indicators (SLIs), 17\n\nabstracting your system into types of com‐\n\nponents, 22\n\narchitecture for example mobile phone\n\ngame, 23-25\n\nautomation of collection of data at Home\n\nDepot, 51\n\ncanary metrics and, 345 changing SLI implementation, 36 dashboards showing SLI trends, 33 explaining to customers, 395 for example game service SLOs, 446 implementation, 21 measurements with, 20 measuring, 26-28\n\ncalculating SLIs over previous week, 28 moving from specification to implementa‐\n\ntion, 25 API and HTTP server availability and\n\nlatency, 25\n\npipeline freshness, coverage, and cor‐\n\nrectness, 26\n\nspecifications, 21 using to calculate starter SLOs, 28 service level objectives (SLOs), 17-42\n\nadjusting priorities according to, 381 alerting on, 75-91\n\nconsiderations in, 75 low-traffic services and error budget\n\nalerting, 86-89\n\nmaking sure alerting is scalable, 89 pager alerts, 163 services with extreme availability goals,\n\n89\n\nsignificant events, 76-86\n\nby SRE and development teams for a ser‐\n\nvice, 379\n\ncontinuous improvement of SLO targets,\n\n34-37 improving quality of SLOs, 35 decision making using SLOs and error\n\nbudgets, 37-38\n\ndefining and measuring for data processing\n\npipelines, 268 data correctness, 269\n\n470\n\n|\n\nIndex\n\ndata freshness, 269 data isolation/load balancing, 269 end-to-end measurement, 270\n\ndefining before general availability phase of\n\nservice lifecycle, 373\n\ndesign and implementation by your first\n\nSRE, 402\n\nEvernote case study, 43-49\n\nbreaking down SLO wall between cus‐ tomer and cloud provider, 48\n\ncurrent state of SLOs, 49 introduction of SLOs, 45-47 why Evernote adopted SRE model, 44\n\nexample document for game service,\n\n445-448\n\nfor Spotify event delivery system operation,\n\n290 skewness SLO, 292 timeliness SLO, 291\n\nfundamental importance in SRE, 43 getting started with, 18-23\n\nmeasurements using SLIs, 20-23 reliability targets and error budgets, 19\n\nHome Depot case study, 49-59\n\napplying VALET to batch applications,\n\n57\n\nautomating VALET data collection, 55 evangelizing SLOs, 54 first set of SLOs, 52-54 future aspirations, 58 proliferation of SLOs, 57 SLO culture project, 50 using VALET in testing, 58\n\nimplementing, worked example, 23-34\n\nchoosing appropriate time window, 29 dashboards and reports, 33 documenting SLOs and error budget\n\npolicy, 32\n\nestablishing error budget policy, 31 getting stakeholder agreement, 30 measuring the SLIs, 26-28 moving from SLI specification to imple‐\n\nmentation, 25\n\nusing SLIs to calculate starter SLOs, 28\n\nin SRE with customers, 394\n\nauditing monitoring and building shared\n\ndashboards, 395\n\nmeasuring and renegotiating, 396\n\nmanaging by, in SRE, 5",
      "content_length": 2769,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 503,
      "content": "minimizing risk to by canarying releases,\n\n343 refining\n\nexperimenting with relaxing SLOs, 41 grading interaction importance, 39 modeling dependencies, 40 modeling user journeys, 39\n\ntracking performance over time at Evernote,\n\n155\n\nusing for SRE practices without SREs, 399 using to reduce toil, 102 why SREs need them, 17\n\nservice lifecycle, SRE engagement during,\n\n372-374 abandoned phase, 374 active development phase, 373 architecture and design phase, 372 deprecation phase, 374 general availability phase, 374 limited availability phase, 373 unsupported phase, 374\n\nservice reviews (regular), performing, 381 services\n\nmultiple, supporting with single SRE team,\n\n382\n\nSRE rollout for, 414\n\nsharded LogJoiner (AdWords example), 254 sharing postmortems openly, 217 shift length for on-call SREs, 167 short term goals (SRE team), 379 side effects, interleaving with configuration\n\nevaluation, 319 silos, elimination of, 2 simplicity, 133-141\n\ncase study, end-to-end API simplicity, 134 case study, project lifecycle complexity, 134 escaping in configuration, 308, 326 regaining\n\ncase study, eliminating pDNS depend‐\n\nency on itself, 140\n\ncase study, running hundreds of micro‐ services on shared platform, 139 case study, simplifying Display Ads Spi‐\n\nderweb, 137\n\nsite reliability engineering (see SRE) site reliability engineers (see SREs) skewness SLO (Spotify case study), 292 SLAs (see service level agreements) SLIs (see service level indicators)\n\nSLOs (see service level objectives) software engineering, 400 software-defined networking (SDN), 107 source control, using with configurations, 330 speed of data retrieval (monitoring system), 62 Spotify case study, 287-299\n\ncustomer integration and support, 293-298\n\ncapacity planning, 295 development process, 296 documentation, 294 incident handling, 297 system monitoring, 294\n\nevent delivery, 288 event delivery system design and architec‐\n\nture, 289 data collection, 289 data delivery, 290 extract, transform, load process, 290 event delivery system operation, 290-293\n\nSRE (site reliability engineering)\n\nabout, 4 comparing and contrasting with DevOps, 7 development by Google and others, 43 organizational context and fostering suc‐\n\ncessful adoption, 9-12 practices without SREs, 399 principles, 4-7\n\nmanaging by SLOs, 5 moving fast by reducing cost of failure, 6 sharing ownership with developers, 6 using same tooling regardless of job title,\n\n7\n\nworking to minimize toil, 5\n\nreaching beyond your walls, 391-398 reasons for adoption by Evernote, 44 rollout for services, 414\n\nSRE engagement model, 371-389\n\nending the relationship, 385-389 scaling SRE to larger environments, 382-385 service lifecycle, 372-374 setting up relationship with development\n\nteam, 375-380\n\nsustaining an effective ongoing relationship,\n\n380-382\n\nSRE teams\n\nadjusting structures to changing circum‐\n\nstances, 384\n\ncohesive distributed SRE teams, running,\n\n384\n\nIndex\n\n|\n\n471",
      "content_length": 2920,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 504,
      "content": "forming new team at Google, 149-153\n\nafterword, 152 initial scenario, 149 maintaining playbooks, 152 training, 150 lifecycles, 399-422\n\nmaking more SRE teams, 413-418 starting an SRE role, 400-403 suggested practices for running many\n\nteams, 418-421\n\nyour first SRE team, 403-412\n\non-call engineers in survive the week cul‐\n\nture, 171-173\n\nsingle team supporting multiple services,\n\n382\n\nstructuring multiple SRE team environ‐\n\nment, 383\n\nwork overload when half a team leaves, case\n\nstudy, 358-360\n\nSREs (site reliability engineers) being on-call (see on-call) exchange program at Google, 419 funding and hiring, 421 mobility for, 419 starting an SRE role, 400-403\n\nbootstrapping your first SRE, 402 distributed SREs, 403 finding your first SRE, 400 placing your first SRE, 401\n\ntraining for, 419 why they need SLOs, 17 work overload (see overload, identifying\n\nand recovering from)\n\nstaging, 159 stakeholders, getting agreement from on SLOs,\n\n30\n\nstateful systems\n\ntraffic teeing in, 351 using autoscaling with, 237\n\nstatsd metric aggregation daemon, 69 storage systems, 23\n\nalternatives to filer-based home directories,\n\n123\n\nstorming (first SRE team), 405 stressors (psychological), identifying and allevi‐\n\nating, 367\n\nstring interpolation, 318 sunk cost fallacy, 359\n\n472\n\n|\n\nIndex\n\nsuperfluous (undesirable) language in postmor‐\n\ntems, 201\n\nsupport for services, deciding on, 11 survive the week culture, 171-173\n\nempowering ops engineers in SRE, 172 improving team relations, 172\n\nswaps (short-term) in on-call scheduling, 169 symptoms of overload, 366 system architecture, covering in interviews with\n\nSREs, 401\n\nsystem diagrams for data processing pipeline,\n\n271\n\nsystemic fixes for pager alerts, 164 systems\n\ncomplexity of, measures for, 132 keeping architectural drawings of, 133 maturity levels, 18\n\nT TCP, 226 team, existing, converting to SRE team, 404,\n\n409 risks and mitigations for, 407\n\ntemplates\n\nfor postmortems, 220 templating engines, using for configuration,\n\n318\n\ntesting templates in a configuration system,\n\n330\n\nusing for configurations, 326\n\ntesting\n\nalerting logic in monitoring system, 72 automated tests, 336 for configuration systems, 330 for preexisting bugs in production environ‐\n\nment, 159\n\nquick fixes for bugs, 162 software testing to reduce bugs reaching\n\nproduction, 159\n\ntesting pyramid philosophy in Spotify\n\ndevelopment process, 296\n\nunit and integration testing, data processing\n\npipeline, 283\n\nThe Home Depot (THD) (see Home Depot,\n\nSLO case study)\n\nthree Cs of incident management, 176 tickets\n\nnew ticket SLO in perceived overload case\n\nstudy, 361",
      "content_length": 2595,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 505,
      "content": "P1-P5 tickets in Evernote/Google relation‐\n\nship, 49\n\nSLOs in Home Depot case study, 53 support tickets for Home Depot services, 51 ticket toil, 98\n\ntiered SRE engagement, 140 time for postmortems, lacking, 219 time windows for SLOs, 29\n\nat Evernote, 46\n\ntimeliness SLO (Spotify case study), 291 toil\n\nconfiguration-induced, 315\n\nreducing, 316\n\ngetting ahead of by helping customers, 393 metrics in work overload, 367 working to minimize in SRE, 5\n\ntoil, eliminating, 93-129\n\ncase study, decommissioning filer-backed\n\nhome directories, 121-129 background, 121 decision on the solution, 122 design and implementation, 123 key components of the solution, 124-126 lessons learned, 127-129 problem statement, 121\n\ncase study, reducing toil in datacenter with\n\nautomation, 107-120 background, 107-110 decision on the solution, 110 design first effort, Saturn line-card\n\nrepair, 110\n\ndesign second effort, Saturn vs. Jupiter\n\nline-card repair, 112\n\nimplementation, Jupiter line-card repair,\n\n114\n\nimplementation, Saturn line-card repair\n\nwith automation, 111 lessons learned, 118-120 problem statement, 110\n\ncharacteristics and examples of toil, 94-96 measuring toil, 96-98 taxonomy of toil, 98-100 business processes, 98 cost engineering and capacity planning,\n\n100\n\nmigrations, 99 production interrupts, 99 release shepherding, 99\n\ntroubleshooting for opaque architec‐\n\ntures, 100\n\ntoil management strategies, 101-106 assessing risks in automation, 104 automating toil response, 104 engineering toil out of the system, 101 getting support from management and\n\ncolleagues, 103\n\nidentifying and measuring toil, 101 increasing uniformity, 103 legacy systems, 105 promoting toil reduction as a feature,\n\n103\n\nproviding self-service methods, 102 rejecting toil, 101 starting small, then improving, 103 starting with human-backed interfaces,\n\n102\n\nusing feedback to improve, 105 using open source and third-party tools,\n\n105\n\nusing SLOs to reduce toil, 102\n\ntooling\n\nin DevOps and SRE, 8 relationship with culture in DevOps, 3 using same tooling regardless of job title, 7\n\ntools\n\ncommon tooling adoption in SRE, case\n\nstudy, 432-439\n\nfor configuration systems, 330 for incident response, 190 for postmortems, 221 in configuration system, 310 increasing uniformity in, 103 using open source and third-party tools, 105\n\ntraffic teeing, 351 traffic volume metrics, 51\n\nSLOs in Home Depot case study, 52\n\ntraining\n\nfor incident response, 191 for SREs, 419 new SRE team at Google, 150 teaching customers, 393 to reduce perceived work overload, 364 using postmortems to train new engineers,\n\n218\n\ntravel for SRE teams, 420 triaging interrupts, 360 troubleshooting for opaque architectures, 100\n\nIndex\n\n|\n\n473",
      "content_length": 2693,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 506,
      "content": "truncated exponential backoff, 235 two-phase mutations, 279\n\nU ulimit utility, 334 unhealthy instances, handling, 236 uniformity, increasing, 103, 128 unsupported phase, service lifecycle, 374 user behaviors causing bugs to manifest, 160 user journeys, modeling, 39 user-centric view (configuration), 305\n\nmandatory and optional configuration\n\nquestions, 306\n\nquestions asked should be close to user\n\ngoals, 305\n\nusers\n\ndeciding reliability, 392 helping past difficulties, 393\n\nutilization\n\ninfrastructure utilization in Home Depot\n\ncase study, 52\n\nmeasurement in Home Depot case study, 51 monitoring system metrics on saturation, 71\n\nV VALET (SLOs at Home Depot), 53 versioning, using with configurations, 312, 329 virtual machines run by cloud provider, availa‐\n\nbility of, 48 visualizations, 33\n\n474\n\n|\n\nIndex\n\n(see also dashboards) for data processing pipeline, 283\n\nvolume (traffic), 51\n\n(see also traffic volume metrics) in Home Depot VALET SLOs, 53\n\nW Waze, scaling, change management case study,\n\n427-432\n\nwisdom of production, 5 work overload, 356\n\n(see also overload, identifying and recover‐\n\ning from)\n\nworkloads\n\ndistributing between geographically split\n\nSRE teams, 416\n\nSRE teams having complete self-\n\ndetermination of, 411 SRE teams regulating, 403 workload coverage, 397\n\nX x20 filesystem, 123\n\nY YAML, 320\n\nconfigs written in, JSON and, 323 JSON object encoded as YAML streams in\n\nKubernetes, 322",
      "content_length": 1415,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 507,
      "content": "About the Editors\n\nBetsy Beyer is a Technical Writer for Google Site Reliability Engineering in NYC. She has previously written documentation for Google Datacenters and Hardware Operations teams. Before moving to New York, Betsy was a lecturer on technical writing at Stanford University. En route to her current career, Betsy studied Interna‐ tional Relations and English Literature, and holds degrees from Stanford and Tulane.\n\nNiall Richard Murphy has been working in internet infrastructure for 20 years. He is a company founder, a published author, a photographer, and holds degrees in Com‐ puter Science & Mathematics and Poetry Studies.\n\nDave Rensin is a Google SRE Director, previous O’Reilly author, and serial entrepre‐ neur. He holds a degree in Statistics.\n\nKent Kawahara is a Program Manager for Google’s Site Reliability Engineering team focused on Google Cloud Platform customers and is based in Sunnyvale, CA. In pre‐ vious Google roles, he managed technical and design teams to develop advertising support tools and worked with large advertisers and agencies on strategic advertising initiatives. Prior to Google, he worked in Product Management, Software QA, and Professional Services at two successful telecommunications startups. He holds a BS in Electrical Engineering and Computer Science from the University of California at Berkeley.\n\nStephen Thorne is a Senior Site Reliability Engineer at Google. He currently works in Customer Reliability Engineering, helping to integrate Google’s Cloud customers’ operations with Google SRE. Stephen learned how to be an SRE on the team that runs Google’s advertiser and publisher user interfaces, and later worked on App Engine. Before his time at Google, he fought against spam and viruses in his home country of Australia, where he also earned his BSc in Computer Science.\n\nColophon\n\nThe animal on the cover of The Site Reliability Workbook is a green thornytail iguana (Uracentron azureum), an arboreal lizard that lives in the Amazon and other South American rainforests.\n\nThe skin of this lizard is a very vivid green, interspersed with black stripes. As its name suggests, it also has rows of spikes on its tail, but the purpose of these is unclear. The green thornytail lizard is rather small, at about 3.5 inches long, and is difficult to spot in the wild because it tends to live high in the forest canopy (where it can more easily bask in sunlight). Ants make up the bulk of the lizard’s diet, which it catches by using a “sit and wait” method until insects wander by its location on a tree.",
      "content_length": 2564,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 508,
      "content": "Many of the animals on O’Reilly covers are endangered; all of them are important to the world. To learn more about how you can help, go to animals.oreilly.com.\n\nThe cover image is from a loose plate, source unknown. The cover fonts are URW Typewriter and Guardian Sans. The text font is Adobe Minion Pro; the heading font is Adobe Myriad Condensed; and the code font is Dalton Maag’s Ubuntu Mono.",
      "content_length": 396,
      "extraction_method": "Unstructured"
    }
  ]
}