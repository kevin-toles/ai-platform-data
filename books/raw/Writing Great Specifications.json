{
  "metadata": {
    "title": "Writing Great Specifications",
    "author": "Unknown Author",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 308,
    "conversion_date": "2025-12-25T18:23:03.622238",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "Writing Great Specifications.pdf",
    "extraction_method": "PyMuPDF_fallback (Unstructured failed)"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Introduction to specification by example and Gherkin",
      "start_page": 28,
      "end_page": 57,
      "detection_method": "regex_chapter",
      "content": "5\nWhy do teams need specifications?\npromise is as reassuring as it is deceiving. In practice, creating a complete specification\nis extremely difficult, if not impossible.\n No software development team functions without specifications, though. Whether\nyou write an official document or have a casual conversation about the requirements\nduring a workshop, you’re still specifying.\n The one and only reason teams need specifications is information asymmetry. Teams\nneed to distribute information evenly among the stakeholders to create the best possi-\nble product. If they don’t, they’ll miss critical requirements and make an incomplete\nproduct—or even a broken one.\nDEFINITION\nInformation asymmetry—A situation in which one party has more\nor better information than another\nTo reduce information asymmetry, teams create specifications—recipes defining what\nneeds to be done or how it needs to be done. Specifications can help fight information\nasymmetry in two ways:\nA specification can define acceptance criteria that help examine whether a\nteam has delivered a complete system that works.\nA specification can provide a common language that allows technical and\nnontechnical stakeholders to understand each other when they talk about\nrequirements.\nWe’ll now go into more depth on both of these topics.\n1.2.1\nDefining acceptance criteria in specifications\nAssume that you and the public transport company’s management team have agreed\nthat the system you’re building should include two subsystems:\nAn internal management application for updating bus schedules\nA mobile timetable application with journey-planning functionality\nSounds reasonable, doesn’t it? The capabilities for both the employees of the com-\npany and its customers are clearly defined. But are they really?\n Every time you analyze a requirement, you’ll eventually stop talking about general\ncapabilities of the system and start thinking in terms of concrete, discrete quality mea-\nsures that the application must meet. When discussing our public transport company,\nI said that a good requirement would be to apply discounts when students or retirees\nbuy tickets. But how can you determine whether that requirement is satisfied without\ngoing into more detail? For example, you’d need to declare that students can have a\n30% discount and retirees can have a 95% discount. These two declarations would\nallow you to say that the requirement was in fact satisfied and implemented correctly.\nSuch quality measures are called acceptance criteria.\nDEFINITION\nAcceptance criterion—A condition or quality measure that a soft-\nware product must meet to satisfy requirements\n\n\n6\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nAcceptance criteria illustrate requirements. You should be able to use a criterion to\nevaluate the system and get an unambiguous confirmation that the system either\npasses or fails your test: for example, “A bus road should consist of at least two bus\nstops.” Right, and that’s how the system behaves. “Timetables for work weeks should\nbe different than timetables for weekends.” Oops, we forgot about that; let’s go back\nto the drawing board. You should be able to get a binary response to every criterion—\nas in yes or no questions. Without that binary response, you can’t say whether the sys-\ntem is complete and works as it should.\n Raw requirements are often too difficult to comprehend without further analysis.\nWithout clear acceptance criteria for each of the requirements, delivery teams can’t\nplan any work ahead and deliver any value in a predictable way. When there’s not a\ngood specification, functionality usually suffers from rework or bugs that cause delays\nand cost a lot. Good acceptance criteria ensure that the implemented solution meets\nthe demands of your stakeholders. \n1.2.2\nBuilding a ubiquitous language into specifications\nImagine for a moment that after you finish the beta version of the mobile journey plan-\nner, the customer support department receives a phone call from an angry customer:\nThe customer begins, “I downloaded the app to help me during my two-day stay in the\ncity. But I can’t get where I want!”\n“What street are you on? What’s wrong?”\n“I’ve got a meeting in Edison. I used your app to get there, but I can’t find the building\nI’m supposed to enter. It’s all wrong!”\n“Wait—do you mean Edison Street or Edison Business Center? They’re two different\nplaces.”\nThe customer wanted to plan the journey without knowing what street the destination\nbuilding was on, but the application didn’t support such a behavior. To add insult to\ninjury, the mobile app chose Edison Street, located elsewhere in the city, as the final\ndestination, because it couldn’t find Edison Business Center in the database.\n The result? The user and the application spoke two different languages, and the\nconfused customer got lost. The dictionary of the developers who built the app was\nrestricted to streets; after all, bus stops inherit their names from where they’re located.\nThat’s how the system works, the team said. What they didn’t know was that their cus-\ntomers don’t think about the rules of a system—they only want to arrive on time.\n To avoid similar mistakes, delivery teams should strive to grasp the language their\nusers speak and align their language with this language. The result of this alignment is\noften called a ubiquitous language.\nDEFINITION\nUbiquitous language—A common language between developers\nand domain experts\n\n\n7\nWhy do teams need specifications?\nA ubiquitous language is “a language cultivated in the intersection of [technical and\nbusiness] jargons.”8 The development of journey-planning software requires knowl-\nedge in two different domains: journey planning and software. Experts in both areas\nmust communicate understandably.\nDEFINITION\nDomain—What an organization does, and the world it does it in\nThe journey planners will use the jargon of their field and have limited understanding\nof the technical dictionary of software development. Developers, on the other hand,\nwill understand and discuss the system in terms such as objects, methods, and design\npatterns. Having a single common language eliminates the cost of mental translation\nand reduces the number of misunderstandings—the ratio of noise in the signal—in\ndiscussions between technical and nontechnical stakeholders. Translation blunts com-\nmunication and makes domain learning anemic.\n The journey planners from the example can also be called domain experts. Domain\nexperts help you create a ubiquitous language. When either the business side or the\ntechnical side discovers a misunderstanding, they can use the opportunity to improve\ntheir shared dictionary and avoid the same mistake the next time. This way, they build\na shared domain model, which will improve in quality over time.\nDEFINITION\nDomain expert—A person who is an authority in a particular area\nor topic. The term usually refers to a domain other than the software domain.\nDEFINITION\nDomain model—A simplification of the real-world business\ndomain. It’s an interpretation of reality that abstracts the aspects relevant only\nto solving the problem at hand.\nThe ubiquitous language fuels the domain model. Having a shared dictionary of\nimportant business concepts creates a platform for discussing data, behaviors, and\nrelationships within the model in a meaningful way, with a certainty that everybody is\non the same page. In the journey-planning example, the team thought that a destina-\ntion was the same as a street; but it turned out that users assumed there are other kinds\nof destinations, such as buildings and points of interest. Having established a baseline,\nthe team can use the common language to establish clear relationships between the\nconcepts of destinations, streets, buildings, and points of interests.\n A specification can help develop the ubiquitous language. It’s a container where\nall important domain concepts can be stored after they’re encountered and analyzed\nby the team. When that happens, and the process is thorough and successful, the spec-\nification becomes a documentation of the domain, the knowledge base of the delivery\nteam. When a specification fails to contribute to the ubiquitous language or doesn’t\ncreate a truthful domain model, the team may misunderstand requirements, which\noften leads to expensive rework. \n8 Eric Evans, Domain-Driven Design (Addison-Wesley, 2003).\n\n\n8\nCHAPTER 1\nIntroduction to specification by example and Gherkin\n1.3\nCommon specification pitfalls\nMuch of software engineering is about building systems right, but specifications,\nrequirements, and acceptance criteria are about building the right system. From time\nto time, every software engineer experiences a painful push-back caused by a sloppy\nanalysis of the requirements. You, too, know what’s at stake. This section should help\nyou identify some pitfalls you yourself may have encountered.\n I want to discuss these five anti-patterns:\nOver-specification\nHand-offs\nUnder-documentation\nSpeci-fiction\nTest-inability\nI named each anti-pattern in a distinctive way that will help you remember what it’s\nabout. Hopefully, as you go through the sections that follow, the names of the anti-\npatterns will become clearer to you, and I’ll achieve my goal.\n1.3.1\nOver-specification\nA popular first instinct meant to defend a project against ambiguity and insufficient\nplanning is to try to design and plan as much as we can up front. I call that over-\nspecification.\nDEFINITION\nOver-specification—Doing too much specification up front\nIt’s definitely easier to remove or change a requirement during an analysis phase; the\nmore time we invest in implementing it, the more unmotivated we become when we\nhave to kill it. The up-front approach aims to remove useless implementations, design\nflaws, and predictable errors as early as possible in exchange for a longer analysis\nphase. But software development teams must also understand that over-specification\ncan lead to a state of analysis paralysis.\nDEFINITION\nAnalysis paralysis—A productivity block created in search of the\nperfect—unattainable—design\nIn extreme cases, bureaucratic or regulated environments may demand over-specifica-\ntion by requesting specification documents that can run into thousands of pages.\n(Bear in mind, though, that analysis paralysis isn’t limited to written specifications.)\nBut unless you’re making software for surgeons, analyzing every single detail in\nadvance often feels unnecessary—even harmful. \n1.3.2\nHand-offs\nHanding off requirements looks like a classic waterfall mistake—an artifact from the\npast—but I still see agile teams struggling with hand-offs, often due to their organiza-\ntion’s internal politics. Any requirement can be handed off.\n\n\n9\nCommon specification pitfalls\nDEFINITION\nHand-off—A situation in which somebody analyzes requirements\nwithout the input of the delivery team, signs off on the scope by writing down\nthe analyzed requirements, and later hands off those requirements to the\ndelivery team to complete\nHand-offs result in a fragmented communication flow between business and delivery.\nIn my experience, people who hand off requirements are often business users, manag-\ners, analysts, product owners, or designers, depending on the chain of command in a\ngiven organization. In a management-oriented company, managers are more likely to\ncreate an environment where they can decide on the list of requirements and the\nscope, trying to maintain control over important decisions. I’ve seen the same thing\nhappen with design teams in design-oriented organizations. And engineers, too, can\nhand off requirements if they’re within their areas of expertise. (Think of technical,\nnonfunctional requirements such as performance, security, or low-level integrations.)\nNobody’s a saint.\n Such organizations mistake the communication structure for the organizational\nstructure. A company can be management-oriented, design-oriented, or engineering-\noriented and still have a healthy, collaborative, and inclusive process.\n Hand-offs cause various problems with delivery. A team that only receives a specifi-\ncation won’t understand the context in which the requirements were collected. Their\ndecision-making abilities will be impaired when it comes to split-second decisions. The\nteam won’t be able to make on-the-fly decisions because they won’t know the thought\nprocess that led to making the requirements the way they are. They will only see the\nfinal result—the specification. They may also be too afraid to change anything. And in\nover-specified documents, contradictions and ambiguities can occur easily. When\nhand-offs like these happen, misunderstandings creep in and cause expensive rework\nto appear later in the process.\nTIP\nDon’t let documentation replace communication. \n1.3.3\nUnder-documentation\nMany delivery teams burnt by over-specification discard it in favor of an implementation-\nfirst approach, eradicating any up-front practices. An implementation-first approach\noptimizes for writing software without dealing with wasteful documentation and speci-\nfications. It rejects huge design commitments before customers prove they want the\nsolution—and the only way to prove it is to hack some code together and release it as\nsoon as possible, rejecting any process that doesn’t help write production code. For\nexample, Extreme Programming advocates use no extra design documents and let the\ncode speak for itself. Running code doesn’t lie, as a document might. The behavior of\nrunning code is unambiguous.\n Initially, the implementation-first approach feels efficient, especially in young com-\npanies—but as the organization grows and the product matures, diseconomies of scale\nkick in. Not everyone is a coder. Communication and decision-making start causing\n\n\n10\nCHAPTER 1\nIntroduction to specification by example and Gherkin\ntrouble, and adding new people to the team slows work instead of making it faster. I\ncall such a specification anti-pattern under-documentation.\nDEFINITION\nUnder-documentation—Discarding documentation and letting\ncode speak for itself in order to speed up development\nUnderdocumented teams are left with no clear path to track decisions made in the\npast. Institutional memory suffers; when people who worked on implementation\nbecome unavailable, temporarily or permanently, they take their knowledge with\nthem. Building long-term understanding within the company often requires addi-\ntional facilitation. Many teams hurting from under-documentation realize its down-\nsides too late when fixing the problem gets painful.\nTIP\nDon’t let agile be an excuse to ignore documentation. \n1.3.4\nSpeci-fiction\nDocumentation and specification artifacts grow obsolete easily. As your product\nevolves over time, requirements often evolve, flat-out change, or turn out to be poorly\ndefined and have to be refined. Documentation and specifications, like all internally\ncomplex documents, are often too difficult to update on a regular basis without intro-\nducing some inconsistencies. Outdated and unwanted, they become speci-fiction. (Yes,\nI invented the word. No, I’m not a poet.)\nDEFINITION\nSpeci-fiction—A specification that poses as a single source of truth\nbut that can’t be one because nobody cares to update it\nIf you’ve ever struggled with outdated documentation, you’re already familiar with the\nphenomenon of speci-fiction. Sometimes documents are left outdated because of\nmultiple last-minute changes. In this case, the fiction in speci-fiction is that a new\nreader would be led to falsely believe that the specification or documentation\ndescribes the entire system as it is, when the working system is, in fact, different,\nbecause the requirements were changed during the release frenzy. Speci-fiction is\nonly an illusion of correctness—an illusion that occurs when no single, reliable source\nof truth exists. \n1.3.5\nTest-inability\nThe INVEST mnemonic for agile software projects is a common reminder of the char-\nacteristics of a good-quality product backlog item such as a user story (see table 1.1).\nMuch of INVEST is beyond the scope of this discussion; I won’t expand on the topic\ndirectly, but I already talked about such characteristics as valuable and small when I dis-\ncussed the difference between the right delivery and the right software at the begin-\nning of this chapter and when I talked about over-specification and long specification\ndocuments.\n\n\n11\nMeet specification by example and Gherkin\n \nI’d like to focus on the testability part, which many teams overlook. I’ve met many pro-\ngrammers and testers who, when working on a user story, weren’t sure where to start,\nwhat to test and what not to test, how much to test in one go, what to call their tests,\nand how to understand why a test fails.\n According to INVEST, testability should be baked into a good user story, because\ntestability lays the foundation for quality. How can you be sure that you delivered any\nbusiness value if you don’t know how to test its implementation? Or how can you know\nthat you’ll continue to deliver value in the future, regardless of any system changes or\nerrors? What I call test-inability is a team’s failure to answer questions like these—a fail-\nure that originates in a bad specification process.\nDEFINITION\nTest-inability—Lacking clear measures of value that can support\ndevelopment \n1.4\nMeet specification by example and Gherkin\nDelivery teams choose the implementation-first approach despite its shortcomings\nbecause it gives them the freedom, agility, and productivity they love. On the other\nhand, the up-front approach has the upper hand in consistently producing somewhat\nreliable documentation. Is there any method that combines the best of both worlds?\nFortunately, yes. Of the many tools and methodologies introduced by the community\nto reshape traditional specification methods, I find two particularly interesting and\nexplore them in the book: SBE and Gherkin.\n Specification by example, a set of practices that sprang from the agile acceptance-\ntesting tree, is a collaborative approach to defining software requirements based on\nillustrating executable specifications with concrete examples. It aims to reduce the\nlevel of abstraction as early in the process as possible, getting everyone on the same\npage and reducing future rework.\n Gherkin, a business-readable domain-specific language, provides a framework for\nbusiness analysis and acceptance testing. Gherkin helps you understand requirements\nfrom the perspective of your customers. By forcing you to think about what a user’s\nworkflow will look like, Gherkin facilitates creating precise acceptance criteria. The\nTable 1.1\nThe INVEST mnemonic\nLetter\nMeaning\nDescription\nI\nIndependent\nThe story should be self-contained.\nN\nNegotiable\nThe story should leave space for discussion about its scope.\nV\nValuable\nThe story must deliver value to the stakeholders.\nE\nEstimable\nThe delivery team should always be able to estimate the size of the story.\nS\nSmall\nThe smaller the story, the easier it is to analyze and estimate correctly.\nT\nTestable\nThe story should support test development.\n\n\n12\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nbook uses a Cucumber version of Gherkin’s syntax. If you don’t yet know what that\nmeans, don’t worry—I’ll explain everything in chapter 2.\n SBE and Gherkin reimagine the traditional software development process. Every\nsoftware development process follows similar phases as functionality progresses from\nconception to release (see figure 1.1). In most agile software development methodol-\nogies, the phases are as follows:\nPlanning implementation\nBuilding the product\nLaunching the product\nGetting feedback\nMany teams also fall into a trap of treating specifying as a one-time activity that occurs\nduring the planning phase, instead of as a process that keeps occurring as requirements\nevolve and change, which they often do throughout development. Teams that don’t\ntreat specification as a long-term process often behave like automata—machines\ndesigned to automatically follow a predetermined sequence of operations. In such a\ncase, the sequence is defined during the planning phase and must be followed as long\nas no problems occur. But when a problem does occur, it’s often already too late.\n With SBE and Gherkin, as shown in figure 1.2, we follow a different paradigm.\nThis paradigm requires us to use practices that must be performed throughout the\nentirety of a project—from analysis to maintenance. You’ll see why when I talk more\nabout designing acceptance tests (a testing activity) and building living documentation (a\nmaintenance activity). Instead of creating a static document with requirements, I’ll\ntalk about a system of dynamic specification documents that constantly evolves along\nwith the product.\n1. Plan\nSoftware\ndevelopment \nlife cycle\n3. Launch\n4. Feedback\n2. Build\nTraditional specification\nFigure 1.1\nThe place of specifications in the \ntraditional software development process\n\n\n13\nMeet specification by example and Gherkin\nIf you’re curious about what a specification written in Gherkin looks like, look at this\nexample:\nFeature: Setting starting points and destinations\nScenario: Starting point should be set to current location\nGiven a commuter that enabled location tracking\nWhen the commuter wants to plan a journey\nThen the starting point should be set to current location\nScenario: Commuters should be able to choose bus stops and locations\nGiven a bus stop at Edison Street\nAnd a Edison Business Center building at Main Street\nWhen the commuter chooses a destination\nThen the commuter should be able to choose Edison Street\nBut the commuter should be also able to choose Edison Business Center\nIn order to help you write specifications like this, the upcoming chapters will apply\nSBE’s key process patterns to Gherkin. You’ll be able to offer programmers, designers,\nand managers an inclusive environment for clear communication, discovering\nrequirements, and building a documentation system.\n1.4.1\nKey process patterns\nTeams that apply SBE successfully introduce seven process patterns into their work-\nflow.9 In an SBE process that uses Gherkin—which, as you’ll see later, is only one of\n9 Gojko Adzˇic´, Specification by Example (Manning, 2011).\n1. Plan\nSoftware\ndevelopment\nlife cycle\n3. Launch\n4. Feedback\n2. Build\nSpecification by example\nFigure 1.2\nSBE reimagines the software development process by prolonging \nthe specification process so that it takes place throughout the entire project.\n\n\n14\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nseveral ways of applying SBE—these seven patterns can be split into three distinct\ngroups revolving about the central concept of conversations (see figure 1.3).\n Patterns focused on having conversations aim to increase the knowledge flow between\nthe delivery team and the business as well as within the delivery team, without sacrific-\ning agility. Patterns that deal with automating conversations ensure that the specifications\nstay up to date throughout the project’s life cycle, allowing nontechnical stakeholders\nto check whether the use cases they care about work well within the system.\n Capturing conversations links analysis and automation. Having conversations can’t\nbe a separate development activity, just as you can’t write automated tests for the sake\nof writing tests. That’s where the real magic begins, and where you’ll meet Gherkin—\nit will let you write down your conversations in a form that’s easy to automate. \n1.5\nHaving conversations that identify business needs\nThe main premise of SBE and Gherkin is that frequent conversations between domain\nexperts and the delivery team lay a foundation for the entire development process\n(see figure 1.4). Here are some examples of conversations:\nThe public transport company’s management wants to build new modules into\ntheir timetables system, and you discuss their business needs together.\nAn angry customer explains that your mobile app shouldn’t interpret Edison\nBusiness Center as Edison Street because they’re not the same thing.\nAutomating\nconversations\nSpecification by\nexample and\nGherkin\nCapturing\nconversations\nHaving\nconversations\nRefining\nspecifications\nLiving\ndocumentation\nValidating\nfrequently\nAutomating tests\nbased on\nexamples\nDeriving scope\nfrom goals\nSpecifying\ncollaboratively\nIllustrating\nrequirements\nusing examples\nFigure 1.3\nA high-level look at SBE’s process patterns\n\n\n15\nHaving conversations that identify business needs\nTwo engineers discuss whether the system should treat a bus route as a collec-\ntion of 2D points on a map or a straight line between the start point and the des-\ntination point.\nA commuter files a bug report about the bus-scheduling functionality.\nYou read customer feedback on social media and discover what new functional-\nities users want.\nFrom these examples, we can reason that a conversation means a discussion between\nthe business and the technology. Business domains and technology domains interact\nbecause they have to—if you want to create any software, let alone working software or,\nsometimes, even successful software, the team must understand the business context\nand have required technical excellence. The sections that follow analyze the topics\nthat such interactions can follow.\n1.5.1\nDeriving scope from goals\nConversations typically revolve around four questions:\n1\nWhy are we building this?\n2\nWho are we building this for?\n3\nWhat exactly are we going to build?\n4\nHow will we build it?\nExplore possible solutions with\nconcrete examples to choose the\nbest implementations.\nFind the answers together\nwith business stakeholders.\nAnswer why, who, what, how.\nAutomating\nconversations\nSpecification by\nexample and\nGherkin\nCapturing\nconversations\nHaving\nconversations\nDeriving scope\nfrom goals\nSpecifying\ncollaboratively\nIllustrating\nrequirements\nusing examples\nFigure 1.4\nHaving conversations should provide delivery teams with \nall the answers necessary to understand a project’s goals, and who \ncustomers are and what solutions they need.\n\n\n16\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nSome answers come from the business domain and others from the technology\ndomain (see figure 1.5). Usually, the business domain provides the who and the why,\nand the technology domain provides good what and how answers.\n In general, answering questions at the top of the list will give you enough input to\nask and answer the questions at the bottom. Such a practice—getting from business\nobjectives to programmable solutions—is what SBE’s practitioners call deriving scope from\ngoals. Over the last five years, deriving scope from goals emerged as probably the most\nimportant practice in the modern landscape of software development.\n Every major conference now features someone talking about the value of delivery\npeople understanding business goals and designing software according to their com-\npany’s objectives. Techniques such as impact mapping, feature injection, and user-\nstory mapping have spread widely, changing the business analysis landscape. I, too,\nwill talk about these techniques throughout the book.\n The questions I listed help delivery teams understand why a solution is needed and\nwho needs it. Answering them means discussing the company’s goals and establishing\nsuccess metrics. The goals and metrics, in turn, allow you to determine the scope of\nfuture work the team must deliver and build a framework that will let the team say\nwhether they’re making progress in terms of reaching their goals. \n1.5.2\nIllustrating requirements with examples\nSBE and Gherkin require delivery teams to support their conversations with practical\nexamples. Illustrating requirements with examples helps reduce the level of abstraction\nand leads to clearer acceptance criteria—especially if the examples are concrete\ninstead of vague.\n Humans prefer stories illustrated with examples. Say you were a lawyer who wanted\nto explain to your friend how splitting royalties works. If you said, “The writers should\nsplit the salary based on their contribution,” your friend might not have a good idea\nBusiness needs\nand problems to solve\nDesign and\narchitecture\nThe business\ndomain\nConversation\nWho and why\nRequirements\nWhat and how\nSolutions\nThe technical\ndomain\nFigure 1.5\nThe business and \ntechnology domains must meet over the \ncourse of a conversation if you want to \nunderstand the business goals and set \nthe optimal project scope.\n\n\n17\nHaving conversations that identify business needs\nof what you meant. Each of you might understand the concept of “contribution” dif-\nferently. But let’s change that to “Here’s an example: John, Gilly, and Robbie wrote a\n250-page book together. John and Gilly wrote 100 pages each, so they should get 40%\nof the salary, because they each wrote 40% of the book—and Robbie, who wrote only\n50 pages, should get 20% of the salary, just as 50 is 20% of 250.” This time, your friend\nwould probably grasp the full idea in a split second.\n Clear storytelling invites good examples, because examples help us build better\nmental models of the new concepts we encounter. They’re anchors. Links. Cognitive\nshortcuts. Most important, they reduce the likelihood of misunderstanding the pur-\npose of a story. Requirements illustrated with good examples inherit all these benefits.\nThey’re simpler to digest and easier to keep in your head.\n Let’s look at a conversation without any concrete examples and a conversation full\nof examples to see if that’s true. Here’s the first conversation:\n“Okay, so how should the application work?”\n“I suppose that when commuters download our mobile app, they should be able to provide\na starting point and a destination point, and see a timetable with all the bus lines and\ndeparture times they might find helpful in getting to the destination. It’s very simple,\nreally.”\n“Seems that way.”\nSuch a conversation raises more questions than it answers. What are the starting\npoints and destination points? Are they streets? Bus stops? Buildings and other places?\nAnd what exactly may a commuter “find helpful in getting to the destination?” There’s\nno way we can know for sure.\n What would happen, though, if we asked for concrete examples during the discussion?\n“OK, so how should the application work?”\n“Let’s not jump to conclusions. Imagine for a moment that you’re going to the city, say,\non a business trip. How and when do you get there?”\n“Well, I guess I might arrive a day earlier to be sure nothing goes wrong.”\n“So we’re going to need a functionality to filter the timetables by date.”\n“Yes, we are. But let’s consider what happens if the you’re a bit more happy-go-lucky and\narrive in the city an hour before the meeting. You don’t have enough time to check where\nyou are. Or maybe you don’t know the exact street you must arrive at.”\n“Wow, we might need to implement a GPS geolocation functionality so we could help\nusers know their current location.”\n“Yeah, and there should be an option to search for locations such as parks, buildings,\nand restaurants instead of only bus stop names.”\n“Seems that way.”\nConversations with examples look similar to short stories about a system’s behaviors.\nGood stories are vivid and build a platform for fertile discussion between the people\n\n\n18\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nwho read them. Bad stories confuse readers and leave people clueless. The same is\ntrue for good and bad specifications. \n1.5.3\nSpecifying collaboratively\nAs you’ll see in the sections to come, SBE and Gherkin redefine the distinction\nbetween analysis, design, and implementation by building a bridge between require-\nments and code. The practitioners should see the act of specifying as a process of con-\ntinuous discovery through reducing their uncertainty about the requirements.\nSpecifying is not a single activity or a phase to go through. In an agile process, require-\nments evolve as a project progresses because rarely does the knowledge exist up front\nto specify an application adequately.\n Every time you have a conversation about your product, every time you ask a ques-\ntion about a requirement, every time you encounter a bug, every time you hear cus-\ntomer feedback—you’re discovering whether your assumptions about the product are\ntrue or false. You’re learning.\n Sometimes, though, organized effort may be required to produce a reliable,\nrepeatable specification process in a complex environment with multiple stakehold-\ners. In such cases, SBE encourages specifying collaboratively by inviting the stake-\nholders to specification workshops or holding smaller, more regular meetings within\nthe delivery team.\n The participants should use the specification workshops to capture and refine\ngood, concrete examples that emerged when the delivery team tried to derive scope\nfrom the business goals. They should then match the examples with requirements and\nacceptance criteria, letting the examples guide their analysis efforts.\n Depending on the size of the team and the complexity of the product, specifica-\ntion workshops can range from multiday sessions featuring every important stake-\nholder to short, regular meetings between product owners, senior engineers, and\ndesigners. These workshops put a strong emphasis on knowledge sharing. Including\ndiverse participants guarantees exploring multiple perspectives and covering different\nangles. Knowledge should flow freely within the team. Analysts, designers, developers,\nand testers should strive to understand what they’re about to build, asking as many\nquestions as they deem relevant. To achieve a common perspective on how customers\nwill use the software, participants should learn the ubiquitous language of the busi-\nness owners and the customers. Long story short, they should build a short-term\nunderstanding of the requirements that will guide their efforts in planning and\nduring implementation.\nWARNING\nThe topic of organizing and facilitating specification workshops,\nalthough important, is beyond the scope of the book, which focuses on writ-\ning skills. I only talk about workshops briefly in section 7.4. Chapter 7 is also\nwhere I mention a few resources and techniques for organizing workshops.\nFor now, I advise you to read Gojko Adzˇic´’s original Specification by Example;\nchapter 6 talks about collaborative specification. \n\n\n19\nLong-term benefits of automating conversations\n1.6\nLong-term benefits of automating conversations\nAfter the delivery team collects examples, team members create specifications out of\nconversations recorded in Gherkin. They automate the conversations and examples\nwith software tests, validating the tests frequently to make sure the specifications stay\nup to date (see figure 1.6).\nI’ll now talk about the elements of the automation process and why automating speci-\nfications gives delivery teams an enormous advantage. Don’t be surprised that I\nhaven’t yet discussed recording conversations in Gherkin, even though the translation\nprocess is a prerequisite for automation. I want you to understand the benefits and\nchallenges of team specification and automation first, so that you’ll be free to draw\nyour own conclusions when we explore Gherkin.\n1.6.1\nAutomating tests based on examples\nSBE requires delivery teams to use conversations to collect meaningful examples that\nhelp the team understand the requirements. From examples, tests are created. Good\nexamples make tests better and more business-driven by covering real-world use cases\nprovided by business stakeholders and customers. In the end, tests verify whether the\ndelivery team implemented requirements correctly. You can see the schematics of this\nprocess in figure 1.7.\nConversations and examples are\nautomated as software tests.\nTests based on examples can  \nbe run upon each build when \nany errors are signaled.\nTests and their conversations\nbecome documentation.\nAutomating\nconversations\nSpecification by\nexample and\nGherkin\nCapturing\nconversations\nHaving\nconversations\nLiving\ndocumentation\nValidating\nfrequently\nAutomating tests\nbased on\nexamples\nFigure 1.6\nAutomation turns conversations into executable test cases \nthat, if validated frequently, become long-term system documentation.\n\n\n20\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nAutomating ties conversations and examples to system behaviors. Tests return binary\nresponses about every conversation you capture. A conversation either passes your\ntest, meaning the behavior was implemented correctly, or it fails the test, meaning the\nsystem is incomplete or broken.\n If an example passes the test, you know that the acceptance criterion illustrated by\nthe example is still relevant. If the test is failed, you’re notified that the changed code\nbase no longer satisfies the acceptance criteria. If that’s the case, the examples should\nchange to reflect that—and sometimes the code has to change, too. (The code could\nbe right and the example now outdated, or the example could be right and the code\nwrong. In each case, you fix a different thing.)\n Why is that? Imagine that the example public transport company introduces new\nexpress buses. These vehicles skip most of the bus stops on their way, in order to get to\nthe destination point more quickly. Your team now needs to add express buses to the\nmobile app. It’s a simple change in terms of code: somebody must add a new attribute\nto the database that determines whether a bus line is an express line or a regular one.\nEasy peasy. You make the change quickly and then take a lunch break.\nThat’s when all hell breaks loose. (Almost.)\nThe team forgot that the timetables module isn’t the only one affected. The mobile\napp also features a live map that shows how the buses closest to the user move around.\nA commuter can check which buses are which in the legend on the map. The legend\nis generated automatically, but adding the new type of express bus broke the program-\nming logic behind it. As a result, the legend has disappeared. For the few days before\nyou notice the problems, commuters not only aren’t able to distinguish express buses\nfrom regular buses—they aren’t able to find any buses on the map.\nIf you had any documentation in place, the change made it inaccurate and out-\ndated. Nobody updated the document, because your team wanted to have lunch.\nThat’s what usually happens: people forget, production hotfixes creep in, the Four\nHorsemen of the Apocalypse drop by. And when the dust settles, your carefully pre-\npared documentation no longer reflects the current state of the system. In this case, it\ndoesn’t tell the reader that there are two types of buses, and it doesn’t explain the dif-\nference between them. Step by step, with every hotfix and every negligent change, the\ndocumentation becomes irrelevant. \nExamples\nRequirements\nVerify\nElaborate\nCan become\nTests\nFigure 1.7\nCollecting examples that illustrate \nrequirements is the first step to create \nmeaningful, business-driven, automated tests.\n\n\n21\nLong-term benefits of automating conversations\n1.6.2\nValidating frequently\nNone of these problems would arise if your conversations and examples were auto-\nmated. When conversations are run as tests, you can regularly track which ones\nbehave correctly and which ones don’t. If you test frequently and your specification is\nexhaustive, you’ll get instant feedback after you make a change to the code base.\n You can validate during the development process or before a release—what mat-\nters is that you must do it often. The more often you test, the sooner you can spot pos-\nsible errors.\n Captured conversations should be validated against both the existing system and\nnew code as it’s being written. If you validate conversations frequently, you can have as\nmuch trust in the specification as you have in the code. This way, you create a more\naccessible way to review implemented requirements for all stakeholders.\n Because SBE and Gherkin see development as a process of constant discovery\nthrough reducing uncertainty about requirements, the model of the system is, by defi-\nnition, not fully defined from the beginning—it’s only defined well enough. It evolves\ncontinuously based on feedback from stakeholders, and new examples and domain\nconcepts enter the specification as new elements are added to the code. To make sure\nthese new examples fit into the system, delivery teams need a process of continuous\nintegration.\nDEFINITION\nContinuous integration—A software development practice where\nmembers of a team integrate their work frequently. Each team member\nshould integrate as often as possible, leading to multiple integrations per day.\nEach integration is verified by an automated build to detect integration errors\nquickly.\nIf the team uses a testing tool (like Cucumber, a Gherkin-compatible test runner),\nthe tests can be run on each software build. If any errors are signaled, they can be\ncaught early and fixed, letting the “integrate, build, test” process start again—this\ntime, successfully. \n1.6.3\nLiving documentation\nAs much as we’d like it to be otherwise, only working production code holds the truth\nabout the system. Most specifications become outdated before the project is delivered.\nBecause every product is a machine made out of thousands of moving parts, the dat-\ning problem becomes a curse of all software projects.\n Outdated documentation may seem like a reliable source of knowledge about the\nsystem, but it only misleads its readers. An automated, frequently tested specifica-\ntion—as well as the examples included in it—is resistant to such problems. The direct\nconnection between scenarios and code often reduces the damage by cultivating a sys-\ntem of living documentation.\n \n\n\n22\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nDEFINITION\nLiving documentation—Documentation that changes along with\nthe system it documents, thanks to the link between the text and the code as\nwell as frequent validation.\nWhen tests keep specifications in check, they let specifications with examples evolve\ninto a documentation system. Using executable specifications as living documentation\nmeans taking advantage of automation to facilitate learning within the team and their\ndecision-making abilities. When Gherkin scenarios are free of unnecessary technical\nbloat, well written, accurate, and full of business-oriented examples and domain\nvocabulary, they can serve as a single source of truth that everyone uses to learn about\nthe functionalities in question.\n Thanks to frequent validation, you know that your tests, examples, and conversa-\ntions are up to date; and when you trust your tests, you can use them as documenta-\ntion for the entire system. You can track every test back to its origin—the conversation\nyou had with your stakeholders about the requirement. When in doubt, you or any-\none else on your team can always check the captured conversation. Frequent valida-\ntion also guarantees that the documentation must change every time the underlying\ncode changes, because the documentation is connected to the code through tests.\n A living documentation system should benefit everyone. Specifying collaboratively,\nillustrating requirements with examples, and refining specifications for readability—\nall these measures should involve everyone who matters in the requirement-analysis\nprocess, or a few dedicated people can make the requirements as easy to understand\nas possible for everyone else. Everyone involved should be able to read the results,\ntoo. Tools such as Relish, Cucumber Pro, and CukeHub can even integrate with a\ncode repository of your choice and publish the scenarios in a private cloud where you\ncan collaborate and share executable specifications and test results with other team\nmembers, as easily as you can share a document in Google Docs. \n1.7\nCapturing conversations as executable specifications\nOkay, so automating conversations offers a lot of benefits. But how do we automate\nthem? At the beginning of section 1.6, I promised that we’d come back to the topic of\nrecording conversations in a language that will help you optimize them for automa-\ntion. This section discusses the refinement process that makes free-flowing conversa-\ntions easy to automate (see figure 1.8).\n Specification workshops allow for having conversations. Programmers and testers\nare responsible for automation. How does the translation process happen? Should\nprogrammers store conversations as comments in their testing code? That would be\nridiculous—but the records have to be written somewhere, don’t they? A free-flowing\nconversation is, by definition, an unreliable medium that only stimulates short-term\nmemory. We need long-term storage.\n As introduced earlier, Gherkin is the tool for capturing conversations about\nrequirements in a formalized way, clarified by extracting essential information and\nremoving noise. Gherkin facilitates knowledge sharing among all stakeholders,\n\n\n23\nCapturing conversations as executable specifications\nregardless of their technical skill. It does so by conveying tests and requirements in a\nready-for-automation template that’s expressed in plain English and that uses the\nubiquitous language of a product.\n Gherkin focuses on capturing conversations as scenarios. Scenarios preserve essen-\ntial information and remove noise by extracting concrete actions from conversations.\nDEFINITION\nScenario—A concrete example that illustrates a business rule\nFollowing is an example of a scenario. Remember the conversation about how the\nmobile app for journey planning should work?\n“Let’s imagine that you’re going to the city on a business trip. When do you get there? ...\nIf you’re a bit happy-go-lucky and arrive in the city an hour before the meeting, you don’t\nhave enough time to check where you are.”\n“Wow, we might need to implement a GPS geolocation functionality, so we could help\nusers know their current location.”\nHere’s the same conversation expressed in Gherkin:\nGiven a commuter that enabled mobile location tracking\nWhen the commuter wants to plan a journey\nThen the starting point should be set to current location\nThis sequence is called the Given-When-Then template. I’ll talk about it in detail in\nchapter 2, where you’ll learn the basics of using the template.\n Thanks to its focus on user actions, Gherkin is a great language for conveying\nbehavioral requirements. Just as having conversations improves a delivery team’s short-\nterm understanding, capturing conversations ensures that they don’t let that knowl-\nedge slip through their fingers in the future. Scenarios achieve that and remind us\nConversations must be written\nexplicitly in an automation\ntemplate and refined to feature \nonly key examples. \nAutomating\nconversations\nSpecification by\nexample and\nGherkin\nCapturing\nconversations\nHaving\nconversations\nRefining\nspecifications\nFigure 1.8\nThe capture process aims to preserve verbal product-design chats and \ntranslate them to lightweight, long-term, formalized stories that, in time, can be used \nto put together system documentation.\n\n\n24\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nthat we don’t need 100-page functional requirements documents to capture what’s\nvaluable. We don’t even have to write all the scenarios up front. We can capture a few\nscenarios at a time, as we discuss each new requirement. A few months in, we’ll have a\nhuge library of relevant scenarios. We only need to be consistent.\nDEFINITION\nBehavioral requirement—A requirement formed as a story about\nhow users behave when they interact with the system. Whereas normally\nrequirements can be formed as abstract statements, behavioral requirements\nalways talk about examples of using the system.\nThe contents of the template should use nontechnical language that relies heavily on\nreal-world business concepts. Notice how the example mentions commuter, journey, and\nthe starting point—concepts borrowed from the business vocabulary of the public\ntransport company—but doesn’t say anything about low-level development proce-\ndures or the application’s user interface. Scenarios captured using the Given-When-\nThen template should stay at a business-readable, code-free level at all times, improv-\ning the domain model and building its ubiquitous language.\nWARNING\nIf you see anything about a connection to the database in a Gher-\nkin scenario, or read about buttons or any other UI element, somebody made\na huge mistake.\nBecause programmers and testers can automate anything put in the Given-When-\nThen template, scenarios written in Gherkin become executable specifications. This book\nwill teach you to write executable specifications in Gherkin and use the Given-When-\nThen template. You’ll also learn the rest of the Gherkin syntax required to capture\ndesign conversations in a form that easily translates to executable specifications.\nDEFINITION\nExecutable specification—A specification that can be run as an auto-\nmated test\nThe syntax serves as a link between speech, text, and automated code. It lets you prog-\nress naturally from one to another. Gherkin also provides techniques to organize sce-\nnarios into full documents, link similar behaviors, and simplify capture and\nautomation, all while keeping things at a business-readable level derived from the\nubiquitous language.\n Most executable specifications contain many scenarios, and every scenario needs\nmultiple examples. In its rough form, an example is like a quick note or a doodle. It\nmakes sense when you look at it a day after you made it, but try examining it six months\nlater—not so meaningful anymore, right? That’s why successful teams don’t use raw\nexamples; they refine them. A team extracts the essence of key examples and turns it\ninto clear, unambiguous, organized specification documents, as shown in figure 1.9.\n As new requirements appear, acceptance criteria generate new examples, and\nevery example generates a new scenario. To refine executable specifications, teams\nmerge similar examples, reject examples that introduce noise, and choose the most\n\n\n25\nMaking software that matters\nmeaningful or descriptive examples. The result is an executable specification in its\nfinal form, ready to become the foundation for the living documentation system. \n1.8\nMaking software that matters\nYou’ve now begun the journey of mastering executable specifications written in Gher-\nkin according to SBE’s key practices. As you learn more about SBE and Gherkin, we’ll\nfocus on practicing techniques that help you avoid common specifying pitfalls. When\nsoftware engineers and designers don’t put enough thought into their specifications,\nthe cost is measured in weeks of work and hundreds of thousands of dollars wasted.\n The benefits of SBE and Gherkin go far beyond reducing rework. You’ll get better\ninsight into your business domain and reduce friction caused by inevitable translation\ncosts that come up when a business requirement becomes working software. People\nmade these tools and processes because they wanted to guarantee that the software they\nhelp build will make sense to customers. They wanted to make software that matters.\nRaw examples\nRaw scenario\nRaw examples\nAcceptance\ncriterion\nRaw scenario\nRefined example\nRefined scenario\nRefined example\nRaw examples\nRaw scenario\nRefined scenarios contain\nonly key examples needed to\nunderstand the criterion.\nAn acceptance criterion \nneeds examples that pass \nor fail the criterion.\nRaw examples generate\nraw scenarios that often \nhave similar structure.\nFigure 1.9\nThe process of refining raw examples extracted from collected acceptance \ncriteria into refined scenarios with key examples\nSBE, BDD, or ATDD?\nWhen I started my journey with executable specifications, like many other practitioners\nI was confused by the naming issues around the topic of agile acceptance testing.\nWhen I found out that many people call SBE behavior-driven development (BDD) or\nacceptance test-driven development (ATDD), I didn’t understand the difference.\n\n\n26\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nBecause this is a book about practical application of executable specifications with\nexamples, it mainly deals with capturing conversations in Gherkin and refining exam-\nples. It’s a long-ignored topic due to Gherkin’s seemingly easy syntax and elusively low\nentry barrier. Many software engineers and designers think they need a quick tutorial\nand then can start writing. It’s only a simple Given-When-Then sequence, right?\n Yes and no. Everything depends on the project you’re dealing with. At first, having\nexecutable specifications will yield better alignment without much training—but com-\nplex products with complicated business domains can go astray quickly. Hundreds of\nrequirements will produce hundreds of Gherkin files you have to manage. And every\nfile will contain multiple scenarios, and every scenario will attach additional example.\nThat sounds like Gherkin and SBE don’t fit huge projects well; but, truth be told, huge\nprojects will stretch every process and tool. As you’ll see, executable specifications\nwith examples shine the brightest in complex environments—but that’s why I’m writ-\ning a book, and not a blog post.\n You don’t have to be able to write testing code to read the book. I’ll cover automat-\ning conversations only as long as it introduces good patterns that will make life easier\nfor your engineers. Having said that, we should always value business-oriented specs\nover specs that are easy to automate. Similarly, I won’t talk about anything related to\nhaving product-design conversations during specification workshops, unless it directly\nimpacts you when writing specifications in Gherkin. There are other resources that\nteach these skills well enough.\n I do expect you, however, to understand the basics of the automated testing process\nand why it matters. Practical knowledge about the QA process will be helpful in some\nof the later chapters. If you have a technical background or are experienced in work-\ning with developers and QA engineers in any agile methodology, you’ll be fine. I also\n(continued)\nMy confusion was deepened by the fact that I became interested in SBE after reading\nGojko’s book, but the first project where I was able to practice writing executable\nspecifications used Gherkin. In his book, Gojko wrote that he didn’t “want to use any\nof the Driven Development names, especially not Behavior-Driven Development.” But\nGherkin was invented by Dan North and Chris Matts, and Dan North is the main face\nof BDD. I was perplexed.\nI wanted to avoid naming controversies, because they aren’t key to what you’re going\nto learn. I honestly admit that I borrowed freely from both fields, trying to create a mix\nthat will maximize benefits and minimize mental load. Dan North calls BDD a meth-\nodology; but, quoting Gojko, what I wrote here doesn’t form a fully fledged software\ndevelopment methodology. My only goal is to teach you to write great Gherkin speci-\nfications using SBE practices. So whenever I talk about a practice or an idea derived\nfrom SBE, I’ll tell you that up front. Everything else will appear under the umbrella\nterm of Gherkin and good Gherkin practices; if you want to read more about it, you\ncan assume it comes from the field of BDD.\n\n\n27\nSummary\nexpect you to understand what it takes to release a product, from its conception\nthrough the public announcement to long-term maintenance. Some of the things\nwe’ll discuss will cover not only initial requirements but also possible changes in scope\nthat a product can face at a later stage of its life cycle.\n What will you learn? The next chapter explores Gherkin and SBE in practice. You’ll\nbegin by capturing requirements and acceptance criteria as executable test cases. As\nyou progress through the book, you’ll tackle more-advanced topics. You’ll learn to\nwrite good scenarios. You’ll see how to choose good examples. You’ll design business-\noriented error checks. When the time comes, you’ll move on from thinking about\nsuites of specifications, and you’ll learn to organize scenarios into groups of coherent\nspecification documents that readers can navigate easily. I’ll also talk about how the\nubiquitous language shapes examples and scenarios, and how to evolve specifications\ninto a living documentation system over time.\n Right now, though—right now, welcome to specification by example and Gherkin. \n1.9\nSummary\nA specification is a description of the system design required to implement the\nsystem.\nAcceptance criteria let you review whether you’ve built a complete system.\nA ubiquitous language is a common language among developers, business\nstakeholders, and end users. It makes every stakeholder sure they’re talking\nabout the same things.\nSpecification by example is a business-analysis process aiming for “just enough,”\njust-in-time software design. Lightweight examples provide enough initial con-\ntext to start development and are later refined into more-sophisticated forms.\nGherkin is a business-readable language for writing specification documents.\nGherkin’s practitioners capture conversations about requirements in the form\nof behaviors—also called scenarios—which are examples of how the system is\nexpected to behave.\nAn executable specification is a conversation captured using the Given-When-\nThen template with a corresponding acceptance test. The acceptance test\nmakes sure the delivery team has implemented the underlying requirement\ncorrectly.\nEvery executable specification’s life cycle starts with a specification that later\nbecomes an automated test. Automating the specification ensures that it stays\nup to date, because the captured conversation is directly tied to testing code.\nThis way, tests become documentation.\nGherkin and SBE arm you with software development techniques that facilitate\nknowledge sharing, reduce short-term waste without sacrificing long-term docu-\nmentation, and help the delivery team deliver software faster and without\nrework thanks to meaningful, concrete examples of system behaviors that\nensure everyone’s on the same page.\n\n\nPart 1\n Writing executable\nspecifications with examples\nP\nart 1 of this book consists of six chapters that discuss the ins and outs of writ-\ning executable specifications in Gherkin. Chapters 2 and 3 will teach you about\nGherkin—the language in which you’ll write scenarios. Chapters 4 and 5 discuss\nthe art of writing a special kind of scenario called a scenario outline, as well as\nchoosing good examples. Chapters 6 and 7 talk about what happens when a\nspecification is “finished,” explain its life cycle, and go into depth about creating\na living documentation system.\n\n\n31\nThe specification layer\nand the automation layer\nIf you haven’t worked with Gherkin and specification by example (SBE) before,\nchapter 1 may have shown you your first Gherkin scenario (listing 1.1). We haven’t\nyet written a full Gherkin specification document together, though, and we’ll need\nmore practical examples to do that.\n Chapter 1 also talked about how conversations captured in Gherkin become\nautomated tests and how automation keeps executable specifications up to date.\nBut we didn’t discuss any details. What does automation mean in the context of SBE?\nHow can you automate conversations? Are there any tools you can use? These are\nall legitimate questions.\nThis chapter covers\nUnderstanding an executable specification’s \nlayers\nUnderstanding the structure of those layers\nWriting your first Given-When-Then scenarios\nExploring how the specification layer interacts \nwith testing code\n\n\n32\nCHAPTER 2\nThe specification layer and the automation layer\n In this chapter, you’ll learn to write a simple executable specification from scratch.\nThroughout the chapter, you’ll work on an example of a calendar application that\nschedules meetings for its users. (Think Google Calendar.) You’ll write a simple sce-\nnario about what it takes to create new meetings. By doing so, we’ll also explore the\nbasics of the relationship between the two layers of every executable specification, in\norder to understand the technical limitations behind the Given-When-Then template.\n2.1\nThe layers of executable specifications\nEvery executable specification has two layers: a specification layer and an automation layer\n(see figure 2.1). Without the specification layer, an executable specification wouldn’t\nbe a specification. Without the automation layer, it wouldn’t be executable. This sec-\ntion provides a brief overview of both.\n This book deals mainly with the specification layer and the writing aspect of exe-\ncutable specifications—the art of writing Gherkin. But to do that well, you need to\nknow the basics of the automation layer, too. That’s because automation requires the\nspecification layer to be written in a certain way that allows computers to read it.\nReading Gherkin listings\nA quick note on how to read the Gherkin listings placed here and there throughout\nthe book. Because the goal is to get as close to writing the perfect Gherkin scenario\nas possible, some of the listings are rated on a scale from [BAD] to [BEST]. (Not all\nscenarios are comparable, so not all are rated.)\nListings marked [BAD] are anti-patterns, should be avoided, and are mentioned only\nto warn you about their bad effects. The [OK] listings are neither good nor bad; they’re\nmediocre. The [GOOD] and [BETTER] listings are at the quality level you should strive\nfor after reading this chapter. And the [BEST] listings contain non-obvious solutions\nthat become possible only after you’ve applied the advanced tips and tricks from this\nchapter. The best scenarios don’t happen every time, but when they do, it’s extremely\nsatisfying.\nAutomation layer\nExecutable\nspecification\nSpecification layer\nFigure 2.1\nEvery executable specification in Gherkin has two layers \nthat complement each other and create automated tests written in \nnatural language.\n\n\n33\nThe layers of executable specifications\n2.1.1\nThe specification layer\nSimply put, the specification layer of an executable specification is the document you\nread when you want to know what you’re going to build. Gherkin specifications are\nusually short, and even a small project will have multiple documents—all of these doc-\numents together form a large specification layer for the entire project.\nDEFINITION\nSpecification layer—Contains text documents written in Gherkin\nthat humans can read\nIt’s important to understand these three elements of the specification layer (see figure 2.2):\nAcceptance criteria\nScenarios\nThe ubiquitous language\nI’ll talk about acceptance criteria, scenarios, and the ubiquitous language in detail\nlater in the chapter, but here’s a brief summary. Chapter 1 said that specifications talk\nabout requirements and acceptance criteria that the delivery team needs to under-\nstand if they want to implement new features correctly. Gherkin organizes the accep-\ntance criteria by conveying them as scenarios written using the Given-When-Then\ntemplate. The scenarios become elaborate expressions of the ubiquitous language,\nwhich is a common language among developers, business stakeholders, and end users.\nAs you saw in chapter 1, the scenarios are a way to store conversations about require-\nments in a written form: they’re a reflection of how the delivery team talks with the\nbusiness about important domain concepts. You’ll see a similar situation play out later\nin this chapter.\nAutomation layer\nExecutable\nspecification\nSpecification layer\nStores acceptance\ncriteria\nCultivates the\nubiquitous\nlanguage\nConveys\nacceptance criteria\nas scenarios\nFigure 2.2\nThe specification layer of an executable \nspecification is the layer where conversations about \nacceptance criteria are conveyed as Given-When-Then \nscenarios that create the most accurate reflection of the \nubiquitous language between technology and business.\n\n\n34\nCHAPTER 2\nThe specification layer and the automation layer\nHere’s an example of some simple Gherkin text:\nFeature: Teams\nScenario: Enforcing access rules\nFor more information on availability, please look at the\ninvite confirmation scenarios later in the specification.\nIn short, an unavailable person who already confirmed RSVP\ncan be invited to another event at the same time, but will\nbe able to attend only one of them.\nGiven Mike, Kate, and John were assigned to the same team\nAnd Ada was assigned to another team\nWhen Kate and Mike schedule a 1 hour long meeting at 4 p.m.\nThen John should see that Kate and Mike will be unavailable\nBut Ada shouldn't be able to see Kate and Mike's meeting\nAs explained in chapter 1, the sequence within each scenario is called the Given-When-\nThen template. The template and some other repeatable structures visible in the exam-\nple are what enable automation of every Gherkin document.\n The specification layer is created by writing feature files.\nDEFINITION\nFeature file—A file with a .feature extension written in Gherkin\nthat groups related scenarios within a document that provides a specification\nfor a single functionality\nAs a matter of principle, both technical and nontechnical stakeholders can have\naccess to the specification layer of the specification suite. They should be at least able\nto read and understand it if they have to. But as I mentioned, the specification layer\nalso has to be formatted in a way that allows for automation, so some constraints, pre-\ndefined grammar, and strict syntax are always present. This chapter will show you the\nbasics of Gherkin’s automation syntax later on.\nDEFINITION\nSpecification suite—A collection of all executable specifications\nand the testing code for a single project. This collection is usually put in the\nreal codebase where it can be automated and executed. \n2.1.2\nThe automation layer\nThe programmers and testers on your team will use scenarios to write the testing\ncode. The testing code is the executable part of your executable specifications. Every\npart of the specification suite related to executing automated tests is contained within\nan automation layer.\nDEFINITION\nAutomation layer—The automation layer executes a simulation of\nthe implemented application to see if the code behaves as defined in the\nspecification.\nTo make a long story short, every time you want to write a Gherkin specification like\nthe one shown earlier, you have to add a new .feature file to the specification layer of\n\n\n35\nThe layers of executable specifications\nyour specification suite, write the scenarios there, and then add the testing code to the\nsuite (see figure 2.3).\n A specification suite is a kind of test suite. In software development, a test suite is a\ncollection of test cases that are intended to be used to test a software program to show\nthat it implements a specific set of behaviors. Because the tests for executable specifi-\ncations share some qualities with traditional tests but are different in other aspects,\nthe name should be both familiar and new—thus, a specification suite.\n It’s important to understand these three aspects of the automation layer (see figure 2.4):\nThe automation layer is a simulation of a working application that behaves as the\nGiven-When-Then scenarios tell it to.\nThe simulation performs acceptance tests that check whether the system under\ntest behaves in an acceptable way.\nThe automation layer is designed to be a feedback loop that makes accepted spec-\nifications pass the testing process and rejects specifications that weren’t\naccepted, marking them as broken.\nExecutable\nspecification\nExecutable\nspecification\nExecutable\nspecification\nSpecification suite\nExecutable\nExecutable\nExecutable\nspecification\nspecification\nspecification\nSpecification layer\nAutomation layer\nFigure 2.3\nA specification suite, as well as every executable \nspecification in the specification suite, can be split into two layers—\nthe specification layer and the automation layer—which work \ntogether to create a functional testing process.\nAutomation layer\nSpecification layer\nUses feedback\nloops\nRuns acceptance\ntests\nSimulates a\nworking\napplication\nExecutable\nspecification\nFigure 2.4\nThe automation layer runs a \nsimulation of the system, which uses a \nseries of acceptance tests to check \nwhether the system under test works as \nyou expect it to.\n\n\n36\nCHAPTER 2\nThe specification layer and the automation layer\nI’ll talk about feedback loops more in chapter 6 when we get to the topic of an execut-\nable specification’s life cycle.\n As an example of how the automation layer works, suppose you want to test\nwhether a calculator app works well. To do so, you need some samples of addends and\nthe results you expect the calculations to return. The automation layer will then be\nable to execute the testing code responsible for performing calculations and see\nwhether the result returned by the code matches the expected result defined in the\nspecification (see table 2.1).\nTable 2.1\nAn example of the automation layer’s behavior\nInput given\nAutomation layer\nExpected output\n1 + 0\nThe testing code runs …\n1\n1 + 1\nThe testing code runs …\n2\n1 + 2\nThe testing code runs …\n3\n1 + (-1)\nThe testing code runs …\n0\nRunning the automation layer with Cucumber\nThe Given-When-Then template’s syntax enables automation. That’s why tools like\nJBehave and Cucumber use Gherkin, which is a more elaborate evolution of the tem-\nplate. But Gherkin isn’t the only available option. Different tools for automated accep-\ntance testing impose their preferred syntax differently. Some tools, like FitNesse, use\na wiki-like system as the main way of organizing the specification layer.\nJBehave, Cucumber, and FitNesse are all test execution engines.\nDEFINITION\nTest execution engine—A type of software that’s written to\nautomatically test other software. Throughout the book, I use terms\nsuch as test execution engine, test runner, testing framework, and auto-\nmation framework interchangeably.\nThis book teaches a Cucumber-flavored version of Gherkin.\nDEFINITION\nCucumber—A testing framework that can match Gherkin\nfeature files with testing code. It lets programmers run the code that\nautomates the scenarios.\nCucumber emerged from the Ruby community, but it also supports or has an equiva-\nlent for .NET, C++, JS, Lua, PHP, Python, and JVM. It can run Gherkin files written in\nmore than 60 spoken languages—among them Chinese, French, Arabic, and Pirate\nEnglish.a\na https://github.com/cucumber/cucumber/wiki/Spoken-languages.\n",
      "page_number": 28
    },
    {
      "number": 2,
      "title": "The specification layer and the automation layer",
      "start_page": 58,
      "end_page": 81,
      "detection_method": "regex_chapter",
      "content": "37\nThe layers of executable specifications\n \nA huge variety of learning resources is already available that teach how to deal with\nthe automation layer, so instead this book focuses on mastering the Gherkin layer—a\ntopic that’s underrated by many developers and testers. Also, because you can use\nGherkin with many programming languages such as Ruby, Java, and Python, I wanted\nto stay as language agnostic as possible. If you’re curious about how to write and exe-\ncute automated tests, you can easily find a lot of articles on the web. This chapter\nincludes a brief introduction to the topic of automation, explaining only as much as is\nneeded to understand the depths of the specification layer. \nThe division of labor is simple (see the following figure). Gherkin handles everything\nrelated to capturing conversations about the business logic, from rewriting accep-\ntance criteria as scenarios to modeling the business domain using the ubiquitous lan-\nguage. Cucumber, on the other hand, allows the delivery team to test the system\nusing the same examples that were captured during the analysis and design phases.\nWhy did I choose Cucumber and Gherkin for the book? According to the popularity of\nits open source repository, Cucumber is rising as the most popular testing framework\nsupporting executable specifications, decisively beating both JBehave (10 times as\npopular) and FitNesse (twice as popular). But I discuss a lot of techniques throughout\nthe book that can come in handy for people who use other test runners, too. (Unfor-\ntunately, there are some differences between Cucumber’s Gherkin and JBehave’s\nGherkin in terms of syntax and indentation; due to the scope of the book, you’ll have\nto research the differences between Cucumber and JBehave on the your own.)\nYou’re probably wondering, “Will this book teach me to automate executable specifi-\ncations with Cucumber?” Spoiler alert: it won’t. If you want to read more about auto-\nmating Gherkin tests with Cucumber, read the appendix. It’s a quick tutorial about\nhow to write and run simple automated tests for your feature files. I have to warn you,\nthough: the appendix covers only the basics.\nExamples\nStores acceptance\ncriteria\nConveys acceptance\ncriteria as scenarios\nCultivates the\nubiquitous language\nSimulates the\napplication\nCucumber\nGherkin\nRuns acceptance\ntests\nUses feedback \nloops\nExamples act as a link between Gherkin and Cucumber. The system \nis tested using the same examples that were collected when the \ndelivery team first analyzed the requirements.\n\n\n38\nCHAPTER 2\nThe specification layer and the automation layer\n2.2\nWriting your first Gherkin scenario\nAt the beginning of this chapter, I mentioned that you’ll work with an example of a\ncalendar application for teams, similar to Google Calendar (see figure 2.5). Every cal-\nendar application must allow teams to schedule meetings—to keep things simple,\nthat’s the one and only thing you’re going to specify today.\n2.2.1\nFeature\nIt’s time to write some Gherkin. This section presents a step-by-step tour of writing your\nfirst scenario. To begin, create an empty text file in any text editor of your choice.\n Every Gherkin .feature file starts in a similar manner. You’ve already seen it twice\nin previous examples of executable specifications:\nFeature: Scheduling\nFeature is Gherkin’s word for indicating that a new specification has begun—what fol-\nlows is the name of the feature being documented. Conventionally, every feature file\nconsists of a single Feature in order to encourage writing many small files rather than\na few large specifications.\nWARNING\nDon’t get too used to the Feature keyword. In chapter 8, you’ll\nreplace it with more-advanced keywords such as Ability and Business Need\nthat allow for better categorization of requirements.\nBelow the Feature line, you can add a description of the feature. It’s expected to\ndescribe the business value of this feature or to provide additional information that\nmakes the feature easier to understand. In this book, I call this a specification brief.\nDEFINITION\nSpecification brief—Specification line containing important pieces\nof information such as an answer to the question of why a specification was\nwritten in the first place, who the most important stakeholder is, and why they\nneed it.\nFigure 2.5\nYou could imagine your application is a simpler clone of Google Calendar, Microsoft Outlook, or any \nother popular scheduling software you and your friends use.\n\n\n39\nWriting your first Gherkin scenario\nFor the time being, let’s keep the feature file simple. Given the example’s scope, you’ll\nspecify only one or two scenarios. You should inform the reader where other scenarios\ncan be found.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nFrom the point of view of Gherkin’s syntax, the first line is the most important,\nbecause the Feature: part can never be changed. (Okay, there are two exceptions,\nbut I’ll talk about them at the end of the book.) The spaces in front of what follows\nare important, too, because the spaces tell Cucumber what the file’s structure is.\nThere are no strict rules or limitations regarding vertical spacing between the first line\nand the specification brief. Personally, I like to add a blank line because I think it\nmakes the document clearer. But if you don’t agree, you don’t have to do that.\n2.2.2\nScenario\nIn chapter 1, I said that Gherkin captures behavioral requirements. Behavioral\nrequirements are formed as stories about how users behave when they interact with\nthe system. In Gherkin, these stories are called scenarios. In this section, you’ll start\nwriting your first scenario.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nListing 2.1\nFeature line followed by a specification brief\nListing 2.2\nYour first scenario\nSpecification brief\nExercise 1\nWrite the rest of the specification brief that explains who will use the scheduling fea-\ntures and why they need them, based on what you know about the application. You\ncan draw some inspiration from the description of the app at the beginning of this\nsection. \nName of the scenario\n\n\n40\nCHAPTER 2\nThe specification layer and the automation layer\nIn this example, the Scenario line lets both the reader and the automation frame-\nwork know that a new scenario begins below it. If a scenario needs additional elabora-\ntion, you can place any amount of free-flowing text between the Scenario line and the\nfirst Given. It’s similar to the specification brief, and that’s why it’s called a scenario\nbrief. There are multiple ways to use the free-flowing space, as we’ll discuss through-\nout the book: for example, to provide definitions for domain-specific concepts, which\nyou’ll see in action in chapter 7 during the discussion of living documentation.\n Every scenario should do the following:\nDefine context (the Givens)\nDescribe an event that occurs within the system (the Whens)\nEnsure that expected outcomes take place (the Thens)\nThe sequence is called the Given-When-Then template.\n The Givens explain what needs to happen so you can watch the rest of the scenario\ntake place. The Whens neatly organize the template around a single behavior of the sys-\ntem, so a reader doesn’t have to wonder what the purpose of the scenario is. The\nThens clarify the consequences of taking that action.\n The Given-When-Then template is a simple yet powerful tool. It often works as a\nharmonious system. A slight change anywhere may influence a new change elsewhere.\nGivens, Whens, and Thens influence each other, but sometimes they force entire sce-\nnarios to change—and when scenarios change, sometimes entire specifications must\nchange as well. I talk more about this in chapter 3, which covers all the details of the\ntemplate. \n2.2.3\nGiven\nAh, the Givens. Givens answer a single question: what are the prerequisites that allow\nthe scenario to happen?\n For example, when a scenario’s main action is, as in this case, creating a meeting,\nthere must be some users who will be able to perform the action—so a user account\nmust have been created first.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nGiven a user\nListing 2.3\n[OK] Your first Given\nGiven that’s been added to the scenario\n\n\n41\nWriting your first Gherkin scenario\nTIP\nYou can see that there are two more spaces before the Given. Scenarios\nrequire additional indentation because it helps Cucumber understand which\nGivens, Whens, and Thens belong to which scenarios.\nGiven a user—that sounds vague, doesn’t it? All apps have users. And pretty much\nanyone can be a user. First, this naming doesn’t explain anything. Second, you’re work-\ning hard to make your application unique; the specification should reflect that, too.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nGiven a team member\nBetter! Now, you can at least see that the scheduling feature is about collaboration. A\nteam member sounds a bit abstract, though—and software should be made for real people.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nGiven Mike, a member of our team\nUsers play key roles in scenarios, and it’s a good practice to use unique, real names for\nseveral reasons. I talk about them in the next chapter, when I introduce the topic of\noutside-in development. Right now, I’ll give you a simple example. Let’s say that two\nusers appear in a single scenario. Calling them team member 1 and team member 2 would\nsound awkward, wouldn’t it? That’s why you’ll specify Mike—because Mike doesn’t\nsound awkward, and when things aren’t awkward, more people read and understand\nthem. Hello, Mike. Do you like Gherkin? (I bet he does. It’s the sole reason you\nbrought him into existence). \nListing 2.4\n[BETTER] Your first Given, reworked\nListing 2.5\n[BEST] Your first Given, reworked a second time\nA more specific Given\nA Given with a real person\n\n\n42\nCHAPTER 2\nThe specification layer and the automation layer\n2.2.4\nWhen\nGivens create the context in which the rest of the scenario takes place. Let’s keep the\nmomentum going and specify what the main action of the scenario should be. And,\nbecause Whens describe key actions the user performs, this is the perfect job for a new\nWhen. Let’s add one to the scenario.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nGiven Mike, a member of our team\nWhen Mike chooses 2 p.m. as a start time for his meeting\nAs you can see, you’re aiming for an example as concrete as possible: in addition to\nthe user introduced in the previous step, you’ve added specific hours. Also notice that\nthe second step is aligned to the right so the word When ends at the same place Given\ndoes. This is a community convention that you’ll see in many feature files, but it isn’t\nobligatory. You could also write\nGiven Mike, a member of our team\nWhen Mike chooses 2 p.m. as a start time for his meeting\nwithout aligning the When to the right under Given. We’ll continue to use this conven-\ntion throughout the book, though.\n Note that the scenario has already introduced some simple terms into your prod-\nuct’s ubiquitous language: a meeting, a team member, a start time. If programmers or\ndesigners read the scenario, they’ll adopt this dictionary without having to invent their\nown terms. Left to their own devices, technical experts often invent artificial names\nbecause they don’t know any better, and introducing artificial terms almost always wid-\nens the communication gap between business and delivery, instead of bridging it.\n Every scenario should preferably have only one When, because that makes scenarios\nclearer and easier to read. I’ll talk more about such design rules in chapter 3, where\nyou’ll learn about specifying user tasks and choosing the right abstraction level for\nyour scenarios. \n2.2.5\nThen\nAn action without an outcome is wasted. The part of the Given-When-Then template\nthat asserts the outcome is the Then—so why don’t you add it to the scenario?\nListing 2.6\nYour first When\nPrerequisite needed for the \nmain action to happen\nMain action\nof the\nscenario\n\n\n43\nUnderstanding the structure of steps and scenarios\n \nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nGiven Mike, a member of our team\nWhen Mike chooses 2 p.m. as a start time for his meeting\nThen he should be able to save his meeting\nThens describe consequences. In this case, choosing a valid start time for a meeting\nresults in successfully creating the meeting. A Then is usually a concrete representa-\ntion of the rule your criteria try to enforce. The representation is usually a change in\nthe system. For example, it may be something new that was created—like Mike cre-\nated his first meeting—but it may also be something that was removed or rephrased.\n The main difference between the scenario in listing 2.7 and the acceptance crite-\nria you usually see is that the scenario seems much more personal. That’s because\nAcceptance criteria are the abstract rules of the system; scenarios tell stories\nabout people who use the system according to these rules.\nHuman beings discuss and remember stories much better than they do abstract\nrules.\nAdding a Then means that, in eight simple steps, you’ve arrived at a full Gherkin spec-\nification starting from an empty text file. You now have a simple test that specifies what\nneeds to happen if you want to create an event.\n2.3\nUnderstanding the structure of steps and scenarios\nNow’s the perfect time for a quick theoretical break. Let’s slow down to process all the\ninformation discussed regarding the specification layer, from the standpoint of the\nautomation layer. Givens, Whens, and Thens are also known as steps.\nDEFINITION\nStep—The smallest unit of any Gherkin specification. It’s usually\na single line of text.\nListing 2.7\nYour first Then\nPredicate\nMain action\nConsequence \nof the action\nExercise 2\nWrite a simple scenario for canceling a meeting. Remember to specify proper conse-\nquences, so people won’t show up to canceled meetings!\n\n\n44\nCHAPTER 2\nThe specification layer and the automation layer\nAll steps work on two levels:\nA step describes the business logic of the application in natural language.\nEach step is closely related to its underlying testing code, which checks whether\nthe business logic described is implemented properly.\nFrom the technical point of view, every step consists of a restricted keyword and the\nstep’s content written in natural language that follows the keyword:\nDEFINITION\nKeyword—A special word used to optimize the specification layer\nfor automation. Keywords are imposed and enforced by the test execution\nengine. They must appear in every executable specification written in Gherkin.\nEvery keyword has a specific function to serve:\n\nGivens execute testing code needed to run a scenario: for example, creating\naccounts or prepopulating the database with example data.\n\nWhens execute the main action of a scenario that’s expected to change the state\nof the application by adding new data to the database, editing existing data, or\nintegrating with an external service like email.\n\nThens measure consequences of a scenario’s main action to check whether the\nstate of the application changed as you expected it to.\nThere are also other keywords such as But and And—they’re replacements that help\nyou avoid using the same word multiple times in a row. They make scenarios flow\nmore naturally.\n Here’s a full list of the keywords supported by Gherkin. Some of them you already\nknow; others you’ll meet later in this chapter and in the chapters yet to come:\n\nFeature\n\nBackground\n\nScenario\n\nGiven\n\nWhen\n\nThen\n\nAnd\n\nBut\nGiven Mike, Kate, and John were assigned to the same team\nKeyword\nStep\n\n\n45\nTesting different outcomes\n\nScenario Outline\n\nExamples\nScenarios and features use keywords to maintain their structure, too.\n You probably remember the Feature keyword. In chapter 8, you’ll learn that Fea-\nture can be replaced with more-specific keywords such as Ability and Business\nNeed. They can help you differentiate between your requirements and organize them\nin a clearer way—but for now, Features are all you need. Similarly, the Scenario key-\nword lets both the reader and the automation framework know that a new scenario\nhas begun.\nNow is the perfect time for the quick theoretical break to end. You can be proud of\nyourself. A few pages in, you already know most of Gherkin’s syntax. Be alert, though:\nwe’re not done yet. \n2.4\nTesting different outcomes\nLet’s review the scenario again. It’s a good practice to do so once in a while, for two\nreasons. First, Gherkin is prose—sometimes a bit awkward, but still prose. And prose\nstriving for readability and clearness needs constant reviewing—especially if it’s writ-\nten by technical people. (Ask my editors.) Second, every scenario is also a test, and\ndelivery teams should continuously work on improving their tests in case they missed\nanything when they wrote them in the first place.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nListing 2.8\nExpected output of the scenario\nExercise 3\nFind all the keywords in the Gherkin file that you’ve written so far in this chapter, sep-\narate the keywords from the steps, and write the results in a table. Try to memorize\nthe keywords; they’re the most basic ones, but they’re also the most popular.\nUnderstanding indentation in Gherkin’s syntax\nYou may have noticed that, like Python and YAML, Gherkin is a line-oriented language\nthat uses indentation to define structure. You can use spaces or tabs, but it’s usually\nconsidered a good practice to use spaces, because they maintain the structure more\neasily on everyone’s computers.\nLine-oriented languages require you to keep every command within a single line. You\ncan’t write a two-line Given, for example. The only exceptions to the single-line rule\nare free-flowing descriptions such as the specification brief and scenario briefs. Free-\nflowing descriptions aren’t part of the Given-When-Then template, and they don’t\nmake any difference when it comes to automation. That’s why you can format them\nhowever you want.\n\n\n46\nCHAPTER 2\nThe specification layer and the automation layer\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nGiven Mike, a member of our team\nWhen Mike chooses 2 p.m. as a start time for his meeting\nThen he should be able to save his meeting\nHave you noticed anything weird?\n This scenario looks perfect—too perfect, some might say. Mike accomplished a total\nsuccess without breaking a sweat. How often does that happen in reality? As a person\nwhose job is to make software for a living, you know the answer all too well. It never hap-\npens. When real people interact with software, not only does a total success rarely\noccur, but sometimes it’s flat-out impossible—and the results look more like carnage.\n Developers, designers, testers, and analysts can never assume that customers will\nuse their products in a linear manner. They must always prepare to specify multiple\npaths a user can choose.\n To see why, let’s get back to the example. We’ve taken SBE’s commitment to con-\ncrete examples seriously: you can’t get more concrete than the 2 p.m. start time in the\nWhen. Have you asked yourself, though, whether there’s any possibility that the start\ntime may fail? For example, what would happen if Mike chose 2 p.m. as the start time,\nbut it was already 3 p.m.? Wouldn’t that break the scenario?\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a new meeting successfully\nGiven Mike, a member of our team\nAnd that it isn't 2 p.m. yet\nWhen Mike chooses 2 p.m. as a start time for his meeting\nThen he should be able to save his meeting\nScenario: Failing at creating a new meeting\nGiven Mike, a member of our team\nAnd that it's already 3 p.m.\nWhen Mike chooses 2 p.m. as a start time for his meeting\nThen he shouldn't be able to save his meeting\nListing 2.9\nTwo similar scenarios with different outcomes\nPrerequisite that guarantees \na positive outcome\nPositive\noutcome\nPrerequisite that guarantees \na negative outcome\nNegative \noutcome\n\n\n47\nHow the automation and specification layers interact\nBy writing two different outcomes for the same action, you’ve written your first compre-\nhensive test in Gherkin. You can either pass or fail a test. In order to make sure your\nspecification suite has acceptable scenario coverage, you must specify both what hap-\npens when a user takes a successful approach, as well as an unlucky approach.\n Testers usually call scenarios with positive outcomes happy paths. Beginning with\nthe happy-path scenario is a good way to establish a key example as a foundation from\nwhich to think about other possibilities. Fortunately, testing heuristics suggest a multi-\ntude of other paths, including angry paths, scary paths, embarrassing paths, forgetful\npaths, and so on. We’ll talk more about all the possibilities in chapters 4 and 5, which\nare about choosing good examples for your executable specifications.\n2.5\nHow the automation and specification layers interact\nThe two scenarios in listing 2.8 are your first real tests written in Gherkin. But didn’t I\nsay in chapter 1 that SBE’s practitioners automate their tests? How does that happen? I\ntalked a bit about Cucumber, the test execution engine, earlier in this chapter, but I\nhaven’t said anything concrete. How are you going to write good tests in Gherkin with-\nout learning to write real testing code in Cucumber? Is that even possible? Let’s\ndecouple these worrisome questions and take them one by one.\n2.5.1\nStep definitions\nCucumber executes the testing code within something called a step definition.\nDEFINITION\nStep definition—An implementation of the testing code for a sin-\ngle step. Step definitions are containers for the testing code that must be exe-\ncuted in order to run the steps in the automation layer.\nFor example, let’s consider possible step definitions for testing a notification email\nthat’s sent after Mike creates his event. You can find some practical examples of step\ndefinitions in table 2.2.\nTable 2.2\nWhat needs to happen under the hood to test whether an email was sent?\nKeyword\nTesting code in the step definition\nGiven\nEstablish connection to the database, populate it with some testing data, or configure \nthe application to a desirable state\nWhen\nSimulate sending an email based on the data fetched from the database\nThen\nCheck if the email was sent by integrating with the mailing service’s internal queue\nExercise 4\nWhat are other circumstances that may result in failures when Mike creates a meet-\ning? Write a third scenario that adds more detail to the specification. You can use a\nscheduling conflict in Mike’s calendar as a reason for failure, or you can invent your\nown example. \n\n\n48\nCHAPTER 2\nThe specification layer and the automation layer\nIn theory, the relationship between features, steps, and step definitions is pretty sim-\nple. Figure 2.6 illustrates the high-level flow.\n Every feature contains multiple scenarios that contain multiple steps. These steps\nhave corresponding step definitions that are responsible for running the automation\ncode that affects a simulation of a system, as well as checking whether the code yields\nexpected results. \n2.5.2\nMatching steps with step definitions\nA middle-sized Gherkin project can contain between 200 and 600 scenarios. If you\nassume that every scenario has at least 3 steps, each of which is one of each kind, that’s\nbetween 600 and 1,800 steps in a single specification suite. And remember that, unlike\nkeywords, a step’s content isn’t predefined; you can write whatever you like as long as\nit fits within a single sentence and makes sense, given the rest of your scenario. All in all,\nthat’s a lot of content and a lot of step definitions to execute. How does that happen?\n In general, Gherkin files must be parsed by a testing framework that matches steps\nand their step definitions (see figure 2.7). That’s precisely what Cucumber does.\n From a technical point of view, every step’s content is matched with a step defini-\ntion within the automation layer—like in a search-and-replace operation in any text\neditor you’ve ever used. Here’s the general rule for matching step definitions:\nStep's content <- Testing code\nYou can read this expression as the general rule, “the left-hand side can be replaced\nwith the right-hand side.” When anything that matches the left side—a step—is found,\nit’s replaced with whatever the right side—testing code—contains. Table 2.3 lists some\nsimple, practical examples with dummy testing code written in Ruby. If you want a\nmore advanced explanation, check out appendix A.\nFeature files\nStep definitions\nTesting code\nSimulation of\na system\nSteps explain what the \nsystem should do.\nStep definitions list actions \nthat need to be taken in code \nto execute the feature.\nTesting code executes the \nactions on a running \nsimulation of a system.\nFigure 2.6\nGherkin features test a \nsimulation of the working system with \ntesting code executed through step \ndefinitions.\n\n\n49\nHow the automation and specification layers interact\n \nTable 2.3\nSpecific steps matched with their step definitions\nStep’s content\nStep definition’s code\nPurpose\nMike, a member of our \nteam\n@mike = \nUser.create(name: \n\"Mike\")\nCreate Mike’s account.\nthat it isn’t 2 p.m. yet\nTime.freeze(\"1 p.m.\")\nFreeze the time of the system’s \nsimulation to make sure the \nevent is valid.\nMike chooses 2 p.m. as a \nstart time for his \nmeeting\n@meeting = \nMeeting.create(start_tim\ne: \"2 p.m.\", user: \n@mike)\nAttempt to save Mike’s meeting \nin the database.\nhe should be able to save \nhis meeting\nexpect(@meeting.saved?).\nto eq true\nEnsure that the system saved \nMike’s meeting properly.\nhe shouldn’t be able to \nsave his meeting\nexpect(@meeting.saved?).\nto eq false\nEnsure that the system didn’t \nsave the incorrect meeting.\nGiven Mike, Kate, and John were assigned to the same team\nBusiness logic expressed in natural language\nStep\nTesting code validating the implementation\nAutomation engine\nGiven(/^Mike, Kate, and John were assigned to the\nsame team$/) do\n \n@john = create_user(\"John Appleseed\")\n \n@mike = create_user(\"Mike Johnson\")\n \n@kate = create_user(\"Kate Middleton\")\n \nteam = Team.create(name: \"Team A\")\n \n[@john, @mike, @kate].each do |person|\n \n \nperson.update_attributes(team: team)\n \nend\nend\nStep definition\nFigure 2.7\nThe testing code contained in step definitions is matched \nto examples and scenarios through regular expressions executed by \nthe automation engine. Steps and their step definitions are inseparably \nconnected. Steps describe the business logic in natural language; step \ndefinitions allow the automation engine to run the testing code needed \nto check whether the step’s business logic is implemented correctly.\n\n\n50\nCHAPTER 2\nThe specification layer and the automation layer\nYou’ll notice, first, that Cucumber rejects keywords when matching a step. Cucumber\nbehaves like that because in some advanced cases, you may want to write interchange-\nable steps; for example, you may want a When from one scenario to become a Given in\nanother scenario. I’ll talk more about why you might want to do so in chapter 3. Sec-\nond, Cucumber matches the rest of the step with the testing code in a step definition\nwith the step’s name.\n Only together can Gherkin and Cucumber work as an end-to-end tool. The specifi-\ncation layer elaborates requirements and acceptance criteria in natural language\nusing important real-world examples. The examples, expressed in steps, become links\nthat connect acceptance criteria with automated tests—the automation layer—\nthrough regular expressions (see figure 2.8). The tests make sure the system behaves\nas the requirements should require it to.\nYou could write scenarios without using Cucumber, but they wouldn’t be executable.\nAnd if they weren’t executable, they wouldn’t become acceptance tests. Without accep-\ntance tests, you couldn’t easily know when to update the scenarios when the system\nbreaks or changes. And why would you keep outdated scenarios? You’d probably dis-\ncard them just as you discard the sticky notes with user stories after you finish the story.\n That’s why the system works only if every acceptance criterion becomes a scenario,\nscenarios become tests, and tests control the design of the system by validating the sys-\ntem frequently with the testing code. These three steps make a cohesive whole: a spec-\nification process that covers your development efforts from start to end.\nExamples\nexpressed in steps\n• Scenario\n• Scenario\n• Scenario\n• Scenario\n• Scenario\n• Scenario\n• Scenario\n• Scenario\n• Scenario\nAutomation code\nCucumber\nGherkin\nAutomation code\nAutomation code\nSpecification\nSpecification\nSpecification\nStep definition\nSpecification layer\nAutomation layer\nStep definition\nStep definition\nFigure 2.8\nExamples, expressed in steps, act as a link between \nGherkin and Cucumber. Steps, scenarios, and feature files constitute \nthe specification layer. Step definitions and the testing code are the \nfundamentals of the automation layer. Together, the specification layer \nand the automation layer create an executable specification suite.\n\n\n51\nFinishing the Gherkin crash course\n \n2.6\nFinishing the Gherkin crash course\nAnd—you’re finished. After reading this chapter, you’re ready to write Gherkin speci-\nfications for any project.\n Let’s review what you’ve done:\nYou analyzed your acceptance criteria using concrete examples of how you\nexpect users to use the product in their natural environment.\nYou captured these examples as Given-When-Then scenarios to prepare them\nfor future automation.\nYou ended up with a specification that’s different from traditional requirements\ndocuments:\nIt’s much smaller, because Gherkin requires you to break down the scope of\nyour work into singular features. Small specifications fit well into iterative pro-\ncesses that focus on getting small chunks of work done quickly and repeatably.\nIt’s concrete and doesn’t leave much to a reader’s imagination. By making the\nsolution easier to comprehend, concrete examples allow engineers to produce\nworking code more quickly.\nIt’s ready to be tied up with implementation code through automated tests in\norder to maintain consistency with the system at all times. The document will\nstay up to date, because when anything changes, the link between code and sce-\nnarios will be broken. If the specification is validated frequently, the delivery\nteam will be able to spot broken scenarios quickly.\nIt’s not wasteful. The specification acts as a link between the analysis, design,\nimplementation, and testing phases. The system doesn’t require a separate test-\ning phase that would enable testers to determine whether requirements are sat-\nisfied—if they trust the specification, they can focus on exploratory testing and\nmore-difficult edge cases. No other development artifacts are introduced.\nTesting and checking\nA question that’s often asked when the topic of automated tests comes up is, “Why\ndon’t we get rid of all of our testers and automate all of our testing?” But you never\nhear anyone say, “Why don’t we get rid of all of our developers and automate all the\ndevelopment?” Trying to answer why is an interesting thought exercise.\nDevelopers do the smart thing and call their automated work compiling. Testers, too,\ncould differentiate between testing that requires thought and can’t be automated and\nthe checking that’s done with automation. When you design scenarios and think\nabout the possible inputs and expected outputs, you’re doing exploratory testing that\ncould never be done without a conscious mind. Once you design the scenarios, you\ncan automate most of them with testing code—and that’s the checking part. Some\ntests are more complicated than simple, easy-to-replicate checks, and that’s why\nthey can never be fully automated. \n\n\n52\nCHAPTER 2\nThe specification layer and the automation layer\nWhat this chapter didn’t cover is Gherkin’s full syntax. Don’t worry; you can find a full\nspecification of the Gherkin language in Cucumber’s repository on GitHub. But in my\nopinion, you can feel free to skip it. Throughout the book, you’ll see that the key to\nwriting good Gherkin lies somewhere other than getting to know the intricacies of its\nsyntax—and you’ll learn the handiest tricks on the fly.\n The real difficulty in using Gherkin is its flexibility. In addition to the keywords,\nyou can type almost anything you want in any order you can imagine. Such flexibility\ncan lead you astray if you’re not careful. In the next chapter, you’ll see how to protect\nyourself.\n2.7\nAnswers to exercises\nEXERCISE 1\nWrite the rest of the specification brief that explains who will use the\nscheduling features and why they need them, based on what you know about the appli-\ncation.\nLike it or not, meetings are the lifeblood of every organization.\nOur calendar app is meant for busy teams who work in collaborative\nenvironments, have to manage multiple meetings a day with different\nclients, and want to be as mobile as they can. They need smart reminders,\nhelp with different time zones, and a professional meeting management\nsolution.\nThis feature, then, being the simplest meeting management form we could\ncome up with without compromising on powerful capabilities, is the core\npart of our product.\nPlease be careful and make sure everything is tested properly.\nEverything else in this application could break and people would still\nforgive us; if this feature breaks, we'll all be doomed.\nEXERCISE 2\nWrite a simple scenario for canceling a meeting.\nGiven a meeting by John and Anna at 4 p.m.\nAnd that it is 3 p.m. now\nWhen Anna cancels the meeting\nThen the event should be removed from the calendar\nAnd John should be notified about the canceled event\nEXERCISE 3\nFind all the keywords in the Gherkin file that you’ve written so far in this\nchapter, separate the keywords from the steps, and write the results in a table.\n\nFeature\n\nScenario\n\nGiven\n\nWhen\n\nThen\n\nAnd\n\nBut\n\n\n53\nSummary\nEXERCISE 4\nWhat are other circumstances that may result in failures when Mike cre-\nates a meeting? Write a third scenario that adds more detail to the specification.\nGiven Mike, a member of our team\nAnd another event in Mike's calendar at 2 p.m.\nWhen Mike chooses 2 p.m. as a start time for his new meeting\nThen he should not be able to save his meeting\n2.8\nSummary\nA full Gherkin specification is called a feature. A single feature is typically con-\ntained in its own file that ends with a .feature extension. A feature typically spec-\nifies the behavior of a single functionality.\nThe specification layer contains specification files with the .feature extension,\nwritten in plain English and filled with domain-specific terms and concepts.\nThe automation layer and the specification layer heavily influence each other.\nYou can’t have a good specification layer without understanding the basics of\nthe automation layer.\nGiven a set of expected inputs and outputs, the automation layer executes a\nsimulation of the application to see whether the working code behaves as\nexpected.\nCucumber is a testing framework that matches Gherkin steps with step defini-\ntions and lets you run testing code.\n\nGivens, Whens, and Thens are called steps.\nSteps begin with keywords that help Cucumber parse the feature file.\nStep definitions are containers for all the testing code that must be executed to\nrun a step.\n\n\n54\nMastering the\nGiven-When-Then template\nIn chapter 2, we explored the two layers of executable specifications: the specifica-\ntion layer and the automation layer. We focused on the specification layer and writ-\ning it. But if you ever tried to write a blog post, you know that just writing and great\nwriting aren’t the same thing. Likewise, writing scenarios and writing great scenar-\nios can be quite different.\n This chapter will teach you to write great scenarios. Chapter 2 taught you the\nbasics of the Given-When-Then template, and this chapter is an advanced course.\nExpressive scenarios incorporate a vivid vocabulary of domain language that helps\nThis chapter covers\nWriting scenarios for the real world\nUsing realistic data in scenarios\nUnderstanding advanced rules for using Given-\nWhen-Then\nGetting unstuck when writing scenarios\nGenerating ideas for new scenarios\n\n\n55\nChoosing the right style for your Gherkin scenarios\nreaders understand requirements more easily. But Gherkin’s syntax is so easy that\nsometimes it seems repetitive—and therefore boring. Boring scenarios are easier to\nskim. You must learn to write expressive scenarios if you are to establish a connection\nwith your readers.\n My goal for this chapter was to write it like a practical cheat sheet. You’ll be able to\nuse it like your personal Gherkin Manual of Style—similar to the way the Chicago Man-\nual of Style is a style guide for American English (it’s been published since 1906 by the\nUniversity of Chicago Press). Its 16 editions have prescribed writing styles widely used\nin publishing. Like English, Gherkin is a language—so an advanced manual will help\nyou in the future.\n Chapter 1 said that each Gherkin scenario is like a short story about a product.\nMore parallels can be drawn between Gherkin and literature. An expert can rate each\nliterary work in three areas: style, composition, and story. Style is all about the beauty\nof the language. Composition is about clarity and coherence of thought. Story is what\nhappens to the heroes. Great Gherkin, too, can be rated using the same methodol-\nogy—so the chapter you’re reading right now is split into the following three sections:\nThe style section (3.1) talks about the highest-level guidelines you should focus\non when trying to write beautiful Gherkin scenarios. I’ll explain why your sce-\nnarios should focus on stakeholders and be written in an outcome-oriented way.\nThe composition section (3.2) expands on the structure of the Given-When-\nThen template and how you can write new scenarios more easily.\nThe story section (3.3) explains what to do when you don’t know what to write,\nby teaching methods to generate new ideas and get unstuck.\nThis chapter is organized around a collection of tips from these categories. Whenever\nI start a new tip, I’ll begin by mentioning the category it belongs to. Most of the tips\nwill be introduced in the order of this list, so you can expect style tips to appear in the\nstyle section, and so on. Sometimes, though, I’ll mention techniques from other sec-\ntions if they seem relevant but aren’t important enough to warrant separate\nsubsections—for example, I might include a story tip in the composition section. So\ndon’t be surprised.\n3.1\nChoosing the right style for your Gherkin scenarios\nExercises in Style is a classic book by the French author Raymond Queneau. The plot is\nsimple: a man gets into an argument with another passenger on a bus. But this anec-\ndote is told 99 more times, each in a radically different style: as a sonnet, an opera, in\nslang, and with many more permutations. Each style used in Exercises highlights differ-\nent elements of the same story—and so, readers perceive each retelling differently,\nnoticing different nuances every time.\n Like Queneau, you can write your scenarios in different styles. This section will\nteach you what works best with Gherkin. We’ll try to dissect what makes a scenario\n\n\n56\nCHAPTER 3\nMastering the Given-When-Then template\nexpressive. I’ll talk about what you should focus on when writing new scenarios—\nwhat to emphasize and what to hide. I’ll also discuss why trying to create software\nmodels that stick to the real world as closely as possible ultimately results in building\nbetter software.\n3.1.1\nDoing outside-in development with Gherkin\nStarting with this section, you’ll be working on an example application we’ll name\nQueneau after the French author. Queneau is a text editor with features that let writ-\ners easily imitate different styles, exactly like its namesake.\nWRITING USER-ORIENTED SCENARIOS\nOne of Queneau’s competitive advantages is that the app can teach you to imitate the\nstyle of popular authors, such as Raymond Queneau himself and, let’s say, Vladimir\nNabokov. It does so by instructing you to revise your text like the chosen author\nwould. In Nabokov’s case, Queneau would instruct you to shorten your sentences,\nremove any adverbs, avoid passive voice, and so on. Thanks to what you learned in\nchapter 2, I can easily demonstrate such functionality using a Gherkin scenario.\nScenario: Detect sentences that are too long\nGiven text with a sentence that is too long:\n\"\"\"\nAs he crossed toward the pharmacy at the corner he involuntarily turned\nhis head because of a burst of light that had ricocheted from his \ntemple, and saw, with that quick smile with which we greet a rainbow or \na rose, a blindingly white parallelogram of sky being unloaded from the \nvan—a dresser with mirror across which, as across a cinema screen, \npassed a flawlessly clear reflection of boughs sliding and swaying not \narboreally, but with a human vacillation, produced by the nature of \nthose who were carrying this sky, these boughs, this gliding façade.\n\"\"\"\nWhen the content is analyzed\nThen the sentence that is too long should be detected\nThe scenario looks fine—but if you scratch the surface, doesn’t it seem lifeless? After\nall, writers will use your text editor to bring hundreds of beautiful and despicable\ncharacters to life. This scenario looks out of touch compared with what your end users\nwill do with the product. By talking about system operations like analyzing and detec-\ntion, which are highly technical, the scenario is clearly written in a style your users\nwouldn’t want to read. And because more people read books written by authors like\nNabokov than books written by technical people, you should do something about it if\nyou want nontechnical stakeholders to read your scenarios, too.\nListing 3.1\n[OK] An example scenario\n\n\n57\nChoosing the right style for your Gherkin scenarios\n \nTo see what I mean, let’s look at a revised version of the scenario from listing 3.1.\nScenario: Detect sentences that are too long\nWhen Vladimir writes a sentence that is too long:\n\"\"\"\nAs he crossed toward the pharmacy at the corner he involuntarily turned \nhis head because of a burst of light that had ricocheted from his\ntemple, and saw, with that quick smile with which we greet a rainbow or\na rose, a blindingly white parallelogram of sky being unloaded from the\nvan—a dresser with mirror across which, as across a cinema screen, \npassed a flawlessly clear reflection of boughs sliding and swaying not \narboreally, but with a human vacillation, produced by the nature of \nthose who were carrying this sky, these boughs, this gliding façade.\n\"\"\"\nThen he should be notified that the sentence could be shortened\nWithout changing much of the content, focusing on the person in front of the screen\nshifts attention to answering an important question: can you do something to improve\nVladimir’s life? Is it the most efficient way to help him? Can he achieve his goal easily?\nHaving answered these questions, you might, for example, notice that if Queneau\nhighlighted the sentence that could be shortened immediately after Vladimir wrote it,\nthe app would distract him instead of helping him focus. Should you introduce two\ndifferent modes, one for writing and one for editing? Editing mode would suggest\npossible changes. Vladimir would be able to switch between modes at will, depending\non what he wanted to do at the moment.\nListing 3.2\n[GOOD] User-oriented scenario\nUsing multiline doc strings\nIf you need to write a step that won’t fit on a single line, you can use doc strings. A\ndoc string follows a step and begins and ends with three double quotation marks.\nHere’s an example:\nGiven a text:\n\"\"\"\nThere is no rule on how to write.\nSometimes it comes easily and perfectly;\nsometimes it's like drilling rock\nand then blasting it out with charges.\n\"\"\"\nDoc strings allow you to write long error messages or email contents in your scenar-\nios. Sometimes longer texts have a lot of business value. For example, in heavily reg-\nulated environments where mistakes are expensive, you might want to test your error\nmessages with executable specifications.\nDoc string\n\n\n58\nCHAPTER 3\nMastering the Given-When-Then template\n \nScenario: Detect sentences that are too long\nThe EDIT MODE highlights all the suggestions made by\nour text editor directly in the text.\nThe WRITE MODE hides the suggestions, so the author\ncan focus on writing without any distractions.\nWhen Vladimir writes a sentence that is too long:\n\"\"\"\nAs he crossed toward the pharmacy at the corner he involuntarily turned\nhis head because of a burst of light that had ricocheted from his\ntemple, and saw, with that quick smile with which we greet a rainbow or\na rose, a blindingly white parallelogram of sky being unloaded from the\nvan—a dresser with mirror across which, as across a cinema screen, \npassed a flawlessly clear reflection of boughs sliding and swaying not \narboreally, but with a human vacillation, produced by the nature of \nthose who were carrying this sky, these boughs, this gliding façade.\n\"\"\"\nThen he should be notified that it could be shortened in the Edit Mode\nBut he shouldn't be notified about that in the Write Mode\nTIP\nHashing out Gherkin scenarios is a great way to brainstorm and discover\nnew features. Writing a Given-When-Then scenario is even cheaper than\ndrawing a sketch or making a mock-up. I find collaborating over Gherkin sce-\nnarios particularly valuable in asynchronous, remote work environments. \nDEFINING ACTORS IN SCENARIOS\nIn chapter 2, when you were polishing your first Given in listing 2.7, I asked you to call\nthe user in the scenario Mike. I told you that the reason to do so was that when two\nusers appear in a single scenario, calling them team member 1 and team member 2 sounds\nawkward.\n Real names and user-oriented scenarios facilitate empathy, and this is important.\nIn one project, I called the user in most of my scenarios Simona. Every time I wrote a\nscenario, I imagined that she was anxious to get her work done as quickly as she could,\nbecause she had a sick child at home. I wondered whether there was anything more I\ncould do to make her work easier. In user-centered design and marketing, what I did\nwith Simona’s scenarios is called creating a persona. Personas are fictional characters\ncreated to represent the different user types that might use a product in a similar way.\nSo every time I mentioned Simona, I meant every person similar to her—a certain\ndemographic, a customer segment. But these are abstract terms. A good persona is\nmuch more real.\nListing 3.3\n[BEST] Discovering user benefits with Gherkin\n\n\n59\nChoosing the right style for your Gherkin scenarios\n \nHad you looked at this situation only from the perspective of the system, you would\nhave seen only system attributes—data coming in and going out of your application,\nthe inputs and outputs. In some cases, this isn’t a bad approach—and yes, there can\nbe other cases. From a technical point of view, every scenario must be written from the\nperspective of an actor.\nDEFINITION\nActor—Anything that influences an action or a process taking\nplace in the system under design\nThere are three types of actors:\nStakeholders\nOrganizations\nSystems\nShould you write steps with step definitions that have no testing code?\nWhen I was learning how to use Cucumber and Gherkin, I was told that writing steps\nwith step definitions that don’t execute any testing code was a bad practice. Here’s\na quick example:\nGiven Vladimir's desire not to be distracted\nWhen he turns on the Write Mode\nThen only the paragraph he's working on should be fully visible\nAnd the other paragraphs should be dimmed out\nHow on earth could you write testing code to check whether a user feels distracted?\nAt first glance, the step feels redundant. Including it seems like unnecessary work for\nwhoever will implement the acceptance tests. A developer would certainly tell you\nthat doing so increases the complexity of the test suite for no reason.\nI think the answer becomes clearer if you keep in mind that scenarios emerge before\nyou start thinking about tests and testing code. With specification by example (SBE)\nand Gherkin, you follow an end-to-end paradigm of building a dynamic specification\nsystem that constantly evolves along with the product. And when you embrace the\nmindset of organizing your development process around collecting examples and\nrefining scenarios, then you can see a fluid progression between development\nphases.\nImagine that you’re sitting in a specification workshop, trying to analyze the Write\nMode feature. It would be extremely natural to write that Vladimir doesn’t want to be\ndistracted, because that’s why you invented the feature in the first place. You could\neven rename the Write Mode to something like Focus Mode and make it a big ele-\nment of your marketing value proposition for Queneau.\nThis is why I think that instead of not writing steps with empty step definitions, you\nshould make a habit of not writing steps that don’t bring any value. These are two\ndifferent things.\n\n\n60\nCHAPTER 3\nMastering the Given-When-Then template\nA stakeholder is someone with a vested interest in the behavior of the use case, even if\nthey never interact directly with the system. Stakeholders come in all sorts of flavors.\nThey’re the people who use the software you create, but they can also be economic\nbuyers, decision makers, business partners, or insiders.\n But organizations and systems can be actors, too. For example, an external service\nprovided by a business partnership may shape your product and deserve a mention in\nyour scenarios. \nOUTSIDE-IN DEVELOPMENT AND USER-ORIENTED SCENARIOS\nYou can write Gherkin scenarios for all three types of actors, but I strongly advocate\ntaking the perspective of a specific group of stakeholders: the end users. End users are\nthe people who interact with your product. They experience how your software works\nin the real world. In general, you should use the tools you choose in a way that can\nyield the most benefits. But the software development community has come to a\nbroad consensus that the user-centered perspective works best. That’s why, as an\nindustry, we’ve reoriented most of our tools, such as user stories, to focus on people.\nI’ve already mentioned how UX designers and marketers use personas to empathize\nwith abstract customer segments. Gherkin, too, fits this trend well.\nTIP\n[STORY] To elicit better requirements, understand who needs a sug-\ngested solution and why they need it. If you need help to better understand\nyour stakeholders, try creating a user journey map. A user journey map is a\nvisual or graphic interpretation of the overall story, from an individual’s per-\nspective, of their relationship with an organization, a service, a product, or a\nbrand, over time and across channels. Unfortunately, creating user journey\nmaps goes beyond the scope of the book.\nIn the world of software, focusing on stakeholders is also called outside-in development.\nAt times, outside-in development is like literature, too. Storytellers have to keep in\nmind what’s interesting to their audience, not what’s fun to do as a writer. Those\nobjectives can be very different. Even systems-heavy solutions can be analyzed from\nthis perspective. Systems are designed by people; they’re used by people; they’re man-\naged by people. The outside-in approach forces you to think about the people who\ndefine software requirements and try to understand why they want what they want. In\ngeneral, try to write your scenarios for end users when you can—but when you can’t,\ndon’t lose sight of the people behind systems and machines.\nDEFINITION\nOutside-in development—A software development methodology\nthat aims to create successful software through understanding the goals and\nmotivations of stakeholders\nThis section isn’t meant to exhaust the topic of outside-in development. That’s a sepa-\nrate art of finding, analyzing, and managing stakeholders on different levels, both\ninside your organization and outside of it. As I just outlined, it’s more complex than\nfocusing on end users. For example, some stakeholders may be hidden from your\n",
      "page_number": 58
    },
    {
      "number": 3,
      "title": "Mastering the Given-When-Then template",
      "start_page": 82,
      "end_page": 107,
      "detection_method": "regex_chapter",
      "content": "61\nChoosing the right style for your Gherkin scenarios\nview. This usually happens when a new, weird requirement emerges, and you have no\nidea where it came from—because it doesn’t sound like a request people you usually\ntalk to would make. (Hint: It may have been enforced by a silent stakeholder.)\nMachine-to-machine solutions are another example. I can’t cover them all in this\nchapter. But I wanted to achieve two things: to give you a guideline—a rule of thumb\nthat will maximize results and minimize effort; and to give you a platform from which\nto investigate outside-in development on your own. \n3.1.2\nGathering realistic data\nI started writing short stories when I was in middle school. I couldn’t write very well, so\nI at least wanted the stories to be cool. I wrote about stuff I thought was exciting. It was\nalso stuff I knew nothing about. The results always turned out to be boring because my\nstories lacked detail and depth. It took me a few years to realize that people liked my\nwriting more when there was something true and realistic at the core of a story rather\nthan when it was shouting “cool” all over the place but felt fake. Good Gherkin writers\nshould also hate fake stories—fake examples, fake actors, and fake domain concepts—\nbecause fake data often results in making misinformed decisions. Let me explain why.\n Table 3.1 contains three examples of rules that Queneau implements to help writ-\ners edit their text files more easily. All three examples were devised to illustrate system\nrules somebody took for granted. But the correct approach for illustrating require-\nments with examples is to find examples that constitute a source of each rule. As a\nstrong fundamental, grounded in the real world, the source provides validation of\nwhether a rule makes sense. The examples in the table don’t—they’re more like frag-\nile crutches.\n If you put the table in a Gherkin scenario, it wouldn’t break the test-execution\nengine. The examples were designed not to break it.\n Fake scenarios with fictional examples poison your decision making. Outside-in\ndevelopment relies on analyzing people, processes, and rules outside of your system\nto incorporate them in your application. The role of data in Gherkin is to inform\nOutside-in terminology and behavior-driven development\nOutside-in terminology belongs to the Gherkin domain but not to the SBE domain,\nwhich means you may not hear it much when talking with people who use non-\nGherkin executable specifications like FitNesse. Behavior-driven development (BDD)—\nwhich is mostly associated with Gherkin through the figure of Dan North, who had a\nhand in creating both BDD and Gherkin—is often defined as “a second-generation,\noutside-in, pull-based, multiple-stakeholder, multiple-scale, high-automation, agile\nmethodology.”\nBonanza of keywords aside, I took the liberty of integrating outside-in methods into\nthis chapter and also chapter 5. But I believe that mentioning the terminology mix-up\nexplicitly here is a fair thing to do.\n\n\n62\nCHAPTER 3\nMastering the Given-When-Then template\ndecisions and ensure continuity of research and discovery in the software develop-\nment process. Examples and scenarios should empower future readers to understand\nthe context they were written in, so that anyone who decides to push the feature for-\nward can build on top of what the original writers intended.\n Look at the examples again. If you were to make a change to this scenario six\nmonths after its conception, would you—a person who hasn’t worked on this project\nbefore—be able to understand why such sentences were chosen? No. They would\nseem arbitrary.\n Ultimately, what we’re after is authenticity—both in software and in writing.\nAuthentic stories strive to tell you something impactful and true. Similarly, authentic,\nimpactful software understands you and your needs. \n3.1.3\nFavor specifying intentions and outcomes over the user interface\nThe two previous chapters talked about how the Given-When-Then template works well\nwith behavioral requirements. Behaviors are actions performed by actors and meant to\nmake a change in a system. Understanding how high-level these actions should be is a\ndifficult topic that many Gherkin writers struggle with. I’ll talk about it multiple times\nthroughout the chapter. This section will give you an introduction to help you under-\nstand the general rule for how abstract or concrete behaviors should be.\n I have to begin by saying that Cucumber and Gherkin are typically associated with\nend-to-end system testing. This heritage is the reason a lot of people write Gherkin\nscenarios that talk about what’s tested in the automation layer: the user interface.\nDEFINITION\nEnd-to-end tests—Tests that check whether the flow of an applica-\ntion is behaving as expected from start to finish, by running a simulation of the\nentire system in a browser and emulating real users clicking through the UI\nTo understand what I mean, look at the following scenario. It specifies a simple\nexporting feature built into Queneau.\nTable 3.1\n[BAD] Fictional examples of acceptance criteria in Queneau\nRule\nExample\nAvoid long sentences\nThis is a sentence that is too long and, while it’s certainly pretty, it \nmight therefore be too complicated for a reader to comprehend at a \nglance—so you should consider shortening it or breaking it into smaller \npieces.\nReplace difficult words with \nsimpler alternatives\nThis extraordinary sentence contains a difficult world—extraordinary—\nthat you could replace with a simpler word such as special.\nAvoid adverbs\nAdverbs should be limited, preferably removed.\n\n\n63\nChoosing the right style for your Gherkin scenarios\n \nScenario: Exporting documents\nGiven \"Export\" button from the \"File\" menu was clicked\nWhen Vladimir types \"Lolita\" into the \"Name\" text field\nAnd he chooses \"PDF\" from the file type select field\nAnd he chooses a \"1955\" destination folder from a select field\nThen a file \"Lolita.pdf\" should appear in folder \"1955\"\nNow, imagine that you change the location of the Export button in the example, put-\nting it in the Edit menu instead of File. It’s a minuscule change, but you’d have to\nrewrite both the step and the step definition in question.\n If the specification has to change every time the UI changes—when a button disap-\npears, for example—then building trust is more difficult, because humans instinc-\ntively value stability over chaos. Writing about buttons, forms, links, and input fields is\na limiting approach to harnessing the benefits of a business-readable DSL like Gherkin\nin bridging the communication gap between technology and business.\n Some of the confusion comes from the fact that Gherkin scenarios are about\nbehaviors, and thinking about behaviors can automatically prime you to imagine a UI\nto interact with. But throughout the book, I favor a different approach: writing Gher-\nkin specifications that describe the business logic of a system, as well as the intentions\nof actors and the outcomes they can or can’t achieve. So instead of talking about but-\ntons or links, you talk about business goals, customers, requirements, and acceptance\ncriteria—because that’s what the business cares about.\nTIP\n[STYLE] Don’t write scenarios about the UI. Write about business out-\ncomes. Nobody cares about the UI; they care if they can get their job done.\nFavoring specifying intentions and outcomes over the UI is a practical tip for writing\nmore-bulletproof scenarios. But from a theoretical point of view, the discussion is\nabout preferring one style of writing over another: interface-oriented style, which is\nalso called imperative style; or outcome-oriented style, also known as declarative style.\n Imperative style is simple, is intuitive, and reflects what manual testers do. That’s\nwhy almost everybody who is new to Gherkin naturally starts with this style. In contrast,\ndeclarative style describes what the user does, but not how they do it—the how part is\npushed into step definitions and handled by the automation layer. The real difference\nbetween the imperative approach and the declarative approach comes down to differ-\nent levels of abstraction. Imperative writing is less abstract and more concrete,\nwhereas declarative writing is more abstract. Liz Keogh, a BDD mentor, argued once\nthat “there’s no such thing as declarative and imperative”1 and “every declarative is a\nchunking-up of something else, and every imperative is a chunking-down, and you can\nchunk up and down to different levels of abstraction.” Chunking up and chunking down\nare terms from the domain of natural language processing, and they mean becoming\nmore abstract or more specific, respectively.\nListing 3.4\n[BAD] Interface-oriented scenario\n1 Liz Keogh, “There’s No Such Thing as Declarative and Imperative,” June 17, 2013, http://mng.bz/QO51.\n\n\n64\nCHAPTER 3\nMastering the Given-When-Then template\nBut choosing the right level of abstraction isn’t only a stylistic choice. It’s also about\ncomposition. For example, the more abstract you decide to be, the shorter your sce-\nnarios will be and the fewer steps they will contain. And that can be good or bad.\nShorter scenarios can be easier to read, discuss, and remember—but they can also be\ntoo short to allow readers to grasp difficult domain concepts and their consequences\nin full. So the choice of abstraction level shouldn’t be automatic. I’ll talk more about\nhow to make a good decision in the next section (which talks in general about compo-\nsitions) and, particularly, in section 3.2.4. I’ll also revisit the topic in chapter 8, where\nI’ll talk about splicing scenarios into specifications while maintaining a reasonable\nlevel of abstraction. \n3.2\nComposing Gherkin scenarios\nIn literature, composition involves structuring a story to the best of your ability in order\nto achieve a specific storytelling effect. This section discusses the rules of composing\nGiven-When-Then templates designed to facilitate outside-in development:\nLow-level composition—How to phrase Gherkin steps\nHigh-level composition—How to balance Givens, Whens, and Thens in your scenarios\nThese rules should help you write easily readable Gherkin scenarios more quickly.\n3.2.1\nStarting with a Then\nEvery writer knows that there’s something terrifying about a blank page. Even if you\nknow what you want to write about, transforming thoughts into words is difficult. The\nsame applies to Gherkin scenarios. It may seem counterintuitive, but the easiest way to\nstart writing a Gherkin scenario is to begin with the end in mind—the Then—just as\nmost good writers never start writing without figuring out the ending. This should get\nyou unstuck quickly. It also brings other benefits, such as better collaboration with\nbusiness users to elicit better requirements.\nTIP\nStarting with examples of outputs can help engage business users in the\ndiscussion even before any scenarios are written and will give them a clear pic-\nture of what they can get out of the system. Outputs are often easier to discuss\nthan inputs because, usually, outputs already “exist” in the real world. For\nexample, when you’re trying to automate a manual process with software, the\nexpected outputs of the process are easy to retrieve from existing results. Now\nyou only need to figure out the automation process.\nTIP\nTo help achieve better outcomes, examine a behavior that already exists,\nand try to improve it.\nExercise 1\nRewrite listing 3.4 in declarative style.\n\n\n65\nComposing Gherkin scenarios\nWhat are the other benefits? The truth is, no one is ever in the market to buy a “prod-\nuct.” Think about it. Nobody wants to buy a drill for the sake of buying a drill. Some-\ntimes, though, people need a hole in a wall. In marketing, mistaking the source of\ndemand is called marketing myopia.2\nDEFINITION\nMarketing myopia—The mistake of paying more attention to the\nspecific products a company offers than to the benefits and experiences pro-\nduced by these products.\nCustomers want to buy a specific outcome your product will produce. And Thens are the\noutcomes. That’s why you should start with both getting the right Thens and getting\nthe Thens right, by which I mean your users should want the outcomes you’re specify-\ning, and the outcomes should be described clearly to the delivery team. Everything\nelse should build on top of that.\nTIP [STYLE] To facilitate outside-in development, use the following template\nto phrase most of your Thens: <an actor> should be able to <achieve a result.>.\nStarting with Thens fits into a larger narrative than writing good Gherkin or even mak-\ning software. Principles of Marketing, for example, is a must-read resource for all market-\ning students. You won’t find a line of code in it—not even a mention of an application\nor a server. The Jobs-to-be-Done framework3 also developed a concept of customers\nhiring products to yield specific outcomes, rather than buying new stuff. Doing\noutside-in development can fit into new business practices like these as they spread\namong companies. \n3.2.2\nUsing only one When per scenario\nIn prose, each form of fiction can only contain a story specific to its length. Short sto-\nries focus on a single hero or theme. Novels feature casts of multiple characters and\ngently intertwine their subplots.\n If you try to apply the structure of a novel to a short story without recomposing it,\nyou’ll fail. Many book adaptations fail as movies for the same reason. They try to fit\ntoo many themes and characters into a movie that’s two hours long, confusing viewers\nwith rushed plots and undeveloped characters.\n Ideally, a scenario should be three sentences long and feature one Given, one\nWhen, and one Then. Just as short stories focus on only one theme, each scenario\nshould be composed to talk about only one acceptance criterion.\n Let’s say that, in Queneau, there’s a readability score feature that lets writers know\nwhen they violate too many suggestions, making the text hard to read. Here’s a sce-\nnario describing that.\n2 Philip T. Kotler and Gary Armstrong, Principles of Marketing (Prentice Hall, 2013).\n3 First described in the 2005 Harvard Business Review article “Marketing Malpractice: The Cause and the Cure,”\nby Clayton M. Christensen, Scott Cook, and Taddy Hall.\n\n\n66\nCHAPTER 3\nMastering the Given-When-Then template\n \nScenario: Improving readability score\nGiven Vladimir's low readability score\nWhen he goes into the Edit Mode\nAnd he simplifies the text\nThen his readability score should improve\nTell me: does the readability score improve only when you use Edit Mode?\n When you use two Whens for one outcome, you can never be sure which When\ncaused the outcome to happen. In listing 3.5, intuition suggests that both Whens are\nnecessary for the readability score to improve. But are they? Why would the score\nimprove only if you used Edit Mode? Does that mean if you made the same changes in\nWrite Mode, the readability score wouldn’t go up? That’s ridiculous. To avoid such\nconfusion, think of Whens as user tasks performed by actors, and try to specify only one\nuser task per scenario.\nDEFINITION\nUser task—A high-level instruction that describes a single business\nactivity\nTo determine whether a When you wrote is a user task, ask whether the actor could per-\nform the task without turning on a computer. “Revising content” is a user task because\nyou can revise manually, too. “Choosing destination folder for a text file” isn’t a user\ntask, because it’s too low level—it deals with the tech domain instead of the business\ndomain.\n When you write a scenario with two user tasks, you make the scenario more diffi-\ncult to analyze. Coupling always means some interaction between multiple rules, and\nListing 3.5\n[BAD] Scenario with two Whens\nThe Screenplay Pattern\nTask-oriented thinking comes from an acceptance-testing practice called the Screen-\nplay Pattern, brought to life by Antony Marcano and later refined by Andy Palmer. I\nstumbled on the Screenplay Pattern thanks to Jan Molak and John Ferguson Smart,\nwho expanded on the subject in a series of articles.a\nThe Screenplay Pattern is a user-centered approach to writing high-quality automated\nacceptance tests based on good software-engineering principles. From a high-level\npoint of view, the pattern organizes tests around actors who perform user tasks in\norder to accomplish their business goals. The approach is similar to the one I take\nin the book.\nDevelopers and engineers will find the pattern helpful in avoiding redundancy and\norganizing test code according to patterns such as the Single Responsibility Principle\nand the Open-Closed Principle. Non-engineers can also use the Screenplay Pattern to\norganize Gherkin scenarios more easily.\na Jan Molak, “From Acceptance Tests to User Guides,” March 31, 2016, http://mng.bz/VU1u.\n\n\n67\nComposing Gherkin scenarios\ninteraction means new inputs and outputs to take care of. Given Gherkin scenarios’\noptimal length, it would be like trying to fit a novel into three sentences. But when\nyou aim to use only one task per scenario, you can clearly see what’s being tested in\nthe scenario.\nTIP\n[STYLE] User tasks take place in the present and should be phrased in\nactive voice to differentiate them from contexts and outcomes.\nBut sometimes a scenario with multiple Whens is an acceptable choice. Each high-level\nuser task is comprised of multiple lower-level activities called user actions. For example,\nwhen you want to print a document, you have to choose a format and pages to print\nand a quality of printing to achieve the final objective. (There are many other options\nto choose from, but I’m simplifying for the sake of the example.)\nScenario: Printing documents\nGiven a 50 pages long draft\nWhen Vladimir wants to print in the letterhead format\nAnd he chooses to print all the pages\nAnd he chooses to print in low quality\nThen the printer should print 50 low quality A4 pages\nNone of these steps is a standalone user task; you must complete all three to get a\nmeaningful result. If you only use multiple Whens to convey user actions, there also\nisn’t any confusion about whether the steps are all required for the scenario to take\nplace in the real world.\nTIP\n[COMPOSITION] To distinguish small user actions and big user tasks,\nremember that user tasks should allow actors to proceed to Thens. If a When\nneeds additional clarification, it’s a user action.\nWhen you set out to write a new scenario, should you write about user tasks or user\nactions? That depends. I’ll come back to this in section 3.2.4, which discusses choos-\ning the right level of abstraction for your scenarios. \n3.2.3\nSpecifying prerequisites with Givens\nIn sci-fi and fantasy, imaginary worlds often enable writers to tell the stories they want\nto share. Let me give you an example. The events of The Lord of the Rings wouldn’t hap-\npen if not for the One Ring, a magical item that’s central to the plot. The ring is an\nelement of the fictional universe that author J. R. R. Tolkien created; but because its\nListing 3.6\n[GOOD] Scenario with multiple user actions\nExercise 2\nRewrite the user actions from listing 3.7 as a user task.\n\n\n68\nCHAPTER 3\nMastering the Given-When-Then template\nappearance sets the action in motion, it’s also a prerequisite necessary for the rest of the\nstory to happen.\n Givens have a role in scenarios that’s similar to world-building in storytelling. A Given\ncreates a snapshot of the represented world and its history before the action of the scenario\ncan take place. The snapshot stays static until the actors change it with their actions.\nTIP\n[STYLE] Don’t phrase Givens as actions. Use passive voice in past tense,\nor phrase each Given as a list of things that need to happen before the actors\ncan move the action forward.\nBut how can you create a snapshot in text? Use lists, because you can often rearrange\nlists easily, or use passive voice in past tense—but always remember to reserve actions\nfor Whens. Actions are usually scenario specific and thus can't be moved freely; lists, on\nthe other hand, are universal, because you can rearrange items more easily. And it’s\noften important to phrase Givens flexibly, because although different scenarios need\ndifferent snapshots, you’ll often want to reuse elements you’ve already created for\nother scenarios. To illustrate, here’s an example of an action within a Given.\nGiven Vladimir writes a sentence in his draft:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nI might suspect that this step was copied from another scenario where it was used as a\nWhen to specify some action. The problem is that without looking at the testing code,\nyou’ll know little about this step’s implementation. The implementation can, for\nexample, depend on other Givens that were useful when the step was a When but will\nonly make your new scenario less clear if you have to include them.\n Here’s how you could rewrite the problematic step to be standalone and flexible.\nGiven text:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nNow you have a step that is clearly distinct and can later be automated in a way that’s\neasy and safe to reuse in other scenarios.\n Think of Givens as building blocks. These blocks are used to build a coherent\nworld where your scenarios can take place. Passive blocks tend to fit with each other\nmore easily. You can just list necessary prerequisites, instead of trying to awkwardly\nstitch together a few active sentences from other scenarios.\nListing 3.7\n[BAD] An active Given\nListing 3.8\n[GOOD] A passive Given\n\n\n69\nComposing Gherkin scenarios\n \nREUSING GIVENS WITH BACKGROUNDS\nSometimes you’ll need the same prerequisites for all the scenarios in a single feature\nfile. Gherkin makes that easier with backgrounds.\n To better understand what a Gherkin background is, imagine you’re writing a\nbook that features multiple narrators. Each of the narrators tells their part of the story\nin a separate chapter. All the chapters are happening simultaneously. To let the reader\nbetter understand the plot, you decide to add a prologue written in third-person nar-\nrative mode that explains the basic context for all the other chapters. For example,\nthe book may be a historic action novel that pictures a chaotic aftermath of a medieval\ncity’s burning. The prologue describes events that led to the burning. The chapters\ndeal with the aftermath from the perspective of subsequent narrators. If Gherkin’s sce-\nnario can be compared to the book’s chapters, then a background is exactly like the\nprologue.\nDEFINITION\nBackground—A list of steps that run before each one of the sce-\nnarios in the same feature file\nYou can use a background to extract steps that are necessary to understand all other\nscenarios in a specification, without repeating them in every scenario. Let’s say you\nchoose to implement a search-and-replace function in Queneau. A simple implemen-\ntation will need four new scenarios: one for search, one for search and replace, one\nfor a success scenario, and one for a failure scenario.\nFeature: Search and replace\nScenario: Successful search\nGiven a text:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nWhen Vladimir searches for \"was\"\nThen he should be pointed to the word \"was\" in the text\nScenario: Unsuccessful search\nGiven a text:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\nListing 3.9\nScenarios with redundant Givens\nExercise 3\nRewrite the following step into a passive Given: Given Vladimir wants to write\na new book.\nThe same \nGivens in all \nscenarios\n\n\n70\nCHAPTER 3\nMastering the Given-When-Then template\n\"\"\"\nWhen Vladimir searches for \"best\"\nThen he should see that there is no such word in the text\nScenario: Successful search and replace\nGiven a text:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nWhen Vladimir wants to replace \"was\" with \"is\"\nThen the text should be:\n\"\"\"\nIt is love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nScenario: Unsuccessful search and replace\nGiven a text:\n\"\"\"\nIt is love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nWhen Vladimir wants to replace \"best\" with \"greatest\"\nThen the text stay as it was:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nHere’s the same specification, simplified thanks to a background.\nFeature: Search and replace\nBackground:\nGiven a text:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nScenario: Successful search\nWhen Vladimir searches for \"was\"\nThen he should be pointed to the word \"was\" in the text\nScenario: Unsuccessful search\nWhen Vladimir searches for \"best\"\nThen he should see that there is no such word in the text\nScenario: Successful search and replace\nWhen Vladimir wants to replace \"was\" with \"is\"\nThen the text should be:\nListing 3.10\nGivens refactored into Background\nThe same \nGivens in all \nscenarios\nThe Background keyword\nRedundant Givens from \nall four scenarios put in \nthe background\n\n\n71\nComposing Gherkin scenarios\n\"\"\"\nIt is love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nScenario: Unsuccessful search and replace\nWhen Vladimir wants to replace \"best\" with \"greatest\"\nThen the text stay as it was:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nAs you can see, backgrounds are put after the specification brief but before the sce-\nnarios. When you run the test-execution engine, it will execute both of the Givens\nbefore running each scenario.\n3.2.4\nChoosing the right abstraction level\nIn section 3.2.2, I said that you may want to write about high-level behaviors called\nuser tasks that consist of other, low-level behaviors: user actions. Due to the amount of\ntime I’m spending talking about ambiguity and clarity, you may think that being\nexplicit and listing every possible action in your scenarios is the default way to go. But\nbeing verbose isn’t always a good idea.\nTHE DISADVANTAGES OF BEING OVERLY SPECIFIC\nLook at the following scenario, which talks about versioning drafts. The person who\nwrote it chose to make changes in the newer revision using low-level user actions.\nScenario: Revising drafts\nGiven a draft of \"Lolita\"\nWhen Vladimir writes:\nListing 3.11\nScenario that should be more abstract\nShould you use backgrounds?\nSometimes a background is a useful tool. We managed to go from 49 lines of text in\nlisting 3.9 to 37 in listing 3.10, a decrease of almost 25%. And the more scenarios\nyou have, the greater the decrease will be.\nHaving said that, I don’t advise using backgrounds too often. Many Gherkin practi-\ntioners think backgrounds are prone to being misused and that they make the spec-\nification layer too technical. Everyone should be able to read a Gherkin scenario and\nunderstand it even without knowing Gherkin’s syntax—backgrounds make this\nharder. If you feel like you have to use backgrounds frequently, you should think\nabout using broader-concept steps or split your specification into several smaller fea-\nture files. \n\n\n72\nCHAPTER 3\nMastering the Given-When-Then template\n\"\"\"\nChapter 29\n\"\"\"\nAnd he marks the paragraph as a H1\nAnd he writes:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nThen the new draft should replace the previous draft\nThe scenario is technically okay, but it’s too verbose given its purpose. Writing two new\nparagraphs with specific examples isn’t required to check whether new drafts replace\nolder drafts. It makes the scenario more difficult to read. But what if you simplified it?\nScenario: Revising drafts\nGiven a draft of \"Lolita\"\nWhen Vladimir makes a new revision\nThen the new draft should replace the previous draft\nMuch better!\n Unfortunately, no single rule exists for choosing the right level of abstraction. But\ndon’t worry about that right now. Even though you’re trying to write the best scenarios\nyou can, I wouldn’t expect that to happen every time—and that’s fine! Finish the first\ndraft and see what other people think. Ask your teammates, or find a third-party\nreader. Iterative improvement is much better than nonexistent perfection. The follow-\ning subsection offers some tips that should help you choose the optimal level of\nabstraction. \nHOW MANY STEPS SHOULD YOU AIM FOR IN A SCENARIO?\nRemember how I talked about starting new scenarios by writing their Thens? The level\nof abstraction of a particular scenario should depend on Thens, too, making them as\nobvious as possible. When you begin with the end in mind, you can work back to a cor-\nrect abstraction level, thinking about the minimal set of user tasks and prerequisites\nneeded to achieve the outcome you want.\nTIP\n[STYLE] As a rule of thumb, keep your scenarios at an abstraction level\nthat allows you to aim for as few Givens, Whens, and Thens as possible without\nsacrificing readability.\nIn general, you should explain the details necessary to understand the purpose of a\nscenario. If there’s a user flow that must be part of a scenario, because the scenario\ncan’t take place without it, but it isn’t crucial to understanding the scenario’s essence,\nthen you should only mention it briefly and consider wrapping it in a broader con-\ncept. This is what I did in listing 3.12 when I removed several specific steps, such as\nListing 3.12\nScenario at the correct abstraction level\n\n\n73\nComposing Gherkin scenarios\nmaking a paragraph into a header, and wrapped them in the broader concept “mak-\ning a new revision.”\n On the other hand, you should always have readers in mind. Will they understand\nwhat you intended if you simplify a scenario too much? For example, in the next sce-\nnario, do you know what Vladimir did to make the readability score go up?\nScenario: Improving readability score\nGiven Vladimir's low readability score\nWhen he simplifies the text\nThen his readability score should improve\nI have no idea. Simplifying can mean a thousand things.\nMy personal rule of thumb, which can help you to choose the right abstraction level,\nsays that you should be detailed when you introduce a new domain concept or a new\nuser flow to the specification suite, explaining as much as you deem necessary. Corri-\ndor testing is useful to determine whether you’re specific enough.\nDEFINITION\nCorridor testing—Informal, ad hoc solicitation to gain quick user\nfeedback or data. Named after the classic example of spotting someone across\na corridor and asking for their opinion.\nRemember that a concept important to one scenario may not be as important to oth-\ners. It’s okay if you explain a particular user flow in detail in one scenario and only\nmention it briefly in other specifications. You can be briefer and act as though the\nreader is someone who already knows the concept you’re writing about whenever you\nmention anything that already exists somewhere else in the specification suite.\n In prose, getting the right abstraction level is easy, because the reader is usually\nreading chapters in a linear manner. For example, if I taught you what an executable\nspecification is in chapter 1, I can expect that you already know what it is when you\nread chapter 3. A specification suite doesn’t work this way. A reader with any level of\nknowledge about the system can jump into any specification file at any moment. But\ndon’t worry about that right now. Chapter 7, which discusses living documentation,\ntalks about creating universal glossaries of concepts that will help you regulate the\nlevel of abstraction of particular steps throughout the specification suite. And chap-\nters 8 and 9 present some techniques for organizing scenarios and specifications in a\nmanner that’s easy to follow even though the reading process isn’t linear. \nListing 3.13\nScenario that should be less abstract\nExercise 4\nRewrite listing 3.13 to reduce its level of abstraction. For the purpose of the exercise,\nyou can assume that there’s only one way to improve the readability score: by making\nlong sentences shorter.\n\n\n74\nCHAPTER 3\nMastering the Given-When-Then template\n3.3\nTelling Gherkin stories with impact\nGherkin scenarios tell stories about behaviors performed by actors. Whereas the previ-\nous sections taught you why the outside-in style matters and how to structure stories,\nthey didn’t address the most important issue many writers face: what to write about.\nHow do you write meaningful scenarios that make your software better? Where should\nyou start? How can you make sure all inputs and outputs are covered properly and\nyour tests are good? This section offers some methods for writing scenarios that have\nreal impact.\n3.3.1\nWriting warm-up narratives\nA good way to get started when you’re stuck with a new requirement is to write a short,\nfree-flowing narrative about the requirement in action. You can do this after you\ngather some initial examples and acceptance criteria but before you write any scenar-\nios in Gherkin. Here’s an example.\n\"If your story is ready for rewrite, cut it to the bone.\nGet rid of every ounce of excess fat. This is going to hurt;\nrevising a story down to the bare essentials is always\na little like murdering children, but it must be done.\"\n—Stephen King\nWriting is hard. Many authors struggle to get anything done.\nThere's something terrifying about a blank page, but there's\nsomething terrifying about an unrevised page, too. What can\nyou do to make a writer's life easier?\nSketch out a few moments of a day in the life of one of the actors. In this narrative,\ninvent a person you can empathize with, and capture, briefly, the mental state of that\nperson, their goals, or the conditions that drive them to act as they do.\n When writing, don’t think about implementation yet. Ignore any technical limita-\ntions of your current system, and don’t focus on the new features you’ll have to\ndevelop to support the behavior. You don’t have to worry about edge cases, either. The\npoint of this exercise is to write anything. You can always rewrite the narrative into the\nGiven-When-Then template later.\nListing 3.14\nWarm-up narrative\nExercise 5\nWrite a warm-up narrative for Vladimir and the Focus Mode feature. Focus Mode, men-\ntioned in section 3.1.1, is a distraction-free writing mode designed to help the writer\nstay in the flow. Does the narrative cause you to imagine new solutions that would\nhelp Vladimir write something more easily?\n\n\n75\nTelling Gherkin stories with impact\nIf you think the narrative captures the business situation well enough, you can also put\nit into the specification brief. As long as you keep a beginner’s mind and write noth-\ning about your system in the narrative, it shouldn’t be redundant to the scenarios in\nthe specification. Instead, it should capture a broader business perspective and the\nneed for the requirement that arose long before your team wrote any code. \n3.3.2\nVetting acceptance criteria with examples\nA great way to generate new scenarios is to take advantage of the fact that acceptance\ncriteria and examples vet each other. By vetting, I mean that finding an acceptance cri-\nterion you haven’t yet considered can lead to adding new examples to your scenarios\n(see figure 3.1). But examples that are unexpected, weren’t considered seriously at\nfirst, or were discovered later in the process can also generate new acceptance criteria\n(see figure 3.2).\nExamples illustrate acceptance criteria. So when you take on a new example, you also\nagree to apply a new rule to your design or modify an existing one.\n You can start your analysis with either looking for examples or gathering an initial\nlist of acceptance criteria. There isn’t a strict rule for that, because you’ll probably go\nback and forth multiple times during development.\n Where you start from depends on the conversation you want to have. Exploring\nexamples first works best when you don’t have a good grasp of the system’s rules yet or\nwhen you want to challenge the stereotypical assumptions of your interlocutors. Col-\nlecting acceptance criteria first works better when you or your stakeholders have a\ngood initial understanding of what you’re about to build—for example, when you’re\nautomating a well-described process that’s an industry standard. \n3.3.3\nExploring contexts by questioning Givens\nIt’s easy to get stuck again after you finish writing a scenario. I can’t tell you how many\ntimes I’ve said “So—that’s it!” after writing a scenario, only to discover much later that\nmy complacency led me to overlook a subtle edge case that I then had to take care of.\nI was surprised the first time it happened. But after a similar situation occurred a few\nweeks later, I knew I had to be more careful. The problem was, even when I was\nExamples\nAcceptance\ncriteria\nCan generate new\nFigure 3.1\nYou can use a few \nobvious acceptance criteria as a \nchecklist to discover examples that \nwill help you explore the requirement.\nExamples\nAcceptance\ncriteria\nCan generate new\nFigure 3.2\nUnexpected examples \nchallenge acceptance criteria to \nensure a system’s completeness.\n\n\n76\nCHAPTER 3\nMastering the Given-When-Then template\ncautious, the sense of closure I felt after writing each scenario made it difficult to look\nat it again with fresh eyes.\n One of the methods I encountered when I wanted to solve this problem is called\ncontext questioning.4 To use this pattern, ask yourself, “Is there a context that, for the\nsame event, produces a different outcome?”\n Let me give you an example. Here’s a scenario you’ve already seen in this chapter:\nScenario: Revising drafts\nGiven a draft of \"Lolita\"\nWhen Vladimir makes a new revision\nThen the new draft should replace the previous draft\nAre there any other Givens that produce different Thens for the same event? Are there\nany kinds of drafts that, when Vladimir makes a new revision, shouldn’t replace the pre-\nvious edit?\n What if Queneau stores the drafts in the cloud? You could, for example, encounter\na synchronization conflict in the same draft between two devices, such as a mobile\nphone and a laptop. When a sync issue arises, you probably shouldn’t discard any of\nthe drafts—neither the one you store in the cloud nor the one that’s being saved. \n3.3.4\nExploring outcomes by questioning Thens\nContext questioning is a great technique to get you unstuck and help you write sce-\nnarios that are more complete, but it isn’t the only one. In the same book, Liz Keogh\ntalks about outcome questioning. To question outcomes, ask yourself, “Is there another\noutcome that also matters?”\n Let’s stay in the same area as the previous example: saving files in the cloud. Sup-\npose Queneau offers a free 50 MB cloud plan for everyone. When a user runs out of\nspace, they should upgrade to continue using the cloud feature:\nScenario: Upgrading cloud plans\nGiven a 50 MB limit on Vladimir's cloud drive\nAnd 50 MB of text documents on Vladimir's cloud drive\nWhen Vladimir tries to save a new revision in the cloud\nThen he should be upgraded to a plan with more space\nHaven’t you forgotten something? I once heard that making a profit is a nice thing to\ndo in the software business—so maybe you should also make sure you charge Vladi-\nmir’s credit card. Here’s the scenario after outcome questioning:\nScenario: Upgrading cloud plans\nGiven a 50 MB limit on Vladimir's cloud drive\nAnd 50 MB of text documents on Vladimir's cloud drive\nWhen Vladimir tries to save a new revision in the cloud\n4 I first read about context questioning in a book called Behaviour Driven Development by Liz Keogh (Leanpub,\n2015).\n\n\n77\nAnswers to exercises\nThen he should be upgraded to a plan with more space\nAnd his credit card should be charged $5\nBut there are two separate outcomes here. Should they be in the same scenario, or in\ndifferent ones? A good rule of thumb is to ask whether they can happen separately. If\nthey can’t, they should be in the same scenario. But if they can, you need to ask whether\nthe outcomes are related to the same business domain. If they aren’t, they’re probably\ntwo separate requirements and should be separated so the specification suite will be\norganized more clearly and have good searchability. I’ll talk more about this in chapters\n8 and 9, which explore the topic of organizing scenarios and specification suites.\nI’ll talk about the concept of the specification suite as a map of requirements more in\nchapters 8–11. For now, we’ll use the rule of thumb I discussed previously. \n3.4\nAnswers to exercises\nEXERCISE 1\nRewrite listing 3.4 in the declarative style:\nGiven a draft to export\nWhen Vladimir saves \"Lolita\" as a PDF\nThen a formatted PDF should appear where Vladimir saved it\nEXERCISE 2\nRewrite the user actions from listing 3.7 as a user task:\nGiven a 50 pages long draft\nWhen Vladimir wants to print the entire draft as low-quality A4\nThen the printer should print 50 low quality A4 pages\nEXERCISE 3\nRewrite the following step into a passive Given: Given Vladimir wants\nto write a new book:\nGiven a new book idea by Vladimir\nEXERCISE 4\nRewrite listing 3.13 to reduce its level of abstraction. For the purpose of\nthe exercise, you can assume that there’s only one way to improve the readability\nscore: by making long sentences shorter:\nGiven text with a low readability score:\n\"\"\"\nAs he crossed toward the pharmacy at the corner he involuntarily turned his\nhead because of a burst of light that had ricocheted from his temple, and\nsaw, with that quick smile with which we greet a rainbow or a rose, a\nblindingly white parallelogram of sky being unloaded from the van—a dresser\nExercise 6\nAre concepts such as cloud features and buying extra space in the same domain as\ncharging the user’s credit card?\n\n\n78\nCHAPTER 3\nMastering the Given-When-Then template\nwith mirror across which, as across a cinema screen, passed a flawlessly\nclear reflection of boughs sliding and swaying not arboreally, but with a\nhuman vacillation, produced by the nature of those who were carrying this\nsky, these boughs, this gliding façade.\n\"\"\"\nWhen Vladimir breaks his long sentence into multiple ones:\n\"\"\"\nAs he crossed toward the pharmacy at the corner\nhe involuntarily turned his head.\n--\nA burst of light ricocheted from his temple.\n--\nHe saw, with that quick smile with which we greet\na rainbow or a rose, a blindingly white\nparallelogram of sky being unloaded from the van.\n--\nIt was like a dresser with mirror across which,\nas across a cinema screen, passed a flawlessly clear\nreflection of boughs sliding and swaying.\n--\nIt did so not arboreally, but with a human\nvacillation, produced by the nature of those who\nwere carrying this sky, these boughs,\nthis gliding façade.\n\"\"\"\nThen his readability score should improve\nEXERCISE 5\nWrite a warm-up narrative for Vladimir and the Focus Mode feature:\n\"Every writer is at heart a\nprocrastinator, because writing is an exhausting difficult\nprocess—especially writing prose. Vladimir knows that, too, even though\nhe may not want to admit it so easily.\n\"When the deadline comes, he won't have a choice anymore and he'll be\nforced to focus and get rid of any distractions under pressure. Here's\nwhere we and our Focus Mode can help.\n\"So what, possibly, can distract a writer sitting in front of his PC?\nOther programs—Facebook, Twitter, and so on—so we'll make the\neditor full screen.\n\"But what about the sentences he already wrote? He'll want to edit them\neven though it would be better to move on for now and do it later—so we\ncan, for example, dim all the sentences apart from the one that's\ncurrently being written.\n\"Vladimir certainly listens to music, because everybody listens to music.\nBut is the music Vladimir listens to the right music to increase his focus?\nWe could provide a short ambient playlist built into our Focus Mode that\nwould guarantee to boost his productivity based on new psychology\nresearch.\"\nEXERCISE 6\nAre concepts such as cloud features and buying extra space in the same\ndomain as charging the user’s credit card?\n\n\n79\nSummary\n There are at least two domains in play here:\nThe payments domain should only deal with processing payments, managing\ncredit cards, and dealing with refunds.\nThe cloud domain doesn’t necessarily have to be connected to the payments\ndomain.\nFor example, you could easily imagine a change in Queneau’s business model that\nwould make all the cloud features available for free. In that case, you’d need to keep\nall the cloud scenarios but remove from them all mentions of paid and free plans. To\navoid that, you should specify cloud functionality and paid plan limits separately.\n3.5\nSummary\nOutside-in development is a methodology that aims to build a clear understand-\ning of the goals and motivations of stakeholders.\nStart writing your next scenario with a Then to put emphasis on outcomes that\nare important for stakeholders.\nTo keep scenarios short, sweet, and simple, aim to use only one When per sce-\nnario.\n\nWhens should describe business rules and business-driven behaviors, instead of\nsystem implementations or the UI.\nTo separate context from actions and consequences, write Givens using passive\nvoice and past tense.\nA warm-up narrative briefly sketches out a few moments in a day in the life of\none of the actors.\nVetting examples means exploring the boundaries of acceptance criteria by\nadding or removing examples and checking whether the criteria are still valid.\nContext questioning means looking for other possible Givens and Thens for the\nsame Whens.\nOutcome questioning means looking for other possible Thens for the same\nGivens and Thens.\n\n\n80\nThe basics of\nscenario outlines\nChapters 2 and 3 explored the art of writing scenarios. You learned several tech-\nniques that make creating new scenarios easy and fun. And that’s fantastic! After\nall, the gentle learning curve is what makes Gherkin so beginner-friendly. But this\nsimplicity is also what makes creating a stable specification suite difficult from a\nlong-term perspective. Gherkin is almost too easy to write, so it’s also easy to pick\nup bad habits.\n While writing this chapter, I looked at several of my first feature files: some\nwere longer than 500 lines, even though most of the scenarios were similar. As I\nread the full specification, I understood why. The feature was a reporting system\nThis chapter covers\nUnderstanding scenario outlines versus \nscenarios\nRemoving redundancies in scenarios with DRY\nComparing advantages and disadvantages of \nscenario outlines\nMaintaining scenario outlines over time\n\n\n81\nExample shopping application\nfor conversion metrics. The scenarios looked as if I wrote a main scenario and then\ncopied it multiple times to play with different metrics, changing only the numbers\nand trying to make sure the calculations would be implemented exactly as they\nshould be. I had good intentions, but I wasted a lot of space—and the readability\nwasn’t perfect, either. Looking back, I saw that my desire to be precise backfired.\nGoing through one feature file took almost an hour, as I tried to re-create my think-\ning. When I finished, I felt sorry for my former teammates.\n Surely there must be a better approach than copying and pasting scenarios! Today,\nI can laugh at my former self, because I know one: scenario outlines.\nDEFINITION\nScenario outline—A template that similar scenarios can share so\nyou don’t have to repeat the same Given-When-Then template throughout\nyour feature file\nScenario outlines look similar to normal scenarios, but there are some differences\nthat I’ll talk about throughout the chapter.\n The process of getting from raw scenarios to reusable scenario outlines is usually iter-\native, as you’ll see later. When I talked about key process patterns of SBE in chapter 1, I\ncalled the process refining examples. That means taking raw examples and doing the\nfollowing:\nMerging similar examples\nRemoving irrelevant examples\nFocusing on key examples\nMaking sure key examples are easy to understand\nOutlines can help you do all that efficiently.\n Using scenario outlines is a difficult skill to get right. That’s why we’ll explore the\ntopic in two connected chapters. This chapter covers the basics: you’ll go through a\ntutorial to learn the syntax, and you’ll learn how to apply that syntax to a real-world\nproject. You’ll also see that outlines can change—grow or shrink—over time, and why\nthat happens. After you understand how outlines work, we’ll examine the advantages\nand disadvantages they bring to the table. Then, chapter 5 will talk about advanced\ntechniques for using scenario outlines—techniques that elevate the upsides to their\nfull potential, simultaneously reducing the downsides.\n4.1\nExample shopping application\nA single example runs through the course of chapters 4 and 5: an e-commerce shop-\nping application similar to Amazon—the everything store. Like Amazon, this company\nhopes to become the go-to retailer of books, movies, music, and games, along with\nelectronics, toys, apparel, sports, tools, groceries, and garden items.\n The company’s plans for the future are ambitious. Right now, though, the store\nsells only books in digital formats, such as PDFs and audiobooks. It’s still an early-stage\nstart-up; building a digital shop was the easiest way to release the minimal viable pro-\nduct and start growing revenue.\n\n\n82\nCHAPTER 4\nThe basics of scenario outlines\n Now, management feels that it’s high time for the company to move from digital-\nonly to selling physical items, too. They choose to begin selling physical-format publi-\ncations, such as hardcovers, paperbacks, and audio CDs, for two reasons. First, the\ncompany is already a book-selling start-up, so there will be no rebranding expenses.\nSecond, and more important, shipping publications in physical formats will require\nbuilding a working shipping infrastructure. The company can use such an infrastruc-\nture in the future to add new products such as toys and tools. \n4.2\nUsing scenario outlines\nThis section reviews an existing feature file for one of the core functionalities of the\nstore: shipping orders. Because shipping digital products isn’t the same as selling\nphysical ones, you’ll need to add some new scenarios to specify new shipping capabili-\nties for the system.\n Along the way, you’ll notice that the scenarios become too similar, which makes for\nboring reading, and that the feature file grows in size, which doesn’t seem efficient.\nYou’ll then rewrite the feature file by merging multiple scenarios into a single sce-\nnario outline.\n4.2.1\nSpotting redundancies in Gherkin scenarios\nManagement has given you a green light to implement shipping physical orders. Even\nthough this is a huge change, you won’t start from scratch. Fortunately, your system\nalready has basic functionalities, such as an order-status page, that you can expand on.\nIn addition, you can connect with external shipping APIs and let other companies\nhandle behind-the-scenes shipment management. The only thing you have to do right\nnow is specify how customers will order shipping for the new formats you’re going to\noffer, and implement the scenarios.\n Before you do that, though, let’s look at the two existing scenarios. They were writ-\nten a few months ago to handle the most basic use cases.\nFeature: Shipping\nScenario: Shipping PDFs\nGiven a PDF book in Simona's cart\nWhen she pays for it\nThen the book should be sent to a mobile device\nScenario: Shipping audiobooks\nGiven an audiobook in Simona's cart\nWhen she pays for it\nThen the book should be sent over email\nWith digital books, the case is simple. They’re sent either by email or directly to a\nmobile device such as a Kindle reader. Going physical will force you to let customers\nListing 4.1\nTwo simple initial scenarios\n\n\n83\nUsing scenario outlines\nprovide their shipping addresses and make sure the books they buy are shipped by\nintegrating with external APIs from a shipping company—a task that will probably be\nhandled in the automation layer.\n Have you noticed that the two scenarios in listing 4.1 look almost the same? They\nshare the same basic structure due to an example-counterexample relationship. Because\nthere are only two ways to ship a digital order—device integration and email down-\nload link—each scenario is a counterexample to the other. Whoever wrote this feature\nfile clearly wanted to let you know that the system ships PDFs differently than audio-\nbooks.\n To illustrate contrast, examples and counterexamples usually share the same basic\nstructure, differing only in details. In the example’s two scenarios, the Whens are iden-\ntical. They make Simona pay for her order:\nWhen she pays for it\nThe repeating When creates the underlying structure of the scenarios. The differences\nlie in the Givens and Thens, but even they are similar.\n In Gherkin, repetition isn’t uncommon. Although the syntax looks like a natural\nlanguage, the scenarios often aren’t pretty. They’re written and read by technical\nteams or busy nontechnical stakeholders who often value brevity over beauty. Some\nredundancies are to be expected—especially in shorter specifications. Even though\nthis isn’t a problem in a two-scenario feature file, you’ll see that there are cases where\nrepetition becomes too awkward to dismiss in writing and too difficult to maintain in\nthe specification suite long-term.\n Let’s see what happens when you add the new physical formats and shipping fea-\ntures. Here are the three types of books the company has decided to add:\nHardcovers\nPaperbacks\nAudio CDs\nUnlike the digital formats, these are sent to the user’s shipping address by an external\nshipping company; see table 4.1.\nTable 4.1\nAll book formats\nFormat\nShipped …\nPDF\nTo a mobile device\nAudiobook\nWith an email download link\nHardcover\nTo a shipping address\nPaperback\nTo a shipping address\nAudio CD\nTo a shipping address\n\n\n84\nCHAPTER 4\nThe basics of scenario outlines\nThe new scenarios should be easy enough to write. After all, you’re going to use the\nsame template that you established when you analyzed the initial examples.\nFeature: Shipping\nScenario: Shipping PDFs\nGiven a PDF book in Simona's cart\nWhen she pays for it\nThen the book should be sent to a mobile device\nScenario: Shipping audiobooks\nGiven an audiobook in Simona's cart\nWhen she pays for it\nThen the book should be sent over email\nScenario: Shipping hardcovers\nGiven a hardcover book in Simona's cart\nWhen she pays for it\nThen the book should be shipped physically\nScenario: Shipping paperbacks\nGiven a paperback book in Simona's cart\nWhen she pays for it\nThen the book should be shipped physically\nScenario: Shipping Audio CDs\nGiven an Audio CD book in Simona's cart\nWhen she pays for it\nThen the book should be shipped physically\nNow it’s even worse, isn’t it? You’ve ended up with five scenarios that are almost\nexactly the same. It’s an inelegant, inefficient solution. It also isn’t perfect from a\nreadability standpoint. I can imagine people reading only the first scenario and then\nskimming through the remaining examples—which is warranted in this case, but a\nbad habit in general. What if some of the scenarios hide an important detail despite\nlooking similar to the others? A skimming reader could easily miss that. How can you\nmake sure that won’t happen?\n4.2.2\nRefactoring redundant scenarios with scenario outlines\nIdeally, you want to have two types of scenarios:\nScenarios that visually group similar examples together and use the same\nunderlying template for all examples. The visual grouping notifies the reader\nthat it’s safe to skim the examples.\nScenarios that are important enough to stand on their own, letting readers\nknow they should focus when reading them.\nListing 4.2\nScenarios with new shipping options added\nThree new \nscenarios\n\n\n85\nUsing scenario outlines\nThe first type of scenarios are, in fact, scenario outlines. To understand how scenario\noutlines work, you’ll have to forget the rule about using concrete examples—only for\na little while, and only to see whether adding a bit of abstraction will help remove\nredundancy from your scenarios. You’ll also look for a way to visually distinguish simi-\nlar steps and build a shared template for such scenarios.\n In the online store, you’ve added the new book formats and ended up with five dif-\nferent Givens splattered throughout your feature file:\n\nGiven a PDF book in Simona’s cart\n\nGiven an audiobook in Simona’s cart\n\nGiven a hardcover book in Simona’s cart\n\nGiven a paperback book in Simona’s cart\n\nGiven an Audio CD book in Simona’s cart\nBecause they all share the same sentence structure, they can easily be abstracted away\ninto a simple template similar to this:\nGiven a <format> book in Simona's cart\nWe already noted that each of the five scenarios in the specification uses the same\nWhen to perform the main action, so let’s add that step to the template:\nGiven a <format> book in Simona's cart\nWhen she pays for it\nThe only thing left is taking care of the Thens. Just as there are several kinds of Givens,\nthere are also several different kinds of Thens:\n\nThen the book should be sent to a mobile device\n\nThen the book should be sent over email\n\nThen the book should be shipped physically\nThe list is shorter this time, but remember that the three scenarios for hardcovers,\npaperbacks, and audio CDs use the same Then because these formats are shipped\nusing the same method. Despite that, the three Thens can be abstracted away into a\nsimilar template:\nThen the book should be <shipped>\nThe result is a scenario template similar to the following.\nGiven a <format> book in Simona's cart\nWhen she pays for it\nThen the book should be <shipped>\nLook back for a moment at table 4.1. Notice the <format> and <shipped> attributes\nfrom the scenario template and the header row. You could use the table to put each of\nthe formats in the scenario template, along with an accompanying shipping method.\nListing 4.3\nFull scenario template\n\n\n86\nCHAPTER 4\nThe basics of scenario outlines\nAnd if you could make the <shipped> attribute dependent on the <format> attribute\nin the automation layer, you could change the outcome of the scenario based on your\ntemplate every time you executed the specification suite—without changing the rest\nof the steps!\n The good news is, you can do that. The template in listing 4.3 is valid Gherkin.\nGherkin lets you group similar scenarios that share the same structure in a scenario out-\nline: an automatable template for removing redundancy in similar scenarios. Outlines\nuse visual signs such as attributes and tables to group related examples so you don’t\nhave to worry about missing anything important. \n4.3\nThe structure of a scenario outline\nHere’s what a full scenario outline looks like.\nFeature: Shipping\nScenario Outline: Shipping\nGiven a <format> book in Simona's cart\nWhen she pays for it\nThen the book should be <shipped>\nExamples:\n| format\n| shipped\n|\n| PDF\n| sent to a mobile device |\n| Audiobook | sent over email\n|\n| Hardcover | shipped physically\n|\n| Paperback | shipped physically\n|\n| Audio CD\n| shipped physically\n|\nThe result is similar to the process you analyzed back in figure 1.9 (repeated here in\nfigure 4.1), when I talked about the process of collecting and refining examples.\nThanks to scenario outlines, you can take raw examples from raw scenarios and put them\ninto refined scenario groups. Grouping raw examples is possible because every outline\nis built from three elements: the Scenario Outline keyword, parameters, and the\nExamples table. The following sections analyze this structure, starting with the end:\nthe Examples table.\n4.3.1\nThe Examples table\nThe Examples table contains all the examples. The syntax is straightforward. Tables\ncan be created easily: use a vertical stroke (|) as the first character of the line, and also\nseparate table cells with it. The first row is the header row containing the Scenario\nOutline parameters. After the header, each example has its own row. \nListing 4.4\nIntroducing a scenario outline\nScenario Outline is the keyword that \nlets the test runner recognize outlines.\nTwo parameters: \nformat and shipped\nExamples with which to \nreplace the angle brackets\n",
      "page_number": 82
    },
    {
      "number": 4,
      "title": "The basics of scenario outlines",
      "start_page": 108,
      "end_page": 123,
      "detection_method": "regex_chapter",
      "content": "87\nThe structure of a scenario outline\n4.3.2\nParameters\nThe Scenario Outline parameters go in angle brackets (<>), like <format> and\n<shipped>. They allow the test runner to paste the examples from the table into the\noutline you’ve written.\n If you have the following steps\nGiven a <format> book in Simona's cart\nWhen she pays for it\nThen the book should be <shipped>\nand the following table, which is a simplified version of the full table\nExamples:\n| format\n| shipped\n|\n| PDF\n| sent to a mobile device |\n| Audiobook | sent over email\n|\nthen Scenario Outline will produce and run two scenarios:\n\n<format> is replaced with PDF and <shipped> is replaced with sent to a\nmobile device\n\n<format> is replaced with Audiobook and <shipped> is replaced with sent over\nemail.\nRaw examples\nRaw scenario\nRaw examples\nAcceptance\ncriterion\nRaw scenario\nRefined example\nRefined scenario\nRefined example\nRaw examples\nRaw scenario\nRefined scenarios contain\nonly key examples needed to\nunderstand the criterion.\nAn acceptance criterion \nneeds examples that pass \nor fail the criterion.\nRaw examples generate\nraw scenarios that often \nhave similar structure.\nFigure 4.1\nEvery acceptance criterion generates new examples; every example generates \na new scenario. Teams should refine their specifications to merge similar examples, reject \nthose that introduce noise, and choose the most meaningful or descriptive ones.\n\n\n88\nCHAPTER 4\nThe basics of scenario outlines\nThus, scenario 1 will run as\nGiven a PDF book in Simona's cart\nWhen she pays for it\nThen the book should be sent to a mobile device\nand scenario 2 will run as\nGiven an audiobook in Simona's cart\nWhen she pays for it\nThen the book should be sent over email\nEach step from the generated scenarios will have an accompanying step definition in\nthe automation layer that lets each example run as an automated test.\n Outlines rely on patterns to match attributes with the examples from the table.\nWhen a test runner sees a Gherkin scenario with multiple examples, it runs the sce-\nnario template as many times as there are examples, replacing abstract attributes with\nthe concrete values dictated. Each time, it replaces a pattern called <pattern_name>\nwith a corresponding example. Every pattern’s name must be written without any\nspaces and within angle brackets.\nTIP\nIf you’re curious about how to automate scenario outlines, check out\nsection A.6 in the appendix, which talks about executing scenarios with multi-\nple examples.\nWith scenario outlines, you can test for multiple cases that share similarities but yield\ndifferent outcomes. The simplest examples are two contrasting cases for the same\nacceptance criterion: a success scenario and a failure scenario. The success scenario\ndefines what conditions are needed for the user to succeed, given the user’s inten-\ntions. Failure scenarios, on the other hand, define every other behavior that will fall\nshort.\n As you can see, merging similar scenarios means writing separate scenarios first\nand looking for similarities later. It’s a simple technique used by beginners. People\ngenerally use it in order to not break the Don’t Repeat Yourself (DRY) principle of soft-\nware development. This principle, aimed at reducing repetition of information of all\nkinds, states that you shouldn’t write similar code twice. \n4.3.3\nThe Scenario Outline keyword\nThe Scenario Outline keyword at the beginning of listing 4.4—the Scenario Outline:\nShipping part—notifies the test runner that it should execute the outline as many\ntimes as there are examples in the table. If you need additional information about key-\nwords, the automation layer, and executing scenarios, refer back to sections 2.1, 2.3,\nand 2.5. \n\n\n89\nAdvantages of scenario outlines\n4.4\nAdvantages of scenario outlines\nNow that you understand how to use scenario outlines, let’s talk about why you’d want\nto. In addition to the DRY principle mentioned in the previous section, outlines offer\ntwo other advantages for your executable specifications:\nOutlines take much less space.\nOutlines group concrete examples according to high-level business rules.\n4.4.1\nShorter feature files\nThe first and foremost reason to use scenario outlines is brevity. In the example, when\nyou refactored the five scenarios into a single outline, you saved 16 lines—a 52%\ndecrease in length. That’s a lot of space, even though shipping functionality is a sim-\nple case to specify in terms of business complexity and you didn’t have many scenarios\nto begin with. \n4.4.2\nFeature files organized by high-level business rules\nScenario outlines also increase your scenarios’ level of abstraction without sacrificing\nthe focus on concrete, real-world examples. In the last few years, I’ve seen and written\nmany feature files that were longer and much more difficult than the one in the exam-\nple. And although saving space is a nice side benefit, the real problem with longer\nspecifications is that they become more difficult to grasp at a glance because you can’t\nbe sure how particular scenarios relate to each other. Here’s an example to show you\nwhat I mean.\n Imagine that you have 10 or more scenarios in a single feature file. Some of the\nscenarios talk about distinct business rules; others cover different cases of a single\ncomplex rule; and, last but not least, some test important edge cases pointed out by\ntesters. If you want to search for a particular scenario, it’s much harder to find it in a\nmessy specification suite like that. You’ll naturally want to group such scenarios into\nseveral easy-to-find cohorts—and scenario outlines let you do that. When you use out-\nlines, you can be sure that every scenario covers only a single business rule and that\ndifferent applications of that rule are listed in the Examples table. In that regard,\nGherkin is similar to legal reasoning. In Gherkin, scenarios are easier to digest when\nthere are only a few rules to obey; but, like in law, the more rules you have, the messier\nand more complicated an entire codex becomes.\n For example, many countries in medieval Europe had laws specifying different\npenalties for stealing or killing various kinds of livestock. To enforce the rules, the\nsheriff had to remember that stealing a chicken should cost X and that stealing a cow\nshould cost Y, arbitrary amounts. It would have been much easier to make a general\nrule that, for example, tied indemnities to the average price of similar livestock in the\ncapital’s marketplace. If countries had done that, they could have illustrated the rule\nwith concrete examples based on market prices measured the previous summer, to be\nsure the sheriff and the citizens were on the same page.\n\n\n90\nCHAPTER 4\nThe basics of scenario outlines\n The same principles apply to executable specifications. Remember when you\nadded new book formats to the scenario outline? At first, you had only two specific\nscenarios without a general rule in place. Each scenario specified how one of the two\nbook formats was shipped. But as you added new examples, the specification got mess-\nier, and the abundance of concrete examples didn’t look elegant. So from those two\nscenarios, you derived a general rule for shipping and rewrote it as a scenario outline.\nIn a way, you went through a process similar to how legal reasoning evolved through-\nout the last millennium—but you did so over the course of a single chapter, instead of\n1,000 years. Point for you.\n Although scenario outlines won’t solve all the problems you’ll encounter when\nmanaging large specification suites, they can work well on the level of a single feature\nfile. And we’ll visit management at the level of the entire suite in chapters 8 and 9. \n4.5\nGrowing and maintaining scenario outlines\nIn the world of continuous deployment and short release cycles, no feature is ever set\nin stone. Such flexibility lets delivery teams that use iterative software development\nprocesses build smaller features that take less time to develop and that can be\nexpanded in the future. As features expand, so do scenario outlines. Although sce-\nnario outlines do make feature files shorter, they, too, can grow to a size at which man-\naging an outline becomes a problem.\n To illustrate how that happens, let’s return to the example. Assume that develop-\nment was smooth and the feature was safely deployed to production. That’s great! But\nit doesn’t mean your work is done. Shortly after deployment, you start working on new\niterations of your shipping feature. You’ll begin by expanding the PDF example:\nExamples:\n| format\n| shipped\n|\n| PDF\n| sent to a mobile device |\n| Audiobook | sent over email\n|\n| Hardcover | shipped physically\n|\n| Paperback | shipped physically\n|\n| Audio CD\n| shipped physically\n|\nWhen it comes to mobile devices, there are at least three major mobile platforms to\nconsider: Apple’s, Google’s, and Amazon’s. When you first implemented the feature\nfor mobile integration, you decided that books in the PDF format should be shipped\ndirectly to a customer’s mobile device. You decided to use an external integration pro-\nvider. The provider maintained a single API endpoint for integrating with all three\nplatforms at once, which was convenient at the time. Unfortunately, your design team\ndecided recently that a shallow integration like that isn’t enough in terms of user\nexperience. Each of the three platforms you support has a standalone e-book reader:\niBooks, Google Play Books, and Kindle. You’d like to develop a deeper integration\nwith each of these ecosystems, to control the overall user experience without forcing\nusers to install additional apps beyond what they already have.\nExample you’ll \niteratively expand\n\n\n91\nGrowing and maintaining scenario outlines\n As you can see, the example that was fine in the past lacks necessary detail in this\narea. To fix that, the team has agreed that you need to split the single example into\nthree examples—one for each of the new deep mobile integrations. Based on that,\nyou’ll then rewrite the application code. And later, you’ll have to write new testing\ncode for each example in the automation layer, too.\n Let’s get ready to work! Here’s what a reworked scenario outline could look like.\nFeature: Shipping\nScenario Outline: Shipping books that were bought\nGiven a <format> book in Simona's cart\nWhen she pays for it\nThen the book should be <shipped> by <provider>\nExamples:\n| format\n| shipped\n| provider\n|\n| PDF\n| sent to a mobile device | Apple\n|\n| PDF\n| sent to a mobile device | Google\n|\n| PDF\n| sent to a mobile device | Amazon\n|\n| Audiobook | sent over email\n| in-house service |\n| Hardcover | shipped physically\n| postal service\n|\n| Paperback | shipped physically\n| postal service\n|\n| Audio CD\n| shipped physically\n| postal service\n|\nThe automation layer can now have a different technical test for each provider in the\nstep definitions. In terms of numbers, you’ve removed one example and added three\nmore. The table grew larger. Ten examples aren’t difficult to maintain, but you know\nthat selling books is just the first step for your e-commerce company.\n At the beginning of this chapter, I mentioned that the company wanted to be the\nonline retailer of books, movies, music, games, electronics, toys, apparel, sports, tools,\ngroceries, and garden items—even though it initially only sold books. Soon, the com-\npany decided to begin its expansion by adding products such e-readers, tablets, and\nheadphones, chosen to fit into the store’s reading landscape. Such products are too\nprecious to be casually shipped by a postal service; they need to be shipped by courier\ndelivery.\n As soon as everyone agreed on the details, your team updated the specification to\ninclude new examples.\nFeature: Shipping\nScenario Outline: Shipping\nGiven an <item> in Simona's cart\nWhen she pays for it\nThen the book should be <shipped> by <provider>\nListing 4.5\nReworked scenario outline\nListing 4.6\n[OK] Scenario outline with a growing list of examples\nSeparate example\nfor Apple devices\nSeparate\nexample\nfor Google\ndevices\nSeparate \nexample \nfor Amazon \ndevices\n\n\n92\nCHAPTER 4\nThe basics of scenario outlines\nExamples:\n| item\n| shipped\n| provider\n|\n| PDF e-book\n| sent to mobile device | Apple\n|\n| PDF e-book\n| sent to mobile device | Google\n|\n| PDF e-book\n| sent to mobile device | Amazon\n|\n| Audiobook\n| sent over email\n| in-house service |\n| Hardcover book | shipped physically\n| postal service\n|\n| Paperback book | shipped physically\n| postal service\n|\n| Audio CD\n| shipped physically\n| postal service\n|\n| E-reader\n| shipped physically\n| courier delivery |\n| Tablet\n| shipped physically\n| courier delivery |\n| Headphone\n| shipped physically\n| courier delivery |\nWith the three new examples, you now have 10 examples overall—which is quite a few.\nAnd you’re still not finished. In the future, there will probably be even more examples\nas the store grows and new shipment methods appear. Organizing the examples in a\nmore efficient way would probably be a wise thing to do before you end up with a\nmessy specification.\n Gherkin lets you organize examples into multiple tables. You can split examples\ninto two or more tables and name each table accordingly to explain what the exam-\nples do and why they’re there. So if you have a generic table of four numbers that\nlooks similar to this\nExamples:\n| Number |\n| 1\n|\n| 2\n|\n| 3\n|\n| 4\n|\nyou can split it into two tables:\nExamples: Odd numbers\n| Number |\n| 1\n|\n| 3\n|\nExamples: Even numbers\n| Number |\n| 2\n|\n| 4\n|\nThe result is valid Gherkin code that any Gherkin-compatible test runner can easily\nunderstand.\n That seems like the perfect solution to the problem in the example, so let’s use it\nto tidy up the scenario outline.\nE-readers \nadded to \nthe store\nTablets\nadded to\nthe store\nHeadphones added\nto the store\nTables can have names.\nEach table contains \nits own examples.\nTables can have names.\nEach table contains \nits own examples.\n\n\n93\nGrowing and maintaining scenario outlines\n \nFeature: Shipping\nScenario Outline: Shipping\nGiven an <item> in Simona's cart\nWhen she pays for it\nThen the book should be <shipped> by <provider>\nExamples: Ship by sending to a mobile device\n| item\n | shipped\n| provider |\n| PDF e-book | sent to mobile device | Apple\n|\n| PDF e-book | sent to mobile device | Google\n|\n| PDF e-book | sent to mobile device | Amazon\n|\nExamples: Ship by sending a download link\n| item\n| shipped\n| provider\n|\n| Audiobook | sent over email | in-house service |\nExamples: Ship by a postal service\n| item\n| shipped\n| provider\n|\n| Hardcover book | shipped physically | postal service\n|\n| Paperback book | shipped physically | postal service\n|\n| Audio CD\n| shipped physically | postal service\n|\nExamples: Ship by courier\n| item\n| shipped\n| provider\n|\n| E-reader\n| shipped physically | courier delivery |\n| Tablet\n| shipped physically | courier delivery |\n| Headphone | shipped physically | courier delivery |\nThis listing organizes examples by shipping method. Each shipping method has its own\nlist of examples. No table is longer than three examples—such a neat categorization!\n But let’s check whether using multiple tables with examples will bring you more\nflexibility in the long term. At the moment, you sell and ship these items:\nDigital books on three platforms: Apple, Google, and Amazon\nPhysical books\nAudiobooks\nAudio CD books\nE-readers\nTablets\nHeadphones\nThat’s already a lot, but fast-forward a few more months to when the company decides\nto expand its services once again. This time, management not only wants to sell books\nand electronics, but also decides to grow the company’s entertainment market by add-\ning downloadable movies to the catalogue. And like e-books, movies should integrate\nout of the box with the three major platforms: Apple’s, Google’s, and Amazon’s.\nListing 4.7\n[BETTER] Examples grouped in separate tables\nTable for shipping \nmobile products\nTable for products \nthat can be \ndownloaded\nTable for shipping \nproducts via postal \nservices\nTable for \nshipping \nproducts by \ncourier\n\n\n94\nCHAPTER 4\nThe basics of scenario outlines\n That should guarantee a few new examples, shouldn’t it? But in keeping with the\nflexibility of scenario outlines with multiple tables, adding the additional rows\nshouldn’t be much of a problem.\nFeature: Shipping\nScenario Outline: Shipping\nGiven an <item> in Simona's cart\nWhen she pays for it\nThen the book should be <shipped> by <provider>\nExamples: Ship to Apple devices\n| item\n \n| shipped\n| provider |\n| PDF e-book | sent to mobile device | Apple\n|\n| Movie\n | sent to iTunes\n| Apple\n|\nExamples: Ship to Google devices\n| item\n | shipped\n| provider |\n| PDF e-book | sent to mobile device | Google\n|\n| Movie\n | sent to Google Play\n| Google\n|\nExamples: Ship to Amazon devices\n| item\n | shipped\n| provider |\n| PDF e-book | sent to mobile device | Amazon\n|\n| Movie\n | sent to Fire TV\n| Amazon\n|\nExamples: Ship by sending a download link\n| item\n | shipped\n| provider\n|\n| Audiobook  | send download link to email | in-house service |\nExamples: Ship by a postal service\n| item\n| shipped\n| provider\n|\n| Hardcover book | shipped physically | postal service |\n| Paperback book | shipped physically | postal service |\n| Audio CD\n| shipped physically | postal service |\nExamples: Ship by courier\n| item\n| shipped\n| provider\n|\n| E-reader\n| shipped physically | courier delivery |\n| Tablet\n| shipped physically | courier delivery |\n| Headphone | shipped physically | courier delivery |\nAdding three new examples was a piece of cake. And even though you now have 13\ndistinct items in the tables, the feature file still looks extremely organized. Such is the\npower of good scenario outlines.\n As the list of examples has expanded, the structure of the outline has also\nchanged. You’ve added new parameters, and you’ve split examples into clear, sepa-\nrated tables. The main takeaway of this section is to remember what many Gherkin\nwriters forget: that scenarios can—and should—be refactored as code. In software\nengineering, code refactoring is the process of restructuring existing computer code—\nchanging the factoring—without changing its external behavior. Gherkin can be\nrefactored, too. \nListing 4.8\nTables that can grow while maintaining readability\nMovies shipped to \nGoogle’s service\nMovies shipped to \nApple’s service\nMovies shipped to \nAmazon’s service\n\n\n95\nSummary\n4.6\nDisadvantages of scenario outlines\nI’ve already said a lot about the upsides of using scenario outlines. You’ve seen how\nthey can group similar scenarios with reusable attributes and tables according to the\nDRY principle. Section 4.4 expanded on the topic of how scenario outlines help orga-\nnize feature files by distinct business rules, resulting in greater readability and search-\nability. And in the previous section, you saw how a single scenario outline can hold\nmultiple examples without losing its focus. These are all good things. But now let’s\nconsider the other side of the story. It’s time to talk about the downsides—because\nthere are some.\n In truth, the Gherkin community tends to frown on using scenario outlines,\nbecause outlines written by inexperienced Gherkin practitioners often look more like\ncode than business-level features. It’s true: the attributes, brackets, and tables can\nsometimes appear scary to people who are new to Gherkin. Unfortunately, that can\nmake outlines less accessible to business stakeholders.\n So should you use scenario outlines or not? The answer isn’t straightforward.\nGood, easy-to-read scenario outlines with business-level examples can play a part in\ngetting buy-in from other stakeholders for using SBE. But bad examples can also\nmake accepting SBE much harder for anyone who isn’t already convinced about using\nthe methodology.\n For example, I worked according to SBE principles on two different projects. In\nboth projects, our team had to use two contrasting approaches. For one project, we\ngot a product owner to work on the scenarios with the delivery team over Git. The\nproduct owner was obviously a tech-savvy person who didn’t mind seeing scenario out-\nlines, even though they looked a bit technical with all the brackets and tables. For the\nsecond project, we never got anyone on the business side to discuss the tests. They\nfound it difficult to talk using Givens, Whens, and Thens and grew discouraged quickly.\nSo we hid all of our process and only asked for examples to get them talking about\ntheir process. We didn’t even show them the scenarios, let alone the scenario outlines.\nWe only discussed tables with examples stored in spreadsheets—and nobody said we\nwere too technical. I’ll teach you that method in chapter 5.\n So yes, scenario outlines can be easily misused—but they can also be effective. My\ngoal is to teach you how to use them well, because, as you’ve seen, the advantages are\nhuge. This is also why, to make sure you get it right, I decided to explore the topic in\ntwo chapters. The first chapter is behind us—on the second step of the journey, we’ll\ntalk about advanced techniques for using scenario outlines. \n4.7\nSummary\nScenario outlines are templates for similar scenarios that can help remove\nredundancy in your executable specifications according to the DRY principle.\nThe Examples table contains the examples and groups them by similarity.\nEach scenario outline can have multiple tables with examples.\n\n\n96\nCHAPTER 4\nThe basics of scenario outlines\nThe parameters in scenario outlines allow test runners to paste the examples\nfrom the table into the outline.\nScenario outlines work best when they group examples by business rules that\nthe examples adhere to.\nA scenario outline can grow over time as new examples appear.\nThe downside of using scenario outlines is that they can appear too technical\nand become code-like if you’re not careful.\n\n\n97\nChoosing examples\nfor scenario outlines\nDid you know that female drivers are 47% more likely than male drivers to be seri-\nously injured in a car crash? When safety regulations were originally imposed on\nautomakers in the 1960s, the government wanted to require the use of two crash\ntest dummies of two slightly different sizes. Doing so would mean that only 5% of\nmen were larger than and 5% of women were smaller than the dummies. But auto-\nmakers pushed back, and, eventually, the requirement was reduced to only one\ncrash test dummy the size of an average male, making tests more standardized.\n Then, in 2011, for the first time female crash test dummies were required in\nsafety testing. The results forced some automakers to slash their safety ratings by\nmore than half, from a top five-star rating to just two stars. According to the test\nThis chapter covers\nWriting advanced scenario outlines\nUsing the outside-in method\nGoing beyond the simplest examples\nTesting diverse outcomes\nFixing bad examples\n\n\n98\nCHAPTER 5\nChoosing examples for scenario outlines\ndata, when a car slams into a barrier at 35 mph, a female dummy in the front passen-\nger seat registers a 20% to 40% risk of being killed or seriously injured. The average\nusing the male dummy is just 15%.\n Even though software is ubiquitous today, software engineering is still a young\nindustry. As such, it has had to borrow useful metaphors, mindsets, and practices from\nother, more mature fields. For example, civil engineering was a major influence.\nThat’s why some of us call ourselves engineers or software architects; it’s also why we\ntalk about building software.\n Automated testing has also had to borrow metaphors. That’s why, not coinciden-\ntally, the simplest examples are often called dummies—just like the fake mannequins in\ncar safety testing. In software engineering, dummy data is generic information that\ndoesn’t contain any real data but can be used as a placeholder. John Doe, for exam-\nple, is a dummy name commonly used by testers. Dummies are used whenever a tester\nor developer needs to make tests pass—they devise a set of dummy values meant to go\nsuccessfully through the validation systems used in the test, without caring about\nwhether these values will appear in the real world.\n But as in the case of female crash test dummies, even the most basic placeholders\ncan influence the results of a test in a dramatic and horrific way. I don’t want to argue\nthat all kinds of tests should use the most realistic data possible—it wouldn’t make\nmuch sense for some low-level unit tests, for example—but I strongly believe that some\ntests should. In section 3.1.2, which talked about advanced techniques for writing new\nscenarios, I made a case for using real-world data when working with SBE. Now, in the\nmiddle of this two-chapter journey through the world of scenario outlines, I feel com-\npelled to reiterate.\n Coming out of chapter 4, you know how to use scenario outlines to contain multi-\nple examples in reusable templates that are easy to manage and grow. But I haven’t yet\ntalked about methods for choosing examples to feature in your outlines. So, this chap-\nter focuses on an outside-in method for writing scenario outlines. Chapter 3 defined\noutside-in development as a software development methodology that aims to create suc-\ncessful software through understanding the goals and motivations of stakeholders. In\na nutshell, outside-in outlines focus on taking examples from the outside world (where\nstakeholders operate) into your product. In contrast, the previous chapter only taught\nyou to use scenario outlines as a method to keep your specifications tidy, without the\nneed to interact with anyone to get the job done.\n I’ll also talk about general rules for choosing meaningful examples for scenario\noutlines and how illustrative tests are different from exhaustive tests. As you progress,\nyou’ll learn that some kinds of tests should be performed in different tools than\nCucumber or other Gherkin-compatible test runners.\n\n\n99\nWriting outside-in scenario outlines\n5.1\nExample shopping application\nTo retain a sense of continuity between the two chapters that talk about scenario out-\nlines, chapter 4 and this chapter use the same example: an e-commerce shopping\napplication similar to Amazon.\n As explained in chapter 4, the company began by selling books, but it wants to be\nthe online retailer of books, movies, music, and much more. It started expanding by\nadding products such as e-readers, tablets, and headphones, chosen to fit into the\nstore’s reading landscape. Next, the company entered the entertainment market by\nadding digitally distributed movies to its catalogue. Although there’s still a lot of work\nahead, the business is already diverse—and, fortunately, full of examples to work with. \n5.2\nWriting outside-in scenario outlines\nAs you already know, scenario outlines are templates for similar scenarios. But what\nyou probably don’t know—and what most people in the Gherkin community don’t\ntalk about often—is that the method you’ve been using to create outlines, based on\nmerging redundant scenarios, is reactive instead of proactive. In this section, I’ll show\nyou a proactive way to write outside-in scenario outlines in Gherkin.\nDEFINITION\nOutside-in scenario outline—A scenario outline written directly\nfrom examples gathered during an analysis phase rather than by merging sim-\nilar scenarios\nThe outside-in method consists of two steps:\n1\nCollect real-world examples for your specification in the form of a table.\n2\nWrite the scenario outline based on the table, adjusting the steps and parame-\nters to the data.\nThis approach requires you to analyze examples first and write scenarios later. The\ntable created in step 1 doesn’t even have to be a Gherkin table—it can be a simple\nspreadsheet created in Excel by you and other stakeholders. The merging method\ndescribed in chapter 4, on the other hand, assumes that you evolve scenarios into sce-\nnario outlines only if you notice any redundancy, and the specification becomes too\ndifficult to manage easily. In that sense, the merging method is much more reactive\nthan the outside-in method.\n Generally, I prefer the outside-in method. Scenario outlines made from merging\noften look too programmatic, which makes business people reluctant to read them. I\nthink it has something to do with Don’t Repeat Yourself (DRY), which is the founding\nprinciple of the merging technique. The cost of elegant structure and reduced redun-\ndancy is often sacrificing Gherkin’s natural language and putting too many things into\nbrackets and parameters. In contrast, the outside-in method puts emphasis on a grad-\nual evolution from a non-Gherkin table, which any nontechnical person can read, to a\nGherkin scenario, which business owners don’t have to read if they’ve already read the\nexamples. The evolutionary process often makes the resulting outline look much\nmore natural.\n\n\n100\nCHAPTER 5\nChoosing examples for scenario outlines\n5.2.1\nCollecting examples for outside-in scenario outlines\nTo derive a scenario outline from examples, you first need some examples. And to get\nexamples, you need a new feature to implement. Luckily, your product owners can\nhappily oblige. The company’s current priority is to get more items into the store to\nexpand its marketplace. Negotiating with big publishers and producers has proven to\nbe difficult, so management wants to open the store to individual merchants who can\nsell both new and used items. The merchants will benefit from the company’s\nadvanced shipping infrastructure—and the company will take a cut from their profits.\n After some analysis, sales and marketing have agreed on a pricing model that\nworks according to the following rules:\nMerchants can create accounts and list new items for free.\nThe company takes a cut after an item is successfully sold.\nThe size of that cut depends on the purchaser’s shipping location, because mer-\nchants have to pay for access to the global customer base available thanks to the\ncompany’s shipping infrastructure.\nSo far so good. Let’s settle on the pricing ranges and remake the list into a draft of the\nExamples table. The commission structure was designed based on shipping distances\nfrom the company’s US operations base and infrastructure in each region (see table 5.1).\n \nSuch a table could easily be the result of a conversation between nontechnical stake-\nholders from sales and marketing and the delivery team of programmers, testers, and\ndesigners. No technical skill is required to create or understand it, because no Gher-\nkin is involved yet. If you fear that scenario outlines are too technical, you can keep\nyour examples at the nontechnical level during your specification workshops; there’s\nnothing wrong with that. \nTable 5.1\nDraft of a table with examples\nRegion\nCommission\nNorth America\n10%\nSouth America\n11.4%\nEurope\n12.9%\nAsia\n12.9%\nAfrica\n13.5%\nExercise 1\nRewrite the table of examples in Gherkin.\n\n\n101\nWriting outside-in scenario outlines\n5.2.2\nWriting outside-in scenario outlines from collected examples\nNow that you have the Examples table, you can write the Givens, Whens, and Thens. To\ndo that, you need to find a scenario template that will work well with the structure of\nthe table. For example, can you see that each entry in the <region> column is like a\nquestion and the corresponding <commission> entry is like an answer to that question?\nNorth America? You take 10% of the purchase.\nSouth America? The cut is 11.4%.\nEurope and Asia? That’s 12.9%.\nAfrica? Be ready to give away 13.5%.\nFrom a technical point of view, the questions define the state of the system before you\ndecide how much of a commission you take—and the answers define an outcome based\non the chosen state. In chapter 3, I said that system states are described by Givens and\nthat the outcomes should be written as Thens. So in a way, you already have two-thirds\nof the scenario ready to write down:\nGiven a purchase from <region>\nThen we should take <commission> of the price\nThat certainly looks promising. But because this is a scenario about sellers, not buyers,\nas in the previous scenarios, you can also add another Given specifying that a mer-\nchant is the main actor. Let’s call the smaller shop Quick-Ship:\nGiven a merchant called Quick-Ship\nAnd a purchase from <region>\nThen we should take <commission> of the price\nYou only need one more step, which specifies the main action of the scenario:\nGiven a merchant called Quick-Ship\nAnd a purchase from <region>\nWhen Quick-Ship gets paid for the purchase\nThen we should take <commission> of the price\nThe last thing you need to do is combine the Examples table you prepared earlier with\nthe Given-When-Then and add keywords like Feature and Scenario Outline.\nFeature: Selling items through individual merchants\nScenario Outline: Merchant commissions\nGiven a merchant called Quick-Ship\nAnd a purchase from <region>\nWhen Quick-Ship gets paid for the purchase\nThen we should take <commission> of the price\nExamples:\n| region\n| commission |\n| North America | 10%\n|\n| South America | 11.4%\n|\nListing 5.1\nOutside-in scenario outline derived from examples\n\n\n102\nCHAPTER 5\nChoosing examples for scenario outlines\n| Europe\n| 12.9%\n|\n| Asia\n| 12.9%\n|\n| Africa\n| 13.5%\n|\nAs you can see, with a little creativity, you’ve easily arrived at a complete scenario out-\nline. Choosing examples from which to derive outlines is a separate art, though, and\ncovering it appropriately will require a lot more space.\n Now that you know how to write outside-in scenario outlines, I can talk in detail\nabout collecting great examples. Section 5.3 talks about efficient methods for finding\ngood examples. Section 5.4, on the other hand, is about examples you should avoid. By\nthe end of this chapter, I’ll have talked about every important aspect of writing exem-\nplary scenario outlines, and you’ll be ready to use that knowledge in the real world. \n5.3\nFinding key examples for scenario outlines\nGood outside-in scenario outlines need good examples—that goes without saying.\nThis section will teach you the general rules for choosing good examples. Then it will\nzoom in to explain particular techniques of collecting and refining examples. These\ntechniques will help you\nIdentify important business cases\nMake sure you cover all the relevant examples\nSpot troublesome examples that break often\nSuch techniques are also called testing heuristics.\nDEFINITION\nTesting heuristic—A set of rules of thumb, educated guesses, intui-\ntive judgments, and common sense used by testers to generate new testing ideas\nTesters and developers often aim to prevent or find as many bugs as they can. It’s a\ngreat approach that increases test coverage and makes software more secure and eas-\nier to maintain. Thus, having more tests with more examples is, in general, considered\nto be “better.” The most common indicator that can force delivery teams to simplify\ntheir tests are brittle, overcomplicated tests that cause performance issues. Other than\nthat, the more the better.\n But this isn’t what Gherkin tests look like. As discussed in chapter 1, other indicators\nare in play, like readability and teaching principles. This section provides a simple frame-\nwork you can use to distinguish between exhaustive examples and illustrative examples.\n To understand the difference, imagine that examples in scenario outlines are like\nthe contacts on your phone. An exhaustive list of examples is like a list of all the con-\ntacts you have on your phone. That’s pretty much everyone you know and can think of\nalong with emergency phone numbers in case a tragedy happens. With exhaustive\nexamples, the goal is to test safely by detecting more defects with more tests.\nDEFINITION\nExhaustive testing—An approach in which test coverage is mea-\nsured based on how many checks and examples you have. The more exam-\nples, the better.\n",
      "page_number": 108
    },
    {
      "number": 5,
      "title": "Choosing examples for scenario outlines",
      "start_page": 124,
      "end_page": 149,
      "detection_method": "regex_chapter",
      "content": "103\nFinding key examples for scenario outlines\nIllustrative examples, on the other hand, contain one key example from each of your\nimportant social circles: family, friends, work, and so on. A list like that is much\nshorter.\nDEFINITION\nIllustrative testing—An approach in which you use only the most\nrepresentative examples and only as many as needed to understand the pur-\npose of a test\nAn illustrative example of a contact list would be a model simplified to represent the people\nyou hang out with. This simplified model would remove any phone contact that made\nthe list more difficult to understand.\nChoosing good illustrative examples is crucial to doing scenario outlines well. This\nsection expands on the guidelines outlined in the previous paragraphs by discussing\nconcrete candidates for illustrative examples. Reading it should help you come up\nwith a table for any scenario outline more quickly and easily.\n A specification should list only the key representative examples. This will help\nkeep the specification short and easy to understand. The key examples typically\ninclude the following:\nEach important aspect of business functionality—Business users, analysts, and/or\ncustomers typically define these.\nEach important technical edge case—For example, technical boundary conditions.\nDevelopers typically suggest such examples when they’re concerned about func-\ntional gaps or inconsistencies. Business users, analysts, and/or customers define\nthe correct expected behavior.\nEach particularly troublesome area of the expected implementation—For example, cases\nthat caused bugs in the past, and boundary conditions that may not be explicitly\nillustrated by previous examples. Testers typically suggest these, and business\nowners, analysts, and/or customers define the correct behavior.\nThis list of simple guidelines summarizes the most important points discussed in this\nchapter and will guide you when you begin collecting examples for your next require-\nment. The subsections that follow provide more information and insight about these\nareas. First, we’ll look at representative business examples. Then we’ll move on to\nexamples with boundary conditions, ending the section with examples that highlight\nhistorically buggy functionalities.\nExercise 2\nPrepare a list of the most representative examples that will illustrate what your online\nshop is selling to someone who didn’t read this chapter or chapter 4.\n\n\n104\nCHAPTER 5\nChoosing examples for scenario outlines\n5.3.1\nDomain-specific examples\nDomain-specific examples are inputs and outputs that are tied to your product’s busi-\nness domain extremely closely. In fact, you often need to be a domain expert—one\nwho’s extremely knowledgeable about the domain—to recognize and understand\nthese examples at a glance.\n Unfortunately, there are no quick and easy heuristics for spotting and managing\ndomain-specific examples, because each business domain is unique. But there’s some-\nthing else I want to show to you.\n An early reviewer of the book argued that a section about domain-specific exam-\nples seems a bit redundant, because unspecific examples are usually standardized and\neasy to understand. There’s little value in documenting features such as restoring a\npassword, changing basic settings, and so on—with some exceptions, such as generic\nexamples that cause regular bugs. I agree—but I also want to argue that even the sim-\nplest functionality can have impactful domain-specific examples that sometimes may\nlead to discovering new, unexpected features. It’s a fact that’s overlooked by many\ndevelopers, testers, designers, and managers.\n The most domain-specific attribute for any e-commerce application is usually the\nprice. Every e-commerce shop should experiment with its prices on a daily basis to sub-\ntly encourage customers to buy more. Many other factors can also influence the price\nof any item in the store: daily deals, coupons, fire sales, bundles, free shipping, and so\non. That’s a lot to convey in a single specification; but at this point in the chapter, you\nhave all the tools you need to make that happen, such as parameters and multiple\ntables. Let’s look at the result.\nFeature: Pricing\nScenario Outline: Discounts\nGiven items like <items> costing <price> in John's cart\nAnd a <discount> discount\nWhen John proceeds to checkout\nThen he should only pay <final> for the items in his cart\nExamples: Daily deals\nDaily deals are always 17% discounts.\n| items\n| price\n| discount | final\n|\n| \"Writing Great Specifications\" | $44.99 | 17%\n| $37.34 |\nExamples: Coupons\nThere are five different types of coupons available.\n| items\n| price\n| discount | final\n|\n| \"Writing Great Specifications\" | $44.99 | 5%\n| $42.74 |\n| \"Writing Great Specifications\" | $44.99 | 15%\n| $38.24 |\n| \"Writing Great Specifications\" | $44.99 | 30%\n| $31.49 |\n| \"Writing Great Specifications\" | $44.99 | 50%\n| $22.49 |\n| \"Writing Great Specifications\" | $44.99 | 75%\n| $11.24 |\nListing 5.2\n[GOOD] Specification full of domain-specific examples\n\n\n105\nFinding key examples for scenario outlines\nExamples: Bundles\nWe offer \"buy two, pay for one\" bundles.\n| items\n| price\n| discount | final\n|\n| \"Specification by Example\" bundle | $44.99 | 50%\n| $22.49 |\nThis is a good specification. The reader can easily see that there are three types of dis-\ncounts and identify the discounted prices. But you can also do something more\ndomain-specific here.\n Your superior shipping infrastructure lets you sell and ship items more cheaply\nthan your competitors. So, thanks to your margins, you can sometimes sacrifice short-\nterm profits from single transactions for increased long-term volume. For example,\nresearch shows that when given various price options, 57% of consumers choose\nround, whole-dollar amounts ending in zero. Because of the straightforward nature of\nelectronic payments, the most plausible explanation is that people prefer round\nprices. When a person buys a discounted book from your store for $23.23, the differ-\nence between that price and, say, $23.00 isn’t much. So maybe you should discount\nprices even further, to whole-dollar amounts, to encourage more customers to buy\nand thus increase sales. In a high-volume store like this one that processes thousands\nof transactions each day, 23 cents doesn’t make much of a difference. But if you could\npersuade an average client to buy two items instead of one during the same shopping\nsession, that would result in a massive increase in revenue.\nScenario Outline: Discounts\n57 percent of consumers pick round, whole-dollar amounts\nending in zero.\nGiven items like <items> costing <price> in John's cart\nAnd a <discount> discount\nWhen John proceeds to checkout\nThen the order should technically be discounted to <discounted>\nBut the final price should be discounted even further to <final>\nExamples:\n| items\n| price\n| discount | discounted | final\n|\n| \"Lord of the Rings\" | $44.99 | 17%\n| $37.34\n| $37.00 |\n| [...]\n| [...]\n| [...]\n| [...]\n| [...]\n|\nListing 5.3\n[GOOD] More complex discounting scenario\nUsing table briefs\nListing 5.5 is the first specification in the book to use table briefs. Table briefs are\nsimilar to specification briefs and scenario briefs, which you’ve been using through-\nout the book. They’re free-flowing text sections between the table and the Examples\nkeyword. You can use table briefs to expand on the context of the examples or pro-\nvide additional information.\n\n\n106\nCHAPTER 5\nChoosing examples for scenario outlines\nThis new discounting approach might be interpreted as overengineering, but my\npoint is that even the simplest features have indiscernible, domain-specific quirks that\ncan and should be covered by your executable specifications. You don’t even have to\ndig that deep.\n Another complex domain-specific example is a registration process in a custom\nemployee-satisfaction application built for a company with thousands of employees. In\naddition to standard information like username, password, and email, you’ll need to\ndeal with a lot of inputs specific to the company. For instance, you’ll have to add dif-\nferent departments, like Software Engineering and Sales; and branches, such as Los\nAngeles and New York. The onboarding flow for the app may look different for a soft-\nware engineer from Los Angeles than for a salesperson from New York: if each city has\na different satisfaction program, it will be pointless to ask New York employees\nwhether they’re interested in wellness programs that are only available in Los Angeles.\nTo create a great onboarding experience, you’ll end up with a complex registration\nform that needs to change and evolve for every employee. As an analyst, I like to look\nfor domain-specific examples in processes that most people would consider standard,\nand I advise you to do the same in order to create a user experience that feels unique\nand tailored to your business domain.\n If an example is highly domain specific, having it in an executable specification is\nof great help to the delivery team. The team can trust that the example is tested and\nup to date. They can even add more detail over time if they need to. And every time\nthey implement new functionality, automated tests will remind them not to break\nthese important examples. \n5.3.2\nCounterexamples\nBalancing examples with counterexamples is another way to fill the Examples table in\nscenario outlines. By a counterexample, I mean a different combination of inputs, yield-\ning another extreme outcome, in the same workflow. To see what I mean by extreme,\nlet’s talk briefly about a simple free-shipping example.\n Let’s say your online shopping application offers free shipping for orders that are\nmore expensive than the average customer’s average order. This is a popular e-com-\nmerce incentive to encourage customers to order more at a single time and simplify\npayment processing. You could illustrate the free-shipping behavior with this simple\nscenario.\nFeature: Free shipping\nScenario: Orders over $100 should be shipped for free\nGiven items worth $100 in John's cart\nWhen John proceeds to checkout\nThen he should be offered free shipping\nListing 5.4\n[GOOD] Simple free-shipping example\n\n\n107\nFinding key examples for scenario outlines\nIt’s a good starting point, but it’s simplistic. With a scenario like this one, you only\nknow that a $100 purchase is in the range eligible for free shipping. You know nothing\nabout less- or more-expensive purchases. You don’t even know whether this is the low-\nest price point eligible for free shipping. In theory, the free-shipping threshold will be\nmentioned in the name of the scenario. But relying on that would mean assuming\nthat all the people who need to see the scenario will read it from cover to cover. It’s a\nrisky assumption; most business people, programmers, designers, and testers will only\nscan text, because they’re busy, on deadline, and looking for quick answers.\n To improve this scenario, look for a visual way to highlight the contrast between\norders that qualify for free shipping and orders that don’t. A scenario outline can do\nexactly that.\nFeature: Free shipping\nScenario Outline: Orders over $100 should be shipped for free\nGiven items worth <purchase> in John's cart\nWhen John proceeds to checkout\nThen he should be offered <shipping>\nExamples:\n| purchase | shipping\n|\n| $99\n| $5 shipping\n|\n| $100\n| free shipping |\nYou could even throw in a third example showing a $101 purchase being offered free\nshipping. You’ll see why and when a similar example can be useful in section 5.4.4,\nwhere I talk about classes of equivalence and the Goldilocks principle.\nCounterexamples support the delivery team by drawing clearer boundaries between\ndifferent combinations of inputs and outcomes. They can be used to illustrate edge\ncases, show contrasting areas of implementation, and define blank-slate states and\nextreme conditions. Readers benefit from counterexamples the same way pedestrians\nbenefit from red and green lights: they know when they have a clear go and when they\nmust stop and look around. It’s a simple but effective heuristic. \n5.3.3\nExploratory outcomes\nBalancing examples with counterexamples isn’t the only heuristic you can use to your\nadvantage. I like to say that most engineers, analysts, designers, and testers are forced\nListing 5.5\n[BETTER] Example contrasted with a counterexample\nExercise 3\nWhen an item that’s on sale is featured as a daily deal, what will a table with an exam-\nple and a counterexample look like? Write a scenario outline with an answer. You can\nuse the discounts from listing 5.6.\n\n\n108\nCHAPTER 5\nChoosing examples for scenario outlines\nto be optimists due to the chaotic, uncertain nature of the software development pro-\ncess. If they truly care about a meaningful result, the journey requires at least some\ndegree of optimism.\n This optimism can blind you to less obvious or less probable examples and cause\nyou to focus on positive outcomes only. Chapter 2 mentioned that testers often call\nscenarios with positive outcomes happy paths and that scenario outlines can account\nfor a multitude of other paths including angry paths, scary paths, embarrassing paths,\nand forgetful paths. This chapter expands on the topic of these exploratory outcomes.\n In general, exploratory outcomes pursue possible unhappy paths, leading to new test-\ning ideas. They belong mainly to the analysis phase and can be used to stimulate\ngroup thinking and brainstorming during specification workshops or when a single\nperson is analyzing a requirement.\n I found the “go beyond the happy path” heuristic in the excellent book Fifty Quick\nIdeas to Improve Your Tests by Gojko Adžic´, David Evans, and Tom Roden (Neuri Con-\nsulting, 2015). On a daily basis, you can use the following subsections as a checklist to\ngenerate new testing ideas. These questions can guide your conversations with stake-\nholders as you mine them for possible input.\nTHE HAPPY PATH\nFind the main success scenario, usually describing the most straightforward example.\nWhat happens if everything goes all right? Should anyone be rewarded? What changes\nshould be made in the system? Should the successful result be logged anywhere?\nTHE ANGRY PATH\nLook for the main failure scenario: anything that will make the application throw\nerrors, quit, or break. Maybe the angry path is a counterexample for the happy path.\nOr perhaps it’s the most frustrating scenario imaginable, where only one thing\ngoes wrong, but it breaks the entire process. An example could be a server error that\nappears when the user is completing a form six screens long and can’t save their\nprogress. \nTHE SCARY PATH\nThink about the areas of highest risk. I usually try to imagine misunderstandings and\nerrors that could get me or the end user fired. One of my projects dealt with sending\na lot of paid text messages automatically. I was always scared that a bug would send\nthousands of messages at once that I would have to pay for. What failure scenarios and\ncode would I, as the developer of the project, devise to relieve myself of my fear?\nTHE EMBARRASSING PATH\nWrite down all the things that, if they broke, would cause huge embarrassment on all\nfronts. Imagine you’re the CEO, and you’re giving a demo in front of investors or\nimportant customers. You’re trying to create a new account, and you can’t. Or you’re\ntrying to order something, and the payment can’t be processed. “Maybe next time,”\nyou hear. Can you think of an example that would create a similar situation?\n\n\n109\nFinding key examples for scenario outlines\nTHE DELINQUENT PATH\nShould the functionality be secured in any special way? Who is authorized to use it?\nAre any special permissions needed? Does any third-party regulatory body require\nlegal compliance? If anyone saw the data produced by this functionality, would some-\none be in trouble?\nTHE STRESSFUL PATH\nIf scale, speed, and performance are important business aspects of the function or\ncomponent you have to work with, give your projections for future changes of busi-\nness volume. For example, a one-year business report could contain so much data that\nit might be impossible to download on the fly. Is there an example that would stretch\nyour system to its limits?\nNOTE\nScale, speed, and performance are nonfunctional requirements, and it\nisn’t obvious whether those are a good fit for Gherkin and SBE. We’ll get back\nto this issue in chapter 8. \nTHE GREEDY PATH\nSelect everything, tick every box, opt into every option, and order lots of everything.\nSometimes, following the greedy path results in examples that apply to power users—\nexcessive users who will try to use your application to the fullest. But other times, the\ngreedy path will remind you about behaviors of casual users, such as those who wait\nuntil the last day of the last deadline and suddenly want your application to do 60\nthings at once. Will it be ready? Or will it break?\nTHE FORGETFUL PATH\nFill up all the memory available in the system, and check what happens. Leave a shop-\nping cart full of items, but never finish the order. Be an admin user who forgets to\napprove new accounts. Nobody has a perfect memory. Can you find any forgetful\nexamples and deploy appropriate countermeasures?\nTHE DESOLATE PATH\nWhat does your functionality look like before the user uses it for the first time? What\nhappens when users don’t want to provide required input? What if they can’t? They\nmay not have the necessary information yet. On the desolate path, provide your fea-\nture with examples of nothingness. Give too little information. Don’t upload enough\nphotos. Write nothing. \nTHE INDECISIVE PATH\nI’m an indecisive user every time I have to publish anything. I check all the tabs in the\neditor, rewrite all the headlines multiple times, add and remove tags, and reposition\nimages. Are you sure your feature will work correctly with similar users?\nEXAMPLE EXPLORATORY OUTCOMES\nIf you were to apply the exploratory-outcomes method to your e-commerce shopping\napplication, you might use it to build a scenario outline for checking out. The check-\nout process is a good candidate because it involves many moving parts—payments,\n\n\n110\nCHAPTER 5\nChoosing examples for scenario outlines\ncart management, and shipping—and each of these parts can break at any moment,\nyielding a different outcome.\nFeature: Checkout\nScenario Outline: Processing purchases at checkout\nGiven <prerequisite>\nWhen checkout proceeds\nThen the contents of the cart should be <bought?>\nAnd the credit card should be <charged?> for it\nExamples: The happy path\n| prerequisite\n| bought? | charged? |\n| John adds an item to the cart | bought\n| charged\n|\nExamples: The angry path\n| prerequisite\n| bought?\n| charged?\n|\n| the item is in stock\n| bought\n| charged\n|\n| the item goes out of stock | not bought | not charged |\nExamples: The embarrassing path\n| prerequisite\n| bought?\n| charged?\n|\n| John can pay\n| bought\n| charged\n|\n| John can't pay | not bought | not charged |\nExamples: The delinquent path\n| prerequisite\n| bought?\n| charged?\n|\n| minors try to buy an R rated movie | not bought | not charged |\n| adults try to buy an R rated movie | bought\n| charged\n|\nTIP\nYou may have noticed that listing 5.6 features a <prerequisite> param-\neter that’s substituted for an entire Given step. This is possible because test\nrunners go through the parameters before execution and literally generate\nnew scenarios out of the scenario outlines—and only then are the scenarios\nexecuted. In this case, a test runner like Cucumber will generate as many\nGivens as there are examples in the table for the <prerequisite> parameter,\nmaking the outline possible.\nTo make things clear at a glance, each table has examples that describe only one busi-\nness rule. And, as discussed earlier, each table has both an example and a correspond-\ning counterexample to clearly show boundaries.\n You could also use techniques like outcome questioning and context questioning,\nwhich you learned about in chapter 3. That way, you could see whether any of the tables\ncould create more standalone examples, by asking, “Is there another outcome that also\nmatters?” or “Is there a context that, for the same event, produces a different outcome?”\nTIP\nExploring outcomes can help elicit better requirements, too. Asking for\nalternative examples can make whoever is asking for a feature think twice\nabout whether the proposed solution is the best one. And you don’t even\nhave to write any Gherkin to ask this question early in the process.\nListing 5.6\n[GOOD] Generating diverse exploratory outcomes\nMain success\nscenario\nExamples \nthat may \ncause errors\nEmbarrassing\nscenarios that\ncan’t happen if\nyou want to\nmake money\nExamples \nrequiring legal \ncompliance\n\n\n111\nFinding key examples for scenario outlines\nExploratory outcomes help the delivery team view the feature they’re working with\nfrom multiple angles. They can also help discover troublesome edge cases. But not all\noutcomes have to generate meaningful corresponding examples. It’s valuable to go\nthrough the list with most new features; such a checklist can come in handy in stress-\nful, time-sensitive situations. In The Checklist Manifesto (Metropolitan Books, 2009),\nAtul Gawande talks about the risks of routine and repetitive tasks in a complex envi-\nronment, where experts are up against the deficits of human memory and attention.\nUnder pressure, people tend to skip some steps. A checklist with possible testing\nideas, ingrained in your development process, can help you avoid that and can result\nin better coverage. \n5.3.4\nBoomerangs\nBoomerangs are functionalities that keep breaking every now and then, returning from\nproduction to development despite your team’s best efforts to fix the broken code for\ngood. They negatively affect budgets, deadlines, and morale, because the team wastes\ntime returning to the same functionality while other features have to wait. Boomer-\nangs are also important to identify and contain because they clearly highlight areas\nwhere you lack domain knowledge and where there are communication issues. It’s not\nas easy to prevent boomerangs as is it to identify them, but executable specifications\ncan help you decrease the risk of a boomerang appearing.\n Boomerangs can appear in the following situations:\nFunctionality deals with complex domain rules that are difficult for industry\noutsiders to understand.\nThe team didn’t identify a major stakeholder who had a say in the decision-\nmaking process.\nThe team underestimated such a stakeholder’s requests and didn’t satisfy the\nstakeholder.\nThe team allowed for a bus factor of one. A bus factor is the number of people\nwho need to get hit by a bus for the project or team to stop functioning. There-\nfore, a bus factor of one is the riskiest. If a feature that used to be fine becomes\na boomerang only after somebody’s departure, it means some knowledge disap-\npeared along with the person.\nCustomers aren’t satisfied with the solution, even though it was implemented\nexactly as it was designed.\nExecutable specifications with examples can help you reduce the likelihood of most of\nthese issues.\n Some boomerangs can be prevented before they happen. For instance, collecting\nexamples directly from end users and customers can increase the probability that your\nproduct will answer real customer needs. Examples can also help you understand\ncomplicated domain processes, as you saw in previous chapters—in chapter 3, for\nexample, which talked about outside-in development. Other boomerangs can’t be\n\n\n112\nCHAPTER 5\nChoosing examples for scenario outlines\nprevented before they happen—but executable specifications can still help you make\nsure they won’t reappear.\n Let’s focus again on the scenario outline for free shipping. I used it to explain the\nrule for using counterexamples in section 5.1.2.\nFeature: Free shipping\nScenario Outline: Orders over $100 should be shipped for free\nGiven items worth <purchase> in John's cart\nWhen John proceeds to checkout\nThen he should be offered <shipping>\nExamples:\n| purchase | shipping\n|\n| $99\n| $5 shipping\n|\n| $100\n| free shipping |\nAt the time you wrote it, this was a good outline: simple to grasp and self-explanatory,\nwith two contrasting examples. But as soon as the coding was finished and the func-\ntionality hit production, the delivery team learned that they forgot about a simple yet\ncrucial example.\n After the release, it turned out that free shipping is location-restricted to custom-\ners based in the United States. Business stakeholders said the company couldn’t afford\nto offer free shipping to other countries. You rework the scenario outline as follows, to\nreflect that decision.\nFeature: Free shipping\nScenario Outline: Orders over $100 should be shipped for free\nGiven items worth <purchase> in John's cart\nAnd shipment to <country>\nWhen John proceeds to checkout\nThen he should be offered <shipping>\nExamples: Restrict free shipping to the USA\n| country | purchase | shipping\n|\n| US\n| $99\n| $5 shipping\n|\n| US\n| $100\n| free shipping |\nExamples: Other countries don't have free shipping\n| country | purchase | shipping\n|\n| Canada\n| $99\n| $5 shipping\n|\n| Canada\n| $100\n| $5 shipping\n|\n| Poland\n| $99\n| $5 shipping\n|\n| Poland\n| $100\n| $5 shipping\n|\n| Egypt\n| $99\n| $5 shipping\n|\n| Egypt\n| $100\n| $5 shipping\n|\n| Japan\n| $99\n| $5 shipping\n|\n| Japan\n| $100\n| $5 shipping\n|\nListing 5.7\n[GOOD] Scenario outline for free shipping\nListing 5.8\n[BETTER] Reworked boomerang scenario outline\n\n\n113\nFinding key examples for scenario outlines\nSometimes, boomerangs return multiple times. The more often they return, the more\nprominence they deserve—more tests and more examples, which then become docu-\nmentation. Chapter 1 talked about how a specification suite can become a living docu-\nmentation system and a single source of truth. Being a single source of truth means that\nwhen stakeholders prepare to implement a new user story or repair a bug fix, they can\nuse the suite to read relevant scenarios and check important examples. Relying on long-\nterm, written knowledge instead of fallible human memory can help you spot inconsis-\ntencies and troublesome areas sooner and more easily. That’s why boomerangs, should\nthey appear, deserve a prominent place in your scenario outlines. We’ll return to the\ntopic of boomerangs as part of a living documentation system in chapter 7. \nAnalyzing boomerangs in depth\nSpotting, analyzing, and fixing boomerangs is extremely important when it comes to\neliciting better requirements. One technique you can use to understand the root\ncauses of misunderstood requirements is the Five Whys technique.\nFive Whys is an iterative interrogative technique used to explore the cause-and-effect\nrelationships underlying a particular problem. The primary goal of the technique is to\ndetermine the root cause of a defect or problem by repeating the question “Why?”\nEach answer suggests the next question.\nHere’s a classic example of using Five Whys to analyze a problem. The issue is that\na vehicle won’t start:\n1 Why? The battery is dead.\n2 Why? The alternator isn’t functioning.\n3 Why? The alternator belt has broken.\n4 Why? The alternator belt was well beyond its useful service life and not\nreplaced.\n5 Why? The vehicle was not maintained according to the recommended ser-\nvice schedule.\nAs you can see, this technique, even though it’s simple, can be used to deeply inves-\ntigate the problems that cause boomerangs.\nSome analysts use the Five Whys technique not only to prevent defects, but also to\nelicit new requirements by asking why a requested feature is needed. Asking why\nsomething is needed can sound like a challenge and may put the other person in a\ndefensive position, especially in larger organizations; instead, you can ask for a high-\nlevel example of how a feature would be useful, to start a discussion without chal-\nlenging authority.\nFive Whys was first developed by Toyota Motor Corporation. If you’re interested, you\ncan find more about it in most teaching resources about lean methodologies.\n\n\n114\nCHAPTER 5\nChoosing examples for scenario outlines\n5.4\nAvoiding scenario outline anti-patterns\nScenario outlines are like programs. They can help you automate. But one of the basic\nrules of technology is that automation, when applied to an efficient operation, will\nmagnify the efficiency—but automation applied to an inefficient operation will mag-\nnify the inefficiency. So scenario outlines can hurt you, too, if you aren’t careful. This\nsection discusses examples that you shouldn’t test with Gherkin; automating them\nwould only magnify the inefficiency of the entire specification suite.\n5.4.1\nTypical data validations\nInputs in your application need to be validated against model rules, database-consis-\ntency constraints, I/O rules, and other parameters that depend on the type of data\nprovided. These rules don’t belong to your domain only; they’re general data-valida-\ntion rules. Should you include examples like these in your specifications?\n For example, when dealing with numbers, should you write automated tests for\naccepting numerical formats such as 1,234,567, 1.234.567, 1234567, and 1 234\n567? Or, with strings, should you deal with entering accented characters, like ð? Or,\nwith dates, should you add examples of invalid dates, such as February 30 and Sep-\ntember 31?\n Executable specifications are only one part of the entire test suite a software appli-\ncation can have. The main role of scenarios is to provide a communication framework\nfor talking with stakeholders that lets you build a living documentation system. You\nshouldn’t try to use a specification suite to replace other kinds of tests—if you do, it\nwill quickly become cluttered. Executable specifications should only optimize for\nthree simple things: being clear, self-explanatory, and readable for both technical and\nnontechnical team members.\n Usually, data validations are too low-level to satisfy these three criteria. You can eas-\nily validate this statement by trying to get business stakeholders to read scenarios with\ntechnical examples. Decision makers don’t have time to read about strings or date val-\nidations. They want to read about their businesses. They want to make sure the scenar-\nios cover cases needed by their sales teams to satisfy contracts that they want to sign\nwith clients. \n5.4.2\nSimple combinatorial outcomes\nSometimes a functionality has to accept many different inputs that generate hundreds\nof outcomes. If you try to write a scenario to cover all the inputs and outputs, the\nExamples table will grow so large that it will be unreadable. Let’s think about what to\ndo in such a situation. Do you use all the examples and accept a scenario that’s hard to\nread, or do you keep the Examples table short and possibly leave an important edge\ncase without a test?\n \n \n\n\n115\nAvoiding scenario outline anti-patterns\n For example, suppose your website has a complex filtering system to help custom-\ners find new products more quickly. The shopping search engine has to deal with\nmany attributes, such as keywords, author, title, ISBN, publisher, subject, format, lan-\nguage, and publication date—and these are just for books. Your shop also sells video\ngames, groceries, gift cards, pet supplies, and so on, and each of these categories has\nits own filtering options.\n Imagine a scenario outline like this (I intentionally left the Examples table empty):\nFeature: Search\nScenario Outline: Filtering\nGiven books:\n| title\n| genre\n| author\n| release |\n| \"Sorrow\"\n| adventure | Damion Melville | 1994\n|\n| \"Setup\"\n| humor\n| Beyhan Topuz\n| 2000\n|\n| \"Recruits\" | adventure | Fionna Walker\n| 2005\n|\n| \"Aliens\"\n| sci-fi\n| Phan Uoc\n| 2013\n|\n| \"Invent\"\n| horror\n| Stela Vánová\n| 1988\n|\nWhen Simona searches for <filter>\nAnd she wants to find <value>\nThen she should see <results>\nExamples:\n| filter | value | results |\n| [...]\n| [...] | [...]\n|\nHow many different combinations could you test here? How many would be meaning-\nful? How many would you be including in the scenario just in case?\n In this example, the business domain is simple. But the temptation to write exam-\nples exhaustively instead of illustratively increases when even the simple outcomes for a\nproduct are complicated—for example, when the team is new to the domain. Self\ndoubt leads to scenarios with too many examples—examples that are too simple and\nboring for the business stakeholders and domain experts to read, but, at the same\ntime, are too confusing and difficult for the delivery team to maintain. In my experi-\nence, this is the number-one reason teams become discouraged with SBE. Instead, you\ncan reap the benefits of an approach called pairwise testing.\nDEFINITION\nPairwise testing—A testing heuristic based on the observation that\nmost faults are caused by a combination of at most two factors. Pairwise exam-\nples are shorter than exhaustive ones, but they can still be effective in finding\ndefects.\nPairwise testing is an effective heuristic that should let you pay attention to both\nreadability and preventing defects. Let’s fill the Examples table with pairs to see if\nthat’s true.\n\n\n116\nCHAPTER 5\nChoosing examples for scenario outlines\n \nFeature: Search\nScenario Outline: Filtering\nGiven books:\n| title\n| genre\n| author\n| release |\n| \"Sorrow\"\n| adventure | Damion Melville | 1994\n|\n| \"Setup\"\n| humor\n| Beyhan Topuz\n| 2000\n|\n| \"Recruits\" | adventure | Fionna Walker\n| 2005\n|\n| \"Aliens\"\n| sci-fi\n| Phan Uoc\n| 2013\n|\n| \"Invent\"\n| horror\n| Stela Vánová\n| 1988\n|\nWhen Simona searches for <filter>\nAnd she wants to find <value>\nThen she should see <results>\nExamples:\n| filter\n| value\n| results\n|\n| title\n| \"Lord of the Rings\"\n| no results\n|\n| title\n| \"Setup\" or \"Invent\"\n| \"Setup\", \"Invent\"\n|\n| genre\n| adventure\n| \"Sorrow\", \"Recruits\" |\n| author and release | Phan Uoc, 2013\n| \"Aliens\"\n|\n| author and release | Phan Uoc, 1994\n| no results\n|\nEach example tests a different combination of two factors:\nB Combines searching by a title and an empty set of results to test whether it’s possi-\nble to create a failing query\nC Combines two alternative titles to check whether advanced OR filtering works\nD Combines two books belonging to the same genre to test whether the genre filter\nwill return all possible results\nE Combines an existing author and a correct release year to make sure filtering by\ntwo distinct attributes is possible\nF Combines an existing author with an incorrect release year to check whether the\nadvanced logic behind the two-attribute filter yields correct results\nIf you think there may be more possible edge cases, you’re right. But remember that\nthe process of collecting examples and refining executable specifications is continu-\nous. It starts before anyone writes the first line of code, and it doesn’t end with\nproduction deployment. I guarantee that this table will change—growing or\nListing 5.9\n[GOOD] Using pairs of factors to generate outcomes\nB\nProvides a title.\nThe book\ndoesn’t exist.\nC\nProvides\ntwo titles.\nD\nProvides a genre. \nThe test should \nyield two results.\nE\nProvides a release \nyear and author.\nF\nProvides an author. The\nrelease year is false.\nExercise 4\nPrepare a list of pairwise examples for another search scenario in which Simona\nlooks for a new smartphone.\n\n\n117\nAvoiding scenario outline anti-patterns\nshrinking—throughout the product’s lifetime. You don’t have to get it all right on the\nfirst try; you only have to do enough to begin writing code. You can always improve the\nmodel later. \n5.4.3\nDatabase models\nA database model is a type of data model that determines the logical structure of a data-\nbase. It can be a representation of all the attributes you need to store in the database\nto allow your application to persist data. For example, when a new user signs up, you\nneed to store their username and password, but also their last sign-in date, number of\nsign-ins, and their IPs. Databases like Postgres and MySQL store data in tables, just as\nGherkin does, so some programmers and testers are tempted by their old habits to\nwrite Gherkin just like SQL.\n To see an example of such an approach, let’s look at a feature file for a standard\nreviewing functionality. Every time a customer buys something, they can rate the item\nafterward, which can help you promote popular, high-quality items on the website and\nremove bad items from the store. When an item gets bad reviews, you should ask\nwhether buyers want to tell you how you could improve their experience in the future.\nAnd if an item is rated well, you should try to persuade happy customers to recom-\nmend it to their friends.\n Here’s a scenario showing what happens when the author doesn’t care about mak-\ning the specification readable for nontechnical readers.\nFeature: Reviews\nBackground:\nGiven customers:\n| id | name\n| email\n|\n| 1\n| Dominic Advice | doad@exmaple.com |\nAnd items:\n| id | name\n| price\n| type |\n| 1\n| Writing Great Specifications | $44.99 | book |\nAnd publishers:\n| id | name\n|\n| 1\n| Manning Publications |\nAnd publications:\n| publisher_id | item_id |\n| 1\n| 1\n|\nAnd authors:\n| id | name\n|\n| 1\n| Kamil Nicieja |\nAnd book authored by:\n| author_id | item_id |\n| 1\n| 1\n|\nListing 5.10\n[BAD] Gherkin tables that look like SQL\nBecause both Postgres and MySQL \nare RDBMS databases, based on the \nrelational model of data, you need \nto explicitly define relationships \nbetween the book and its author, \nand between the book and its \npublisher, by linking item_id and \nauthor_id or publisher_id.\nPublishers and authors are in the specification only because \nthey’re required to save a book in the database; without them, \nthe book object wouldn’t pass necessary internal validations.\n\n\n118\nCHAPTER 5\nChoosing examples for scenario outlines\nScenario Outline: Reviewing sold items by customers\nGiven customer <user_id> bought item <item_id>\nWhen the customer gives the item <rating> stars\nThen we should <outcome>\nExamples:\n| item_id | user_id | rating | outcome\n|\n| 1\n| 1\n| 0\n| ask_how_can_we_improve |\n| 1\n| 1\n| 1\n| ask_how_can_we_improve |\n| 1\n| 1\n| 2\n| ask_how_can_we_improve |\n| 1\n| 1\n| 3\n| do_nothing\n|\n| 1\n| 1\n| 4\n| ask_for_recommendation |\n| 1\n| 1\n| 5\n| ask_for_recommendation |\nThere are two major problems with this specification:\nIt’s full of technicalities that aren’t in any way related to what is being\nspecified.\nInstead of specifying the business context, it’s mostly concerned with setting up\nthe database in a way that won’t break the test suite on execution.\nYou can see that many lines of the specification aren’t necessarily connected to the\ntopic of reviews. For example, are the price and type of a reviewed item required to\nunderstand how reviews work? They’re important if you want to talk about market-\ning—but not from an implementation perspective. All these lines are probably\nincluded because the author decided to reuse steps written for another scenario\nwhere prices, authors, and publishers were relevant. But that’s just lazy writing.\n Now, look at the Background section at the beginning of the specification. These\ntables are included only to create required relationships between database objects.\nBecause the author chose a book as the item that’s being reviewed, you’re forced to\nread about its publisher and author. You can only guess that without the publisher and\nthe author, the book object couldn’t be saved in the database, making the tests unable\nto proceed. Instead of solving the problem in the automation layer, the author\ndecided to write steps that would make it easy to manipulate the testing code directly\nfrom the specification layer.\n In general, technical stuff like managing database models should always be han-\ndled in the automation layer. Sometimes, though, delivery teams forget about the\nneed for a healthy balance between the specification layer and the automation layer—\nthey decide to handle database modeling in the specification layer to reduce redun-\ndancy and simplify step definitions.\n Here’s how to write the previous specification if you handle technicalities in the\nautomation layer.\n\n\n119\nAvoiding scenario outline anti-patterns\n \nFeature: Reviews\nScenario Outline: Reviewing items by customers\nGiven Dominic bought \"Writing Great Specifications\"\nWhen he rates it with <rating> stars\nThen we should <ask> for <feedback>\nExamples:\n| rating | ask\n| feedback\n|\n| 0\n| ask\n| tips to make it better |\n| 1\n| ask\n| tips to make it better |\n| 2\n| ask\n| tips to make it better |\n| 3\n| don't ask | no feedback\n|\n| 4\n| ask\n| a recommendation\n|\n| 5\n| ask\n| a recommendation\n|\nThe specification is much easier to read, you got rid of the artificial Background tables,\nand readers can easily see that the only thing being tested in this simple scenario out-\nline is the numerical scale of ratings that need to be implemented in the system.\nWARNING\nWriting outlines that look like SQL tables is an anti-pattern. As a\nrule, you should always solve technical difficulties in the automation layer,\ninstead of trying to solve them in the specification layer of your specifications.\nGherkin is, by definition, a business-readable, domain-specific language. There’s nothing\nbusiness-y, readable, or domain-specific about database rows. I think the confusion\ncomes from the fact that some people don’t treat Gherkin as a wrapper for automat-\ning conversations about requirements. Instead, they want to use it as a wrapper that\nmakes writing tests easier, without having to write new testing code all the time. This\nmay sound like a strong opinion, but I think this is a lazy, technology-oriented way to\nuse executable specifications that should be—at all costs—avoided. \n5.4.4\nClasses of equivalence\nClasses of equivalence are examples such as “X is less than Y,” as in the following step:\nGiven a user who is less than 18 years old\nWhen the user tries to buy a violent movie or game\nThen the purchase should be blocked\nA step like this can be used, for example, to make sure young users can’t purchase vio-\nlent movies or games. I don’t recommend using classes of equivalence, though,\nbecause they can create an illusion of shared understanding, which is the gravest mis-\ntake an executable specification can make. Every class of equivalence is, in fact, a set,\nand mental operations on sets don’t come naturally to most people. If you talk about\nsets expressed as domain-specific examples, the difficulty is twofold. When reading\nsuch a specification, your short-term memory has to maintain both the boundaries of\nListing 5.11\n[GOOD] Scenario outline without unnecessary technical detail\nClass of \nequivalence\n\n\n120\nCHAPTER 5\nChoosing examples for scenario outlines\nthe set and the new business domain concepts that the specification is trying to teach\nyou. In such circumstances, mistakes come easily.\n Examples that use classes of equivalence should be rewritten using a testing heuris-\ntic called the Goldilocks principle. This principle is derived from the children’s story\n“The Three Bears,” in which a little girl named Goldilocks finds a house inhabited by\nthree bears. Each bear has its own food and bed. After testing all three choices of both\nitems, Goldilocks determines that the first is to one extreme—too hot or too large.\nThe second is to the opposite extreme—too cold or too small. But the third, she\ndetermines, is “just right.”\nDEFINITION\nGoldilocks principle—A principle that requires at least three testing\nsamples whenever possible. The samples should include an average (or\nacceptable) example and two or more extreme examples (edge cases).\nThe Goldilocks principle is a good heuristic to convey classes of equivalence in sce-\nnario outlines. You can even use it if you don’t have three clear-cut boundary exam-\nples. For example, you could rewrite the previous snippet something like this:\nGiven a user who is <age> years old\nWhen the user tries to buy a violent movie or game\nThen the purchase should be <blocked>\nExamples:\n| age | blocked\n|\n| 17\n| blocked\n|\n| 18\n| not blocked |\n| 19\n| not blocked |\nThree examples illustrate the rule. The middle example in the table is the boundary\ncondition: the age of majority. The first example is there to illustrate that 18 isn’t the\nonly age that’s blocked from purchasing restricted content, so the reader can expect\nthat the same applies to ages below 17 as well. The last example shows what should\nhappen when you successfully cross the boundary condition specified in the middle\nexample.\nYou always need to be extremely careful when dealing with boundary conditions.\nWherever you find yourself trying to express an example as a class of equivalence,\nrewrite it using the Goldilocks principle with concrete examples of the boundaries. It\nmay seem like too much trouble at first, but it’s a good, safe habit that can spare you\nmany misunderstandings. \nExercise 5\nRewrite the following Given so that it will use a parameter, similar to the <age>\nparameter in the previous snippet, and a table with three Goldilocks examples:\nGiven a discount that is higher than 10% and lower than 12%\n\n\n121\nAnswers to exercises\n5.5\nAnswers to exercises\nEXERCISE 1\nRewrite the table of examples in Gherkin:\nExamples:\n| region\n| commission |\n| North America | 10%\n|\n| South America | 11.4%\n|\n| Europe\n| 12.9%\n|\n| Asia\n| 12.9%\n|\n| Africa\n| 13.5%\n|\nEXERCISE 2\nPrepare a list of the most representative examples that will illustrate what\nyour online shop is selling to someone who didn’t read this chapter or chapter 4:\nExamples:\n| item\n| category\n|\n| \"Sorrow\" by Damion Melville | paperback\n|\n| \"Setup\" by Beyhan Topuz\n| hardcover\n|\n| \"Recruits\" by Fionna Walker | e-book\n|\n| \"Aliens\" by Phan Uoc\n| audiobook\n|\n| \"Invent\" by Stela Vánová\n| audio CD\n|\n| Kindle Paperwhite 3\n| e-reader\n|\n| Apple iPad\n| tablet\n|\n| Beats Solo 2\n| headphones |\n| \"Inception\"\n| movie\n|\nEXERCISE 3\nWhen an item that’s on sale is featured as a daily deal, what will a table\nwith an example and a counterexample look like?\nExamples:\n| item\n| discount\n| price\n|\n| Kindle Paperwhite 3 | N/A\n| $119.99 |\n| Kindle Paperwhite 3 | Daily Deal | $99.59\n|\nEXERCISE 4\nPrepare a list of pairwise examples for another search scenario in which\nSimona looks for a new tablet:\nExamples:\n| filter\n| value\n| results\n|\n| manufacturer and line | \"Samsung\", \"S2\"\n| Galaxy Tab S2\n|\n| manufacturer and line | \"Samsung\", empty | Galaxy Tab S2, Tab E |\n| year and manufacturer | \"2013\", \"Apple\"\n| iPad Air\n|\nEXERCISE 5\nRewrite the Given so that it will use a parameter, similar to the <age>\nparameter in the previous snippet, and a table with three Goldilocks examples:\nGiven a <discount>\nExamples:\n| discount\n|\n| 10% discount |\n| 11% discount |\n| 12% discount |\n\n\n122\nCHAPTER 5\nChoosing examples for scenario outlines\n5.6\nSummary\nOutside-in scenario outlines are written directly from examples gathered\nduring an analysis phase rather than by merging similar scenarios.\nIllustrative examples are tests that only test the key inputs and outputs. They’re\ndifferent from exhaustive tests that test every possible combination of inputs\nand outputs to maximize test coverage.\nScenario outlines work well with representative examples illustrating each\nimportant aspect of business functionality.\nExamples should always be illustrated with counterexamples in order to show\nclear boundaries between business rules.\nThe Goldilocks principle states that in a given sample of tests, there may be\nentities belonging to extremes, but there will always be an entity belonging to\nthe average.\nBoomerangs are difficult areas of implementation, troubled with production\nbugs, and they also make good candidates to include in scenario outlines.\nExamples that prevent data-type attacks, such as testing input field validations,\nare usually too low level to be included in executable specifications.\nExamples created by combining all possible inputs often make executable spec-\nifications unreadable, brittle, and slow.\nYou should always solve technical difficulties in the automation layer, instead of\ntrying to solve them in the specification layer of your specifications.\n\n\n123\nThe life cycle of\nexecutable specifications\nIn its original meaning in systems theory, feedback is the exchange of data about how\none part of a system is working—with the understanding that one part affects all\nothers in the system—so that if any part heads off course, it can be changed for the\nbetter. In SBE, a specification suite is the system, every executable specification is a\npart of that system, and the delivery team is the recipient of the feedback.\n As anyone who works in a corporate environment knows, there are two kinds of\nfeedback:\nSupporting that lets people know they’re doing their job well\nCritiquing that’s meant to correct the current course of action\nThis chapter covers\nWorking with an executable specification \nthroughout its life cycle\nUnderstanding requirements’ precision level\nUsing examples in different development phases\nUnderstanding what happens after \nimplementation\n\n\n124\nCHAPTER 6\nThe life cycle of executable specifications\nThe same rules apply to the systems of feedback in SBE. Back in 2003, Brian Marick\nwrote a series of blog posts about the concept of an agile testing matrix.1 The series is\nalso one of the oldest articles about modern testing methods I know of that suggested\ndropping the name tests and replacing it with examples for business-facing testing.\n Marick organized his quadrant into distinct quadrants with two axes (see figure 6.1).\nThe vertical axis splits the matrix into business-facing tests, such as prototypes and\nexploratory testing, and technology-facing tests, such as unit tests and performance\ntests. Unit tests deal with low-level testing; they make sure small components of code\nrun well. Performance tests determine how a system performs in terms of responsive-\nness and stability under workload.\n Our area of interest lies in the upper half of the matrix, though: it’s split into tests\nthat support the team’s progress and tests that critique the product. Tests that support the team\nhelp the team write new code before they have a working product. Tests that critique\nthe product look at a finished product with the intent of discovering inadequacies. As\nyou can see, this is similar to the feedback system that powers any human organization.\n The question we’ll explore throughout this chapter is when examples should sup-\nport the team’s work and when they should critique the product. You’ll see how exam-\nples and automation can give delivery teams feedback of both kinds. And you’ll come\nto understand how feedback forces at the core of every executable specification suite\nwork much like a development manager: constantly evaluating the job done by\n1 See Brian Marick, “My Agile Testing Project,” on his blog, “Exploration Through Example,” August 21, 2003,\nhttp://mng.bz/TkO1.\nExamples\nFunctional tests\nStory tests\nPrototypes\nSimulations\nAcceptance tests\nExploratory testing\nScenarios\nUsability testing\nAlpha and beta versions\nUnit tests\nComponent tests\nPerformance tests\nSecurity tests\nCritique\nthe\nproduct\nSupport\nthe team\nBusiness facing\nTechnology facing\nFigure 6.1\nThe agile testing quadrants. I’ve highlighted the tests that will be important \nin this analysis.\n\n\n125\nprogrammers, analysts, designers, and testers; praising the team for their successes;\nand pointing out failures.\n To see how feedback loops in SBE help uncover contradictions and uncertainty that\ncan hide even in well-analyzed requirements, I’ll also talk about the life cycle of an exe-\ncutable specification. In product design, life cycle can be defined as the process of bring-\ning a new product or a new feature to market and then maintaining it over time.\n Chapter 1 said that all software development processes follow similar phases as a\nfunctionality progresses from conception to release, such as planning, building,\nreleasing, and getting feedback. These phases are also a called the software development\nlife cycle. I also said that, traditionally, specifications belong to the planning phase\nbecause that’s when delivery teams first interact with new requirements (as presented\nin figure 6.2).\nSBE is different because it doesn’t see specification as a singular phase but rather as a\nprocess that spreads across multiple phases as requirements evolve and change (see\nfigure 6.3). Specifications become tests; and tests, as you’ll see in chapter 7, become\ndocumentation.\n By evolving requirements, I mean that the precision level of your requirements\nchanges throughout the life cycle of an executable specification. Every requirement\nstarts as a vague goal with a high level of uncertainty. As you implement it, uncer-\ntainty decreases, because the requirement gradually becomes working code. As you’ll\nsee, SBE and Gherkin have a different feedback loop at each stage of the life cycle,\nwhich helps decrease uncertainty even further than in other software development\nprocesses.\n To understand this process thoroughly, we’ll track how a raw requirement becomes a\nGherkin specification—from a broad concept to a working implementation. This time\n1. Plan\nSoftware\ndevelopment\nlife cycle\n3. Launch\n4. Feedback\n2. Build\nTraditional specification\nFigure 6.2\nThe software development \nprocess. Traditional specification \nbelongs to the analysis phase.\n\n\n126\nCHAPTER 6\nThe life cycle of executable specifications\naround, you’ll specify a new feature in a simple mapping application called Mapper.\nMaps are by definition instruments of changing precision. You can use one to look at\ncontinents and countries from a high-level view, but you can also buy a local map of\nyour city and use it to find your home. A map is a great metaphor: just as there are\nlow-resolution and high-resolution maps, there are low-resolution requirements and\nhigh-resolution executable specifications.\n6.1\nEnd-to-end overview of the process\nIn this and the next section, we’ll look at a full overview of what life cycle and precision\nlevel mean. Every software feature goes through several development phases such as\nanalysis, design, implementation, testing, and maintenance. This is what a life cycle is.\nAs discussed in chapter 2, Gherkin specifications are also called features, and they go\nthrough similar phases.\n At its core, every executable specification is the result of a five-step process (see fig-\nure 6.4):\n1\nUnderstanding business goals\n2\nAnalyzing the scope of requirements through examples\n3\nDesigning the solution by deriving scenarios from acceptance criteria and\nexamples\n4\nRefining scenarios until you can implement the behaviors from the specification\n5\nIterating the specification over time\n1. Plan\nSoftware\ndevelopment\nlife cycle\n3. Launch\n4. Feedback\n2. Build\nSpecification by example\nFigure 6.3\nSBE in the software development process. Specification spreads throughout \nmultiple phases.\n\n\n127\nUnderstanding business goals\nAs you cross each threshold, the precision level of your analysis increases (see figure\n6.5). The more precise you are, the better you understand the implications of imple-\nmenting a requirement.\n Business goals are broad directives that sometimes don’t provide a specific solu-\ntion. Requirements are less abstract; they define what needs to be built for whom in\norder to achieve the high-level goal. Solutions are precise plans for features, interac-\ntion flows, and user interfaces. Because software is comprised of thousands of moving\nparts, no solution is fully precise until it’s implemented as working code. And only\nafter the code is released to production do you get the feedback needed to asses\nwhether a business goal has been met, which removes any remaining ambiguity. \n6.2\nUnderstanding business goals\nTo see how the precision level increases throughout the life cycle of an executable\nspecification, we need to start with the least specific phase: discussing business goals\n(see figure 6.6). For this example, assume on the Mapper project, your responsibility\nis to lead a team of developers, designers, and testers. Management is looking for a\nway to increase Mapper’s presence among small businesses and get smaller enterprises\nto pay to be featured on your online maps. Right now, your maps feature only a few of\nthe most popular outlets of international companies located at prominent locations,\nbut management would like to include more firms. Your team has been tasked with\nmaking that change happen.\nUnderstanding\nbusiness goals\nRefining\nscenarios\nAnalyzing\nrequirements\nwith examples\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.4\nThe life cycle of executable specifications\nNeed for\ndetail\nPriorities,\nsolutions, scope,\nestimates\nOpportunities,\nrisks, goals,\nobjectives\nDocumentation,\nregression tests,\ncustomer feedback\nDesign rules,\nacceptance tests\nAnalysis\nPlanning\nImplementation\nStage\nMaintenance\nFigure 6.5\nAs the need for \ndetail increases, so does the \nprecision of artifacts that \nappear during development.\n\n\n128\nCHAPTER 6\nThe life cycle of executable specifications\nTIP\nWhen you’re trying to elicit requirements, raising the discussion to the\nlevel of business goals lets you deal with scope and priorities more efficiently.\nAs you raise the discussion to the level of goals, the number of things you have\nto talk about decreases. That makes it easier to focus on the essentials.\nYou and management agree on actionable goals that the team should aim to meet in\nthe next six months; see table 6.1. You have to understand both the short-term and\nthe long-term contexts. If you knew only the short-term goal, you’d devise a tempo-\nrary solution. For example, your team could add new businesses to the platform man-\nually and still achieve the goal. Because the absolute number of businesses featured\non Mapper is low at the moment, doubling that number would take only a few min-\nutes of work.\nOnly when you also look at the long-term goal you can see that the company is look-\ning for a solution that will let it achieve sustainable growth in a new market segment.\nMeeting such a goal will require you to take different actions.\n \nTable 6.1\nHigh-level goals for the next six months\nPerspective\nGoal\nShort-term\n2x increase in businesses featured on Mapper’s platform\nLong-term\nEstablish presence in the unsaturated segment of small \nbusinesses in order to seek growth\nUnderstanding\nbusiness goals\nRefining\nscenarios\nAnalyzing\nrequirements\nwith examples\nAnalyzing\nlong-term\ngoals\nAnalyzing\nshort-term\ngoals\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.6\nTo understand why a feature request arises, you \nneed to understand the business goals it aims to achieve. \nUnderstanding business goals will let you define proper scope.\nOther resources for strategic planning\nImpact mapping is one of the best methods I know for creating medium-term strategic\nplans. An impact map is a visualization of scope and underlying assumptions, created\ncollaboratively by senior technical and business staff. It’s a mind map that’s grown\nduring a discussion that considers the following four aspects:\n",
      "page_number": 124
    },
    {
      "number": 6,
      "title": "The life cycle of executable specifications",
      "start_page": 150,
      "end_page": 175,
      "detection_method": "regex_chapter",
      "content": "129\nUnderstanding business goals\nGoal—Why are we doing this?\nActors—Who can produce the desired effect? Who can obstruct it? Who are\nthe consumers or users of our product? Who will be impacted by it?\nImpacts—How should our actors’ behavior change? How can they help us to\nachieve the goal? How can they obstruct us or prevent us from succeeding?\nDeliverables—What can we do, as an organization or a delivery team, to sup-\nport the required impacts?\nI like impact maps because they make assumptions hierarchical and testable. What\ndoes that mean? Let’s say you have an impact map with a goal to grow mobile adver-\ntising for a website.\nFirst, you define the success metrics for your goal. Then, you identify several actors\nwho can help reach you that goal, including super-fans with mobile devices. One pos-\nsible impact could be that they stay longer on your website and increase advertising\nexposure. You figure that features such as forums and chats, among others, might\nhelp achieve that impact.\nLet’s say that after implementing several deliverables, you realize that you were\nwrong in thinking that forums and chats would increase engagement. You may have\nseveral other, similar deliverables on your map, but now you know that this branch of\nthe map isn’t as impactful as you thought it would be—so you might discard that\nimpact or even discard that actor. If you did the latter, all the other deliverables for\nsuper-fans with mobile devices would be automatically discarded as well, because\nthe map is hierarchical. Thus you can treat the map as an easy-to-maintain, visual,\ntestable product backlog that keeps changing its shape as your knowledge about the\nworld grows.\nYou can read more about impact maps in Impact Mapping by Gojko Adžic´  (Provoking\nThoughts, 2012). \nExample of an impact map \nfrom www.impactmapping\n.org/drawing.html\n\n\n130\nCHAPTER 6\nThe life cycle of executable specifications\n6.3\nAnalyzing requirements with examples\nAs you may recall from chapter 1, an SBE process starts with deriving scope from goals.\nThe previous section provided you with a goal. Now you need the scope. There are\nseveral methods to derive scope (see figure 6.7). In recent years, user stories have\nrisen to become the most popular method for defining and discussing scope among\nagile teams; this section will guide you through the process of creating user stories,\nillustrated with examples.\n6.3.1\nConveying requirements as user stories\nA user story lets you convey a glimpse of a requirement as a product backlog item. The\nitem becomes a ticket for a future conversation. Through user stories, you can negotiate\nthe priority of any given requirement, discuss possible solutions and scope, and make\nsome estimates. They’re used for planning.\n The previous section talked about short- and long-term business goals. Even if you\nacknowledge both contexts that are important to your company, that’s only one side\nof the story. Customers don’t care about the goals of businesses; they want businesses\nto bring them value. Customer-oriented firms know that and use user-centered tools\nto align their strategies to their customers’ interests.\n That’s what user stories are for. Writing a user story lets you restate your business\nobjective as a customer benefit.\nIn order to let new customers discover my company\nAs an owner of a small business\nI want to add my company to Mapper's platform\nListing 6.1\n[OK] Your first user story\nRefining user\nstories with\nexamples\nUnderstanding\nbusiness goals\nRefining\nscenarios\nAnalyzing\nrequirements\nwith examples\nCollecting\nexamples\nConveying\nrequirements in\nuser stories\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.7\nTeams hold collaborative \nspecification workshops to find examples that \nillustrate requirements. The examples help the \nteam to refine the scope of their user stories.\n\n\n131\nAnalyzing requirements with examples\nTIP\nI talk more about user stories in chapter 8. You’ll learn alternative for-\nmats to express your stories so that you’ll be able to aim for understanding\nrather than strict conformance to any single format. Stay tuned! Right now,\nyou only have to focus on the three key elements that all user stories share—\nwho, what, and why.\nThanks to your knowledge about your market, you know that making Mapper a new\ndistribution channel will encourage small businesses to add themselves to the plat-\nform. They will essentially do the job for you, if you help them find new clients.\n User stories are crucial to increasing precision to the level an executable specifica-\ntion needs. But stories and scenarios are separate creatures, as shown in table 6.2.\nUser stories have acceptance criteria. Executable specifications have acceptance tests.\nWithout the criteria, there can be no tests. A delivery team derives new executable\nspecifications and new scenarios from user stories.\nAt this stage, you already suspect that your team will have to build some kind of a form\nthat will allow companies to sign up and mark themselves on your maps. You know that\nbecause analyzing business goals and writing the user story increased the precision\nlevel of the requirement to the point that you can begin to devise a specific solution.\n Placing the responsibility for a solution on the development team is a great way to\nobtain the right scope for a goal. The executive team may already have ideas about the\nsolution, derived from their intuitions and expertise; but they made you the product\nowner, so you’re the decision maker.\n When a requirement or a business objective contains implementation details, it\nusually means somebody’s trying to slip in a predetermined solution, binding it\nunnecessarily with the problem your organization is trying to solve. It could be a team\nmember, a manager, someone from marketing and sales, or even a bossy customer.\n Henry Ford famously said, “If I had asked people what they wanted, they would\nhave said faster horses.” Visionaries use this quote as a beaten-to-death excuse for\nignoring customer feedback. I think customers clearly told Ford what they wanted:\nthey told him that speed is the key requirement for transport. But because they\nweren’t engineers, they weren’t able to say that cars would satisfy the requirement.\n People will always use solutions to help themselves imagine consequences of any\ngiven requirement, because it’s a natural way of thinking. But as someone who works\nTable 6.2\nA comparison of user stories and executable specifications\nUser story\nExecutable specification\nDiscarded after implementation\nKept after implementation\nA unit of change\nAn effect of the change\nHas acceptance criteria\nIs an acceptance test\nProduces short-term results, such as cards or tasks\nProduces long-term, living documentation\n\n\n132\nCHAPTER 6\nThe life cycle of executable specifications\nwith technology, you should strive to extract unbiased, pure requirements from their\nsolutions. Only when you decide what will work best for the company should you\nmove on to writing down an executable specification.\nStoring user stories in a product backlog\nA user story is only a token for a future conversation. It’s a reminder that when the\nright time comes, you’ll have to discuss the such-and-such requirement with your\nstakeholders in order to implement it correctly.\nEven though user stories shouldn’t by any measure replace conversations, you can\nprepare notes in advance that will help you get up to speed after you pull a story out\nof the product backlog. (A backlog is a lot like a freezer: some stories don’t age well.)\nYou don’t want to be overly specific, of course. Specificity at this stage could con-\nstrain your flexibility in the future. You should never treat user stories as a to-do list.\nThey’re more like a list of guidelines: directions that you suspect you might explore\nin the future. But stories can stay in the freezer for months, so you may want to pro-\nvide some details to remind you of its purpose back when you put that particular story\nin the backlog.\nTo specify my stories, I use a four-element template based on a simplified story-\nelements template first shown to me during a workshop by David Evans, who is a vet-\neran of agile testing and an active member of the agile community. For each story, I\nwrite down the following:\nStakeholders and their interests—Along with the primary actor who has the\nmost interest in the story and is featured in the story, I sometimes list other\nstakeholders who could be affected by the story.\nA trigger—The event that causes the new behavior to be initiated or invoked\nby a user or by the system itself.\nThe main success scenario—Intentions and outcomes that should guarantee\nthe primary actor’s success (remember not to over-specify UI or implementa-\ntion details!).\nAcceptance criteria—Two to five one-line descriptions that sufficiently identify\neach testing condition for the story to be verified.\nI put these notes in the description of the story in the backlog.\nYou can see that each of the four notes will help me prepare Gherkin scenarios more\nquickly after I pull the user story from the backlog. I’ll already know the primary actor.\nFrom the trigger, I’ll have some idea about the Givens. The main success scenario\nwill help me imagine the Whens and Thens. And from the list of acceptance criteria,\nI’ll be able to estimate how many scenarios an executable specification for this user\nstory will have.\nSometimes notes don’t age well. Requirements can change over time. But notes can\nstill help you in such situations: you can always compare your past notes with your\ncurrent direction. The difference between the former and the latter will be the sum of\nthe learning your team has accomplished during the freezer time.\n\n\n133\nAnalyzing requirements with examples\n \n6.3.2\nCollecting examples\nYou now have a user story that you can put in your team’s backlog. You also have a\nrough sense of the amount of work you’ll face: you know what’s expected of you, and\nyou’ve shared the news with the engineers, who told you their first impressions and\ninitial ideas of what could be done to meet the requirements. What happens next?\n Chapter 1 taught you that after you derive scope from goals, you should start speci-\nfying collaboratively to illustrate requirements with examples. Specifying collaboratively\nmeans domain experts, product managers, developers, testers, and designers working\ntogether to explore and discover examples that will become Gherkin scenarios. Let’s\nassume that in the Mapper example scenario, you decide to organize a workshop.\nTIP\nIt’s your job to be a facilitator and to extract relevant information from\nwhatever is said. Starting by asking for rules is okay as long as you don’t expect\nthe rules to be a fully developed list of acceptance criteria. They’ll be messy\nand, probably, contradictory or inconsistent. As a technologist, you should\nconstantly challenge and refine the requirements your team takes on.\nDuring the workshop, your team comes up with examples of small businesses based in\nyour town that would be most likely to join Mapper’s platform (see table 6.3). You also\nadd a few ideas of how particular businesses may use Mapper to lead new customers\nthrough their conversion channels.\nTable 6.3\nExamples of relevant small businesses\nBusiness name\nBusiness type\nFeatures for lead generation\nDeep Lemon\nRestaurant\nShowing customers business hours\nThe Pace Gallery\nArt gallery\nAdvertising expositions\nFrench Quarter Inn\nHotel\nBooking rooms\nGreen Pencil\nBistro\nShowing customers business hours\nRadio Music Hall\nConcert hall\nAdvertising concert programs\nCity Cinema\nMovies\nShowcasing new films and ticket prices\nChristie’s\nPub\nShowing customers business hours\nThe template can also be useful when you gain new insights about the story, but it’s\nstill not the right time to implement that story—for example, when you gather new\ncustomer feedback, but have other priorities at the moment. Updating the template\ncan preserve your new insights for the future discussion. \n\n\n134\nCHAPTER 6\nThe life cycle of executable specifications\nWhat a diverse bunch of businesses! Having them sign up to Mapper would lead to a lot\nof healthy growth. The difficult part is that they would require different features in order\nto find the platform valuable, and some of those features would be as complex as inte-\ngrating with external booking systems and payment processors. But for now, Mapper’s\ncustomers will have to deal with the limited scope that we’ll implement in this chapter.\n At the analysis stage, delivery teams use examples to understand the business con-\ntext of their requirements—just as you did when you illustrated your business goals\nwith examples of use cases that might help you achieve those goals. Delivery teams can\nalso use examples to check whether the designers, programmers, and testers are in\nsync with the domain experts—again, just as you did during your specification work-\nshop. This is clearly the supporting role of examples that I talked about when I introduced\nthe agile testing matrix in figure 6.1. Is there a relationship between the two critical\ndiagrams in this chapter—the matrix from figure 6.1 and the life cycle diagram from\nfigure 6.5? As you can see in figure 6.8, you could easily rework the life cycle diagram\nto show the supporting role of examples in the early stages of development.\nThe supporting role of early examples means delivery teams can use them to support\nwriting new code when they work on new functionalities. In a way, the right examples\nprovoke the right code, guiding the development process.\n But as the requirements become more precise, the supporting role becomes less\nimportant than the critiquing role (see figure 6.9). By critiquing, I mean that examples\nbegin to challenge the requirement. For example, what if the examples collected by the\ndelivery team are wrong? Some surely will be.\n Examples at the critiquing stage usually have something they didn’t have earlier:\nan actual iteration of working software. When working software becomes available, it’s\nSupport role \nimportant at first,\ndiminishes later\nSupport\nCritique\nAnalysis\nPlanning\nImplementation\nStage\nMaintenance\nFigure 6.8\nBefore they’re automated, examples support delivery teams \nin understanding the scope of requirements—which is important at the \nbeginning of the life cycle.\n\n\n135\nAnalyzing requirements with examples\neasier to verify whether your initial analysis was right. Sometimes, the business expert\nwill forget things that real users will need. They may also be misguided or may cham-\npion a preferred solution due to a personal agenda. And sometimes, you can end up\noverengineering the solution and worrying about too many examples that aren’t use-\nful in the real world. \n6.3.3\nRefining user stories with examples\nLet’s assume that building a feature for so many kinds of businesses proved to be too\ndifficult for Mapper. Having a deadline to meet and limited resources you can use,\nyou decide to reduce the scope. To choose a customer segment that will allow you to\neasily expand to other businesses in the future, you must look for a carryover customer.\nDEFINITION\nCarryover customer—An example of a real customer who shares\nbehavioral traits with as many other customers as possible and becomes a\nmodel for an average consumer. If you design a product or a feature for the\nright carryover customer, other segments of the market should find it valu-\nable, too.\nDid you notice that all of the gastronomy businesses in table 6.3 share the same feature—\nshowing customers business hours—that would drive their conversion rates? Other busi-\nnesses, such as shops, pubs, and clubs, share this trait, too. After some discussion, the\nMapper team agree that restaurants and bistros make good carryover customers.\nIn order to let my customer know where and when they can come in\nAs an owner of a gastronomy business\nI want to add my company to Mapper's platform\nListing 6.2\n[BETTER] Refined user story\nWhen a functionality is implemented,\nacceptance tests start to critique the product.\nSupport\nCritique\nAnalysis\nPlanning\nImplementation\nStage\nMaintenance\nFigure 6.9\nAs requirements get more precise, examples are challenged \nby the working product.\n\n\n136\nCHAPTER 6\nThe life cycle of executable specifications\nYou believe that implementing this user story will fulfill the short-term business goal\nyou were tasked with. While you test the waters with gastronomy, the user stories for\nother businesses will wait patiently in the backlog for their turn.\nTIP\nFeatures can usually be split only based on technology. This is a limiting\napproach. For example, if you wanted to split a report-generating feature into\nsmaller portions, your first instinct would probably be to split it based on its\ntechnological ability to generate reports in different formats such as .pdf, .csv,\nand .xls. User stories and requirements, on the other hand, can be split by\nvalue. In your analysis of Mapper’s platform, you choose the most valuable\ncustomer segment and split a small capability that would bring this segment a\nlot of value without a lot of effort on your side.\nYou wouldn’t be able to make a confident decision without the validation provided by\nthe examples you collected. That’s their power.\n Collecting, analyzing, and refining examples creates a powerful feedback loop\nwithin any project that uses SBE. Examples helped you define the scope of the features\nand split user stories into smaller, more precise backlog items. Even though you’re yet\nto see an executable specification that your Mapper team could use, it should already\nbe clear why examples lie at Gherkin’s center.\nEliciting better requirements with Feature Injection\nThe process you’ve been using throughout the chapter to elicit requirements is sim-\nilar in design to feature injection: a technique that iteratively derives scope from goals\nthrough high-level examples.a In feature injection, teams first “hunt for value” by cre-\nating a model for delivering business value and listing underlying assumptions\ninstead of trying to describe the value with simple numbers such as revenue goals.\nYou created a simple model for value delivery when we discussed Mapper’s short-\nterm and long-term goals, why the goals are important, how they influence Mapper’s\nbusiness model, and which stakeholders demand that you achieve the metrics.\nOnce a model is defined, you do more than just evaluate whether to accept or reject\na suggested feature. You can proactively create a list of features that drive toward\ndelivery of business value based on your models. You did that when you wrote your\nfirst user story and refined it to better fit the value model.\nInjecting features provides a set of happy paths to create the outputs that will deliver\nthe business value. But doing so doesn’t provide all possible variations of input that\ncan occur and that may affect the outputs, or all cases that need to be considered\nfor successful delivery. You may recall happy paths from section 5.3.3, where I talked\nabout exploratory outcomes. Exploratory outcomes pursue possible unhappy paths,\nleading to new testing ideas. When new examples are generated, you can put them\ntogether in an executable specification—which is what you’re about to do for Mapper. \na Feature injection was created by Chris Matts and then expanded with Rohit Darji, Andy Pols,\nSanela Hodzic, and David Anderson over the years 2003–2011. For more information, see\n“Feature Injection: Three Steps to Success” by Chris Matts and Gojko Adžic´, InfoQ, Decem-\nber 14, 2011, http://mng.bz/E5fS.\n\n\n137\nDeriving scenarios from examples\n6.4\nDeriving scenarios from examples\nIn this section, you’ll step over another precision threshold as the user story you chose\n(listing 6.2) finally transforms into a draft of an executable specification. To do so,\nyou’ll finally write your scenarios (see figure 6.10).\nTIP\nA story becomes an executable specification when you’re sure it’s worth\ninvesting time and effort in it.\nFrom the examples you collected, you derive a list of acceptance criteria for the user\nstory:\nEvery new business should provide a name and a location to display on the\nmap.\nEvery business should provide business hours for each day of the week.\nLet’s take the relevant examples of pubs, restaurants, and bistros from the previous\nsection to write the first draft of an executable specification.\nFeature: New businesses\nScenario Outline: Businesses should provide required data\nGiven a restaurant <business> on <location>\nWhen <business> signs up to Mapper\nThen it should be added to the platform\nAnd its name should appear on the map at <location>\nExamples:\n| business\n| location\n|\n| Deep Lemon\n| 6750 South Street, Reno\n|\n| Matt's\n| 9593 Riverside Drive, St. Louis |\n| Back to Black | 8114 2nd Street, Stockton\n|\n| Green Pencil\n| 8583 Williams Street, Glendale\n|\n| Le Chef\n| 3318 Summit Avenue, Tampa\n|\n| Paris\n| 2105 Briarwood Court, Fresno\n|\n| Christie's\n| 714 Beechwood Drive, Boston\n|\n| The Monument\n| 77 Chapel Street, Pittsburgh\n|\n| Anchor\n| 110 Cambridge Road, Chicago\n|\nListing 6.3\n[OK] First draft of an executable specification\nWriting\nscenarios\nUnderstanding\nbusiness goals\nRefining\nscenarios\nAnalyzing\nrequirements\nwith examples\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.10\nExamples serve as a basis for all scenarios to come. Over time, the team should \noptimize scenarios for readability and remove confusing, redundant examples.\n\n\n138\nCHAPTER 6\nThe life cycle of executable specifications\nStraightforward, isn’t it? You take the first acceptance criterion from your list, rework\nit to fit the Given-When-Then template, and use a scenario outline to include all the\nrelevant examples you collected during the previous phase of your analysis.\n The increased precision level allows your team to spot a possible edge case: what if\na restaurant has two establishments in two different locations in the same city? There\nmight be one Deep Lemon in Reno at 6750 South Street and a second one at 289 Lau-\nrel Drive, for example.\n Should you allow that in your application? And if the answer is yes, should you\nmake that process easier? In the end, you decide there’s nothing wrong with accept-\ning multiple locations, but you don’t have time to optimize the process. Users will\nhave to make do with what they have. To finalize the decision, you add another exam-\nple to the outline.\nFeature: New businesses\nScenario Outline: Businesses should provide required data\nGiven a restaurant <business> on <location>\nWhen <business> signs up to Mapper\nThen it should be added to the platform\nAnd its name should appear on the map at <location>\nExamples:\n| business\n| location\n|\n| Deep Lemon\n| 6750 Street South, Reno\n|\n| Deep Lemon\n| 289 Laurel Drive, Reno\n|\n| Matt's\n| 9593 Riverside Drive, St. Louis |\n| Back to Black | 8114 2nd Street, Stockton\n|\n| Green Pencil\n| 8583 Williams Street, Glendale\n|\n| Le Chef\n| 3318 Summit Avenue, Tampa\n|\n| Paris\n| 2105 Briarwood Court, Fresno\n|\n| Christie's\n| 714 Beechwood Drive, Boston\n|\n| The Monument\n| 77 Chapel Street, Pittsburgh\n|\n| Anchor\n| 110 Cambridge Road, Chicago\n|\nThis is a fine example of a typical SBE tendency: tests guiding implementation. Only\nwhen you get to the precision level of test cases can you see that you overlooked an\nimportant element of the design. That’s because tests and requirements are essentially\nconnected. In 1968, Alan Perlis wrote that “a simulation which matches the require-\nments contains the control which organizes the design of the system.”2 A test pre-\ndefines “ideal” outputs and inputs up front; the application code must then be\ndesigned so that the real inputs and outputs match the ideal ones defined by the test.\nOtherwise, the test will fail.\nListing 6.4\n[BETTER] Second draft of the executable specification\n2 Software Engineering: Report on a conference sponsored by the NATO SCIENCE COMMITTEE, Garmisch, Germany, 7th to\n11th October 1968, eds. Peter Naur and Brian Randell (Scientific Affairs Division, NATO, 1969),\nhttp://mng.bz/jn3d.\nFirst location \nof a business\nSecond \nlocation of \nthe same \nbusiness\n\n\n139\nRefining scenarios\nTIP\nHere’s a rule of thumb: good code designs usually don’t need complex\ntests. If your tests are too complicated, you may be missing an important\ndomain concept or tackling a known concept the wrong way.\nFor the second time in this chapter, the feedback mechanisms of the SBE process have\nled you to discover something you missed in your initial analysis. You should expect to\nmake such discoveries multiple times during any feature’s development. You’ll proba-\nbly go back and forth multiple times during development or even after implementa-\ntion (as represented in figure 6.11). SBE practitioners should adopt the mindset that\nthere’s no such thing as a single moment when a feature is finished—features only get\nreleased. These are two different things.\n You can begin analyzing requirements either by looking for examples, as you did\nin Mapper’s case, or by perfecting a list of acceptance criteria. Either way, feedback\nlets you spot inconsistencies more quickly and easily. You shouldn’t expect to get\neverything right the first time; that’s typical. \n6.5\nRefining scenarios\nWith a scenario now in place, your team can implement it. Implementing the behav-\niors described by a scenario is the stage with the highest possible precision before a\nfeature is released to customers who validate its business value in the real world. This\nsection will show you what happens when a raw scenario first meets working code, and\nhow that meeting increases precision to a release-ready level.\n In chapters 1 and 2, you saw that after you write the first draft of a new executable\nspecification, you often need to refine scenarios and choose key examples to improve the\nreadability of your executable specification (see figure 6.12). That happens when\nteams refine their specifications to merge similar examples, reject the ones that intro-\nduce noise, and choose the most meaningful or descriptive ones.\nAcceptance \ncriteria\nGenerate\nChallenge\nExamples\nFigure 6.11\nCollecting, \nanalyzing, and refining examples \nis a continuous, never-ending \nprocess that exists within a \npowerful feedback loop.\nChoosing key\nexamples\nUnderstanding\nbusiness goals\nRefining\nscenarios\nRefining\nexamples for\nreadability\nAnalyzing\nrequirements\nwith examples\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.12\nTeams refine their specifications by \nextracting key examples and turning scenarios \ninto clear, unambiguous, organized documents.\n\n\n140\nCHAPTER 6\nThe life cycle of executable specifications\nReturning to Mapper, after your team begins to implement the behaviors from the\nscenario, they notice that the examples used in the previous section don’t test any\nedge cases other than a business with two locations. The examples don’t specify what\nhappens when any attribute of a business is missing. All the examples in the outline\nend with the business successfully joining Mapper’s platform. Why aren’t there any\ncounterexamples?\n Let’s think for a moment and look for a few counterexamples that would go astray\nfrom the happy path:\nThe applicant might forget to fill out the input field with the business name on\nthe registration form.\nThe applicant might forget to mark the location on the map.\nThe applicant might make both of the previous mistakes.\nThe applicant might provide a location, but it might be inaccurate; for exam-\nple, the user might mark the middle of a river as a location for their business.\nHaving defined new examples, you should now do two things. First, you need to\nremove redundant examples that don’t bring any value to the specification. Second,\nadd new examples and counterexamples that express the failure scenarios. You can\nalso split the examples into multiple tables to improve readability.\nFeature: New businesses\nScenario Outline: Businesses should provide required data\nGiven a restaurant <business> on <location>\nWhen <business> signs up to Mapper\nThen it <should?> be added to the platform\nAnd its name <should?> appear on the map at <location>\nExamples: Business name and location should be required\n| business\n| location | should?\n|\n| UNNAMED BUSINESS | NOWHERE\n| shouldn't |\nExamples: Allow only businesses with correct names\n| business\n| location\n| should?\n|\n| Back to Black\n| 8114 2nd Street, Stockton | should\n|\n| UNNAMED BUSINESS | 8114 2nd Street, Stockton | shouldn't |\nExamples: Allow businesses with two or more establishments\n| business\n| location\n| should? |\n| Deep Lemon | 6750 Street South, Reno | should\n|\n| Deep Lemon | 289 Laurel Drive, Reno\n| should\n|\nExamples: Allow only suitable locations\n| business | location\n| should?\n|\n| Anchor\n| 110 Cambridge Road, Chicago | should\n|\n| Anchor\n| Chicago River, Chicago\n| shouldn't |\n| Anchor\n| NOWHERE\n| shouldn't |\nListing 6.5\n[BEST] Executable specification with refined key examples\nFailure scenario \nwith no name \nor location\nFailure\nscenario\nwith no\nname\nFailure scenario \nwith an \ninaccurate \nlocation\nFailure\nscenario\nwith no\nlocation\n\n\n141\nIterating specifications over time\nTIP\nYou may have noticed that in listing 6.5, UNNAMED BUSINESS and NOWHERE\nare uppercase. To be honest, this isn’t a Gherkin convention; but the capital\nletters make these examples stand out, which improves readability.\nThe reworked outline is much easier to read and has more-comprehensive scenarios.\nYou need only to glance at it to recognize what it tests and why. It clearly distinguishes\nbetween success examples and failure examples. To my eye, the precision level of this\nscenario looks like it’s release ready. Congratulations!\n6.6\nIterating specifications over time\nYou don’t stop working on an executable specification after you write it (see figure 6.13).\nIt’s a continuous process. The team should validate the specification suite frequently to\nspot any integration errors as soon as possible, keeping the suite consistent at all times.\nThis section will show you how.\nWhen the specifications are consistent and up to date, they evolve into a living docu-\nmentation system that acts as a single source of truth about the system’s behaviors.\nEverybody on the team can use the system freely to solve their disagreements. We’ll\nenlarge on that, too.\n6.6.1\nValidating the specification suite\nIn the heat of the battle, while revising your scenario outline, you almost forgot that\nthe user story you wrote at the beginning of this chapter specified two acceptance\ncriteria:\nEvery new business should provide a name and a location to display on the\nmap.\nEvery business should provide specific business hours for each day of the week.\nSo far, you’ve only taken care of the first criterion. Let’s use what you’ve learned to\nwrite the second scenario.\nUnderstanding\nbusiness goals\nRefining\nscenarios\nEvolving the\ndocumentation\nsystem\nValidating the\nspecification\nsuite\nAnalyzing\nrequirements\nwith examples\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.13\nThe process of iterating specifications over time \nmeans validating frequently, keeping the specification suite \nconsistent over time, and evolving a living documentation system.\n\n\n142\nCHAPTER 6\nThe life cycle of executable specifications\n \nFeature: New businesses\nScenario Outline: Businesses should provide required data\n[...]\nScenario Outline: Businesses should be able to set their hours\nGiven a restaurant <business> on <location>\nWhen it schedules its hours to be <times> every day\nThen the hours should appear on the map at <location>\nExamples: Restaurants\n| business\n| location\n| times\n|\n| Deep Lemon | 6750 Street South, Reno\n| 7 AM-8 PM |\nExamples: Bistros\n| business\n| location\n| times\n|\n| Le Chef\n| 3318 Summit Avenue, Tampa | 9 AM-9 PM |\nExamples: Pubs\n| business\n| location\n| times\n|\n| Anchor\n| 77 Chapel Road, Chicago\n| 3 PM-3 AM |\nAfter you agree on the shape of the scenario, the team proceeds to automate it. They\nwrite new application code and generate the step definitions required to test the\ncode. Having done that, they run the test-execution engine to make sure the modified\nsystem works as they expect it to.\n And that’s when they find out that implementing the behavior from the new sce-\nnario breaks another scenario in the specification suite.\nFeature: Show sightseeing objects on the map\nScenario: Tourists should be able to see sightseeing objects\nGiven a sightseeing object:\n| name\n| location\n|\n| Memorial Monument | Oak Street |\nWhen Janet, who is a tourist, looks at Oak Street\nThen she should see Memorial Monument on the map\nIt turns out that the new attributes of business hours don’t work well with other types\nof entities that Mapper features on its maps, such as sightseeing objects. Not all sight-\nseeing objects—such as monuments—have opening and closing times.\n Your team forgot about that, and the validations they added prevented sightseeing\nobjects from being created in the database. To fix that, you decide to make the valida-\ntions optional instead of required. As soon as you do, the system starts working again,\nand the feature is ready to be deployed to production.\n Before we move on, let’s dissect what happened. The specification suite has to be con-\nsistent. When the team implements the behaviors from a new executable specification,\nListing 6.6\nAdding another scenario to the specification\nListing 6.7\nBroken scenario\n\n\n143\nIterating specifications over time\nthey should execute the existing specifications in order to check whether they still\nwork. The team must test the existing specifications every time changes are introduced\nto the system.\n If a scenarios breaks after you introduce a new feature, you can take only two\nactions:\nUpdate the broken scenario so it complies with the changes.\nChange the new feature so it won’t break the scenario.\nAs you can see, whereas new scenarios influence old scenarios, the old ones can also affect\nnew features (see figure 6.14). It’s another feedback loop within the process of SBE.\nI’ve already talked about it in chapter 1, which listed validating frequently as one of SBE’s\nkey practices.\nWhen you validate frequently, you once again operate in the product-critique quad-\nrant of the testing matrix. As soon as you automate the critiques, the test-execution\nengine will check the application regularly against new examples, protecting the qual-\nity of your product (see figure 6.15). Modern development practices take advantage of\nthat in various ways. For example, teams that employ continuous integration (CI)\npractices will integrate as often as possible, leading to multiple integrations per day.\nEach integration will then be verified by an automated build that can detect errors\nalmost instantly. Some teams trust their specification suites so much that they let every\nchange be automatically deployed to production if the tests pass—a practice known as\ncontinuous deployment.\nThe specification\nsuite\nThe new changes the old.\nThe old influences the new.\nThe new feature\nFigure 6.14\nThe feedback loop \nbetween new features and the \nexisting specification suite\nContinuous \nintegration\nSupport\nCritique\nAnalysis\nPlanning\nImplementation\nStage\nMaintenance\nFigure 6.15\nAfter release, examples become automated tests that \ncritique the finished product, if they’re validated frequently.\n\n\n144\nCHAPTER 6\nThe life cycle of executable specifications\nMost often, integration tests are followed by user acceptance testing (UAT). A popular\nargument for performing UAT manually is that getting your hands on the product\nactivates a different type of perception and judgment than thinking about automa-\ntion. Manipulation is different than cogitation. For example, when you test-drive a car,\nyou notice things you wouldn’t spot when poring over its specs, like the seats being\ntoo stiff or the leather not looking right.\nDEFINITION\nUser acceptance testing (UAT)—The last phase of the software-test-\ning process. During UAT, actual end users test the product to make sure it can\nhandle the tasks required by the specifications.\nBut when business stakeholders trust in their executable specifications, they can\nreplace simple, manual, boring checks with automated tests from the specification\nsuite, streamlining the UAT process. (I’m not saying they should remove manual tests\naltogether; they can just have fewer trivial ones.) Such trust is an ultimate sign that\nyou’re doing SBE well and that the stakeholders understand why examples and scenar-\nios are important. \n6.6.2\nEvolving the documentation system\nAfter you deploy the feature to production, it starts living a life of its own. A bug may\noccur from time to time; you fix it, write a regression test, and move on. As with any\nother feature, when development ends, maintenance begins. This section covers what\nhappens with an executable specification at the end of its life cycle, when it reaches\nthe highest precision level.\n The Mapper features turn out to be a success. Gastronomy businesses sign up like\ncrazy. You hope that implementing the user stories about other types of businesses will\nhappen in the future. For now, management is happy. You’re proud of your team, too.\nThe code is good; the specification looks fine.\n At least, you think so, until your team comes back to the specification two months\nlater. That’s when Martha, a fresh hire on your team, takes on a new user story con-\nnected to small businesses. To implement it, she needs to understand the feature bet-\nter, so she reads the specification the team created a few months ago. She still has\nsome questions, though, so she talks to you:\n“Hey,” she says. “What are popular hours?”\n“No idea. Why?”\n“Here’s a user story you created two months ago, before I joined the team. It only mentions\nthat you might also want to consider letting gastronomy businesses specify popular\nhours.”\n“OK … that does ring a bell. But I’m not sure …”\n“If it helps, I read the specification, and it already has a scenario that allows businesses\nto schedule some kind of hours. Maybe somebody already implemented that user story but\nforgot to mark it as done.”\n\n\n145\nIterating specifications over time\n“Let’s ask Gus. I think he was the last one to work with this feature. Hey, Gus, have you\nalready implemented something called popular hours?”\n“Didn’t we do that two months ago? Or wait, maybe it was business hours, not popular\nhours. Let me check the code …”\nYou get the gist.\n Two months ago, you made a frequent development mistake: mid battle, you\nthought the specifications you wrote were perfectly clear, because you still had all\nthe domain concepts in your short-term memory. After the dust settled, you realized\nthat your feeling of clarity was illusionary. Martha bravely brought a fresh perspec-\ntive that helped you realize that issue. You cringe at the thought of how many other\ndecisions were made without clear distinctions between domain concepts like the\none she noticed.\n You decide to rewrite the scenario in question and include some clarifying definitions.\nFeature: New businesses\nScenario Outline: Businesses should provide required data\n[...]\nScenario Outline: Businesses should be able to set relevant hours\nBUSINESS HOURS define when a business opens and closes.\nBusinesses provide POPULAR HOURS to help their customers\ndecide when it's the best time to come in.\nGiven a restaurant <business> on <location>\nWhen it schedules <hours> to be <times>\nThen the <hours> should appear on the map at <location>\nExamples: Restaurants\n| business\n| location\n  | hours\n| times\n|\n| Deep Lemon | 6750 Street South, Reno   | business hours     | 7 AM-8 PM |\n| Deep Lemon | 6750 Street South, Reno  | popular hours\n| 3 PM-5 PM |\nExamples: Bistros\n| business   | location\n| hours\n| times\n|\n| Le Chef   | 3318 Summit Avenue, Tampa | business hours     | 9 AM-9 PM |\n| Le Chef   | 3318 Summit Avenue, Tampa | popular hours\n| 8 PM-9 PM |\nExamples: Pubs\n| business   | location\n  \n| hours\n| times\n|\n| Anchor\n  | 77 Chapel Road, Chicago  | business hours     | 3 PM-3 AM |\n| Anchor\n  | 77 Chapel Road, Chicago  | popular hours\n| 9 PM-2 AM |\nBuilding and evolving a documentation system is the last step in the life cycle of any exe-\ncutable specification. Your work on a specification is rarely finished after you deploy\nListing 6.8\n[BETTER] Executable specification with clarifications\nAdded\ndefinition\nfor business\nhours\nSeparate \ndefinition for \npopular hours \nthat explains \nthe difference\nExamples\nof\nbusiness\nhours\nExamples of popular hours\n\n\n146\nCHAPTER 6\nThe life cycle of executable specifications\nthe new feature to production. You’ll likely come back to rewrite the steps, or change\nthe structure of the scenarios, or, as in the case we just discussed, add clarifications to\nthe specification layer. Chapter 7 goes into depth on these topics.\nAs the application changes and you discover new requirements, you may realize that\nsome of the scenarios you thought were distinct are parts of a bigger whole and\nshould be combined in a single specification. Sometimes the scenarios you thought\nwere connected will branch out into their own requirements. As the business evolves,\nyour specification suite should evolve with it. Changes in a specification suite often\ndirectly reflect the changes in a delivery team’s understanding of the business\ndomain. It’s a fascinating subject that we’ll explore deeply in chapters 8–11.\n Before we finish this chapter, figure 6.16 takes another look at the full life cycle of\nany executable specification. The next chapter focuses on the last box in this life\ncycle. As you may remember from chapter 1, fully fledged executable specifications\nare also called living documentation. Living documentation is always up to date because\nit changes alongside the system, thanks to the link between the documentation and\nautomated tests. When an executable specification evolves into living documentation,\nits active life cycle ends. That doesn’t mean the specification won’t change anymore, of\ncourse, but it’ll be more passive from now on. Usually, it’ll be changed and influenced\nby new specifications that enter the specification suite as the product matures. In\nchapter 7, which talks about the details of building a living documentation system, I\ndiscuss techniques that help you manage and maintain specifications in the passive\nstage of their life cycle (see figure 6.16).\nGall’s Law\nWhy do I keep talking about gradual evolution of requirements and domain concepts\ninstead of trying to find the perfect system design from scratch? Gall’s Law is the\nreason.\nGall’s Law is a rule of thumb for systems design that comes from John Gall’s book\nSystemantics: How Systems Really Work and How They Fail (General Systemantics\nPress, 2002):\nA complex system that works is invariably found to have evolved from\na simple system that worked. A complex system designed from\nscratch never works and can’t be patched up to make it work. You\nhave to start over with a working simple system.\n—Gall’s law\nI’m a strong believer in the power of this law. That’s why I keep repeating that you\nshould look for simple things that work, in terms of both the requirements and the\nimplementation, and then build on them. Moreover, SBE’s feedback loops will help\nyou spot systems that work, and thus never break, and systems that don’t work, and\nthus break constantly.\n\n\n147\nSummary\n6.7\nSummary\nAn executable specification evolves throughout a project’s life cycle.\nAs the project progresses, executable specifications become more precise. The\nlater the life cycle’s phase, the greater the need for detail.\nExploring examples is a process of discovery: you start with little certainty about\nthe examples’ completeness, and as you contest them and improve the list, you\nbecome more certain that your understanding is sound.\nKey examples should be chosen to illustrate the acceptance criteria clearly and\ncompletely. As acceptance criteria change, the list of key examples evolves.\nSome examples support the team in their attempts to write new code, and some\nexamples critique the product, aiming to improve its quality.\nNew features add new specification documents to the specification suite, but\nthe existing specification suite can also cause changes in new features. The new\ninfluences the old, but the old can also change the new.\nRefining user\nstories with\nexamples\nWriting\nscenarios\nChoosing key\nexamples\nUnderstanding\nbusiness goals\nRefining\nscenarios\nRefining\nexamples for\nreadability\nEvolving the\ndocumentation\nsystem\nValidating the\nspecification\nsuite\nAnalyzing\nrequirements\nwith examples\nCollecting\nexamples\nConveying\nrequirements in\nuser stories\nAnalyzing\nlong-term\ngoals\nAnalyzing\nshort-term\ngoals\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.16\nThe full life cycle of \nan executable specification\n\n\n148\nLiving documentation\nEverybody who’s ever worked with software has probably dealt with documentation\nat some point. Documentation can be provided on paper or online, or on digital or\nanalog media, such as audiotape or CDs. SBE introduces a different type of docu-\nmentation.\nDEFINITION\nLiving documentation—Documentation that changes along with\nthe system it describes. Thanks to frequently validated acceptance tests, the\nliving documentation system is aware of changes you make to the system; if\nthe changes yield different results than the results expected by the living\ndocumentation system, running acceptance tests will yield an error.\nSBE is actually a system of documentation. What I mean is that living documentation\nis a suite of acceptance tests written in a domain-specific language like Gherkin and\nThis chapter covers\nUnderstanding living documentation\nHelping new team members with living \ndocumentation\nDefining domain concepts consistently\nDocumenting product changes and troublesome \nareas\n\n\n149\nreadable by nontechnical team members. Through acceptance tests, automated sce-\nnarios are tied to application code. This means scenarios that describe functional and\nbehavioral requirements can be used to create a living documentation system that\nevolves every time the code changes.\n Moreover, writing documentation isn’t a separate activity or a standalone phase.\nThe scenarios are the documentation. In chapter 6, you saw that every executable\nspecification evolves during development, increasing its precision level throughout its\nlife cycle. You start with high-level requirements that vaguely describe business goals,\nand you end up with a set of automated acceptance tests that are low-level and precise\nbecause they’re actual working code. At the high-fidelity end of that spectrum, when\nthe first drafts of scenarios are finished and approved, executable specifications\nbecome living documentation. Having already explored how to write scenarios in\nchapters 2 and 3 and how to write scenario outlines in chapters 4 and 5, it’s high time\nwe talk about creating high-precision living documentation from specification drafts.\n Even though I didn’t dwell on it, you used some of the techniques for building a\nliving documentation system in previous chapters to do the following:\nExplain difficult domain concepts\nHighlight differences between dangerously similar domain concepts\nDocument troublesome areas of implementation\nGive more context about business goals\nThanks to these activities, living documentation can be of great value to software\ncompanies:\nIt allows team leads to get new hires up to speed much more quickly, because\nthey can take advantage of documentation that is brief, concise, customer ori-\nented, and always up to date.\nWhen teams validate frequently and make the specification suite part of a con-\ntinuous integration system, they can easily trace an integration error back to its\ntest and, beyond, to a scenario linked to the broken part of the application.\nSuch scenarios can be used as documentation to repair the bug more quickly.\nI talked about continuous integration in section 1.6.2: it’s a software development\npractice where members of a team integrate their work frequently, and each integra-\ntion is verified by an automated build to detect integration errors quickly. And\nthroughout chapters 5 and 6, we investigated how valuable good, meaningful tests in\nscenario outlines can be in terms of product quality.\n This chapter talks in depth about each of the activities needed to create great doc-\numentation that evolves along with the system. By the end of the chapter, you’ll know\nwhat a minimally qualified reader is and why writing for a specific reader in your orga-\nnization matters. A reader-oriented mindset will teach you to better document changes\nin the specification suite. You’ll practice creating definitions for new concepts in the\nubiquitous language of your projects. In the long term, this will help you manage the\nthat language in a growing specification suite.\n\n\n150\nCHAPTER 7\nLiving documentation\n7.1\nLiving documentation in action\nFirst, we’ll look at living documentation from a practical perspective. Throughout this\nchapter, you’ll be using as an example an application called HouseKeeper. House-\nKeeper is free property-management software for independent tenants and landlords.\nLet’s suppose that thousands of property managers save time and money every month\nwith HouseKeeper, whether they’re managing one unit or hundreds. HouseKeeper\nhandles online rent payment, tenant screening, and credit and background checks.\nThis example will show you documentation practices in action in a domain that’s both\nfamiliar and difficult.\n One day, a coworker named Peter comes to you because he saw in the version con-\ntrol system that you were the last person who contributed to the specification docu-\nment he’s having trouble with. Peter is new to the team. He’s also from Poland, where\nrenting works much differently than in the United States; there are fewer legal obliga-\ntions in Poland, and the market is less saturated, because most people buy their own\napartments and the only renters are college students. Understandably, Peter is having\na rough time with the transition, but he’s trying his best to learn fast.\n Peter mentions that he has some questions about the documentation—mainly the\nlack of it. You’re surprised. Before you can get to the bottom of the problem, you read\nthe scenario in question. It’s about qualifying and scoring the best candidates when a\nproperty is vacant and no lease has yet been signed.\nFeature: Qualifying tenant leads\nScenario Outline: Screening candidates\nGiven a lead:\n| name\n| credit used | total debt |\n| Simona Jenkins | <used>\n| <debt>\n|\nAnd that the lead waits in the queue to the tenants pipeline\nWhen the candidate has a <score>\nThen we should <result> the lead\nExamples:\n| used | debt\n| score\n| result |\n| 40%\n| $202,704 | credit score of 499 | reject |\n| 41%\n| $202,704 | credit score of 500 | accept |\nYou then ask Peter what’s wrong.\n“I’m just confused,” he says. “There’s a lot of terminology that isn’t explained anywhere.\nFor example, what’s a tenants pipeline?”\n“It’s a list of verified tenants that landlords get … but I see your point. Are there any\nother issues you’ve noticed?”\n“Yes. Are screening and qualifying leads the same? And, while we’re at it, are tenant\nleads and candidates the same? Or is a candidate some special kind of a lead? Or maybe\nit’s the other way around.”\nListing 7.1\n[BAD] Executable specification with no documentation\n\n\n151\nLiving documentation in action\n“You’re right, that might be confusing. They’re actually the same. I suppose I didn’t want\nto use the same expression so often.”\n“Yeah. By the way, is the credit score rating the entire screening process? If so, why can’t it\nbe called a credit report? Why invent an additional name?”\n“Actually, the credit score is just one part of the screening process, which can involve other\nsteps as well. We just don’t support them right now.”\n“Oh, I see. That might not be obvious for some people, like me. And that might become a\nlarger issue in the future, because I noticed that we’re hiring more engineers from all over\nthe world. And renting doesn’t work the same everywhere!”\nAs you can see, there are several troublesome areas when it comes to the documenta-\ntion aspect of your scenario outline:\nYou need to make the naming consistent, making sure the same concepts are\nalways referred to by the same name. Doing so should remove the trouble with\ncandidates and leads, as well as screening and qualifying.\nWhen you first wrote the text, you had some assumptions about your team\nmembers’ prerequisite knowledge, regardless of their experience. The tenants\npipeline is an example. And even though screening is the main criterion for\nlandlords considering tenant leads, it’s not explained anywhere. That has to\nchange.\nSome domain concepts, like screening and credit scores, may be new to some\nteam members and difficult for them to understand. That means you didn’t\ntake into account the idiosyncrasies of your team when you wrote the scenario.\nIt’s out of touch.\nWhat could you do to change that? Here are some ideas.\nFeature: Screening tenant leads\nSCREENING is the process of evaluating a tenant lead before\nsigning a lease in order to choose the best candidate.\nTENANT LEAD is a potential tenant who applied to live in\nan apartment managed by our rental platform.\nPlease note that the manual screening process is more complex\nthan the one we currently support in our product. For example,\nin the future we might want to support checking criminal or\neviction history, or even terrorist watchlist search.\nScenario Outline: Screening tenant leads based on credit score\nListing 7.2\n[GOOD] Documented specification with fixed issues\n“Qualifying” is now called \n“screening” everywhere the \nconcept is mentioned.\nDefinition of “screening” supplied\nin the specification brief\nDefinition of\n“tenant lead”\nsupplied in the\nspecification\nbrief\nExplanation of the screening \nprocess’s business context and your \nteam’s progress on implementing it\nCandidates are now consistently\ncalled tenant leads.\n\n\n152\nCHAPTER 7\nLiving documentation\nTENANTS PIPELINE is a list of verified tenant\nleads a landlord can choose from.\nCredit score is calculated by an external auditor\nthrough their API and has a range of 300-850.\nGiven a tenant lead:\n| name\n| credit used | total debt |\n| Simona Jenkins | <used>\n| <debt>\n|\nAnd that the lead waits in the queue to the tenants pipeline\nWhen the tenant lead has a <score>\nThen we should <result> the lead\nExamples:\n| used | debt\n| score\n| result |\n| 40%\n| $202,704 | credit score of 499 | reject |\n| 41%\n| $202,704 | credit score of 500 | accept |\nLet’s sum up the changes:\nYou added a few short definitions that explain the most important domain con-\ncepts. This should ensure that every team member who reads the scenario,\nregardless of their experience, has more or less the same knowledge when they\nstart working with the specification.\nYou cleared up the naming issues so there’s no way to confuse a domain con-\ncept with any other domain concept.\nYou added notes about screening and the credit score that explain the business\ncontext of the feature. You let the reader know that you’re at the beginning of a\njourney to create a great screening process; even at this early stage, you need\nhelp from other companies who do credit reports and background checks,\nbecause those aren’t your company’s area of expertise.\nNote that although all of these changes could have been made earlier in the life cycle\nof the executable specification—when it was first written, for example—there’s noth-\ning wrong with the fact that the changes are only happening now, after Peter pointed\nthem out. That’s why we talk about a living documentation system. Such a system\nemploys feedback loops to correct itself over time. These feedback loops can be man-\nual—as in Peter’s case, when he had to read the specification before tackling a bug\nerror connected with that area of your product. But feedback loops can also be auto-\nmated. For example, if a particularly nasty bug breaks your continuous integration sys-\ntem periodically, you can progressively add more regression examples to ensure that\nthe system doesn’t break again. That, too, is documentation.\n You saw how such automated living documentation works in section 5.3.4, when we\ndiscussed boomerangs. Executable specifications can eventually stop boomerangs—\nfunctionalities that break every now and then—if you automate each new edge case as\na regression example.\nDefinition of “tenants pipeline” \nsupplied in the scenario brief\nExplanation of how a \ncredit score is calculated \nand what the range is\nCandidates are now\nconsistently called\ntenant leads.\n\n\n153\nWriting documentation\n In chapter 6, you saw automated living documentation in action when we dis-\ncussed iterating executable specifications over time. Section 6.1 showed that when a\ndelivery team implements a new executable specification, they should also execute\nexisting specifications in order to check whether they still work after changes are\nintroduced to the system. Only in this way can the team verify that the specification\nsuite is still consistent—and that the living documentation is up to date.\n Because previous chapters covered many areas related to automation, I focus here\non writing high-precision documentation instead of having up-to-date tests. In SBE,\niterations are the common thread between automated documentation and manual\ndocumentation. Either way, manual or automated, the living documentation system\nworks iteratively—so you can let go of the expectation that you should nail things\ndown on the first try every time.\nNOTE\nWhen I say living documentation in the context of this book, I mean that\nthe documentation changes along with the product; tests help to achieve this\nresult, but they aren’t the only component. Be aware that other authors may\nmean regression tests, discussed in chapters 6. \n7.2\nWriting documentation\nThe example in the previous section showed some documentation challenges and\npractical solutions to deal with them. Let’s now talk in depth about each of these\nmethods. You’ll see how to use them effectively and what their major use cases are.\n From a 50,000-foot view, Gherkin scenarios are high level and talk about the busi-\nness instead of technology specifics; as a result, business stakeholders will read and\ncontribute to them, which helps bridge the communication gap between delivery\nteams and the business. Because scenarios explain the most important user flows as\nwell as the inputs and outputs of features, high-level documentation for a business can\ndo two other important jobs:\nDocument the business domain for people who are unfamiliar with it\nDocument the delivery team’s decision-making process for future reference\nWithout business domain documentation, scenarios will be difficult for anyone unfa-\nmiliar with the product to understand. For example, let’s say I’m a product manager\nand you’re a new hire on the team. I’m onboarding you to the product. I could start\nby telling you about the steps needed to make the application generate a tenants pipe-\nline—you need to click here, write that, go there—but that doesn’t guarantee you’ll\nknow what the pipeline is. Sometimes seeing doesn’t equal understanding.\n Living documentation can include decision making because executable specifica-\ntions have a long life cycle that covers every phase of development. Scenarios can\nreflect decisions made in analysis, design, or development. The life cycle even expands\nbeyond implementation. When acceptance tests that are part of the continuous inte-\ngration process break, the specification suite prohibits integration or deployment, thus\n\n\n154\nCHAPTER 7\nLiving documentation\navoiding errors in production. Teams can use that to spot and document troublesome\nareas that break often. If any errors still slip through, they can be documented as\nregression tests later, after they’re fixed. Why should you do that? Because document-\ning the decision-making process will let you and your peers recreate your thought pro-\ncess in the future and make sure future decisions are consistent with past ones.\n Next, let’s explore documenting domain concepts and documenting decisions. \n7.3\nDefining important domain concepts\nThe two most popular and practical uses of any documentation are these:\nLearning about things you don’t know\nRecalling details you learned in the past but have forgotten\nFor example, if you hear somebody mention a domain concept called a price index, and\nyou have no idea what that means, you can check the documentation. And if you work\non that feature again in a few months, you’ll check the docs again to refresh your mem-\nory. Defining new concepts and making the definitions easy to find under quickly\nsearchable names is one of the most important jobs of any documentation.\n7.3.1\nWriting lexical definitions\nChapter 1 talked about the ubiquitous language: a common language for developers,\nbusiness stakeholders, and end users. To illustrate the concept of such a language and\nthe cost of mental translations, I talked about a public transport mobile app that sug-\ngested Edison Street to the user as a final destination, because it couldn’t fetch Edison\nBusiness Center—the user’s intended destination—from the database. The mistake\nhappened because the user and the developers associated different domain concepts\nwith the term destination. The delivery team thought of bus stops; but the user wanted\nto get to a specific place regardless of whether it was a bus stop, a street, or a building.\n In that case, a wrong definition led to wrong code. To avoid similar mistakes, the\nteam could add a refined definition to the executable scenario and use it as documen-\ntation for future reference.\n In the example of the real estate application at the beginning of this chapter, you\ndid a similar thing to clarify the domain concepts of screening, tenant leads, and a ten-\nants pipeline. Here’s a definition within a scenario outline:\nScenario Outline: Screening leads based on credit score\nTENANTS PIPELINE is a list of verified tenant\nleads a landlord can choose from.\nYou used the scenario brief to write a short note that explains what the pipeline is.\n(You also used the specification brief for the same reason with a second definition.)\nTruth be told, this isn’t the most advanced definition in the history of definitions—it’s\na simple clarification that gives the reader more context. When it comes to the art of\n",
      "page_number": 150
    },
    {
      "number": 7,
      "title": "Living documentation",
      "start_page": 176,
      "end_page": 196,
      "detection_method": "regex_chapter",
      "content": "155\nDefining important domain concepts\ndefinitions, Gherkin favors a utilitarian approach: use anything that works for your\nteam, and refine it in case of any misunderstandings.\nTIP\nWrite lexical definitions in specification and scenario briefs when you\nwant to explain a domain concept in your own words. Use specification briefs\nfor global definitions that are important to the entire specification. Use sce-\nnario briefs for local definitions that are relevant to specific scenarios only.\nBecause specification and scenario briefs are free-flowing text sections in Gherkin’s\nsyntax, there’s no specific way to format definitions. Many Gherkin practitioners use\nsystems like Markdown, with its headings and text formatting. Personally, I favor com-\nmon text files, using uppercase to define new domain concepts. The choice is almost\nentirely aesthetic, but I also like that it’s the simplest possible way to make definitions\nstand out—you don’t have to know a formatting system to see that a brief includes\nsomething important.\nExercise 1\nCreate a short definition that explains what a scenario outline is.\nUsing connotative definitions\nDefinitions used in this section are called connotative definitions. A connotative defi-\nnition specifies the necessary and sufficient conditions for a thing to be a member\nof a specific set.\nHere are two examples of connotative definitions:\nTriangle: a plane figure that has three straight bounding sides\nQuadrilateral: a plane figure that has four straight bounding sides\nAs you can see, connotative meaning relates to the associations, overtones, and feel\nof a concept, rather than what it refers to explicitly—which is what denotative defini-\ntions do.\nIn terms of logic, connotative definitions create a decision tree of questions whose\nanswers can be used to state whether an objects fits the definition. For example, in\nthe case of the definition of a triangle, you can ask two questions that let you define\nwhether any object is a triangle. The first question is whether the object is a plane\nfigure. If it isn’t, it can’t be a triangle. If the object is a plane figure, you need to ask\nthe second question: whether the object has three straight bounding sides. If it does,\nit can’t be a triangle—but only in terms of pure logic, of course. (And every person\nwho has ever built software knows how difficult it can be to find perfect boundary con-\nditions while also taking care of all the edge cases and exceptions.)\n\n\n156\nCHAPTER 7\nLiving documentation\n7.3.2\nWriting illustrative definitions\nOther ways to define a domain concept can also be considered. Sometimes, it may be\ntoo difficult to write a clear, concise definition that captures the essence of a problem.\nIn that case, you can use the second popular way to create definitions: illustrating, list-\ning examples that belong to the set you’re trying to define. Gherkin works great with\nthis method, because illustrating is Gherkin’s core job. Even the term specification by\nexample reflects that.\n Let’s look at how you can use a definition by example. Suppose the HouseKeeper\napp can work with multiple types of tenancies, by which I mean that some landlords\nwant to rent an entire apartment, some want to rent a single bedroom, and others\nrent a single bed in a shared bedroom. You could try to define these tenancies under\nthe umbrella term housing unit, and you could try to define units the same way you did\nwith the previous definitions. For example, you might say that a unit is a place where\nthe occupants live and eat separately from other residents in the structure or building.\nBut is that the best approach? It sounds horribly abstract.\n Instead, you can create an illustrative scenario that lists all the types of units. This\nway, the scenario itself becomes a definition of a domain concept. Here’s how that\nmight look.\n(continued)\nThe type of connotative definition used in the previous examples of a triangle and a\nquadrilateral is called a genus-differentia definition. It’s a type of definition that takes\na large category (the genus) and narrows it down to a smaller category based on a\ndistinguishing characteristic (the differentia). For the triangle definition, the genus is\nplane figure and the differentia is with three straight bounding sides: three bounding\nsides are what distinguish triangles from quadrilaterals, which have four bounding\nsides, and other plane figures, which have even more. \nPlane figure\nEssence\nNot a plane figure\nThree straight\nbounding sides\nTriangle\nNot three straight\nbounding sides\nThe decision tree of a connotative \ndefinition of a triangle\n\n\n157\nDefining important domain concepts\nFeature: Units\nScenario Outline: Defining types of units\nGiven a <unit>\nWhen a new tenant moves in\nThen the tenant should have a lease on <rent>\nExamples:\n| unit\n| rent\n|\n| apartment\n| the entire flat\n|\n| room\n| their room only\n|\n| shared bedroom | share the rent with a roommate |\nThis scenario outline isn’t a great test. It’s simple, like the definitions you created\nbefore, and it doesn’t test anything mission critical. But it does its job well: it illustrates\nby example a new domain concept better than you could define the concept with an\nabstract definition.\nTIP\nUse a definition by example when it’s easier to imagine and understand\nthe properties of a given set of items by listing the items within that set than\nby trying to capture the set’s essence with a concise definition in the specifica-\ntion brief.\nListing 7.3\nDefining by example using a scenario outline\nExercise 2\nCreate a definition by example that will define the concept of Gherkin keywords like\nGiven, When, and Then.\nUsing denotative definitions\nDefinitions by example can also be called denotative definitions. A denotative defini-\ntion means a list that names the objects that belong to the set being defined; for\nexample, “A plane figure is something like circles, triangles, squares, rectangles, and\nso on.” Denotative definitions are practical; they state what is, as is.\nThey can be inefficient, though—for example, a complete list of plane figures will be\nlong. A connotative definition creates a hierarchical decision tree of investigative\nquestions, whereas a denotative definition creates a flat decision tree of all possibil-\nities in a given set—a plane figure can be a circle or a triangle, or a square, or a rect-\nangle, and so on. The listing is safer, because the only thing you have to do is to\ncheck whether an item belongs to the specified set, but it’s also longer and more\ndifficult to maintain in the long run. The list can grow or shrink; you have to keep it\nup to date. \n\n\n158\nCHAPTER 7\nLiving documentation\n7.3.3\nUsing glossaries\nAlthough putting a definition in a scenario that required clarification in the first place\ncomes naturally, it also has some downsides. The most obvious is that various scenarios\ncan mention the same domain concepts multiple times throughout the specification\nsuite. For example, the scenario outline used in this chapter’s main example mentions\na tenants pipeline, so you put the definition there; but if you had to deal with the com-\nplete specification suite of the HouseKeeper application, you’d probably have to men-\ntion the pipeline in many other feature files, too. Should you define each domain\nconcept from scratch in every scenario that mentions it? If you did so, you’d quickly\ndiscover that having so many definitions is difficult to maintain over time.\n One way to solve the dilemma is to define a domain concept only in the scenario in\nwhich it originates. In that case, you’ll only have a definition for the tenants pipeline in\nthe scenario outline about tenant leads from this chapter—because that’s where the\nconcept appears for the first time in the domain. This isn’t the perfect solution,\nthough, because it forces readers to search for the definition in other feature files. But\nformatting definitions in a consistent way may make searching the specification suite\nmuch easier.\n Another approach is to quit writing definitions in the briefs and instead create a\nseparate file in the specification suite that contains all the definitions. Such a file can\nfunction as the project’s glossary. It doesn’t even have to be written in Gherkin; if you\nwrite a simple .txt file (or perhaps a .md document formatted in Markdown), every\ntest runner will ignore it during validation. I’ve used glossaries several times and been\nhappy with the results, especially in projects with complex domains where concepts\nrequired frequent clarification. The downside of having a glossary is that maintaining\nit requires additional effort; a plain text file isn’t connected to the automation system\nthat keeps the living documentation up to date. Whenever you change a scenario in a\nway that redefines a corresponding domain concept, you must remember to update\nits definition in the glossary—which is more difficult because the definition is no lon-\nger in the same file and can’t serve as an obvious reminder.\nNOTE\nWe’ll come back to the concept of glossaries in chapter 11. The prob-\nlem with glossaries is that they depend heavily on context. For example, a sin-\ngle term can have multiple meanings, depending on context. Such terms are\ncalled polysemes. In chapter 11, you’ll learn how to deal with polysemes and\ncreate unequivocal glossaries. \n7.3.4\nNaming important domain concepts\nClosely connected to the area of definitions is naming. Naming domain concepts\nappropriately is important because people involved in development may call the same\nconcept by the same or different names, which can lead to potentially disastrous mis-\nunderstandings. You saw something like this in the HouseKeeper project, when Peter\nwasn’t sure whether screening and the process of qualifying tenants were the same; he\nhad similar doubts regarding candidates and tenant leads.\n\n\n159\nDefining important domain concepts\nTIP\nA single domain concept should always be referred to by the same\nname. Even slight changes in naming can cause people to wonder whether\nthey’re dealing with an existing domain concept or a new one—is it the\nsame, or similar but slightly different? There’s no way to know without addi-\ntional clarification.\nNames have power. As the saying goes, “There are only two hard things in computer\nscience: cache invalidation and naming things.” A lot of the effort involved in writing\nGherkin also concerns naming, because Gherkin is a domain-specific language that\nlooks similar to plain, business-readable speech. And, as in any language, Gherkin\nwriters must be careful when creating or giving names.\nTIP\nDon’t invent a new name if you’re modeling a domain concept that\nexists in the real world outside of your application. Delivery teams should\nstrive to understand and use the language of domain experts and not replace\nit with their own technical language. For example, don’t call screening some-\nthing like validating candidates, even if you think it’s a better name for what’s\ngoing on behind the scenes in the backend. (You can use your own names for\ndomain concepts that the delivery team invented to help users do their jobs\nmore quickly and easily.)\nIn Gherkin, naming has three crucial areas: naming actors, naming actions, and nam-\ning beginning and ending states.\nNAMING THE ACTORS THAT APPEAR IN SCENARIOS\nLet’s say you have two scenarios that are unrelated to each other. The first scenario\nmentions Simona Jenkins, who is an admin in the application. The second scenario\ntalks about Adam Johnstone but calls him a user with admin privileges. Are admins\nand users with admin privileges the same or different? The reader of the scenarios can\nonly assume. And you know what they say about assuming ... \nNAMING THE ACTIONS IN SCENARIOS\nI talked about naming actions with regard to screening and qualifying tenant leads. In\nthe example domain, these two terms describe the same activity. They have different\nnames, though, which made Peter think they might be two separate, although related,\ndomain concepts. \nNAMING THE STATES IN WHICH SCENARIOS BEGIN AND END\nIn the strictest sense of the word state, the subsection on naming actors inferred states:\ntwo actors were in the state of having an admin account. Similar inconsistencies hap-\npen so often that I wanted to talk about them separately. But there are also problems\nwith naming other states.\n For example, you should focus on maintaining consistency between initial states and\nexpected states. The initial state is set in the Givens and talks about how things look at\nthe beginning of a scenario. The expected state is the state at the end of the scenario,\nwhen the change described in the main action of the steps has taken place. Initial states\nand expected states are extremely important to the testing aspect of each executable\n\n\n160\nCHAPTER 7\nLiving documentation\nspecification. They tell testers and developers the intended consequences behind the\nscenario—the consequences they have to make sure take place. So naming the same\nstate one way when it’s an initial state and another way when it’s an expected state can\nresult in misunderstood features and rework.\nTIP\nYou should favor simple names that are easy to search for. Doing so will\ncome in handy when you have to find a single definition in a huge specifica-\ntion suite. \n7.4\nDocumenting decisions using briefs\nIn section 7.2.1, you saw how specification and scenario briefs can contain useful\ninformation such as definitions. Specification and scenario briefs are versatile; they\ncan contain any free-flowing information—and because the life cycle of an executable\nspecification is long, starting in the analysis phase and expanding even beyond the\nimplementation phase, you may want to include information in addition to defini-\ntions. For example, you could explain why you wrote a scenario the way you wrote it,\nor you could give some context about the scope of the feature. These decisions can\nalso be documented in briefs, in several ways.\n7.4.1\nUsing warning notes to highlight problematic areas\nA warning note is meant to highlight troublesome areas of any given specification. A\nwarning can indicate, for instance, difficult testing or implementation issues that\nshouldn’t be missed if the delivery team decides to rework the feature.\n Here’s an example of a warning note. You may have seen it before, because it’s a\npopular joke, but it always makes me smile:\nOnce you are done trying to 'optimize' this routine,\nand have realized what a terrible mistake that was,\nplease increment the following counter as a warning\nto the next guy:\ntotal_hours_wasted_here = 42\nThis warning note was originally a code comment, which makes it ineligible for a\nbusiness-level specification suite, but I mention it because you can have similar warn-\nings for domain concepts and requirements. For instance, section 5.3.4 discussed\nboomerangs (functionalities that break repeatedly) as a good source of examples for\nscenarios. A warning note in the table brief would be perfect to explain the context\nbehind any given boomerang and maybe give some tips to the maintainers about how\nto avoid repeating mistakes the team made in the past. \n7.4.2\nUsing context notes to deepen the business context\nContext notes explain the details of a feature’s business context. You can use them to\nelaborate on the current scope of the functionality, talk about industry standards,\nmake a quick analysis of similar features used by competitors, or describe the circum-\nstances of taking on the feature in the first place.\n\n\n161\nHigh-level overview of the documentation process\n The HouseKeeper example uses a context note when the specification brief\nexplains the minimized scope of the screening feature, which, in this case, only covers\ncredit score reports:\nPlease note that the manual screening process is more complex\nthan the one we currently support in our product. For example,\nin the future we might want to support checking criminal or\neviction history, or even terrorist watchlist search.\n7.4.3\nUsing maintenance notes for internal purposes\nBy maintenance notes, I mean notes that aren’t related to the functionality itself.\nInstead, they help readers navigate the specification suite and maintain it in the long\nterm if they choose to edit a scenario or add a new Gherkin file.\n A maintenance note is a meta-note. It doesn’t elaborate on any particular step in\nthe scenario; it talks about the scenario itself. For example, it can explain where cer-\ntain scenarios are located or why they were split between various Gherkin documents\nin a certain way:\nSince screening is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenarios.\nYou can find more detailed scenarios in the rest\nof the files inside the \"screening\" folder in the\nspecification suite.\n7.5\nHigh-level overview of the documentation process\nSo far, this chapter has taken you on a whirlwind tour of the most important docu-\nmentation techniques an SBE practitioner may want to use. But when you’re working\nday to day with real teams, knowing the techniques may not be enough. Knowing that\nyou can document product changes using notes is different than knowing when to doc-\nument these changes and when not to document them. Both of these questions can be\nequally important, and the answers can vary depending on the particular team. Some\nteams may need more documentation; some teams need less. Every team needs differ-\nent documentation. In this section, I’ll talk about how to understand your team’s idio-\nsyncrasies, choose the best strategy to achieve your documentation goals, and tweak\nthe content of your scenarios so everyone on your team can benefit from the docu-\nmentation.\n From a high-level perspective, the main purpose of documentation is communica-\ntion. Documentation can communicate relevant instructions and applications, dan-\ngerous bottlenecks, potential issues, and proven solutions.\n In communications theory, a message is the smallest unit of communication. Every\nmessage is made out of three elements:\nSender\nReceiver\nContent\n\n\n162\nCHAPTER 7\nLiving documentation\nFigure 7.1 illustrates these three elements.\n We can translate such a diagram to the domain of SBE as follows:\nA sender is anybody who writes documentation.\nA receiver is anybody who reads the documentation, intending to use it in work.\nContent means Gherkin scenarios that are refined and precise enough to be\nused not only as short-term specifications but also as long-term documentation.\nI’ve already talked about the techniques you can use to create fine documentation\ncontent. You were able to do so thanks to a well-defined example. The example,\nthough, is always just an example; it’s a static snapshot of an imaginary application\nthat’s designed to be easy to digest in order to facilitate learning. The real world is\nmessier.\n While working with your documentation, you may feel the urge to jump straight to\nwriting the content of your scenarios, as you did earlier. This isn’t always a good idea.\nIn this section, I’ll argue that senders and receivers can greatly influence the final\nshape of living documentation, and—if these elements aren’t given enough care—not\nalways in a positive way. Even a crafted message can be met with a dismissive shrug if\nthe message isn’t tailored to the audience, highlighting passages they’re most likely to\nagree with. On the other hand, sometimes a good message with a well-defined audi-\nence misses its mark because the sender wasn’t the right person to drive its point\nhome. Think of a politician who runs on a platform of getting rid of corrupt officials\nin a country where corruption is the number-one issue—but at the same time, that\npolitician has a history of corruption scandals.\n To create great documentation, you need three elements: people who can create a\nmeaningful message, a well-defined audience, and engaging content that’s full of\nhelpful tips (see figure 7.2). I covered the topic of engaging content at the beginning\nof this chapter, when describing useful documentation techniques, and in the other\nchapters, when I talked about writing great scenarios. Now let’s look at writers and\nreaders.\nSender\nMessage\nReceiver\nContent\nFigure 7.1\nThe general \nschema of communication\n\n\n163\nWho creates living documentation?\n  \n7.6\nWho creates living documentation?\nTraditionally, professionals whose field of work is documentation are technical writers\nand corporate communicators. A technical writer is a professional writer who pro-\nduces technical documentation. Technical writers can sometimes be domain experts\nwho know the ins and outs of the business they’re writing about. Most of the time,\nthough, they collaborate with domain experts, engineers, and—if documentation is\npublicly available—end users to create full documentation.\n Why are communication and collaboration important? Melvin Conway had a good\nanswer. He was the computer programmer behind Conway’s Law, which is an adage\nintroduced in 1968: “Organizations that design systems are constrained to produce\ndesigns that are copies of the communication structures of these organizations.” In\nother words, healthy communication produces healthy designs—and dysfunctional\ncommunication produces dysfunctional designs.\n With Gherkin, documentation is a result of the entire team’s work and is every-\nbody’s responsibility. Every engineer, designer, analyst, and tester can write Gherkin\ndocumentation, just as anyone can write or edit scenarios. It’s not only encouraged;\nsometimes it’s necessary. SBE is a process that by definition requires interdisciplinary\ncollaboration. Most of the time, analysts and designers can provide the correct behav-\nior—but developers and testers know the best way to write a test so that it’s easy to\nautomate later and fits into the rest of the living documentation system.\n If analysts or designers worked alone, they would most likely write brittle tests. If\ndevelopers and testers worked alone, they would probably optimize for automation\ntoo much and write scenarios that were difficult for nonprogrammers to understand.\nBalance is key.\nWho writes it\n and when?\nDelivery team when\nthey must make\nnew decisions\nParticipants of the\nworkshops before\nimplementation\nLiving\ndocumentation\nWho reads it\n and when?\nExisting team\nmembers when they\nrevisit the features\nNew team\nmembers during\nonboarding\nWhat’s the\ncontent?\nDocumentation of\nthe on-the-fly\ndecision making\nDocumentation \nof the business \ndomain\nFigure 7.2\nWhen working \nwith a living documentation \nsystem, you must take into \naccount three aspects: the \npeople who create the \ndocumentation, the people \nwho will read it, and the kind \nof content that should be \ncreated by the former to \nsatisfy the latter.\n\n\n164\nCHAPTER 7\nLiving documentation\n7.6.1\nCreating documentation through all-team \nspecification workshops\nSection 1.5.3 talked about how SBE encourages you to specify collaboratively by invit-\ning stakeholders to specification workshops or holding smaller, more regular meet-\nings within the delivery team. Because automated tests let specifications become\ndocumentation, the same workshops can be used to work on the most important\naspects of future documentation: for example, clarifying difficult domain concepts.\n Big, all-team workshops can help teams that have recently started working with SBE.\nThey’re intense domain- and scope-exploration exercises. Although most of the time\nin workshops is spent collecting relevant examples and building the short-term under-\nstanding required for the delivery team to kick off development, you can just as easily\ndesign exercises to facilitate long-term learning that later pays off in documentation.\n For example, one of the most effective exercises I’ve ever seen has participants\nwrite in their own words a definition for a particular domain concept—while forbid-\nding them to talk to each other. Comparing differences in definitions almost always\nyields interesting results and gets everyone on the same page.\n Another interesting exercise is to delegate one person to be a note taker and later\nuse the notes in creating documentation. Having a single delegate often frees the\nother participants to fully immerse themselves in the workshop, although having\nmore people taking notes is also fine.\nTIP\nIf you need more inspiration for conducting workshops, read Gamestorm-\ning: A Playbook for Innovators, Rulebreakers, and Changemakers by Dave Gray,\nSunni Brown, and James Macanufo (O’Reilly Media, 2010). The book\nincludes more than 80 games to help you break down barriers, communicate\nbetter, and generate new ideas, insights, and strategies. The authors have\nidentified tools and techniques from some of the world’s most innovative pro-\nfessionals, whose teams collaborate and make great things happen. \n7.6.2\nCreating documentation through Three Amigos meetings\nTeams who’ve been doing SBE for a while don’t need as much time or as many people\nin their workshops. They often opt to hold smaller meetings and include only the peo-\nple who are required. For example, a team may choose to delegate a developer, a tes-\nter, and a designer or an analyst to represent each of the key roles required to ship the\nright software.\n Such meetings are typically called Three Amigos meetings and are run when the\ndomain still requires frequent clarification, but the most important stakeholders\naren’t available on demand. Such meetings yield most of the benefits of big, all-team\nworkshops while being much leaner, faster, and easier to organize; but they require\nadditional effort to get the delivery team and the business stakeholders on the same\npage if a stakeholder representative such as a product owner isn’t present.\n At the same time, the Three Amigos have to be careful not to force their ideas, per-\nspectives, and experiences on others by remembering that they only represent the\n\n\n165\nWho creates living documentation?\ndelivery team. For example, it can be easy for the Amigos to document one area well\nbecause they find it interesting, while leaving other areas unexplored because they\nunderstood them intuitively. It’s a good idea not to have the same people be the\nAmigos repeatedly and instead to change the squad from time to time.\n If you choose the right participants, workshops—both big and small—can be a\ngreat step to fight information asymmetry. Chapter 1 defined information asymmetry as\na situation where one party has more or better information than another. Such asym-\nmetry can sometimes drastically impair the delivery team’s ability to make indepen-\ndent decisions in the face of a crisis. Good workshops naturally reduce information\nasymmetry among the participants; but the best workshops leave a long-term imprint,\nusually in written form, that can help people who weren’t present during the meeting. \n7.6.3\nCreating documentation through individual people\nDocumentation can also be written by a single individual chosen by the team. That may\nbe, for example, the most experienced developer on the team or the only analyst who\nhas direct access to the client because of the way the organization is structured and\nmanaged. I played such a role in some of the projects I worked on; I worked on prepar-\ning detailed examples and documenting new domain concepts ahead of the team.\n This isn’t necessarily a bad practice, even though it may sound like it. After all, isn’t\nSBE all about collaboration? It is—but having a single person work ahead of the team\ndoesn’t rule out collaboration. That person can speed up development by laying a\nfoundation for future work while the rest of the team is still working on the current\niteration.\n A problem emerges when the person becomes a single source of truth about require-\nments by controlling the flow of information between business stakeholders and the\ndelivery team. For example, they may want to present their perspective on a particular\ndomain concept as the only way to understand it correctly. In such a case, the single\nsource of truth can easily become a single source of failure. Both the person who’s\nworking ahead and the delivery team must be aware of that.\nNOTE\nKeeping the rest of the team in the loop and reviewing the new domain\nconcepts shortly after the initial analysis is done are good steps toward elimi-\nnating the possibility of a single point of failure, but reducing bottlenecks is\nmore of a management topic and beyond the scope of this book. If you’re\ninterested, you can read Elastic Leadership: Growing Self-Organizing Teams by Roy\nOsherove (Manning, 2016); chapter 3 in the book, “Bus Factors,” talks about\nbottlenecks and how to eliminate them.\nSometimes a single person can write documentation after development, too. Chapter 6\nexamined SBE as an iterative process that starts when the delivery team is still highly\nuncertain about implementation detail. Writing documentation in such conditions, at\nthe beginning of the process, can be wasteful because the delivery team is probably\nwrong about some things. For example, a delivery team working with a corporation’s\nlegacy software can be sufficiently sure of the requirements even early in development,\n\n\n166\nCHAPTER 7\nLiving documentation\nbecause a big company has established processes. But almost every time you work on\nsomething new, whether for a corporation or a startup, things will be less certain. A\nteam may hold workshops and draft some scenarios without worrying about long-term\ndefinitions and notes; these can be added later, as the living documentation evolves\nalong with the feature.\n Unfortunately, in the real world, most teams can’t afford the luxury of holding\nanother workshop with several participants to work on documentation after a feature\nis implemented. Teams that can’t work on documentation collaboratively early in the\nprocess must train designers, testers, programmers, and analysts to write documenta-\ntion iteratively. Let me give you an example of what I mean when I say iteratively. Let’s\nsay a programmer was delegated to fix a bug that resulted from a misunderstanding of\na domain concept. That programmer may work on the bug alone. The programmer\nshould be able not only to fix the bug but also to fix the scenarios by clarifying the rel-\nevant domain concept and, therefore, making sure nobody repeats the same mistake\nin the future. They must either write the documentation with enough empathy to\nkeep less technical teammates in mind or be communicative enough to find and\nengage other viewpoints as they make the changes, thus making the effort more\ncollaborative. \n7.7\nChoosing the right audience for living documentation\nBefore you can start thinking about writing documentation, you need to consider who\nyou want to document for. Do you remember the last time you read well-written docu-\nmentation? As you were reading, did the text seem to know most of the questions you\nwere going to ask, and address most of the doubts in your mind? That’s how it should\nbe if the authors considered their audience. This section talks about techniques that\ncan help you become such an author.\n A single warning before we start—when you hold specification workshops fre-\nquently, you may think you’re covered in terms of including diverse perspectives in\nyour documentation. That may be true with regard to technical skill if testers, design-\ners, developers, and analysts collaborate during the workshops. But there are other\naspects you may want to consider. For example, I think we can agree that it’s reason-\nable to choose senior personnel to run Three Amigos meetings and write new scenar-\nios. After all, they’re the most likely to analyze requirements correctly due to their\nexperience and skill. The problem is, they may write scenarios for junior and mid-\nlevel personnel and lose track of what other team members need from the specifica-\ntion. The reason is the same as the reason you chose them in the first place—their\nexperience and skill. Their seniority may cause them to underestimate some issues\nand focus on others, which they consider interesting or worth tackling.\n7.7.1\nWho’s a minimally qualified reader?\nAmong its many useful purposes, documentation is a teaching tool. By documenting\nfeatures, user stories, and code, you teach readers everything they need to know to get\n\n\n167\nChoosing the right audience for living documentation\nthe feature to work. It seems logical, then, to draw some inspiration for creating better\nliving documentations from the realm of education. But in school, everyone learns at\na different pace—for example, students who are curious may already know some of\nthe material from other sources. Even if we come from similar backgrounds, every-\nbody’s knowledge base is a little different. Yet the textbook is the same for all students.\n To do their jobs well, authors who write textbooks must first establish a baseline of\nknowledge and skills that every student must possess in order to successfully complete\nthe course. Only if they do so will they know which skills need to be covered in detail,\nforming the main body of the text. If they don’t, the results will be catastrophic. To\nunderstand why, let’s consider an average student in an average class. Being average\nmeans half of the students are doing worse than the chosen student and half of them\nare doing better—which means if the textbook was written for the average student, at\nleast half of the kids will find it more or less difficult to read. That’s why textbook\nauthors spend a lot of time thinking about the right minimally qualified reader (MQR)\nand write as if for that person only, keeping in mind what that person likely does and\ndoesn’t know.\nDEFINITION\nMinimally qualified reader (MQR)—The persona of a typical stu-\ndent with the basic skills needed to benefit from the information. Knowing\nthe MQR means understanding what that person already knows, and teaching\nwhat that person doesn’t yet know. Defining the reader is an essential part of\nmaking good, useful living documentation.\n7.7.2\nFinding the perfect MQR in an organization\nJust like students, people on teams and in organizations aren’t uniform. For example,\nlet’s consider a junior-level engineer, straight out of college, who joined the team a\nfew months ago; an analyst who’s fairly senior but as a new hire hasn’t yet fully grasped\nthe business domain; a mid-level designer; and a senior tester who has been around\nforever and knows the ins and outs of the system. They all have different work experi-\nences and skills. How can you write documentation for all of them?\n Each profession—engineer, analyst, designer, and tester—already has its own doc-\numentation. Engineers can document their work with code comments or architecture\ndiagrams. Analysts also use diagrams, and they can write user stories or use cases.\nDesigners build design systems that explain their decisions and make sure elements\nand styles are used consistently. Testers document their work by building matrices for\nmanual tests, refining acceptance criteria, and writing down bugs and errors by creat-\ning regression tests.\n Engineers write documentation for other engineers, analysts write for other ana-\nlysts, designers write for other designers, and testers write for other testers. But living\ndocumentation is documentation that can and should be written by all the team mem-\nbers. The content is different, too. Gherkin scenarios talk about business features, the\nbusiness domain, and broad-concept examples, which may be new and difficult for\nthe delivery team to understand, regardless of their role and technical skill.\n\n\n168\nCHAPTER 7\nLiving documentation\n So living documentation can be written by all the team members as well as written for\nall the team members. But if everyone on the team is the audience, how do you\nchoose the MQR? In the previous section, I told you that it’s a good practice to write as\nif for that person only, keeping in mind what that person likely does and doesn’t\nknow. In my experience, it’s best to choose an actual person in your organization as\nthe MQR, because you can always run your scenarios past that person, watch the reac-\ntion, and then revise accordingly.\n How do you spot that person? What criteria should you look for?\n The MQR should\nBe experienced enough to be confident in their craft, so you don’t feel the urge\nto explain any universal solutions, either in design or in technology.\nHave at least some technical understanding due to working with a technical\nteam, but programming skills aren’t necessary.\nBe new to the business domain. It’s expected that the MQR doesn’t know the\nterminology, business-related concepts, industry standards and regulations,\ncompany workflows, or competitive advantages.\nTIP\nThe MQR should be a mid-level new hire who knows the basics of their\ncraft but doesn’t yet understand the business domain of the project. The ideal\nperson is a basic, solid programmer, designer, analyst, or tester who maybe\nhas a couple of years on the job.\nThinking about the MQR, you can also consider creating a list of prerequisites to\nexplicitly define the areas of knowledge your team members must have before work-\ning with the specification suite. Creating such a list is usually unnecessary when you’re\ndealing with easier business domains that the team thinks they know well, but some-\ntimes such a list can be of help in projects that are more difficult.\nWhen dealing with any particular feature, you may want to think about the takeaways\nyou want future readers to understand. Defining the takeaways up front will let you\ndecide on the best method for teaching the reader each skill. Some takeaways will\nExercise 3\nFind a good MQR in your organization. Can you think of anyone? They may be a\ncoworker sitting at the desk next to you.\nExercise 4\nBased on the HouseKeeper example, make a list of three to five domain prerequi-\nsites for your team in your latest project. Are you sure the MQR will know all of them?\n\n\n169\nSummary\nrequire their own scenarios; some will work well as examples within other scenarios;\nand others just need a short note in the specification brief or the scenario briefs.\n7.8\nAnswers to exercises\nEXERCISE 1\nCreate a short definition that explains what a scenario outline is:\nA scenario outline is a scenario that can take multiple examples at once.\nEXERCISE 2\nCreate a definition by example that will define the concept of Gherkin\nkeywords like Given, When, and Then:\nA Gherkin keyword is any special word like Given, When, Then, But, And, Scenario,\nFeature, and so on. Keywords are always placed at the beginning of a new line.\nEXERCISE 3\nFind a good MQR in your organization:\nIt’s tricky to provide an answer for this exercise, but I’ll try. A good MQR in my last\nmedium-sized project was Mark, a great programmer who recently joined the company but\nhad no idea about the products we were working with, because we were an agency and\nhad multiple rotating clients. Mark, if you’re reading this—hello!\nEXERCISE 4\nBased on the HouseKeeper example, make a list of three to five domain\nprerequisites for your team in your latest project:\nWhat property management is\nRental process differences in the countries you support\nThe details of signing a lease\nEXERCISE 5\nMake a list of takeaways for the screening feature from listing 7.2:\nA reader should know what the screening process is.\nA reader should know what you’re screening for.\nA reader should know what you don’t screen for and why.\nA reader should know what a credit score is.\nA reader should know when a candidate is accepted.\n7.9\nSummary\nLiving documentation is documentation that changes along with the system it\ndescribes.\nGherkin can document the business domain for people unfamiliar with it or\ndocument the delivery team’s decision-making process for future reference.\nExercise 5\nMake a list of takeaways for the screening feature from listing 7.2. \n\n\n170\nCHAPTER 7\nLiving documentation\nA lexical definition explains domain concepts in specification briefs and sce-\nnario briefs.\nA definition by example is a list naming the objects that belong to the set being\ndefined.\nA single domain concept—such as an actor, an action, or a state—should always\nbe called by the same name throughout the specification suite, to avoid confu-\nsion and misunderstandings.\nSpecification briefs and scenario briefs can be used to document various deci-\nsions made during the development process for future reference, including\nbusiness context, warnings, and maintenance notes.\nCreating Gherkin documentation is an iterative process that starts during team\nworkshops. The documentation is progressively refined as the feature evolves.\nA minimally qualified reader (MQR) is a persona of a person in your organiza-\ntion with the basic skills needed to benefit from the documentation on their\nown.\nA good MQR is a mid-level new hire who knows the basics of their craft but\ndoesn’t yet understand the business domain of the project.\n\n\nPart 2\nManaging\nspecification suites\nThis part of this book is a four-chapter series about managing specification\nsuites. Chapter 8 talks about organizing scenarios into specifications. Chapter 9\nexamines refactoring large specifications into smaller ones, chapter 10 discusses\ndesigning domain models in a specification suite, and chapter 11 talks about\nmanaging multiple domain models in large projects.\n Unlike in part 1, each chapter in part 2 discusses the same example: Activi-\ntee, an online platform for Fortune 500 companies that want to achieve better\nbusiness results by improving employee engagement. Whether a company is\nlooking to enhance health and wellness or foster team building, the HR depart-\nment can tap into Activitee’s extensive library of suggested events or charge up\nexisting internal team events—like company retreats and annual staff picnics.\n\n\n173\nOrganizing scenarios\ninto a specification suite\nI remember one particular specification my team and I worked on. The scenarios\nwere meant to describe a highly personalized management panel for the organiza-\ntion’s key performance indicators (KPIs). We started with a few KPIs and no option\nto combine them to create custom reports. Putting the scenarios in a single feature\nfile seemed an obvious choice back then—but in the end, that turned out to have\nbeen a bad decision.\n The file kept growing as new KPIs appeared. At the time, we didn’t recognize\nthe difference between exhaustive and illustrative examples, so we tested too many\nThis chapter covers\nOrganizing scenarios into specifications\nOrganizing specifications by outcome and \nstakeholder\nWorking with functional and nonfunctional \nrequirements\nChoosing among features, abilities, and business \nneeds\n\n\n174\nCHAPTER 8\nOrganizing scenarios into a specification suite\ncombinations. The specification ended up being unreadable. It had 508 lines of\ntext—about 10 times as many as the longest ones you’ve seen in this book so far. When\nwe finally rewrote the specification, we found that we had specified the same option in\ntwo separate scenarios because we hadn’t noticed that a similar example already\nexisted. If we’d had a different, more focused organization system, we would have\nbeen able to consider the granularity of our scenarios from the start.\n These are the types of issues discussed in this chapter, and for good reason. If all of\nthe 50 or so scenarios in part 1 were written for the same project, you’d end up with a\nrespectable specification suite. But real projects can have hundreds or even thousands\nof scenarios, depending on the size of the product. They have to be organized some-\nhow—a real specification suite is never just a single feature file. I’ve blissfully skipped\nover such challenges so far, because each chapter in part 1 deals with a single feature\nfile. Such conditions exist only in training exercises, though.\n The sections to come focus on the topic of organizing scenarios into specifications.\nWe’ll analyze two methods:\nOrganizing scenarios by features—Cucumber-flavored Gherkin’s default method of\norganization\nOrganizing scenarios by user stories—The default for other SBE tools, but only an\nunofficial (although popular) method in the Gherkin community\nIn this chapter, we’ll determine that the second method is better when it comes to spec-\nifying requirements. We’ll also discuss choosing the correct granularity level for speci-\nfications based on user stories, to make sure your scenarios don’t get out of control.\n To create a more complete theory of organizing requirements, we’ll expand the\ndiscussion by adding some notes about working with functional and nonfunctional\nrequirements. (I realize that some experts see this terminology as a minefield—we’ll\ndiscuss that, too.) And we’ll also talk about two new keywords that will let you organize\nyour specifications in a systematic manner: Ability and Business Need.\n The example discussed in chapters 8–11 concerns Activitee: an online platform for\nFortune 500 companies that want to improve employee engagement. Let’s say that\nyou and I are a part of an Activitee team. Encouraged by chapter 7’s praise of collabo-\nrative specification, we decide to hold a specification workshop. Because it’s our first\nworkshop together, we purposely choose a simple area to specify: the capabilities of an\nHR administrator role in Activitee’s employee-management module. We want to\nanswer this question: what are the behaviors that HR admins can perform that casual\nemployees can’t?\n Assume that the following are some of the scenarios we come up with. Don’t worry\nabout the Given-When-Then aspects of these scenarios—the names are sufficient for\nthe purpose of this story:\nEditing employee profiles\nRemoving former employees\nManaging other HR administrators\n\n\n175\nIs organizing scenarios by features a good idea?\nSeeing the list of all employees\nApproving new employees\nAssigning a new employee to a company branch\nAssigning a new employee to a department\nSyncing Activitee’s organogram with an external source\nOnboarding new employees\nEmailing employees with important announcements\nGranting limited admin access to team leaders\nCreating common interest groups\nSome of these scenarios relate to employee management, and others specify self man-\nagement between HR administrators; there’s even a scenario about email announce-\nments, which will become yet another area of implementation. If we keep brainstorming,\nwe could easily come up with more ideas.\n This process of starting with multiple disorganized ideas that are later organized\ninto more coherent material is common in all specification meetings. But how should\nwe organize our new scenarios coherently? We already suspect that we won’t be able to\nput them all in the same feature file. We wouldn’t even be sure what to call it. Would Fea-\nture: Admins be an expressive name for a specification? It sounds more like a catchall.\n If keeping the results in the same file isn’t a viable option, then the only possibility\nis to split the scenarios into several specifications. But how should we split them?\n As you write scenarios, such questions constantly arise. Which scenarios should be\nin which specifications? Should we establish a hierarchy of feature files, or will a flat\nstructure, such as putting everything in a single directory, work? Even the simplest\nquestion—how long a standard specification should be—doesn’t have an obvious\nanswer. So far, the specification documents in this book have been short. But short\ndocuments may only have been a consequence of the simplicity of the exercises. And\neven if keeping specifications short is a good practice to follow—which it is—how\nshould you split scenarios when dealing with large functionalities like modules?\n8.1\nIs organizing scenarios by features a good idea?\nCucumber-flavored Gherkin does offer a default way to organize scenarios into specifi-\ncations. Every time you wrote a specification in previous chapters, you started with the\nFeature keyword, indicating that you were specifying system features. The files that\ncontain scenarios are called feature files, which is official Cucumber nomenclature that\nisn’t used in other tools for making executable specifications. (We’ll get to that later.)\n In the case of the long list of scenarios for Activitee, you’d normally create a fea-\nture file like this:\nFeature: Employee management\n[...]\nYou’d put all the scenarios in this feature file and call it a day.\n\n\n176\nCHAPTER 8\nOrganizing scenarios into a specification suite\n I have a couple of issues with features, though:\nAnything can be a feature. A single button, like the Share button in Facebook,\ncan be a feature. A new screen, such as a user profile, can be a feature, too.\nEven a brand-new module (like a simple payment system) can be a feature. The\nword feature is often nothing more than an umbrella term for anything that’s\nbeing added to the product.\nA reasonably sized feature can change as the product evolves. If a feature turns\nout to be more important than you initially thought, it will grow larger—and so\nwill its feature file. The question is, how do you split it? Unfortunately, there’s\nno clear answer, because, once again, anything can be a feature. Without a clear\nmethodology in place, your team may split features differently each time a simi-\nlar problem appears. (Goodbye, consistency.)\nNonetheless, it’s easy to understand why Cucumber-flavored Gherkin uses features as\nthe default option. If anything can be a Gherkin feature, people who only recently\nstarted using the language will be less intimidated by it. At first, this choice can facili-\ntate faster learning. (It’s also the reason previous chapters used the Feature keyword.\nI warned you in chapter 2 not to become too attached to it!) But as you write more\nscenarios, and your specification suites become larger, you’ll realize that organizing\nscenarios by features may not be the best idea. Let’s look for something better. \n8.2\nOrganizing scenarios by user stories\nIf features aren’t the best choice, do we have other options? Earlier, I said that other\ntest runners that execute specifications don’t use the terms feature or feature file.\nLet’s examine one such tool: JBehave, a Java testing framework for behavior-driven\ndevelopment.\n JBehave calls executable specifications stories. In chapters 1 and 2, I described sce-\nnarios as short stories about the behaviors of particular actors. But JBehave takes the\nmetaphor even further: each story file can have an optional narrative section at the top\nof the specification brief. Here’s an example from JBehave’s official tutorial:\nNarrative:\nIn order to communicate effectively to the business some functionality\nAs a development team\nI want to use Behaviour-Driven Development\nIt’s not only a “narrative”—it’s a user story! User stories are one of the most popular\nmethods among technical teams for defining and discussing scope. It makes sense\nthat stories should be able to define the scope of a specification, too. In section 6.3.1,\nyou wrote a user story in a similar format when you were working on the Mapper\napplication and wanted to see how executable specifications fit into a real-world pro-\ncess of delivering software; so the concept of narratives should be more or less familiar\nto you by now.\n",
      "page_number": 176
    },
    {
      "number": 8,
      "title": "talks about organizing scenarios into specifications. Chapter 9",
      "start_page": 197,
      "end_page": 204,
      "detection_method": "regex_chapter",
      "content": "177\nOrganizing scenarios by user stories\n With stories, JBehave presents a different answer to the dilemma of organizing sce-\nnarios. You can organize scenarios according to the user stories that brought them to\nlife, which results in a more chronological model of organization. Because each file is\na separate user story and the implementation of each story can be placed in time, you\ncan track which user stories created which scenarios and when. In a way, you can see\nhow the product evolved from the first user story the team implemented to the last\none. This already sounds like a more exciting possibility than features for organizing\nspecification suites. The rest of this section look at other benefits.\n Unfortunately, unlike JBehave, Cucumber doesn’t support the Narrative keyword.\nInstead, a new Ability keyword will replace the sometimes-troublesome Feature\nkeyword.\n8.2.1\nIntroducing the Ability keyword\nThe Ability keyword is simple to use. To keep changes minimal, you only have to\nreplace the Feature keyword at the beginning of each Gherkin specification with\nAbility. No changes are needed in the automation layer, and you should keep the\n.feature extension for your files.\nNOTE\nStrangely, although features and abilities are synonymous, you won’t\nfind a word about Ability in Cucumber’s official documentation. I stumbled\non it when looking at Cucumber’s source code. I later learned that the key-\nword is listed in a table that appears if you type cucumber --i18n en in a com-\nmand shell.\nThis section takes a somewhat more elaborate route to show how to link abilities with\nuser stories. By setting scope boundaries, you can make a user story answer the ques-\ntion of which scenarios belong together in the same specification. Let’s begin by creat-\ning a simple feature. You’ll then rewrite it as an ability. Here’s the user story I chose as\nan inspiration:\nIn order to increase my engagement\nAs an employee\nI want to see relevant events and courses in my news feed\nNOTE\nI wrote this story in feature injection format. Section 8.2.2 will talk\nmore about different formats.\nAfter an HR admin assigns an employee to the correct branch and department, the\nemployee should be able to see events, courses, and discussions from interest groups\nthat are relevant to their job title. Employees from New York shouldn’t see events at\nthe Atlanta branch; likewise, engineering employees won’t be interested in training\nworkshops meant for the sales department. But sometimes an engineer from Atlanta\nmay be interested in an engineering course that takes place in New York. Here’s the\nspecification.\n\n\n178\nCHAPTER 8\nOrganizing scenarios into a specification suite\n \nFeature: Branches and departments\nScenario Outline: Employees should only see content relevant to them\nGiven <person> from <branch> who works in <department>\nWhen <person> looks at the company dashboard on Activitee\nThen <person> should see <type> <content>\nExamples: Employees should see after-\nwork content only from their location\n| person | branch\n| department\n| type\n| content |\n| Jane\n| New York | Engineering | New York after-work\n| events\n|\n| Mike\n| New York | HR\n| New York after-work\n| posts\n|\n| Tom\n| Atlanta\n| Sales\n| Atlanta after-work\n| events\n|\n| Ramona | Atlanta\n| Engineering | Atlanta after-work\n| posts\n|\nExamples: Employees should see work-related content from all locations\n| person | branch\n| department\n| type\n| content |\n| Mike\n| New York | HR\n| Atlanta HR\n| events\n|\n| Jane\n| New York | Engineering | Atlanta engineering\n| posts\n|\n| Jane\n| New York | Engineering | New York engineering | events\n|\n| Tom\n| Atlanta\n| Sales\n| Atlanta sales\n| events\n|\n| Ramona | Atlanta\n| Engineering | Atlanta engineering\n| posts\n|\n| Ramona | Atlanta\n| Engineering | New York engineering | events\n|\nEach employee has a few examples that specify the different types of content they\nshould be allowed to see. Only people from New York will see New York after-work activ-\nities such as bowling and collective outings. When it comes to work-related events and\ndiscussions within departments, people from all locations can participate. But, most\nimportant, this specification uses the Feature keyword. Let’s attempt to replace it.\nREWORKING FEATURES INTO ABILITIES\nLet’s begin by replacing the Feature keyword with the Ability keyword.\nAbility: Branches and departments\nThat’s a good start. The second step is to write down the expected business outcome.\nAbility: Engage with content I like\nNext, let’s clarify which stakeholder has this capability.\nAbility: Employees can engage with content they like\nListing 8.1\n[OK] Specification derived from a user story as a feature\nListing 8.2\n[BETTER] Feature reworked into an ability\nListing 8.3\n[BETTER] Ability with an outcome\nListing 8.4\n[BETTER] Ability with a stakeholder and an outcome\n\n\n179\nOrganizing scenarios by user stories\nTo complete the translation process, you should also specify the proposed technical\nsolution: it was the last part of the user story and will help you achieve your objective.\nAbility: Employees can engage with content they like in their news feeds\nNOTE\nFor a fully working content management system, you also need a spec-\nification that takes care of assigning events to particular branches and depart-\nments. Chapter 9 discusses that.\nThe line now looks slightly different than the original story. The reasons are simple:\nTo keep the line short and easy to read.\nTo make it fit well with the Ability keyword.\nDifferent user stories can be written in different formats, as discussed in section\n8.2.2. \nORGANIZING THE SPECIFICATION SUITE WITH ABILITIES\nSimilar to this example, you can group scenarios into abilities in a specification suite\nbased on the following, in this order:\n1\nStakeholders\n2\nBusiness capabilities of these stakeholders\n3\nReasonably small common outcomes\nIf you used the system in figure 8.1 to organize the specification suite, you’d end up\nwith something like figure 8.2. Note that neither figure includes a proposed technical\nsolution, even though that’s typically part of every user story. The figures only include\nthe expected abilities of stakeholders—for example, the ability to update a map (even\nthough a map can be updated many different ways). That’s because each specification\nspecifies the technical solution in the scenarios, so you don’t have to include it again\nin your system of hierarchy.\nNOTE\nYou’ll create a more complex example of a specification suite based\non abilities in chapter 9.\nListing 8.5\n[BEST] Ability with stakeholder, outcome, and technical solution\nAbility\nStakeholder\nOutcome\nFigure 8.1\nThe progression from left to right indicates \nhierarchy. First is the Ability keyword, which \ncreates a space for user stories in the specification \nsuite. Then come different stakeholders. In the end, \nstakeholders can achieve concrete outcomes.\nmanaging employees.feature\nHR\nAbilities\nFeatures\nFigure 8.2\nA specification suite \norganized according to figure 8.1\n\n\n180\nCHAPTER 8\nOrganizing scenarios into a specification suite\nHere’s a short cheat sheet summing up everything you need to know in order to use\nabilities in practice:\nTwo scenarios for two different stakeholders are, by definition, two different\nrequirements—so they should be two different abilities.\nTwo scenarios that describe two different business outcomes are probably two\ndifferent requirements—so they, too, should be split into two abilities.\nIf behaviors that look similar at first yield different outcomes in the end, they\nshould be put into separate abilities, because they’re probably from two differ-\nent domains. For example, a simple behavior like a company can join the\nActivitee platform could yield two or more outcomes like these:\n– The employees should be invited to create their Activitee accounts (an\nemployee management behavior)\n– Activitee’s sales department should be notified about a new company\non trial (a sales behavior)\nIn the end, you’d need to split these scenarios into two separate abilities.\nFollowing these rules will yield a specification suite full of short feature files, especially\nif you decide to use scenario outlines as you did in chapters 4 and 5. Each scenario\noutline would be a different ability for a different stakeholder, with similar outcomes\ngrouped in a few tables with examples. I also like to keep one to three edge cases as\nadditional scenarios in the same feature file if they’re small variations of the behavior\nfrom the outline. (You can find such edge cases by using techniques like context ques-\ntioning and outcome questioning, which we discussed in sections 3.3.3 and 3.3.4.)\nYou’ll probably end up with a specification that’s 50–100 lines long, which is a good\nlength for an executable specification; any reader will be able to understand its gen-\neral purpose at a glance. \nCHOOSING THE RIGHT LEVEL OF GRANULARITY FOR ABILITIES\nIn the list of rules in the previous section, I mentioned that the common outcomes\nshould be reasonably small. Let’s expand on what that means and look at another\nexample.\n Some companies on the Activitee platform have so many events that the applica-\ntion will be unusable without a good search engine to find those events. To create\nsuch a search engine, the engineering team has to deal with many filters: searching by\nname, department, branch, event type, participants, and so on.\nFeature: Event search\nScenario Outline: Filtering events\nGiven events:\n| name\n| department | branch\n| type\n| users\n|\n| Sales 101\n| Sales\n| New York | work-related | Mike, John\n|\n| Weekly status | HR\n| New York | work-related | Simona, John |\n| Bowling\n| -\n| Atlanta\n| after-work\n| Jane\n|\nListing 8.6\n[BAD] Searching for events\n\n\n181\nOrganizing scenarios by user stories\nWhen Simona searches for events by <filter>\nAnd she wants to find <value>\nThen she should see <results>\nExamples:\n| filter\n| value\n| results\n|\n| name\n| \"Staff picnic\" | no results\n|\n| department | \"Sales\"\n| \"Sales 101\"\n|\n| branch\n| \"New York\"\n| \"Sales 101\", \"Weekly status\" |\n| type\n| \"After-work\"\n| \"Bowling\"\n|\n| user\n| \"Mike\"\n| \"Sales 101\"\n|\nYou could obviously think of more search filters on the spot:\nAdd AND and OR filters.\nFilter by date and time.\nFilter by organizers.\nFilter by distance from location.\nThe real question is this: in terms of granularity, should you add more scenarios to the\nsame specification, or split scenarios for different filters between different abilities?\nIt’s an interesting dilemma. There are reasons to consider putting these scenarios in\nthe same feature file. The behavior would probably stay the same, regardless of the\ntype of filter. Inputs and outputs would differ a little, but they would be acceptably\nsimilar. The differences between filters would be solved in the automation layer. But\ndue to the number of scenarios, the resulting feature file would be so long that its\nlength could affect readability.\n This is why I mentioned reasonably small common outcomes. In this case, I can think of\ntwo possible solutions:\nSplit the scenarios into several abilities based on the rule of thumb provided\nearlier, which says that a single file should generally contain a single outline and\na few scenarios for possible edge cases. Thus, you’d give each filter its own fea-\nture file.\nRedefine what key examples means for this particular case. I like this solution bet-\nter. You should probably have only one example for each filter instead of multi-\nple repetitive scenarios.\nEither way, this is what I mean by reasonably small: when other rules fail, split your sce-\nnarios in a way that’s not overwhelming. \nExercise 1\nMake a [BAD] specification a [GOOD] one by rewriting the Feature line from listing\n8.6 into an ability with a clear outcome and a stakeholder.\n\n\n182\nCHAPTER 8\nOrganizing scenarios into a specification suite\n8.2.2\nUnderstanding the structure of user stories\nThis section deals with user stories. The chapter has used them already, but I haven’t\nexplained much about them.\n The user stories we’ve analyzed so far were written in the feature injection format:\nIn order to [achieve a business outcome]\nAs [an actor or a stakeholder]\nI want [a technical solution]\nThis format was first proposed by Chris Matts, an agile business analysis thought\nleader. You first used feature injection in chapter 6, to derive scope. Teams “hunt for\nvalue” by creating a model for business-value delivery and listing underlying assump-\ntions instead of trying to describe the value model with simple numbers. (That’s why\n“achieving a business objective” is on the first line of the template.) A well-phrased\nuser story that’s illustrated with high-level examples and that yields a fruitful discus-\nsion about expected business value can help create such a model.\n The assumption is that if you create a value model first and only then “inject” a\nfunctionality derived from the model, you’ll eliminate pet features, and the function-\nality will more likely be accepted by users and deliver real value. Therefore, abilities\nbased on user stories will be more likely to deliver value, because they enable you to\nconnect your specification process with feature injection and to derive scenarios\ndirectly from the value model.\n The feature injection format isn’t the only format; most agile coaches can come up\nwith four or five. It isn’t even the most popular format for user stories. The most pop-\nular is the Connextra format:\nAs [an actor or a stakeholder]\nI want [a solution]\nSo that [I can achieve a business benefit]\nThe general format we presented for abilities is a mix of the feature injection format\nand the Connextra template. It doesn’t follow them exactly, so it should be familiar to\npeople who’ve used either one. If you don’t like it, feel free to tweak it so it looks more\nlike your format of choice. The specific format isn’t important—what matters is\nunderstanding the value-delivery process for a requirement. Any user story that will\nbring you and your team closer to understanding this model is a good story, regardless\nof the format. Just make sure the template is easy for everyone to understand—even\npeople who weren’t present during implementation.\nTIP\nIf you’re looking for more resources about user stories, I recommend\nreading Fifty Quick Ideas to Improve Your User Stories by Gojko Adžic´ and David\nEvans (Neuri Consulting LLP, 2014) and User Stories Applied by Mike Cohn\n(Addison-Wesley Professional, 2004). \n\n\n183\nOrganizing scenarios by user stories\n8.2.3\nAnalyzing the relationship between user stories \nand executable specifications\nOrganizing a specification suite by user stories engenders an important question: are\nexecutable specifications extended user stories? Making abilities look similar to user\nstories only makes the issue more difficult. This section explores the similarities and\ndifferences between user stories and executable specifications.\n If user stories and executable specifications are one and the same, you’d expect\nthat every user story would become an executable specification and that your projects\nwould have as many stories as specifications. In practice, this isn’t true. A typical pro-\nject has many more stories than specifications. There must be differences between\nthem, despite their similarities.\nSIMILARITIES BETWEEN USER STORIES AND EXECUTABLE SPECIFICATIONS\nWe’ll start with the similarities. In 2001, Ron Jeffries—the creator of Extreme Pro-\ngramming—wrote that “user stories have three critical aspects. We can call these Card,\nConversation, and Confirmation.” He considers the textual artifact—the card—noth-\ning more than a piece of text to put on a Trello board or hang on the wall as a sticky\nnote. The card only captures a glimpse of the requirement behind the user story. It\ndoesn’t matter how refined it is; you still need to discuss acceptance criteria, tests, and\nsuccess and failure scenarios, as well as define confirmation metrics to produce a\nworking capability. In short, you must take care of the conversation and confirmation.\nThat’s why experts often call the card only a ticket for a conversation.\n In this sense, an executable specification is similar to a fully realized user story.\nGherkin scenarios often consist of recorded conversations between stakeholders, and\nthe underlying tests confirm and validate the acceptance criteria automatically. If you\nphrase the abilities similarly to how you phrase user stories, you’ll even have a link\nbetween every card and the title of the user story’s Gherkin ability.\nDIFFERENCES BETWEEN USER STORIES AND EXECUTABLE SPECIFICATIONS\nEven with all their similarities, there are some crucial differences between user stories\nand Gherkin specifications, as outlined in table 8.1; I talked some about them in sec-\ntion 6.3.1, when you wrote your first user story. Unfortunately, these differences mean\nthat ultimately you can’t treat stories and specifications the same way.\nTable 8.1\nComparison of user stories and executable specifications\nA user story…\nAn executable specification…\nIs discarded after implementation\nIs kept after implementation\nIs a unit of change\nIs an effect of the change\nHas acceptance criteria\nIs an acceptance test\nProduces short-term results, such as cards or tasks\nProduces long-term living documentation\n\n\n184\nCHAPTER 8\nOrganizing scenarios into a specification suite\nUser stories have acceptance criteria—but executable specifications are acceptance\ntests. Obviously, without the criteria, there can be no tests—but that doesn’t mean\nexecutable specifications and user stories are the same thing. They only share some\nunderlying core similarities that spring from the fact that they’re both tools to talk\nabout requirements.\n The main difference is that user stories\nRepresent the future scope of work (see the right side of figure 8.3)\nDiscuss changes that have to be made to the system\nExpire if they stay in the product backlog too long\nWhereas, executable specifications\nRepresent the scope of the work that has been done so far (see the left side of fig-\nure 8.3)\nDiscuss the current state of the chosen part of the system\nBecome more precise as time passes, thanks to automated tests and feedback\nloops like those you saw in action throughout chapters 6 and 7\nAlthough it may have seemed at the start of the chapter that I was encouraging you to\nconsider user stories and specifications as equal, we should take a more conservative\napproach and say that new executable specifications and new scenarios are only\nderived from user stories. What I mean is that even though user stories can generate\nnew scenarios, they can also change or remove existing scenarios. A model of organi-\nzation based on user stories can’t assume a 1:1 relationship between a single story and\na single specification. Any single specification will most likely be changed by multiple\nuser stories as the product evolves. If you assume that specifications are extended sto-\nries, you’ll end up creating a false equivalence between stories and specifications. \n8.2.4\nIterative dangers of organizing scenarios by user stories\nWhy would an equivalence between stories and specifications be false? Because user\nstories are requirements—just like executable specifications are requirements—but\nuser stories are often requirements only for the current iteration.\n For example, in Scrum, the backlog holds all the user stories; at the beginning of\nevery sprint, the development team and the product owner select the user stories for\nRequirements\nFuture\nPast and current\nUser stories\nExecutable\nspecifications\nFigure 8.3\nExecutable specifications represent requirements that \nhave been implemented so far or are currently being implemented. \nUser stories represent the future scope of work and are often used \nas reminders for a future conversation about the requirement.\n",
      "page_number": 197
    },
    {
      "number": 9,
      "title": "discusses that",
      "start_page": 205,
      "end_page": 241,
      "detection_method": "regex_chapter",
      "content": "185\nOrganizing scenarios by user stories\nthe current sprint. Scrum requires the development team to deliver a fully functional\niteration of the product at the end of each sprint. So for some bigger features, you’ll\nend up simplifying the solution, only to make it more complex iteratively. A blogging\nplatform might at first introduce a full-text search that only lets readers search by title,\nand then add a capability to search by body text in the next iteration. The second\ncapability would become a separate user story, but it would still have to build on a pre-\nviously completed story. Should you create two specifications because there are two\nuser stories? Or should you treat the second story as an expansion of the first story?\nTIP\nTo those who argue that every user story must be independent—and\nthat thus you can’t have a story that builds on another story—I say you can\nimplement a title search or body search in any order, so there’s no depen-\ndency between the stories. Nonetheless, some stories inevitably build on pre-\nviously implemented solutions.\nFrom a technical point of view, a user story can only be a complete requirement when\nit introduces a brand-new capability to the system. If a user story changes an existing\ncapability, the requirement is now formed from two user stories: the one that intro-\nduced it in the past and the one modifying it right now.\n User stories don’t have to be full units of the requirements. They’re often only\nunits of change in the requirements. They’re like commits in Git or any other version\ncontrol system. Every story is a new layer of changes you introduce to the application.\nTo recreate requirements from them, you’d have to juxtapose all stories related to a\nsingle functionality chronologically and reason the final shape of the requirement\ncurrently in effect out of the changes made to the original story by newer stories.\nThat’s way too much effort.\nThinking of user stories in terms of geometry and geography\nI like thinking about user stories and executable specifications in spatial ways. A user\nstory is like a Euclidean vector: it has a direction (in which the delivery team wants to\ngo) and length (a scope estimate). A story is merely a planning tool that helps teams\norganize themselves in order to get from point A to point B. When you want to get\nfrom A to B, you know that your current plan is temporary—the same route that got\nyou from A to B won’t automatically get you from B to C, and so on.\nAn executable specification, on the other hand, is more like a two-dimensional plane.\nIt’s an overview of what the vectors created. It’s like a map that your team has\ncharted along the way during your journey. It shows your current knowledge about the\nrequirements. You’ll probably improve the map as you venture into new territories.\nBut because most of the hard work is already done, you can be more thoughtful about\nthe long term and organize the map in a way that won’t get you lost in the woods in\nthe future.\n\n\n186\nCHAPTER 8\nOrganizing scenarios into a specification suite\nThe iteration problem is why putting user stories in the specification brief is a prob-\nlematic method that I don’t advise practicing. Which of multiple user stories influenc-\ning the specification should the brief contain? All of them, in chronological order? (I\nwas surprised to learn that JBehave embraced this pattern back in the day.) How can\nyou do better than that? Here are a few thoughts:\nDon’t store user stories in specification briefs. Instead, extract desired business\noutcomes from your stories, and name specifications after the outcomes. Men-\ntion stakeholders to put actors in context.\nMake brand-new executable specifications only from user stories that imply\nbrand-new business outcomes.\nIf a user story implies a change in the behavior of an existing outcome, review\nthe existing specification to see if the new scenarios are important enough to\nwarrant a change in the contents of the Ability keyword.\nSometimes a change in behavior is so significant that adding new examples or\nscenarios isn’t enough. In this case, check whether the change results in creat-\ning a brand-new capability for an existing actor or a new actor; if the answer is\nyes, split the old ability into two new, separate specifications. \n8.3\nWhat about nonfunctional requirements?\nBy default, abilities imply capabilities of specific actors. We can say that such and such\na user should be able to do such and such a thing. But what about requirements that\ndon’t apply to particular actors? Think of security, usability, testability, maintainability,\nextensibility, scalability, and so on. Trying to specify an ability that makes sure every\nfunctionality in your system is fast could result in a feature file with hundreds of sce-\nnarios, rendering your effort to create small specifications pointless. Such require-\nments are often called nonfunctional requirements.\nDEFINITION\nNonfunctional requirement—A requirement that defines a general\nquality that the entire system must stick to horizontally\nIf you decide to use the nonfunctional terminology, you can also say that a require-\nment that defines a capability of an actor is a functional requirement.\nDEFINITION\nFunctional requirement—A requirement that defines a function of\na system as an ability to solve a problem or achieve an objective at hand\nWhereas functional requirements define the utility of a system, nonfunctional\nrequirements define its architecture. They aren’t related to any particular vertical\nfunctionality. So, if we said that a specification suite is like a map of requirements,\nshould nonfunctional requirements be on the map, too? The answer isn’t unequivo-\ncal. In this section, we’ll look at the question from two angles:\nHow to handle nonfunctional requirements according to SBE’s key patterns\nThe difficulty of writing nonfunctional requirements in Gherkin\n\n\n187\nWhat about nonfunctional requirements?\nI have to admit that conveying nonfunctional requirements in Gherkin isn’t an estab-\nlished practice. I haven’t seen any Gherkin thought leaders advising this approach.\nOther than one practical use case, which you’ll see in section 8.3.4, most of the ideas\noutlined in this case are theoretical. So if you’re only interested in learning practical\ntechniques, go straight to section 8.3.4.\n I was even advised to drop the terms functional and nonfunctional requirements,\nbecause the differences between them can cause confusion. I decided to keep the ter-\nminology intact, because I assume that many readers are already familiar with it.\nThere’s no point in pretending the terms and the controversy don’t exist. This is also\nan interesting topic to explore. With some hesitation, I decided to include it here so\nthat you can build a more complete understanding of requirements in your specifica-\ntion suites.\n8.3.1\nDealing with nonfunctional requirements according to SBE\nTeams that use SBE illustrate requirements using concrete examples to build a better\nmental model of whatever they’re about to do. Although illustrating functional\nrequirements with examples comes naturally, because each behavior needs concrete\ninputs and outputs, most people intuitively think that nonfunctional requirements\ndon’t fit this process pattern as well. For example, some nonfunctionals aren’t dis-\ncrete. Think of a fun requirement for a game: how could you specify fun?\n To illustrate nonfunctional requirements with examples, you need to adopt a\nbeginner’s mindset and stop thinking about your system, which you do when you work\nwith functionals. Instead, you should think about other systems that you know of and\ncan use as an inspiration, a standard, or a benchmark. For example, for a security\nrequirement, you could find examples of the most secure systems in your product cat-\negory and see whether you could replicate what they did. In the case of a usability\nrequirement, you could ask your UX designers to showcase some useful patterns from\nproducts they like, and UI requirements could be illustrated with low-fidelity mockups\nor interactive prototypes and animations. For a performance requirement, you could\nlook at your competitors if they’re better than you; or, if they aren’t, make a list of\nproducts from other industries that the team should look at as gold standards. And\nfinally, for the problematic fun requirement, you could find examples of game\nmechanics that you or your players enjoyed in the past.\n Unfortunately, nonfunctional requirements are usually difficult to automate,\nexcept for security tests or performance tests. (For example, performance require-\nments are usually discrete, which makes automation easier: “The system has to process\nX GB of data within Y hours on a Z hard drive.”) But lack of automation doesn’t mean\nExercise 2\nCan you identify more nonfunctional requirements?\n\n\n188\nCHAPTER 8\nOrganizing scenarios into a specification suite\nyou can’t use these examples to discuss such requirements with business stakeholders\nor during specification workshops and reap the benefits. \n8.3.2\nCan Gherkin specify nonfunctional requirements?\nThroughout the book, I’ve treated Gherkin scenarios as behavioral requirements. As\nbehaviors, scenarios should by definition be functional requirements. But the rela-\ntionship between behaviors, functional requirements, and nonfunctional require-\nments is more complicated than it may seem. For example, security requirements may\nimply a two-factor authentication function; in this case, a nonfunctional requirement\nis generating a functional requirement. And some nonfunctional requirements can\nbe phrased as behaviors, like this scenario:\nGiven a search form\nWhen the user submits a query\nThen the user should see the result in less than 100 seconds\nI’ll agree that, in this case, the nonfunctional requirement sounds like it’s being\nforced into the template. That’s because I mixed two domains—the search domain\nand the performance domain—while trying to write the scenario in the outside-in\nstyle you’ve been practicing throughout the book. Unfortunately, only the search\ndomain fits the outside-in style meant for stakeholders; the performance domain,\nwhich is the main domain of this scenario, must be written in another style. But is that\npossible? I’m playing devil’s advocate right now, but let’s think about that for a\nmoment.\n As we examined advanced techniques for writing scenarios in chapter 3, you saw\nthat every scenario must be written from the perspective of an actor. Because anything\nthat influences an action or a process taking place in the system under design can be\nan actor, three kinds of actors come to mind: stakeholders, organizations, and systems.\nAs I mentioned, scenarios in which the actor is a stakeholder are written in the\noutside-in style. But that leaves out organizations and systems.\n I’ll argue that you could rewrite the previous example scenario without using the\noutside-in style and with the system in the role of an actor. You could even use good\ntechnical practices from performance testing, such as averaging query run time to get\nbetter results. Here’s the same nonfunctional requirement written from the system’s\nperspective:\nGiven a search query\nWhen the system runs the query 100 times\nThen the average execution time should be less than 100 seconds\nThe system style matches performance much better, because they’re both technologi-\ncal at heart, whereas the outside-in style required a more empathetic approach. But\nbetter phrasing doesn’t get rid of all the issues:\nYou can’t use the Goldilocks principle (discussed in section 5.4.4) and get rid of\nthe class of equivalence from the Then step (less than 100 seconds) due to\nthe nondeterministic nature of the requirement.\n\n\n189\nWhat about nonfunctional requirements?\nThe scenario is more technical and may seem boring to nontechnical stake-\nholders. This could possibly be solved with good stakeholder management: for\nexample, you could show the system scenarios only to technical stakeholders\nwho are interested in the performance domain, and keep the outside-in scenar-\nios for the nontechnical stakeholders. It’s an interesting idea that we’ll talk\nabout in section 8.3.3.\nThe scenario only tests the average execution time of search queries, without\ntesting whether the results are rendered on the screen quickly enough.\nIf you decided to simulate a full user experience in order to test whether the\nsearch was fast enough from a user perspective, you’d need to test every screen\nwhere a user could execute a search query.\nEven though we still have many unanswered questions, let’s set them aside for a\nmoment and say that we will try to use Gherkin to specify this requirement. But how\ndo we do that?\n8.3.3\nIntroducing the Business Need keyword\nTheoretically, if you wanted to specify a nonfunctional requirement with Gherkin, you\ncould. Syntax would be problematic, though. Keywords like Feature and Ability\nseem out of place. Performance isn’t a feature. It could be an ability, but that would\nsound as phony as the initial scenario that mixed the empathetic outside-in style with\nthe technical performance domain. Fortunately, Gherkin has a third keyword that’s\nsimilar to these two: Business Need. Here’s how it looks in practice:\nBusiness Need: Performance\nLike abilities, business needs don’t influence the automation layer, and you store\nthem in files with the .feature extension. Here’s the search scenario, phrased as a busi-\nness need.\nBusiness Need: Performance\nScenario: Searches must run faster than 100 seconds\nGiven a search query\nWhen the system runs the query 100 times\nThen the average execution time should be less than 100 seconds\nAdding business needs to figure 8.1, which outlined the structure of functional abili-\nties, yields the diagram shown in figure 8.4.\nListing 8.7\nPerformance requirement phrased as a business need\nAbilities\nRequirements\nStakeholder\nOutcomes\nBusiness needs\nQuality measures\nFigure 8.4\nRequirements in a \nspecification suite. Abilities specify \nfunctional requirements, and \nbusiness needs specify \nnonfunctionals. Instead of \nstakeholders and outcomes, \nbusiness needs talk about required \nquality measures.\n\n\n190\nCHAPTER 8\nOrganizing scenarios into a specification suite\nFigure 8.5 shows the example specification suite when it includes the business need\nfor performance.\n Impatient readers may say that dedicating an entire section to the mostly theoreti-\ncal concept of business needs in Gherkin was extravagant. They’re probably right—\nbut I had an ulterior motive, which I’ll reveal in the next section. In my opinion, if a\nspecification suite were to truly become a map of requirements for an entire product,\nit would have to include nonfunctional requirements. And in some cases, it can do so\nmore easily than in our previous problematic example. \n8.3.4\nUsing the Business Need keyword to identify new stakeholders\nAs I said at the beginning of section 8.3.2, the relationship between functional and\nnonfunctional requirements is more complicated than it seems at first. I used the\nexample of a security requirement that might imply a two-factor authentication func-\ntion to show that, sometimes, nonfunctional requirements create functions and\nbehaviors that can be described in Gherkin—and even in the outside-in style. We’ll now\nexamine such situations in depth. When do they occur? And are there consequences\nyou should be aware of?\nMEETING THE CHAMPIONS BEHIND REQUIREMENTS\nTo keep things simple, we’ll stay in the security domain introduced by the two-factor\nauthentication example. But to discuss the issue fully, we’ll need something more: a\nstory.\n Let’s say it’s Monday, and you’re at the weekly status meeting where you discuss the\nstories your Activitee team chose to implement during this iteration. The product\nowner unexpectedly adds a new story to this week’s backlog. The story is about making\npasswords in the system more secure. The team decides that the simplest way to\nachieve results this week, given the team’s current capacity, is to force users to create\npasswords that are harder to crack.\n Together, the team creates a list of acceptance criteria for new passwords:\nPasswords should have a minimum of eight characters.\nDon’t use repetitive or sequential characters.\nUsernames, first names, surnames, and so on shouldn’t qualify as passwords.\nThe team then collects a list of examples and drafts a scenario that checks whether\neach example is strong enough to pass the security measures. A few weeks ago, the\nmanaging employees.feature\nHR\nAbilities\nperformance.feature\nBusiness needs\nFeatures\nFigure 8.5\nA specification suite \norganized according to figure 8.4\n\n\n191\nWhat about nonfunctional requirements?\nteam would probably have added this scenario to an existing feature file connected to\naccount management; but let’s say you’ve just read the first half of this chapter and\nknow that Gherkin specifications can be organized as requirements and that non-\nfunctional requirements, such as security, can be specified using the Business Need\nkeyword.\nBusiness Need: Security\nScenario Outline: Passwords should be secure\nGiven Simona has to set a password\nWhen she tries to set the password to <password>\nThen the password should be considered <secure>\nExamples: Too short\n| password | secure\n|\n| shorty\n| insecure |\nExamples: No repetitive or sequential characters\n| password | secure\n|\n| aaaaaaaa | insecure |\nExamples: No usernames, first names, or surnames\n| password\n| secure\n|\n| simonajenkins | insecure |\nExamples: Good password\n| password\n| secure\n|\n| nevergonnagiveyouup | secure\n|\nIt’s a classic case of a functional behavior that the end user can interact with. To make\nthe examples easy to read, you put them in a scenario outline. Each acceptance crite-\nrion has its own table—isn’t that what you’d do with any other requirement? In a way,\nthis is a standard Gherkin specification. But if you remember that it was created from\na nonfunctional requirement, some interesting questions appear. For example, what\nprompted the security requirement to emerge in the first place? (Yes, I know. I, too,\nam sure that a real-world delivery team would ask this question before writing the speci-\nfication. I admit that I structured the story so I could ask the question dramatically\nnow. Sorry about that!) In a software development agency, the request for the security\nrequirement would come from the clients—but who or what planted it in their heads\nin the first place? The same goes for in-house teams, where the requirement might be\nhanded off to the product owner by someone from management.\n Requirements listed as nonfunctional usually imply that there’s a stakeholder\nwhom the team hasn’t yet explicitly identified. For example, the company might have\nhired a chief security officer, who, unbeknownst to the team, ordered a security audit.\nThe request for stronger passwords may be only the first step, if the functional behav-\nior for forcing stronger passwords was just the easiest fix on the CSIO’s list. In that\ncase, you can assume that more security requirements will emerge in the future.\nListing 8.8\nBusiness need for security\n\n\n192\nCHAPTER 8\nOrganizing scenarios into a specification suite\n Another reason for the security requirement to appear might be that the company\nsigned a contract with an enterprise client that cares about security. Some stakehold-\ners work behind the scenes for a long time and become more active only when an\nissue that interests them is on the table—they’re identified when new nonfunctional\nrequirements crop up, seemingly out of nowhere. Even if business needs can’t create a\ncomplete map of nonfunctionals, you can use them to mark potentially dangerous\nareas from which you suspect new stakeholders may emerge.\nAPPLYING A FRAMEWORK TO WORK WITH BUSINESS NEEDS OVER TIME\nI suggest the following simple framework to work with requirements like those just\ndiscussed:\nInclude nonfunctional requirements in the specification suite if they can be\nspecified as functional behaviors, such as a two-factor authentication scenario\nin a security requirement.\nMark nonfunctional requirements as business needs with general names such\nas Security, Usability, and so on.\nLet each business need grow naturally by adding new functional scenarios over\ntime.\nIf one of the business needs grows too large and has too many functional\naspects, consider splitting it into several smaller abilities. By now, you should\nhave enough functional scenarios to justify doing so.\n– If you haven’t already, work to identify the stakeholder behind the business\nneed that had to be split, and try to include that stakeholder in your software\ndevelopment process.\n– Having identified the stakeholder, move the acquired abilities under the abil-\nities filesystem tree.\nYou’ll see this framework work in practice in chapter 9.\nExercise 3\nThink of some other examples of behavioral functions that could be derived from non-\nfunctional requirements. You can use the requirements you prepared in exercise 2.\nExercise 4\nAdd a two-factor authentication scenario to the business need for security as another\nquality measure.\n\n\n193\nAnswers to exercises\n8.4\nAnswers to exercises\nEXERCISE 1\nMake a [BAD] specification a [GOOD] one by rewriting the Feature line\nfrom listing 8.6 into an ability with a clear outcome and a stakeholder:\nAbility: Employees can find events by using advanced search filters\nEXERCISE 2\nCan you identify more nonfunctional requirements?\nTestability\nMaintainability\nExtensibility\nScalability\nReporting\nEXERCISE 3\nThink of some other examples of behavioral functions that could be\nderived from nonfunctional requirements. You can use the requirements you pre-\npared in exercise 2:\nA nonfunctional reporting requirement can imply functions such as generating reports,\ndownloading reports, archiving reports, and so on.\nEXERCISE 4\nAdd a two-factor authentication scenario to the business need for secu-\nrity as another quality measure:\nScenario Outline: Use two-factor authentication for more security\nGiven <authentication> for Simona\nAnd Simona's desire to log in\nWhen she provides her username\nAnd she provides her password\nAnd she enters <code>\nThen she should be <authenticated>\nExamples: Two-factor authentication\n| authentication\n| code\n| authenticated |\n| two-factor auth\n| the correct code | logged in\n|\n| two-factor auth\n| the wrong code\n| not logged in |\nExamples: Make sure single-factor authentication still works\n| authentication\n| code\n| authenticated |\n| traditional auth | no code | logged in\n|\nExercise 5\nSplit the business need for security into two abilities: one for secure passwords, and\nanother for two-factor authentication. \n\n\n194\nCHAPTER 8\nOrganizing scenarios into a specification suite\nEXERCISE 5\nSplit the business need for security into two abilities: one for secure pass-\nwords, and another for two-factor authentication:\nAbility: Users can secure their account with strong passwords\nScenario Outline: Passwords should be secure\nGiven Simona has to set a password\nWhen she tries to set the password to <password>\nThen the password should be considered <secure>\n[...]\nAbility: Users can turn two-factor authentication on for more security\nScenario Outline: Use two-factor authentication\nGiven <authentication> for Simona\nAnd Simona's desire to log in\nWhen she provides her username\nAnd she provides her password\nAnd she enters <code>\nThen she should be <authenticated>\n[...]\n8.5\nSummary\nCucumber organizes Gherkin scenarios into specifications through feature\nfiles.\nEven though the default way to organize scenarios in Cucumber-flavored Gher-\nkin is through the Feature keyword, features are difficult to organize consis-\ntently because anything can be a feature.\nTesting tools like JBehave use user stories to organize scenarios; but more often,\nexecutable specifications are only derived from user stories, because they can not\nonly add, but also change or remove existing scenarios.\nIf you don’t use user stories, you can organize your scenarios by any other kind\nof functional requirement.\nA functional requirement defines a function of a system as an ability to solve a\nproblem or achieve an objective at hand.\nYou can specify user stories or functional requirements as abilities of particular\nstakeholders.\nBe careful with user stories that are iterative!\nNonfunctional requirements define general qualities that the entire system\nmust stick to, such as security, usability, and testability.\nYou can specify nonfunctional requirements as business needs that define par-\nticular quality measures.\nSome nonfunctional requirements can imply functionality.\nRequirements listed as nonfunctional usually imply that there’s a stakeholder\nwhom the team hasn’t yet explicitly identified.\n\n\n195\nRefactoring features into\nabilities and business needs\nThis is the second chapter in a four-chapter series about managing large specifica-\ntion suites. Chapter 8 focused on organizing scenarios into specifications, discuss-\ning the optimal length of an average executable specification and the theoretical\naspects of deciding to put a scenario into one specification or another. In this chap-\nter, we’ll put the theory into practice by refactoring larger executable specifications\ninto smaller ones that will be easier to manage.\n We’ll continue to work with Activitee, an online platform for Fortune 500 com-\npanies that want to improve employee engagement. Chapter 8 introduced two new\ntypes of executable specifications: abilities and business needs. They replaced the\nFeature keyword because they’re easier to organize. But it’s one thing to know a\nThis chapter covers\nManaging functional and nonfunctional \nrequirements\nRefactoring features into abilities\nRecognizing and refactoring business needs\nIdentifying new stakeholders with business needs\n\n\n196\nCHAPTER 9\nRefactoring features into abilities and business needs\ntheory and another to apply it in practice. In this chapter, we’ll deal with two core\naspects of the Activitee experience—events and application security—in order to\ndetermine which is an ability and which is a business need.\n9.1\nAnalyzing user stories: a practical example\nBefore you can talk about abilities and business needs, you need to learn about the\nrequirements in question. This section looks at two Activitee teams who are getting to\nknow the scope of work ahead of them. Imagine that the two teams have just finished\ntheir previous iterations. They’re ready to take two new user stories from the top of\ntheir backlog, which has recently been prioritized by Activitee’s product management.\n The first team—which I’ll refer to from this point on as the events team—will work\non a user story connected with Activitee’s core value proposition: organizing and man-\naging events. The user story introduces a new capability for team leaders to create\nevents with an attendance fee:\nIn order to organize informal company outings online\nAs a team leader\nI want to create events that let people pay for attendance on Activitee\nThe use case for paid events is to let team leaders organize informal team outings\nwithout involving the entire HR department. The team may just want to go bowling\nafter work—and Activitee should let employees organize and pay for the event up\nfront online. Section 9.2 covers the actions of the events team.\n The second team, which I’ll call the application security team, will work on a user\nstory that deals with security:\nIn order to meet my company's security policy\nAs a Fortune 500 company employee\nI want to increase my account security\nAs of this moment, the team doesn’t have a lot of information about this story, which\npopped up in the backlog recently and was quickly prioritized to the top. Activitee’s\nprimary clients—Fortune 500 companies with thousands of employees—always have\ntheir own security policies. It makes sense that Activitee should work on its security\nmeasures in order to meet their standards; but right now, the team has to wait to see\nwhat kind of solution will be required. We’ll look at that in section 9.3.\n As the teams talk about requirements with relevant stakeholders and draft new\nGherkin scenarios in response, they must determine what kinds of requirements\nthey’re dealing with. Chapter 8 provided frameworks for working with two types of\nrequirements in Gherkin: defining system functions using abilities, and using business\nneeds to define functional aspects of general system qualities like security and perfor-\nmance. You may already suspect which keyword will help with which Activitee user story. \n9.2\nRefactoring features into abilities\nLet’s examine how the events team works with the user story about paid events. The\nstory introduces a new capability for team leaders to create events with an attendance\n\n\n197\nRefactoring features into abilities\nfee. It’s fitting, then, to suspect that the team will use the Ability keyword to define\nsuch a requirement.\n Throughout the rest of this section, you’ll see the challenges of organizing func-\ntional scenarios over time, how they can accumulate into executable specifications\nthat are too long to manage without significant effort, and what steps are necessary to\nbreak such specifications into smaller parts. As you’ll see, we can’t talk about these\nissues without touching on the topic of the legacy Feature keyword, too—but let’s not\nget ahead of ourselves just yet.\n9.2.1\nDeriving new scenarios from user stories\nIn the case of the events team, finding relevant stakeholders and discussing the user\nstory with them isn’t difficult. Most of Activitee’s HR and team leadership use the com-\npany’s own product. The team gathers a few team leaders in a conference room, and\ntogether they come up with a scenario that they think will satisfy both their own needs\nand the needs of their clients.\nScenario: Users should be able to pay for events online\nGiven an event created by team lead Mike for his team:\n| name\n|\n| 2nd Bowling Night |\nAnd an attendance fee of $25 set by the team lead\nWhen Jane pays for the event online\nThen she should become a confirmed attendee\nActivitee’s specification suite has grown significantly since the company adopted SBE\nand Gherkin. So, the team must decide where to put this new scenario. \n9.2.2\nStarting with simple features\nAfter reading the previous paragraph, you’ve probably thought about finding an exist-\ning ability or creating a new one. But remember that when teams begin using Gher-\nkin, they almost always define new system functions using the Feature keyword, which\nis Cucumber-flavored Gherkin’s default way of defining requirements. Activitee’s very\nfirst executable specification is no different (see the following listing).\nFeature: Creating events\nScenario: HR admins should be able to create company events\nGiven a Fortune 500 company like Coca-Cola\nAnd James, an HR admin in that company\nWhen James organizes a company-wide event:\n| name\n| date\n| time\n|\n| Annual staff picnic | 10-03-2017 | 10 AM |\nThen the employees in other departments should be notified\nListing 9.1\nEvents team: scenario derived from the user story\nListing 9.2\nActivitee’s first executable specification\n\n\n198\nCHAPTER 9\nRefactoring features into abilities and business needs\nAs it happens, the current events team is the same team who worked on this scenario,\nback when Activitee was still striving to launch its product. They imagine that their\nnew scenario will seamlessly fit into what they remember as a one-scenario feature\nabout the catchall topic of creating events. We’ll soon see if they’re right. \n9.2.3\nAdding scenarios over time\nThe event system lies at the heart of Activitee’s value proposition. Over time, multiple\nteams have been tasked with delivering new functionalities in the events space. They\ntook artistic license with the initially simple feature by adding new scenarios as they\nsaw fit. The word feature is an umbrella term, so anything can be a feature—if a ham-\nmer is the only tool you have, everything looks like a nail.\n The current events team is surprised by how many different scenarios have been\nadded. You can imagine the questions that pop into their heads when they read the\nlatest version of the specification (shown in the following listing): How are these sce-\nnarios related? What’s going on? Will we break anything?\nFeature: Creating events\nScenario: HR admins should be able to create company events\nGiven a Fortune 500 company like Coca-Cola\nAnd James, an HR admin in that company\nWhen James organizes a company-wide event:\n| name\n| date\n| time\n|\n| Annual staff picnic | 10-03-2017 | 10 AM |\nThen the employees in other departments should be notified\nScenario Outline: Managing invited participants\nGiven James drafted a new event\nWhen he invites <invitee>\nThen only <invitee> should be notified about the invite\nBut <uninvited> should not be notified\nExamples: Invites to one-on-one events such as annual reviews\n| invitee | uninvited |\n| Simona\n| Jane\n|\nExamples: Invites to local events in specific locations\n| invitee\n| uninvited\n|\n| Atlanta employees | New York employees |\nExamples: Inviting one department, but not the other (all locations)\n| invitee\n| uninvited\n|\n| engineers | salespeople |\nExamples: Inviting a specific department from a specific location\n| invitee\n| uninvited\n|\n| Atlanta engineers | New York engineers, salespeople |\nScenario Outline: Managing simple events and serial events\nListing 9.3\n[BAD] Feature with loosely related scenarios added over time\nBasic success\nscenario for\ncreating company-\nwide events\nScenario outline that \ndeals with managing \nparticipants\nScenarios\nthat deal\nwith time\nand date\nmanagement\n\n\n199\nRefactoring features into abilities\nGiven a company-wide event called <name>\nAnd that it takes place <date> at <time>\nWhen Simona wants to attend the event\nThen she should get a reminder <date> before <time>\nExamples:\n| name\n| date\n| time\n|\n| Annual staff picnic | on 10-03-2017 | 10 AM |\n| Yoga classes\n| every Monday\n| 10 AM |\nScenario Outline: Managing scheduling conflicts for company-wide events\nGiven a company-wide event created by James:\n| name\n| date\n| time\n|\n| Annual staff picnic | 10-03-2017 | 10 AM |\nAnd that Terry wants to organize another company-wide event:\n| name\n| date\n| time\n|\n| The Move with Purpose Marathon | 10-03-2017 | 10 AM |\nWhen Terry does <action> that the scheduling conflict is OK\nThen the event should be <result>\nAnd the employees in other departments should get <email>\nExamples:\n| action\n| result\n| email\n|\n| confirm\n| published\n| a notification\n|\n| not confirm | not published | no notification |\nScenario: Managing scheduling conflicts for local events\nEvents from local branches shouldn't cause conflicts.\nGiven an Atlanta event created by James:\n| name\n| date\n| time\n|\n| Local staff picnic | 10-03-2017 | 10 AM |\nWhen Terry wants to organize another event in New York:\n| name\n| date\n| time\n|\n| The Move with Purpose Marathon | 10-03-2017 | 10 AM |\nThen the event should be successfully published\nAnd the employees in other departments should be notified\nNOTE\nDon’t worry about the details of these scenarios right now. We’ll dis-\ncuss them at length soon.\nThis specification has 10 examples in a single file that spans more than 75 lines of\ntext! These examples cover three important areas of implementation:\nCreating and scheduling events—The first scenario introduces the concept of\ncompany-wide events that are visible to all employees.\nManaging participants by location and department—These four scenarios discuss\nevents that are either local or limited to particular departments or specific\nemployees.\nManaging participants by date and time—These three scenarios introduce the\nthird type of events, serial events, which can take place in multiple time slots\n(think of yoga classes that take place over several months).\nScenarios that deal\nwith time and date\nmanagement\nScenarios \nthat deal \nwith time \nand date \nmanagement\n\n\n200\nCHAPTER 9\nRefactoring features into abilities and business needs\nAdding the scenario about paid events would enlarge the text to 6 scenarios and 84\nlines, talking about 4 loosely connected areas of implementation. Given that an aver-\nage scenario in this feature file has about 10 lines of text, adding just 2 more scenarios\nto each of these 4 areas would result in 80 additional lines, making the entire specifi-\ncation 164 lines long. Early reviewers of this book shared that the specification suites\nthey encounter in their environments often deal with hundreds or even thousands of\nscenarios! There is a dire need for a more granular organization system.\n When the Activitee events team tries to fit the new scenario into this overgrown\nfeature, they come to the same conclusion. Fortunately, while they searching for a\ngood solution, they stumble on the Ability keyword and decide to break their huge\nfeature into several smaller abilities. \n9.2.4\nSplitting huge features into small abilities\nThe events team choose to split their feature according to the four areas of implemen-\ntation specified in the previous section. This decision is driven by the fact that they\nwere able to track the source of each area to a different user story in the archives of\ntheir backlog—just as we did back in section 8.2.1.\nSPLITTING SCENARIOS BETWEEN ABILITIES\nThe first ability created by the Activitee team deals with company-wide events and the\nbasic success scenario for creating events.\nAbility: HR reps can organize their wellness programs through online events\nScenario: HR admins should be able to create company events\nGiven a Fortune 500 company like Coca-Cola\nAnd James, an HR admin in that company\nWhen James organizes a company-wide event:\n| name\n| date\n| time\n|\n| Annual staff picnic | 10-03-2017 | 10 AM |\nThen the employees in other departments should be notified\nThis ability shows the basic flow of events being created and scheduled for entire com-\npanies by HR departments, which are Activitee’s primary users. You can expect that\nthe behaviors and examples from this ability will always be required to create the most\nbasic type of event on the Activitee platform.\n Soon after, the Activitee events team prepares the second ability for the user story that\nstarted the rewriting process in the first place: the paid informal events functionality.\nAbility: Team leads can facilitate teamwork by organizing team outings online\nScenario: Users should be able to pay for events online\nGiven an event created by team lead Mike for his team:\nListing 9.4\n[GOOD] Ability allowing HR reps to create company-wide events\nListing 9.5\n[GOOD] Ability that lets team leaders create paid informal events\n\n\n201\nRefactoring features into abilities\n| name\n|\n| 2nd Bowling Night |\nAnd an attendance fee of $25 set by the team lead\nWhen Jane pays for the event online\nThen she should become a confirmed attendee\nOnce the events team deals with the newest user story, they can move on to reorganize\nthe other requirements that have been added to the specification by different teams\nover time. They start with the scenarios that specify managing and inviting partici-\npants (see listing 9.6). There are four use cases:\nInviting selected individuals\nInviting all people from a specific location\nInviting all people from a specific department\nInviting all people from a specific department in a specific location\nAll of these scenarios deal with targeting. HR representatives want to target different\nevents to different people. They don’t want people from Atlanta to see events that are\norganized for the New York branch. They also know from experience that engineers may\nbe interested in different after-work activities than employees in the sales department.\nAbility: HR reps can target wellness programs by choosing specific audiences\nScenario Outline: Managing invited participants\nGiven James drafted a new event\nWhen he invites <invitee>\nThen only <invitee> should be notified about the invite\nBut <uninvited> should not be notified\nExamples: Invites to one-on-one events such as annual reviews\n| invitee | uninvited |\n| Simona\n| Jane\n|\nExamples: Invites to local events in specific locations\n| invitee\n| uninvited\n|\n| Atlanta employees | New York employees |\nExamples: Inviting one department, but not the other (all locations)\n| invitee\n| uninvited\n|\n| engineers | salespeople |\nExamples: Inviting a specific department from a specific location\n| invitee\n| uninvited\n|\n| Atlanta engineers | New York engineers, salespeople |\nThe remaining three scenarios are related to scheduling issues, so the events team\ndecides to group them together under managing the company’s event calendar.\nListing 9.6\n[GOOD] Ability for targeting event programs\n\n\n202\nCHAPTER 9\nRefactoring features into abilities and business needs\n \nAbility: HR reps can manage their wellness program's calendar by scheduling events\nScenario Outline: Managing simple events and serial events\nGiven a company-wide event called <name>\nAnd that it takes place <date> at <time>\nWhen Simona wants to attend the event\nThen she should get a reminder <date> before <time>\nExamples:\n| name\n| date\n| time\n|\n| Annual staff picnic | on 10-03-2017 | 10 AM |\n| Yoga classes\n| every Monday\n| 10 AM |\nScenario Outline: Managing scheduling conflicts for company-wide events\nGiven a company-wide event created by James:\n| name\n| date\n| time\n|\n| Annual staff picnic | 10-03-2017 | 10 AM |\nAnd that Terry wants to organize another company-wide event:\n| name\n| date\n| time\n|\n| The Move with Purpose Marathon | 10-03-2017 | 10 AM |\nWhen Terry does <action> that the scheduling conflict is OK\nThen the event should be <result>\nAnd the employees in other departments should get <email>\nExamples:\n| action\n| result\n| email\n|\n| confirm\n| published\n| a notification\n|\n| not confirm | not published | no notification |\nScenario: Managing scheduling conflicts for local events\nEvents from local branches shouldn't cause conflicts.\nGiven an Atlanta event created by James:\n| name\n| date\n| time\n|\n| Local staff picnic | 10-03-2017 | 10 AM |\nWhen Terry wants to organize another event in New York:\n| name\n| date\n| time\n|\n| The Move with Purpose Marathon | 10-03-2017 | 10 AM |\nThen the event should be successfully published\nAnd the employees in other departments should be notified\nThe events team ends up with four small specifications split from a single long one.\nEach of the four new feature files deals with a specific area of implementation. Being\nsmaller, they’re also easier to comprehend, and they can be expanded in the future\nwithout losing their readability. The team also splits the scenarios among the stake-\nholders that are relevant to their content. Under the previous system, the feature\ntalked about events created by both HR representatives and individual team leaders.\nNow, each stakeholder has their own specification with their own scenarios.\nListing 9.7\n[GOOD] Ability for managing the event calendar\n\n\n203\nRecognizing and refactoring business needs\nMANAGING THE HIERARCHY OF FEATURE FILES IN THE SPECIFICATION SUITE\nThe last thing we need to discuss before moving on to the second Activitee team is the\nhierarchy of feature files in the specification suite created as a result of the changes\nmade to the suite in this section. In chapter 8, we established a hierarchy of feature\nfiles for abilities (see figure 9.1).\nThe events team uses that hierarchy to organize the four new executable specifica-\ntions (see figure 9.2). They end up with a specification suite organized by abilities and\nstakeholders. Each stakeholder can achieve different outcomes valuable to them.\nThus, the specification suite is now organized as a map of Activitee clients and the\nvalue the company delivers. As you’ll learn in section 9.3, the system is also flexible\nand can be easily expanded to fit other requirements, such as functional aspects of\nnonfunctional requirements.   \n9.3\nRecognizing and refactoring business needs\nNow, let’s move on to the application security team, who take on the user story about\nsecurity:\nIn order to meet my company's security policy\nAs a Fortune 500 company employee\nI want to make sure only I can access my account\nThis section focuses on specifying the functional aspects of the nonfunctional security\nrequirement using the Business Need keyword. You’ll also see how a business need\nAbility\nStakeholder\nOutcome\nFigure 9.1\nThe progression indicates hierarchy. At the \ntop is the Ability keyword, which creates a space for \nuser stories in the specification suite. Next are different \nstakeholders. At the bottom are outcomes that \nstakeholders can achieve.\nHR\nevents.feature\nscheduling.feature\ntargeting.feature\nAbilities\nFeatures\noutings.feature\nTeam leads\nFigure 9.2\nA specification suite \norganized according to abilities of \nstakeholders such as HR \nadministrators and team leads\n\n\n204\nCHAPTER 9\nRefactoring features into abilities and business needs\ncan grow in size over time and how to react when that happens, by slicing the specifi-\ncation into smaller abilities—similar to what the events team did in section 9.2.\n The goal of the application security team is to find and implement solutions that\ncould increase the security of the Activitee platform according to industry standards.\nThey didn’t have to start from scratch. You may remember the business need shown in\nthe following listing, which you wrote for Activitee in chapter 8. An Activitee product\nowner unexpectedly added to the backlog a new story about making passwords in the\nsystem more secure. The team decided that the simplest way to achieve results quickly,\ngiven Activitee’s current capacity, would be to force users to create passwords that are\nharder to crack:\nBusiness Need: Security\nScenario Outline: Passwords should be secure\nGiven Simona has to set a password\nWhen she tries to set the password to <password>\nThen the password should be considered <secure>\nExamples: Too short\n| password | secure\n|\n| shorty\n| insecure |\nExamples: No repetitive or sequential characters\n| password | secure\n|\n| aaaaaaaa | insecure |\nExamples: No usernames, first names, or surnames\n| password\n| secure\n|\n| simonajenkins | insecure |\nExamples: Good password\n| password\n| secure\n|\n| nevergonnagiveyouup | secure\n|\nThe password scenario looked like a good starting point. But the new user story\nimplied a larger scope than just passwords. In order to decide on the most suitable\nsolution, the team needed to understand the broader context of how the new story\nappeared in the backlog in the first place.\n9.3.1\nAdding functional scenarios to business needs\nA quick investigation by the Activitee team determined the origin of the new security\nrequirement. Activitee is a technology platform, and it works best with technologically\nsavvy companies—but most of its early clients were less technologically oriented and\nhad never used software for employee wellness. Such clients were easier to capture,\nbut they also paid less and required more customer service. Most of Activitee’s target\ncustomers already use some kind of wellness program. Activitee, as a new player on\nthe market, had to catch up to its competitors.\n When asked about the security requirement, the sales team confirmed that the\ncompany had reached the point that it could successfully compete with existing\n\n\n205\nRecognizing and refactoring business needs\nemployee wellness solutions, and that the sales team had entered into contract negoti-\nations with some desirable potential clients. But seducing technologically oriented\ncustomers meant the product would have to excel in areas where nontechnical clients\nwere more forgiving—such as application security.\n The application security team was pleasantly surprised to hear from the sales team\nthat at this stage in the negotiations, the business value could be brought by preparing\na few security scenarios showing that Activitee had something in the works. Enterprise\nsales often take months to close, so the team would have lots of time to implement the\nsolutions they would suggest. Saying they were working on something and actually\ndoing it wouldn’t make much of a difference—the sales representatives just wanted a\nfew scenarios to discuss during their sales pitches. Questions about security were pop-\nping up more often, and they needed some leverage. They said that an upcoming\nmeeting with a potential client would be a good opportunity to try the scenarios.\n The application security team decided to add new functional scenarios to the exist-\ning security business need. The first scenario was simple and was requested by the\nteam’s UX designer, who wanted to improve the experience of choosing a strong\nenough password by adding a password strength meter. The designer had wanted to\naddress this omission for a long time, but there was always something more important.\nThe team agreed that they could include it in the scope this time. The scenario out-\nline was as follows.\nScenario Outline: Users should be able to see a password strength meter\nGiven Simona has to set a password\nWhen she tries to set the password to <password>\nThen Simona should see that her password is <strength>\nExamples: Short passwords\n| password | strength |\n| shorty\n| weak\n|\nExamples: Longer passwords that are common dictionary words\n| password\n| strength |\n| imagination | medium\n|\n| countryside | medium\n|\n| inimitable | medium\n|\nExamples: Long, non-obvious passwords\n| password\n| strength |\n| nevergonnagiveyouup | strong\n|\nThe next scenario was suggested by the technical team. Increasingly, two-factor\nauthentication is required for both enterprise-oriented and customer-oriented appli-\ncations. The two-factor authentication the team agreed on would involve entering a\ncombination of a password and a random code sent over SMS.\nListing 9.8\nScenario outline for a password strength meter\n\n\n206\nCHAPTER 9\nRefactoring features into abilities and business needs\n \nScenario Outline: Users should be able to use two-factor authentication\nGiven <authentication> for Simona\nAnd Simona's desire to log in\nWhen she provides her username\nAnd she provides her password\nAnd she enters <code>\nThen she should be <authenticated>\nExamples: Two-factor authentication\n| authentication\n| code\n| authenticated |\n| two-factor auth\n| the correct code | logged in\n|\n| two-factor auth\n| a wrong code\n| not logged in |\nExamples: Make sure single-factor authentication still works\n| authentication\n| code\n| authenticated |\n| traditional auth | no code | logged in\n|\nThe third scenario the team decided to suggest was another industry standard: a\nreviewable login history. With a login history, a user would be able to see where and\nwhen their account was recently used. The team used a simple example of a hacker\nfrom a distant location who somehow got access to the account of an unlucky Activitee\nuser. They also suggested that the user should be able to log out from all devices\nremotely in case of a security breach.\nScenario Outline: Users should be able to review their login history\nGiven Simona's previous logins were from <country>\nWhen somebody logs in to her account from <login>\nThen her account should be considered <compromised>\nAnd Simona should be notified about the security breach\nExamples:\n| country | login\n| compromised |\n| the USA | the USA | secure\n|\n| the USA | the UK\n| compromised |\n| the UK\n| the UK\n| secure\n|\n| the UK\n| the USA | compromised |\nScenario: Users should be able to log out remotely\nGiven Simona was notified about the security breach\nWhen she confirms her identity via two-factor authentication\nThen she should be able to log herself out from all devices remotely\nThe team was happy with the scenarios they prepared. But when the sales representa-\ntives came back from the meeting with the prospective client, they didn’t mention the\nscenarios. They were confused and had only one question: what is SSO, and why don’t\nwe have it?\n We’ll address that question in the next section. \nListing 9.9\nScenario outline to introduce two-factor authentication\nListing 9.10\nScenarios for a login history\n\n\n207\nRecognizing and refactoring business needs\n9.3.2\nIdentifying new stakeholders with business needs\nIn chapter 8, I said that requirements listed as nonfunctional and defined as business\nneeds usually imply that there’s a stakeholder the team hasn’t yet explicitly identified.\nFor example, some stakeholders work behind the scenes and become more active only\nif an issue that interests them is on the table. Such stakeholders can be identified\nwhen new nonfunctional requirements appear, seemingly out of nowhere.\n It turns out this was exactly what happened during the sales meeting that confused\nActivitee’s representatives. The prospective client was interested in security because it\nhad a very active Chief Information Security Officer who was responsible for the com-\npany’s IT and computer systems. The CISO was involved in the process from the get-\ngo, which was something Activitee’s reps hadn’t seen in less technologically savvy com-\npanies. The CISO turned out to be a competent, demanding stakeholder who was the\nultimate decision maker but worked behind the scenes, leaving the negotiations to\nanother executive. But as Activitee reps kept coming back with proposals that weren’t\nsatisfying, the CISO decided to become personally involved.\n During the meeting, the CISO took for granted the scenarios presented by Activi-\ntee’s sales team, which meant they officially became part of the future scope and not\njust proposals, as they were first pitched. Moreover, the CISO wanted Activitee to satisfy\nanother requirement: that’s right, the SSO thing.\nDEFINITION\nSingle sign-on—A session- and user-authentication service that\npermits a user to use one set of login credentials (such as username and pass-\nword) to access multiple applications\nSSO stands for single-sign on. You use consumer-facing versions of SSO every time you\nuse Facebook or Twitter to sign up on a website. In such cases, Facebook and Twitter\nplay the role of identity providers that manage aspects of your accounts. For example,\na website can ask the identity provider for your real name or profile picture and\nupdate it if you changed it on Facebook or Twitter.\n Enterprises need SSO because every day their employees use dozens of applica-\ntions to get the job done. I myself have mostly worked at small-to-medium agencies\nand startups, but even there I used 20 or 30 apps to manage my work—without SSO. It\nwas a pain. For companies with thousands of employees, the pain must be a thousand\ntimes stronger. Enterprise identity providers like okta.com can help teams alleviate\nthe pain and manage their application stack.\n Having investigated the topic, the application security team came up with a few\nnew scenarios to make the business need for security more complete.\nScenario: CISOs should be able to have the IT Security team set SSO up\nGiven a valid SSO API endpoint provided by an IT Security team\nAnd a client ID\nAnd a client secret\nListing 9.11\nSSO scenarios\n\n\n208\nCHAPTER 9\nRefactoring features into abilities and business needs\nAnd a callback URL\nWhen IT Security team activates SSO\nThen the company's Activitee should start pointing to the Identity Provider\nScenario: SSO-enabled users should be authenticated and let in\nGiven an SSO-enabled company\nAnd James, an employee who's logged in to the Identity Provider's system\nWhen he doesn't re-enter his credentials on Activitee when he logs in\nThen he should still be authenticated and let in\nScenario: A company deactivates SSO\nGiven an SSO-enabled company\nWhen their CISO decides to disable SSO\nThen the employees need to enter credentials in order to get in\nThe scenarios require the IT security team to point Activitee’s software toward a work-\ning API endpoint that gives the user account information Activitee needs after identity\nconfirmation. The security team also provides a client ID and a client secret, which the\nidentity provider uses to select the correct company’s user base. A callback URL is then\nrequired to redirect the user back to Activitee. The third new scenario deals with a\ncompany that decides to stop using a given SSO provider; in this case, Activitee must\nforce employees to generate new passwords, because the Activitee platform didn’t\nstore them (the SSO provider did).\n The overarching lesson here is that the Activitee team could have reacted more\nquickly to the fact that a new business need emerged and became increasingly\ndemanding. Had they done so, they would have understood much earlier that there\nwas a stakeholder they hadn’t identified who was working behind the scenes, influenc-\ning their results. If they had talked to that stakeholder directly in the first place, they\nwould have been able to present a scope that was smaller and tailored to the CISO’s\nneeds from the outset. Instead, they ended up committing to scenarios they thought\nwere only proposals—and also had to implement three new SSO-related scenarios. In\nthe end, it was all an issue of stakeholder management. \n9.3.3\nRefactoring functional scenarios in business \nneeds into individual abilities\nSo far, all the security-related scenarios are in a single business need. Figure 9.3 shows\nthe specification suite.\n Although Activitee’s business need started as a simple feature file with a single sce-\nnario, it’s now vastly different. After all the iterations, there are eight different scenarios\nrelated to various areas of the product, such as passwords, two-factor authentication,\nand SSO integration. Now that we know CISOs are important stakeholders with their\nown requests, we suspect that the number of scenarios will keep growing—which means\nit’s time to break the business need into several smaller abilities that will grow inde-\npendently in the future.\n Let’s start with the SSO scenarios, because they’re distinct from the scenarios pre-\npared by the application security team and will be the easiest to extract. Extracting\n\n\n209\nRecognizing and refactoring business needs\nthese SSO scenarios lets us add a specification brief with a lexical definition—just like\nyou practiced doing in chapter 7.\nAbility: CISOs can manage employees easily by integrating with an SSO provider\nSINGLE SIGN-ON (SSO) is a session and user authentication service\nthat permits a user to use one set of login credentials\n(e.g., name and password) to access multiple applications.\nBig companies with hundreds of employees find it hard to manage\nemployees' data across many different internal services while adhering\nto internal security or privacy policies (e.g. some organizations\nchange employees' passwords once a month because of security issues).\nSome might want to implement a custom registration process due\nto legal reasons. All of them will eventually part ways with some of\ntheir employees and will have to make sure that these ex-employees'\nprivate data is deleted across all of the internal services.\nScenario: CISOs should be able to have the IT Security team set SSO up\nGiven a valid SSO API endpoint provided by an IT Security team\nAnd a client ID\nAnd a client secret\nAnd a callback URL\nWhen IT Security team activates SSO\nThen the company's Activitee should start pointing to the Identity Provider\nScenario: SSO-enabled users should be authenticated and let in\nGiven an SSO-enabled company\nAnd James, an employee who's logged in to the Identity Provider's system\nWhen he doesn't re-enter his credentials on Activitee when he logs in\nThen he should still be authenticated and let in\nListing 9.12\nSSO ability broken up from the previous business need\nHR\nevents.feature\nscheduling.feature\ntargeting.feature\nAbilities\nFeatures\nBusiness needs\noutings.feature\nsecurity.feature\nTeam leads\nFigure 9.3\nA specification suite \nwith both abilities and business \nneeds becomes a map of functional \nrequirements and stakeholders \nwho find them important, as well as \nfunctional aspects of nonfunctional \nrequirements important to the \nentire system.\n\n\n210\nCHAPTER 9\nRefactoring features into abilities and business needs\nScenario: A company deactivates SSO\nGiven an SSO-enabled company\nWhen their CISO decides to disable SSO\nThen the employees need to enter credentials in order to get in\nThe application security team also decides to extract the password-strength scenarios\ninto their own ability.\nAbility: Employees can secure their passwords\nScenario Outline: Passwords should be secure\nGiven Simona has to set a password\nWhen she tries to set the password to <password>\nThen the password should be considered <secure>\nExamples: Too short\n| password | secure\n|\n| shorty\n| insecure |\nExamples: No repetitive or sequential characters\n| password | secure\n|\n| aaaaaaaa | insecure |\nExamples: No usernames, first names, or surnames\n| password\n| secure\n|\n| simonajenkins | insecure |\nExamples: Good password\n| password\n| secure\n|\n| nevergonnagiveyouup | secure\n|\nScenario Outline: Users should be able to see a password strength meter\nGiven Simona has to set a password\nWhen she tries to set the password to <password>\nThen Simona should see that her password is <strength>\nExamples: Short passwords\n| password | strength |\n| shorty\n| weak\n|\nExamples: Longer passwords that are common dictionary words\n| password\n| strength |\n| imagination | medium\n|\n| imagination | medium\n|\n| imagination | medium\n|\nExamples: Long, non-obvious passwords\n| password\n| strength |\n| nevergonnagiveyouup | strong\n|\nThe only scenarios that remain in the security business need deal with employees\nauthenticating themselves and managing their identity.\nListing 9.13\nPassword-strength ability\n\n\n211\nRecognizing and refactoring business needs\n \nAbility: Employees can authenticate and manage their identity\nScenario Outline: Users should be able to use two-factor authentication\nGiven <authentication> for Simona\nAnd Simona's desire to log in\nWhen she provides her username\nAnd she provides her password\nAnd she enters <code>\nThen she should be <authenticated>\nExamples: Two-factor authentication\n| authentication\n| code\n| authenticated |\n| two-factor auth\n| the correct code | logged in\n|\n| two-factor auth\n| a wrong code\n| not logged in |\nExamples: Make sure single-factor authentication still works\n| authentication\n| code\n| authenticated |\n| traditional auth | no code | logged in\n|\nScenario Outline: Users should be able to review their login history\nGiven Simona's previous logins were from <country>\nWhen somebody logs in to her account from <login>\nThen her account should be considered <compromised>\nAnd Simona should be notified about the security breach\nExamples:\n| country | login\n| compromised |\n| the USA | the USA | secure\n|\n| the USA | the UK\n| compromised |\n| the UK\n| the UK\n| secure\n|\n| the UK\n| the USA | compromised |\nScenario: Users should be able to log out remotely\nGiven Simona was notified about the security breach\nWhen she confirms her identity via two-factor authentication\nThen she should be able to log herself out from all devices remotely\nWe have three more feature files than we started with, but the upside is that the appli-\ncation security team will be able to grow each area of implementation independently\nin the future. You can also see that each of the specifications we ended up with has two\nor three tightly connected scenarios instead of eight scenarios that try to specify the\nsecurity aspect holistically within a single business need.\n It’s not that the previous business need was bad; it just outgrew its purpose. Busi-\nness needs are used to identify areas where new stakeholders may potentially emerge.\nAs soon as that happens, you can begin working with the stakeholders to develop their\nareas of interest—and abilities are much better for doing that (see figure 9.4).\nListing 9.14\nAbility for employee authentication and identity management\n\n\n212\nCHAPTER 9\nRefactoring features into abilities and business needs\n    \n9.4\nSummary\nYou can convey your requirements as abilities or business needs when deriving\nthem from user stories.\nAdding too many new scenarios to existing executable specifications makes\nthem cover too many topics at once.\nTo avoid covering too many topics, refactor large specifications into smaller\nones.\nEven though many teams use the Feature keyword at the beginning of their\nGherkin journey, they should consider switching to abilities and business needs\nlater on.\nYou can refactor existing features into smaller abilities by splitting the scenarios\njust like the user stories from which they were derived.\nSpecify functional aspects of nonfunctional requirements like security using\nbusiness needs.\nNew business needs usually imply that there’s a stakeholder whom the team\nhasn’t yet explicitly identified.\nWhen a business need grows into having too many functional scenarios, you can\nmove each function to its own ability.\nEmployees\nauthentication.feature\npasswords.feature\nAbilities\nFeatures\nsso.feature\nCISO\nHR\nevents.feature\nscheduling.feature\ntargeting.feature\noutings.feature\nTeam leads\nFigure 9.4\nThe specification \nsuite with new security \nstakeholders, such as CISOs, and \nnew security abilities, such as \nauthentication, which were \nbroken out from a prior business \nneed when it had too many \nfunctional aspects to keep in a \nsingle feature file\n\n\n213\nBuilding a domain-driven\nspecification suite\nThis is the third chapter in a four-chapter series about managing large specification\nsuites. Chapters 8 and 9 discussed actors and using their abilities and business\nneeds as replacements for the Feature keyword. In this chapter, we’ll analyze what\nhappens when actors have too many scenarios and another level of hierarchy is\nneeded—which usually happens in medium-sized projects.\n Figure 10.1 shows a specification suite for the fictional company Activitee of\nchapters 8–11. We built most of this suite in chapters 8 and 9; the figure presents a\nslightly expanded version, after the product has grown into a medium-sized pro-\nject. We’ll talk about the new specifications in section 10.3.\nThis chapter covers\nRecognizing good domain models\nAnalyzing a ubiquitous language\nDistilling business domains from scenarios\nRecognizing different kinds of business domains\nOrganizing a specification suite according to \navailable domains\n\n\n214\nCHAPTER 10\nBuilding a domain-driven specification suite\nCISO\nHR\nauthentication.feature\nevents.feature\ninterest groups.feature\nsso.feature\nnews feed.feature\npasswords.feature\nprofile.feature\nredeeming bonuses.feature\nsearch.feature\ngranting bonuses.feature\noutings.feature\nkpi.feature\nevents.feature\ninviting employees.feature\nkpi.feature\nmanaging employees.feature\nonboarding employees.feature\norganization structure.feature\nrewards program.feature\ntargeting.feature\nperformance.feature\nEmployees\nAbilities\nFeatures\nBusiness needs\nTeam leads\nFigure 10.1\nActors in medium-sized projects can have too many abilities, which makes the \nspecification suite more difficult to understand.\n\n\n215\nDistilling business domains from a ubiquitous language\nBefore writing this chapter, I looked at some of the real projects I’ve worked on over\nthe last few years. In one of these projects, a specification suite with about 60 scenarios\nhad 380 steps spread between two actors. If you had such a project, then assuming\nevery feature file had about three scenarios, as I advised in chapter 8, you’d end up\nwith about 20 feature files in the suite—10 per actor. A slightly bigger project of mine\nhad 170 scenarios written for 4 actors, 1,120 steps, and about 60 feature files—15 per\nactor. In such cases, a simple split between actors’ abilities and the system’s business\nneeds, introduced in chapter 8, may not be enough. We’re approaching a similar\nthreshold with the Activitee specification suite.\n The concepts we’ll be using to manipulate and comprehend these large domains\ncome from the field of domain-driven design (DDD). This chapter and the next one\nwill rely heavily on ideas borrowed from DDD. You may be familiar with DDD; I first\nmentioned it in chapter 1 when I talked about ubiquitous languages in specifications.\nIn this chapter, we’ll discuss domains—subdomains, core domains, secondary\ndomains, and generic domains—as well as domain models, a ubiquitous language,\nglossaries, bounded contexts, and context maps. This chapter is be a high-level sum-\nmary of the most important concepts of strategic domain-driven design and shows how\nyou can use these techniques in designing your specification suites.\n You’ll begin by distilling business domains from a ubiquitous language. Then,\nyou’ll use the distilled domain to build a domain model. Finally, you’ll reorganize a\nlarge specification suite according to that model, grouping similar feature files\ntogether. Some of these methods were discussed earlier in the book; for example, I\ntalked about a ubiquitous language in various parts of chapters 1, 2, 5, and 7. Chapter\n7, which discussed living documentation, also talked about creating glossaries. We’ll\nnow revisit these concepts in the context of DDD and also introduce new ideas. Keep\nin mind that this chapter is by no means a full introduction to DDD. If interested, you\ncan read more in Eric Evans’ canonical work on the topic: Domain-Driven Design (Addi-\nson-Wesley, 2003). In this case, just as in Evans’ book, everything starts with a ubiqui-\ntous language.\n10.1\nDistilling business domains from \na ubiquitous language\nA ubiquitous language, first mentioned in section 1.2.2, is a language cultivated in the\nintersection of technical and business jargons, derived from multiple sources (see fig-\nure 10.2). Each project has its own ubiquitous language. It’s not the language of the\nbusiness, nor is it the language of technology. It’s a mix of both.\n Domain experts—people with authority in a particular area or topic—have different\ndesign jargons. Technology experts—such as designers, testers, analysts, and engi-\nneers—also have their own jargons. Design jargon is just as bad as technical jargon.\nWhen bankers talk too much about their work, they can be as annoying at the dinner\ntables as programmers, designers, or testers—and they can be just as difficult to under-\nstand for a layperson inexperienced in their domain. The narrower the business\n\n\n216\nCHAPTER 10\nBuilding a domain-driven specification suite\ndomain of a project, the more difficult the language seems to outsiders. But most peo-\nple can understand the consumer-facing aspects of businesses. Pop culture can help,\ntoo: for example, movies about Wall Street have helped people understand basic\nfinance keywords such as shorting, popularized by the 2015 movie The Big Short; and ini-\ntial public offering (IPO), depicted in the critically acclaimed The Wolf of Wall Street in 2013.\n Businesses like Activitee aren’t likely to receive that type of publicity. So, a ubiqui-\ntous language must grow out of blending technological expertise with business exper-\ntise in reasonable proportions. This section explores how you can analyze a\nubiquitous language to derive a model of the business domains used in a specification\nsuite. Deriving the model is the first step in getting to the end goal: creating a proper\nsystem for organizing large specification suites according to the business domain.\n Before we continue our work on Activitee’s specification suite, let’s analyze a sim-\npler example.\n10.1.1 Spotting different domains in your scenarios\nUbiquitous language lies at the heart of DDD. Gherkin scenarios can be a great source\nof a ubiquitous language, because each scenario is a recording of a conversation that\nbusiness experts had with technology experts about requirements. If the recording is\ntruthful, the scenario should easily capture a ubiquitous language that the experts cre-\nated during their conversations, both face-to-face and in writing.\n Naturally, a raw record won’t be perfect. Let’s say you’re sitting in a specification\nworkshop for a simple cloud storage service similar to Dropbox, Google Drive, Apple\niCloud, or Microsoft OneDrive. A domain expert is explaining a behavior, and you’re\nwriting it down as a Gherkin draft. The following record ends up on the whiteboard.\nGiven a 2 GB limit on free cloud drive accounts\nAnd 2 GB of files on Simona's free cloud drive account\nWhen she upgrades to the premium plan\nListing 10.1\nConversation recorded as a Gherkin scenario\nDomain\nexperts\nUbiquitous\nlanguage\nDocumentation\nDelivery\nteam\nSpecifications\nConversations\nTesting code\nApplication\ncode\nFigure 10.2\nThe sources of a ubiquitous \nlanguage—a language that’s created by \nmixing the jargons of technology and \nbusiness in order to build a unified lingual \nmodel that can be used by both the domain \nexperts and the technology experts\n\n\n217\nDistilling business domains from a ubiquitous language\nThen her credit card should be charged $5\nAnd her storage should be upgraded to a 40 GB limit\nIt’s a good enough draft—at least for the brainstorming stage. But if you look at the\nscenario more closely, you’ll see that it introduces terms from several domains into a\nubiquitous language for the team:\nTerms like cloud drive are from the cloud domain.\nGigabytes, files, and storage are from the more general storage domain, which,\nnonetheless, must stay connected to the cloud domain.\nTerms like premium plan, free, and credit card are from the payments domain, also\ncalled the commercial offering domain, which all nonfree products share.\nTIP\nChapter 7 discussed which elements of Gherkin scenarios are important\nparts of a ubiquitous language. They’re elements such as actors, states, out-\ncomes, domain concepts, and actions.\nWe can easily illustrate how different domains map onto the scenario, as shown in fig-\nure 10.3. Notice that some of the domains don’t have to be tightly coupled. For exam-\nple, the payments domain doesn’t have to be connected so closely to the storage\ndomain. Upgrading an account to the premium plan will also make available other,\nnonstorage features, such as team collaboration—so maybe you should look for a\nmore general way to specify the details of the business model. But that doesn’t mean\nyou can uncouple all domains. The storage domain, for example, often remains con-\nnected to the cloud domain, because there can be no cloud storage without having\nstorage in the first place.\n \nGiven a 2 GB limit on free cloud drive accounts\nAnd 2 GB of files on Simona's free cloud drive account\nWhen she upgrades to the premium plan\nThen her credit card should be charged $5\nAnd her storage should be upgraded to a 40 GB limit\nCloud domain\nStorage domain\nPayments domain\nFigure 10.3\nDifferent domains can appear in a single scenario, depending \non how you formulate the behavior using a ubiquitous language.\nExercise 1\nChoose one state, one action, and one outcome from listing 10.1, and assign a\ndomain to each one. If you notice multiple domains in any of the steps, decide which\ndomain should be the most important in this step.\n\n\n218\nCHAPTER 10\nBuilding a domain-driven specification suite\n10.1.2 Distilling the core domain from scenarios\nDomain design, like any other design, is an art of trade-offs. We can clearly see that\nthe domains in listing 10.1 aren’t equal. Delivering products and services is a complex\nendeavor that requires many different activities coordinated among many diverse\ndepartments. Some domains are inherently more important than others, and some\nare more generic than others. This is natural. Your task is to untangle and prioritize\ndomains so that you can decide which ones to focus on. DDD calls such a prioritization\nprocess distillation.\nDEFINITION\nDistillation—A procedure whereby the components of a mixture\nare separated in order to extract the various ingredients, particularly the most\nvaluable one: the heart of the distillate\nWhat should you do about all the different domains in a scenario?\nListing 10.1 presents a scenario that contains multiple subdomains. Should you\nleave it that way or refine it?\nYou faced a similar dilemma in section 3.3.4, which talked about a technique called\noutcome questioning. This technique requires you to ask, “Is there another outcome\nthat also matters but isn’t included in the scenario?” When you asked that question\nin chapter 3, you found another outcome—but it belonged to a completely different\nbusiness domain!\nYou’re facing a similar problem here. In fact, I based this example on the example\nfrom section 3.3.4, with some modifications. You can see the similarities if you com-\npare listing 10.1 with the scenario from chapter 3, repeated here:\nScenario: Upgrading cloud plans\nGiven a 50 MB limit on Vladimir's cloud drive\nAnd 50 MB of text documents on Vladimir's cloud drive\nWhen Vladimir tries to save a new revision in the cloud\nThen he should be upgraded to a plan with more space\nAnd his credit card should be charged $5\nIn the suggested answer to the exercise, which asked you to consider whether the\noutcomes from different domains that appeared back in chapter 3 should be sepa-\nrated, I wrote that, in my opinion, you should specify cloud functionality and paid plan\nlimits separately. I stand by this opinion.\nThe cloud and storage domains can stay together because they’re closely related, but\nthe payments domain should be specified elsewhere in the specification suite. You\ncould, for example, reword the scenario in terms of dealing only with remaining free\nspace on a user’s cloud drive and block the user’s ability to upload new files. Then,\nin a separate specification, you could have all the scenarios that deal with premium\naccounts and payments. Among them, you’d be able to include a scenario to specify\nhow much disk space free and premium accounts have. \n\n\n219\nDistilling business domains from a ubiquitous language\nIn the case of the storage service, if you were to distill the business into the several\ndomains mentioned in section 10.1.1, the cloud domain would clearly be the heart of\nthe distillate. In other words, the cloud domain is the core domain.\nDEFINITION\nCore domain—A domain most closely associated with the strategy\nand market positioning of a company. It’s a domain of the utmost value.\nA competitive company must excel at its core domain. The cloud storage company in\nthe example must excel at the cloud domain if it wants to deliver enough value to its\ncustomers in this crowded market. By distilling the core domain, you can understand\nwhich scenarios and domain concepts are the heart of your software system and there-\nfore should be more important than others. \n10.1.3 Distilling subdomains accompanying the core domain\nIn addition to the core cloud domain, the example company distills into two other\ndomains: storage and payments. If the core domain is the most important domain,\nthen, by definition, you can have only one core domain. What are the other domains?\nThey’re subdomains: domains other than the core domain, which aren’t at the heart of\nthe company but are nonetheless necessary to sustain its strategic mission.\n To understand the concept of subdomains more easily, look at your own life. We all\nhave something important at the center of our lives. For some people, it’s family. For\nother people, it’s a passionate interest. This is a core domain. Although you know that\nit matters to you above all else, you know that a full human life has other, less important\naspects, too, which support your well-being. Work is a good example. Other aspects are\nmore mundane—like going shopping and paying taxes. They’re the remaining sub-\ndomains of your life.\nSUPPORTING SUBDOMAINS\nLet’s get back to the storage service. If you were to point out the domain that’s next-\nmost-important after the core domain, you’d probably choose the storage subdo-\nmain. Cloud storage obviously differs from physical storage, but the company needs\nsome classic storage expertise, too, to become a viable player in the cloud industry.\nThis is why domains like the storage domain from the example are called supporting\nsubdomains.\nDEFINITION\nSupporting subdomain—A domain that indirectly supports the\ncore domain without belonging to it. Even though only one domain can lie at\nthe heart of a company, each core domain needs subdomains to support its\nstrategic mission.\nA company doesn’t have to excel at its supporting subdomains. The value of support-\ning domains, in isolation, is weak. You just have be good enough not to fall too far\nbehind the competition. In the example, storage is a well-penetrated area with multi-\nple industry standards and established solutions that we don’t have to develop on our\nown. The company doesn’t have to drive innovation in this subdomain. You only\n\n\n220\nCHAPTER 10\nBuilding a domain-driven specification suite\nneed to make sure it works at a standard level that customers have learned to gener-\nally accept.\n By distilling supporting subdomains, you learn which domain concepts should be\ntaken care of after you deal with your core domain. Learning that is important\nbecause it lets you allocate appropriate resources to the supporting subdomains and,\ntherefore, avoid over- and underinvestments.\nGENERIC SUBDOMAINS\nThe payments domain is also a subdomain—but it’s different than storage. Storage is\nat least thematically related to the core domain. The payments domain is, in this case,\na generic domain, like authentication or account management. It’s like paying taxes\nin my earlier metaphor comparing subdomains to areas of life.\n Such domains are required for the software to function, but they don’t come from\nor influence the core domain. This is why we call such domains generic subdomains.\nDEFINITION\nGeneric subdomain—A universal subdomain that can appear in\nany kind of software and includes standardized solutions such as account\nmanagement and support functionalities. Whereas supporting subdomains\nsupport the core domain without belonging to it, generic subdomains don’t\nhave to be related to the core domain; they’re meant to increase utility and\nmake basic services work.\nSome other classic examples are accounting, human resources, and project manage-\nment. Some technical solutions, such as search, can also be generic subdomains.\nGeneric subdomains are usually the least important subdomains in terms of market\ncompetition—I’ve never heard of anyone choosing a product or a service because of its\ngreat payments system. Still, generic subdomains are essential and can’t be ignored. For\nexample, you instinctively know that you can’t ignore the payments subdomain—but at\nthe same time, you could delegate it or even outsource it to a third-party service.\nExercise 2\nThink of one more supporting subdomain that could be relevant to the cloud storage\nservice.\nExercise 3\nCan you think of another generic subdomain?\n\n\n221\nCreating a domain model from distilled domains\n10.2\nCreating a domain model from distilled domains\nTogether, the core domain and the subdomains, distilled from a ubiquitous language,\ncreate a domain model. Chapter 1 said that a domain model is a simplification of the\nreal-world business domain—an interpretation of reality that abstracts only the\naspects relevant to solving the problem at hand.\n Better models help you solve problems more reliably and easily. If you can not only\norganize scenarios by requirements, as you did in chapter 8, but also organize require-\nments by their corresponding domains, then you can build better domain models—which,\nin turn, will help you maintain and organize large enterprise systems and start har-\nnessing DDD’s benefits. In this section, you’ll prepare to create a domain model from\nthe subdomains distilled from the ubiquitous language. We’ll look at why good mod-\nels are important and what makes a good model.\n10.2.1 The domain model and the specification suite\nHere’s a quick example of how you can organize the requirements in a specification\nsuite by their corresponding domains, thus creating a visual representation of the\ndomain model included in that specification suite. This example is also based on the\ncloud storage service, to maintain continuity.\n Let’s assume that the distillation process is finished, and you’ve extracted all the rel-\nevant subdomains. You end up with a complete list of actors and their abilities, pre-\npared based on the practices covered in chapter 8, as well as several business needs that\nspecify a few functional aspects of your nonfunctional requirements (see figure 10.4).\n As you can see, the abilities—or functional requirements—in the system are orga-\nnized by their corresponding subdomains. (I added a new generic subdomain for\naccess control to make the specification suite a little more complex.) Now, even if a\nsingle actor has multiple capabilities, you can split all of them among various subdo-\nmains. You can also see which actors are present in which subdomains, which will help\nyou understand which subdomains are important to which stakeholders. In addition,\nyou can make an inverse deduction: you’re able to see which stakeholders can be\ninstrumental in developing the subdomains. Also notice that you haven’t done any-\nthing with business needs; they’re nonfunctional requirements, and nonfunctionals\nare general qualities like speed or usability—they belong to the entire system instead\nof specific subdomains.\n Such a specification suite can become a visual representation of the domain model\nspecified by this suite. You can see a clear hierarchy of subdomains, actors, and\nrequirements. Moreover, a representation like this can evolve naturally over time,\nbecause the requirements are tied to the domain logic code by the automated tests. If\nyou change the requirements or change the domain logic, you’ll probably need to\nadd, delete, or move the feature files related to the changed requirements—and your\nvisualization of the model will change alongside the model.\n",
      "page_number": 205
    },
    {
      "number": 10,
      "title": "Building a domain-driven specification suite",
      "start_page": 242,
      "end_page": 261,
      "detection_method": "regex_chapter",
      "content": "222\nCHAPTER 10\nBuilding a domain-driven specification suite\n10.2.2 Why are good domain models important?\nNow that you know how to create a simple domain model based on a ubiquitous lan-\nguage, we can discuss why good models are important. In chapter 1, you learned that\n80% of all product defects are inserted when delivery teams define their require-\nments. If you look at each requirement as a problem to solve on behalf of your cus-\ntomers, you can assume that building better domain models will result in fewer\nmisunderstood requirements. To build a realistic model of your business domain, you\nAccess\ncontrol\n[Some feature files]\n[Some feature files]\n[Some feature files]\n[Some feature files]\nPayments\n[Some feature files]\nCloud\nAdmins\nManagers\nGuests\nEmployees\nAdmins\nAdmins\nEmployees\n[Some feature files]\n[Some feature files]\nAbilities\nFeatures\nBusiness\nneeds\n[Some feature files]\nStorage\nActors in subdomains\nA generic subdomain\nThe core domain\nA generic subdomain\nFunctional\nrequirements\nNonfunctional\nrequirements\nA supporting\nsubdomain\nFigure 10.4\nA specification suite organized by the subdomains present in the suite. Each \nsubdomain features a list of actors relevant to this subdomain. Every actor can have various \ncapabilities in each of the subdomains.\n\n\n223\nCreating a domain model from distilled domains\nmust not only understand particular requirements, but also understand how they\nrelate to each other.\n Maps can help. Maps often show how we think about the world around us. When\nthe model depicted in a map is wrong, the decisions made based on the incorrect map\nare more likely to be wrong, too. By more likely, I mean that you won’t necessarily be\nwrong every time you use a wrong model—but you’ll increase the long-term risk factor of\nbeing wrong. Let me explain what I mean.\n The geocentric map of the solar system, also called the Ptolemaic model, depicted\na universe where the sun, moon, stars, and planets all circled Earth. The geocentric\nmodel was eventually replaced by the heliocentric model, including Copernican helio-\ncentrism. But the Ptolemaic model was good enough for scientists to successfully per-\nform many calculations. Both the Copernican and Ptolemaic models provided\nidentical results for identical inputs. Only after Kepler demonstrated that the sun is\ndirectly involved in determining a planet’s orbit was a new model required. If you\nabstain from talking about the real world for a moment, the geocentric model is only\nwrong when you go deep into the details.\n At times, something similar happens with software. I’ve seen projects that didn’t\ncare much about mapping the business domain but that still delivered working soft-\nware, even though it was based on imperfect models. Some of these projects worked\nwell enough for a long time because they were all the business owners needed. Good\nfor them. But other projects turned out to be unmaintainable in the long term and\nfailed spectacularly when the teams tried to modify the scope by adding new require-\nments or expanding existing capabilities. Every time, it was a truly Copernican\nmoment, in the sense that finding out a Ptolemaic model is wrong is usually very pain-\nful—and very expensive. \nWhy organize specification suites by subdomains?\nAn early reviewer of this book asked the following question:\nThe book talks about the idea of organizing specifications by domains. Fine, but\nwhy not organize them by actors instead?\nIt’s an interesting question. Chapter 8 left you with a simpler organization system\nthat had actors at the top. Why should you now adopt a different system, with busi-\nness domains at a higher level of the hierarchy?\nThe reason is that actors and stakeholders don’t always define business domains,\nbut business domains always define the stakeholders and actors. Business value is\nalways dictated by the core domain. For example, a banking company will only hire\nbanking personnel—the actors are derived from the business domain. The ubiquitous\nlanguage, too, is created out of particular domains: you aren’t interested in the way\ndomain experts talk, but rather in their subject-matter expertise. \n\n\n224\nCHAPTER 10\nBuilding a domain-driven specification suite\n10.2.3 What makes a good domain model in software?\nBad models lead you to make wrong decisions. Good models, on the other hand, have\nthese characteristics:\nAccurate enough to find a good solution to a problem\nUnified, as in “the model is internally consistent”\nStable in finding good solutions over time\nRealistic and empirically based on the real world\nAttributes such as accuracy are easy to accept. But some attributes are more controversial.\n If a good model has to be stable, should you advocate iterative software develop-\nment? Throughout the book, I’ve talked about the process of discovering require-\nments and refining models over time. Discovering requirements sounds fine, but what\nif your discoveries lead you to a painful Copernican moment, as described in the pre-\nvious section?\n Just as software development can be iterative, so can science. New theories replace\nold theories and tend to be better. The same is true with software development. New\ndomain models tend to be better than old models. The challenging issue is how to\nmanage the transition risk between the old and new models. The risk is lowered if the\ntransition is small and the model improves iteratively over small batches of changes.\nThe risk is also reduced if the model is strengthened by automated tests. In general,\ntests make a model stronger because automation ensures that you’re tying the model\ndirectly to code, which creates powerful feedback loops between changes in the\nmodel and changes in the code. (Feedback loops were discussed in chapter 6.) SBE\nand Gherkin, as explained in this book, employ both of these practices.\n Feedback loops help with unification of the model, too. When a model is fre-\nquently validated by automated tests, you can be sure that it’s internally consistent to\nthe level covered by the tests. \n10.3\nBuilding a domain-driven specification suite \nin practice\nWe can now get back to the Activitee example. In this section, we’ll derive domains\nfrom a few of the specifications created for Activitee in the previous chapters. We’ll do\nthe same for a few new specifications shown in figure 10.1, when we were imagining\nwhat a medium-sized suite could look like in Activitee’s case. Thanks to the distillation\nprocess, you’ll be able to add another layer to your suite-building skills as we organize\nActivitee’s specifications and actors by their subdomains. The new layer should result\nin something we’ll call a domain-driven specification suite.\nDEFINITION\nDomain-driven specification suite—A specification suite organized\naccording to its various domains. Domain-driven suites are easier to manage\nwhen you have too many actors or when actors have too many abilities.\n\n\n225\nBuilding a domain-driven specification suite in practice\n10.3.1 Distilling subdomains from unequivocal scenarios\nLet’s begin with an easy, unequivocal example. Back in chapter 9, we wrote the follow-\ning ability, which specifies how employees can authenticate and manage their identity\non the Activitee platform.\nAbility: Employees can authenticate and manage their identity\nScenario Outline: Users should be able to use two-factor authentication\nGiven <authentication> for Simona\nAnd Simona's desire to log in\nWhen she provides her username\nAnd she provides her password\nAnd she enters <code>\nThen she should be <authenticated>\nExamples: Two-factor authentication\n| authentication\n| code\n| authenticated |\n| two-factor auth\n| the correct code | logged in\n|\n| two-factor auth\n| a wrong code\n| not logged in |\nExamples: Make sure single-factor authentication still works\n| authentication\n| code\n| authenticated |\n| traditional auth | no code | logged in\n|\nScenario Outline: Users should be able to review their login history\nGiven Simona's previous logins were from <country>\nWhen somebody logs in to her account from <login>\nThen her account should be considered <compromised>\nAnd Simona should be notified about the security breach\nExamples:\n| country | login\n| compromised |\n| the USA | the USA | secure\n|\n| the USA | the UK\n| compromised |\n| the UK\n| the UK\n| secure\n|\n| the UK\n| the USA | compromised |\nScenario: Users should be able to log out remotely\nGiven Simona was notified about the security breach\nWhen she confirms her identity via two-factor authentication\nThen she should be able to log herself out from all devices remotely\nThe three scenarios are very focused. They talk about one thing, and one thing only:\nsecurity (see table 10.1). Their business context explains that; they were created when\nActivitee signed a new client that had an active Chief Information Security Officer\nresponsible for its IT and computer systems.\nListing 10.2\nfeatures/abilities/security/employees/authentication.feature\n\n\n226\nCHAPTER 10\nBuilding a domain-driven specification suite\n \nSpecifications like this are easy to analyze, because they’re unequivocal. You can derive\nthe domain easily, because the scenarios talk about a single topic. If all Gherkin speci-\nfications maintained this one-to-one relationship between scenarios and domains, our\njob in this section would almost be done. Unfortunately, as you saw in figure 10.3, and\nas you’ll see in the sections to come, reality isn’t always organized so neatly. \n10.3.2 Distilling subdomains from mixed scenarios\nSecurity wasn’t the only topic covered in chapter 9. You also prepared specifications\nthat allowed HR representatives to target programs to specific audiences.\nAbility: HR reps can target wellness programs by choosing specific audiences\nScenario Outline: Managing invited participants\nGiven James drafted a new event\nWhen he invites <invitee>\nThen only <invitee> should be notified about the invite\nBut <uninvited> should not be notified\nExamples: Invites to one-on-one events such as annual reviews\n| invitee | uninvited |\n| Simona\n| Jane\n|\nExamples: Invites to local events in specific locations\n| invitee\n| uninvited\n|\n| Atlanta employees | New York employees |\nExamples: Inviting one department, but not the other (all locations)\n| invitee\n| uninvited\n|\n| engineers | salespeople |\nExamples: Inviting a specific department from a specific location\n| invitee\n| uninvited\n|\n| Atlanta engineers | New York engineers, salespeople |\nThe language in the four scenarios from listing 10.3 isn’t as unequivocal as in the pre-\nvious specification (see table 10.2). At least two domains can be derived from the new\nsteps. Some domain concepts refer to the events domain, others to the domain of\norganization.\n If we only wanted to analyze the ubiquitous language of the specification suite, say-\ning that there are two distinct domains at play would be fine. The problem is that we\nwant to organize the suite by its domains. Because the file system is a hierarchical\nstructure, we can only assign the feature file that includes the ability from listing 10.4\nTable 10.1\nDomain in listing 10.3\nDomain\nUbiquitous language\nSecurity\nAuthentication, two-factor authentication, password, compro-\nmised account, secure, security breach, identity, remote logout\nListing 10.3\nfeatures/abilities/events/HR/targeting.feature\n\n\n227\nBuilding a domain-driven specification suite in practice\nto a single domain (if we want various directories to represent various domains).\nThat’s why we have to choose between the two domains we just distilled.\n We can make the choice based on multiple approaches:\nTreat the core domain as more important than other subdomains. In Activitee’s case,\nthe events domain clearly is the core domain. The downside of this approach is\nthat the core domain will always take precedence in every scenario it appears\nin—which isn’t something we want, because most scenarios have to deal with\nthe core domain in one way or another.\nCount the domain concepts (terms) in each domain, and assume that the more popular\ndomain is also more important. The first downside is that we have no guidelines for\ndealing with draws (ties). The second downside is that some domains will be\nmore popular only because they’re more generic than others or because they\nhave more nonfunctional aspects, making it easier for them to spread horizon-\ntally across the suite.\nCombine the two previous approaches in an attempt to calculate the relative weight of each\ndomain. This approach acknowledges that some domains (such as the core\ndomain) are inherently more important than others. But it also acknowledges\nthat domains with more domain concepts can, in some cases, be even more\nessential than the core domain.\nTable 10.2 shows that the specification from listing 10.4 is close to a draw, with a 5-4\nresult. We can assume that the distilled domains are almost equally important to the\ndistillate. Personally, I recommend choosing the events domain, because the scenarios\nonly talk about managing participants, and the core domain can take precedence in\nthis case.\n Next, let’s talk about an example where the opposite is true. In chapter 8, we pre-\npared a specification similar to the one from listing 10.4. It said that employees should\nonly see Activitee content that’s relevant to them—and that relevancy should be calcu-\nlated based on their branches and departments.\nAbility: Employees can see content they like in the news feeds for their branches\nScenario Outline: Employees should only see content relevant to them\nGiven <person> from <branch> who works in <department>\nWhen <person> looks at the company dashboard on Activitee\nThen <person> should see <type> <content>\nTable 10.2\nDomains in listing 10.4\nDomain\nUbiquitous language\nEvents\nEvent, draft, invite, participants, annual review\nOrganization\nEmployee, team, location, department\nListing 10.4\nfeatures/abilities/organization/employees/news feed.feature\n\n\n228\nCHAPTER 10\nBuilding a domain-driven specification suite\nExamples: Employees should see after-work content only from their location\n| person | branch\n| department\n| type\n| content |\n| Jane\n| New York | Engineering | New York after-work\n| events\n|\n| Mike\n| New York | HR\n| New York after-work\n| posts\n|\n| Tom\n| Atlanta\n| Sales\n| Atlanta after-work\n| events\n|\n| Ramona | Atlanta\n| Engineering | Atlanta after-work\n| posts\n|\nExamples: Employees should see work-related content from all locations\n| person | branch\n| department\n| type\n| content |\n| Mike\n| New York | HR\n| Atlanta HR\n| events\n|\n| Jane\n| New York | Engineering | Atlanta engineering\n| posts\n|\n| Jane\n| New York | Engineering | New York engineering | events\n|\n| Tom\n| Atlanta\n| Sales\n| Atlanta sales\n| events\n|\n| Ramona | Atlanta\n| Engineering | Atlanta engineering\n| posts\n|\n| Ramona | Atlanta\n| Engineering | New York engineering | events\n|\nNOTE\nI counted posts as part of the organization subdomain because Activi-\ntee’s news feed treats posts as pieces of content published in various interest\ngroups. Groups belong to the organization domain.\nIf you look at table 10.3, you’ll see that listing 10.5 is the opposite of listing 10.4. It’s\nclose to a draw again—but this time, it’s a 3-5 result in favor of the organization subdo-\nmain. This, together with the fact that the examples talk not only about events but also\nabout posts in interest groups, impels me to recommend adding this specification to\nthe organization subdomain.\n10.3.3 Distilling subdomains from other scenarios\nWe now have three domains with at least one scenario assigned: security, events, and\norganization. We can use the same decision-making framework for other specifica-\ntions in the suite, so we won’t focus as much on the distillation process as in the previ-\nous examples. Instead, we’ll look at examples that introduce new subdomains, so that\nour analysis will be more diverse.\n Let’s analyze a specification that wasn’t included in chapters 8 or 9. At the begin-\nning of the chapter, I added it to figure 10.1: the kpi.feature file.\n Key performance indicators (KPIs) are a common type of performance measure-\nment. KPIs evaluate the success of an organization or a particular activity in which it\nengages. Activitee provides HR departments with analytical tools that help them track\ntheir KPIs. The rationale is that analytics give HR representatives a sense of current\ndirection and let them plan their event strategy in the long term. One of the KPIs in\nActivitee is the adoption metric.\nTable 10.3\nDomains in listing 10.5\nDomain\nUbiquitous language\nEvents\nEvents, after-work, work-related\nOrganization\nEmployee, branch, department, location, posts \n\n\n229\nBuilding a domain-driven specification suite in practice\n \nAbility: HR can analyze adoption metrics to keep track of their KPIs\nScenario Outline: Calculating adoption goals\nOur assumption is that employee distribution\nbetween interests should be that every\ninterest group should aim to have at least 5%\nof the overall employee base. This is meant to ensure\nthat there are no \"dead\" interests nobody\nlikes.\nTHE FORMULA FOR THE ADOPTION GOAL\nthe adoption goal = (`active_groups` * 100%) / all interest groups\n`active_groups` = groups with more users than `required_users_per_group`\n`required_users_per_group` = 5% of all employees\nGiven HR set the adoption goal to 60%\nAnd the company has <users> employees registered\nAnd there are <groups> interest groups in the organization\nAnd only <active> interest groups have more members than <required>\nWhen the current adoption goal is calculated\nThen it should be at <goal>\nAnd Mike's company <should> be meeting their KPIs\nExamples: Must be enough active groups\n| users | groups | active | required | goal | should\n|\n| 200\n| 20\n| 12\n| 10\n| 60%\n| should\n|\n| 200\n| 20\n| 11\n| 10\n| 55%\n| should not |\nExamples: The size of the user base should affect the goal\n| users | groups | active | required | goal | should\n|\n| 2000\n| 20\n| 12\n| 100\n| 60%\n| should\n|\n| 2000\n| 20\n| 11\n| 100\n| 55%\n| should not |\nThis time, the choice is easy. The analytics subdomain is both the most frequently\nmentioned and, based on the examples, is the most important subdomain in listing\n10.6 (see table 10.4).\nThe last specification we’ll analyze is an ability for employees to redeem bonus points\nas engagement rewards (see listing 10.6). Team leaders who use Activitee can grant\ntheir subordinates bonus points for teamwork. The employees can later redeem the\npoints to get rewards from a special rewards catalog prepared by the HR department.\nListing 10.5\nfeatures/abilities/analytics/HR/kpi.feature\nTable 10.4\nDomains in listing 10.6\nDomain\nUbiquitous language\nEvents\nInterests\nOrganization\nEmployee, employee base, interest groups\nAnalytics\nKPI, adoption, goal, activity\n\n\n230\nCHAPTER 10\nBuilding a domain-driven specification suite\n \nAbility: Employees can redeem their bonuses to get engagement rewards\nScenario Outline: Redeeming a bonus as an employee\nGiven a Fortune 500 company like Coca-Cola\nAnd a bonus of 100 points granted to Simona by her team lead\nAnd a company rewards catalog:\n| reward\n| points needed |\n| A Starbucks Gift Card | 100\n|\n| A dinner with the CEO | 100000\n|\nWhen Simona tries to redeem her bonus points to <reward>\nThen she should <outcome>\nExamples:\n| reward\n| outcome\n|\n| A Starbucks Gift Card | get her reward\n|\n| A dinner with the CEO | see she doesn't have enough points |\nTable 10.5 shows that the bonuses subdomain is the clear winner in this case.\n10.3.4 Creating a specification suite from distilled domains\nWe end up with five distinct domains (see table 10.6). We’re also able to prioritize the\ndomains. I’ve already said that the events domain is the core domain because it lies at\nthe heart of Activitee’s platform. Security, on the other hand, is a classic generic sub-\ndomain: the company is only required to adhere to industry standards that almost all\nenterprise applications have to deal with. We’ll automatically treat all the other\ndomains as supporting subdomains.\nNOTE\nAn early reviewer of this book argued that the analytics domain should\nbe a generic subdomain instead of a supporting subdomain. I would usually\nagree, but I think Activitee’s case is different. Metrics are becoming more\nimportant in the HR world. Activitee’s sales team uses their data-driven prod-\nuct and analytical tools as important parts of their sales pitch. That’s why I\nListing 10.6\nfeatures/abilities/bonuses/employees/redeeming bonuses.feature\nTable 10.5\nDomains in listing 10.6\nDomain\nUbiquitous language\nOrganization\nCompany, team lead\nBonuses\nBonus, points, reward, rewards catalog, redeeming \nTable 10.6\nDomains in Activitee’s specification suite\nType\nDomains\nCore domain\nEvents\nSupporting subdomains\nOrganization, bonuses, analytics\nGeneric subdomains\nSecurity\n\n\n231\nAnswers to exercises\ndecided to list the analytics domain as a supporting subdomain: it’s important\nto the most important stakeholders—HR representatives.\nNow that all the important subdomains have been distilled, we can reorganize Activitee’s\nspecification suite according to everything learned in this chapter (see figure 10.5).\nHere’s what you can do with a domain-driven suite like this one:\nClose branches of the directory tree to reduce noise from the many subdomains\nin the specification suite.\nGrade subdomains on their importance by counting how many specifications\nare featured in each subdomain.\nTrack subdomains’ growth over time.\nSee how many actors each subdomain has to deal with, and map the relevant\nstakeholders and their interests.\nWatch new stakeholders appear in selected subdomains.\nIf you’re using a version control system to store your specification suite, you should be\nable to track all that at any point in time—the feature files and their file structure will\nbe stored in the commits. For example, you should be able to rewind and statistically\ndetermine which areas of your product have grown the most in the last six months.\nAnd because domains are mostly derived from the business aspects of a project and are\nseldom dictated by technology, you can also determine where the most business value\nwas added. If you do that, you will, for example, be able to say which aspects of your\nproduct you should continue investing in—and which maybe aren’t worth the effort. \n10.4\nAnswers to exercises\nEXERCISE 1\nChoose one state, one action, and one outcome from listing 10.1, and\nassign a domain to each one. If you notice multiple domains in any of the steps,\ndecide which domain should be the most important in this step:\nA storage state: a 2 GB limit\nA commercial offering action: upgrade to the premium plan\nA payments outcome: her credit card should be charged\nEXERCISE 2\nThink of one more supporting subdomain that could be relevant to the\ncloud storage service:\nA file access-control subdomain can be a good example. Some files should only be\naccessible to the people they were shared with.\nEXERCISE 3\nCan you think of another generic subdomain?\nA user access-control subdomain would be generic in most systems. Although file access\ncontrol would be connected to the core domain of the cloud storage system and thus be a\nsupporting subdomain, a user ACL, regulating which user could access which teams,\nwould be a generic subdomain. User access control, along with authentication, could\neven be in the same bounded context for account management.\n\n\n232\nCHAPTER 10\nBuilding a domain-driven specification suite\nHR\nkpi.feature\nTeam leads\ntracking performance.feature\nEmployees\nredeeming bonuses.feature\nHR\nrewards program.feature\nTeam leads\ngranting bonuses.feature\nevents.feature\nEmployees\nsearch.feature\nevents.feature\nHR\nscheduling.feature\ntargeting.feature\nTeam leads\noutings.feature\ninterest groups.feature\nEmployees\nnews feed.feature\nperformance.feature\nprofile.feature\ninviting employees.feature\nmanaging employees.feature\nonboarding employees.feature\norganization structure.feature\nCISO\nsso.feature\nEmployees\nauthentication.feature\npasswords.feature\nHR\nHR\npermissions.feature\nAbilities\nFeatures\nBusiness\nneeds\nSecurity\nOrganization\nEvents\nBonuses\nAnalytics\nFigure 10.5\nA medium-sized Activitee specification suite, \norganized by domains such as the core events domain; \nsupporting subdomains including organization, bonuses, \nand analytics; and a generic security subdomain\n\n\n233\nSummary\n10.5\nSummary\nGherkin helps you build better domain models by capturing a ubiquitous lan-\nguage, one of the main concepts from a software development methodology\ncalled domain-driven design (DDD).\n\nDDD is an approach to software development for complex needs that connects\nthe implementation to an evolving model created with domain experts.\nDomain experts are the people who know the most about a high-priority area of\nthe business. When domain experts and technical experts communicate, they\nuse—and simultaneously create—a shared, ubiquitous language.\nThrough a ubiquitous language, you can distill all the different subdomains\nand build a better map of your business domain by organizing the require-\nments in the specification suite according to their subdomains.\nThe core domain is the domain where the most value should be added in your\nsystem.\nA supporting subdomain models some aspect of the business that is essential,\nbut not core.\nA generic domain captures nothing special to the business, but it’s required for\nthe overall business solution.\n\n\n234\nManaging large projects\nwith bounded contexts\nThis is the final chapter in our four-chapter series about managing specification\nsuites. Chapters 8, 9, and 10 talked about managing small- to medium-sized suites.\nIn this chapter, we’ll split a large specification suite into several smaller suites, each\nof which will be a unified model of a particular subarea of a complex business\ndomain. In doing this, you’ll see how the challenge of managing large specification\nsuites can be viewed as a task of managing multiple medium-sized suites, which is\nsomething you already know how to do.\n One of the biggest projects I’ve worked on while using SBE and Gherkin spread\ninto multiple applications, each having its own specification suite. The applications\nThis chapter covers\nRefactoring large specification suites\nRecognizing false cognates and duplicate concepts\nManaging bounded contexts\nDrawing context maps\nFitting domain-driven design into an SBE process\n\n\n235\nAnalyzing domain concepts in context\ndealt with the same business domain, but they were managed by separate teams, some\nof which were outsourced. As systems grow too complex to know completely at the\nlevel of individual capabilities, you need techniques for manipulating and compre-\nhending large domains easily, as well as sharing consistent organization models\namong multiple technical teams.\n This hasn’t yet happened in the Activitee example. In the previous chapters, you\nsaw Activitee evolve from having a small specification suite to a medium-sized one. In\nthis chapter, we’ll fast-forward its evolution to a later stage so that you can learn the\ntechniques necessary to deal with really large suites. By large, I mean that it would be\npointless to try to show you an illustration of this suite—it wouldn’t fit on a single\npage, and we’d have to take too much time to analyze it.\n Given the way I’ve been talking about the domain model, you might assume that\nthe goal is to create a single, cohesive, all-inclusive model of the organization’s entire\nbusiness domain. That’s not correct. Experience shows that no matter how hard you\ntry, you’ll never be able to create a unified model for an entire organization. The\nsubject-matter experts will keep expanding their ubiquitous languages by adding,\nmodifying, and removing domain concepts as they see fit—often without maintaining\nconsistency within the larger organization. In this regard, ubiquitous languages are\nlike dialects. Dialects are based on the same core language, just as ubiquitous lan-\nguages are based on the same core domain in the corporate world. If you tried to\nforce people to unify their dialects into a single official language, the task would take\nyears—even if you assumed total cooperation. The process wouldn’t be impossible,\nbut the cost could end up outweighing the benefit. Now, imagine the same challenge\nin the corporate world. Yuck, right?\n Integrating different ubiquitous languages isn’t worth the effort required to create\na unified model of the entire business domain. If making a unified model of a com-\nplex domain isn’t an optimal choice, how can you organize large enterprise specifica-\ntion suites according to a domain model? Fortunately, domain-driven design (DDD)\nhas an answer to this question. The answer, as often happens in DDD, begins with the\nconcept of ubiquitous language and the process of translation.\n11.1\nAnalyzing domain concepts in context\nThis section explores the process of translation among dialects that appear in a speci-\nfication suite as it grows larger and includes more subdomains. Each subdomain\ncomes with its own dialect; in different dialects, the same word can mean opposite\nthings, or the same thing can have two names. Soon, you’ll see how to spot such words\nin a specification suite and how to deal with them. If you understand the problem of\ndealing with coexisting dialects, you’ll be able to solve it later in the chapter and learn\nhow to manage large specification suites.\n\n\n236\nCHAPTER 11\nManaging large projects with bounded contexts\n11.1.1 Spotting false cognates\nActivitee is becoming larger. The product is growing, the specification suite is grow-\ning—and there have been growing pains. For example, a new team member will\nquickly notice that there’s something called an event in multiple places in the growing\nspecification suite. Sometimes events are put in an obvious context (see listing 11.1),\nbut other times they’re found in places where, at face value, they shouldn’t be—like\nthe application security subdomain (see listing 11.2).\nScenario: Team leads and HR should be able to cancel events\nGiven an event created by Mike for his team:\n| name\n| date\n| time\n|\n| Bowling | 10-03-2017 | 10 AM |\nAnd Simona's confirmed attendance\nWhen Mike cancels the event\nThen Simona should receive a cancellation notification\nScenario: Employees can review events in the security log\nGiven Simona's previous logins were from the USA\nAnd her latest login was from the UK\nAnd somebody attempted to change her password\nWhen she reviews her activity log\nThen she should see the following events:\n| event\n| from | created at |\n| log in\n| USA\n| yesterday\n|\n| log in\n| USA\n| yesterday\n|\n| log in\n| UK\n| today\n|\n| change password attempt | UK\n| today\n|\nIt turns out that there are two different kinds of events in the specification suite (see\nalso figure 11.1):\nCore domain events—Events that take place in the real world and at which\nemployees have fun\nApplication security events—Digital footprints on the Activitee platform that can\nbe used to review suspicious activity\nDDD calls such concepts false cognates.\nDEFINITION\nFalse cognate—A domain concept that shares its name with\nanother domain concept. False cognates lead people to think they’re talking\nabout the same thing when they aren’t.\nIn linguistics, false cognates are also called polysemes: words that can have multiple\nmeanings depending on the context. Polysemy is distinct from homonymy, which is an\nListing 11.1\nEvent concept in the core events domain\nListing 11.2\nEvent concept in the application security subdomain\n\n\n237\nAnalyzing domain concepts in context\naccidental similarity between two words; whereas homonymy is often a linguistic coin-\ncidence, polysemy isn’t. The difference between polysemy and homonymy is that poly-\nsemy is more contextual. You’ve already seen that difference: context led us to\ndetermine that events in listing 11.1 aren’t the same as events in listing 11.2 and that\nthey belong to different domains. The context was provided by the examples in the\ntables and by the differences in ubiquitous languages used in the scenarios. \n11.1.2 Dealing with false cognates\nFalse cognates aren’t necessarily mistakes. As I said before, different groups of people\nwill use subtly different vocabularies in different parts of a large organization. You\ncan’t force security experts to abandon their vocabulary—in which the concept of\nevent as a logged activity is used often—just because you have another domain that\nuses a similar name for a different concept.\n But false cognates, like polysemes in natural languages, can introduce confusion.\nTrying to eradicate them isn’t a domain-driven way of dealing with false cognates.\nInstead, you can try to explicitly define the relationships between different contexts in\nwhich the domain concepts in question appear. Gherkin and Cucumber let you do\nthat with glossaries.\n In chapter 7, we defined a glossary as a separate file in the specification suite that\ncontains the definitions of all domain concepts required to understand a suite. This\ndefinition was fine for small specification suites of limited complexity. But now you\nknow that in larger suites, some names can have multiple meanings in different con-\ntexts. And I’ve already said that trying to create a single, unified, all-encompassing\nglossary is often too difficult and yields little return on investment.\n But what if you tried to create multiple contextual glossaries, like the ones shown\nin figure 11.2? A contextual glossary defines domain concepts from a shared context\nwhere no polysemes exist. A glossary for the core domain will define event as unequiv-\nocally a domain concept.\nCore domain\nAn outing in the\nreal world\nSecurity\nA logged activity\nEvent\nDomain\nNames\nFigure 11.1\nTwo different domain concepts can sometimes share the same name \nin the ubiquitous language.\n\n\n238\nCHAPTER 11\nManaging large projects with bounded contexts\n \nEVENT is a social outing in the real world.\nCOMPANY-WIDE EVENT is an event targeted at everyone within an entire\n➥organization.\nLOCAL EVENT is an event targeted for some specific location like New York,\n➥Boston, Atlanta.\n(...)\nA glossary for the security context will define event as a domain concept from the secu-\nrity domain. In this context, events are also unequivocal—as long as you don’t mix\none context with the other.\nEVENT is any logged activity.\nSINGLE SIGN-ON (SSO) is a session and user authentication service that permits\n  a user to use one set of login credentials (e.g., name and password) to\n  access multiple applications.\nTWO-FACTOR AUTHENTICATION (2FA) adds a second level of authentication to an\n  account log-in. When you have to enter only your username and one\n  password, that's considered a single-factor authentication. 2FA requires\n  the user to have two out of three types of credentials before being able\n  to access an account.\n(...)\nListing 11.3\nfeatures/abilities/events/glossary.md\nListing 11.4\nfeatures/abilities/security/glossary.md\nAmbiguous term in the context\nof the core events domain\nevents.feature\nEvents\nSecurity\nTeam leads\nevents.feature\nEmployees\nglossary.md\nglossary.md\nAbilities\nFeatures\nFigure 11.2\nA specification suite can have multiple glossaries, each \ndefining domain concepts in different contexts.\nAmbiguous term in the context of the\napplication security subdomain\n\n\n239\nAnalyzing domain concepts in context\nContext rules everything. The more you think about it, the more often you’ll notice\nthat subdomains, actors, and domain concepts always appear in context. The larger\nthe specification suite, the more you must be aware of the contexts that exist within it.\nYou’ll soon see how contexts will let you manage large specification suites, too. Unfor-\ntunately, you aren’t ready to do that just yet, because specifying false cognates isn’t the\nonly issue you’ll face when dealing with context in specification suites. \n11.1.3 Spotting duplicate concepts\nThe ubiquitous languages of different contexts sometimes interact. That’s why a sin-\ngle domain concept can appear in multiple contexts. It’s an inversion of what we\ntalked about in the previous section, where two domain concepts appeared to be the\nsame but weren’t.\n For example, the Activitee platform uses the concept of interest in multiple contexts\n(see figure 11.3). In the employee context, interests mean hobbies and activities that\nusers are interested in. In the core domain context, interests are used to target events\nat particular employees. In the organization context, each interest has its own interest\ngroup, which is a simple message board for like-minded people.\nIf interests from the three contexts I just mentioned were false cognates, they would\nall be different concepts—and different domain concepts deserve their own defini-\ntions. But in this situation, the domain concept is the same for all, so we only have to\nwrite a single definition for it and duplicate it in every context. Compare the glossaries\nin listings 11.5. and 11.6.\nEVENT is a social outing in the real world.\nCOMPANY-WIDE EVENT is an event targeted at everyone within an entire\n➥organization.\nLOCAL EVENT is an event targeted for some specific location like New York,\n➥Boston, Atlanta.\nINTEREST is a hobby or activity that our employees may want to participate in.\n(...)\nListing 11.5\nfeatures/abilities/events/glossary.md\nInterest\nInterest\nOrganization context\nCore domain context\nThe same concept\nin two different\ncontexts\nFigure 11.3\nDialects and contexts can share the same domain concepts \nunder the same names. Each context usually requires a slightly different \nimplementation, but the underlying concepts remain the same. Each \ncontext uses different aspects of the concept.\nInterests in the core\ndomain context\n\n\n240\nCHAPTER 11\nManaging large projects with bounded contexts\nINTEREST is a hobby or activity that our employees may want to participate in.\nINTEREST GROUP is a group of like-minded people who share the same interest\n➥and can use an Activitee message board to discuss it.\n(...)\nDDD calls such concepts duplicate concepts.\nDEFINITION\nDuplicate concept—One of at least two models of the same domain\nconcept. Each model represents and implements the same domain concept\nin a different context.\nIn chapter 10, I said that a model is an interpretation of reality that abstracts only the\naspects relevant to solving the problem at hand. Because different contexts deal with\ndifferent problems, they can abstract different aspects of the same domain concept\n(see figure 11.4).\nEach context will imply slightly different functions when implemented as code, even\nthough the underlying concept is the same. For example, an Interest model in the\norganization context will implement a create_interest_group() function, which will\ncontain code used to create interest groups. An Interest model in the employee con-\ntext will implement an add_as_hobby() function, which will assign interests to\nemployees who choose them.\nListing 11.6\nfeatures/abilities/organization/glossary.md\nInterests in the \norganization context\nCore domain\nAn outing in the\nreal world\nDomain\nNames\nInterest\nOrganizationInterest\n•create_interest_group()\nEmployeeInterest\n•add_as_hobby()\nModels\nFigure 11.4\nThe same domain concept can have two different models in two \ndifferent contexts, each model having its own implementation with unique functions.\n\n\n241\nModeling specification suites as bounded contexts\n Tracking duplicate concepts is just as important as tracking false cognates, because\nerrors introduced into a duplicate in one context can influence another context—for\nexample, through a shared database. Having multiple possible implementations can\nalso introduce new political issues over ownership of a concept. If two teams work in\ntwo different contexts that share a single domain concept, how do these teams man-\nage the differences between their visions of the concept? This is a common situation.\nI’ll try to answer this question in the next section. \n11.2\nModeling specification suites as bounded contexts\nDuplicate concepts are common and to be expected. Large projects are often decen-\ntralized, and decentralization invites duplication. In the long run, it’s not efficient to\ntry to avoid this. False cognates are less common and more harmful: they can lead to\ndelivery teams prying into each other’s code, inconsistent databases, and confusion in\ncommunication. Uninvited as they are, multiple false cognates often happen in a typi-\ncal large software development project.\n DDD doesn’t deal with duplicate concepts and false cognates by creating an all-\nencompassing domain model where inconsistencies don’t appear. Rather, it recog-\nnizes the splinters and either removes (when they’re design mistakes) or contains the\ninconsistencies within multiple smaller models that interact with each other. The\ninteraction process is key. It’s like translation. Every model must figure out a way to\nresolve the splinters in order to exchange information (send or retrieve data)\nrequired to complete the interaction. Such models are called bounded contexts. I used\nthe word context a lot in previous sections—and that was a conscious decision. In this\nsection, I’ll explain what bounded contexts are and how they can help you manage\nlarge specification suites.\n11.2.1 Understanding bounded contexts\nA bounded context is a fragment of the domain that has a unified model. A model is\nmeaningless unless it’s logically consistent, so each bounded context must have a uni-\nfied model that’s internally valid.\nDEFINITION\nBounded context—A fragment of the domain that has a unified\nmodel\nThe internal consistency of a model—meaning that each term is unambiguous and\nthere are no contradicting rules—is called unification. You know that a model is uni-\nfied when the following are true:\nIt has an unambiguous glossary.\nIt’s validated by specification suite tests.\nIt’s continuously integrated.\nEven though the context is internally consistent, it may not be consistent with other\nbounded contexts. Within the context, you should work to keep the model logically\n",
      "page_number": 242
    },
    {
      "number": 11,
      "title": "Managing large projects with bounded contexts",
      "start_page": 262,
      "end_page": 308,
      "detection_method": "regex_chapter",
      "content": "242\nCHAPTER 11\nManaging large projects with bounded contexts\nunified, but don’t worry about applicability outside those bounds. The translation pro-\ncess will handle that job later. We’ll talk more about how to resolve inconsistencies\nbetween contexts in section 11.2.4.\n How do you define contextual bounds? You can use a rule of thumb and identify\ncontexts by their glossaries. Whenever a fragment of the domain has an unambiguous\nglossary, it can be represented as a bounded context. An unambiguous glossary is a\nsign of unification. Other than that, contexts can be flexible.\n Remember that a bounded context is always a model. Models are abstract interpre-\ntations of reality made to solve problems at hand. As long as your interpretation\nmakes sense and you can keep the ubiquitous language consistent, you may choose\nfrom many potential splits between contexts. Any split can be more or less optimal,\ndepending on the problem at hand. You can assume that the more you get to know\nabout the domain and your stakeholders, the more optimal the contexts you create\nwill become. \n11.2.2 Splitting a large specification suite \ninto multiple bounded contexts\nDefining bounded contexts catalyzes the split of a single large specification suite into\nseveral smaller specification suites. Each context is a fragment of the domain. Each\nfragment becomes a potential split line. In this section, we’ll define a few contexts for\nActivitee, based on the contextual glossaries discussed earlier. We’ll then do a few\nsplits based on those contexts. We should end up with a clearly organized project with\na lot of room to grow for new abilities and business needs.\n At the end of the previous chapter, five subdomains were in play (see figure 11.5):\nAnalytics\nBonuses\nEvents\nOrganization\nApplication security\nIn figure 11.2, we use bounded contexts that include only a single subdomain.\nThere’s a separate context for the events subdomain, which has its own glossary—and\nthere’s a second context for the application security subdomain with another glos-\nsary. That can happen, but it doesn’t have to be the case every time. A bounded con-\ntext can easily deal with multiple subdomains, as long as they can share a single\nglossary (see figure 11.6). For example, we can define a bounded context for the\ncore Activitee experience, which deals with subdomains such as events, bonuses, and\norganization. The ubiquitous languages in these subdomains are generally consistent\nand fit together easily.\n \n \n\n\n243\nModeling specification suites as bounded contexts\n \n \nHR\nkpi.feature\nTeam leads\ntracking performance.feature\nEmployees\nredeeming bonuses.feature\nHR\nrewards program.feature\nTeam leads\ngranting bonuses.feature\nevents.feature\nEmployees\nsearch.feature\nevents.feature\nHR\nscheduling.feature\ntargeting.feature\nTeam leads\noutings.feature\ninterest groups.feature\nEmployees\nnews feed.feature\nperformance.feature\nprofile.feature\ninviting employees.feature\nmanaging employees.feature\nonboarding employees.feature\norganization structure.feature\nCISO\nsso.feature\nEmployees\nauthentication.feature\npasswords.feature\nHR\nHR\npermissions.feature\nAbilities\nFeatures\nBusiness\nneeds\nSecurity\nOrganization\nEvents\nBonuses\nAnalytics\nFigure 11.5\nAn Activitee specification \nsuite organized by domains\n\n\n244\nCHAPTER 11\nManaging large projects with bounded contexts\nFigure 11.6 shows a specification suite with three subdomains and a single unified glos-\nsary. From the modeling perspective, the unification aspect is the most important.\nFrom the technical perspective, having a separate specification suite for several subdo-\nmains often means you’ve decided to split a so-far-unified product into multiple appli-\ncations called services, each of which is responsible for certain aspects of the business\ndomain. That’s because Cucumber can read only one features directory per project. (If\nyou wanted to keep your bounded contexts in a single application, you’d need to create\na separate folder for each context in the features directory—a less elegant solution.)\n After extracting three subdomains from figure 11.6, we still have two other subdo-\nmains to deal with: analytics and application security. I talked a bit about the security\nsubdomain when we analyzed false cognates. You may remember from chapters 9 and\n10 that this subdomain cares mainly about identity issues, such as authentication,\nauthorization, and SSO. That’s why we can extract it into a separate bounded context\ncalled the identity context (see figure 11.7).\nWe can do the same with the analytics subdomain (see figure 11.8). Although key per-\nformance indicators (KPIs) are an important part of Activitee, they’ve always been sep-\narated from the rest of the platform. There are a couple of reasons to keep this\nsubdomain in a separate bounded context. First, the analytics product doesn’t intro-\nduce any new functionalities on its own; it feeds on data from other features. This data\nfeed product has to interact with other ubiquitous languages on a daily basis. A sepa-\nrate glossary would be a great tool to define the interactions between different dialects\nand resolve possible conflicts. For example, the analytics product could be able to ana-\nlyze the frequency of both HR events and security events, with a glossary specifying\nwhich is which. You can also look at similar products from other companies. For\ninstance, at the time of writing, Twitter Analytics is a separate application, complete\nwith its own design and a URL different than the core Twitter experience.\n[...]\nAbilities\nBonuses\nglossary.md\n[...]\nEvents\n[...]\nOrganization\nFeatures\nFigure 11.6\nA bounded context \nfor the core Activitee experience, \nwith a single unified glossary for \nthree subdomains\nAbilities\nglossary.md\n[...]\nSecurity\nFeatures\nFigure 11.7\nActivitee’s identity \ncontext and its glossary only specify \nscenarios that deal with the application \nsecurity subdomain—for example, \nauthentication and authorization.\n\n\n245\nModeling specification suites as bounded contexts\nThe real relationships between bounded contexts and subdomains is usually more\ncomplex than in these simple examples. For instance, we’ve assumed that the contexts\ncontain entire subdomains, which can happen—but the opposite is just as likely. A\nsubdomain can be split into parts, each part implemented in a different bounded con-\ntext; there’s nothing wrong with that. \n11.2.3 Managing bounded contexts with context maps\nCreating bounded contexts is a good first step toward manipulating and comprehend-\ning large domains easily. It reduces the problem of managing large specification suites\ninto managing multiple medium-sized specification suites. But how can you work with,\norganize, and comprehend multiple bounded contexts? The solution is to create a\ncontext map: a map that describes the points of contact between different bounded\ncontexts. I’ll show you an example in a moment.\nDEFINITION\nContext map—A map that describes the points of contact between\ndifferent bounded contexts (different specification suites), outlining explicit\ntranslations for any communication and highlighting any sharing\nI’ve talked about maps already:\nIn section 8.2.3, when discussing the concept of a specification suite as a map of\nrequirements\nIn section 10.2.2, when likening the domain model to a map of the domain that\nhelps you make good decisions on your journey to deliver software that will be\nvaluable in that domain\nA context map is an entirely new kind of map. If a specification suite is a map of\nrequirements organized according to DDD principles, then a context map is a map of\nspecification suites and the relationships between suites.\n Why are context maps important? Splitting the domain model into multiple con-\ntexts won’t automatically make the domain model smaller, easier to comprehend, or\nless complex. It will decentralize complexity.\n Decentralization is a huge topic in DDD. For example, each time you find out that\ntwo decentralized contexts aren’t synchronized (for example, if you find a false cog-\nnate and haven’t decided what to do with it), you can make one of two decisions:\nPull the model back together, and refine it to prevent fragmentation.\nAccept the fragmentation as a result of diverse groups who want to push the\nmodel in different directions for good reasons, and let them develop their con-\ntexts independently.\nAbilities\nglossary.md\n[...]\nAnalytics\nFeatures\nFigure 11.8\nActivitee’s analytics \ncontext focuses only on analytical \nabilities, with a glossary that can unify the \nubiquitous language in the specification \nsuite presented in the diagram.\n\n\n246\nCHAPTER 11\nManaging large projects with bounded contexts\nIf you make the second decision, you’ll need a way to track fragmentation and see\nwhere different bounded contexts converge and diverge. A good first step is creating\nand maintaining separate glossaries for each bounded context—something you’ve\nalready done. A good second step is to mark relationships such as false cognates and\nduplicate concepts in different contexts. Here’s where context maps come in handy. \n11.2.4 Drawing context maps\nFigure 11.9 shows what a context map looks like in theory. It shows two models, each\nin its own bounded context. Each model is a visual representation of the domain con-\ncepts present in each context as well as the relationships between the concepts. (In\npractice, such diagrams are most often drawn in UML, a popular modeling language\nthat provides a standard way to visualize the design of a system.) You can also see the\ntranslation map, which is a space where you can define the points of contact between\ndifferent bounded contexts. Each point of contact can specify interactions such as\nfalse cognates, duplicate concepts, and any other relation that you deem important.\nFigure 11.10 shows a more practical example based on the Activitee platform and the\nfalse cognates and duplicate concepts we dealt with in section 11.1. Software develop-\nment teams often draw maps like this one to outline explicit translations for any com-\nmunication and highlight any sharing between contexts. The map defines the\nterritory of each context and the borders between contexts. Without a context map,\npeople on other teams may not be aware of contextual bounds and may unknowingly\nmake changes that blur the edges or complicate the interconnections.\n A context map is different than the map I talked about when comparing a specifi-\ncation suite to a map. Due to automation and its link to real working code, a specifica-\ntion suite can only be a model of the bounded contexts in a single codebase. So if you\nhave to split your bounded contexts into separate codebases due to the complexity of\nTranslation\nmap\nModel in context\nModel in context\nFigure 11.9\nA simple context map that lists translations such as false \ncognates and duplicate concepts between two theoretical models in their \nbounded contexts\n\n\n247\nModeling specification suites as bounded contexts\nthe system or your system architecture, each specification suite will be able to map\nonly what it can automate; therefore, it will always be limited to the reach of its testing\ncode. A simple, practical example is that two different subsystems can be written in\ntwo different programming languages, which makes unified testing more difficult.\nYou have to resort to non-automated methods, such as context maps. It really is just a\nsimple drawing. Still, each specification suite with a glossary will help you create better\ncontext maps because it’s an automated, frequently validated, always up-to-date map\nof each bounded context. But the context map itself must be maintained manually.\n In DDD, contexts map are an important element of strategic design. Strategic design\nis not only a way to map a business domain, as in the example, but also a way to show\nwhich parts of the system matter most to the business and where to focus design\nefforts in order to be effective. Eric Evans defined several design patterns.1 The con-\nformist pattern is a good example. A conformist context adheres to other models in\norder to simplify integration by adopting to a provided language and data without\nquestioning it. Therefore, conformity eliminates the complexity of translation.\n Another example is the anticorruption layer pattern, which creates an isolating\nlayer to provide clients with functionality in terms of their own domain model. Thanks\nto DDD’s strategic patterns, you can not only define the points of contact shared by the\nubiquitous languages of different bounded contexts, but also define how, in the long\nterm, each team should manage their context’s interactions with other contexts and,\ntherefore, other teams.\n Unfortunately, it’s beyond the scope of this book to discuss techniques from the field\nof DDD. If you’re interested in the topic, you can read Evans’ book, which is a great\nintroduction to the topic and will give you a fuller overview of what DDD is all about. \n1 Eric Evans, Domain-Driven Design, chapters 14–17 (Addison-Wesley, 2003).\nEvent\nThe security context\nEvent\nFalse cognates\nInterest\nThe analytics context\nInterest\nCore context\nDuplicate concepts\nFigure 11.10\nA simple \ncontext map that lists \npreviously defined false \ncognates and duplicate \nconcepts between Activitee’s \nbounded contexts\n\n\n248\nCHAPTER 11\nManaging large projects with bounded contexts\n11.3\nFitting DDD into an SBE process\nPaired with SBE and Gherkin, DDD can be a powerful tool. To solidify your under-\nstanding before we end the chapter, let’s review the general process, this time from\nstart to finish. This section features some new material that will let you see the pro-\ncesses of modeling and specifying from the perspective of different team members;\nprogrammers, designers, analysts, and testers will be able to understand how the\ndomain-modeling process will affect their jobs.\n Everything starts with the ubiquitous language, created thanks to the cooperation\nof both domain experts and technical experts. When they converse about the require-\nments and their organization’s business domain, they naturally flesh out domain con-\ncepts and mix their jargons to create the ubiquitous language—the language of the\ndomain in a given technological context, also called a bounded context.\n That’s when Gherkin steps in. Gherkin allows for the recording and long-term\nstorage of short-term conversations. When the experts write down their conversations\nin Gherkin, they can refine their domain models more easily. As section 10.2.2\nexplained, you can analyze Gherkin scenarios to distill different domains from each\nconversation and decide which is the core domain and which are secondary or\ngeneric domains (and thus less important). And section 10.2.3 showed that analyzing\nfalse cognates and duplicate concepts between different scenarios can lead to creating\ndifferent bounded contexts, which fragment the domain into several smaller context-\ndependent models.\n Thanks to Gherkin’s connection to the realm of automated testing, each bounded\ncontext binds the testing code of its specification suite and the real code meant to\nimplement the actual requirements. Thanks to automated tests, which frequently ver-\nify the suite’s consistency, as well as Gherkin’s focus on the ubiquitous language, you\ncan be sure that each specification suite based on a bounded context presents a uni-\nfied, consistent model of the subdomain the current code is dealing with.\n The requirements are organized according to their corresponding subdomains.\nYou can quickly inspect the subdomains used in each context by analyzing the struc-\nture of directories within the specification suite, as well as create and maintain a uni-\nfied glossary of domain concepts for each bounded context. The structure of your\nspecification suites becomes a visual and hierarchical domain model—a map of the\nfragments of your business domain that you’ve already specified—in which require-\nments and glossaries are connected to their corresponding domains.\n Thanks to bounded contexts, the problem of managing large specification suites is\nreduced to a problem of managing multiple medium-sized specification suites—a\ntopic we discussed in chapters 8–10 and that you should be ready to deal with. The only\nremaining issue is figuring out how to deal with interactions among multiple suites.\nThe relationships among different specification suites can be clarified by using context\nmaps. By describing the points of contact between different bounded contexts, context\nmaps can give you a fuller overview of your business domain and provide a translation\n\n\n249\nSummary\nframework between the bounded contexts. The translation framework can help you\ndeal with false cognates and duplicate concepts more easily.\n Refining the domain model as well as defining and analyzing bounded contexts\ncan yield multiple positive outcomes to each delivery team. DDD emphasizes that dif-\nferent parts of your system matter differently to your business and provides a method-\nology to focus your team’s design efforts most effectively. Designers and analysts can\nbenefit from DDD by understanding where business value comes from, thanks to see-\ning which domains and contexts grow the fastest.\n Better domain models yield better code designs, without unnecessary coupling of\nconcepts that should stay separate; this makes code more stable for developers and\nautomated testing easier for testers. For free, developers also get a methodology for\nnaming their domain objects in code according to the ubiquitous language—which\nreduces the cost of mental translations.\n On a personal note, I wish I’d known all this years ago when my team and I were\nworking on a particular enterprise project. It would have saved us considerable time\nand stress. The complexity was eating us up on a daily basis. We were on the right\ntrack to curb it, but the project lacked the finishing touches. We knew how to use\nGherkin and Cucumber, but we had no idea how to organize large specification suites.\nWe understood the concept of a ubiquitous language, but we didn’t yet grasp all of its\nimplications for software design. The only element almost completely missing was\nDDD. (We learned about the ubiquitous language through Gherkin.) As I reminisce, I\nsee how we could have used glossaries, bounded contexts, context maps, and DDD\ndesign patterns to improve our processes. I can only hope that this chapter—a culmi-\nnation of the previous lessons—will aid you in writing great specifications so that you\ncan harness the true power of executable Gherkin much more quickly and easily than\nI did. \n11.4\nSummary\nA false cognate is a domain concept that shares its name with another domain\nconcept.\nFalse cognates lead people to think they’re talking about the same thing when\nthey aren’t.\nDuplication of concepts leads to two different implementations of the same\ndomain concept in two different contexts.\nFalse cognates and duplicate concepts are examples of why it’s difficult to cre-\nate a unified, all-encompassing domain model—repetitions, inconsistencies,\nand equivocation creep in.\nEven though domain models lie at the center of domain-driven design, DDD’s\ngoal isn’t to build a single model of an organization’s entire business domain.\nInstead, DDD practitioners use bounded contexts.\n\n\n250\nCHAPTER 11\nManaging large projects with bounded contexts\nA bounded context is only a fragment of the domain with a unified model. A\nfragment can be small and consistent enough to avoid equivocation within its\nmodel.\nA specification suite of a bounded context specifies the ubiquitous language of\nits model.\nThanks to bounded contexts, the problem of managing large specification\nsuites is reduced to a problem of managing multiple medium-sized specifica-\ntion suites.\nEach bounded context needs to figure out how to communicate with other\nbounded contexts, just as different departments learn to share information\nwithin a company.\nBounded contexts share information through context maps. A context map\ndescribes the points of contact between different bounded contexts, outlining\nexplicit translations for any communication and highlighting any sharing.\n\n\n251\nappendix\nExecuting specifications\nwith Cucumber\nThis appendix is a quick tutorial on how to write and run simple automated tests\nfor feature files with Cucumber and Gherkin. I do realize that some readers will\nexpect an explanation of the executable part of executable specifications. Execution\nis Cucumber’s role. To execute a specification, you write tests based on a prepared\nscenario, which you later evolve into a scenario outline—and then you automate\nthat, too. I’m assuming you’ve read at least chapters 2 and 5, which talk about sce-\nnarios and scenario outlines. You can, however, proceed up to section A.8 without\nhaving read chapter 5, and then come back later.\n This tutorial will teach you the basic workings of the automation layer based on\nan example of a simple banking application that lets clients deposit and withdraw\nmoney. I’ll try to keep the example simple and explain everything along the way, for\nreaders who are nontechnical but want to learn more about the automation layer.\n You can use the command-line interpreter of your choice. I’ll assume you under-\nstand basic regular expressions and Ruby, which I’m using to write the code, as well\nas how to configure and use RubyGems to install Cucumber. I realize that not every-\nbody needs to know Ruby, so I’m writing the simplest implementation code possible\nand testing it with the simplest testing code I can think of. This choice means the\nresults won’t be perfect according to Ruby’s coding standards, but you should be\nable to understand my code regardless of your language of choice.\nA.1\nIntroducing test-driven development\nThis appendix is more of a high-level overview of fundamental testing techniques\nrather than a complete explanation. It focuses on the two most important topics:\nUnderstanding test-driven development (TDD)\nWriting unit tests\n\n\n252\nCHAPTER \nExecuting specifications with Cucumber\nTDD is one of the best-known practices inside and outside agile software development\ncommunities.\nDEFINITION\nTest-driven development—A software development methodology\nthat requires developers to write failing tests first and then gradually create\nthe implementation code to make the tests pass\nThis appendix relies on TDD heavily, so it’s important that you understand what that\nmeans. Kent Beck, who popularized TDD, explained it as a practice that requires you\nto “test a little, code a little.”1 Each time you have a new feature to implement, Beck\nsaid, you should do the following:\n1\nAdd a failing test first.\n2\nRun all of your tests, and confirm that the new test fails.\n3\nWrite the minimum implementation code that causes the new test to pass.\n4\nRun the tests again to see them pass, thanks to the new code.\n5\nThe minimum implementation code will usually be ugly even though it passes\nthe test. Refactor and polish the code. Use the test repeatedly to check whether\nthe code works as intended even with changes.\n6\nRepeat the entire process every time you want to add a new functionality.\nThis process is sometimes simplified into a three-step loop: red-green-refactor. Most test\nrunners mark failing tests in red and passing tests in green. You start with a red test\nand gradually work to make it a green one. As soon as you get a green test, you refac-\ntor the code to polish it, and then you use the tests to be sure you didn’t break any-\nthing while making your implementation more beautiful.\n If you feel that writing failing tests before writing actual implementation code is\nweird, don’t worry—I remember feeling that way. It becomes more natural as you get\nthe hang of it. The benefit of TDD is that when you focus on writing only the code nec-\nessary to pass tests, your designs will often be cleaner and clearer than you can achieve\nwith other methods. \nA.2\nIntroducing unit tests\nThe tests you’ll write in this appendix are called unit tests.\nDEFINITION\nUnit test—A low-level test that focuses on a small part of the soft-\nware system called a unit of work\nPeople often consider different things to be single units of work. In object-oriented\ndesign, a unit can be an entire interface, such as a class; but in functional design, it\nmay be a single function. In the context of this appendix, it doesn’t matter. I chose to\nuse unit tests because they’re short, simple, and quick, and they don’t require you to\n1 Kent Beck and Erich Gamma, “Test Infected: Programmers Love Writing Tests,” Java Report, 3(7), July 1998,\nhttp://junit.sourceforge.net/doc/testinfected/testing.htm.\n\n\n253\nConfiguring the environment\ncreate an advanced implementation such as a database connection or a user interface.\nYou can copy the code as is and make it run effortlessly on your machine.\n Unit tests aren’t the only type of tests. Most teams use Cucumber and Gherkin to run\nend-to-end tests with a runner like Selenium for web browser automation. Selenium-\ndriven specifications simulate a user working with a real instance of the system. When\nI say real, I mean as real as possible. You can even configure Selenium to run Firefox or\nChrome on your machine in order to watch Cucumber click over the simulated user\ninterface as it tests the system. Personally, I like to use an approach based on domain-\ndriven design (discussed in chapter 10) and write Cucumber tests that validate the\ndomain layer without end-to-end testing, which tends to be slow and performance\nheavy. Unfortunately, a discussion of choosing domain logic tests over end-to-end tests\nis too complex for me to do it justice in an appendix. I wanted to mention it, though,\nin order to show you some possible future learning paths.\n If you want to learn more about the automation aspects of Cucumber and Gher-\nkin, read The Cucumber Book by Matt Wynne and Aslak Hellesøy (Pragmatic Program-\nmers, 2012). If you’re a Java person, you may want to look at BDD in Action by John\nFerguson Smart (Manning, 2014), which features many code examples written in Java.\nYou should have zero problems finding books that talk about any of the topics I’ve just\nmentioned, including TDD, unit tests, and end-to-end testing; they’re all established\nsoftware development practices. \nA.3\nConfiguring the environment\nTo execute any tests, you first need to make sure you have a test runner on board and\nthat your programming environment is configured to make the tests pass. A test run-\nner—in this case, Cucumber—is a type of software written to automatically test other\nsoftware. In this section, you’ll install Cucumber and do the basic configuration\nrequired to execute any specifications.\n You can install Cucumber by running the gem install cucumber command on\nyour terminal:\n$ gem install cucumber\nFetching: cucumber-2.4.0.gem (100%)\nSuccessfully installed cucumber-2.4.0\nParsing documentation for cucumber-2.4.0\nInstalling ri documentation for cucumber-2.4.0\nDone installing documentation for cucumber after 3 seconds\n1 gem installed\nNOTE\nThe gem install cucumber command’s output may be much longer in\na clean Ruby environment, because all kinds of dependencies will have to be\ninstalled. I simplified the output for the sake of space.\nAlso, create a directory where you’ll store your tests and scenarios:\n$ mkdir bank\n$ cd bank\n\n\n254\nCHAPTER \nExecuting specifications with Cucumber\nOnce you’re in the new directory, you can run Cucumber to see what happens:\n$ cucumber\nNo such file or directory - features. You can use `cucumber --init` to get\n➥started.\nTIP\nYou can only use the cucumber command in a directory that contains a\ndirectory called features.\nYou haven’t done any configuration yet, so Cucumber asks you to prepare the environ-\nment for future testing. Executing cucumber --init will create the file structure\nrequired to put your scenarios in the specification suite and write the tests:\n$ cucumber --init\ncreate\nfeatures\ncreate\nfeatures/step_definitions\ncreate\nfeatures/support\ncreate\nfeatures/support/env.rb\nThe file structure is simple enough:\nYou put your .feature files in the features directory.\nStep definitions (the testing code) go in features/step_definitions.\nThe files in the features/support directory can be used to configure the specifi-\ncation suite. Don’t worry about it for now; the default configuration will be all\nyou need.\nThanks to the cucumber --init command, you have a good baseline. You’ve installed\nCucumber and gotten it to work, and you know where to store scenarios and tests.\nNow you need to take care of those, if you want to execute any specifications. \nA.4\nPreparing scenarios for automation\nTDD is a test-first approach, so you first need to write a test. Listing A.1 presents a very\nsimple scenario for depositing money in a bank account. The scenario includes two\nGivens, in which you meet a user—Simona Jenkins—with an empty bank account; a\nWhen where she deposits the money; and a Then that checks whether her account bal-\nance was updated. In this section, you’ll automate each of the Given-When-Thens.\nFeature: Bank account\nScenario: Adding money to your account\nGiven a bank account in Simona's name\nAnd that her current account balance is $0\nWhen she deposits $500\nThen the account balance should be $500\nTIP\nYou can choose any names for your feature files. Cucumber will read\neverything from the features directory.\nListing A.1\nScenario for depositing money\n\n\n255\nPreparing scenarios for automation\nPut the scenario in a feature file called account.feature in the features directory, and\nexecute the cucumber command again. Even though this code looks like a big jump in\ncomplexity, the command just reprints the scenario, returns tests results, and gener-\nates missing code snippets:\n$ cucumber\nFeature: Bank account\nScenario: Adding money to your account\n# features/account.feature:3\nGiven a bank account in Simona's name\n# features/account.feature:5\nAnd that her current account balance is $0 # features/account.feature:6\nWhen she deposits $500\n# features/account.feature:7\nThen the account balance should be $500\n# features/account.feature:8\n1 scenario (1 undefined)\n4 steps (4 undefined)\n0m0.003s\nYou can implement step definitions for undefined steps with these snippets:\nGiven(/^a bank account in Simona's name$/) do\npending # Write code here that turns the phrase above into concrete actions\nend\nGiven(/^that her current account balance is \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nWhen(/^she deposits \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nThen(/^the account balance should be \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nThe test results are classified as undefined because you haven’t written any testing\ncode. That’s why Cucumber generates a code snippet for every Given, When, and Then.\nThe step definitions are marked as pending; Cucumber will ignore them unless you\nput some code in them. At this moment, the step definitions are more placeholders\nfor future tests than real tests. You’ll change that soon. As you write more code, the\npending steps will be classified as either passed or failed.\n Notice that steps and step definitions are matched through regular expressions.\nCucumber lets you use regular expressions to extract attributes from the steps, and to\nmake automation easier and reduce redundancy. For example, if you changed the she\ndeposits $500 step to she deposits $1000, Cucumber wouldn’t need a second step\ndefinition, because it treats \\$(\\d+) as a placeholder that can catch all numbers in\nany step that matches the rest of the regular expression—the she deposits part.\nTIP\nBe careful! Sometimes regular expressions in Cucumber can cause head-\naches. Cucumber reuses steps based on the expressions you write. If you write\na regex that’s too loose, you may end up with a step definition that’s matched\nwith a different step than you had in mind.\nWith a specification in place, you can proceed to writing your first testing code. \nPrinted-out scenario\nTest results\nCode snippets\n\n\n256\nCHAPTER \nExecuting specifications with Cucumber\nA.5\nWriting tests in a test-driven manner\nHere’s where the challenge gets interesting. To make the development process really\ntest-driven, you should write the tests before the implementation. Let’s begin by copy-\ning the snippets generated by Cucumber and putting them in a file called account.rb\nin the features/step_definitions directory.\nGiven(/^a bank account in Simona's name$/) do\npending # Write code here that turns the phrase above into concrete actions\nend\nGiven(/^that her current account balance is \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nWhen(/^she deposits \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nThen(/^the account balance should be \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nA.5.1\nDefining prerequisites with Givens\nIn the case of the first Given in listing A.2, you’ll have to create a bank account in the\nname of a client named Simona. The code should create Simona’s client account with\na hypothetical Client object and then create a bank account—for example, with an\nAccount object—and assign it to Simona (see the following listing). Keep in mind that\nyou haven’t created any real objects yet. Instead, you’re planning which objects and\nmethods you’ll need during implementation.\nGiven(/^a bank account in Simona's name$/) do\n@simona = Client.new(name: \"Simona\")\n@simona.account = Account.new\nend\nYou’ll probably reuse Simona’s Client account in many other scenarios—even those\nthat don’t deal with deposits and don’t interact with the Account object. It would be a\ngood idea to extract creating the Client profile into a separate step, to simplify reus-\ning that step in other scenarios. Cucumber lets you do that with its step method.\nGiven(/^a client called Simona$/) do\n@simona = Client.new(name: \"Simona\")\nend\nGiven(/^a bank account in Simona's name$/) do\nListing A.2\nfeatures/step_definitions/account.rb\nListing A.3\nTesting code for the first Given step\nListing A.4\nInvoking steps from other step definitions\n\n\n257\nWriting tests in a test-driven manner\nstep \"a client called Simona\"\n@simona.account = Account.new\nend\nThe step method takes a String with the name of another step, runs it through\nCucumber’s regex engine, and executes the called step inside another step. You’re\nprobably being too careful, using the step function so soon in this case, because\nthere’s no explicit need for reusability; but the method is so useful that you couldn’t\nleave it aside.\n Having taken care of the first Given, let’s proceed to the second one. This step\nshould make sure the initial balance in Simona’s account is the same in every test run\nso you won’t end up with a different amount of money than defined in the scenario.\nGiven(/^that her current account balance is \\$(\\d+)$/) do |arg1|\n@simona.account.balance = arg1.to_i\nend\nThis step definition uses a regular expression to extract the current account balance\nfrom the scenario. That’s why you can use the arg1 argument in the testing code to\ndefine Simona’s account balance. Using a regular expression means that whatever\nnumber you write in the scenario will be extracted by Cucumber for use as the value\nof the arg1 argument.\nNOTE\nYou have to recast arg1 as an Integer because Cucumber treats every\nargument extracted from regular expressions as a String.\nEven though you don’t yet have any real code for the Account object, you know that it\nshould have a method for setting the initial account balance. If it didn’t, you wouldn’t\nbe able to execute your tests. In Ruby, this means instances of the Account object must\nimplement a method like balance= with a numeric argument. That’s how tests written\nin the TDD manner can influence the implementation code’s design.\nTIP\nIf you want to, you can rename arg1 to something more human friendly,\nlike current_balance. \nA.5.2\nTaking actions with Whens\nTwo steps down, two steps to go. The When should allow the client to deposit the\namount of money specified in the scenario, which is the primary action of the scenario.\nWhen(/^she deposits \\$(\\d+)$/) do |arg1|\n@simona.account.deposit(arg1.to_i)\nend\nListing A.5\nGiven step for setting the account balance\nListing A.6\nDefining the scenario’s primary action in a When\nReusing a Given thanks to \nCucumber’s step method\n\n\n258\nCHAPTER \nExecuting specifications with Cucumber\nAgain, you use an argument from the step definition; and again, you recast arg1 as an\nInteger. You also know that every instance of the Account object will have to imple-\nment a deposit method, which will increase the account balance set by the balance=\nmethod you used in the previous step definition. In this scenario, you know that the\ndeposit method should increase the balance by $500. \nA.5.3\nTesting consequences with Thens\nThis is the last step. It’s a Then, so you programmatically define the consequences you\nexpect from this scenario and test whether the actions you took in the previous steps\nhad the desired effect.\nThen(/^the account balance should be \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nProgrammers and testers test consequences with assertions.\nDEFINITION\nAssertion—A statement that’s expected to always be true when\nexecuted. If an assertion evaluates to false at runtime, an assertion failure\nresults, which typically causes the program to crash or to throw an assertion\nexception.\nI’m using RSpec to write my test assertions. RSpec is a behavior-driven development\n(BDD) testing framework for Ruby. You can easily combine RSpec with Cucumber,\nthanks to the rspec-expectations library; Cucumber will automatically load RSpec’s\nmatchers and expectation methods. The assertions check whether the output\nexpected in the feature file matches the output from the executed tests. If it doesn’t,\nRSpec will raise an error and stop executing the tests.\n To use RSpec’s assertions with Cucumber, you need to install the library using\nRubyGems:\n$ gem install rspec-expectations\nFetching: rspec-support-3.5.0.gem (100%)\nFetching: diff-lcs-1.2.5.gem (100%)\nFetching: rspec-expectations-3.5.0.gem (100%)\nSuccessfully installed rspec-support-3.5.0\nSuccessfully installed diff-lcs-1.2.5\nSuccessfully installed rspec-expectations-3.5.0\n3 gems installed\nAs you can see, rspec expectations loads a few supporting libraries—that’s fine.\nYou’ll need them all to use assertions.\nTIP\nIf you’re using Bundler, you can add gem 'rspec-expectations' to your\nGemfile, instead. Bundler provides a consistent environment for Ruby pro-\njects by tracking and installing the exact gems and versions that are needed.\nListing A.7\nPending Then step\n\n\n259\nWriting implementation code based on tests\nTherefore, you can list the gems your project requires in a Gemfile and install\nthem all at once, instead of going through the list one by one.\nThe last step required to use rspec-expectations in your testing code is to add a\nrequire line at the top of the account.rb file in features/step_definitions, as shown next.\nrequire \"rspec/expectations\"\nGiven(/^a client called Simona$/) do\n@simona = Client.new(name: \"Simona\")\nend\n(...)\nNow you can use RSpec’s expect syntax to create a simple assertion that will check\nwhether Simona’s account balance equals final_balance—the number extracted\nfrom the scenario by Cucumber.\nThen(/^the account balance should be \\$(\\d+)$/) do |final_balance|\nexpect(@simona.account.balance).to eq final_balance.to_i\nend\nIn this case, you know that Simona’s account balance should be $500, because you\nused the deposit method to increase it when you wrote the testing code for the When.\n And that’s all! (For now.) You’ve completed the testing code required to execute\nthe specification. That doesn’t mean, of course, that it will be executed successfully. As\nyou’ll soon see, you still have to write the implementation code. \nA.6\nWriting implementation code based on tests\nDo you remember the red-green-refactor loop I talked about at the beginning of this\nappendix? You should periodically run Cucumber to check whether the code you’ve\nwritten so far is enough to make the tests pass. In this section, you’ll see how failing tests\ncan guide you in writing the implementation code that will later run in production.\nAfter a few iterations, you should end up with working code that makes the tests pass.\n Let’s not get ahead of ourselves, though. First, run Cucumber to see whether any-\nthing has changed since you used it to generate snippets for the step definitions:\n$ cucumber\nFeature: Bank account\nScenario: Adding money to your account\n# features/account.feature:3\nGiven a bank account in Simona's name\n➥# features/step_definitions/tests.rb:3\nuninitialized constant Client (NameError)\n./features/step_definitions/tests.rb:4:in\n➥`/^a bank account in Simona's name$/'\nfeatures/account.feature:5:in `Given a bank account in Simona's name'\nListing A.8\nIncluding the rspec-expectations gem\nListing A.9\nUsing an Rspec assertion to check the final account balance\nNameError exception \nthrown during test execution\n\n\n260\nCHAPTER \nExecuting specifications with Cucumber\nAnd that her current account balance is $0\n➥# features/step_definitions/tests.rb:8\nWhen she deposits $500\n➥# features/step_definitions/tests.rb:12\nThen the account balance should be $500\n➥# features/step_definitions/tests.rb:16\nFailing Scenarios:\ncucumber features/account.feature:3 # Scenario: Adding money to your account\n1 scenario (1 failed)\n4 steps (1 failed, 3 skipped)\n0m0.005s\nOuch! The scenario failed in its first step because Cucumber threw an exception. Let’s\nlook at the step definition to see what’s wrong:\nGiven(/^a client called Simona$/) do\n@simona = Client.new(name: \"Simona\")\nend\nOh, that’s it: there’s a NameError because the step definition tried to use the Client\nobject even though you haven’t defined it. Let’s write some implementation code to\nmake the Client object more real—and make the test pass.\n First, create a directory called features/implementation where you’ll store imple-\nmentation code for Cucumber to see:\nmkdir features/implementation\nTIP\nIn real-world projects, you’ll store your implementation code outside of\nthe features directory. But for now, I want to keep things easy; so, you’re put-\nting the code where Cucumber can see it without your having to reconfigure\nCucumber to see code in other directories.\nYou can now write the following simple implementation of the Client object that\nshould make the step definition from listing A.10 pass.\nclass Client\ndef initialize(name:)\n@name = name\nend\ndef name\n@name\nend\nend\nThe object has two simple methods for setting and reading a client’s name. It’s not\nmuch, but remember that TDD requires you to write only the code necessary to pass\ntests. Because setting the name is where you saw the tests fail, that’s what you should fix.\n To see what you should do next, though, you have to rerun Cucumber:\nListing A.10\nfeatures/implementation/client.rb\n\n\n261\nWriting implementation code based on tests\n$ cucumber\nFeature: Bank account\nScenario: Adding money to your account\n# features/account.feature:3\nGiven a bank account in Simona's name\n➥# features/step_definitions/account.rb:7\nuninitialized constant Account (NameError)\n./features/step_definitions/account.rb:9:in\n➥`/^a bank account in Simona's name$/'\nfeatures/account.feature:5:in `Given a bank account in Simona's name'\nAnd that her current account balance is $0\n➥# features/step_definitions/account.rb:12\nWhen she deposits $500\n➥# features/step_definitions/account.rb:16\nThen the account balance should be $500\n# features/step_definitions/account.rb:20\nFailing Scenarios:\ncucumber features/account.feature:3 # Scenario: Adding money to your account\n1 scenario (1 failed)\n4 steps (1 failed, 3 skipped)\n0m0.008s\nThe tests are still failing, but at least you got a different error. This time, Cucumber\ntracked the source of the exception back to the ninth line of the features/step_defini-\ntions/account.rb file:\nGiven(/^a bank account in Simona's name$/) do\nstep \"a client called Simona\"\n@simona.account = Account.new\nend\nThe step definition is trying to use the Account object even though it doesn’t exist.\nLet’s create the simplest possible implementation of the Account object that should\nmake the tests pass—or at least let you progress to a different error.\nclass Account\nend\nRerun Cucumber:\n$ cucumber\n(...)\nundefined method `account=' for #<Client:0x007f87021cf788 @name=\"Simona\">\n➥(NoMethodError)\n./features/step_definitions/account.rb:9:in\n➥`/^a bank account in Simona's name$/'\nAnother exception. The implementation of the Client object still doesn’t have a\nmethod for connecting bank accounts with their owners—but you use the method in\nListing A.11\nfeatures/implementation/account.rb\nAnother NameError \nexception\nLine 9\n\n\n262\nCHAPTER \nExecuting specifications with Cucumber\nlisting A.12 when you invoke the account= method on the @simona instance of the\nClient object. Let’s fix that.\nclass Client\ndef initialize(name:)\n@name = name\nend\ndef name\n@name\nend\ndef account=(account)\n@account = account\nend\nend\nThe account= method sets the client’s bank account to the account you put in the\nargument—just as the test expects.\n Again, run Cucumber:\n$ cucumber\n(...)\nundefined method `account' for #<Client:0x007fc42d34d9a8>\nDid you mean?\naccount= (NoMethodError)\n./features/step_definitions/account.rb:13:in\n➥`/^that her current account balance is \\$(\\d+)$/'\nAgain, the run fails—and again, with a different error. By this time, you should under-\nstand how TDD works. Writing the tests first lets you progress in small, incremental\nloops driven by tests. You test a little and then code a little.\n This example was a bit far-fetched. In the real world, you wouldn’t wait for Cucum-\nber to notify you if you knew an implementation of an object was missing. Experi-\nenced programmers can sense how much code is needed from the outset and write\nthe final methods on their first try. Now that you know how TDD works, you can skip\nthe incremental changes and go straight to working implementation code.\n Following is the working implementation of the Client object.\nclass Client\ndef initialize(name:)\n@name = name\nend\ndef name\n@name\nend\ndef account=(account)\nListing A.12\nExpended Client object with an account= method\nListing A.13\nfeatures/implementation/client.rb\n\n\n263\nExecuting the working specification\n@account = account\nend\ndef account\n@account\nend\nend\nAnd here’s the working implementation for the Account object.\nclass Account\ndef initialize\n@balance = 0\nend\ndef balance\n@balance\nend\ndef balance=(balance)\n@balance = balance\nend\ndef deposit(transfer)\n@balance += transfer\nend\nend\nWith these two objects, you can expect your next Cucumber run to work without any\nproblem. You’ll soon see if that’s true. \nA.7\nExecuting the working specification\nIf you execute cucumber again, you’ll see that the testing code works well and your sce-\nnarios pass (I cut out the content of the scenarios to make the listing shorter):\n$ cucumber\n(...)\n1 scenario (1 passed)\n4 steps (4 passed)\n0m0.057s\nHooray! Now that the objects and tests work, you can rerun Cucumber every time you\nwant to check whether the underlying implementation code still behaves as the test-\ning code expects it to. Every time you make a change to the codebase—for example,\nwhen you introduce a new feature or fix an error in an existing feature—you can exe-\ncute the cucumber command and see if the Client and Account objects work as they\nshould. \nListing A.14\nfeatures/implementation/account.rb\n\n\n264\nCHAPTER \nExecuting specifications with Cucumber\nA.8\nExecuting scenario outlines\nIn chapter 4, you learned that a scenario outline is a template that similar scenarios\ncan share so you don’t have to repeat the same Given-When-Thens throughout your\nfeature file. Scenario outlines use more-technical elements of Gherkin’s syntax, such\nas dynamic parameters and tables with examples. In this section, we’ll explore\nwhether and how such elements change the automation process for scenario outlines.\n Let’s begin by adding a second scenario with a contrasting outcome that you can\nrewrite as an outline later. You have a scenario for deposits; the following is a scenario\nfor withdrawals.\nFeature: Bank account\nScenario: Adding money to your account\nGiven a bank account in Simona's name\nAnd that her current account balance is $0\nWhen she deposits $500\nThen the account balance should be $500\nScenario: Withdrawing money from your account\nGiven a bank account in Simona's name\nAnd that her current account balance is $500\nWhen she withdraws $500\nThen the account balance should be $0\nNow that you have two similar scenarios, you can rewrite the specification as a single\nscenario outline.\nFeature: Bank account\nScenario Outline: Managing money in your account\nGiven a bank account in Simona's name\nAnd that her current account balance is <balance>\nWhen she <action>\nThen the account balance should be <result>\nExamples:\n| balance | action\n| result |\n| $0\n| deposits $500\n| $500\n|\n| $500\n| withdraws $500 | $0\n|\nHaving done that, run Cucumber to check whether the tests pass or break:\n$ cucumber\n(...)\n2 scenarios (1 undefined, 1 passed)\n8 steps (1 skipped, 1 undefined, 6 passed)\nListing A.15\nAdding a withdrawal scenario to the executable specification\nListing A.16\nTwo similar scenarios reframed as a single scenario outline\n\n\n265\nExecuting scenario outlines\n0m0.009s\nYou can implement step definitions for undefined steps with these snippets:\nWhen(/^she withdraws \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nCucumber generated a snipper for a pending step definition. That’s because the new\nwithdrawal scenario only changed the main action of the scenario from a deposit to a\nwithdrawal.\n Let’s add the snippet to features/step_definitions/account.rb and write the testing\ncode that will be run upon execution.\nWhen(/^she withdraws \\$(\\d+)$/) do |arg1|\n@simona.account.withdraw(arg1.to_i)\nend\nThis code is similar to the code you wrote for the deposit step back in section A.4.3.\nYou just changed the deposit method in the Account object to a new withdraw\nmethod that will handle withdrawals.\n You know what will happen if you run Cucumber: you’ll see a NoMethodError\nexception, because the Account object doesn’t yet know how to handle withdrawals.\nLet’s take care of this now.\nclass Account\ndef initialize\n@balance = 0\nend\ndef balance\n@balance\nend\ndef balance=(balance)\n@balance = balance\nend\ndef deposit(transfer)\n@balance += transfer\nend\ndef withdraw(transfer)\n@balance -= transfer\nend\nend\nThe implementation of the withdraw method is the opposite of the deposit method.\nIt should make the tests run successfully, though. Let’s see if that’s true:\nListing A.17\nTesting code for the step definition added in the outline\nListing A.18\nAdding the withdraw method to the Account object\n\n\n266\nCHAPTER \nExecuting specifications with Cucumber\n$ cucumber\nFeature: Bank account\nScenario Outline: Managing money in your account\n➥# features/outline.feature:3\nGiven a bank account in Simona's name\n➥# features/outline.feature:5\nAnd that her current account balance is <balance>\n➥# features/outline.feature:6\nWhen she <action>\n➥# features/outline.feature:7\nThen the account balance should be <result>\n➥# features/outline.feature:8\nExamples:\n| balance | action\n| result |\n| $0\n| deposits $500\n| $500\n|\n| $500\n| withdraws $500 | $0\n|\n2 scenarios (2 passed)\n8 steps (8 passed)\n0m0.011s\nThat’s it. The examples passed! Even though you may have suspected that the pro-\ngrammatic elements of scenario outlines, such as dynamic parameters and tables,\nwould complicate your code in the automation layer, the testing process looked the\nsame. Cucumber goes through the parameters before execution and generates new\nscenarios out of the scenario outlines—and only then are the scenarios executed.\nThat’s why you didn’t have to change anything in the step definitions from previous\nsections. \nA.9\nTesting systems end to end with Capybara\nIn this appendix, you’ve used Cucumber to write unit tests because they’re short and\neasy to learn. But in the testing community, Cucumber is typically associated with\nusing Capybara for an end-to-end system testing.\nDEFINITION\nCapybara—An integration testing tool for web applications. Capy-\nbara helps you test web applications by simulating how a real user would inter-\nact with your app.\nYou can even configure Capybara to run Firefox or Chrome on your machine as a test\ndriver in order to watch Cucumber click over the simulated user interface when it\ntests the system. The main benefit is that such tests check the system end to end, forc-\ning it to integrate different elements such as the domain layer, API calls, and the user\ninterface. The main drawback is that end-to-end testing is slow and performance\nheavy. In the banking example, the unit tests took 0.011 seconds; a single end-to-end\nintegration test can take up to 30 seconds, depending on how many screens you want\nto test in a single run.\n\n\n267\nTesting systems end to end with Capybara\n We won’t be analyzing a Capybara end-to-end example in this appendix. To do so,\nyou’d need to create a fully working web application—a task that’s definitely beyond\nthe scope of this book. Besides, other resources such as The Cucumber Book, referenced\nearlier, can help you learn more about end-to-end testing. What you can do, though, is\nrewrite one step definition to see what a test using Capybara looks like.\nWhen(/^she deposits \\$(\\d+)$/) do |arg1|\nclick_link \"Deposit\"\nfind(\"input#deposit\", match: :first).set arg1\nclick_button \"Deposit\"\nend\nCapybara provides a new set of methods such as click_link, find, and click_button\nthat you can use to interact with the user interface.\n As of version 5.1, Ruby on Rails has Capybara working out of the box as the default\nsolution for system tests. You get a Capybara wrapper that’s preconfigured for Chrome\nand enhanced to provide failure screenshots as part of Action Dispatch. Different\nframeworks in other programming languages have their own equivalents of Capybara.\n Even if your language doesn’t provide something like Capybara, you can use the\noriginal Ruby version and write Cucumber tests in Ruby that will check your applica-\ntion written in any other language. This is possible because Capybara only interacts\nwith the user interface, so you only have to run a web server behind the scenes that\ncan serve a simulation of your web application. As long as you do that, you’ll be fine. \nListing A.19\nWhen step rewritten to use Capybara\n\n\n269\nA\nabilities 177–181\nchoosing granularity level for 180–181\norganizing specification suite with 179–180\nrefactoring business needs into 208–212\nrefactoring features into 196–203\nadding scenarios over time 198–200\nderiving new scenarios from user \nstories 197\nsplitting features into small abilities 200–203\nstarting with simple features 197–198\nreworking features into 178–179\nAbility keyword 45\nabstraction levels, choosing 71–73\ndisadvantages of over specifying 71–72\nsuggested number of steps in scenarios 72–73\nacceptance criteria\ndefining 5–6\nvetting with examples 75\nacceptance tests 12, 35\nactions in scenarios, naming 159\nactive life cycle 146\nactors\ndefining in scenarios 58–60\nin scenarios 159\nadvanced filtering 116\nadverbs 62\nagile 10\nall-team specification workshops 164\nanalysis paralysis 8\nanalytics domain 230\nanalyzing requirements with examples 130–136\ncollecting examples 133–135\nconveying requirements as user stories\n130–133\nrefining user stories with examples 135–136\nAnd keyword 44\nangle brackets 87\nangry path 108\nanti-patterns, avoiding 114–120\nclasses of equivalence 119–120\ndatabase models 117–119\nsimple combinatorial outcomes 114–117\ntypical data validations 114\napplication security events 236\napplication security team 196\nassertions 258\naudience, for living documentation 166–169\nautomata-machines 12\nautomating\nconversations 14\nbenefits of 19–22\ntests based on examples 19–20\nautomation framework 36\nautomation layers 34–37\ninteracting with specification layers 47–51\noverview 32–34\nB\nbackgrounds, reusing Givens with 69–71\nbacklog, Scrum 184\nBAD listings 32\nBDD (behavior-driven development) 258\nbehavioral requirements 23\nBEST listings 32\nboomerangs 111–113\nbounded contexts\nanalyzing domain concepts in context\n235–241\ndealing with false cognates 237–239\nspotting duplicate concepts 239–241\nspotting false cognates 236–237\nindex\n\n\n270\nINDEX\nbounded contexts (continued)\nfitting DDD into SBE process 248–249\nmodeling specification suites as 241–247\ndrawing context maps 246–247\nmanaging bounded contexts with context \nmaps 245–246\noverview 241–242\nsplitting large specification suite into multi-\nple bounded contexts 242–245\nbounding sides 156\nbuilding living documentation 12\nBusiness Need keyword 45, 189–190\nbusiness needs\nadding functional scenarios to 204–206\nidentifying new stakeholders with 207–208\nidentifying with conversations\nderiving scope from goals 15–16\nillustrating requirements with examples\n16–18\nspecifying collaboratively 18\nrefactoring into abilities 208–212\nbusiness rules, organizing feature files by 89–90\nBut keyword 44\nC\ncapturing conversations 14\nCapybara, testing systems with 266–267\ncarryover customer 135\nchunking up/down 63\nCI (continuous integration) 21, 143\nCISO (Chief Information Security Officer) 207\nclasses, of equivalence 119–120\nclick_link method 267\ncloud domain 79\ncloud drive 217\ncloud features 77\ncode refactoring 94\ncollaborative specification 18\ncollecting examples\nfor outside-in scenario outlines 100\noverview 133–135\ncombinatorial outcomes 114–117\ncompiling 51\ncontent 162\ncontext maps\ndrawing 246–247\nmanaging bounded contexts with 245–246\ncontext notes 160–161\ncontexts, exploring by questioning Givens 75–76\ncontextual glossary 237\ncontinuous deployment 143\nconversations\nbenefits of automating 19–22\nautomating tests based on examples 19–20\nliving documentation 21–22\nvalidating frequently 21\nidentifying business needs with 14–18\nderiving scope from goals 15–16\nillustrating requirements with examples\n16–18\nspecifying collaboratively 18\nConway's Law 163\ncore domain 219, 236\ncorridor testing 73\ncounterexamples 106–107\ncreating events 199\ncriteria, acceptance 75\ncritiquing feedback 123\ncritiquing stage 134\ncucumber --init command 254\nCucumber, executing specifications with\nconfiguring environment 253–254\nexecuting scenario outlines 264–266\nexecuting the working specification 263\npreparing scenarios for automation 254–255\ntest-driven development 251–252\ntesting systems end to end with Capybara\n266–267\nunit tests 252–253\nwriting implementation code based on tests\n259–263\nwriting tests in test-driven manner 256–259\nCukeHub 22\nD\ndata\ngathering 61–62\nvalidations 114\ndatabase models 117–119\nDDD (domain-driven design)\nfitting into SBE process 248–249\noverview 215, 235\ndecentralization 245\ndeclarative style 63\ndefinitions by example 157\ndelinquent path 109\ndesigning acceptance tests 12\ndesolate path 109\ndestination 154\ndistilling business domains\ncore domain from scenarios 218–219\ncreating domain model from distilled domains\n221–224\nimportance of good models 222–223\nspecification suite 221–223\nwhat makes good domain model 224\nspotting different domains in scenarios\n216–218\n\n\n271\nINDEX\ndistilling business domains (continued)\nsubdomains accompanying core domain\n219–220\nsubdomains from mixed scenarios 226–228\nsubdomains from other scenarios 228–230\nsubdomains from unequivocal scenarios\n225–226\ndocumentation. See living documentation\ndomain concepts, naming 158–160\nactions in scenarios 159\nactors that appear in scenarios 159\nstates in which scenarios begin and end\n159–160\ndomain experts 7\ndomain model 7, 221\ndomain-driven design. See DDD\ndomain-driven specification suite, building\ncreating domain model from distilled \ndomains 221–224\nimportance of good models 222–223\nspecification suite 221–223\nwhat makes good domain model 224\ncreating specification suite from distilled \ndomains 230–231\ndistilling business domains 215–220\ncore domain from scenarios 218–219\nspotting different domains in scenarios\n216–218\nsubdomains accompanying core \ndomain 219–220\nsubdomains from mixed scenarios 226–228\nsubdomains from other scenarios 228–230\nsubdomains from unequivocal \nscenarios 225–226\ndomain-specific examples 104–106\nDRY (Don’t Repeat Yourself) 88, 99\ndummies 98\ndummy data 98\nduplicate concepts 240\nE\nembarrassing path 108\nend users 60\nend-to-end tests 62\nequivalence, classes of 119–120\nevents domain 227\nevents team 196\nevolving requirements 125\nexample-counterexample 83\nexamples\nanalyzing requirements with 130–136\ncollecting examples 133–135\nconveying requirements as user stories\n130–133\nrefining user stories with examples 135–136\nautomating tests based on 19–20\nchoosing for scenario outlines\navoiding scenario outline anti-patterns\n114–120\nshopping application example 99\nwriting outside-in scenario outlines 99–102\ncollecting 100, 133–135\nderiving scenarios from 137–139\ndomain-specific 104–106\nillustrating requirements with 16–18\nrefining user stories with 135–136\nvetting acceptance criteria with 75\nwriting outside-in scenario outlines from\n101–102\nSee also key examples\nExamples tables\nin scenario outlines 86\noverview 100\nexecutable scenarios, user stories and 183–184\nexecutable specifications\nlayers of 32–37\nautomation layers 34–37\nspecification layers 33–34\nlife cycle of\nanalyzing requirements with examples\n130–136\nderiving scenarios from examples 137–139\nend-to-end overview 126–127\niterating specifications over time 141–146\nrefining scenarios 139–141\nunderstanding business goals 127–129\nexhaustive examples 102\nexhaustive testing 102\nexpect syntax, RSpec 259\nexpected state 159\nexploratory outcomes 107–111, 136\nangry path 108\ndelinquent path 109\ndesolate path 109\nembarrassing path 108\nexamples of 109–111\nforgetful path 109\ngreedy path 109\nhappy path 108\nindecisive path 109\nscary path 108\nstressful path 109\nF\nfailure scenario 88\nfalse cognates 236\ndealing with 237–239\nspotting 236–237\n\n\n272\nINDEX\nfeature files 34, 175\norganizing by high-level business rules 89–90\nshorter with scenario outlines 89\nfeature injection format 182\nFeature keyword 38–39, 45, 175, 178\nfeatures\norganizing scenarios by 175–176\nrefactoring into abilities 196–203\nadding scenarios over time 198–200\nderiving new scenarios from user stories 197\nsplitting features into small abilities 200–203\nstarting with simple features 197–198\nreworking into abilities 178–179\nfeedback loops 35, 152, 224\nfiction 10\nfiltering advanced 116\nFitNesse 36\nFive Whys technique 113\nforgetful path 109\nfragments 250\nfunctional requirements 186\nG\ngathering realistic data 61–62\ngem install cucumber command 253\ngenus-differentia definition 156\nGherkin language\noutside-in development with 56–61\ndefining actors in scenarios 58–60\nuser-oriented scenarios 56–58, 60–61\nSBE and\nbenefits of automating conversations 19–22\nbenefits of specifications 4–7\ncreating software with 25–27\nidentifying business needs with conversations\n14–18\nintroduction to 11–14\nproblems with specifications 8–11\nspecifications, defined 4\nscenarios 38–43, 64–77\nchoosing abstraction levels 71–73\nchoosing styles for 55–64\nexploring contexts by questioning Givens\n75–76\nexploring outcomes by questioning Thens\n76–77\nFeature keyword 38–39\nGivens 40–41\nScenario line 39–40\nspecifying prerequisites with Givens 67–71\nspotting redundancies in 82–84\nstarting with Thens 64–65\nThens 42–43\nusing one When per scenario 65–67\nvetting acceptance criteria with examples 75\nWhens 42\nwriting warm-up narratives 74–75\nGivens 40–41\ndefining prerequisites with 256–257\nexploring contexts by questioning 75–76\nreusing with backgrounds 69–71\nspecifying prerequisites with 67–71\nGiven-When-Then templates\nchoosing styles for Gherkin scenarios 55–64\ngathering realistic data 61–62\noutside-in development with Gherkin 56–61\nspecifying intentions and outcomes 62–64\nwriting Gherkin scenarios 64–77\nchoosing abstraction levels 71–73\nexploring contexts by questioning Givens\n75–76\nexploring outcomes by questioning Thens\n76–77\nspecifying prerequisites with Givens 67–71\nstarting with Thens 64–65\nusing one When per scenario 65–67\nvetting acceptance criteria with examples 75\nwriting warm-up narratives 74–75\nglobal definitions 155\nglossaries, living documentation 158\ngoals\nderiving scope from 15–16\nof businesses 127–129\nGoldilocks principle 120\nGOOD listings 32\ngreedy path 109\ngrowing scenario outlines 90–94\nH\nhand-offs 8–9\nhappy paths 47, 108, 136\nhigh-level composition 64\nHouseKeeper 150, 161\nI\nidentifying business needs with conversations\nderiving scope from goals 15–16\nillustrating requirements with examples 16–18\nspecifying collaboratively 18\nidentity context 244\nillustrative definitions, writing 156–157\nillustrative testing 103\nimpact map 128\nimperative style 63\nindecisive path 109\ninformation asymmetry 5, 165\n\n\n273\nINDEX\ninitial state 159\nintense domain exercises 164\nintentions, specifying 62–64\ninterface-oriented style 63\niterating specifications 141–146\nevolving documentation systems 144–146\nvalidating specification suites 141–144\niterative documentation 166\nJ\nJBehave 36, 176\nK\nkey examples, finding for scenario outlines\n102–113\nboomerangs 111–113\ncounterexamples 106–107\ndomain-specific examples 104–106\nexploratory outcomes 107–111\nkey process patterns 13–14\nkeywords 44, 169\nKPIs (key performance indicators) 173, 228\nL\nlanguages, building 6–7\nlarge suites 235\nlayers, of executable specifications 32–37\nSee also automation layers; specification layers\nlexical definitions\noverview 170\nwriting 154–156\nlife cycle 125\nliving documentation\naudience for 166–169\ncreating 163–166\nthrough all-team specification workshops\n164\nthrough individual people 165–166\nthrough Three Amigos meetings 164–165\ndocumenting decisions using briefs 160–161\ncontext notes 160–161\nmaintenance notes 161\nwarning notes 160\nin example 150–153\nnaming important domain concepts 158–160\nactions in scenarios 159\nactors that appear in scenarios 159\nstates in which scenarios begin and end\n159–160\nprocess overview 161–163\nusing glossaries 158\nwriting 153–154\nwriting illustrative definitions 156–157\nwriting lexical definitions 154–156\nlocal definitions 155\nlow-level composition 64\nM\nmaintaining scenario outlines 90–94\nmaintenance notes 161\nMapper project 127\nmaps 60\nmarketing myopia 65\nmerging examples 81\nmessages 161\nmeta-note 161\nmethodologies 26\nMQRs (minimally qualified readers) 166–169\nN\nNameError 260\nNarrative keyword 177\nnarrative section, JBehave 176\nnarratives, warm-up 74–75\nnegative outcomes 46\nnew scenarios 184\nNoMethodError 265\nnonfunctional requirements 186–193\nBusiness Need keyword 189–190\ndealing with according to SBE 187–188\nwhether Gherkin scenarios can specify 188–189\nnotes\ncontext notes 160–161\nmaintenance notes 161\nwarning notes 160\nO\nOK listings 32\norganizing scenarios. See scenarios, organizing\noutcome questioning 76, 218\noutcome-oriented style 63\noutcomes\ncombinatorial 114–117\ncommon 181\nexploratory 107–111\nangry path 108\ndelinquent path 109\ndesolate path 109\nembarrassing path 108\nexamples of 109–111\nforgetful path 109\ngreedy path 109\n\n\n274\nINDEX\noutcomes, exploratory (continued)\nhappy path 108\nindecisive path 109\nscary path 108\nstressful path 109\nexploring by questioning Thens 76–77\nspecifying 62–64\ntesting 45–47\noutlines. See scenario outlines\noutside-in development, with Gherkin 56–61\ndefining actors in scenarios 58–60\nuser-oriented scenarios 56–58, 60–61\noutside-in scenario outlines, writing 99–102\ncollecting examples for 100\nfrom collected examples 101–102\nover-specification 8\nP\npairwise testing 115\npassive life cycle 146\npasswords 190\npatterns, key process 13–14\npayments domain 79\npersonas 58\nplane figure 156\nplanning tools 185\npolysemes 158, 236\npositive outcomes 47\nposts 228\nprecision level 126\nprerequisites, specifying with Givens 67–71\nprice index 154\nQ\nquadrilateral connotative definition 155\nquality measures 5\nqueries 189\nR\nraw examples 86\nreceiver 162\nred-green-refactor 252\nredundancies, spotting in Gherkin scenarios\n82–84\nrefactoring code 94\nrefactoring redundant scenarios 84–86\nrefine scenarios 139\nrefining\nscenarios 139–141\nuser stories with examples 135–136\nregression tests 153\nRelish 22\nremoving examples 81\nrequirements\nanalyzing with examples 130–136\ncollecting examples 133–135\nrefining user stories with examples 135–136\nconveying as user stories 130–133\nrestricted keyword 44\nreusing Givens with backgrounds 69–71\nRspec 258\nrspec-expectations library 258\nS\nSBE (specification by example)\ndealing with nonfunctional requirements \naccording to 187–188\nfitting DDD into process 248–249\nGherkin and\nbenefits of automating conversations 19–22\nbenefits of specifications 4–7\ncapturing conversations as executable \nspecifications 22–25\ncreating software with 25–27\nidentifying business needs with conversations\n14–18\nintroduction to 11–14\nproblems with specifications 8–11\nspecifications, defined 4\nscan test 107\nscary path 108\nscenario briefs 170\nScenario keyword 45\nScenario line 39–40\nscenario outlines\nadvantages of 89–90\nfeature files organized by high-level business \nrules 89–90\nshorter feature files 89\navoiding anti-patterns 114–120\nclasses of equivalence 119–120\ndatabase models 117–119\nsimple combinatorial outcomes 114–117\ntypical data validations 114\nchoosing examples for\navoiding scenario outline anti-patterns\n114–120\nwriting outside-in scenario outlines 99–102\ndisadvantages of 95\nfinding key examples for 102–113\nboomerangs 111–113\ncounterexamples 106–107\ndomain-specific examples 104–106\nexploratory outcomes 107–111\ngrowing and maintaining 90–94\n\n\n275\nINDEX\nscenario outlines (continued)\noutside-in, writing 99–102\nrefactoring redundant scenarios with 84–86\nshopping application example 81–82, 99\nstructure of 86–88\nExamples tables 86\nparameters 87–88\nScenario Outline keyword 88\nusing 82–86\nrefactoring redundant scenarios with sce-\nnario outlines 84–86\nspotting redundancies in Gherkin scenarios\n82–84\nscenarios\ndefining actors in 58–60\nderiving from examples 137–139\nin Gherkin\nchoosing styles for 55–64\nspotting redundancies in 82–84\norganizing\nby features 175–176\nby user stories 176–186\nabilities 177–181\nexecutable specifications and 183–184\niterative dangers of 184–186\nstructure of 182\nnonfunctional requirements 186–193\nBusiness Need keyword 189–190\ndealing with according to SBE 187–188\nwhether Gherkin scenarios can specify\n188–189\npreparing for automation 254–255\nredundant, refactoring with scenario outlines\n84–86\nrefining 139–141\nsimplifying 71–72\nsplitting 175, 181\nstructure of 43–45\nsuggested number of steps in 72–73\nuser-oriented\noutside-in development and 60–61\nwriting 56–58\nwriting in Gherkin 38–43, 64–77\nchoosing abstraction levels 71–73\nexploring contexts by questioning Givens\n75–76\nexploring outcomes by questioning Thens\n76–77\nFeature keyword 38–39\nGivens 40–41\nScenario line 39–40\nspecifying prerequisites with Givens 67–71\nstarting with Thens 64–65\nThens 42–43\nusing one When per scenario 65–67\nvetting acceptance criteria with examples 75\nWhens 42\nwriting warm-up narratives 74–75\nSee also scenario outlines\nscheduling events 199\nscope boundaries 177\nscope, deriving from goals 15–16\nscope-exploration exercises 164\nscreening 154\nScrum 184\nsender 162\nserial events 199\nservices 244\nshipping methods 93\nSimona scenario 58\nsimple outcomes 115\nsimplifying scenarios 71–72\nsimulations 35\nsingle sign-on. See SSO\nsingle source of failure 165\nsingle source of truth 165\nsmall characteristics 10\nsnapshots 68\nsoftware\ncreating with Gherkin 25–27\ncreating with SBE 25–27\nsource 61\nspecification briefs 38, 170\nspecification by example. See SBE\nspecification layers\ninteracting with automation layers 47–51\noverview 33–34\nspecification suites\nmodeling as bounded contexts 241–247\ndrawing context maps 246–247\nmanaging bounded contexts with context \nmaps 245–246\noverview 241–242\nsplitting large specification suite into multi-\nple bounded contexts 242–245\nvalidating 141–144\nspecification workshops, all-team 164\nspecifications\nbenefits of 4–7\nbuilding ubiquitous languages 6–7\ndefining acceptance criteria 5–6\ndefined 4\nexecuting with Cucumber\nconfiguring environment 253–254\nexecuting scenario outlines 264–266\nexecuting working specification 263\npreparing scenarios for automation 254–255\ntest-driven development 251–252\ntesting systems with Capybara 266–267\n\n\n276\nINDEX\nspecifications, executing with Cucumber\n(continued)\nunit tests 252–253\nwriting implementation code based on tests\n259–263\nwriting tests in test-driven manner 256–259\niterating 141–146\nevolving documentation systems 144–146\nvalidating specification suites 141–144\nproblems with 8–11\nhand-offs 8–9\nover-specification 8\nspeci-fiction 10\ntest-inability 10–11\nunder-documentation 9–10\nSee also executable specifications\nspeci-fiction 10\nsplitting scenarios 175, 181\nSSO (single sign-on) 207\nstakeholder management 189\nstakeholders 60\nstandard processes 106\nstate of the system 101\nstates, naming 159–160\nstep definitions\nmatching steps with 48–51\noverview 47–48\nstep method 256–257\nsteps\nmatching with step definitions 48–51\nstructure of 43–45\nsuggested number in scenarios 72–73\nstrategic design 247\nstrategic domain-driven design 215\nstressful path 109\nstructure, of scenario outlines 86–88\nExamples tables 86\nparameters 87–88\nScenario Outline keyword 88\nstyles, choosing for Gherkin scenarios 55–64\ngathering realistic data 61–62\noutside-in development with Gherkin 56–61\nspecifying intentions and outcomes 62–64\nsubdomains 219\nsuccess scenario 88\nsupporting feedback 123\nT\ntargeting 201\nTDD (test-driven development) 251\nteam leadership 197\nteam member 41\ntechnological ability 136\ntemplates. See Given-When-Then templates\ntenant leads 154\ntenants pipeline 150\ntest execution engine 36\ntest runner 36, 253\ntest safely 102\ntest suite 35\ntest-inability 10–11\ntesting\nautomating based on examples 19–20\nframework 36\nheuristics 102\noutcomes 45–47\nsystems, with Capybara 266–267\nThens\nexploring outcomes by questioning 76–77\noverview 42–43\ntesting consequences with 258–259\nto begin composing scenarios 64–65\nThree Amigos meetings 164–165\nticket for conversation 183\ntriangle connotative definition 155\ntrigger 132\ntwo-factor authentication 188\nU\nUAT (user acceptance testing) 144\nubiquitous language 33, 154\nUI (user interface), favoring specifying intentions \nand outcomes over 62–64\nuncouple domains 217\nundefined test results 255\nunder-documentation 9–10\nunhappy paths 136\nunification 224\nunit of work 252\nunits 156\nuser journey map 60\nuser stories\nanalyzing 196\nconveying requirements as 130–133\norganizing scenarios by 176–186\nabilities 177–181\nexecutable specifications and user \nstories 183–184\niterative dangers of 184–186\nstructure of 182\nrefining with examples 135–136\nuser-oriented scenarios\noutside-in development and 60–61\nwriting 56–58\n\n\n277\nINDEX\nV\nvalidating\nfrequently 21\nspecification suites 141–144\nvaluable characteristics 10\nvetting acceptance criteria with examples 75\nW\nwarm-up narratives, writing 74–75\nwarning notes 160\nWhens\noverview 42\ntaking actions with 257–258\nusing one per scenario 65–67\nwriting\ndocumentation 153–154\noutside-in scenario outlines 99–102\ncollecting examples for 100\nfrom collected examples 101–102\nscenarios in Gherkin 38–43, 64–77\nchoosing abstraction levels 71–73\nexploring contexts by questioning Givens\n75–76\nexploring outcomes by questioning Thens\n76–77\nFeature keyword 38–39\nGivens 40–41\nScenario line 39–40\nspecifying prerequisites with Givens 67–71\nstarting with Thens 64–65\nThens 42–43\nusing one When per scenario 65–67\nvetting acceptance criteria with examples 75\nWhens 42\nwriting warm-up narratives 74–75\nwarm-up narratives 74–75\n\n\nMORE TITLES FROM MANNING\nFor ordering information go to www.manning.com\nSpecification by Example\nHow Successful Teams Deliver the Right Software\nby Gojko Adzic\nISBN: 9781617290084\n296 pages\n$49.99\nJune 2011\nBDD in Action\nBehavior-Driven Development for the whole software lifecycle\nby John Ferguson Smart\nISBN: 9781617291654\n384 pages\n$49.99\nSeptember 2014\nTest Driven\nPractical TDD and Acceptance TDD for Java Developers\nby Lasse Koskela\nISBN: 9781932394856\n544 pages\n$44.99\nAugust 2007\n\n\nMORE TITLES FROM MANNING\nFor ordering information go to www.manning.com\nJava Testing with Spock\nby Konstantinos Kapelonis\nISBN: 9781617292538\n304 pages\n$44.99\nMarch 2016\nThe Art of Unit Testing, Second Edition\nwith examples in C#\nby Roy Osherove\nISBN: 9781617290893\n296 pages\n$44.99\nNovember 2013\nEffective Unit Testing\nA guide for Java developers\nby Lasse Koskela\nISBN: 9781935182573\n258 pages\n$39.99\nFebruary 2013\n\n\nMORE TITLES FROM MANNING\nFor ordering information go to www.manning.com\nKanban in Action\nby Marcus Hammarberg and Joakim Sundén\nISBN: 9781617291050\n360 pages\n$44.99\nFebruary 2014\nThe Mikado Method\nby Ola Ellnestam and Daniel Brolund\nISBN: 9781617291210\n240 pages\n$44.99\nMarch 2014\nRe-Engineering Legacy Software\nby Chris Birchall\nISBN: 9781617292507\n232 pages\n$64.99\nApril 2016\n\n\nBest practices in the book\n \nBest practice\nSection\nDon’t let agile be an excuse to ignore documentation.\n1.3.3\nDon’t let documentation replace communication.\n1.3.2\nDerive scope from goals.\n1.5.1\nIllustrate requirements with examples.\n1.5.2\nSpecify collaboratively.\n1.5.3, 7.4\nValidate frequently.\n1.6.2\nCapture behavioral requirements with scenarios.\n2.2.2\nGather examples from the real world.\n3.1.2\nFavor specifying intentions and outcomes over user interface.\n3.1.3\nStart writing scenarios with the Then keyword.\n3.2.1\nAim for one When keyword per scenario.\n3.2.3\nDon’t use backgrounds.\n3.2.3\nAim for as few Givens, Whens, and Thens as possible.\n3.2.4\nRefactor redundant scenarios with scenario outlines.\n4.2.2\nWrite scenario outlines from examples.\n5.2\nRefine scenarios by keeping only key examples.\n5.3\nAvoid examples of simple combinatorial outcomes.\n5.4.2\nHide the database layer.\n5.4.3\nAvoid classes of equivalence.\n5.4.4\nDocument domain concepts in briefs.\n7.2.1\nWrite documentation for the minimally qualified reader.\n7.5\nUse the Ability keyword to specify functional user stories.\n8.2.1\nUse the Business Need keyword to specify nonfunctional user stories.\n8.3.3\nBreak big business needs into smaller abilities.\n9.3.3\nBuild a domain-driven specification suite.\n10.3\nSplit a large specification suite into multiple bounded contexts.\n11.2\n\n\n$44.99 / Can $59.99  [INCLUDING eBOOK]\nKamil Nicieja\nT\nhe clearest way to communicate a software speciﬁ cation is \nto provide examples of how it should work. Turning these \nstory-based descriptions into a well-organized dev plan is \nanother matter. Gherkin is a human-friendly, jargon-free lan-\nguage for documenting a suite of examples as an executable \nspeciﬁ cation. It fosters efﬁ cient collaboration between business \nand dev teams, and it’s an excellent foundation for the speciﬁ ca-\ntion by example (SBE)  process.\nWriting Great Specifications teaches you how to capture execut-\nable software designs in Gherkin following the SBE method. \nWritten for both developers and non-technical team members, \nthis practical book starts with collecting individual feature sto-\nries and organizing them into a full, testable spec. You’ll learn to \nchoose the best scenarios, write them in a way that anyone can \nunderstand, and ensure they can be easily updated by anyone. \nWhat’s Inside\n● Reading and writing Gherkin\n● Designing story-based test cases\n● Team collaboration\n● Managing a suite of Gherkin documents\nPrimarily written for developers and architects, this book is \naccessible to any member  of a software design team.\nKamil Nicieja is a seasoned engineer, architect, and project man-\nager with deep expertise in Gherkin and SBE.\nTo download their free eBook in PDF, ePub, and Kindle formats, \nowners of this book should visit \nwww.manning.com/books/writing-great-specifications\nWRITING GREAT SPECIFICATIONS\nSOFTWARE ENGINEERING\nM A N N I N G\n“\nDoes a great job taking \nconcepts from good architec-\ntural practices and applying \nthem to the world of collab-\norative speciﬁ cations.”\n \n—From the Foreword by \n    Gojko Adžic, author of \n    Speciﬁ cation by Example \n“\nThe missing manual for \nwriting great speciﬁ cations. \nI wish this book had existed \nﬁ ve years ago!”\n \n—Craig Smith, Unbound DNA\n“\nWill jolt you into best \npractices, give you fresh \nperspectives, and reinvigorate \nyour commitment to this \nbusiness-critical skill.”\n \n—Dane Balia, Hetzner\n“\nThe complete book on \nhow to write great speciﬁ ca-\ntions. Most of us know bits \nand pieces, but to truly grok \nit, you need this excellent \nguide.”\n—Kumar Unnikrishnan\n    Thomson Reuters \nSEE  INSERT\n´\n",
      "page_number": 262
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "content": "M A N N I N G\nKAMIL NICIEJA\nFOREWORD BY GOJKO ADŽIC´\n",
      "content_length": 53,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 2,
      "content": "A complete list of Gherkin keywords and their synonyms\n \nKeyword\nSynonyms\nDescription\nFeature\nBusiness Need, Ability\nBegins a Gherkin file\nBackground\nRuns steps before scenarios\nScenario\nStarts a new scenario\nScenario Outline\nScenario Template\nStarts a new scenario with multi-\nple examples\nGiven\n*, And, But\nPuts the system in a predefined \nstate\nWhen\n*, And, But\nPerforms an action\nThen\n*, And, But\nTests for consequences\nExamples\nScenarios\nLists examples for scenario out-\nlines\n",
      "content_length": 482,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 3,
      "content": "Writing Great Specifications\n",
      "content_length": 29,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 5,
      "content": "Writing\nGreat Specifications\nUSING SPECIFICATION\nBY EXAMPLE AND GHERKIN\nKAMIL NICIEJA\nFOREWORD BY GOJKO ADŽIC´\nM A N N I N G\nSHELTER ISLAND\n",
      "content_length": 140,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 6,
      "content": "For online information and ordering of this and other Manning books, please visit\nwww.manning.com. The publisher offers discounts on this book when ordered in quantity. \nFor more information, please contact\nSpecial Sales Department\nManning Publications Co.\n20 Baldwin Road\nPO Box 761\nShelter Island, NY 11964\nEmail: orders@manning.com\n©2018 by Manning Publications Co. All rights reserved.\nNo part of this publication may be reproduced, stored in a retrieval system, or transmitted, in \nany form or by means electronic, mechanical, photocopying, or otherwise, without prior written \npermission of the publisher.\nMany of the designations used by manufacturers and sellers to distinguish their products are \nclaimed as trademarks. Where those designations appear in the book, and Manning \nPublications was aware of a trademark claim, the designations have been printed in initial caps \nor all caps.\nRecognizing the importance of preserving what has been written, it is Manning’s policy to have \nthe books we publish printed on acid-free paper, and we exert our best efforts to that end. \nRecognizing also our responsibility to conserve the resources of our planet, Manning books\nare printed on paper that is at least 15 percent recycled and processed without the use of \nelemental chlorine.\nManning Publications Co.\nDevelopment editor: Marina Michaels\n20 Baldwin Road\nTechnical development editors: Alain Couniot \nPO Box 761\nand Jonathan Thoms\nShelter Island, NY 11964\nReview editor: Aleksandar Dragosavljevic´\nProject editor: Tiffany Taylor\nCopyeditor: Tiffany Taylor\n \nProofreader: Katie Tennant\nTechnical proofreader: Alessandro Campeis\nTypesetter: Dottie Marsico\nCover designer: Marija Tudor\nISBN 9781617294105\nPrinted in the United States of America\n1 2 3 4 5 6 7 8 9 10 – EBM – 22 21 20 19 18 17\n",
      "content_length": 1800,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 7,
      "content": "v\nbrief contents\n1\n■\nIntroduction to specification by example and Gherkin\n1\nPART 1\n WRITING EXECUTABLE SPECIFICATIONS WITH EXAMPLES 29\n2\n■\nThe specification layer and the automation layer\n31\n3\n■\nMastering the Given-When-Then template\n54\n4\n■\nThe basics of scenario outlines\n80\n5\n■\nChoosing examples for scenario outlines\n97\n6\n■\nThe life cycle of executable specifications\n123\n7\n■\nLiving documentation\n148\nPART 2\nMANAGING SPECIFICATION SUITES 171\n8\n■\nOrganizing scenarios into a specification suite\n173\n9\n■\nRefactoring features into abilities and business needs\n195\n10\n■\nBuilding a domain-driven specification suite\n213\n11\n■\nManaging large projects with bounded contexts\n234\n",
      "content_length": 673,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 9,
      "content": "vii\ncontents\nforeword\nxiii\npreface\nxv\nacknowledgments\nxviii\nabout this book\nxx\nabout the cover\nxxiii\n1 Introduction to specification by example and Gherkin\n1\n1.1\nWhat’s a specification?\n4\n1.2\nWhy do teams need specifications?\n4\nDefining acceptance criteria in specifications\n5\n■Building a \nubiquitous language into specifications\n6\n1.3\nCommon specification pitfalls\n8\nOver-specification\n8\n■Hand-offs\n8\n■Under-documentation\n9\nSpeci-fiction\n10\n■Test-inability\n10\n1.4\nMeet specification by example and Gherkin\n11\nKey process patterns\n13\n1.5\nHaving conversations that identify business needs\n14\nDeriving scope from goals\n15\n■Illustrating requirements with \nexamples\n16\n■Specifying collaboratively\n18\n1.6\nLong-term benefits of automating conversations\n19\nAutomating tests based on examples\n19\n■Validating \nfrequently\n21\n■Living documentation\n21\n1.7\nCapturing conversations as executable specifications\n22\n",
      "content_length": 900,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 10,
      "content": "CONTENTS\nviii\n1.8\nMaking software that matters\n25\n1.9\nSummary\n27\nPART 1\nWRITING EXECUTABLE SPECIFICATIONS \nWITH EXAMPLES...............................................29\n2 The specification layer and the automation layer\n31\n2.1\nThe layers of executable specifications\n32\nThe specification layer\n33\n■The automation layer\n34\n2.2\nWriting your first Gherkin scenario\n38\nFeature\n38\n■Scenario\n39\n■Given\n40\n■When\n42\nThen\n42\n2.3\nUnderstanding the structure of steps and scenarios\n43\n2.4\nTesting different outcomes\n45\n2.5\nHow the automation and specification layers interact\n47\nStep definitions\n47\n■Matching steps with step definitions\n48\n2.6\nFinishing the Gherkin crash course\n51\n2.7\nAnswers to exercises\n52\n2.8\nSummary\n53\n3 Mastering the Given-When-Then template\n54\n3.1\nChoosing the right style for your Gherkin scenarios\n55\nDoing outside-in development with Gherkin\n56\n■Gathering \nrealistic data\n61\n■Favor specifying intentions and outcomes \nover the user interface\n62\n3.2\nComposing Gherkin scenarios\n64\nStarting with a Then\n64\n■Using only one When per \nscenario\n65\n■Specifying prerequisites with Givens\n67\nChoosing the right abstraction level\n71\n3.3\nTelling Gherkin stories with impact\n74\nWriting warm-up narratives\n74\n■Vetting acceptance criteria \nwith examples\n75\n■Exploring contexts by questioning \nGivens\n75\n■Exploring outcomes by questioning Thens\n76\n3.4\nAnswers to exercises\n77\n3.5\nSummary\n79\n",
      "content_length": 1394,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 11,
      "content": "CONTENTS\nix\n4 The basics of scenario outlines\n80\n4.1\nExample shopping application\n81\n4.2\nUsing scenario outlines\n82\nSpotting redundancies in Gherkin scenarios\n82\n■Refactoring \nredundant scenarios with scenario outlines\n84\n4.3\nThe structure of a scenario outline\n86\nThe Examples table\n86\n■Parameters\n87\n■The Scenario \nOutline keyword\n88\n4.4\nAdvantages of scenario outlines\n89\nShorter feature files\n89\n■Feature files organized by \nhigh-level business rules\n89\n4.5\nGrowing and maintaining scenario outlines\n90\n4.6\nDisadvantages of scenario outlines\n95\n4.7\nSummary\n95\n5 Choosing examples for scenario outlines\n97\n5.1\nExample shopping application\n99\n5.2\nWriting outside-in scenario outlines\n99\nCollecting examples for outside-in scenario outlines\n100\nWriting outside-in scenario outlines from collected examples\n101\n5.3\nFinding key examples for scenario outlines\n102\nDomain-specific examples\n104\n■Counterexamples\n106\nExploratory outcomes\n107\n■Boomerangs\n111\n5.4\nAvoiding scenario outline anti-patterns\n114\nTypical data validations\n114\n■Simple combinatorial \noutcomes\n114\n■Database models\n117\n■Classes of \nequivalence\n119\n5.5\nAnswers to exercises\n121\n5.6\nSummary\n122\n6 The life cycle of executable specifications\n123\n6.1\nEnd-to-end overview of the process\n126\n6.2\nUnderstanding business goals\n127\n6.3\nAnalyzing requirements with examples\n130\nConveying requirements as user stories\n130\n■Collecting \nexamples\n133\n■Refining user stories with examples\n135\n",
      "content_length": 1446,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 12,
      "content": "CONTENTS\nx\n6.4\nDeriving scenarios from examples\n137\n6.5\nRefining scenarios\n139\n6.6\nIterating specifications over time\n141\nValidating the specification suite\n141\n■Evolving the \ndocumentation system\n144\n6.7\nSummary\n147\n7 Living documentation\n148\n7.1\nLiving documentation in action\n150\n7.2\nWriting documentation\n153\n7.3\nDefining important domain concepts\n154\nWriting lexical definitions\n154\n■Writing illustrative \ndefinitions\n156\n■Using glossaries\n158\nNaming important domain concepts\n158\n7.4\nDocumenting decisions using briefs\n160\nUsing warning notes to highlight problematic areas\n160\nUsing context notes to deepen the business context\n160\nUsing maintenance notes for internal purposes\n161\n7.5\nHigh-level overview of the documentation process\n161\n7.6\nWho creates living documentation?\n163\nCreating documentation through all-team specification \nworkshops\n164\n■Creating documentation through Three \nAmigos meetings\n164\n■Creating documentation through \nindividual people\n165\n7.7\nChoosing the right audience for living \ndocumentation\n166\nWho’s a minimally qualified reader?\n166\nFinding the perfect MQR in an organization\n167\n7.8\nAnswers to exercises\n169\n7.9\nSummary\n169\nPART 2\nMANAGING SPECIFICATION SUITES..................171\n8 Organizing scenarios into a specification suite\n173\n8.1\nIs organizing scenarios by features a good idea?\n175\n8.2\nOrganizing scenarios by user stories\n176\nIntroducing the Ability keyword\n177\nUnderstanding the structure of user stories\n182\n",
      "content_length": 1463,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 13,
      "content": "CONTENTS\nxi\nAnalyzing the relationship between user stories \nand executable specifications\n183\n■Iterative dangers \nof organizing scenarios by user stories\n184\n8.3\nWhat about nonfunctional requirements?\n186\nDealing with nonfunctional requirements according \nto SBE\n187\n■Can Gherkin specify nonfunctional \nrequirements?\n188\n■Introducing the Business Need \nkeyword\n189\n■Using the Business Need keyword to \nidentify new stakeholders\n190\n8.4\nAnswers to exercises\n193\n8.5\nSummary\n194\n9 Refactoring features into abilities and business needs\n195\n9.1\nAnalyzing user stories: a practical example\n196\n9.2\nRefactoring features into abilities\n196\nDeriving new scenarios from user stories\n197\nStarting with simple features\n197\n■Adding \nscenarios over time\n198\n■Splitting huge features \ninto small abilities\n200\n9.3\nRecognizing and refactoring business needs\n203\nAdding functional scenarios to business needs\n204\nIdentifying new stakeholders with business needs\n207\nRefactoring functional scenarios in business \nneeds into individual abilities\n208\n9.4\nSummary\n212\n10 Building a domain-driven specification suite\n213\n10.1\nDistilling business domains from \na ubiquitous language\n215\nSpotting different domains in your scenarios\n216\nDistilling the core domain from scenarios\n218\nDistilling subdomains accompanying the core domain\n219\n10.2\nCreating a domain model from distilled domains\n221\nThe domain model and the specification suite\n221\nWhy are good domain models important?\n222\nWhat makes a good domain model in software?\n224\n10.3\nBuilding a domain-driven specification suite \nin practice\n224\nDistilling subdomains from unequivocal scenarios\n225\nDistilling subdomains from mixed scenarios\n226\n",
      "content_length": 1679,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 14,
      "content": "CONTENTS\nxii\nDistilling subdomains from other scenarios\n228\nCreating a specification suite from distilled domains\n230\n10.4\nAnswers to exercises\n231\n10.5\nSummary\n233\n11 Managing large projects with bounded contexts\n234\n11.1\nAnalyzing domain concepts in context\n235\nSpotting false cognates\n236\n■Dealing with false \ncognates\n237\n■Spotting duplicate concepts\n239\n11.2\nModeling specification suites as bounded contexts\n241\nUnderstanding bounded contexts\n241\n■Splitting a large \nspecification suite into multiple bounded contexts\n242\nManaging bounded contexts with context maps\n245\nDrawing context maps\n246\n11.3\nFitting DDD into an SBE process\n248\n11.4\nSummary\n249\nappendix\nExecuting specifications with Cucumber\n251\nindex\n269\n",
      "content_length": 721,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 15,
      "content": "xiii\nforeword\nTo many agile teams, specifications is a dirty word, and any discussion about written\ndocumentation is heresy. Yet long-term product success depends on new members\njoining teams, scaling up and growing products and organizations, and reconciling\nthe needs and demands of an ever-growing number of user groups and stakeholders.\nThose tasks are almost impossible without capturing knowledge in some form that\nallows sharing and doesn’t rely on a single person’s memory. \n This book deals with those parts of the delivery process that typically fall between the\ncracks of the three Cs of user stories. The Card, Conversation, and Confirmation technique\nfor working with user stories plays a pivotal role in directing software delivery today, but\nmany delivery teams struggle to capture the results of conversations and document\nthem in a way that will make confirmation easy. Kamil’s suggestions and techniques will\nhelp you do that, not just in the short term, but over many years as a software product\nkeeps evolving, and when you need to remember discussions you had months earlier in\norder to inform future cards and conversations. \n Specification by example (SBE) with Gherkin presents a way for teams working in\nan iterative delivery model to capture knowledge about their intentions and about\nwhat their software products do. Most books in this area focus on either tool-specific\nautomation mechanisms or high-level teamwork processes for collecting the right\nexamples, but there’s very little literature out there about the style and form of good\nexamples that will guide development. That’s why this book is so important. \n The omnipresent Given-When-Then style of describing examples is close to natu-\nral language, but that familiarity is a double-edged sword. On the one hand, it makes\nit easy for anyone to get started, which is fantastic because it lowers the bar for teams\nto start a conversation. But Gherkin (the geek name for that format of specifications)\n",
      "content_length": 1986,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 16,
      "content": "FOREWORD\nxiv\nis also aimed at supporting automated validation and long-term documentation, and\nthat requires a lot more formality and structure than natural language does. Without\nconsidering that dark side of Given-When-Then examples, many teams get some\nshort-term benefits at the significantly increased cost of long-term maintenance.\nKamil tackles this problem with several simple techniques that are easy to remember,\nand lots of concrete examples that will help you put things into perspective. \n The ideas in this book are close to some informal approaches I’ve seen working\nwith many successful teams. Kamil presents them as structured patterns, such as “Start-\ning with a Then” and “Specifying intentions and outcomes over the UI,” so you can\nremember them easily. The tips and tricks to work with scenario outlines will save you\nmonths of rework and hassle, helping you deal with possibly the most important and\nmost difficult topic for anyone new to this way of documenting examples. Several\nchapters also have homework exercises that you’ll be able to use to immediately to try\nout new knowledge and ideas. \n I particularly like how the later part of the book touches on domain modeling\nand creating a ubiquitous language. Kamil does a nice job taking those concepts\nfrom good architectural practices and translating them to the world of collaborative\nspecifications.\n—Gojko Adžic´\nAuthor, Specification by Example (Manning, 2011)\n",
      "content_length": 1443,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 17,
      "content": "xv\npreface\nIn 1968, there were only 10,000 installed computers in all of Europe. That year, NATO\nfunded a conference that, even though its topic was little known to a wider audience,\nhosted more than 50 people from 11 different countries. Held in Garmisch, Germany,\nthe conference talked about software engineering and represented the first appear-\nance of programming as an engineering discipline. The event would later become\nknown as the first of two NATO Software Engineering Conferences (the second was\nheld a year later); both played major roles in promoting widespread acceptance of\nsoftware development.\n After the conference, the NATO Science Committee was ordered to compile a\nreport that summarized the discussions.1 Every time I read this report, I’m amazed by\nhow insightful it was and that parts of it remain relevant. “We tend to go on for years,\nwith tremendous investments, to find that the system, which was not well understood\nto start with, does not work as anticipated,” said J. W. Graham during a panel on feed-\nback through monitoring and simulation. “We work like the Wright brothers built air-\nplanes: build the whole thing, push it off the cliff, let it crash, and start over again.”\nDecades have passed, but not a lot has changed.\n Graham’s committee gathered to discuss whether there was a better way to do soft-\nware engineering. They focused on the use of simulation during design, an idea intro-\nduced by Brian Randell in a working paper. “The important point [in building better\nsoftware] is the use of simulation,” continued Graham. By simulation, he meant what\nwe today call test automation—a deterministic environment with predefined inputs and\n1  Software Engineering: Report on a Conference Sponsored by the NATO Science Committee, Garmisch, Germany, 7th to\n11th October 1968, eds. Peter Naur and Brian Randell (Scientific Affairs Division, NATO, 1969),\nhttp://mng.bz/jn3d.\n",
      "content_length": 1911,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 18,
      "content": "PREFACE\nxvi\npredictable outcomes. “Simulation is a way to do trial and error experiments. If the\nsystem is simulated at each level of design, errors can be found and the performance\nchecked at an early stage.” In other words, the earlier in the process we test, the\nsooner we can find mistakes. When we consistently test after every change in design,\nerrors tend to disappear. In the end, we get better software.\n Throughout the rest of the discussion, other participants followed Graham’s train\nof thought. Alan Perlis chimed in, clarifying the relationship between tests and design:\n“A software system can best be designed if the testing is interlaced with the designing\ninstead of being used after the design.” Test a little, code a little. If this sounds familiar,\nthat’s because Perlis’s approach reemerged as test-driven development (TDD) in the\nlate 1990s. Modern TDD requires software engineers to write tests before any applica-\ntion code. Ideally, TDD should actively prevent defects by improving code design. Perlis\npredicted that, too: “A simulation which matches the requirements contains the con-\ntrol which organizes the design of the system. … The critical point is that the simula-\ntion becomes the system.” According to his vision, tests guide software design and\norganize it. TDD does the same. A test-driven process relies on repeating a short devel-\nopment cycle called the red-green-refactor loop. Initially, new tests fail the simulation\nbecause no application code has been written yet (and, in most test-automation\nengines, failed tests appear in red). But as new code is written, more and more tests\nstart to pass—and they turn green as a result. The loop is repeated until all tests pass.\nAnd so, step by step, the simulation becomes the system.\n TDD was created and promoted by Kent Beck. Thirty years divided Beck and Per-\nlis, but as personal computers and software engineering engulfed the world, the\nunderlying problems programmers faced remained the same. TDD has a fatal flaw,\nthough. Although, as Perlis said, a simulation that matches the requirements can con-\ntrol and organize the design of a system, the use of simulation doesn’t address the\nproblem of collecting the correct requirements in the first place. Thus, a good simu-\nlation can perfectly organize the wrong system, rendering itself useless. That’s why\nprogrammers never design software systems alone—they work with designers, testers,\nbusiness analysts, product managers, and so on. But TDD is a highly technical pro-\ncess. Would it be possible to harness the benefits of feedback through simulation on a\nhigher level of abstraction, without relying only on low-level code, and in a more col-\nlaborative way? Fortunately, in the last decade or so, attempts to answer this question\nhave resulted in a lot of innovation (for example, TDD evolved into behavior-driven\ndevelopment [BDD]).\n This book focuses on an innovation called an executable specification: a specification\nthat’s written in natural language and, at the same time, can be run as a program—or,\nmore specifically, as an automated test. The use of natural language instead of code\nmeans everyone, whether they can program or not, can discuss the requirements, as\nwell as their tests and implementation. The use of simulation means we can have the\nsimulation control the design of the system and then become the system itself, by\ninterlacing design and testing.\n",
      "content_length": 3424,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 19,
      "content": "PREFACE\nxvii\n I first became familiar with the topic at Monterail—a web development studio\nworking with enterprise clients and startups from all over the world—where I was\nresponsible for implementing executable specifications. Thanks to executable specifi-\ncations, Monterail’s delivery teams were able to deliver software of higher quality. In a\nyear or so, we wrote more than 500 Gherkin scenarios for highly complex products\nincluding procurement software, webinar/webcast software for marketers, and a\npacket-capture product family that can transform any server into a precision network-\nmonitoring device.\n I started my career at Monterail as an engineer and then moved to product man-\nagement. I wrote executable specifications, I implemented them, and I tested them.\nAround that time, I read Gojko Adžic´’s Specification by Example (Manning, 2011,\nwww.manning.com/books/specification-by-example), which was pivotal to the way I\napproach the topic of software quality. In early 2015, I participated in Product Owner\nSurvival Camp in Vienna, where Ellen Gottesdiener, Gojko Adžic´, David Evans, and\nChristian Hassa held their workshops. During a coffee break, a coworker of mine\n(who also attended) and I mentioned to Gojko that we were thinking about releasing\na free ebook with tutorials for writing executable specifications. Gojko’s book is great,\nbut it focuses on the process and key practices, leaving implementation aspects aside.\nAlthough many books discussed how to write tests, for some reason almost nobody was\ntalking about writing the specification layer—the stuff that humans can read, not just\nmachines. We agreed that it was a topic worth exploring. The joint project didn’t work\nout, but Gojko introduced me to Manning’s Mike Stephens; and, some time later, the\nidea for my own book took off—all thanks to that meeting in Vienna.\n There are many different kinds of executable specifications; an attempt to discuss\nall of them in a single book wouldn’t be practical. So, we’ll explore two of these\napproaches—specification by example (SBE) and Gherkin—that are increasingly pop-\nular. Together, they offer programmers, designers, and managers an inclusive environ-\nment for clear communication, discovering requirements, building a documentation\nsystem, and writing acceptance tests. My goal in this book is to help you create such an\nenvironment in your organization so that we, as an industry, may continue progress-\ning on the path set in 1968 by the pioneers of our industry.\n I wish you good luck in your journey with SBE and Gherkin. But I also want to\nthank you. I truly believe that delivery teams all over the world wield tremendous\npower and have great responsibility to the people who use their software—and\nincreasingly, that’s millions of users. Every attempt to improve software quality—\nincluding yours—should be applauded.\n",
      "content_length": 2862,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 20,
      "content": "xviii\nacknowledgments\nI thank everyone who contributed to this book, especially the people at Manning:\npublisher Marjan Bace and everyone on the editorial and production teams, includ-\ning Alessandro Campeis, Alain Couniot, Bert Bates, Dan Maharry, Marina Michaels,\nMike Stephens, Janet Vail, Tiffany Taylor, Katie Tennant, Dottie Marsico, and Jona-\nthan Thoms. Having some confidence in the topic I wanted to write about, I thought I\nwas the one who was here to teach; but, rightfully, it was I who ended up being\nschooled. I learned so much from you—all while you were working hard to move the\nprocess along as swiftly as possible.\n Thanks go to the amazing group of technical peer reviewers led by Aleksandar\nDragosavljevic: Ivo Alexandre, Costa Alves Angelico, James Anaipakos, Dane Balia,\nKeith Donaldson, Ruben Gamboa, Aurélien Gounot, Burk Hufnagel, Edgar R. Knapp,\nUnnikrishnan Kumar, David Madouros, Russell Martin, Markus Matzker, Nasir\nNaeem, David Osborne, Mike Reidy, and Craig Smith.\n My thanks to Gojko Adžic´, who wrote the foreword and introduced me to Manning.\n I want to thank the great people at Monterail who worked with me from 2013 to\n2015 and contributed to many of the ideas you’ll read here. They helped me see SBE\nand Gherkin from every angle: development, testing, and product design.\n Many friends helped improve early drafts of the book or got me through blocks\nand obstacles. For their invaluable comments and continuing support, I thank Bartek\nJarmołkiewicz, Magda Mól, Dominik Porada, and Piotrek Zadworny.\n I also want to thank my cofounders at Ada:1 Adam Stankiewicz and Natalia S´wirska.\nThe company was born at the same time as the idea for this book. Thank you for your\npatience and encouragement.\n1 Ada is an AI-powered personal assistant that will help you rent your next apartment: http://adarenting.com.\n",
      "content_length": 1846,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 21,
      "content": "ACKNOWLEDGMENTS\nxix\n Finally, a big thank-you goes to my family. I wouldn’t have done any of the work I’m\nproud of today without my parents. Mom, you’ve always believed in me: thank you for\nbeing the very first reader of my short stories, back when I was in school. Dad, I often\nthink of the times when we had fun together learning our first programming lan-\nguage, Visual Basic. I was 10 years old then. I’m older now, but it’s still fun.\n I once read that people write in an attempt to advise their past selves. Since child-\nhood, I’ve wanted to write a book—although I imagined it would be a novel. At some\npoint, I came to believe it would never happen, but the universe works in funny ways.\nTo anyone who struggles with a goal that feels distant and daunting, I want to quote\nNike’s Phil Knight: “The cowards never started, and the weak died along the way. That\nleaves us.” Don’t give up. Thank you for your work.\n",
      "content_length": 919,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 22,
      "content": "xx\nabout this book\nThe goal of this book is to help you learn to do the following:\nCapture requirements and acceptance criteria as executable test cases\nMaster the Gherkin language as a practical, communicative way of writing soft-\nware specifications\nCollect valuable examples\nWrite easy-to-automate specifications\nDesign stable executable specification suites with good test coverage\nBalance the specification style and documentation style in Gherkin scenarios\nManage specification suites in large projects\nWho should read this book\nFor readers who came here with preexisting knowledge of both specification by exam-\nple (SBE) and Gherkin: this is an intermediate-level book designed for anyone who’s\ntasked with writing or updating a specification in Gherkin or who’s responsible for\nimplementing an SBE process using Gherkin in their organization. If those are issues\nyou deal with on a daily basis, you’ll find answers here.\n For readers who came here to learn from scratch: many tutorials on the web\nexplain how to set up executable specifications and write testing code. But their\nauthors don’t understand that, to anyone but software engineers and testers, auto-\nmated testing is as vague a concept as any random UX method can be to an average\nprogrammer. Those tutorials have good intentions and want to bring everyone to the\nsame table, but whose table is that?\n",
      "content_length": 1379,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 23,
      "content": "ABOUT THIS BOOK\nxxi\n This book is a teaching resource meant for everyone—product and design people,\nanalysts, programmers, and testers. Instead of focusing on technical challenges, it\ngoes into depth about writing the text layer of executable specifications in Gherkin in\na clear, understandable, concise manner. Non-engineers can learn how to make essen-\ntial contributions to design and testing without having to learn programming or write\ntesting code. Engineers and testers, on the other hand, will find SBE and Gherkin\nhelpful for doing more meaningful TDD by striking a stronger chord with nontechni-\ncal audiences through executable specifications.\nHow this book is organized\nThis book is divided into 11 chapters and an appendix:\nChapter 1 presents a quick, practical introduction to SBE and Gherkin.\nChapters 2 and 3 talk about writing scenarios and the theory of the automation\nlayer. Chapter 2 introduces the basics of the Given-When-Then template, and\nchapter 3 discusses what makes a great scenario.\nChapters 4 and 5 look at scenario outlines, which are a more advanced way of\nwriting scenarios. Chapter 4 presents the new structure of scenario outlines,\nand chapter 5 shows why it’s important to collect thoughtful examples.\nChapter 6 is about the life cycle of executable specifications. Before going into\nmore-advanced topics, you need to understand the place of SBE and Gherkin in\na real-world software development process.\nChapter 7 covers living documentation and how to create high-precision sce-\nnarios out of unrefined drafts.\nChapters 8 and 9 are about managing medium-sized specification suites. Chap-\nter 8 talks about grouping unorganized scenarios into whole specifications, and\nchapter 9 discusses refactoring large specifications into smaller ones.\nChapters 10 and 11 focus on the largest specification suites. Chapter 10 intro-\nduces domain-driven design as a way to prepare medium-sized specification\nsuites for seamless expansion. Chapter 11 is about splitting large specification\nsuites based on their business domains.\nThe appendix is a quick tutorial on how to write and run simple, automated\ntests for feature files with Cucumber and Gherkin. It’s intended for readers who\nare interested in how the automation layer works in practice.\nYou can read the book from cover to cover or make a quick stop after chapter 2, read\nthe appendix, and then come back to the rest of the book. I highly recommend read-\ning the entire book without skipping chapters—the ordering is intentional and not\ndesigned to be rearranged. Some of the chapters include exercises; the answers are\nprovided at the end of the chapter.\n",
      "content_length": 2648,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 24,
      "content": "ABOUT THIS BOOK\nxxii\nCode conventions and downloads\nThis book contains many examples of source code, both in numbered listings and in-\nline with normal text. In both cases, source code is formatted in a fixed-width font\nlike this to separate it from ordinary text.\n In many cases, the original source code has been reformatted; I’ve added line\nbreaks and reworked indentation to accommodate the available page space in the\nbook. In rare cases, even this wasn’t enough, and listings include line-continuation\nmarkers (➥). Additionally, comments in the source code have often been removed\nfrom the listings when the code is described in the text. Code annotations accompany\nmany of the listings, highlighting important concepts.\n The source code for all examples in this book is available from the publisher’s web-\nsite, www.manning.com/books/writing-great-specifications.\nAbout the author\nKamil Nicieja began his career as an engineer and then moved to\nproduct management. He’s now CEO of Ada (http://adarenting\n.com), an AI-powered personal assistant that will help you rent\nyour next apartment. He’s experienced SBE’s benefits first-hand\nboth in development and in business, and he’s seen what hap-\npens when management and development misunderstand each\nother or don’t develop common domain concepts together from\nboth points of view. In addition to writing this book, he blogs at www.nicieja.co about\nentrepreneurship, startups, and technology.\nBook forum\nPurchase of Writing Great Specifications includes free access to a private web forum run\nby Manning Publications where you can make comments about the book, ask technical\nquestions, and receive help from the author and from other users. To access the forum,\ngo to https://forums.manning.com/forums/writing-great-specifications. You can also\nlearn more about Manning’s forums and the rules of conduct at https://forums\n.manning.com/forums/about.\n Manning’s commitment to our readers is to provide a venue where a meaningful\ndialogue between individual readers and between readers and the author can take\nplace. It isn’t a commitment to any specific amount of participation on the part of the\nauthor, whose contribution to the forum remains voluntary (and unpaid). We suggest\nyou try asking the author some challenging questions lest his interest stray! The forum\nand the archives of previous discussions will be accessible from the publisher’s website\nas long as the book is in print.\n",
      "content_length": 2443,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 25,
      "content": "xxiii\nabout the cover\nThe figure on the cover of Writing Great Specifications is captioned “Habit of a Moorish\nPriest in 1695.” The illustration is taken from Thomas Jefferys’ A Collection of the Dresses\nof Different Nations, Ancient and Modern (four volumes), London, published between\n1757 and 1772. The title page states that these are hand-colored copperplate engrav-\nings, heightened with gum arabic. \n Thomas Jefferys (1719–1771) was called “Geographer to King George III.” He was\nan English cartographer who was the leading map supplier of his day. He engraved\nand printed maps for government and other official bodies and produced a wide\nrange of commercial maps and atlases, especially of North America. His work as a map\nmaker sparked an interest in local dress customs of the lands he surveyed and\nmapped, which are brilliantly displayed in this collection. Fascination with faraway\nlands and travel for pleasure were relatively new phenomena in the late eighteenth\ncentury, and collections such as this one were popular, introducing both the tourist as\nwell as the armchair traveler to the inhabitants of other countries.\n The diversity of the drawings in Jefferys’ volumes speaks vividly of the uniqueness\nand individuality of the world’s nations some 200 years ago. Dress codes have changed\nsince then, and the diversity by region and country, so rich at the time, has faded away.\nIt’s now often hard to tell the inhabitants of one continent from another. Perhaps, try-\ning to view it optimistically, we’ve traded a cultural and visual diversity for a more var-\nied personal life—or a more varied and interesting intellectual and technical life.\n At a time when it’s difficult to tell one computer book from another, Manning cel-\nebrates the inventiveness and initiative of the computer business with book covers\nbased on the rich diversity of regional life of two centuries ago, brought back to life by\nJefferys’ pictures.\n",
      "content_length": 1938,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 27,
      "content": "1\nIntroduction to specification\nby example and Gherkin\nHow well we communicate is determined not by how well we say things, but how well\nwe are understood.\n—Andy Grove\nThe money is all on the right [side of the product life cycle], in the area of certainty\n[where the product is mature]. I work on the left, with uncertainty. I’ll never be rich.\n—Chris Matts\n \nThis chapter covers\nExamining why teams need specifications\nRecognizing common specification pitfalls\nUnderstanding the basics of specification by \nexample and Gherkin\nSolving common delivery problems with \nspecification by example and Gherkin\n",
      "content_length": 609,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 28,
      "content": "2\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nHumanizing technology is perhaps the greatest challenge of software engineering.\nThe technology industry must strive to show tremendous empathy for other people’s\nproblems. We’re making tools for everyone out there. In the messy world of organiza-\ntional politics, broken workflows, human errors, and biases, technology experts must\nfigure out how to successfully deliver great software. It’s an important responsibility.\n To do our job well, we have to\nMake sure we deliver the right software\nDeliver it the right way\nDelivery teams are naturally competent in delivering software the right way. As an\nindustry, we’ve developed tools, standards, and methodologies that make our designs\nbeautiful and usable—and our code performant, secure, and easy to maintain. We\nkeep getting better at refining and reinventing our best practices.\n “The right software” part, though … what does that even mean? Every time I\nexplain to someone what this book is about, I tell them that, as programmers, we’re\ntaught to write code—algorithms, design patterns, abstractions. Or, as designers, we’re\ntaught to design—organize information and create beautiful interfaces. But when we\nget our entry-level jobs, our employers expect us to “deliver value to our clients.” And\nthe client may be, for example, a bank. If I’d been working for a bank when I started\nmy career, it would have quickly come up that I know next to nothing about bank-\ning—except how to efficiently decrease my account balance. So I would have had to\nsomehow translate what was expected of me into code. I would have needed to build a\nbridge between banking and my technical expertise if I wanted to deliver any value.\n“This,” I say, “is what the book is about: building bridges between technology and busi-\nness.” Over the course of multiple projects I’ve had the privilege to work on, I’ve come\nto believe that these bridges can only be built with empathy—understanding other\npeople’s problems—and inclusive communication.\n Even though engineers should be good at building bridges, our industry seems to\nhave a problem with delivering the right software. In practice, delivering the right soft-\nware requires securing the right requirements. I’ll talk more about requirements in a\nmoment. For now, I’ll say the following:\nA 1994 study showed that 31.1% of projects were canceled before they were\ncompleted, and 52.7% of projects cost 189% of their original estimates.1\nIn larger companies, rare successful projects had only 42% of the originally pro-\nposed features.2\nIn 2000, IBM and Bell Labs studies showed that 80% of all product defects are\ninserted at the requirements-definition stage.3\n1 The Standish Group, “The CHAOS Report” (1995), http://mng.bz/40M3.\n2 Ibid.\n3 Ivy Hooks and Kristin Farry, Customer-Centered Products: Creating Successful Products Through Smart Requirements\nManagement (AMACOM/American Management Association, 2001).\n",
      "content_length": 2968,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 29,
      "content": "3\nRequirements errors consume from 28% to more than 40% of a typical pro-\nject’s budget.4\nRequirements defects account for the vast majority of the total cost of all\ndefects—often 70% or more.5\nIn 2008, almost 70% of companies surveyed set themselves up for both failure\nand significantly higher costs by their use of poor requirements practices.6\nWhat are the consequences? Commercial organizations across the European Union\nlost €142 billion on failed IT projects in 2004 alone, mostly because of poor alignment\nwith business objectives or business strategies becoming obsolete during delivery.7 So\nalthough we’re pretty good at maintaining our technical standards of excellence, we\napparently still have a lot to learn when it comes to understanding what businesses\nneed from us.\n In this chapter and throughout the book, I’ll introduce you to a selection of\nbridge-building methods for translating business objectives into working software\nthat, in my experience, results in great and meaningful products and services. This\nchapter will begin your in-depth journey of learning to write executable specifications in\nGherkin according to the key practices of specification by example.\n Specification by example (SBE) is a collaborative software development approach\nthat facilitates collaboration by illustrating software requirements with concrete exam-\nples and automated acceptance tests. Because SBE is a process, you’ll need some tools\nthat will help you implement that process. This is why you’re going to learn Gherkin.\nGherkin is a business-readable, domain-specific language that’s easy for nontechnical\nfolks to understand. As such, it makes translating requirements into code easier.\n In a way, the book is an advanced Gherkin tutorial with some product-design ambi-\ntions. I’ll talk more about the reasons for choosing Gherkin later in the chapter. But\nwhen I was first learning SBE’s key patterns, I found that, although locating material\non automated acceptance tests and eliciting better requirements is easy, there aren’t\nmany resources available on writing great executable specifications. By great, I mean\nwell-written and easy to read in terms of sentences and words, not code. That makes\nmy ambition small, because I chose a specific topic for the book. I care about making\nsure that well-elicited requirements aren’t misrepresented by poorly written specifica-\ntions. At the same time, I realize that writing executable specifications is a cross-\ndisciplinary matter. Whenever I can, I’ll talk about making your requirements better\nand more specific with clever Gherkin techniques. Other times, I’ll point you toward\nspecific books that talk about requirements, product design, or marketing, in hopes\nthey will answer your further questions.\n4 Ibid.\n5 Dean Leffingwell and Don Widrig, Managing Software Requirements: A Use Case Approach, 2nd ed. (Addison-Wes-\nley Professional, 2003).\n6 IAG Consulting, “Business Analysis Benchmark” (2008).\n7 Gojko Adzˇic´, Impact Mapping (Provoking Thoughts, 2012).\n",
      "content_length": 3027,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 30,
      "content": "4\nCHAPTER 1\nIntroduction to specification by example and Gherkin\n This chapter offers an overview of what a specification is and how SBE and Gherkin\nfit into the software development landscape. If you’re a non-engineer, you’ll learn\nhow to make essential contributions to automated testing without having to learn to\nwrite testing code. (Don’t worry about technical lingo. I use it rarely and explain it\nwhen I do.) Engineers and testers will find SBE and Gherkin helpful in striking a\nstronger chord with nontechnical audiences through automated specifications. You’ll\nalso begin to see SBE as a single process to guide product development through\nrequirements analysis, design, development, testing, and so on.\n1.1\nWhat’s a specification?\nImagine that you and the team you work with have been brought in to work on a new\nversion of a management system for a local public transport company. To get on with\nwork, you need a list of functionalities, user stories, blueprints, sketches—anything\nthat will let you write some code or make a UI mock-up. You need a specification.\nDEFINITION\nSpecification—An analysis of a system and its design, made to plan\nand execute the implementation\nThe word specification can mean a written document or an act of specifying. You’ll see\nthat I switch freely between both meanings. Whenever it’s important to make a clear-\ncut distinction, I’ll use a term like specification document or specification process. But you\ncan assume that most of the time, I have the broad meaning of the word in mind.\n In the case of the example public transport company, to devise a specification, you\nhave to agree on a list of requirements and functionalities the new release must satisfy.\nDEFINITION\nRequirement—A capability or condition that must be met or pos-\nsessed by a solution to satisfy market needs or a contract, a standard, a specifi-\ncation, or other formally imposed documents\nFor example, you and the business owners may agree that a good requirement would\nbe to apply discounts when students or retirees buy tickets. Other examples could\nrelate to handling season tickets, performing online payments, managing customers,\nand reports.\n Delivery teams can write down their requirements in a functional requirements\ndocument, but they may also encapsulate requirements in use cases, which are\nshorter, or use user stories as tickets for a future in-depth conversation about the\nrequirements. The final method depends on the software development process cho-\nsen by the team. \n1.2\nWhy do teams need specifications?\nTraditionally, specifications have had a bad reputation in the software development\ncommunity. The reason is half psychological, half practical.\n Psychologically, specifications seem to promise the same success as following a cook-\ning recipe. They invite a “Follow the steps, and everything will be all right” mindset. The\n",
      "content_length": 2867,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 31,
      "content": "5\nWhy do teams need specifications?\npromise is as reassuring as it is deceiving. In practice, creating a complete specification\nis extremely difficult, if not impossible.\n No software development team functions without specifications, though. Whether\nyou write an official document or have a casual conversation about the requirements\nduring a workshop, you’re still specifying.\n The one and only reason teams need specifications is information asymmetry. Teams\nneed to distribute information evenly among the stakeholders to create the best possi-\nble product. If they don’t, they’ll miss critical requirements and make an incomplete\nproduct—or even a broken one.\nDEFINITION\nInformation asymmetry—A situation in which one party has more\nor better information than another\nTo reduce information asymmetry, teams create specifications—recipes defining what\nneeds to be done or how it needs to be done. Specifications can help fight information\nasymmetry in two ways:\nA specification can define acceptance criteria that help examine whether a\nteam has delivered a complete system that works.\nA specification can provide a common language that allows technical and\nnontechnical stakeholders to understand each other when they talk about\nrequirements.\nWe’ll now go into more depth on both of these topics.\n1.2.1\nDefining acceptance criteria in specifications\nAssume that you and the public transport company’s management team have agreed\nthat the system you’re building should include two subsystems:\nAn internal management application for updating bus schedules\nA mobile timetable application with journey-planning functionality\nSounds reasonable, doesn’t it? The capabilities for both the employees of the com-\npany and its customers are clearly defined. But are they really?\n Every time you analyze a requirement, you’ll eventually stop talking about general\ncapabilities of the system and start thinking in terms of concrete, discrete quality mea-\nsures that the application must meet. When discussing our public transport company,\nI said that a good requirement would be to apply discounts when students or retirees\nbuy tickets. But how can you determine whether that requirement is satisfied without\ngoing into more detail? For example, you’d need to declare that students can have a\n30% discount and retirees can have a 95% discount. These two declarations would\nallow you to say that the requirement was in fact satisfied and implemented correctly.\nSuch quality measures are called acceptance criteria.\nDEFINITION\nAcceptance criterion—A condition or quality measure that a soft-\nware product must meet to satisfy requirements\n",
      "content_length": 2634,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 32,
      "content": "6\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nAcceptance criteria illustrate requirements. You should be able to use a criterion to\nevaluate the system and get an unambiguous confirmation that the system either\npasses or fails your test: for example, “A bus road should consist of at least two bus\nstops.” Right, and that’s how the system behaves. “Timetables for work weeks should\nbe different than timetables for weekends.” Oops, we forgot about that; let’s go back\nto the drawing board. You should be able to get a binary response to every criterion—\nas in yes or no questions. Without that binary response, you can’t say whether the sys-\ntem is complete and works as it should.\n Raw requirements are often too difficult to comprehend without further analysis.\nWithout clear acceptance criteria for each of the requirements, delivery teams can’t\nplan any work ahead and deliver any value in a predictable way. When there’s not a\ngood specification, functionality usually suffers from rework or bugs that cause delays\nand cost a lot. Good acceptance criteria ensure that the implemented solution meets\nthe demands of your stakeholders. \n1.2.2\nBuilding a ubiquitous language into specifications\nImagine for a moment that after you finish the beta version of the mobile journey plan-\nner, the customer support department receives a phone call from an angry customer:\nThe customer begins, “I downloaded the app to help me during my two-day stay in the\ncity. But I can’t get where I want!”\n“What street are you on? What’s wrong?”\n“I’ve got a meeting in Edison. I used your app to get there, but I can’t find the building\nI’m supposed to enter. It’s all wrong!”\n“Wait—do you mean Edison Street or Edison Business Center? They’re two different\nplaces.”\nThe customer wanted to plan the journey without knowing what street the destination\nbuilding was on, but the application didn’t support such a behavior. To add insult to\ninjury, the mobile app chose Edison Street, located elsewhere in the city, as the final\ndestination, because it couldn’t find Edison Business Center in the database.\n The result? The user and the application spoke two different languages, and the\nconfused customer got lost. The dictionary of the developers who built the app was\nrestricted to streets; after all, bus stops inherit their names from where they’re located.\nThat’s how the system works, the team said. What they didn’t know was that their cus-\ntomers don’t think about the rules of a system—they only want to arrive on time.\n To avoid similar mistakes, delivery teams should strive to grasp the language their\nusers speak and align their language with this language. The result of this alignment is\noften called a ubiquitous language.\nDEFINITION\nUbiquitous language—A common language between developers\nand domain experts\n",
      "content_length": 2824,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 33,
      "content": "7\nWhy do teams need specifications?\nA ubiquitous language is “a language cultivated in the intersection of [technical and\nbusiness] jargons.”8 The development of journey-planning software requires knowl-\nedge in two different domains: journey planning and software. Experts in both areas\nmust communicate understandably.\nDEFINITION\nDomain—What an organization does, and the world it does it in\nThe journey planners will use the jargon of their field and have limited understanding\nof the technical dictionary of software development. Developers, on the other hand,\nwill understand and discuss the system in terms such as objects, methods, and design\npatterns. Having a single common language eliminates the cost of mental translation\nand reduces the number of misunderstandings—the ratio of noise in the signal—in\ndiscussions between technical and nontechnical stakeholders. Translation blunts com-\nmunication and makes domain learning anemic.\n The journey planners from the example can also be called domain experts. Domain\nexperts help you create a ubiquitous language. When either the business side or the\ntechnical side discovers a misunderstanding, they can use the opportunity to improve\ntheir shared dictionary and avoid the same mistake the next time. This way, they build\na shared domain model, which will improve in quality over time.\nDEFINITION\nDomain expert—A person who is an authority in a particular area\nor topic. The term usually refers to a domain other than the software domain.\nDEFINITION\nDomain model—A simplification of the real-world business\ndomain. It’s an interpretation of reality that abstracts the aspects relevant only\nto solving the problem at hand.\nThe ubiquitous language fuels the domain model. Having a shared dictionary of\nimportant business concepts creates a platform for discussing data, behaviors, and\nrelationships within the model in a meaningful way, with a certainty that everybody is\non the same page. In the journey-planning example, the team thought that a destina-\ntion was the same as a street; but it turned out that users assumed there are other kinds\nof destinations, such as buildings and points of interest. Having established a baseline,\nthe team can use the common language to establish clear relationships between the\nconcepts of destinations, streets, buildings, and points of interests.\n A specification can help develop the ubiquitous language. It’s a container where\nall important domain concepts can be stored after they’re encountered and analyzed\nby the team. When that happens, and the process is thorough and successful, the spec-\nification becomes a documentation of the domain, the knowledge base of the delivery\nteam. When a specification fails to contribute to the ubiquitous language or doesn’t\ncreate a truthful domain model, the team may misunderstand requirements, which\noften leads to expensive rework. \n8 Eric Evans, Domain-Driven Design (Addison-Wesley, 2003).\n",
      "content_length": 2938,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 34,
      "content": "8\nCHAPTER 1\nIntroduction to specification by example and Gherkin\n1.3\nCommon specification pitfalls\nMuch of software engineering is about building systems right, but specifications,\nrequirements, and acceptance criteria are about building the right system. From time\nto time, every software engineer experiences a painful push-back caused by a sloppy\nanalysis of the requirements. You, too, know what’s at stake. This section should help\nyou identify some pitfalls you yourself may have encountered.\n I want to discuss these five anti-patterns:\nOver-specification\nHand-offs\nUnder-documentation\nSpeci-fiction\nTest-inability\nI named each anti-pattern in a distinctive way that will help you remember what it’s\nabout. Hopefully, as you go through the sections that follow, the names of the anti-\npatterns will become clearer to you, and I’ll achieve my goal.\n1.3.1\nOver-specification\nA popular first instinct meant to defend a project against ambiguity and insufficient\nplanning is to try to design and plan as much as we can up front. I call that over-\nspecification.\nDEFINITION\nOver-specification—Doing too much specification up front\nIt’s definitely easier to remove or change a requirement during an analysis phase; the\nmore time we invest in implementing it, the more unmotivated we become when we\nhave to kill it. The up-front approach aims to remove useless implementations, design\nflaws, and predictable errors as early as possible in exchange for a longer analysis\nphase. But software development teams must also understand that over-specification\ncan lead to a state of analysis paralysis.\nDEFINITION\nAnalysis paralysis—A productivity block created in search of the\nperfect—unattainable—design\nIn extreme cases, bureaucratic or regulated environments may demand over-specifica-\ntion by requesting specification documents that can run into thousands of pages.\n(Bear in mind, though, that analysis paralysis isn’t limited to written specifications.)\nBut unless you’re making software for surgeons, analyzing every single detail in\nadvance often feels unnecessary—even harmful. \n1.3.2\nHand-offs\nHanding off requirements looks like a classic waterfall mistake—an artifact from the\npast—but I still see agile teams struggling with hand-offs, often due to their organiza-\ntion’s internal politics. Any requirement can be handed off.\n",
      "content_length": 2338,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 35,
      "content": "9\nCommon specification pitfalls\nDEFINITION\nHand-off—A situation in which somebody analyzes requirements\nwithout the input of the delivery team, signs off on the scope by writing down\nthe analyzed requirements, and later hands off those requirements to the\ndelivery team to complete\nHand-offs result in a fragmented communication flow between business and delivery.\nIn my experience, people who hand off requirements are often business users, manag-\ners, analysts, product owners, or designers, depending on the chain of command in a\ngiven organization. In a management-oriented company, managers are more likely to\ncreate an environment where they can decide on the list of requirements and the\nscope, trying to maintain control over important decisions. I’ve seen the same thing\nhappen with design teams in design-oriented organizations. And engineers, too, can\nhand off requirements if they’re within their areas of expertise. (Think of technical,\nnonfunctional requirements such as performance, security, or low-level integrations.)\nNobody’s a saint.\n Such organizations mistake the communication structure for the organizational\nstructure. A company can be management-oriented, design-oriented, or engineering-\noriented and still have a healthy, collaborative, and inclusive process.\n Hand-offs cause various problems with delivery. A team that only receives a specifi-\ncation won’t understand the context in which the requirements were collected. Their\ndecision-making abilities will be impaired when it comes to split-second decisions. The\nteam won’t be able to make on-the-fly decisions because they won’t know the thought\nprocess that led to making the requirements the way they are. They will only see the\nfinal result—the specification. They may also be too afraid to change anything. And in\nover-specified documents, contradictions and ambiguities can occur easily. When\nhand-offs like these happen, misunderstandings creep in and cause expensive rework\nto appear later in the process.\nTIP\nDon’t let documentation replace communication. \n1.3.3\nUnder-documentation\nMany delivery teams burnt by over-specification discard it in favor of an implementation-\nfirst approach, eradicating any up-front practices. An implementation-first approach\noptimizes for writing software without dealing with wasteful documentation and speci-\nfications. It rejects huge design commitments before customers prove they want the\nsolution—and the only way to prove it is to hack some code together and release it as\nsoon as possible, rejecting any process that doesn’t help write production code. For\nexample, Extreme Programming advocates use no extra design documents and let the\ncode speak for itself. Running code doesn’t lie, as a document might. The behavior of\nrunning code is unambiguous.\n Initially, the implementation-first approach feels efficient, especially in young com-\npanies—but as the organization grows and the product matures, diseconomies of scale\nkick in. Not everyone is a coder. Communication and decision-making start causing\n",
      "content_length": 3040,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 36,
      "content": "10\nCHAPTER 1\nIntroduction to specification by example and Gherkin\ntrouble, and adding new people to the team slows work instead of making it faster. I\ncall such a specification anti-pattern under-documentation.\nDEFINITION\nUnder-documentation—Discarding documentation and letting\ncode speak for itself in order to speed up development\nUnderdocumented teams are left with no clear path to track decisions made in the\npast. Institutional memory suffers; when people who worked on implementation\nbecome unavailable, temporarily or permanently, they take their knowledge with\nthem. Building long-term understanding within the company often requires addi-\ntional facilitation. Many teams hurting from under-documentation realize its down-\nsides too late when fixing the problem gets painful.\nTIP\nDon’t let agile be an excuse to ignore documentation. \n1.3.4\nSpeci-fiction\nDocumentation and specification artifacts grow obsolete easily. As your product\nevolves over time, requirements often evolve, flat-out change, or turn out to be poorly\ndefined and have to be refined. Documentation and specifications, like all internally\ncomplex documents, are often too difficult to update on a regular basis without intro-\nducing some inconsistencies. Outdated and unwanted, they become speci-fiction. (Yes,\nI invented the word. No, I’m not a poet.)\nDEFINITION\nSpeci-fiction—A specification that poses as a single source of truth\nbut that can’t be one because nobody cares to update it\nIf you’ve ever struggled with outdated documentation, you’re already familiar with the\nphenomenon of speci-fiction. Sometimes documents are left outdated because of\nmultiple last-minute changes. In this case, the fiction in speci-fiction is that a new\nreader would be led to falsely believe that the specification or documentation\ndescribes the entire system as it is, when the working system is, in fact, different,\nbecause the requirements were changed during the release frenzy. Speci-fiction is\nonly an illusion of correctness—an illusion that occurs when no single, reliable source\nof truth exists. \n1.3.5\nTest-inability\nThe INVEST mnemonic for agile software projects is a common reminder of the char-\nacteristics of a good-quality product backlog item such as a user story (see table 1.1).\nMuch of INVEST is beyond the scope of this discussion; I won’t expand on the topic\ndirectly, but I already talked about such characteristics as valuable and small when I dis-\ncussed the difference between the right delivery and the right software at the begin-\nning of this chapter and when I talked about over-specification and long specification\ndocuments.\n",
      "content_length": 2625,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 37,
      "content": "11\nMeet specification by example and Gherkin\n \nI’d like to focus on the testability part, which many teams overlook. I’ve met many pro-\ngrammers and testers who, when working on a user story, weren’t sure where to start,\nwhat to test and what not to test, how much to test in one go, what to call their tests,\nand how to understand why a test fails.\n According to INVEST, testability should be baked into a good user story, because\ntestability lays the foundation for quality. How can you be sure that you delivered any\nbusiness value if you don’t know how to test its implementation? Or how can you know\nthat you’ll continue to deliver value in the future, regardless of any system changes or\nerrors? What I call test-inability is a team’s failure to answer questions like these—a fail-\nure that originates in a bad specification process.\nDEFINITION\nTest-inability—Lacking clear measures of value that can support\ndevelopment \n1.4\nMeet specification by example and Gherkin\nDelivery teams choose the implementation-first approach despite its shortcomings\nbecause it gives them the freedom, agility, and productivity they love. On the other\nhand, the up-front approach has the upper hand in consistently producing somewhat\nreliable documentation. Is there any method that combines the best of both worlds?\nFortunately, yes. Of the many tools and methodologies introduced by the community\nto reshape traditional specification methods, I find two particularly interesting and\nexplore them in the book: SBE and Gherkin.\n Specification by example, a set of practices that sprang from the agile acceptance-\ntesting tree, is a collaborative approach to defining software requirements based on\nillustrating executable specifications with concrete examples. It aims to reduce the\nlevel of abstraction as early in the process as possible, getting everyone on the same\npage and reducing future rework.\n Gherkin, a business-readable domain-specific language, provides a framework for\nbusiness analysis and acceptance testing. Gherkin helps you understand requirements\nfrom the perspective of your customers. By forcing you to think about what a user’s\nworkflow will look like, Gherkin facilitates creating precise acceptance criteria. The\nTable 1.1\nThe INVEST mnemonic\nLetter\nMeaning\nDescription\nI\nIndependent\nThe story should be self-contained.\nN\nNegotiable\nThe story should leave space for discussion about its scope.\nV\nValuable\nThe story must deliver value to the stakeholders.\nE\nEstimable\nThe delivery team should always be able to estimate the size of the story.\nS\nSmall\nThe smaller the story, the easier it is to analyze and estimate correctly.\nT\nTestable\nThe story should support test development.\n",
      "content_length": 2693,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 38,
      "content": "12\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nbook uses a Cucumber version of Gherkin’s syntax. If you don’t yet know what that\nmeans, don’t worry—I’ll explain everything in chapter 2.\n SBE and Gherkin reimagine the traditional software development process. Every\nsoftware development process follows similar phases as functionality progresses from\nconception to release (see figure 1.1). In most agile software development methodol-\nogies, the phases are as follows:\nPlanning implementation\nBuilding the product\nLaunching the product\nGetting feedback\nMany teams also fall into a trap of treating specifying as a one-time activity that occurs\nduring the planning phase, instead of as a process that keeps occurring as requirements\nevolve and change, which they often do throughout development. Teams that don’t\ntreat specification as a long-term process often behave like automata—machines\ndesigned to automatically follow a predetermined sequence of operations. In such a\ncase, the sequence is defined during the planning phase and must be followed as long\nas no problems occur. But when a problem does occur, it’s often already too late.\n With SBE and Gherkin, as shown in figure 1.2, we follow a different paradigm.\nThis paradigm requires us to use practices that must be performed throughout the\nentirety of a project—from analysis to maintenance. You’ll see why when I talk more\nabout designing acceptance tests (a testing activity) and building living documentation (a\nmaintenance activity). Instead of creating a static document with requirements, I’ll\ntalk about a system of dynamic specification documents that constantly evolves along\nwith the product.\n1. Plan\nSoftware\ndevelopment \nlife cycle\n3. Launch\n4. Feedback\n2. Build\nTraditional specification\nFigure 1.1\nThe place of specifications in the \ntraditional software development process\n",
      "content_length": 1873,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 39,
      "content": "13\nMeet specification by example and Gherkin\nIf you’re curious about what a specification written in Gherkin looks like, look at this\nexample:\nFeature: Setting starting points and destinations\nScenario: Starting point should be set to current location\nGiven a commuter that enabled location tracking\nWhen the commuter wants to plan a journey\nThen the starting point should be set to current location\nScenario: Commuters should be able to choose bus stops and locations\nGiven a bus stop at Edison Street\nAnd a Edison Business Center building at Main Street\nWhen the commuter chooses a destination\nThen the commuter should be able to choose Edison Street\nBut the commuter should be also able to choose Edison Business Center\nIn order to help you write specifications like this, the upcoming chapters will apply\nSBE’s key process patterns to Gherkin. You’ll be able to offer programmers, designers,\nand managers an inclusive environment for clear communication, discovering\nrequirements, and building a documentation system.\n1.4.1\nKey process patterns\nTeams that apply SBE successfully introduce seven process patterns into their work-\nflow.9 In an SBE process that uses Gherkin—which, as you’ll see later, is only one of\n9 Gojko Adzˇic´, Specification by Example (Manning, 2011).\n1. Plan\nSoftware\ndevelopment\nlife cycle\n3. Launch\n4. Feedback\n2. Build\nSpecification by example\nFigure 1.2\nSBE reimagines the software development process by prolonging \nthe specification process so that it takes place throughout the entire project.\n",
      "content_length": 1528,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 40,
      "content": "14\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nseveral ways of applying SBE—these seven patterns can be split into three distinct\ngroups revolving about the central concept of conversations (see figure 1.3).\n Patterns focused on having conversations aim to increase the knowledge flow between\nthe delivery team and the business as well as within the delivery team, without sacrific-\ning agility. Patterns that deal with automating conversations ensure that the specifications\nstay up to date throughout the project’s life cycle, allowing nontechnical stakeholders\nto check whether the use cases they care about work well within the system.\n Capturing conversations links analysis and automation. Having conversations can’t\nbe a separate development activity, just as you can’t write automated tests for the sake\nof writing tests. That’s where the real magic begins, and where you’ll meet Gherkin—\nit will let you write down your conversations in a form that’s easy to automate. \n1.5\nHaving conversations that identify business needs\nThe main premise of SBE and Gherkin is that frequent conversations between domain\nexperts and the delivery team lay a foundation for the entire development process\n(see figure 1.4). Here are some examples of conversations:\nThe public transport company’s management wants to build new modules into\ntheir timetables system, and you discuss their business needs together.\nAn angry customer explains that your mobile app shouldn’t interpret Edison\nBusiness Center as Edison Street because they’re not the same thing.\nAutomating\nconversations\nSpecification by\nexample and\nGherkin\nCapturing\nconversations\nHaving\nconversations\nRefining\nspecifications\nLiving\ndocumentation\nValidating\nfrequently\nAutomating tests\nbased on\nexamples\nDeriving scope\nfrom goals\nSpecifying\ncollaboratively\nIllustrating\nrequirements\nusing examples\nFigure 1.3\nA high-level look at SBE’s process patterns\n",
      "content_length": 1925,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 41,
      "content": "15\nHaving conversations that identify business needs\nTwo engineers discuss whether the system should treat a bus route as a collec-\ntion of 2D points on a map or a straight line between the start point and the des-\ntination point.\nA commuter files a bug report about the bus-scheduling functionality.\nYou read customer feedback on social media and discover what new functional-\nities users want.\nFrom these examples, we can reason that a conversation means a discussion between\nthe business and the technology. Business domains and technology domains interact\nbecause they have to—if you want to create any software, let alone working software or,\nsometimes, even successful software, the team must understand the business context\nand have required technical excellence. The sections that follow analyze the topics\nthat such interactions can follow.\n1.5.1\nDeriving scope from goals\nConversations typically revolve around four questions:\n1\nWhy are we building this?\n2\nWho are we building this for?\n3\nWhat exactly are we going to build?\n4\nHow will we build it?\nExplore possible solutions with\nconcrete examples to choose the\nbest implementations.\nFind the answers together\nwith business stakeholders.\nAnswer why, who, what, how.\nAutomating\nconversations\nSpecification by\nexample and\nGherkin\nCapturing\nconversations\nHaving\nconversations\nDeriving scope\nfrom goals\nSpecifying\ncollaboratively\nIllustrating\nrequirements\nusing examples\nFigure 1.4\nHaving conversations should provide delivery teams with \nall the answers necessary to understand a project’s goals, and who \ncustomers are and what solutions they need.\n",
      "content_length": 1611,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 42,
      "content": "16\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nSome answers come from the business domain and others from the technology\ndomain (see figure 1.5). Usually, the business domain provides the who and the why,\nand the technology domain provides good what and how answers.\n In general, answering questions at the top of the list will give you enough input to\nask and answer the questions at the bottom. Such a practice—getting from business\nobjectives to programmable solutions—is what SBE’s practitioners call deriving scope from\ngoals. Over the last five years, deriving scope from goals emerged as probably the most\nimportant practice in the modern landscape of software development.\n Every major conference now features someone talking about the value of delivery\npeople understanding business goals and designing software according to their com-\npany’s objectives. Techniques such as impact mapping, feature injection, and user-\nstory mapping have spread widely, changing the business analysis landscape. I, too,\nwill talk about these techniques throughout the book.\n The questions I listed help delivery teams understand why a solution is needed and\nwho needs it. Answering them means discussing the company’s goals and establishing\nsuccess metrics. The goals and metrics, in turn, allow you to determine the scope of\nfuture work the team must deliver and build a framework that will let the team say\nwhether they’re making progress in terms of reaching their goals. \n1.5.2\nIllustrating requirements with examples\nSBE and Gherkin require delivery teams to support their conversations with practical\nexamples. Illustrating requirements with examples helps reduce the level of abstraction\nand leads to clearer acceptance criteria—especially if the examples are concrete\ninstead of vague.\n Humans prefer stories illustrated with examples. Say you were a lawyer who wanted\nto explain to your friend how splitting royalties works. If you said, “The writers should\nsplit the salary based on their contribution,” your friend might not have a good idea\nBusiness needs\nand problems to solve\nDesign and\narchitecture\nThe business\ndomain\nConversation\nWho and why\nRequirements\nWhat and how\nSolutions\nThe technical\ndomain\nFigure 1.5\nThe business and \ntechnology domains must meet over the \ncourse of a conversation if you want to \nunderstand the business goals and set \nthe optimal project scope.\n",
      "content_length": 2402,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 43,
      "content": "17\nHaving conversations that identify business needs\nof what you meant. Each of you might understand the concept of “contribution” dif-\nferently. But let’s change that to “Here’s an example: John, Gilly, and Robbie wrote a\n250-page book together. John and Gilly wrote 100 pages each, so they should get 40%\nof the salary, because they each wrote 40% of the book—and Robbie, who wrote only\n50 pages, should get 20% of the salary, just as 50 is 20% of 250.” This time, your friend\nwould probably grasp the full idea in a split second.\n Clear storytelling invites good examples, because examples help us build better\nmental models of the new concepts we encounter. They’re anchors. Links. Cognitive\nshortcuts. Most important, they reduce the likelihood of misunderstanding the pur-\npose of a story. Requirements illustrated with good examples inherit all these benefits.\nThey’re simpler to digest and easier to keep in your head.\n Let’s look at a conversation without any concrete examples and a conversation full\nof examples to see if that’s true. Here’s the first conversation:\n“Okay, so how should the application work?”\n“I suppose that when commuters download our mobile app, they should be able to provide\na starting point and a destination point, and see a timetable with all the bus lines and\ndeparture times they might find helpful in getting to the destination. It’s very simple,\nreally.”\n“Seems that way.”\nSuch a conversation raises more questions than it answers. What are the starting\npoints and destination points? Are they streets? Bus stops? Buildings and other places?\nAnd what exactly may a commuter “find helpful in getting to the destination?” There’s\nno way we can know for sure.\n What would happen, though, if we asked for concrete examples during the discussion?\n“OK, so how should the application work?”\n“Let’s not jump to conclusions. Imagine for a moment that you’re going to the city, say,\non a business trip. How and when do you get there?”\n“Well, I guess I might arrive a day earlier to be sure nothing goes wrong.”\n“So we’re going to need a functionality to filter the timetables by date.”\n“Yes, we are. But let’s consider what happens if the you’re a bit more happy-go-lucky and\narrive in the city an hour before the meeting. You don’t have enough time to check where\nyou are. Or maybe you don’t know the exact street you must arrive at.”\n“Wow, we might need to implement a GPS geolocation functionality so we could help\nusers know their current location.”\n“Yeah, and there should be an option to search for locations such as parks, buildings,\nand restaurants instead of only bus stop names.”\n“Seems that way.”\nConversations with examples look similar to short stories about a system’s behaviors.\nGood stories are vivid and build a platform for fertile discussion between the people\n",
      "content_length": 2810,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 44,
      "content": "18\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nwho read them. Bad stories confuse readers and leave people clueless. The same is\ntrue for good and bad specifications. \n1.5.3\nSpecifying collaboratively\nAs you’ll see in the sections to come, SBE and Gherkin redefine the distinction\nbetween analysis, design, and implementation by building a bridge between require-\nments and code. The practitioners should see the act of specifying as a process of con-\ntinuous discovery through reducing their uncertainty about the requirements.\nSpecifying is not a single activity or a phase to go through. In an agile process, require-\nments evolve as a project progresses because rarely does the knowledge exist up front\nto specify an application adequately.\n Every time you have a conversation about your product, every time you ask a ques-\ntion about a requirement, every time you encounter a bug, every time you hear cus-\ntomer feedback—you’re discovering whether your assumptions about the product are\ntrue or false. You’re learning.\n Sometimes, though, organized effort may be required to produce a reliable,\nrepeatable specification process in a complex environment with multiple stakehold-\ners. In such cases, SBE encourages specifying collaboratively by inviting the stake-\nholders to specification workshops or holding smaller, more regular meetings within\nthe delivery team.\n The participants should use the specification workshops to capture and refine\ngood, concrete examples that emerged when the delivery team tried to derive scope\nfrom the business goals. They should then match the examples with requirements and\nacceptance criteria, letting the examples guide their analysis efforts.\n Depending on the size of the team and the complexity of the product, specifica-\ntion workshops can range from multiday sessions featuring every important stake-\nholder to short, regular meetings between product owners, senior engineers, and\ndesigners. These workshops put a strong emphasis on knowledge sharing. Including\ndiverse participants guarantees exploring multiple perspectives and covering different\nangles. Knowledge should flow freely within the team. Analysts, designers, developers,\nand testers should strive to understand what they’re about to build, asking as many\nquestions as they deem relevant. To achieve a common perspective on how customers\nwill use the software, participants should learn the ubiquitous language of the busi-\nness owners and the customers. Long story short, they should build a short-term\nunderstanding of the requirements that will guide their efforts in planning and\nduring implementation.\nWARNING\nThe topic of organizing and facilitating specification workshops,\nalthough important, is beyond the scope of the book, which focuses on writ-\ning skills. I only talk about workshops briefly in section 7.4. Chapter 7 is also\nwhere I mention a few resources and techniques for organizing workshops.\nFor now, I advise you to read Gojko Adzˇic´’s original Specification by Example;\nchapter 6 talks about collaborative specification. \n",
      "content_length": 3076,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 45,
      "content": "19\nLong-term benefits of automating conversations\n1.6\nLong-term benefits of automating conversations\nAfter the delivery team collects examples, team members create specifications out of\nconversations recorded in Gherkin. They automate the conversations and examples\nwith software tests, validating the tests frequently to make sure the specifications stay\nup to date (see figure 1.6).\nI’ll now talk about the elements of the automation process and why automating speci-\nfications gives delivery teams an enormous advantage. Don’t be surprised that I\nhaven’t yet discussed recording conversations in Gherkin, even though the translation\nprocess is a prerequisite for automation. I want you to understand the benefits and\nchallenges of team specification and automation first, so that you’ll be free to draw\nyour own conclusions when we explore Gherkin.\n1.6.1\nAutomating tests based on examples\nSBE requires delivery teams to use conversations to collect meaningful examples that\nhelp the team understand the requirements. From examples, tests are created. Good\nexamples make tests better and more business-driven by covering real-world use cases\nprovided by business stakeholders and customers. In the end, tests verify whether the\ndelivery team implemented requirements correctly. You can see the schematics of this\nprocess in figure 1.7.\nConversations and examples are\nautomated as software tests.\nTests based on examples can  \nbe run upon each build when \nany errors are signaled.\nTests and their conversations\nbecome documentation.\nAutomating\nconversations\nSpecification by\nexample and\nGherkin\nCapturing\nconversations\nHaving\nconversations\nLiving\ndocumentation\nValidating\nfrequently\nAutomating tests\nbased on\nexamples\nFigure 1.6\nAutomation turns conversations into executable test cases \nthat, if validated frequently, become long-term system documentation.\n",
      "content_length": 1860,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 46,
      "content": "20\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nAutomating ties conversations and examples to system behaviors. Tests return binary\nresponses about every conversation you capture. A conversation either passes your\ntest, meaning the behavior was implemented correctly, or it fails the test, meaning the\nsystem is incomplete or broken.\n If an example passes the test, you know that the acceptance criterion illustrated by\nthe example is still relevant. If the test is failed, you’re notified that the changed code\nbase no longer satisfies the acceptance criteria. If that’s the case, the examples should\nchange to reflect that—and sometimes the code has to change, too. (The code could\nbe right and the example now outdated, or the example could be right and the code\nwrong. In each case, you fix a different thing.)\n Why is that? Imagine that the example public transport company introduces new\nexpress buses. These vehicles skip most of the bus stops on their way, in order to get to\nthe destination point more quickly. Your team now needs to add express buses to the\nmobile app. It’s a simple change in terms of code: somebody must add a new attribute\nto the database that determines whether a bus line is an express line or a regular one.\nEasy peasy. You make the change quickly and then take a lunch break.\nThat’s when all hell breaks loose. (Almost.)\nThe team forgot that the timetables module isn’t the only one affected. The mobile\napp also features a live map that shows how the buses closest to the user move around.\nA commuter can check which buses are which in the legend on the map. The legend\nis generated automatically, but adding the new type of express bus broke the program-\nming logic behind it. As a result, the legend has disappeared. For the few days before\nyou notice the problems, commuters not only aren’t able to distinguish express buses\nfrom regular buses—they aren’t able to find any buses on the map.\nIf you had any documentation in place, the change made it inaccurate and out-\ndated. Nobody updated the document, because your team wanted to have lunch.\nThat’s what usually happens: people forget, production hotfixes creep in, the Four\nHorsemen of the Apocalypse drop by. And when the dust settles, your carefully pre-\npared documentation no longer reflects the current state of the system. In this case, it\ndoesn’t tell the reader that there are two types of buses, and it doesn’t explain the dif-\nference between them. Step by step, with every hotfix and every negligent change, the\ndocumentation becomes irrelevant. \nExamples\nRequirements\nVerify\nElaborate\nCan become\nTests\nFigure 1.7\nCollecting examples that illustrate \nrequirements is the first step to create \nmeaningful, business-driven, automated tests.\n",
      "content_length": 2760,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 47,
      "content": "21\nLong-term benefits of automating conversations\n1.6.2\nValidating frequently\nNone of these problems would arise if your conversations and examples were auto-\nmated. When conversations are run as tests, you can regularly track which ones\nbehave correctly and which ones don’t. If you test frequently and your specification is\nexhaustive, you’ll get instant feedback after you make a change to the code base.\n You can validate during the development process or before a release—what mat-\nters is that you must do it often. The more often you test, the sooner you can spot pos-\nsible errors.\n Captured conversations should be validated against both the existing system and\nnew code as it’s being written. If you validate conversations frequently, you can have as\nmuch trust in the specification as you have in the code. This way, you create a more\naccessible way to review implemented requirements for all stakeholders.\n Because SBE and Gherkin see development as a process of constant discovery\nthrough reducing uncertainty about requirements, the model of the system is, by defi-\nnition, not fully defined from the beginning—it’s only defined well enough. It evolves\ncontinuously based on feedback from stakeholders, and new examples and domain\nconcepts enter the specification as new elements are added to the code. To make sure\nthese new examples fit into the system, delivery teams need a process of continuous\nintegration.\nDEFINITION\nContinuous integration—A software development practice where\nmembers of a team integrate their work frequently. Each team member\nshould integrate as often as possible, leading to multiple integrations per day.\nEach integration is verified by an automated build to detect integration errors\nquickly.\nIf the team uses a testing tool (like Cucumber, a Gherkin-compatible test runner),\nthe tests can be run on each software build. If any errors are signaled, they can be\ncaught early and fixed, letting the “integrate, build, test” process start again—this\ntime, successfully. \n1.6.3\nLiving documentation\nAs much as we’d like it to be otherwise, only working production code holds the truth\nabout the system. Most specifications become outdated before the project is delivered.\nBecause every product is a machine made out of thousands of moving parts, the dat-\ning problem becomes a curse of all software projects.\n Outdated documentation may seem like a reliable source of knowledge about the\nsystem, but it only misleads its readers. An automated, frequently tested specifica-\ntion—as well as the examples included in it—is resistant to such problems. The direct\nconnection between scenarios and code often reduces the damage by cultivating a sys-\ntem of living documentation.\n \n",
      "content_length": 2715,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 48,
      "content": "22\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nDEFINITION\nLiving documentation—Documentation that changes along with\nthe system it documents, thanks to the link between the text and the code as\nwell as frequent validation.\nWhen tests keep specifications in check, they let specifications with examples evolve\ninto a documentation system. Using executable specifications as living documentation\nmeans taking advantage of automation to facilitate learning within the team and their\ndecision-making abilities. When Gherkin scenarios are free of unnecessary technical\nbloat, well written, accurate, and full of business-oriented examples and domain\nvocabulary, they can serve as a single source of truth that everyone uses to learn about\nthe functionalities in question.\n Thanks to frequent validation, you know that your tests, examples, and conversa-\ntions are up to date; and when you trust your tests, you can use them as documenta-\ntion for the entire system. You can track every test back to its origin—the conversation\nyou had with your stakeholders about the requirement. When in doubt, you or any-\none else on your team can always check the captured conversation. Frequent valida-\ntion also guarantees that the documentation must change every time the underlying\ncode changes, because the documentation is connected to the code through tests.\n A living documentation system should benefit everyone. Specifying collaboratively,\nillustrating requirements with examples, and refining specifications for readability—\nall these measures should involve everyone who matters in the requirement-analysis\nprocess, or a few dedicated people can make the requirements as easy to understand\nas possible for everyone else. Everyone involved should be able to read the results,\ntoo. Tools such as Relish, Cucumber Pro, and CukeHub can even integrate with a\ncode repository of your choice and publish the scenarios in a private cloud where you\ncan collaborate and share executable specifications and test results with other team\nmembers, as easily as you can share a document in Google Docs. \n1.7\nCapturing conversations as executable specifications\nOkay, so automating conversations offers a lot of benefits. But how do we automate\nthem? At the beginning of section 1.6, I promised that we’d come back to the topic of\nrecording conversations in a language that will help you optimize them for automa-\ntion. This section discusses the refinement process that makes free-flowing conversa-\ntions easy to automate (see figure 1.8).\n Specification workshops allow for having conversations. Programmers and testers\nare responsible for automation. How does the translation process happen? Should\nprogrammers store conversations as comments in their testing code? That would be\nridiculous—but the records have to be written somewhere, don’t they? A free-flowing\nconversation is, by definition, an unreliable medium that only stimulates short-term\nmemory. We need long-term storage.\n As introduced earlier, Gherkin is the tool for capturing conversations about\nrequirements in a formalized way, clarified by extracting essential information and\nremoving noise. Gherkin facilitates knowledge sharing among all stakeholders,\n",
      "content_length": 3224,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 49,
      "content": "23\nCapturing conversations as executable specifications\nregardless of their technical skill. It does so by conveying tests and requirements in a\nready-for-automation template that’s expressed in plain English and that uses the\nubiquitous language of a product.\n Gherkin focuses on capturing conversations as scenarios. Scenarios preserve essen-\ntial information and remove noise by extracting concrete actions from conversations.\nDEFINITION\nScenario—A concrete example that illustrates a business rule\nFollowing is an example of a scenario. Remember the conversation about how the\nmobile app for journey planning should work?\n“Let’s imagine that you’re going to the city on a business trip. When do you get there? ...\nIf you’re a bit happy-go-lucky and arrive in the city an hour before the meeting, you don’t\nhave enough time to check where you are.”\n“Wow, we might need to implement a GPS geolocation functionality, so we could help\nusers know their current location.”\nHere’s the same conversation expressed in Gherkin:\nGiven a commuter that enabled mobile location tracking\nWhen the commuter wants to plan a journey\nThen the starting point should be set to current location\nThis sequence is called the Given-When-Then template. I’ll talk about it in detail in\nchapter 2, where you’ll learn the basics of using the template.\n Thanks to its focus on user actions, Gherkin is a great language for conveying\nbehavioral requirements. Just as having conversations improves a delivery team’s short-\nterm understanding, capturing conversations ensures that they don’t let that knowl-\nedge slip through their fingers in the future. Scenarios achieve that and remind us\nConversations must be written\nexplicitly in an automation\ntemplate and refined to feature \nonly key examples. \nAutomating\nconversations\nSpecification by\nexample and\nGherkin\nCapturing\nconversations\nHaving\nconversations\nRefining\nspecifications\nFigure 1.8\nThe capture process aims to preserve verbal product-design chats and \ntranslate them to lightweight, long-term, formalized stories that, in time, can be used \nto put together system documentation.\n",
      "content_length": 2113,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 50,
      "content": "24\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nthat we don’t need 100-page functional requirements documents to capture what’s\nvaluable. We don’t even have to write all the scenarios up front. We can capture a few\nscenarios at a time, as we discuss each new requirement. A few months in, we’ll have a\nhuge library of relevant scenarios. We only need to be consistent.\nDEFINITION\nBehavioral requirement—A requirement formed as a story about\nhow users behave when they interact with the system. Whereas normally\nrequirements can be formed as abstract statements, behavioral requirements\nalways talk about examples of using the system.\nThe contents of the template should use nontechnical language that relies heavily on\nreal-world business concepts. Notice how the example mentions commuter, journey, and\nthe starting point—concepts borrowed from the business vocabulary of the public\ntransport company—but doesn’t say anything about low-level development proce-\ndures or the application’s user interface. Scenarios captured using the Given-When-\nThen template should stay at a business-readable, code-free level at all times, improv-\ning the domain model and building its ubiquitous language.\nWARNING\nIf you see anything about a connection to the database in a Gher-\nkin scenario, or read about buttons or any other UI element, somebody made\na huge mistake.\nBecause programmers and testers can automate anything put in the Given-When-\nThen template, scenarios written in Gherkin become executable specifications. This book\nwill teach you to write executable specifications in Gherkin and use the Given-When-\nThen template. You’ll also learn the rest of the Gherkin syntax required to capture\ndesign conversations in a form that easily translates to executable specifications.\nDEFINITION\nExecutable specification—A specification that can be run as an auto-\nmated test\nThe syntax serves as a link between speech, text, and automated code. It lets you prog-\nress naturally from one to another. Gherkin also provides techniques to organize sce-\nnarios into full documents, link similar behaviors, and simplify capture and\nautomation, all while keeping things at a business-readable level derived from the\nubiquitous language.\n Most executable specifications contain many scenarios, and every scenario needs\nmultiple examples. In its rough form, an example is like a quick note or a doodle. It\nmakes sense when you look at it a day after you made it, but try examining it six months\nlater—not so meaningful anymore, right? That’s why successful teams don’t use raw\nexamples; they refine them. A team extracts the essence of key examples and turns it\ninto clear, unambiguous, organized specification documents, as shown in figure 1.9.\n As new requirements appear, acceptance criteria generate new examples, and\nevery example generates a new scenario. To refine executable specifications, teams\nmerge similar examples, reject examples that introduce noise, and choose the most\n",
      "content_length": 2988,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 51,
      "content": "25\nMaking software that matters\nmeaningful or descriptive examples. The result is an executable specification in its\nfinal form, ready to become the foundation for the living documentation system. \n1.8\nMaking software that matters\nYou’ve now begun the journey of mastering executable specifications written in Gher-\nkin according to SBE’s key practices. As you learn more about SBE and Gherkin, we’ll\nfocus on practicing techniques that help you avoid common specifying pitfalls. When\nsoftware engineers and designers don’t put enough thought into their specifications,\nthe cost is measured in weeks of work and hundreds of thousands of dollars wasted.\n The benefits of SBE and Gherkin go far beyond reducing rework. You’ll get better\ninsight into your business domain and reduce friction caused by inevitable translation\ncosts that come up when a business requirement becomes working software. People\nmade these tools and processes because they wanted to guarantee that the software they\nhelp build will make sense to customers. They wanted to make software that matters.\nRaw examples\nRaw scenario\nRaw examples\nAcceptance\ncriterion\nRaw scenario\nRefined example\nRefined scenario\nRefined example\nRaw examples\nRaw scenario\nRefined scenarios contain\nonly key examples needed to\nunderstand the criterion.\nAn acceptance criterion \nneeds examples that pass \nor fail the criterion.\nRaw examples generate\nraw scenarios that often \nhave similar structure.\nFigure 1.9\nThe process of refining raw examples extracted from collected acceptance \ncriteria into refined scenarios with key examples\nSBE, BDD, or ATDD?\nWhen I started my journey with executable specifications, like many other practitioners\nI was confused by the naming issues around the topic of agile acceptance testing.\nWhen I found out that many people call SBE behavior-driven development (BDD) or\nacceptance test-driven development (ATDD), I didn’t understand the difference.\n",
      "content_length": 1930,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 52,
      "content": "26\nCHAPTER 1\nIntroduction to specification by example and Gherkin\nBecause this is a book about practical application of executable specifications with\nexamples, it mainly deals with capturing conversations in Gherkin and refining exam-\nples. It’s a long-ignored topic due to Gherkin’s seemingly easy syntax and elusively low\nentry barrier. Many software engineers and designers think they need a quick tutorial\nand then can start writing. It’s only a simple Given-When-Then sequence, right?\n Yes and no. Everything depends on the project you’re dealing with. At first, having\nexecutable specifications will yield better alignment without much training—but com-\nplex products with complicated business domains can go astray quickly. Hundreds of\nrequirements will produce hundreds of Gherkin files you have to manage. And every\nfile will contain multiple scenarios, and every scenario will attach additional example.\nThat sounds like Gherkin and SBE don’t fit huge projects well; but, truth be told, huge\nprojects will stretch every process and tool. As you’ll see, executable specifications\nwith examples shine the brightest in complex environments—but that’s why I’m writ-\ning a book, and not a blog post.\n You don’t have to be able to write testing code to read the book. I’ll cover automat-\ning conversations only as long as it introduces good patterns that will make life easier\nfor your engineers. Having said that, we should always value business-oriented specs\nover specs that are easy to automate. Similarly, I won’t talk about anything related to\nhaving product-design conversations during specification workshops, unless it directly\nimpacts you when writing specifications in Gherkin. There are other resources that\nteach these skills well enough.\n I do expect you, however, to understand the basics of the automated testing process\nand why it matters. Practical knowledge about the QA process will be helpful in some\nof the later chapters. If you have a technical background or are experienced in work-\ning with developers and QA engineers in any agile methodology, you’ll be fine. I also\n(continued)\nMy confusion was deepened by the fact that I became interested in SBE after reading\nGojko’s book, but the first project where I was able to practice writing executable\nspecifications used Gherkin. In his book, Gojko wrote that he didn’t “want to use any\nof the Driven Development names, especially not Behavior-Driven Development.” But\nGherkin was invented by Dan North and Chris Matts, and Dan North is the main face\nof BDD. I was perplexed.\nI wanted to avoid naming controversies, because they aren’t key to what you’re going\nto learn. I honestly admit that I borrowed freely from both fields, trying to create a mix\nthat will maximize benefits and minimize mental load. Dan North calls BDD a meth-\nodology; but, quoting Gojko, what I wrote here doesn’t form a fully fledged software\ndevelopment methodology. My only goal is to teach you to write great Gherkin speci-\nfications using SBE practices. So whenever I talk about a practice or an idea derived\nfrom SBE, I’ll tell you that up front. Everything else will appear under the umbrella\nterm of Gherkin and good Gherkin practices; if you want to read more about it, you\ncan assume it comes from the field of BDD.\n",
      "content_length": 3279,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 53,
      "content": "27\nSummary\nexpect you to understand what it takes to release a product, from its conception\nthrough the public announcement to long-term maintenance. Some of the things\nwe’ll discuss will cover not only initial requirements but also possible changes in scope\nthat a product can face at a later stage of its life cycle.\n What will you learn? The next chapter explores Gherkin and SBE in practice. You’ll\nbegin by capturing requirements and acceptance criteria as executable test cases. As\nyou progress through the book, you’ll tackle more-advanced topics. You’ll learn to\nwrite good scenarios. You’ll see how to choose good examples. You’ll design business-\noriented error checks. When the time comes, you’ll move on from thinking about\nsuites of specifications, and you’ll learn to organize scenarios into groups of coherent\nspecification documents that readers can navigate easily. I’ll also talk about how the\nubiquitous language shapes examples and scenarios, and how to evolve specifications\ninto a living documentation system over time.\n Right now, though—right now, welcome to specification by example and Gherkin. \n1.9\nSummary\nA specification is a description of the system design required to implement the\nsystem.\nAcceptance criteria let you review whether you’ve built a complete system.\nA ubiquitous language is a common language among developers, business\nstakeholders, and end users. It makes every stakeholder sure they’re talking\nabout the same things.\nSpecification by example is a business-analysis process aiming for “just enough,”\njust-in-time software design. Lightweight examples provide enough initial con-\ntext to start development and are later refined into more-sophisticated forms.\nGherkin is a business-readable language for writing specification documents.\nGherkin’s practitioners capture conversations about requirements in the form\nof behaviors—also called scenarios—which are examples of how the system is\nexpected to behave.\nAn executable specification is a conversation captured using the Given-When-\nThen template with a corresponding acceptance test. The acceptance test\nmakes sure the delivery team has implemented the underlying requirement\ncorrectly.\nEvery executable specification’s life cycle starts with a specification that later\nbecomes an automated test. Automating the specification ensures that it stays\nup to date, because the captured conversation is directly tied to testing code.\nThis way, tests become documentation.\nGherkin and SBE arm you with software development techniques that facilitate\nknowledge sharing, reduce short-term waste without sacrificing long-term docu-\nmentation, and help the delivery team deliver software faster and without\nrework thanks to meaningful, concrete examples of system behaviors that\nensure everyone’s on the same page.\n",
      "content_length": 2813,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 55,
      "content": "Part 1\n Writing executable\nspecifications with examples\nP\nart 1 of this book consists of six chapters that discuss the ins and outs of writ-\ning executable specifications in Gherkin. Chapters 2 and 3 will teach you about\nGherkin—the language in which you’ll write scenarios. Chapters 4 and 5 discuss\nthe art of writing a special kind of scenario called a scenario outline, as well as\nchoosing good examples. Chapters 6 and 7 talk about what happens when a\nspecification is “finished,” explain its life cycle, and go into depth about creating\na living documentation system.\n",
      "content_length": 573,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 57,
      "content": "31\nThe specification layer\nand the automation layer\nIf you haven’t worked with Gherkin and specification by example (SBE) before,\nchapter 1 may have shown you your first Gherkin scenario (listing 1.1). We haven’t\nyet written a full Gherkin specification document together, though, and we’ll need\nmore practical examples to do that.\n Chapter 1 also talked about how conversations captured in Gherkin become\nautomated tests and how automation keeps executable specifications up to date.\nBut we didn’t discuss any details. What does automation mean in the context of SBE?\nHow can you automate conversations? Are there any tools you can use? These are\nall legitimate questions.\nThis chapter covers\nUnderstanding an executable specification’s \nlayers\nUnderstanding the structure of those layers\nWriting your first Given-When-Then scenarios\nExploring how the specification layer interacts \nwith testing code\n",
      "content_length": 906,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 58,
      "content": "32\nCHAPTER 2\nThe specification layer and the automation layer\n In this chapter, you’ll learn to write a simple executable specification from scratch.\nThroughout the chapter, you’ll work on an example of a calendar application that\nschedules meetings for its users. (Think Google Calendar.) You’ll write a simple sce-\nnario about what it takes to create new meetings. By doing so, we’ll also explore the\nbasics of the relationship between the two layers of every executable specification, in\norder to understand the technical limitations behind the Given-When-Then template.\n2.1\nThe layers of executable specifications\nEvery executable specification has two layers: a specification layer and an automation layer\n(see figure 2.1). Without the specification layer, an executable specification wouldn’t\nbe a specification. Without the automation layer, it wouldn’t be executable. This sec-\ntion provides a brief overview of both.\n This book deals mainly with the specification layer and the writing aspect of exe-\ncutable specifications—the art of writing Gherkin. But to do that well, you need to\nknow the basics of the automation layer, too. That’s because automation requires the\nspecification layer to be written in a certain way that allows computers to read it.\nReading Gherkin listings\nA quick note on how to read the Gherkin listings placed here and there throughout\nthe book. Because the goal is to get as close to writing the perfect Gherkin scenario\nas possible, some of the listings are rated on a scale from [BAD] to [BEST]. (Not all\nscenarios are comparable, so not all are rated.)\nListings marked [BAD] are anti-patterns, should be avoided, and are mentioned only\nto warn you about their bad effects. The [OK] listings are neither good nor bad; they’re\nmediocre. The [GOOD] and [BETTER] listings are at the quality level you should strive\nfor after reading this chapter. And the [BEST] listings contain non-obvious solutions\nthat become possible only after you’ve applied the advanced tips and tricks from this\nchapter. The best scenarios don’t happen every time, but when they do, it’s extremely\nsatisfying.\nAutomation layer\nExecutable\nspecification\nSpecification layer\nFigure 2.1\nEvery executable specification in Gherkin has two layers \nthat complement each other and create automated tests written in \nnatural language.\n",
      "content_length": 2335,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 59,
      "content": "33\nThe layers of executable specifications\n2.1.1\nThe specification layer\nSimply put, the specification layer of an executable specification is the document you\nread when you want to know what you’re going to build. Gherkin specifications are\nusually short, and even a small project will have multiple documents—all of these doc-\numents together form a large specification layer for the entire project.\nDEFINITION\nSpecification layer—Contains text documents written in Gherkin\nthat humans can read\nIt’s important to understand these three elements of the specification layer (see figure 2.2):\nAcceptance criteria\nScenarios\nThe ubiquitous language\nI’ll talk about acceptance criteria, scenarios, and the ubiquitous language in detail\nlater in the chapter, but here’s a brief summary. Chapter 1 said that specifications talk\nabout requirements and acceptance criteria that the delivery team needs to under-\nstand if they want to implement new features correctly. Gherkin organizes the accep-\ntance criteria by conveying them as scenarios written using the Given-When-Then\ntemplate. The scenarios become elaborate expressions of the ubiquitous language,\nwhich is a common language among developers, business stakeholders, and end users.\nAs you saw in chapter 1, the scenarios are a way to store conversations about require-\nments in a written form: they’re a reflection of how the delivery team talks with the\nbusiness about important domain concepts. You’ll see a similar situation play out later\nin this chapter.\nAutomation layer\nExecutable\nspecification\nSpecification layer\nStores acceptance\ncriteria\nCultivates the\nubiquitous\nlanguage\nConveys\nacceptance criteria\nas scenarios\nFigure 2.2\nThe specification layer of an executable \nspecification is the layer where conversations about \nacceptance criteria are conveyed as Given-When-Then \nscenarios that create the most accurate reflection of the \nubiquitous language between technology and business.\n",
      "content_length": 1951,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 60,
      "content": "34\nCHAPTER 2\nThe specification layer and the automation layer\nHere’s an example of some simple Gherkin text:\nFeature: Teams\nScenario: Enforcing access rules\nFor more information on availability, please look at the\ninvite confirmation scenarios later in the specification.\nIn short, an unavailable person who already confirmed RSVP\ncan be invited to another event at the same time, but will\nbe able to attend only one of them.\nGiven Mike, Kate, and John were assigned to the same team\nAnd Ada was assigned to another team\nWhen Kate and Mike schedule a 1 hour long meeting at 4 p.m.\nThen John should see that Kate and Mike will be unavailable\nBut Ada shouldn't be able to see Kate and Mike's meeting\nAs explained in chapter 1, the sequence within each scenario is called the Given-When-\nThen template. The template and some other repeatable structures visible in the exam-\nple are what enable automation of every Gherkin document.\n The specification layer is created by writing feature files.\nDEFINITION\nFeature file—A file with a .feature extension written in Gherkin\nthat groups related scenarios within a document that provides a specification\nfor a single functionality\nAs a matter of principle, both technical and nontechnical stakeholders can have\naccess to the specification layer of the specification suite. They should be at least able\nto read and understand it if they have to. But as I mentioned, the specification layer\nalso has to be formatted in a way that allows for automation, so some constraints, pre-\ndefined grammar, and strict syntax are always present. This chapter will show you the\nbasics of Gherkin’s automation syntax later on.\nDEFINITION\nSpecification suite—A collection of all executable specifications\nand the testing code for a single project. This collection is usually put in the\nreal codebase where it can be automated and executed. \n2.1.2\nThe automation layer\nThe programmers and testers on your team will use scenarios to write the testing\ncode. The testing code is the executable part of your executable specifications. Every\npart of the specification suite related to executing automated tests is contained within\nan automation layer.\nDEFINITION\nAutomation layer—The automation layer executes a simulation of\nthe implemented application to see if the code behaves as defined in the\nspecification.\nTo make a long story short, every time you want to write a Gherkin specification like\nthe one shown earlier, you have to add a new .feature file to the specification layer of\n",
      "content_length": 2507,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 61,
      "content": "35\nThe layers of executable specifications\nyour specification suite, write the scenarios there, and then add the testing code to the\nsuite (see figure 2.3).\n A specification suite is a kind of test suite. In software development, a test suite is a\ncollection of test cases that are intended to be used to test a software program to show\nthat it implements a specific set of behaviors. Because the tests for executable specifi-\ncations share some qualities with traditional tests but are different in other aspects,\nthe name should be both familiar and new—thus, a specification suite.\n It’s important to understand these three aspects of the automation layer (see figure 2.4):\nThe automation layer is a simulation of a working application that behaves as the\nGiven-When-Then scenarios tell it to.\nThe simulation performs acceptance tests that check whether the system under\ntest behaves in an acceptable way.\nThe automation layer is designed to be a feedback loop that makes accepted spec-\nifications pass the testing process and rejects specifications that weren’t\naccepted, marking them as broken.\nExecutable\nspecification\nExecutable\nspecification\nExecutable\nspecification\nSpecification suite\nExecutable\nExecutable\nExecutable\nspecification\nspecification\nspecification\nSpecification layer\nAutomation layer\nFigure 2.3\nA specification suite, as well as every executable \nspecification in the specification suite, can be split into two layers—\nthe specification layer and the automation layer—which work \ntogether to create a functional testing process.\nAutomation layer\nSpecification layer\nUses feedback\nloops\nRuns acceptance\ntests\nSimulates a\nworking\napplication\nExecutable\nspecification\nFigure 2.4\nThe automation layer runs a \nsimulation of the system, which uses a \nseries of acceptance tests to check \nwhether the system under test works as \nyou expect it to.\n",
      "content_length": 1866,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 62,
      "content": "36\nCHAPTER 2\nThe specification layer and the automation layer\nI’ll talk about feedback loops more in chapter 6 when we get to the topic of an execut-\nable specification’s life cycle.\n As an example of how the automation layer works, suppose you want to test\nwhether a calculator app works well. To do so, you need some samples of addends and\nthe results you expect the calculations to return. The automation layer will then be\nable to execute the testing code responsible for performing calculations and see\nwhether the result returned by the code matches the expected result defined in the\nspecification (see table 2.1).\nTable 2.1\nAn example of the automation layer’s behavior\nInput given\nAutomation layer\nExpected output\n1 + 0\nThe testing code runs …\n1\n1 + 1\nThe testing code runs …\n2\n1 + 2\nThe testing code runs …\n3\n1 + (-1)\nThe testing code runs …\n0\nRunning the automation layer with Cucumber\nThe Given-When-Then template’s syntax enables automation. That’s why tools like\nJBehave and Cucumber use Gherkin, which is a more elaborate evolution of the tem-\nplate. But Gherkin isn’t the only available option. Different tools for automated accep-\ntance testing impose their preferred syntax differently. Some tools, like FitNesse, use\na wiki-like system as the main way of organizing the specification layer.\nJBehave, Cucumber, and FitNesse are all test execution engines.\nDEFINITION\nTest execution engine—A type of software that’s written to\nautomatically test other software. Throughout the book, I use terms\nsuch as test execution engine, test runner, testing framework, and auto-\nmation framework interchangeably.\nThis book teaches a Cucumber-flavored version of Gherkin.\nDEFINITION\nCucumber—A testing framework that can match Gherkin\nfeature files with testing code. It lets programmers run the code that\nautomates the scenarios.\nCucumber emerged from the Ruby community, but it also supports or has an equiva-\nlent for .NET, C++, JS, Lua, PHP, Python, and JVM. It can run Gherkin files written in\nmore than 60 spoken languages—among them Chinese, French, Arabic, and Pirate\nEnglish.a\na https://github.com/cucumber/cucumber/wiki/Spoken-languages.\n",
      "content_length": 2153,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 63,
      "content": "37\nThe layers of executable specifications\n \nA huge variety of learning resources is already available that teach how to deal with\nthe automation layer, so instead this book focuses on mastering the Gherkin layer—a\ntopic that’s underrated by many developers and testers. Also, because you can use\nGherkin with many programming languages such as Ruby, Java, and Python, I wanted\nto stay as language agnostic as possible. If you’re curious about how to write and exe-\ncute automated tests, you can easily find a lot of articles on the web. This chapter\nincludes a brief introduction to the topic of automation, explaining only as much as is\nneeded to understand the depths of the specification layer. \nThe division of labor is simple (see the following figure). Gherkin handles everything\nrelated to capturing conversations about the business logic, from rewriting accep-\ntance criteria as scenarios to modeling the business domain using the ubiquitous lan-\nguage. Cucumber, on the other hand, allows the delivery team to test the system\nusing the same examples that were captured during the analysis and design phases.\nWhy did I choose Cucumber and Gherkin for the book? According to the popularity of\nits open source repository, Cucumber is rising as the most popular testing framework\nsupporting executable specifications, decisively beating both JBehave (10 times as\npopular) and FitNesse (twice as popular). But I discuss a lot of techniques throughout\nthe book that can come in handy for people who use other test runners, too. (Unfor-\ntunately, there are some differences between Cucumber’s Gherkin and JBehave’s\nGherkin in terms of syntax and indentation; due to the scope of the book, you’ll have\nto research the differences between Cucumber and JBehave on the your own.)\nYou’re probably wondering, “Will this book teach me to automate executable specifi-\ncations with Cucumber?” Spoiler alert: it won’t. If you want to read more about auto-\nmating Gherkin tests with Cucumber, read the appendix. It’s a quick tutorial about\nhow to write and run simple automated tests for your feature files. I have to warn you,\nthough: the appendix covers only the basics.\nExamples\nStores acceptance\ncriteria\nConveys acceptance\ncriteria as scenarios\nCultivates the\nubiquitous language\nSimulates the\napplication\nCucumber\nGherkin\nRuns acceptance\ntests\nUses feedback \nloops\nExamples act as a link between Gherkin and Cucumber. The system \nis tested using the same examples that were collected when the \ndelivery team first analyzed the requirements.\n",
      "content_length": 2539,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 64,
      "content": "38\nCHAPTER 2\nThe specification layer and the automation layer\n2.2\nWriting your first Gherkin scenario\nAt the beginning of this chapter, I mentioned that you’ll work with an example of a\ncalendar application for teams, similar to Google Calendar (see figure 2.5). Every cal-\nendar application must allow teams to schedule meetings—to keep things simple,\nthat’s the one and only thing you’re going to specify today.\n2.2.1\nFeature\nIt’s time to write some Gherkin. This section presents a step-by-step tour of writing your\nfirst scenario. To begin, create an empty text file in any text editor of your choice.\n Every Gherkin .feature file starts in a similar manner. You’ve already seen it twice\nin previous examples of executable specifications:\nFeature: Scheduling\nFeature is Gherkin’s word for indicating that a new specification has begun—what fol-\nlows is the name of the feature being documented. Conventionally, every feature file\nconsists of a single Feature in order to encourage writing many small files rather than\na few large specifications.\nWARNING\nDon’t get too used to the Feature keyword. In chapter 8, you’ll\nreplace it with more-advanced keywords such as Ability and Business Need\nthat allow for better categorization of requirements.\nBelow the Feature line, you can add a description of the feature. It’s expected to\ndescribe the business value of this feature or to provide additional information that\nmakes the feature easier to understand. In this book, I call this a specification brief.\nDEFINITION\nSpecification brief—Specification line containing important pieces\nof information such as an answer to the question of why a specification was\nwritten in the first place, who the most important stakeholder is, and why they\nneed it.\nFigure 2.5\nYou could imagine your application is a simpler clone of Google Calendar, Microsoft Outlook, or any \nother popular scheduling software you and your friends use.\n",
      "content_length": 1922,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 65,
      "content": "39\nWriting your first Gherkin scenario\nFor the time being, let’s keep the feature file simple. Given the example’s scope, you’ll\nspecify only one or two scenarios. You should inform the reader where other scenarios\ncan be found.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nFrom the point of view of Gherkin’s syntax, the first line is the most important,\nbecause the Feature: part can never be changed. (Okay, there are two exceptions,\nbut I’ll talk about them at the end of the book.) The spaces in front of what follows\nare important, too, because the spaces tell Cucumber what the file’s structure is.\nThere are no strict rules or limitations regarding vertical spacing between the first line\nand the specification brief. Personally, I like to add a blank line because I think it\nmakes the document clearer. But if you don’t agree, you don’t have to do that.\n2.2.2\nScenario\nIn chapter 1, I said that Gherkin captures behavioral requirements. Behavioral\nrequirements are formed as stories about how users behave when they interact with\nthe system. In Gherkin, these stories are called scenarios. In this section, you’ll start\nwriting your first scenario.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nListing 2.1\nFeature line followed by a specification brief\nListing 2.2\nYour first scenario\nSpecification brief\nExercise 1\nWrite the rest of the specification brief that explains who will use the scheduling fea-\ntures and why they need them, based on what you know about the application. You\ncan draw some inspiration from the description of the app at the beginning of this\nsection. \nName of the scenario\n",
      "content_length": 2071,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 66,
      "content": "40\nCHAPTER 2\nThe specification layer and the automation layer\nIn this example, the Scenario line lets both the reader and the automation frame-\nwork know that a new scenario begins below it. If a scenario needs additional elabora-\ntion, you can place any amount of free-flowing text between the Scenario line and the\nfirst Given. It’s similar to the specification brief, and that’s why it’s called a scenario\nbrief. There are multiple ways to use the free-flowing space, as we’ll discuss through-\nout the book: for example, to provide definitions for domain-specific concepts, which\nyou’ll see in action in chapter 7 during the discussion of living documentation.\n Every scenario should do the following:\nDefine context (the Givens)\nDescribe an event that occurs within the system (the Whens)\nEnsure that expected outcomes take place (the Thens)\nThe sequence is called the Given-When-Then template.\n The Givens explain what needs to happen so you can watch the rest of the scenario\ntake place. The Whens neatly organize the template around a single behavior of the sys-\ntem, so a reader doesn’t have to wonder what the purpose of the scenario is. The\nThens clarify the consequences of taking that action.\n The Given-When-Then template is a simple yet powerful tool. It often works as a\nharmonious system. A slight change anywhere may influence a new change elsewhere.\nGivens, Whens, and Thens influence each other, but sometimes they force entire sce-\nnarios to change—and when scenarios change, sometimes entire specifications must\nchange as well. I talk more about this in chapter 3, which covers all the details of the\ntemplate. \n2.2.3\nGiven\nAh, the Givens. Givens answer a single question: what are the prerequisites that allow\nthe scenario to happen?\n For example, when a scenario’s main action is, as in this case, creating a meeting,\nthere must be some users who will be able to perform the action—so a user account\nmust have been created first.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nGiven a user\nListing 2.3\n[OK] Your first Given\nGiven that’s been added to the scenario\n",
      "content_length": 2334,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 67,
      "content": "41\nWriting your first Gherkin scenario\nTIP\nYou can see that there are two more spaces before the Given. Scenarios\nrequire additional indentation because it helps Cucumber understand which\nGivens, Whens, and Thens belong to which scenarios.\nGiven a user—that sounds vague, doesn’t it? All apps have users. And pretty much\nanyone can be a user. First, this naming doesn’t explain anything. Second, you’re work-\ning hard to make your application unique; the specification should reflect that, too.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nGiven a team member\nBetter! Now, you can at least see that the scheduling feature is about collaboration. A\nteam member sounds a bit abstract, though—and software should be made for real people.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nGiven Mike, a member of our team\nUsers play key roles in scenarios, and it’s a good practice to use unique, real names for\nseveral reasons. I talk about them in the next chapter, when I introduce the topic of\noutside-in development. Right now, I’ll give you a simple example. Let’s say that two\nusers appear in a single scenario. Calling them team member 1 and team member 2 would\nsound awkward, wouldn’t it? That’s why you’ll specify Mike—because Mike doesn’t\nsound awkward, and when things aren’t awkward, more people read and understand\nthem. Hello, Mike. Do you like Gherkin? (I bet he does. It’s the sole reason you\nbrought him into existence). \nListing 2.4\n[BETTER] Your first Given, reworked\nListing 2.5\n[BEST] Your first Given, reworked a second time\nA more specific Given\nA Given with a real person\n",
      "content_length": 2080,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 68,
      "content": "42\nCHAPTER 2\nThe specification layer and the automation layer\n2.2.4\nWhen\nGivens create the context in which the rest of the scenario takes place. Let’s keep the\nmomentum going and specify what the main action of the scenario should be. And,\nbecause Whens describe key actions the user performs, this is the perfect job for a new\nWhen. Let’s add one to the scenario.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nGiven Mike, a member of our team\nWhen Mike chooses 2 p.m. as a start time for his meeting\nAs you can see, you’re aiming for an example as concrete as possible: in addition to\nthe user introduced in the previous step, you’ve added specific hours. Also notice that\nthe second step is aligned to the right so the word When ends at the same place Given\ndoes. This is a community convention that you’ll see in many feature files, but it isn’t\nobligatory. You could also write\nGiven Mike, a member of our team\nWhen Mike chooses 2 p.m. as a start time for his meeting\nwithout aligning the When to the right under Given. We’ll continue to use this conven-\ntion throughout the book, though.\n Note that the scenario has already introduced some simple terms into your prod-\nuct’s ubiquitous language: a meeting, a team member, a start time. If programmers or\ndesigners read the scenario, they’ll adopt this dictionary without having to invent their\nown terms. Left to their own devices, technical experts often invent artificial names\nbecause they don’t know any better, and introducing artificial terms almost always wid-\nens the communication gap between business and delivery, instead of bridging it.\n Every scenario should preferably have only one When, because that makes scenarios\nclearer and easier to read. I’ll talk more about such design rules in chapter 3, where\nyou’ll learn about specifying user tasks and choosing the right abstraction level for\nyour scenarios. \n2.2.5\nThen\nAn action without an outcome is wasted. The part of the Given-When-Then template\nthat asserts the outcome is the Then—so why don’t you add it to the scenario?\nListing 2.6\nYour first When\nPrerequisite needed for the \nmain action to happen\nMain action\nof the\nscenario\n",
      "content_length": 2400,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 69,
      "content": "43\nUnderstanding the structure of steps and scenarios\n \nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nGiven Mike, a member of our team\nWhen Mike chooses 2 p.m. as a start time for his meeting\nThen he should be able to save his meeting\nThens describe consequences. In this case, choosing a valid start time for a meeting\nresults in successfully creating the meeting. A Then is usually a concrete representa-\ntion of the rule your criteria try to enforce. The representation is usually a change in\nthe system. For example, it may be something new that was created—like Mike cre-\nated his first meeting—but it may also be something that was removed or rephrased.\n The main difference between the scenario in listing 2.7 and the acceptance crite-\nria you usually see is that the scenario seems much more personal. That’s because\nAcceptance criteria are the abstract rules of the system; scenarios tell stories\nabout people who use the system according to these rules.\nHuman beings discuss and remember stories much better than they do abstract\nrules.\nAdding a Then means that, in eight simple steps, you’ve arrived at a full Gherkin spec-\nification starting from an empty text file. You now have a simple test that specifies what\nneeds to happen if you want to create an event.\n2.3\nUnderstanding the structure of steps and scenarios\nNow’s the perfect time for a quick theoretical break. Let’s slow down to process all the\ninformation discussed regarding the specification layer, from the standpoint of the\nautomation layer. Givens, Whens, and Thens are also known as steps.\nDEFINITION\nStep—The smallest unit of any Gherkin specification. It’s usually\na single line of text.\nListing 2.7\nYour first Then\nPredicate\nMain action\nConsequence \nof the action\nExercise 2\nWrite a simple scenario for canceling a meeting. Remember to specify proper conse-\nquences, so people won’t show up to canceled meetings!\n",
      "content_length": 2143,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 70,
      "content": "44\nCHAPTER 2\nThe specification layer and the automation layer\nAll steps work on two levels:\nA step describes the business logic of the application in natural language.\nEach step is closely related to its underlying testing code, which checks whether\nthe business logic described is implemented properly.\nFrom the technical point of view, every step consists of a restricted keyword and the\nstep’s content written in natural language that follows the keyword:\nDEFINITION\nKeyword—A special word used to optimize the specification layer\nfor automation. Keywords are imposed and enforced by the test execution\nengine. They must appear in every executable specification written in Gherkin.\nEvery keyword has a specific function to serve:\n\nGivens execute testing code needed to run a scenario: for example, creating\naccounts or prepopulating the database with example data.\n\nWhens execute the main action of a scenario that’s expected to change the state\nof the application by adding new data to the database, editing existing data, or\nintegrating with an external service like email.\n\nThens measure consequences of a scenario’s main action to check whether the\nstate of the application changed as you expected it to.\nThere are also other keywords such as But and And—they’re replacements that help\nyou avoid using the same word multiple times in a row. They make scenarios flow\nmore naturally.\n Here’s a full list of the keywords supported by Gherkin. Some of them you already\nknow; others you’ll meet later in this chapter and in the chapters yet to come:\n\nFeature\n\nBackground\n\nScenario\n\nGiven\n\nWhen\n\nThen\n\nAnd\n\nBut\nGiven Mike, Kate, and John were assigned to the same team\nKeyword\nStep\n",
      "content_length": 1696,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 71,
      "content": "45\nTesting different outcomes\n\nScenario Outline\n\nExamples\nScenarios and features use keywords to maintain their structure, too.\n You probably remember the Feature keyword. In chapter 8, you’ll learn that Fea-\nture can be replaced with more-specific keywords such as Ability and Business\nNeed. They can help you differentiate between your requirements and organize them\nin a clearer way—but for now, Features are all you need. Similarly, the Scenario key-\nword lets both the reader and the automation framework know that a new scenario\nhas begun.\nNow is the perfect time for the quick theoretical break to end. You can be proud of\nyourself. A few pages in, you already know most of Gherkin’s syntax. Be alert, though:\nwe’re not done yet. \n2.4\nTesting different outcomes\nLet’s review the scenario again. It’s a good practice to do so once in a while, for two\nreasons. First, Gherkin is prose—sometimes a bit awkward, but still prose. And prose\nstriving for readability and clearness needs constant reviewing—especially if it’s writ-\nten by technical people. (Ask my editors.) Second, every scenario is also a test, and\ndelivery teams should continuously work on improving their tests in case they missed\nanything when they wrote them in the first place.\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nListing 2.8\nExpected output of the scenario\nExercise 3\nFind all the keywords in the Gherkin file that you’ve written so far in this chapter, sep-\narate the keywords from the steps, and write the results in a table. Try to memorize\nthe keywords; they’re the most basic ones, but they’re also the most popular.\nUnderstanding indentation in Gherkin’s syntax\nYou may have noticed that, like Python and YAML, Gherkin is a line-oriented language\nthat uses indentation to define structure. You can use spaces or tabs, but it’s usually\nconsidered a good practice to use spaces, because they maintain the structure more\neasily on everyone’s computers.\nLine-oriented languages require you to keep every command within a single line. You\ncan’t write a two-line Given, for example. The only exceptions to the single-line rule\nare free-flowing descriptions such as the specification brief and scenario briefs. Free-\nflowing descriptions aren’t part of the Given-When-Then template, and they don’t\nmake any difference when it comes to automation. That’s why you can format them\nhowever you want.\n",
      "content_length": 2405,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 72,
      "content": "46\nCHAPTER 2\nThe specification layer and the automation layer\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a meeting\nGiven Mike, a member of our team\nWhen Mike chooses 2 p.m. as a start time for his meeting\nThen he should be able to save his meeting\nHave you noticed anything weird?\n This scenario looks perfect—too perfect, some might say. Mike accomplished a total\nsuccess without breaking a sweat. How often does that happen in reality? As a person\nwhose job is to make software for a living, you know the answer all too well. It never hap-\npens. When real people interact with software, not only does a total success rarely\noccur, but sometimes it’s flat-out impossible—and the results look more like carnage.\n Developers, designers, testers, and analysts can never assume that customers will\nuse their products in a linear manner. They must always prepare to specify multiple\npaths a user can choose.\n To see why, let’s get back to the example. We’ve taken SBE’s commitment to con-\ncrete examples seriously: you can’t get more concrete than the 2 p.m. start time in the\nWhen. Have you asked yourself, though, whether there’s any possibility that the start\ntime may fail? For example, what would happen if Mike chose 2 p.m. as the start time,\nbut it was already 3 p.m.? Wouldn’t that break the scenario?\nFeature: Scheduling\nBecause scheduling is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenario.\nYou can find more detailed scenarios in the rest\nof the files inside the \"meetings\" folder in the\nspecification suite.\nScenario: Creating a new meeting successfully\nGiven Mike, a member of our team\nAnd that it isn't 2 p.m. yet\nWhen Mike chooses 2 p.m. as a start time for his meeting\nThen he should be able to save his meeting\nScenario: Failing at creating a new meeting\nGiven Mike, a member of our team\nAnd that it's already 3 p.m.\nWhen Mike chooses 2 p.m. as a start time for his meeting\nThen he shouldn't be able to save his meeting\nListing 2.9\nTwo similar scenarios with different outcomes\nPrerequisite that guarantees \na positive outcome\nPositive\noutcome\nPrerequisite that guarantees \na negative outcome\nNegative \noutcome\n",
      "content_length": 2345,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 73,
      "content": "47\nHow the automation and specification layers interact\nBy writing two different outcomes for the same action, you’ve written your first compre-\nhensive test in Gherkin. You can either pass or fail a test. In order to make sure your\nspecification suite has acceptable scenario coverage, you must specify both what hap-\npens when a user takes a successful approach, as well as an unlucky approach.\n Testers usually call scenarios with positive outcomes happy paths. Beginning with\nthe happy-path scenario is a good way to establish a key example as a foundation from\nwhich to think about other possibilities. Fortunately, testing heuristics suggest a multi-\ntude of other paths, including angry paths, scary paths, embarrassing paths, forgetful\npaths, and so on. We’ll talk more about all the possibilities in chapters 4 and 5, which\nare about choosing good examples for your executable specifications.\n2.5\nHow the automation and specification layers interact\nThe two scenarios in listing 2.8 are your first real tests written in Gherkin. But didn’t I\nsay in chapter 1 that SBE’s practitioners automate their tests? How does that happen? I\ntalked a bit about Cucumber, the test execution engine, earlier in this chapter, but I\nhaven’t said anything concrete. How are you going to write good tests in Gherkin with-\nout learning to write real testing code in Cucumber? Is that even possible? Let’s\ndecouple these worrisome questions and take them one by one.\n2.5.1\nStep definitions\nCucumber executes the testing code within something called a step definition.\nDEFINITION\nStep definition—An implementation of the testing code for a sin-\ngle step. Step definitions are containers for the testing code that must be exe-\ncuted in order to run the steps in the automation layer.\nFor example, let’s consider possible step definitions for testing a notification email\nthat’s sent after Mike creates his event. You can find some practical examples of step\ndefinitions in table 2.2.\nTable 2.2\nWhat needs to happen under the hood to test whether an email was sent?\nKeyword\nTesting code in the step definition\nGiven\nEstablish connection to the database, populate it with some testing data, or configure \nthe application to a desirable state\nWhen\nSimulate sending an email based on the data fetched from the database\nThen\nCheck if the email was sent by integrating with the mailing service’s internal queue\nExercise 4\nWhat are other circumstances that may result in failures when Mike creates a meet-\ning? Write a third scenario that adds more detail to the specification. You can use a\nscheduling conflict in Mike’s calendar as a reason for failure, or you can invent your\nown example. \n",
      "content_length": 2673,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 74,
      "content": "48\nCHAPTER 2\nThe specification layer and the automation layer\nIn theory, the relationship between features, steps, and step definitions is pretty sim-\nple. Figure 2.6 illustrates the high-level flow.\n Every feature contains multiple scenarios that contain multiple steps. These steps\nhave corresponding step definitions that are responsible for running the automation\ncode that affects a simulation of a system, as well as checking whether the code yields\nexpected results. \n2.5.2\nMatching steps with step definitions\nA middle-sized Gherkin project can contain between 200 and 600 scenarios. If you\nassume that every scenario has at least 3 steps, each of which is one of each kind, that’s\nbetween 600 and 1,800 steps in a single specification suite. And remember that, unlike\nkeywords, a step’s content isn’t predefined; you can write whatever you like as long as\nit fits within a single sentence and makes sense, given the rest of your scenario. All in all,\nthat’s a lot of content and a lot of step definitions to execute. How does that happen?\n In general, Gherkin files must be parsed by a testing framework that matches steps\nand their step definitions (see figure 2.7). That’s precisely what Cucumber does.\n From a technical point of view, every step’s content is matched with a step defini-\ntion within the automation layer—like in a search-and-replace operation in any text\neditor you’ve ever used. Here’s the general rule for matching step definitions:\nStep's content <- Testing code\nYou can read this expression as the general rule, “the left-hand side can be replaced\nwith the right-hand side.” When anything that matches the left side—a step—is found,\nit’s replaced with whatever the right side—testing code—contains. Table 2.3 lists some\nsimple, practical examples with dummy testing code written in Ruby. If you want a\nmore advanced explanation, check out appendix A.\nFeature files\nStep definitions\nTesting code\nSimulation of\na system\nSteps explain what the \nsystem should do.\nStep definitions list actions \nthat need to be taken in code \nto execute the feature.\nTesting code executes the \nactions on a running \nsimulation of a system.\nFigure 2.6\nGherkin features test a \nsimulation of the working system with \ntesting code executed through step \ndefinitions.\n",
      "content_length": 2275,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 75,
      "content": "49\nHow the automation and specification layers interact\n \nTable 2.3\nSpecific steps matched with their step definitions\nStep’s content\nStep definition’s code\nPurpose\nMike, a member of our \nteam\n@mike = \nUser.create(name: \n\"Mike\")\nCreate Mike’s account.\nthat it isn’t 2 p.m. yet\nTime.freeze(\"1 p.m.\")\nFreeze the time of the system’s \nsimulation to make sure the \nevent is valid.\nMike chooses 2 p.m. as a \nstart time for his \nmeeting\n@meeting = \nMeeting.create(start_tim\ne: \"2 p.m.\", user: \n@mike)\nAttempt to save Mike’s meeting \nin the database.\nhe should be able to save \nhis meeting\nexpect(@meeting.saved?).\nto eq true\nEnsure that the system saved \nMike’s meeting properly.\nhe shouldn’t be able to \nsave his meeting\nexpect(@meeting.saved?).\nto eq false\nEnsure that the system didn’t \nsave the incorrect meeting.\nGiven Mike, Kate, and John were assigned to the same team\nBusiness logic expressed in natural language\nStep\nTesting code validating the implementation\nAutomation engine\nGiven(/^Mike, Kate, and John were assigned to the\nsame team$/) do\n \n@john = create_user(\"John Appleseed\")\n \n@mike = create_user(\"Mike Johnson\")\n \n@kate = create_user(\"Kate Middleton\")\n \nteam = Team.create(name: \"Team A\")\n \n[@john, @mike, @kate].each do |person|\n \n \nperson.update_attributes(team: team)\n \nend\nend\nStep definition\nFigure 2.7\nThe testing code contained in step definitions is matched \nto examples and scenarios through regular expressions executed by \nthe automation engine. Steps and their step definitions are inseparably \nconnected. Steps describe the business logic in natural language; step \ndefinitions allow the automation engine to run the testing code needed \nto check whether the step’s business logic is implemented correctly.\n",
      "content_length": 1733,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 76,
      "content": "50\nCHAPTER 2\nThe specification layer and the automation layer\nYou’ll notice, first, that Cucumber rejects keywords when matching a step. Cucumber\nbehaves like that because in some advanced cases, you may want to write interchange-\nable steps; for example, you may want a When from one scenario to become a Given in\nanother scenario. I’ll talk more about why you might want to do so in chapter 3. Sec-\nond, Cucumber matches the rest of the step with the testing code in a step definition\nwith the step’s name.\n Only together can Gherkin and Cucumber work as an end-to-end tool. The specifi-\ncation layer elaborates requirements and acceptance criteria in natural language\nusing important real-world examples. The examples, expressed in steps, become links\nthat connect acceptance criteria with automated tests—the automation layer—\nthrough regular expressions (see figure 2.8). The tests make sure the system behaves\nas the requirements should require it to.\nYou could write scenarios without using Cucumber, but they wouldn’t be executable.\nAnd if they weren’t executable, they wouldn’t become acceptance tests. Without accep-\ntance tests, you couldn’t easily know when to update the scenarios when the system\nbreaks or changes. And why would you keep outdated scenarios? You’d probably dis-\ncard them just as you discard the sticky notes with user stories after you finish the story.\n That’s why the system works only if every acceptance criterion becomes a scenario,\nscenarios become tests, and tests control the design of the system by validating the sys-\ntem frequently with the testing code. These three steps make a cohesive whole: a spec-\nification process that covers your development efforts from start to end.\nExamples\nexpressed in steps\n• Scenario\n• Scenario\n• Scenario\n• Scenario\n• Scenario\n• Scenario\n• Scenario\n• Scenario\n• Scenario\nAutomation code\nCucumber\nGherkin\nAutomation code\nAutomation code\nSpecification\nSpecification\nSpecification\nStep definition\nSpecification layer\nAutomation layer\nStep definition\nStep definition\nFigure 2.8\nExamples, expressed in steps, act as a link between \nGherkin and Cucumber. Steps, scenarios, and feature files constitute \nthe specification layer. Step definitions and the testing code are the \nfundamentals of the automation layer. Together, the specification layer \nand the automation layer create an executable specification suite.\n",
      "content_length": 2385,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 77,
      "content": "51\nFinishing the Gherkin crash course\n \n2.6\nFinishing the Gherkin crash course\nAnd—you’re finished. After reading this chapter, you’re ready to write Gherkin speci-\nfications for any project.\n Let’s review what you’ve done:\nYou analyzed your acceptance criteria using concrete examples of how you\nexpect users to use the product in their natural environment.\nYou captured these examples as Given-When-Then scenarios to prepare them\nfor future automation.\nYou ended up with a specification that’s different from traditional requirements\ndocuments:\nIt’s much smaller, because Gherkin requires you to break down the scope of\nyour work into singular features. Small specifications fit well into iterative pro-\ncesses that focus on getting small chunks of work done quickly and repeatably.\nIt’s concrete and doesn’t leave much to a reader’s imagination. By making the\nsolution easier to comprehend, concrete examples allow engineers to produce\nworking code more quickly.\nIt’s ready to be tied up with implementation code through automated tests in\norder to maintain consistency with the system at all times. The document will\nstay up to date, because when anything changes, the link between code and sce-\nnarios will be broken. If the specification is validated frequently, the delivery\nteam will be able to spot broken scenarios quickly.\nIt’s not wasteful. The specification acts as a link between the analysis, design,\nimplementation, and testing phases. The system doesn’t require a separate test-\ning phase that would enable testers to determine whether requirements are sat-\nisfied—if they trust the specification, they can focus on exploratory testing and\nmore-difficult edge cases. No other development artifacts are introduced.\nTesting and checking\nA question that’s often asked when the topic of automated tests comes up is, “Why\ndon’t we get rid of all of our testers and automate all of our testing?” But you never\nhear anyone say, “Why don’t we get rid of all of our developers and automate all the\ndevelopment?” Trying to answer why is an interesting thought exercise.\nDevelopers do the smart thing and call their automated work compiling. Testers, too,\ncould differentiate between testing that requires thought and can’t be automated and\nthe checking that’s done with automation. When you design scenarios and think\nabout the possible inputs and expected outputs, you’re doing exploratory testing that\ncould never be done without a conscious mind. Once you design the scenarios, you\ncan automate most of them with testing code—and that’s the checking part. Some\ntests are more complicated than simple, easy-to-replicate checks, and that’s why\nthey can never be fully automated. \n",
      "content_length": 2694,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 78,
      "content": "52\nCHAPTER 2\nThe specification layer and the automation layer\nWhat this chapter didn’t cover is Gherkin’s full syntax. Don’t worry; you can find a full\nspecification of the Gherkin language in Cucumber’s repository on GitHub. But in my\nopinion, you can feel free to skip it. Throughout the book, you’ll see that the key to\nwriting good Gherkin lies somewhere other than getting to know the intricacies of its\nsyntax—and you’ll learn the handiest tricks on the fly.\n The real difficulty in using Gherkin is its flexibility. In addition to the keywords,\nyou can type almost anything you want in any order you can imagine. Such flexibility\ncan lead you astray if you’re not careful. In the next chapter, you’ll see how to protect\nyourself.\n2.7\nAnswers to exercises\nEXERCISE 1\nWrite the rest of the specification brief that explains who will use the\nscheduling features and why they need them, based on what you know about the appli-\ncation.\nLike it or not, meetings are the lifeblood of every organization.\nOur calendar app is meant for busy teams who work in collaborative\nenvironments, have to manage multiple meetings a day with different\nclients, and want to be as mobile as they can. They need smart reminders,\nhelp with different time zones, and a professional meeting management\nsolution.\nThis feature, then, being the simplest meeting management form we could\ncome up with without compromising on powerful capabilities, is the core\npart of our product.\nPlease be careful and make sure everything is tested properly.\nEverything else in this application could break and people would still\nforgive us; if this feature breaks, we'll all be doomed.\nEXERCISE 2\nWrite a simple scenario for canceling a meeting.\nGiven a meeting by John and Anna at 4 p.m.\nAnd that it is 3 p.m. now\nWhen Anna cancels the meeting\nThen the event should be removed from the calendar\nAnd John should be notified about the canceled event\nEXERCISE 3\nFind all the keywords in the Gherkin file that you’ve written so far in this\nchapter, separate the keywords from the steps, and write the results in a table.\n\nFeature\n\nScenario\n\nGiven\n\nWhen\n\nThen\n\nAnd\n\nBut\n",
      "content_length": 2136,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 79,
      "content": "53\nSummary\nEXERCISE 4\nWhat are other circumstances that may result in failures when Mike cre-\nates a meeting? Write a third scenario that adds more detail to the specification.\nGiven Mike, a member of our team\nAnd another event in Mike's calendar at 2 p.m.\nWhen Mike chooses 2 p.m. as a start time for his new meeting\nThen he should not be able to save his meeting\n2.8\nSummary\nA full Gherkin specification is called a feature. A single feature is typically con-\ntained in its own file that ends with a .feature extension. A feature typically spec-\nifies the behavior of a single functionality.\nThe specification layer contains specification files with the .feature extension,\nwritten in plain English and filled with domain-specific terms and concepts.\nThe automation layer and the specification layer heavily influence each other.\nYou can’t have a good specification layer without understanding the basics of\nthe automation layer.\nGiven a set of expected inputs and outputs, the automation layer executes a\nsimulation of the application to see whether the working code behaves as\nexpected.\nCucumber is a testing framework that matches Gherkin steps with step defini-\ntions and lets you run testing code.\n\nGivens, Whens, and Thens are called steps.\nSteps begin with keywords that help Cucumber parse the feature file.\nStep definitions are containers for all the testing code that must be executed to\nrun a step.\n",
      "content_length": 1420,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 80,
      "content": "54\nMastering the\nGiven-When-Then template\nIn chapter 2, we explored the two layers of executable specifications: the specifica-\ntion layer and the automation layer. We focused on the specification layer and writ-\ning it. But if you ever tried to write a blog post, you know that just writing and great\nwriting aren’t the same thing. Likewise, writing scenarios and writing great scenar-\nios can be quite different.\n This chapter will teach you to write great scenarios. Chapter 2 taught you the\nbasics of the Given-When-Then template, and this chapter is an advanced course.\nExpressive scenarios incorporate a vivid vocabulary of domain language that helps\nThis chapter covers\nWriting scenarios for the real world\nUsing realistic data in scenarios\nUnderstanding advanced rules for using Given-\nWhen-Then\nGetting unstuck when writing scenarios\nGenerating ideas for new scenarios\n",
      "content_length": 883,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 81,
      "content": "55\nChoosing the right style for your Gherkin scenarios\nreaders understand requirements more easily. But Gherkin’s syntax is so easy that\nsometimes it seems repetitive—and therefore boring. Boring scenarios are easier to\nskim. You must learn to write expressive scenarios if you are to establish a connection\nwith your readers.\n My goal for this chapter was to write it like a practical cheat sheet. You’ll be able to\nuse it like your personal Gherkin Manual of Style—similar to the way the Chicago Man-\nual of Style is a style guide for American English (it’s been published since 1906 by the\nUniversity of Chicago Press). Its 16 editions have prescribed writing styles widely used\nin publishing. Like English, Gherkin is a language—so an advanced manual will help\nyou in the future.\n Chapter 1 said that each Gherkin scenario is like a short story about a product.\nMore parallels can be drawn between Gherkin and literature. An expert can rate each\nliterary work in three areas: style, composition, and story. Style is all about the beauty\nof the language. Composition is about clarity and coherence of thought. Story is what\nhappens to the heroes. Great Gherkin, too, can be rated using the same methodol-\nogy—so the chapter you’re reading right now is split into the following three sections:\nThe style section (3.1) talks about the highest-level guidelines you should focus\non when trying to write beautiful Gherkin scenarios. I’ll explain why your sce-\nnarios should focus on stakeholders and be written in an outcome-oriented way.\nThe composition section (3.2) expands on the structure of the Given-When-\nThen template and how you can write new scenarios more easily.\nThe story section (3.3) explains what to do when you don’t know what to write,\nby teaching methods to generate new ideas and get unstuck.\nThis chapter is organized around a collection of tips from these categories. Whenever\nI start a new tip, I’ll begin by mentioning the category it belongs to. Most of the tips\nwill be introduced in the order of this list, so you can expect style tips to appear in the\nstyle section, and so on. Sometimes, though, I’ll mention techniques from other sec-\ntions if they seem relevant but aren’t important enough to warrant separate\nsubsections—for example, I might include a story tip in the composition section. So\ndon’t be surprised.\n3.1\nChoosing the right style for your Gherkin scenarios\nExercises in Style is a classic book by the French author Raymond Queneau. The plot is\nsimple: a man gets into an argument with another passenger on a bus. But this anec-\ndote is told 99 more times, each in a radically different style: as a sonnet, an opera, in\nslang, and with many more permutations. Each style used in Exercises highlights differ-\nent elements of the same story—and so, readers perceive each retelling differently,\nnoticing different nuances every time.\n Like Queneau, you can write your scenarios in different styles. This section will\nteach you what works best with Gherkin. We’ll try to dissect what makes a scenario\n",
      "content_length": 3042,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 82,
      "content": "56\nCHAPTER 3\nMastering the Given-When-Then template\nexpressive. I’ll talk about what you should focus on when writing new scenarios—\nwhat to emphasize and what to hide. I’ll also discuss why trying to create software\nmodels that stick to the real world as closely as possible ultimately results in building\nbetter software.\n3.1.1\nDoing outside-in development with Gherkin\nStarting with this section, you’ll be working on an example application we’ll name\nQueneau after the French author. Queneau is a text editor with features that let writ-\ners easily imitate different styles, exactly like its namesake.\nWRITING USER-ORIENTED SCENARIOS\nOne of Queneau’s competitive advantages is that the app can teach you to imitate the\nstyle of popular authors, such as Raymond Queneau himself and, let’s say, Vladimir\nNabokov. It does so by instructing you to revise your text like the chosen author\nwould. In Nabokov’s case, Queneau would instruct you to shorten your sentences,\nremove any adverbs, avoid passive voice, and so on. Thanks to what you learned in\nchapter 2, I can easily demonstrate such functionality using a Gherkin scenario.\nScenario: Detect sentences that are too long\nGiven text with a sentence that is too long:\n\"\"\"\nAs he crossed toward the pharmacy at the corner he involuntarily turned\nhis head because of a burst of light that had ricocheted from his \ntemple, and saw, with that quick smile with which we greet a rainbow or \na rose, a blindingly white parallelogram of sky being unloaded from the \nvan—a dresser with mirror across which, as across a cinema screen, \npassed a flawlessly clear reflection of boughs sliding and swaying not \narboreally, but with a human vacillation, produced by the nature of \nthose who were carrying this sky, these boughs, this gliding façade.\n\"\"\"\nWhen the content is analyzed\nThen the sentence that is too long should be detected\nThe scenario looks fine—but if you scratch the surface, doesn’t it seem lifeless? After\nall, writers will use your text editor to bring hundreds of beautiful and despicable\ncharacters to life. This scenario looks out of touch compared with what your end users\nwill do with the product. By talking about system operations like analyzing and detec-\ntion, which are highly technical, the scenario is clearly written in a style your users\nwouldn’t want to read. And because more people read books written by authors like\nNabokov than books written by technical people, you should do something about it if\nyou want nontechnical stakeholders to read your scenarios, too.\nListing 3.1\n[OK] An example scenario\n",
      "content_length": 2577,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 83,
      "content": "57\nChoosing the right style for your Gherkin scenarios\n \nTo see what I mean, let’s look at a revised version of the scenario from listing 3.1.\nScenario: Detect sentences that are too long\nWhen Vladimir writes a sentence that is too long:\n\"\"\"\nAs he crossed toward the pharmacy at the corner he involuntarily turned \nhis head because of a burst of light that had ricocheted from his\ntemple, and saw, with that quick smile with which we greet a rainbow or\na rose, a blindingly white parallelogram of sky being unloaded from the\nvan—a dresser with mirror across which, as across a cinema screen, \npassed a flawlessly clear reflection of boughs sliding and swaying not \narboreally, but with a human vacillation, produced by the nature of \nthose who were carrying this sky, these boughs, this gliding façade.\n\"\"\"\nThen he should be notified that the sentence could be shortened\nWithout changing much of the content, focusing on the person in front of the screen\nshifts attention to answering an important question: can you do something to improve\nVladimir’s life? Is it the most efficient way to help him? Can he achieve his goal easily?\nHaving answered these questions, you might, for example, notice that if Queneau\nhighlighted the sentence that could be shortened immediately after Vladimir wrote it,\nthe app would distract him instead of helping him focus. Should you introduce two\ndifferent modes, one for writing and one for editing? Editing mode would suggest\npossible changes. Vladimir would be able to switch between modes at will, depending\non what he wanted to do at the moment.\nListing 3.2\n[GOOD] User-oriented scenario\nUsing multiline doc strings\nIf you need to write a step that won’t fit on a single line, you can use doc strings. A\ndoc string follows a step and begins and ends with three double quotation marks.\nHere’s an example:\nGiven a text:\n\"\"\"\nThere is no rule on how to write.\nSometimes it comes easily and perfectly;\nsometimes it's like drilling rock\nand then blasting it out with charges.\n\"\"\"\nDoc strings allow you to write long error messages or email contents in your scenar-\nios. Sometimes longer texts have a lot of business value. For example, in heavily reg-\nulated environments where mistakes are expensive, you might want to test your error\nmessages with executable specifications.\nDoc string\n",
      "content_length": 2319,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 84,
      "content": "58\nCHAPTER 3\nMastering the Given-When-Then template\n \nScenario: Detect sentences that are too long\nThe EDIT MODE highlights all the suggestions made by\nour text editor directly in the text.\nThe WRITE MODE hides the suggestions, so the author\ncan focus on writing without any distractions.\nWhen Vladimir writes a sentence that is too long:\n\"\"\"\nAs he crossed toward the pharmacy at the corner he involuntarily turned\nhis head because of a burst of light that had ricocheted from his\ntemple, and saw, with that quick smile with which we greet a rainbow or\na rose, a blindingly white parallelogram of sky being unloaded from the\nvan—a dresser with mirror across which, as across a cinema screen, \npassed a flawlessly clear reflection of boughs sliding and swaying not \narboreally, but with a human vacillation, produced by the nature of \nthose who were carrying this sky, these boughs, this gliding façade.\n\"\"\"\nThen he should be notified that it could be shortened in the Edit Mode\nBut he shouldn't be notified about that in the Write Mode\nTIP\nHashing out Gherkin scenarios is a great way to brainstorm and discover\nnew features. Writing a Given-When-Then scenario is even cheaper than\ndrawing a sketch or making a mock-up. I find collaborating over Gherkin sce-\nnarios particularly valuable in asynchronous, remote work environments. \nDEFINING ACTORS IN SCENARIOS\nIn chapter 2, when you were polishing your first Given in listing 2.7, I asked you to call\nthe user in the scenario Mike. I told you that the reason to do so was that when two\nusers appear in a single scenario, calling them team member 1 and team member 2 sounds\nawkward.\n Real names and user-oriented scenarios facilitate empathy, and this is important.\nIn one project, I called the user in most of my scenarios Simona. Every time I wrote a\nscenario, I imagined that she was anxious to get her work done as quickly as she could,\nbecause she had a sick child at home. I wondered whether there was anything more I\ncould do to make her work easier. In user-centered design and marketing, what I did\nwith Simona’s scenarios is called creating a persona. Personas are fictional characters\ncreated to represent the different user types that might use a product in a similar way.\nSo every time I mentioned Simona, I meant every person similar to her—a certain\ndemographic, a customer segment. But these are abstract terms. A good persona is\nmuch more real.\nListing 3.3\n[BEST] Discovering user benefits with Gherkin\n",
      "content_length": 2470,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 85,
      "content": "59\nChoosing the right style for your Gherkin scenarios\n \nHad you looked at this situation only from the perspective of the system, you would\nhave seen only system attributes—data coming in and going out of your application,\nthe inputs and outputs. In some cases, this isn’t a bad approach—and yes, there can\nbe other cases. From a technical point of view, every scenario must be written from the\nperspective of an actor.\nDEFINITION\nActor—Anything that influences an action or a process taking\nplace in the system under design\nThere are three types of actors:\nStakeholders\nOrganizations\nSystems\nShould you write steps with step definitions that have no testing code?\nWhen I was learning how to use Cucumber and Gherkin, I was told that writing steps\nwith step definitions that don’t execute any testing code was a bad practice. Here’s\na quick example:\nGiven Vladimir's desire not to be distracted\nWhen he turns on the Write Mode\nThen only the paragraph he's working on should be fully visible\nAnd the other paragraphs should be dimmed out\nHow on earth could you write testing code to check whether a user feels distracted?\nAt first glance, the step feels redundant. Including it seems like unnecessary work for\nwhoever will implement the acceptance tests. A developer would certainly tell you\nthat doing so increases the complexity of the test suite for no reason.\nI think the answer becomes clearer if you keep in mind that scenarios emerge before\nyou start thinking about tests and testing code. With specification by example (SBE)\nand Gherkin, you follow an end-to-end paradigm of building a dynamic specification\nsystem that constantly evolves along with the product. And when you embrace the\nmindset of organizing your development process around collecting examples and\nrefining scenarios, then you can see a fluid progression between development\nphases.\nImagine that you’re sitting in a specification workshop, trying to analyze the Write\nMode feature. It would be extremely natural to write that Vladimir doesn’t want to be\ndistracted, because that’s why you invented the feature in the first place. You could\neven rename the Write Mode to something like Focus Mode and make it a big ele-\nment of your marketing value proposition for Queneau.\nThis is why I think that instead of not writing steps with empty step definitions, you\nshould make a habit of not writing steps that don’t bring any value. These are two\ndifferent things.\n",
      "content_length": 2440,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 86,
      "content": "60\nCHAPTER 3\nMastering the Given-When-Then template\nA stakeholder is someone with a vested interest in the behavior of the use case, even if\nthey never interact directly with the system. Stakeholders come in all sorts of flavors.\nThey’re the people who use the software you create, but they can also be economic\nbuyers, decision makers, business partners, or insiders.\n But organizations and systems can be actors, too. For example, an external service\nprovided by a business partnership may shape your product and deserve a mention in\nyour scenarios. \nOUTSIDE-IN DEVELOPMENT AND USER-ORIENTED SCENARIOS\nYou can write Gherkin scenarios for all three types of actors, but I strongly advocate\ntaking the perspective of a specific group of stakeholders: the end users. End users are\nthe people who interact with your product. They experience how your software works\nin the real world. In general, you should use the tools you choose in a way that can\nyield the most benefits. But the software development community has come to a\nbroad consensus that the user-centered perspective works best. That’s why, as an\nindustry, we’ve reoriented most of our tools, such as user stories, to focus on people.\nI’ve already mentioned how UX designers and marketers use personas to empathize\nwith abstract customer segments. Gherkin, too, fits this trend well.\nTIP\n[STORY] To elicit better requirements, understand who needs a sug-\ngested solution and why they need it. If you need help to better understand\nyour stakeholders, try creating a user journey map. A user journey map is a\nvisual or graphic interpretation of the overall story, from an individual’s per-\nspective, of their relationship with an organization, a service, a product, or a\nbrand, over time and across channels. Unfortunately, creating user journey\nmaps goes beyond the scope of the book.\nIn the world of software, focusing on stakeholders is also called outside-in development.\nAt times, outside-in development is like literature, too. Storytellers have to keep in\nmind what’s interesting to their audience, not what’s fun to do as a writer. Those\nobjectives can be very different. Even systems-heavy solutions can be analyzed from\nthis perspective. Systems are designed by people; they’re used by people; they’re man-\naged by people. The outside-in approach forces you to think about the people who\ndefine software requirements and try to understand why they want what they want. In\ngeneral, try to write your scenarios for end users when you can—but when you can’t,\ndon’t lose sight of the people behind systems and machines.\nDEFINITION\nOutside-in development—A software development methodology\nthat aims to create successful software through understanding the goals and\nmotivations of stakeholders\nThis section isn’t meant to exhaust the topic of outside-in development. That’s a sepa-\nrate art of finding, analyzing, and managing stakeholders on different levels, both\ninside your organization and outside of it. As I just outlined, it’s more complex than\nfocusing on end users. For example, some stakeholders may be hidden from your\n",
      "content_length": 3094,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 87,
      "content": "61\nChoosing the right style for your Gherkin scenarios\nview. This usually happens when a new, weird requirement emerges, and you have no\nidea where it came from—because it doesn’t sound like a request people you usually\ntalk to would make. (Hint: It may have been enforced by a silent stakeholder.)\nMachine-to-machine solutions are another example. I can’t cover them all in this\nchapter. But I wanted to achieve two things: to give you a guideline—a rule of thumb\nthat will maximize results and minimize effort; and to give you a platform from which\nto investigate outside-in development on your own. \n3.1.2\nGathering realistic data\nI started writing short stories when I was in middle school. I couldn’t write very well, so\nI at least wanted the stories to be cool. I wrote about stuff I thought was exciting. It was\nalso stuff I knew nothing about. The results always turned out to be boring because my\nstories lacked detail and depth. It took me a few years to realize that people liked my\nwriting more when there was something true and realistic at the core of a story rather\nthan when it was shouting “cool” all over the place but felt fake. Good Gherkin writers\nshould also hate fake stories—fake examples, fake actors, and fake domain concepts—\nbecause fake data often results in making misinformed decisions. Let me explain why.\n Table 3.1 contains three examples of rules that Queneau implements to help writ-\ners edit their text files more easily. All three examples were devised to illustrate system\nrules somebody took for granted. But the correct approach for illustrating require-\nments with examples is to find examples that constitute a source of each rule. As a\nstrong fundamental, grounded in the real world, the source provides validation of\nwhether a rule makes sense. The examples in the table don’t—they’re more like frag-\nile crutches.\n If you put the table in a Gherkin scenario, it wouldn’t break the test-execution\nengine. The examples were designed not to break it.\n Fake scenarios with fictional examples poison your decision making. Outside-in\ndevelopment relies on analyzing people, processes, and rules outside of your system\nto incorporate them in your application. The role of data in Gherkin is to inform\nOutside-in terminology and behavior-driven development\nOutside-in terminology belongs to the Gherkin domain but not to the SBE domain,\nwhich means you may not hear it much when talking with people who use non-\nGherkin executable specifications like FitNesse. Behavior-driven development (BDD)—\nwhich is mostly associated with Gherkin through the figure of Dan North, who had a\nhand in creating both BDD and Gherkin—is often defined as “a second-generation,\noutside-in, pull-based, multiple-stakeholder, multiple-scale, high-automation, agile\nmethodology.”\nBonanza of keywords aside, I took the liberty of integrating outside-in methods into\nthis chapter and also chapter 5. But I believe that mentioning the terminology mix-up\nexplicitly here is a fair thing to do.\n",
      "content_length": 3006,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 88,
      "content": "62\nCHAPTER 3\nMastering the Given-When-Then template\ndecisions and ensure continuity of research and discovery in the software develop-\nment process. Examples and scenarios should empower future readers to understand\nthe context they were written in, so that anyone who decides to push the feature for-\nward can build on top of what the original writers intended.\n Look at the examples again. If you were to make a change to this scenario six\nmonths after its conception, would you—a person who hasn’t worked on this project\nbefore—be able to understand why such sentences were chosen? No. They would\nseem arbitrary.\n Ultimately, what we’re after is authenticity—both in software and in writing.\nAuthentic stories strive to tell you something impactful and true. Similarly, authentic,\nimpactful software understands you and your needs. \n3.1.3\nFavor specifying intentions and outcomes over the user interface\nThe two previous chapters talked about how the Given-When-Then template works well\nwith behavioral requirements. Behaviors are actions performed by actors and meant to\nmake a change in a system. Understanding how high-level these actions should be is a\ndifficult topic that many Gherkin writers struggle with. I’ll talk about it multiple times\nthroughout the chapter. This section will give you an introduction to help you under-\nstand the general rule for how abstract or concrete behaviors should be.\n I have to begin by saying that Cucumber and Gherkin are typically associated with\nend-to-end system testing. This heritage is the reason a lot of people write Gherkin\nscenarios that talk about what’s tested in the automation layer: the user interface.\nDEFINITION\nEnd-to-end tests—Tests that check whether the flow of an applica-\ntion is behaving as expected from start to finish, by running a simulation of the\nentire system in a browser and emulating real users clicking through the UI\nTo understand what I mean, look at the following scenario. It specifies a simple\nexporting feature built into Queneau.\nTable 3.1\n[BAD] Fictional examples of acceptance criteria in Queneau\nRule\nExample\nAvoid long sentences\nThis is a sentence that is too long and, while it’s certainly pretty, it \nmight therefore be too complicated for a reader to comprehend at a \nglance—so you should consider shortening it or breaking it into smaller \npieces.\nReplace difficult words with \nsimpler alternatives\nThis extraordinary sentence contains a difficult world—extraordinary—\nthat you could replace with a simpler word such as special.\nAvoid adverbs\nAdverbs should be limited, preferably removed.\n",
      "content_length": 2585,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 89,
      "content": "63\nChoosing the right style for your Gherkin scenarios\n \nScenario: Exporting documents\nGiven \"Export\" button from the \"File\" menu was clicked\nWhen Vladimir types \"Lolita\" into the \"Name\" text field\nAnd he chooses \"PDF\" from the file type select field\nAnd he chooses a \"1955\" destination folder from a select field\nThen a file \"Lolita.pdf\" should appear in folder \"1955\"\nNow, imagine that you change the location of the Export button in the example, put-\nting it in the Edit menu instead of File. It’s a minuscule change, but you’d have to\nrewrite both the step and the step definition in question.\n If the specification has to change every time the UI changes—when a button disap-\npears, for example—then building trust is more difficult, because humans instinc-\ntively value stability over chaos. Writing about buttons, forms, links, and input fields is\na limiting approach to harnessing the benefits of a business-readable DSL like Gherkin\nin bridging the communication gap between technology and business.\n Some of the confusion comes from the fact that Gherkin scenarios are about\nbehaviors, and thinking about behaviors can automatically prime you to imagine a UI\nto interact with. But throughout the book, I favor a different approach: writing Gher-\nkin specifications that describe the business logic of a system, as well as the intentions\nof actors and the outcomes they can or can’t achieve. So instead of talking about but-\ntons or links, you talk about business goals, customers, requirements, and acceptance\ncriteria—because that’s what the business cares about.\nTIP\n[STYLE] Don’t write scenarios about the UI. Write about business out-\ncomes. Nobody cares about the UI; they care if they can get their job done.\nFavoring specifying intentions and outcomes over the UI is a practical tip for writing\nmore-bulletproof scenarios. But from a theoretical point of view, the discussion is\nabout preferring one style of writing over another: interface-oriented style, which is\nalso called imperative style; or outcome-oriented style, also known as declarative style.\n Imperative style is simple, is intuitive, and reflects what manual testers do. That’s\nwhy almost everybody who is new to Gherkin naturally starts with this style. In contrast,\ndeclarative style describes what the user does, but not how they do it—the how part is\npushed into step definitions and handled by the automation layer. The real difference\nbetween the imperative approach and the declarative approach comes down to differ-\nent levels of abstraction. Imperative writing is less abstract and more concrete,\nwhereas declarative writing is more abstract. Liz Keogh, a BDD mentor, argued once\nthat “there’s no such thing as declarative and imperative”1 and “every declarative is a\nchunking-up of something else, and every imperative is a chunking-down, and you can\nchunk up and down to different levels of abstraction.” Chunking up and chunking down\nare terms from the domain of natural language processing, and they mean becoming\nmore abstract or more specific, respectively.\nListing 3.4\n[BAD] Interface-oriented scenario\n1 Liz Keogh, “There’s No Such Thing as Declarative and Imperative,” June 17, 2013, http://mng.bz/QO51.\n",
      "content_length": 3204,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 90,
      "content": "64\nCHAPTER 3\nMastering the Given-When-Then template\nBut choosing the right level of abstraction isn’t only a stylistic choice. It’s also about\ncomposition. For example, the more abstract you decide to be, the shorter your sce-\nnarios will be and the fewer steps they will contain. And that can be good or bad.\nShorter scenarios can be easier to read, discuss, and remember—but they can also be\ntoo short to allow readers to grasp difficult domain concepts and their consequences\nin full. So the choice of abstraction level shouldn’t be automatic. I’ll talk more about\nhow to make a good decision in the next section (which talks in general about compo-\nsitions) and, particularly, in section 3.2.4. I’ll also revisit the topic in chapter 8, where\nI’ll talk about splicing scenarios into specifications while maintaining a reasonable\nlevel of abstraction. \n3.2\nComposing Gherkin scenarios\nIn literature, composition involves structuring a story to the best of your ability in order\nto achieve a specific storytelling effect. This section discusses the rules of composing\nGiven-When-Then templates designed to facilitate outside-in development:\nLow-level composition—How to phrase Gherkin steps\nHigh-level composition—How to balance Givens, Whens, and Thens in your scenarios\nThese rules should help you write easily readable Gherkin scenarios more quickly.\n3.2.1\nStarting with a Then\nEvery writer knows that there’s something terrifying about a blank page. Even if you\nknow what you want to write about, transforming thoughts into words is difficult. The\nsame applies to Gherkin scenarios. It may seem counterintuitive, but the easiest way to\nstart writing a Gherkin scenario is to begin with the end in mind—the Then—just as\nmost good writers never start writing without figuring out the ending. This should get\nyou unstuck quickly. It also brings other benefits, such as better collaboration with\nbusiness users to elicit better requirements.\nTIP\nStarting with examples of outputs can help engage business users in the\ndiscussion even before any scenarios are written and will give them a clear pic-\nture of what they can get out of the system. Outputs are often easier to discuss\nthan inputs because, usually, outputs already “exist” in the real world. For\nexample, when you’re trying to automate a manual process with software, the\nexpected outputs of the process are easy to retrieve from existing results. Now\nyou only need to figure out the automation process.\nTIP\nTo help achieve better outcomes, examine a behavior that already exists,\nand try to improve it.\nExercise 1\nRewrite listing 3.4 in declarative style.\n",
      "content_length": 2622,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 91,
      "content": "65\nComposing Gherkin scenarios\nWhat are the other benefits? The truth is, no one is ever in the market to buy a “prod-\nuct.” Think about it. Nobody wants to buy a drill for the sake of buying a drill. Some-\ntimes, though, people need a hole in a wall. In marketing, mistaking the source of\ndemand is called marketing myopia.2\nDEFINITION\nMarketing myopia—The mistake of paying more attention to the\nspecific products a company offers than to the benefits and experiences pro-\nduced by these products.\nCustomers want to buy a specific outcome your product will produce. And Thens are the\noutcomes. That’s why you should start with both getting the right Thens and getting\nthe Thens right, by which I mean your users should want the outcomes you’re specify-\ning, and the outcomes should be described clearly to the delivery team. Everything\nelse should build on top of that.\nTIP [STYLE] To facilitate outside-in development, use the following template\nto phrase most of your Thens: <an actor> should be able to <achieve a result.>.\nStarting with Thens fits into a larger narrative than writing good Gherkin or even mak-\ning software. Principles of Marketing, for example, is a must-read resource for all market-\ning students. You won’t find a line of code in it—not even a mention of an application\nor a server. The Jobs-to-be-Done framework3 also developed a concept of customers\nhiring products to yield specific outcomes, rather than buying new stuff. Doing\noutside-in development can fit into new business practices like these as they spread\namong companies. \n3.2.2\nUsing only one When per scenario\nIn prose, each form of fiction can only contain a story specific to its length. Short sto-\nries focus on a single hero or theme. Novels feature casts of multiple characters and\ngently intertwine their subplots.\n If you try to apply the structure of a novel to a short story without recomposing it,\nyou’ll fail. Many book adaptations fail as movies for the same reason. They try to fit\ntoo many themes and characters into a movie that’s two hours long, confusing viewers\nwith rushed plots and undeveloped characters.\n Ideally, a scenario should be three sentences long and feature one Given, one\nWhen, and one Then. Just as short stories focus on only one theme, each scenario\nshould be composed to talk about only one acceptance criterion.\n Let’s say that, in Queneau, there’s a readability score feature that lets writers know\nwhen they violate too many suggestions, making the text hard to read. Here’s a sce-\nnario describing that.\n2 Philip T. Kotler and Gary Armstrong, Principles of Marketing (Prentice Hall, 2013).\n3 First described in the 2005 Harvard Business Review article “Marketing Malpractice: The Cause and the Cure,”\nby Clayton M. Christensen, Scott Cook, and Taddy Hall.\n",
      "content_length": 2787,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 92,
      "content": "66\nCHAPTER 3\nMastering the Given-When-Then template\n \nScenario: Improving readability score\nGiven Vladimir's low readability score\nWhen he goes into the Edit Mode\nAnd he simplifies the text\nThen his readability score should improve\nTell me: does the readability score improve only when you use Edit Mode?\n When you use two Whens for one outcome, you can never be sure which When\ncaused the outcome to happen. In listing 3.5, intuition suggests that both Whens are\nnecessary for the readability score to improve. But are they? Why would the score\nimprove only if you used Edit Mode? Does that mean if you made the same changes in\nWrite Mode, the readability score wouldn’t go up? That’s ridiculous. To avoid such\nconfusion, think of Whens as user tasks performed by actors, and try to specify only one\nuser task per scenario.\nDEFINITION\nUser task—A high-level instruction that describes a single business\nactivity\nTo determine whether a When you wrote is a user task, ask whether the actor could per-\nform the task without turning on a computer. “Revising content” is a user task because\nyou can revise manually, too. “Choosing destination folder for a text file” isn’t a user\ntask, because it’s too low level—it deals with the tech domain instead of the business\ndomain.\n When you write a scenario with two user tasks, you make the scenario more diffi-\ncult to analyze. Coupling always means some interaction between multiple rules, and\nListing 3.5\n[BAD] Scenario with two Whens\nThe Screenplay Pattern\nTask-oriented thinking comes from an acceptance-testing practice called the Screen-\nplay Pattern, brought to life by Antony Marcano and later refined by Andy Palmer. I\nstumbled on the Screenplay Pattern thanks to Jan Molak and John Ferguson Smart,\nwho expanded on the subject in a series of articles.a\nThe Screenplay Pattern is a user-centered approach to writing high-quality automated\nacceptance tests based on good software-engineering principles. From a high-level\npoint of view, the pattern organizes tests around actors who perform user tasks in\norder to accomplish their business goals. The approach is similar to the one I take\nin the book.\nDevelopers and engineers will find the pattern helpful in avoiding redundancy and\norganizing test code according to patterns such as the Single Responsibility Principle\nand the Open-Closed Principle. Non-engineers can also use the Screenplay Pattern to\norganize Gherkin scenarios more easily.\na Jan Molak, “From Acceptance Tests to User Guides,” March 31, 2016, http://mng.bz/VU1u.\n",
      "content_length": 2533,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 93,
      "content": "67\nComposing Gherkin scenarios\ninteraction means new inputs and outputs to take care of. Given Gherkin scenarios’\noptimal length, it would be like trying to fit a novel into three sentences. But when\nyou aim to use only one task per scenario, you can clearly see what’s being tested in\nthe scenario.\nTIP\n[STYLE] User tasks take place in the present and should be phrased in\nactive voice to differentiate them from contexts and outcomes.\nBut sometimes a scenario with multiple Whens is an acceptable choice. Each high-level\nuser task is comprised of multiple lower-level activities called user actions. For example,\nwhen you want to print a document, you have to choose a format and pages to print\nand a quality of printing to achieve the final objective. (There are many other options\nto choose from, but I’m simplifying for the sake of the example.)\nScenario: Printing documents\nGiven a 50 pages long draft\nWhen Vladimir wants to print in the letterhead format\nAnd he chooses to print all the pages\nAnd he chooses to print in low quality\nThen the printer should print 50 low quality A4 pages\nNone of these steps is a standalone user task; you must complete all three to get a\nmeaningful result. If you only use multiple Whens to convey user actions, there also\nisn’t any confusion about whether the steps are all required for the scenario to take\nplace in the real world.\nTIP\n[COMPOSITION] To distinguish small user actions and big user tasks,\nremember that user tasks should allow actors to proceed to Thens. If a When\nneeds additional clarification, it’s a user action.\nWhen you set out to write a new scenario, should you write about user tasks or user\nactions? That depends. I’ll come back to this in section 3.2.4, which discusses choos-\ning the right level of abstraction for your scenarios. \n3.2.3\nSpecifying prerequisites with Givens\nIn sci-fi and fantasy, imaginary worlds often enable writers to tell the stories they want\nto share. Let me give you an example. The events of The Lord of the Rings wouldn’t hap-\npen if not for the One Ring, a magical item that’s central to the plot. The ring is an\nelement of the fictional universe that author J. R. R. Tolkien created; but because its\nListing 3.6\n[GOOD] Scenario with multiple user actions\nExercise 2\nRewrite the user actions from listing 3.7 as a user task.\n",
      "content_length": 2321,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 94,
      "content": "68\nCHAPTER 3\nMastering the Given-When-Then template\nappearance sets the action in motion, it’s also a prerequisite necessary for the rest of the\nstory to happen.\n Givens have a role in scenarios that’s similar to world-building in storytelling. A Given\ncreates a snapshot of the represented world and its history before the action of the scenario\ncan take place. The snapshot stays static until the actors change it with their actions.\nTIP\n[STYLE] Don’t phrase Givens as actions. Use passive voice in past tense,\nor phrase each Given as a list of things that need to happen before the actors\ncan move the action forward.\nBut how can you create a snapshot in text? Use lists, because you can often rearrange\nlists easily, or use passive voice in past tense—but always remember to reserve actions\nfor Whens. Actions are usually scenario specific and thus can't be moved freely; lists, on\nthe other hand, are universal, because you can rearrange items more easily. And it’s\noften important to phrase Givens flexibly, because although different scenarios need\ndifferent snapshots, you’ll often want to reuse elements you’ve already created for\nother scenarios. To illustrate, here’s an example of an action within a Given.\nGiven Vladimir writes a sentence in his draft:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nI might suspect that this step was copied from another scenario where it was used as a\nWhen to specify some action. The problem is that without looking at the testing code,\nyou’ll know little about this step’s implementation. The implementation can, for\nexample, depend on other Givens that were useful when the step was a When but will\nonly make your new scenario less clear if you have to include them.\n Here’s how you could rewrite the problematic step to be standalone and flexible.\nGiven text:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nNow you have a step that is clearly distinct and can later be automated in a way that’s\neasy and safe to reuse in other scenarios.\n Think of Givens as building blocks. These blocks are used to build a coherent\nworld where your scenarios can take place. Passive blocks tend to fit with each other\nmore easily. You can just list necessary prerequisites, instead of trying to awkwardly\nstitch together a few active sentences from other scenarios.\nListing 3.7\n[BAD] An active Given\nListing 3.8\n[GOOD] A passive Given\n",
      "content_length": 2428,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 95,
      "content": "69\nComposing Gherkin scenarios\n \nREUSING GIVENS WITH BACKGROUNDS\nSometimes you’ll need the same prerequisites for all the scenarios in a single feature\nfile. Gherkin makes that easier with backgrounds.\n To better understand what a Gherkin background is, imagine you’re writing a\nbook that features multiple narrators. Each of the narrators tells their part of the story\nin a separate chapter. All the chapters are happening simultaneously. To let the reader\nbetter understand the plot, you decide to add a prologue written in third-person nar-\nrative mode that explains the basic context for all the other chapters. For example,\nthe book may be a historic action novel that pictures a chaotic aftermath of a medieval\ncity’s burning. The prologue describes events that led to the burning. The chapters\ndeal with the aftermath from the perspective of subsequent narrators. If Gherkin’s sce-\nnario can be compared to the book’s chapters, then a background is exactly like the\nprologue.\nDEFINITION\nBackground—A list of steps that run before each one of the sce-\nnarios in the same feature file\nYou can use a background to extract steps that are necessary to understand all other\nscenarios in a specification, without repeating them in every scenario. Let’s say you\nchoose to implement a search-and-replace function in Queneau. A simple implemen-\ntation will need four new scenarios: one for search, one for search and replace, one\nfor a success scenario, and one for a failure scenario.\nFeature: Search and replace\nScenario: Successful search\nGiven a text:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nWhen Vladimir searches for \"was\"\nThen he should be pointed to the word \"was\" in the text\nScenario: Unsuccessful search\nGiven a text:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\nListing 3.9\nScenarios with redundant Givens\nExercise 3\nRewrite the following step into a passive Given: Given Vladimir wants to write\na new book.\nThe same \nGivens in all \nscenarios\n",
      "content_length": 2013,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 96,
      "content": "70\nCHAPTER 3\nMastering the Given-When-Then template\n\"\"\"\nWhen Vladimir searches for \"best\"\nThen he should see that there is no such word in the text\nScenario: Successful search and replace\nGiven a text:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nWhen Vladimir wants to replace \"was\" with \"is\"\nThen the text should be:\n\"\"\"\nIt is love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nScenario: Unsuccessful search and replace\nGiven a text:\n\"\"\"\nIt is love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nWhen Vladimir wants to replace \"best\" with \"greatest\"\nThen the text stay as it was:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nHere’s the same specification, simplified thanks to a background.\nFeature: Search and replace\nBackground:\nGiven a text:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nScenario: Successful search\nWhen Vladimir searches for \"was\"\nThen he should be pointed to the word \"was\" in the text\nScenario: Unsuccessful search\nWhen Vladimir searches for \"best\"\nThen he should see that there is no such word in the text\nScenario: Successful search and replace\nWhen Vladimir wants to replace \"was\" with \"is\"\nThen the text should be:\nListing 3.10\nGivens refactored into Background\nThe same \nGivens in all \nscenarios\nThe Background keyword\nRedundant Givens from \nall four scenarios put in \nthe background\n",
      "content_length": 1428,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 97,
      "content": "71\nComposing Gherkin scenarios\n\"\"\"\nIt is love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nScenario: Unsuccessful search and replace\nWhen Vladimir wants to replace \"best\" with \"greatest\"\nThen the text stay as it was:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nAs you can see, backgrounds are put after the specification brief but before the sce-\nnarios. When you run the test-execution engine, it will execute both of the Givens\nbefore running each scenario.\n3.2.4\nChoosing the right abstraction level\nIn section 3.2.2, I said that you may want to write about high-level behaviors called\nuser tasks that consist of other, low-level behaviors: user actions. Due to the amount of\ntime I’m spending talking about ambiguity and clarity, you may think that being\nexplicit and listing every possible action in your scenarios is the default way to go. But\nbeing verbose isn’t always a good idea.\nTHE DISADVANTAGES OF BEING OVERLY SPECIFIC\nLook at the following scenario, which talks about versioning drafts. The person who\nwrote it chose to make changes in the newer revision using low-level user actions.\nScenario: Revising drafts\nGiven a draft of \"Lolita\"\nWhen Vladimir writes:\nListing 3.11\nScenario that should be more abstract\nShould you use backgrounds?\nSometimes a background is a useful tool. We managed to go from 49 lines of text in\nlisting 3.9 to 37 in listing 3.10, a decrease of almost 25%. And the more scenarios\nyou have, the greater the decrease will be.\nHaving said that, I don’t advise using backgrounds too often. Many Gherkin practi-\ntioners think backgrounds are prone to being misused and that they make the spec-\nification layer too technical. Everyone should be able to read a Gherkin scenario and\nunderstand it even without knowing Gherkin’s syntax—backgrounds make this\nharder. If you feel like you have to use backgrounds frequently, you should think\nabout using broader-concept steps or split your specification into several smaller fea-\nture files. \n",
      "content_length": 2017,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 98,
      "content": "72\nCHAPTER 3\nMastering the Given-When-Then template\n\"\"\"\nChapter 29\n\"\"\"\nAnd he marks the paragraph as a H1\nAnd he writes:\n\"\"\"\nIt was love at first sight, at last sight,\nat ever and ever sight.\n\"\"\"\nThen the new draft should replace the previous draft\nThe scenario is technically okay, but it’s too verbose given its purpose. Writing two new\nparagraphs with specific examples isn’t required to check whether new drafts replace\nolder drafts. It makes the scenario more difficult to read. But what if you simplified it?\nScenario: Revising drafts\nGiven a draft of \"Lolita\"\nWhen Vladimir makes a new revision\nThen the new draft should replace the previous draft\nMuch better!\n Unfortunately, no single rule exists for choosing the right level of abstraction. But\ndon’t worry about that right now. Even though you’re trying to write the best scenarios\nyou can, I wouldn’t expect that to happen every time—and that’s fine! Finish the first\ndraft and see what other people think. Ask your teammates, or find a third-party\nreader. Iterative improvement is much better than nonexistent perfection. The follow-\ning subsection offers some tips that should help you choose the optimal level of\nabstraction. \nHOW MANY STEPS SHOULD YOU AIM FOR IN A SCENARIO?\nRemember how I talked about starting new scenarios by writing their Thens? The level\nof abstraction of a particular scenario should depend on Thens, too, making them as\nobvious as possible. When you begin with the end in mind, you can work back to a cor-\nrect abstraction level, thinking about the minimal set of user tasks and prerequisites\nneeded to achieve the outcome you want.\nTIP\n[STYLE] As a rule of thumb, keep your scenarios at an abstraction level\nthat allows you to aim for as few Givens, Whens, and Thens as possible without\nsacrificing readability.\nIn general, you should explain the details necessary to understand the purpose of a\nscenario. If there’s a user flow that must be part of a scenario, because the scenario\ncan’t take place without it, but it isn’t crucial to understanding the scenario’s essence,\nthen you should only mention it briefly and consider wrapping it in a broader con-\ncept. This is what I did in listing 3.12 when I removed several specific steps, such as\nListing 3.12\nScenario at the correct abstraction level\n",
      "content_length": 2291,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 99,
      "content": "73\nComposing Gherkin scenarios\nmaking a paragraph into a header, and wrapped them in the broader concept “mak-\ning a new revision.”\n On the other hand, you should always have readers in mind. Will they understand\nwhat you intended if you simplify a scenario too much? For example, in the next sce-\nnario, do you know what Vladimir did to make the readability score go up?\nScenario: Improving readability score\nGiven Vladimir's low readability score\nWhen he simplifies the text\nThen his readability score should improve\nI have no idea. Simplifying can mean a thousand things.\nMy personal rule of thumb, which can help you to choose the right abstraction level,\nsays that you should be detailed when you introduce a new domain concept or a new\nuser flow to the specification suite, explaining as much as you deem necessary. Corri-\ndor testing is useful to determine whether you’re specific enough.\nDEFINITION\nCorridor testing—Informal, ad hoc solicitation to gain quick user\nfeedback or data. Named after the classic example of spotting someone across\na corridor and asking for their opinion.\nRemember that a concept important to one scenario may not be as important to oth-\ners. It’s okay if you explain a particular user flow in detail in one scenario and only\nmention it briefly in other specifications. You can be briefer and act as though the\nreader is someone who already knows the concept you’re writing about whenever you\nmention anything that already exists somewhere else in the specification suite.\n In prose, getting the right abstraction level is easy, because the reader is usually\nreading chapters in a linear manner. For example, if I taught you what an executable\nspecification is in chapter 1, I can expect that you already know what it is when you\nread chapter 3. A specification suite doesn’t work this way. A reader with any level of\nknowledge about the system can jump into any specification file at any moment. But\ndon’t worry about that right now. Chapter 7, which discusses living documentation,\ntalks about creating universal glossaries of concepts that will help you regulate the\nlevel of abstraction of particular steps throughout the specification suite. And chap-\nters 8 and 9 present some techniques for organizing scenarios and specifications in a\nmanner that’s easy to follow even though the reading process isn’t linear. \nListing 3.13\nScenario that should be less abstract\nExercise 4\nRewrite listing 3.13 to reduce its level of abstraction. For the purpose of the exercise,\nyou can assume that there’s only one way to improve the readability score: by making\nlong sentences shorter.\n",
      "content_length": 2615,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 100,
      "content": "74\nCHAPTER 3\nMastering the Given-When-Then template\n3.3\nTelling Gherkin stories with impact\nGherkin scenarios tell stories about behaviors performed by actors. Whereas the previ-\nous sections taught you why the outside-in style matters and how to structure stories,\nthey didn’t address the most important issue many writers face: what to write about.\nHow do you write meaningful scenarios that make your software better? Where should\nyou start? How can you make sure all inputs and outputs are covered properly and\nyour tests are good? This section offers some methods for writing scenarios that have\nreal impact.\n3.3.1\nWriting warm-up narratives\nA good way to get started when you’re stuck with a new requirement is to write a short,\nfree-flowing narrative about the requirement in action. You can do this after you\ngather some initial examples and acceptance criteria but before you write any scenar-\nios in Gherkin. Here’s an example.\n\"If your story is ready for rewrite, cut it to the bone.\nGet rid of every ounce of excess fat. This is going to hurt;\nrevising a story down to the bare essentials is always\na little like murdering children, but it must be done.\"\n—Stephen King\nWriting is hard. Many authors struggle to get anything done.\nThere's something terrifying about a blank page, but there's\nsomething terrifying about an unrevised page, too. What can\nyou do to make a writer's life easier?\nSketch out a few moments of a day in the life of one of the actors. In this narrative,\ninvent a person you can empathize with, and capture, briefly, the mental state of that\nperson, their goals, or the conditions that drive them to act as they do.\n When writing, don’t think about implementation yet. Ignore any technical limita-\ntions of your current system, and don’t focus on the new features you’ll have to\ndevelop to support the behavior. You don’t have to worry about edge cases, either. The\npoint of this exercise is to write anything. You can always rewrite the narrative into the\nGiven-When-Then template later.\nListing 3.14\nWarm-up narrative\nExercise 5\nWrite a warm-up narrative for Vladimir and the Focus Mode feature. Focus Mode, men-\ntioned in section 3.1.1, is a distraction-free writing mode designed to help the writer\nstay in the flow. Does the narrative cause you to imagine new solutions that would\nhelp Vladimir write something more easily?\n",
      "content_length": 2363,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 101,
      "content": "75\nTelling Gherkin stories with impact\nIf you think the narrative captures the business situation well enough, you can also put\nit into the specification brief. As long as you keep a beginner’s mind and write noth-\ning about your system in the narrative, it shouldn’t be redundant to the scenarios in\nthe specification. Instead, it should capture a broader business perspective and the\nneed for the requirement that arose long before your team wrote any code. \n3.3.2\nVetting acceptance criteria with examples\nA great way to generate new scenarios is to take advantage of the fact that acceptance\ncriteria and examples vet each other. By vetting, I mean that finding an acceptance cri-\nterion you haven’t yet considered can lead to adding new examples to your scenarios\n(see figure 3.1). But examples that are unexpected, weren’t considered seriously at\nfirst, or were discovered later in the process can also generate new acceptance criteria\n(see figure 3.2).\nExamples illustrate acceptance criteria. So when you take on a new example, you also\nagree to apply a new rule to your design or modify an existing one.\n You can start your analysis with either looking for examples or gathering an initial\nlist of acceptance criteria. There isn’t a strict rule for that, because you’ll probably go\nback and forth multiple times during development.\n Where you start from depends on the conversation you want to have. Exploring\nexamples first works best when you don’t have a good grasp of the system’s rules yet or\nwhen you want to challenge the stereotypical assumptions of your interlocutors. Col-\nlecting acceptance criteria first works better when you or your stakeholders have a\ngood initial understanding of what you’re about to build—for example, when you’re\nautomating a well-described process that’s an industry standard. \n3.3.3\nExploring contexts by questioning Givens\nIt’s easy to get stuck again after you finish writing a scenario. I can’t tell you how many\ntimes I’ve said “So—that’s it!” after writing a scenario, only to discover much later that\nmy complacency led me to overlook a subtle edge case that I then had to take care of.\nI was surprised the first time it happened. But after a similar situation occurred a few\nweeks later, I knew I had to be more careful. The problem was, even when I was\nExamples\nAcceptance\ncriteria\nCan generate new\nFigure 3.1\nYou can use a few \nobvious acceptance criteria as a \nchecklist to discover examples that \nwill help you explore the requirement.\nExamples\nAcceptance\ncriteria\nCan generate new\nFigure 3.2\nUnexpected examples \nchallenge acceptance criteria to \nensure a system’s completeness.\n",
      "content_length": 2638,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 102,
      "content": "76\nCHAPTER 3\nMastering the Given-When-Then template\ncautious, the sense of closure I felt after writing each scenario made it difficult to look\nat it again with fresh eyes.\n One of the methods I encountered when I wanted to solve this problem is called\ncontext questioning.4 To use this pattern, ask yourself, “Is there a context that, for the\nsame event, produces a different outcome?”\n Let me give you an example. Here’s a scenario you’ve already seen in this chapter:\nScenario: Revising drafts\nGiven a draft of \"Lolita\"\nWhen Vladimir makes a new revision\nThen the new draft should replace the previous draft\nAre there any other Givens that produce different Thens for the same event? Are there\nany kinds of drafts that, when Vladimir makes a new revision, shouldn’t replace the pre-\nvious edit?\n What if Queneau stores the drafts in the cloud? You could, for example, encounter\na synchronization conflict in the same draft between two devices, such as a mobile\nphone and a laptop. When a sync issue arises, you probably shouldn’t discard any of\nthe drafts—neither the one you store in the cloud nor the one that’s being saved. \n3.3.4\nExploring outcomes by questioning Thens\nContext questioning is a great technique to get you unstuck and help you write sce-\nnarios that are more complete, but it isn’t the only one. In the same book, Liz Keogh\ntalks about outcome questioning. To question outcomes, ask yourself, “Is there another\noutcome that also matters?”\n Let’s stay in the same area as the previous example: saving files in the cloud. Sup-\npose Queneau offers a free 50 MB cloud plan for everyone. When a user runs out of\nspace, they should upgrade to continue using the cloud feature:\nScenario: Upgrading cloud plans\nGiven a 50 MB limit on Vladimir's cloud drive\nAnd 50 MB of text documents on Vladimir's cloud drive\nWhen Vladimir tries to save a new revision in the cloud\nThen he should be upgraded to a plan with more space\nHaven’t you forgotten something? I once heard that making a profit is a nice thing to\ndo in the software business—so maybe you should also make sure you charge Vladi-\nmir’s credit card. Here’s the scenario after outcome questioning:\nScenario: Upgrading cloud plans\nGiven a 50 MB limit on Vladimir's cloud drive\nAnd 50 MB of text documents on Vladimir's cloud drive\nWhen Vladimir tries to save a new revision in the cloud\n4 I first read about context questioning in a book called Behaviour Driven Development by Liz Keogh (Leanpub,\n2015).\n",
      "content_length": 2473,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 103,
      "content": "77\nAnswers to exercises\nThen he should be upgraded to a plan with more space\nAnd his credit card should be charged $5\nBut there are two separate outcomes here. Should they be in the same scenario, or in\ndifferent ones? A good rule of thumb is to ask whether they can happen separately. If\nthey can’t, they should be in the same scenario. But if they can, you need to ask whether\nthe outcomes are related to the same business domain. If they aren’t, they’re probably\ntwo separate requirements and should be separated so the specification suite will be\norganized more clearly and have good searchability. I’ll talk more about this in chapters\n8 and 9, which explore the topic of organizing scenarios and specification suites.\nI’ll talk about the concept of the specification suite as a map of requirements more in\nchapters 8–11. For now, we’ll use the rule of thumb I discussed previously. \n3.4\nAnswers to exercises\nEXERCISE 1\nRewrite listing 3.4 in the declarative style:\nGiven a draft to export\nWhen Vladimir saves \"Lolita\" as a PDF\nThen a formatted PDF should appear where Vladimir saved it\nEXERCISE 2\nRewrite the user actions from listing 3.7 as a user task:\nGiven a 50 pages long draft\nWhen Vladimir wants to print the entire draft as low-quality A4\nThen the printer should print 50 low quality A4 pages\nEXERCISE 3\nRewrite the following step into a passive Given: Given Vladimir wants\nto write a new book:\nGiven a new book idea by Vladimir\nEXERCISE 4\nRewrite listing 3.13 to reduce its level of abstraction. For the purpose of\nthe exercise, you can assume that there’s only one way to improve the readability\nscore: by making long sentences shorter:\nGiven text with a low readability score:\n\"\"\"\nAs he crossed toward the pharmacy at the corner he involuntarily turned his\nhead because of a burst of light that had ricocheted from his temple, and\nsaw, with that quick smile with which we greet a rainbow or a rose, a\nblindingly white parallelogram of sky being unloaded from the van—a dresser\nExercise 6\nAre concepts such as cloud features and buying extra space in the same domain as\ncharging the user’s credit card?\n",
      "content_length": 2119,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 104,
      "content": "78\nCHAPTER 3\nMastering the Given-When-Then template\nwith mirror across which, as across a cinema screen, passed a flawlessly\nclear reflection of boughs sliding and swaying not arboreally, but with a\nhuman vacillation, produced by the nature of those who were carrying this\nsky, these boughs, this gliding façade.\n\"\"\"\nWhen Vladimir breaks his long sentence into multiple ones:\n\"\"\"\nAs he crossed toward the pharmacy at the corner\nhe involuntarily turned his head.\n--\nA burst of light ricocheted from his temple.\n--\nHe saw, with that quick smile with which we greet\na rainbow or a rose, a blindingly white\nparallelogram of sky being unloaded from the van.\n--\nIt was like a dresser with mirror across which,\nas across a cinema screen, passed a flawlessly clear\nreflection of boughs sliding and swaying.\n--\nIt did so not arboreally, but with a human\nvacillation, produced by the nature of those who\nwere carrying this sky, these boughs,\nthis gliding façade.\n\"\"\"\nThen his readability score should improve\nEXERCISE 5\nWrite a warm-up narrative for Vladimir and the Focus Mode feature:\n\"Every writer is at heart a\nprocrastinator, because writing is an exhausting difficult\nprocess—especially writing prose. Vladimir knows that, too, even though\nhe may not want to admit it so easily.\n\"When the deadline comes, he won't have a choice anymore and he'll be\nforced to focus and get rid of any distractions under pressure. Here's\nwhere we and our Focus Mode can help.\n\"So what, possibly, can distract a writer sitting in front of his PC?\nOther programs—Facebook, Twitter, and so on—so we'll make the\neditor full screen.\n\"But what about the sentences he already wrote? He'll want to edit them\neven though it would be better to move on for now and do it later—so we\ncan, for example, dim all the sentences apart from the one that's\ncurrently being written.\n\"Vladimir certainly listens to music, because everybody listens to music.\nBut is the music Vladimir listens to the right music to increase his focus?\nWe could provide a short ambient playlist built into our Focus Mode that\nwould guarantee to boost his productivity based on new psychology\nresearch.\"\nEXERCISE 6\nAre concepts such as cloud features and buying extra space in the same\ndomain as charging the user’s credit card?\n",
      "content_length": 2266,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 105,
      "content": "79\nSummary\n There are at least two domains in play here:\nThe payments domain should only deal with processing payments, managing\ncredit cards, and dealing with refunds.\nThe cloud domain doesn’t necessarily have to be connected to the payments\ndomain.\nFor example, you could easily imagine a change in Queneau’s business model that\nwould make all the cloud features available for free. In that case, you’d need to keep\nall the cloud scenarios but remove from them all mentions of paid and free plans. To\navoid that, you should specify cloud functionality and paid plan limits separately.\n3.5\nSummary\nOutside-in development is a methodology that aims to build a clear understand-\ning of the goals and motivations of stakeholders.\nStart writing your next scenario with a Then to put emphasis on outcomes that\nare important for stakeholders.\nTo keep scenarios short, sweet, and simple, aim to use only one When per sce-\nnario.\n\nWhens should describe business rules and business-driven behaviors, instead of\nsystem implementations or the UI.\nTo separate context from actions and consequences, write Givens using passive\nvoice and past tense.\nA warm-up narrative briefly sketches out a few moments in a day in the life of\none of the actors.\nVetting examples means exploring the boundaries of acceptance criteria by\nadding or removing examples and checking whether the criteria are still valid.\nContext questioning means looking for other possible Givens and Thens for the\nsame Whens.\nOutcome questioning means looking for other possible Thens for the same\nGivens and Thens.\n",
      "content_length": 1579,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 106,
      "content": "80\nThe basics of\nscenario outlines\nChapters 2 and 3 explored the art of writing scenarios. You learned several tech-\nniques that make creating new scenarios easy and fun. And that’s fantastic! After\nall, the gentle learning curve is what makes Gherkin so beginner-friendly. But this\nsimplicity is also what makes creating a stable specification suite difficult from a\nlong-term perspective. Gherkin is almost too easy to write, so it’s also easy to pick\nup bad habits.\n While writing this chapter, I looked at several of my first feature files: some\nwere longer than 500 lines, even though most of the scenarios were similar. As I\nread the full specification, I understood why. The feature was a reporting system\nThis chapter covers\nUnderstanding scenario outlines versus \nscenarios\nRemoving redundancies in scenarios with DRY\nComparing advantages and disadvantages of \nscenario outlines\nMaintaining scenario outlines over time\n",
      "content_length": 932,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 107,
      "content": "81\nExample shopping application\nfor conversion metrics. The scenarios looked as if I wrote a main scenario and then\ncopied it multiple times to play with different metrics, changing only the numbers\nand trying to make sure the calculations would be implemented exactly as they\nshould be. I had good intentions, but I wasted a lot of space—and the readability\nwasn’t perfect, either. Looking back, I saw that my desire to be precise backfired.\nGoing through one feature file took almost an hour, as I tried to re-create my think-\ning. When I finished, I felt sorry for my former teammates.\n Surely there must be a better approach than copying and pasting scenarios! Today,\nI can laugh at my former self, because I know one: scenario outlines.\nDEFINITION\nScenario outline—A template that similar scenarios can share so\nyou don’t have to repeat the same Given-When-Then template throughout\nyour feature file\nScenario outlines look similar to normal scenarios, but there are some differences\nthat I’ll talk about throughout the chapter.\n The process of getting from raw scenarios to reusable scenario outlines is usually iter-\native, as you’ll see later. When I talked about key process patterns of SBE in chapter 1, I\ncalled the process refining examples. That means taking raw examples and doing the\nfollowing:\nMerging similar examples\nRemoving irrelevant examples\nFocusing on key examples\nMaking sure key examples are easy to understand\nOutlines can help you do all that efficiently.\n Using scenario outlines is a difficult skill to get right. That’s why we’ll explore the\ntopic in two connected chapters. This chapter covers the basics: you’ll go through a\ntutorial to learn the syntax, and you’ll learn how to apply that syntax to a real-world\nproject. You’ll also see that outlines can change—grow or shrink—over time, and why\nthat happens. After you understand how outlines work, we’ll examine the advantages\nand disadvantages they bring to the table. Then, chapter 5 will talk about advanced\ntechniques for using scenario outlines—techniques that elevate the upsides to their\nfull potential, simultaneously reducing the downsides.\n4.1\nExample shopping application\nA single example runs through the course of chapters 4 and 5: an e-commerce shop-\nping application similar to Amazon—the everything store. Like Amazon, this company\nhopes to become the go-to retailer of books, movies, music, and games, along with\nelectronics, toys, apparel, sports, tools, groceries, and garden items.\n The company’s plans for the future are ambitious. Right now, though, the store\nsells only books in digital formats, such as PDFs and audiobooks. It’s still an early-stage\nstart-up; building a digital shop was the easiest way to release the minimal viable pro-\nduct and start growing revenue.\n",
      "content_length": 2784,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 108,
      "content": "82\nCHAPTER 4\nThe basics of scenario outlines\n Now, management feels that it’s high time for the company to move from digital-\nonly to selling physical items, too. They choose to begin selling physical-format publi-\ncations, such as hardcovers, paperbacks, and audio CDs, for two reasons. First, the\ncompany is already a book-selling start-up, so there will be no rebranding expenses.\nSecond, and more important, shipping publications in physical formats will require\nbuilding a working shipping infrastructure. The company can use such an infrastruc-\nture in the future to add new products such as toys and tools. \n4.2\nUsing scenario outlines\nThis section reviews an existing feature file for one of the core functionalities of the\nstore: shipping orders. Because shipping digital products isn’t the same as selling\nphysical ones, you’ll need to add some new scenarios to specify new shipping capabili-\nties for the system.\n Along the way, you’ll notice that the scenarios become too similar, which makes for\nboring reading, and that the feature file grows in size, which doesn’t seem efficient.\nYou’ll then rewrite the feature file by merging multiple scenarios into a single sce-\nnario outline.\n4.2.1\nSpotting redundancies in Gherkin scenarios\nManagement has given you a green light to implement shipping physical orders. Even\nthough this is a huge change, you won’t start from scratch. Fortunately, your system\nalready has basic functionalities, such as an order-status page, that you can expand on.\nIn addition, you can connect with external shipping APIs and let other companies\nhandle behind-the-scenes shipment management. The only thing you have to do right\nnow is specify how customers will order shipping for the new formats you’re going to\noffer, and implement the scenarios.\n Before you do that, though, let’s look at the two existing scenarios. They were writ-\nten a few months ago to handle the most basic use cases.\nFeature: Shipping\nScenario: Shipping PDFs\nGiven a PDF book in Simona's cart\nWhen she pays for it\nThen the book should be sent to a mobile device\nScenario: Shipping audiobooks\nGiven an audiobook in Simona's cart\nWhen she pays for it\nThen the book should be sent over email\nWith digital books, the case is simple. They’re sent either by email or directly to a\nmobile device such as a Kindle reader. Going physical will force you to let customers\nListing 4.1\nTwo simple initial scenarios\n",
      "content_length": 2416,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 109,
      "content": "83\nUsing scenario outlines\nprovide their shipping addresses and make sure the books they buy are shipped by\nintegrating with external APIs from a shipping company—a task that will probably be\nhandled in the automation layer.\n Have you noticed that the two scenarios in listing 4.1 look almost the same? They\nshare the same basic structure due to an example-counterexample relationship. Because\nthere are only two ways to ship a digital order—device integration and email down-\nload link—each scenario is a counterexample to the other. Whoever wrote this feature\nfile clearly wanted to let you know that the system ships PDFs differently than audio-\nbooks.\n To illustrate contrast, examples and counterexamples usually share the same basic\nstructure, differing only in details. In the example’s two scenarios, the Whens are iden-\ntical. They make Simona pay for her order:\nWhen she pays for it\nThe repeating When creates the underlying structure of the scenarios. The differences\nlie in the Givens and Thens, but even they are similar.\n In Gherkin, repetition isn’t uncommon. Although the syntax looks like a natural\nlanguage, the scenarios often aren’t pretty. They’re written and read by technical\nteams or busy nontechnical stakeholders who often value brevity over beauty. Some\nredundancies are to be expected—especially in shorter specifications. Even though\nthis isn’t a problem in a two-scenario feature file, you’ll see that there are cases where\nrepetition becomes too awkward to dismiss in writing and too difficult to maintain in\nthe specification suite long-term.\n Let’s see what happens when you add the new physical formats and shipping fea-\ntures. Here are the three types of books the company has decided to add:\nHardcovers\nPaperbacks\nAudio CDs\nUnlike the digital formats, these are sent to the user’s shipping address by an external\nshipping company; see table 4.1.\nTable 4.1\nAll book formats\nFormat\nShipped …\nPDF\nTo a mobile device\nAudiobook\nWith an email download link\nHardcover\nTo a shipping address\nPaperback\nTo a shipping address\nAudio CD\nTo a shipping address\n",
      "content_length": 2085,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 110,
      "content": "84\nCHAPTER 4\nThe basics of scenario outlines\nThe new scenarios should be easy enough to write. After all, you’re going to use the\nsame template that you established when you analyzed the initial examples.\nFeature: Shipping\nScenario: Shipping PDFs\nGiven a PDF book in Simona's cart\nWhen she pays for it\nThen the book should be sent to a mobile device\nScenario: Shipping audiobooks\nGiven an audiobook in Simona's cart\nWhen she pays for it\nThen the book should be sent over email\nScenario: Shipping hardcovers\nGiven a hardcover book in Simona's cart\nWhen she pays for it\nThen the book should be shipped physically\nScenario: Shipping paperbacks\nGiven a paperback book in Simona's cart\nWhen she pays for it\nThen the book should be shipped physically\nScenario: Shipping Audio CDs\nGiven an Audio CD book in Simona's cart\nWhen she pays for it\nThen the book should be shipped physically\nNow it’s even worse, isn’t it? You’ve ended up with five scenarios that are almost\nexactly the same. It’s an inelegant, inefficient solution. It also isn’t perfect from a\nreadability standpoint. I can imagine people reading only the first scenario and then\nskimming through the remaining examples—which is warranted in this case, but a\nbad habit in general. What if some of the scenarios hide an important detail despite\nlooking similar to the others? A skimming reader could easily miss that. How can you\nmake sure that won’t happen?\n4.2.2\nRefactoring redundant scenarios with scenario outlines\nIdeally, you want to have two types of scenarios:\nScenarios that visually group similar examples together and use the same\nunderlying template for all examples. The visual grouping notifies the reader\nthat it’s safe to skim the examples.\nScenarios that are important enough to stand on their own, letting readers\nknow they should focus when reading them.\nListing 4.2\nScenarios with new shipping options added\nThree new \nscenarios\n",
      "content_length": 1906,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 111,
      "content": "85\nUsing scenario outlines\nThe first type of scenarios are, in fact, scenario outlines. To understand how scenario\noutlines work, you’ll have to forget the rule about using concrete examples—only for\na little while, and only to see whether adding a bit of abstraction will help remove\nredundancy from your scenarios. You’ll also look for a way to visually distinguish simi-\nlar steps and build a shared template for such scenarios.\n In the online store, you’ve added the new book formats and ended up with five dif-\nferent Givens splattered throughout your feature file:\n\nGiven a PDF book in Simona’s cart\n\nGiven an audiobook in Simona’s cart\n\nGiven a hardcover book in Simona’s cart\n\nGiven a paperback book in Simona’s cart\n\nGiven an Audio CD book in Simona’s cart\nBecause they all share the same sentence structure, they can easily be abstracted away\ninto a simple template similar to this:\nGiven a <format> book in Simona's cart\nWe already noted that each of the five scenarios in the specification uses the same\nWhen to perform the main action, so let’s add that step to the template:\nGiven a <format> book in Simona's cart\nWhen she pays for it\nThe only thing left is taking care of the Thens. Just as there are several kinds of Givens,\nthere are also several different kinds of Thens:\n\nThen the book should be sent to a mobile device\n\nThen the book should be sent over email\n\nThen the book should be shipped physically\nThe list is shorter this time, but remember that the three scenarios for hardcovers,\npaperbacks, and audio CDs use the same Then because these formats are shipped\nusing the same method. Despite that, the three Thens can be abstracted away into a\nsimilar template:\nThen the book should be <shipped>\nThe result is a scenario template similar to the following.\nGiven a <format> book in Simona's cart\nWhen she pays for it\nThen the book should be <shipped>\nLook back for a moment at table 4.1. Notice the <format> and <shipped> attributes\nfrom the scenario template and the header row. You could use the table to put each of\nthe formats in the scenario template, along with an accompanying shipping method.\nListing 4.3\nFull scenario template\n",
      "content_length": 2169,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 112,
      "content": "86\nCHAPTER 4\nThe basics of scenario outlines\nAnd if you could make the <shipped> attribute dependent on the <format> attribute\nin the automation layer, you could change the outcome of the scenario based on your\ntemplate every time you executed the specification suite—without changing the rest\nof the steps!\n The good news is, you can do that. The template in listing 4.3 is valid Gherkin.\nGherkin lets you group similar scenarios that share the same structure in a scenario out-\nline: an automatable template for removing redundancy in similar scenarios. Outlines\nuse visual signs such as attributes and tables to group related examples so you don’t\nhave to worry about missing anything important. \n4.3\nThe structure of a scenario outline\nHere’s what a full scenario outline looks like.\nFeature: Shipping\nScenario Outline: Shipping\nGiven a <format> book in Simona's cart\nWhen she pays for it\nThen the book should be <shipped>\nExamples:\n| format\n| shipped\n|\n| PDF\n| sent to a mobile device |\n| Audiobook | sent over email\n|\n| Hardcover | shipped physically\n|\n| Paperback | shipped physically\n|\n| Audio CD\n| shipped physically\n|\nThe result is similar to the process you analyzed back in figure 1.9 (repeated here in\nfigure 4.1), when I talked about the process of collecting and refining examples.\nThanks to scenario outlines, you can take raw examples from raw scenarios and put them\ninto refined scenario groups. Grouping raw examples is possible because every outline\nis built from three elements: the Scenario Outline keyword, parameters, and the\nExamples table. The following sections analyze this structure, starting with the end:\nthe Examples table.\n4.3.1\nThe Examples table\nThe Examples table contains all the examples. The syntax is straightforward. Tables\ncan be created easily: use a vertical stroke (|) as the first character of the line, and also\nseparate table cells with it. The first row is the header row containing the Scenario\nOutline parameters. After the header, each example has its own row. \nListing 4.4\nIntroducing a scenario outline\nScenario Outline is the keyword that \nlets the test runner recognize outlines.\nTwo parameters: \nformat and shipped\nExamples with which to \nreplace the angle brackets\n",
      "content_length": 2223,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 113,
      "content": "87\nThe structure of a scenario outline\n4.3.2\nParameters\nThe Scenario Outline parameters go in angle brackets (<>), like <format> and\n<shipped>. They allow the test runner to paste the examples from the table into the\noutline you’ve written.\n If you have the following steps\nGiven a <format> book in Simona's cart\nWhen she pays for it\nThen the book should be <shipped>\nand the following table, which is a simplified version of the full table\nExamples:\n| format\n| shipped\n|\n| PDF\n| sent to a mobile device |\n| Audiobook | sent over email\n|\nthen Scenario Outline will produce and run two scenarios:\n\n<format> is replaced with PDF and <shipped> is replaced with sent to a\nmobile device\n\n<format> is replaced with Audiobook and <shipped> is replaced with sent over\nemail.\nRaw examples\nRaw scenario\nRaw examples\nAcceptance\ncriterion\nRaw scenario\nRefined example\nRefined scenario\nRefined example\nRaw examples\nRaw scenario\nRefined scenarios contain\nonly key examples needed to\nunderstand the criterion.\nAn acceptance criterion \nneeds examples that pass \nor fail the criterion.\nRaw examples generate\nraw scenarios that often \nhave similar structure.\nFigure 4.1\nEvery acceptance criterion generates new examples; every example generates \na new scenario. Teams should refine their specifications to merge similar examples, reject \nthose that introduce noise, and choose the most meaningful or descriptive ones.\n",
      "content_length": 1402,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 114,
      "content": "88\nCHAPTER 4\nThe basics of scenario outlines\nThus, scenario 1 will run as\nGiven a PDF book in Simona's cart\nWhen she pays for it\nThen the book should be sent to a mobile device\nand scenario 2 will run as\nGiven an audiobook in Simona's cart\nWhen she pays for it\nThen the book should be sent over email\nEach step from the generated scenarios will have an accompanying step definition in\nthe automation layer that lets each example run as an automated test.\n Outlines rely on patterns to match attributes with the examples from the table.\nWhen a test runner sees a Gherkin scenario with multiple examples, it runs the sce-\nnario template as many times as there are examples, replacing abstract attributes with\nthe concrete values dictated. Each time, it replaces a pattern called <pattern_name>\nwith a corresponding example. Every pattern’s name must be written without any\nspaces and within angle brackets.\nTIP\nIf you’re curious about how to automate scenario outlines, check out\nsection A.6 in the appendix, which talks about executing scenarios with multi-\nple examples.\nWith scenario outlines, you can test for multiple cases that share similarities but yield\ndifferent outcomes. The simplest examples are two contrasting cases for the same\nacceptance criterion: a success scenario and a failure scenario. The success scenario\ndefines what conditions are needed for the user to succeed, given the user’s inten-\ntions. Failure scenarios, on the other hand, define every other behavior that will fall\nshort.\n As you can see, merging similar scenarios means writing separate scenarios first\nand looking for similarities later. It’s a simple technique used by beginners. People\ngenerally use it in order to not break the Don’t Repeat Yourself (DRY) principle of soft-\nware development. This principle, aimed at reducing repetition of information of all\nkinds, states that you shouldn’t write similar code twice. \n4.3.3\nThe Scenario Outline keyword\nThe Scenario Outline keyword at the beginning of listing 4.4—the Scenario Outline:\nShipping part—notifies the test runner that it should execute the outline as many\ntimes as there are examples in the table. If you need additional information about key-\nwords, the automation layer, and executing scenarios, refer back to sections 2.1, 2.3,\nand 2.5. \n",
      "content_length": 2295,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 115,
      "content": "89\nAdvantages of scenario outlines\n4.4\nAdvantages of scenario outlines\nNow that you understand how to use scenario outlines, let’s talk about why you’d want\nto. In addition to the DRY principle mentioned in the previous section, outlines offer\ntwo other advantages for your executable specifications:\nOutlines take much less space.\nOutlines group concrete examples according to high-level business rules.\n4.4.1\nShorter feature files\nThe first and foremost reason to use scenario outlines is brevity. In the example, when\nyou refactored the five scenarios into a single outline, you saved 16 lines—a 52%\ndecrease in length. That’s a lot of space, even though shipping functionality is a sim-\nple case to specify in terms of business complexity and you didn’t have many scenarios\nto begin with. \n4.4.2\nFeature files organized by high-level business rules\nScenario outlines also increase your scenarios’ level of abstraction without sacrificing\nthe focus on concrete, real-world examples. In the last few years, I’ve seen and written\nmany feature files that were longer and much more difficult than the one in the exam-\nple. And although saving space is a nice side benefit, the real problem with longer\nspecifications is that they become more difficult to grasp at a glance because you can’t\nbe sure how particular scenarios relate to each other. Here’s an example to show you\nwhat I mean.\n Imagine that you have 10 or more scenarios in a single feature file. Some of the\nscenarios talk about distinct business rules; others cover different cases of a single\ncomplex rule; and, last but not least, some test important edge cases pointed out by\ntesters. If you want to search for a particular scenario, it’s much harder to find it in a\nmessy specification suite like that. You’ll naturally want to group such scenarios into\nseveral easy-to-find cohorts—and scenario outlines let you do that. When you use out-\nlines, you can be sure that every scenario covers only a single business rule and that\ndifferent applications of that rule are listed in the Examples table. In that regard,\nGherkin is similar to legal reasoning. In Gherkin, scenarios are easier to digest when\nthere are only a few rules to obey; but, like in law, the more rules you have, the messier\nand more complicated an entire codex becomes.\n For example, many countries in medieval Europe had laws specifying different\npenalties for stealing or killing various kinds of livestock. To enforce the rules, the\nsheriff had to remember that stealing a chicken should cost X and that stealing a cow\nshould cost Y, arbitrary amounts. It would have been much easier to make a general\nrule that, for example, tied indemnities to the average price of similar livestock in the\ncapital’s marketplace. If countries had done that, they could have illustrated the rule\nwith concrete examples based on market prices measured the previous summer, to be\nsure the sheriff and the citizens were on the same page.\n",
      "content_length": 2958,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 116,
      "content": "90\nCHAPTER 4\nThe basics of scenario outlines\n The same principles apply to executable specifications. Remember when you\nadded new book formats to the scenario outline? At first, you had only two specific\nscenarios without a general rule in place. Each scenario specified how one of the two\nbook formats was shipped. But as you added new examples, the specification got mess-\nier, and the abundance of concrete examples didn’t look elegant. So from those two\nscenarios, you derived a general rule for shipping and rewrote it as a scenario outline.\nIn a way, you went through a process similar to how legal reasoning evolved through-\nout the last millennium—but you did so over the course of a single chapter, instead of\n1,000 years. Point for you.\n Although scenario outlines won’t solve all the problems you’ll encounter when\nmanaging large specification suites, they can work well on the level of a single feature\nfile. And we’ll visit management at the level of the entire suite in chapters 8 and 9. \n4.5\nGrowing and maintaining scenario outlines\nIn the world of continuous deployment and short release cycles, no feature is ever set\nin stone. Such flexibility lets delivery teams that use iterative software development\nprocesses build smaller features that take less time to develop and that can be\nexpanded in the future. As features expand, so do scenario outlines. Although sce-\nnario outlines do make feature files shorter, they, too, can grow to a size at which man-\naging an outline becomes a problem.\n To illustrate how that happens, let’s return to the example. Assume that develop-\nment was smooth and the feature was safely deployed to production. That’s great! But\nit doesn’t mean your work is done. Shortly after deployment, you start working on new\niterations of your shipping feature. You’ll begin by expanding the PDF example:\nExamples:\n| format\n| shipped\n|\n| PDF\n| sent to a mobile device |\n| Audiobook | sent over email\n|\n| Hardcover | shipped physically\n|\n| Paperback | shipped physically\n|\n| Audio CD\n| shipped physically\n|\nWhen it comes to mobile devices, there are at least three major mobile platforms to\nconsider: Apple’s, Google’s, and Amazon’s. When you first implemented the feature\nfor mobile integration, you decided that books in the PDF format should be shipped\ndirectly to a customer’s mobile device. You decided to use an external integration pro-\nvider. The provider maintained a single API endpoint for integrating with all three\nplatforms at once, which was convenient at the time. Unfortunately, your design team\ndecided recently that a shallow integration like that isn’t enough in terms of user\nexperience. Each of the three platforms you support has a standalone e-book reader:\niBooks, Google Play Books, and Kindle. You’d like to develop a deeper integration\nwith each of these ecosystems, to control the overall user experience without forcing\nusers to install additional apps beyond what they already have.\nExample you’ll \niteratively expand\n",
      "content_length": 2988,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 117,
      "content": "91\nGrowing and maintaining scenario outlines\n As you can see, the example that was fine in the past lacks necessary detail in this\narea. To fix that, the team has agreed that you need to split the single example into\nthree examples—one for each of the new deep mobile integrations. Based on that,\nyou’ll then rewrite the application code. And later, you’ll have to write new testing\ncode for each example in the automation layer, too.\n Let’s get ready to work! Here’s what a reworked scenario outline could look like.\nFeature: Shipping\nScenario Outline: Shipping books that were bought\nGiven a <format> book in Simona's cart\nWhen she pays for it\nThen the book should be <shipped> by <provider>\nExamples:\n| format\n| shipped\n| provider\n|\n| PDF\n| sent to a mobile device | Apple\n|\n| PDF\n| sent to a mobile device | Google\n|\n| PDF\n| sent to a mobile device | Amazon\n|\n| Audiobook | sent over email\n| in-house service |\n| Hardcover | shipped physically\n| postal service\n|\n| Paperback | shipped physically\n| postal service\n|\n| Audio CD\n| shipped physically\n| postal service\n|\nThe automation layer can now have a different technical test for each provider in the\nstep definitions. In terms of numbers, you’ve removed one example and added three\nmore. The table grew larger. Ten examples aren’t difficult to maintain, but you know\nthat selling books is just the first step for your e-commerce company.\n At the beginning of this chapter, I mentioned that the company wanted to be the\nonline retailer of books, movies, music, games, electronics, toys, apparel, sports, tools,\ngroceries, and garden items—even though it initially only sold books. Soon, the com-\npany decided to begin its expansion by adding products such e-readers, tablets, and\nheadphones, chosen to fit into the store’s reading landscape. Such products are too\nprecious to be casually shipped by a postal service; they need to be shipped by courier\ndelivery.\n As soon as everyone agreed on the details, your team updated the specification to\ninclude new examples.\nFeature: Shipping\nScenario Outline: Shipping\nGiven an <item> in Simona's cart\nWhen she pays for it\nThen the book should be <shipped> by <provider>\nListing 4.5\nReworked scenario outline\nListing 4.6\n[OK] Scenario outline with a growing list of examples\nSeparate example\nfor Apple devices\nSeparate\nexample\nfor Google\ndevices\nSeparate \nexample \nfor Amazon \ndevices\n",
      "content_length": 2383,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 118,
      "content": "92\nCHAPTER 4\nThe basics of scenario outlines\nExamples:\n| item\n| shipped\n| provider\n|\n| PDF e-book\n| sent to mobile device | Apple\n|\n| PDF e-book\n| sent to mobile device | Google\n|\n| PDF e-book\n| sent to mobile device | Amazon\n|\n| Audiobook\n| sent over email\n| in-house service |\n| Hardcover book | shipped physically\n| postal service\n|\n| Paperback book | shipped physically\n| postal service\n|\n| Audio CD\n| shipped physically\n| postal service\n|\n| E-reader\n| shipped physically\n| courier delivery |\n| Tablet\n| shipped physically\n| courier delivery |\n| Headphone\n| shipped physically\n| courier delivery |\nWith the three new examples, you now have 10 examples overall—which is quite a few.\nAnd you’re still not finished. In the future, there will probably be even more examples\nas the store grows and new shipment methods appear. Organizing the examples in a\nmore efficient way would probably be a wise thing to do before you end up with a\nmessy specification.\n Gherkin lets you organize examples into multiple tables. You can split examples\ninto two or more tables and name each table accordingly to explain what the exam-\nples do and why they’re there. So if you have a generic table of four numbers that\nlooks similar to this\nExamples:\n| Number |\n| 1\n|\n| 2\n|\n| 3\n|\n| 4\n|\nyou can split it into two tables:\nExamples: Odd numbers\n| Number |\n| 1\n|\n| 3\n|\nExamples: Even numbers\n| Number |\n| 2\n|\n| 4\n|\nThe result is valid Gherkin code that any Gherkin-compatible test runner can easily\nunderstand.\n That seems like the perfect solution to the problem in the example, so let’s use it\nto tidy up the scenario outline.\nE-readers \nadded to \nthe store\nTablets\nadded to\nthe store\nHeadphones added\nto the store\nTables can have names.\nEach table contains \nits own examples.\nTables can have names.\nEach table contains \nits own examples.\n",
      "content_length": 1821,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 119,
      "content": "93\nGrowing and maintaining scenario outlines\n \nFeature: Shipping\nScenario Outline: Shipping\nGiven an <item> in Simona's cart\nWhen she pays for it\nThen the book should be <shipped> by <provider>\nExamples: Ship by sending to a mobile device\n| item\n | shipped\n| provider |\n| PDF e-book | sent to mobile device | Apple\n|\n| PDF e-book | sent to mobile device | Google\n|\n| PDF e-book | sent to mobile device | Amazon\n|\nExamples: Ship by sending a download link\n| item\n| shipped\n| provider\n|\n| Audiobook | sent over email | in-house service |\nExamples: Ship by a postal service\n| item\n| shipped\n| provider\n|\n| Hardcover book | shipped physically | postal service\n|\n| Paperback book | shipped physically | postal service\n|\n| Audio CD\n| shipped physically | postal service\n|\nExamples: Ship by courier\n| item\n| shipped\n| provider\n|\n| E-reader\n| shipped physically | courier delivery |\n| Tablet\n| shipped physically | courier delivery |\n| Headphone | shipped physically | courier delivery |\nThis listing organizes examples by shipping method. Each shipping method has its own\nlist of examples. No table is longer than three examples—such a neat categorization!\n But let’s check whether using multiple tables with examples will bring you more\nflexibility in the long term. At the moment, you sell and ship these items:\nDigital books on three platforms: Apple, Google, and Amazon\nPhysical books\nAudiobooks\nAudio CD books\nE-readers\nTablets\nHeadphones\nThat’s already a lot, but fast-forward a few more months to when the company decides\nto expand its services once again. This time, management not only wants to sell books\nand electronics, but also decides to grow the company’s entertainment market by add-\ning downloadable movies to the catalogue. And like e-books, movies should integrate\nout of the box with the three major platforms: Apple’s, Google’s, and Amazon’s.\nListing 4.7\n[BETTER] Examples grouped in separate tables\nTable for shipping \nmobile products\nTable for products \nthat can be \ndownloaded\nTable for shipping \nproducts via postal \nservices\nTable for \nshipping \nproducts by \ncourier\n",
      "content_length": 2093,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 120,
      "content": "94\nCHAPTER 4\nThe basics of scenario outlines\n That should guarantee a few new examples, shouldn’t it? But in keeping with the\nflexibility of scenario outlines with multiple tables, adding the additional rows\nshouldn’t be much of a problem.\nFeature: Shipping\nScenario Outline: Shipping\nGiven an <item> in Simona's cart\nWhen she pays for it\nThen the book should be <shipped> by <provider>\nExamples: Ship to Apple devices\n| item\n \n| shipped\n| provider |\n| PDF e-book | sent to mobile device | Apple\n|\n| Movie\n | sent to iTunes\n| Apple\n|\nExamples: Ship to Google devices\n| item\n | shipped\n| provider |\n| PDF e-book | sent to mobile device | Google\n|\n| Movie\n | sent to Google Play\n| Google\n|\nExamples: Ship to Amazon devices\n| item\n | shipped\n| provider |\n| PDF e-book | sent to mobile device | Amazon\n|\n| Movie\n | sent to Fire TV\n| Amazon\n|\nExamples: Ship by sending a download link\n| item\n | shipped\n| provider\n|\n| Audiobook  | send download link to email | in-house service |\nExamples: Ship by a postal service\n| item\n| shipped\n| provider\n|\n| Hardcover book | shipped physically | postal service |\n| Paperback book | shipped physically | postal service |\n| Audio CD\n| shipped physically | postal service |\nExamples: Ship by courier\n| item\n| shipped\n| provider\n|\n| E-reader\n| shipped physically | courier delivery |\n| Tablet\n| shipped physically | courier delivery |\n| Headphone | shipped physically | courier delivery |\nAdding three new examples was a piece of cake. And even though you now have 13\ndistinct items in the tables, the feature file still looks extremely organized. Such is the\npower of good scenario outlines.\n As the list of examples has expanded, the structure of the outline has also\nchanged. You’ve added new parameters, and you’ve split examples into clear, sepa-\nrated tables. The main takeaway of this section is to remember what many Gherkin\nwriters forget: that scenarios can—and should—be refactored as code. In software\nengineering, code refactoring is the process of restructuring existing computer code—\nchanging the factoring—without changing its external behavior. Gherkin can be\nrefactored, too. \nListing 4.8\nTables that can grow while maintaining readability\nMovies shipped to \nGoogle’s service\nMovies shipped to \nApple’s service\nMovies shipped to \nAmazon’s service\n",
      "content_length": 2296,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 121,
      "content": "95\nSummary\n4.6\nDisadvantages of scenario outlines\nI’ve already said a lot about the upsides of using scenario outlines. You’ve seen how\nthey can group similar scenarios with reusable attributes and tables according to the\nDRY principle. Section 4.4 expanded on the topic of how scenario outlines help orga-\nnize feature files by distinct business rules, resulting in greater readability and search-\nability. And in the previous section, you saw how a single scenario outline can hold\nmultiple examples without losing its focus. These are all good things. But now let’s\nconsider the other side of the story. It’s time to talk about the downsides—because\nthere are some.\n In truth, the Gherkin community tends to frown on using scenario outlines,\nbecause outlines written by inexperienced Gherkin practitioners often look more like\ncode than business-level features. It’s true: the attributes, brackets, and tables can\nsometimes appear scary to people who are new to Gherkin. Unfortunately, that can\nmake outlines less accessible to business stakeholders.\n So should you use scenario outlines or not? The answer isn’t straightforward.\nGood, easy-to-read scenario outlines with business-level examples can play a part in\ngetting buy-in from other stakeholders for using SBE. But bad examples can also\nmake accepting SBE much harder for anyone who isn’t already convinced about using\nthe methodology.\n For example, I worked according to SBE principles on two different projects. In\nboth projects, our team had to use two contrasting approaches. For one project, we\ngot a product owner to work on the scenarios with the delivery team over Git. The\nproduct owner was obviously a tech-savvy person who didn’t mind seeing scenario out-\nlines, even though they looked a bit technical with all the brackets and tables. For the\nsecond project, we never got anyone on the business side to discuss the tests. They\nfound it difficult to talk using Givens, Whens, and Thens and grew discouraged quickly.\nSo we hid all of our process and only asked for examples to get them talking about\ntheir process. We didn’t even show them the scenarios, let alone the scenario outlines.\nWe only discussed tables with examples stored in spreadsheets—and nobody said we\nwere too technical. I’ll teach you that method in chapter 5.\n So yes, scenario outlines can be easily misused—but they can also be effective. My\ngoal is to teach you how to use them well, because, as you’ve seen, the advantages are\nhuge. This is also why, to make sure you get it right, I decided to explore the topic in\ntwo chapters. The first chapter is behind us—on the second step of the journey, we’ll\ntalk about advanced techniques for using scenario outlines. \n4.7\nSummary\nScenario outlines are templates for similar scenarios that can help remove\nredundancy in your executable specifications according to the DRY principle.\nThe Examples table contains the examples and groups them by similarity.\nEach scenario outline can have multiple tables with examples.\n",
      "content_length": 3010,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 122,
      "content": "96\nCHAPTER 4\nThe basics of scenario outlines\nThe parameters in scenario outlines allow test runners to paste the examples\nfrom the table into the outline.\nScenario outlines work best when they group examples by business rules that\nthe examples adhere to.\nA scenario outline can grow over time as new examples appear.\nThe downside of using scenario outlines is that they can appear too technical\nand become code-like if you’re not careful.\n",
      "content_length": 443,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 123,
      "content": "97\nChoosing examples\nfor scenario outlines\nDid you know that female drivers are 47% more likely than male drivers to be seri-\nously injured in a car crash? When safety regulations were originally imposed on\nautomakers in the 1960s, the government wanted to require the use of two crash\ntest dummies of two slightly different sizes. Doing so would mean that only 5% of\nmen were larger than and 5% of women were smaller than the dummies. But auto-\nmakers pushed back, and, eventually, the requirement was reduced to only one\ncrash test dummy the size of an average male, making tests more standardized.\n Then, in 2011, for the first time female crash test dummies were required in\nsafety testing. The results forced some automakers to slash their safety ratings by\nmore than half, from a top five-star rating to just two stars. According to the test\nThis chapter covers\nWriting advanced scenario outlines\nUsing the outside-in method\nGoing beyond the simplest examples\nTesting diverse outcomes\nFixing bad examples\n",
      "content_length": 1016,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 124,
      "content": "98\nCHAPTER 5\nChoosing examples for scenario outlines\ndata, when a car slams into a barrier at 35 mph, a female dummy in the front passen-\nger seat registers a 20% to 40% risk of being killed or seriously injured. The average\nusing the male dummy is just 15%.\n Even though software is ubiquitous today, software engineering is still a young\nindustry. As such, it has had to borrow useful metaphors, mindsets, and practices from\nother, more mature fields. For example, civil engineering was a major influence.\nThat’s why some of us call ourselves engineers or software architects; it’s also why we\ntalk about building software.\n Automated testing has also had to borrow metaphors. That’s why, not coinciden-\ntally, the simplest examples are often called dummies—just like the fake mannequins in\ncar safety testing. In software engineering, dummy data is generic information that\ndoesn’t contain any real data but can be used as a placeholder. John Doe, for exam-\nple, is a dummy name commonly used by testers. Dummies are used whenever a tester\nor developer needs to make tests pass—they devise a set of dummy values meant to go\nsuccessfully through the validation systems used in the test, without caring about\nwhether these values will appear in the real world.\n But as in the case of female crash test dummies, even the most basic placeholders\ncan influence the results of a test in a dramatic and horrific way. I don’t want to argue\nthat all kinds of tests should use the most realistic data possible—it wouldn’t make\nmuch sense for some low-level unit tests, for example—but I strongly believe that some\ntests should. In section 3.1.2, which talked about advanced techniques for writing new\nscenarios, I made a case for using real-world data when working with SBE. Now, in the\nmiddle of this two-chapter journey through the world of scenario outlines, I feel com-\npelled to reiterate.\n Coming out of chapter 4, you know how to use scenario outlines to contain multi-\nple examples in reusable templates that are easy to manage and grow. But I haven’t yet\ntalked about methods for choosing examples to feature in your outlines. So, this chap-\nter focuses on an outside-in method for writing scenario outlines. Chapter 3 defined\noutside-in development as a software development methodology that aims to create suc-\ncessful software through understanding the goals and motivations of stakeholders. In\na nutshell, outside-in outlines focus on taking examples from the outside world (where\nstakeholders operate) into your product. In contrast, the previous chapter only taught\nyou to use scenario outlines as a method to keep your specifications tidy, without the\nneed to interact with anyone to get the job done.\n I’ll also talk about general rules for choosing meaningful examples for scenario\noutlines and how illustrative tests are different from exhaustive tests. As you progress,\nyou’ll learn that some kinds of tests should be performed in different tools than\nCucumber or other Gherkin-compatible test runners.\n",
      "content_length": 3016,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 125,
      "content": "99\nWriting outside-in scenario outlines\n5.1\nExample shopping application\nTo retain a sense of continuity between the two chapters that talk about scenario out-\nlines, chapter 4 and this chapter use the same example: an e-commerce shopping\napplication similar to Amazon.\n As explained in chapter 4, the company began by selling books, but it wants to be\nthe online retailer of books, movies, music, and much more. It started expanding by\nadding products such as e-readers, tablets, and headphones, chosen to fit into the\nstore’s reading landscape. Next, the company entered the entertainment market by\nadding digitally distributed movies to its catalogue. Although there’s still a lot of work\nahead, the business is already diverse—and, fortunately, full of examples to work with. \n5.2\nWriting outside-in scenario outlines\nAs you already know, scenario outlines are templates for similar scenarios. But what\nyou probably don’t know—and what most people in the Gherkin community don’t\ntalk about often—is that the method you’ve been using to create outlines, based on\nmerging redundant scenarios, is reactive instead of proactive. In this section, I’ll show\nyou a proactive way to write outside-in scenario outlines in Gherkin.\nDEFINITION\nOutside-in scenario outline—A scenario outline written directly\nfrom examples gathered during an analysis phase rather than by merging sim-\nilar scenarios\nThe outside-in method consists of two steps:\n1\nCollect real-world examples for your specification in the form of a table.\n2\nWrite the scenario outline based on the table, adjusting the steps and parame-\nters to the data.\nThis approach requires you to analyze examples first and write scenarios later. The\ntable created in step 1 doesn’t even have to be a Gherkin table—it can be a simple\nspreadsheet created in Excel by you and other stakeholders. The merging method\ndescribed in chapter 4, on the other hand, assumes that you evolve scenarios into sce-\nnario outlines only if you notice any redundancy, and the specification becomes too\ndifficult to manage easily. In that sense, the merging method is much more reactive\nthan the outside-in method.\n Generally, I prefer the outside-in method. Scenario outlines made from merging\noften look too programmatic, which makes business people reluctant to read them. I\nthink it has something to do with Don’t Repeat Yourself (DRY), which is the founding\nprinciple of the merging technique. The cost of elegant structure and reduced redun-\ndancy is often sacrificing Gherkin’s natural language and putting too many things into\nbrackets and parameters. In contrast, the outside-in method puts emphasis on a grad-\nual evolution from a non-Gherkin table, which any nontechnical person can read, to a\nGherkin scenario, which business owners don’t have to read if they’ve already read the\nexamples. The evolutionary process often makes the resulting outline look much\nmore natural.\n",
      "content_length": 2912,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 126,
      "content": "100\nCHAPTER 5\nChoosing examples for scenario outlines\n5.2.1\nCollecting examples for outside-in scenario outlines\nTo derive a scenario outline from examples, you first need some examples. And to get\nexamples, you need a new feature to implement. Luckily, your product owners can\nhappily oblige. The company’s current priority is to get more items into the store to\nexpand its marketplace. Negotiating with big publishers and producers has proven to\nbe difficult, so management wants to open the store to individual merchants who can\nsell both new and used items. The merchants will benefit from the company’s\nadvanced shipping infrastructure—and the company will take a cut from their profits.\n After some analysis, sales and marketing have agreed on a pricing model that\nworks according to the following rules:\nMerchants can create accounts and list new items for free.\nThe company takes a cut after an item is successfully sold.\nThe size of that cut depends on the purchaser’s shipping location, because mer-\nchants have to pay for access to the global customer base available thanks to the\ncompany’s shipping infrastructure.\nSo far so good. Let’s settle on the pricing ranges and remake the list into a draft of the\nExamples table. The commission structure was designed based on shipping distances\nfrom the company’s US operations base and infrastructure in each region (see table 5.1).\n \nSuch a table could easily be the result of a conversation between nontechnical stake-\nholders from sales and marketing and the delivery team of programmers, testers, and\ndesigners. No technical skill is required to create or understand it, because no Gher-\nkin is involved yet. If you fear that scenario outlines are too technical, you can keep\nyour examples at the nontechnical level during your specification workshops; there’s\nnothing wrong with that. \nTable 5.1\nDraft of a table with examples\nRegion\nCommission\nNorth America\n10%\nSouth America\n11.4%\nEurope\n12.9%\nAsia\n12.9%\nAfrica\n13.5%\nExercise 1\nRewrite the table of examples in Gherkin.\n",
      "content_length": 2037,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 127,
      "content": "101\nWriting outside-in scenario outlines\n5.2.2\nWriting outside-in scenario outlines from collected examples\nNow that you have the Examples table, you can write the Givens, Whens, and Thens. To\ndo that, you need to find a scenario template that will work well with the structure of\nthe table. For example, can you see that each entry in the <region> column is like a\nquestion and the corresponding <commission> entry is like an answer to that question?\nNorth America? You take 10% of the purchase.\nSouth America? The cut is 11.4%.\nEurope and Asia? That’s 12.9%.\nAfrica? Be ready to give away 13.5%.\nFrom a technical point of view, the questions define the state of the system before you\ndecide how much of a commission you take—and the answers define an outcome based\non the chosen state. In chapter 3, I said that system states are described by Givens and\nthat the outcomes should be written as Thens. So in a way, you already have two-thirds\nof the scenario ready to write down:\nGiven a purchase from <region>\nThen we should take <commission> of the price\nThat certainly looks promising. But because this is a scenario about sellers, not buyers,\nas in the previous scenarios, you can also add another Given specifying that a mer-\nchant is the main actor. Let’s call the smaller shop Quick-Ship:\nGiven a merchant called Quick-Ship\nAnd a purchase from <region>\nThen we should take <commission> of the price\nYou only need one more step, which specifies the main action of the scenario:\nGiven a merchant called Quick-Ship\nAnd a purchase from <region>\nWhen Quick-Ship gets paid for the purchase\nThen we should take <commission> of the price\nThe last thing you need to do is combine the Examples table you prepared earlier with\nthe Given-When-Then and add keywords like Feature and Scenario Outline.\nFeature: Selling items through individual merchants\nScenario Outline: Merchant commissions\nGiven a merchant called Quick-Ship\nAnd a purchase from <region>\nWhen Quick-Ship gets paid for the purchase\nThen we should take <commission> of the price\nExamples:\n| region\n| commission |\n| North America | 10%\n|\n| South America | 11.4%\n|\nListing 5.1\nOutside-in scenario outline derived from examples\n",
      "content_length": 2189,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 128,
      "content": "102\nCHAPTER 5\nChoosing examples for scenario outlines\n| Europe\n| 12.9%\n|\n| Asia\n| 12.9%\n|\n| Africa\n| 13.5%\n|\nAs you can see, with a little creativity, you’ve easily arrived at a complete scenario out-\nline. Choosing examples from which to derive outlines is a separate art, though, and\ncovering it appropriately will require a lot more space.\n Now that you know how to write outside-in scenario outlines, I can talk in detail\nabout collecting great examples. Section 5.3 talks about efficient methods for finding\ngood examples. Section 5.4, on the other hand, is about examples you should avoid. By\nthe end of this chapter, I’ll have talked about every important aspect of writing exem-\nplary scenario outlines, and you’ll be ready to use that knowledge in the real world. \n5.3\nFinding key examples for scenario outlines\nGood outside-in scenario outlines need good examples—that goes without saying.\nThis section will teach you the general rules for choosing good examples. Then it will\nzoom in to explain particular techniques of collecting and refining examples. These\ntechniques will help you\nIdentify important business cases\nMake sure you cover all the relevant examples\nSpot troublesome examples that break often\nSuch techniques are also called testing heuristics.\nDEFINITION\nTesting heuristic—A set of rules of thumb, educated guesses, intui-\ntive judgments, and common sense used by testers to generate new testing ideas\nTesters and developers often aim to prevent or find as many bugs as they can. It’s a\ngreat approach that increases test coverage and makes software more secure and eas-\nier to maintain. Thus, having more tests with more examples is, in general, considered\nto be “better.” The most common indicator that can force delivery teams to simplify\ntheir tests are brittle, overcomplicated tests that cause performance issues. Other than\nthat, the more the better.\n But this isn’t what Gherkin tests look like. As discussed in chapter 1, other indicators\nare in play, like readability and teaching principles. This section provides a simple frame-\nwork you can use to distinguish between exhaustive examples and illustrative examples.\n To understand the difference, imagine that examples in scenario outlines are like\nthe contacts on your phone. An exhaustive list of examples is like a list of all the con-\ntacts you have on your phone. That’s pretty much everyone you know and can think of\nalong with emergency phone numbers in case a tragedy happens. With exhaustive\nexamples, the goal is to test safely by detecting more defects with more tests.\nDEFINITION\nExhaustive testing—An approach in which test coverage is mea-\nsured based on how many checks and examples you have. The more exam-\nples, the better.\n",
      "content_length": 2733,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 129,
      "content": "103\nFinding key examples for scenario outlines\nIllustrative examples, on the other hand, contain one key example from each of your\nimportant social circles: family, friends, work, and so on. A list like that is much\nshorter.\nDEFINITION\nIllustrative testing—An approach in which you use only the most\nrepresentative examples and only as many as needed to understand the pur-\npose of a test\nAn illustrative example of a contact list would be a model simplified to represent the people\nyou hang out with. This simplified model would remove any phone contact that made\nthe list more difficult to understand.\nChoosing good illustrative examples is crucial to doing scenario outlines well. This\nsection expands on the guidelines outlined in the previous paragraphs by discussing\nconcrete candidates for illustrative examples. Reading it should help you come up\nwith a table for any scenario outline more quickly and easily.\n A specification should list only the key representative examples. This will help\nkeep the specification short and easy to understand. The key examples typically\ninclude the following:\nEach important aspect of business functionality—Business users, analysts, and/or\ncustomers typically define these.\nEach important technical edge case—For example, technical boundary conditions.\nDevelopers typically suggest such examples when they’re concerned about func-\ntional gaps or inconsistencies. Business users, analysts, and/or customers define\nthe correct expected behavior.\nEach particularly troublesome area of the expected implementation—For example, cases\nthat caused bugs in the past, and boundary conditions that may not be explicitly\nillustrated by previous examples. Testers typically suggest these, and business\nowners, analysts, and/or customers define the correct behavior.\nThis list of simple guidelines summarizes the most important points discussed in this\nchapter and will guide you when you begin collecting examples for your next require-\nment. The subsections that follow provide more information and insight about these\nareas. First, we’ll look at representative business examples. Then we’ll move on to\nexamples with boundary conditions, ending the section with examples that highlight\nhistorically buggy functionalities.\nExercise 2\nPrepare a list of the most representative examples that will illustrate what your online\nshop is selling to someone who didn’t read this chapter or chapter 4.\n",
      "content_length": 2428,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 130,
      "content": "104\nCHAPTER 5\nChoosing examples for scenario outlines\n5.3.1\nDomain-specific examples\nDomain-specific examples are inputs and outputs that are tied to your product’s busi-\nness domain extremely closely. In fact, you often need to be a domain expert—one\nwho’s extremely knowledgeable about the domain—to recognize and understand\nthese examples at a glance.\n Unfortunately, there are no quick and easy heuristics for spotting and managing\ndomain-specific examples, because each business domain is unique. But there’s some-\nthing else I want to show to you.\n An early reviewer of the book argued that a section about domain-specific exam-\nples seems a bit redundant, because unspecific examples are usually standardized and\neasy to understand. There’s little value in documenting features such as restoring a\npassword, changing basic settings, and so on—with some exceptions, such as generic\nexamples that cause regular bugs. I agree—but I also want to argue that even the sim-\nplest functionality can have impactful domain-specific examples that sometimes may\nlead to discovering new, unexpected features. It’s a fact that’s overlooked by many\ndevelopers, testers, designers, and managers.\n The most domain-specific attribute for any e-commerce application is usually the\nprice. Every e-commerce shop should experiment with its prices on a daily basis to sub-\ntly encourage customers to buy more. Many other factors can also influence the price\nof any item in the store: daily deals, coupons, fire sales, bundles, free shipping, and so\non. That’s a lot to convey in a single specification; but at this point in the chapter, you\nhave all the tools you need to make that happen, such as parameters and multiple\ntables. Let’s look at the result.\nFeature: Pricing\nScenario Outline: Discounts\nGiven items like <items> costing <price> in John's cart\nAnd a <discount> discount\nWhen John proceeds to checkout\nThen he should only pay <final> for the items in his cart\nExamples: Daily deals\nDaily deals are always 17% discounts.\n| items\n| price\n| discount | final\n|\n| \"Writing Great Specifications\" | $44.99 | 17%\n| $37.34 |\nExamples: Coupons\nThere are five different types of coupons available.\n| items\n| price\n| discount | final\n|\n| \"Writing Great Specifications\" | $44.99 | 5%\n| $42.74 |\n| \"Writing Great Specifications\" | $44.99 | 15%\n| $38.24 |\n| \"Writing Great Specifications\" | $44.99 | 30%\n| $31.49 |\n| \"Writing Great Specifications\" | $44.99 | 50%\n| $22.49 |\n| \"Writing Great Specifications\" | $44.99 | 75%\n| $11.24 |\nListing 5.2\n[GOOD] Specification full of domain-specific examples\n",
      "content_length": 2580,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 131,
      "content": "105\nFinding key examples for scenario outlines\nExamples: Bundles\nWe offer \"buy two, pay for one\" bundles.\n| items\n| price\n| discount | final\n|\n| \"Specification by Example\" bundle | $44.99 | 50%\n| $22.49 |\nThis is a good specification. The reader can easily see that there are three types of dis-\ncounts and identify the discounted prices. But you can also do something more\ndomain-specific here.\n Your superior shipping infrastructure lets you sell and ship items more cheaply\nthan your competitors. So, thanks to your margins, you can sometimes sacrifice short-\nterm profits from single transactions for increased long-term volume. For example,\nresearch shows that when given various price options, 57% of consumers choose\nround, whole-dollar amounts ending in zero. Because of the straightforward nature of\nelectronic payments, the most plausible explanation is that people prefer round\nprices. When a person buys a discounted book from your store for $23.23, the differ-\nence between that price and, say, $23.00 isn’t much. So maybe you should discount\nprices even further, to whole-dollar amounts, to encourage more customers to buy\nand thus increase sales. In a high-volume store like this one that processes thousands\nof transactions each day, 23 cents doesn’t make much of a difference. But if you could\npersuade an average client to buy two items instead of one during the same shopping\nsession, that would result in a massive increase in revenue.\nScenario Outline: Discounts\n57 percent of consumers pick round, whole-dollar amounts\nending in zero.\nGiven items like <items> costing <price> in John's cart\nAnd a <discount> discount\nWhen John proceeds to checkout\nThen the order should technically be discounted to <discounted>\nBut the final price should be discounted even further to <final>\nExamples:\n| items\n| price\n| discount | discounted | final\n|\n| \"Lord of the Rings\" | $44.99 | 17%\n| $37.34\n| $37.00 |\n| [...]\n| [...]\n| [...]\n| [...]\n| [...]\n|\nListing 5.3\n[GOOD] More complex discounting scenario\nUsing table briefs\nListing 5.5 is the first specification in the book to use table briefs. Table briefs are\nsimilar to specification briefs and scenario briefs, which you’ve been using through-\nout the book. They’re free-flowing text sections between the table and the Examples\nkeyword. You can use table briefs to expand on the context of the examples or pro-\nvide additional information.\n",
      "content_length": 2401,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 132,
      "content": "106\nCHAPTER 5\nChoosing examples for scenario outlines\nThis new discounting approach might be interpreted as overengineering, but my\npoint is that even the simplest features have indiscernible, domain-specific quirks that\ncan and should be covered by your executable specifications. You don’t even have to\ndig that deep.\n Another complex domain-specific example is a registration process in a custom\nemployee-satisfaction application built for a company with thousands of employees. In\naddition to standard information like username, password, and email, you’ll need to\ndeal with a lot of inputs specific to the company. For instance, you’ll have to add dif-\nferent departments, like Software Engineering and Sales; and branches, such as Los\nAngeles and New York. The onboarding flow for the app may look different for a soft-\nware engineer from Los Angeles than for a salesperson from New York: if each city has\na different satisfaction program, it will be pointless to ask New York employees\nwhether they’re interested in wellness programs that are only available in Los Angeles.\nTo create a great onboarding experience, you’ll end up with a complex registration\nform that needs to change and evolve for every employee. As an analyst, I like to look\nfor domain-specific examples in processes that most people would consider standard,\nand I advise you to do the same in order to create a user experience that feels unique\nand tailored to your business domain.\n If an example is highly domain specific, having it in an executable specification is\nof great help to the delivery team. The team can trust that the example is tested and\nup to date. They can even add more detail over time if they need to. And every time\nthey implement new functionality, automated tests will remind them not to break\nthese important examples. \n5.3.2\nCounterexamples\nBalancing examples with counterexamples is another way to fill the Examples table in\nscenario outlines. By a counterexample, I mean a different combination of inputs, yield-\ning another extreme outcome, in the same workflow. To see what I mean by extreme,\nlet’s talk briefly about a simple free-shipping example.\n Let’s say your online shopping application offers free shipping for orders that are\nmore expensive than the average customer’s average order. This is a popular e-com-\nmerce incentive to encourage customers to order more at a single time and simplify\npayment processing. You could illustrate the free-shipping behavior with this simple\nscenario.\nFeature: Free shipping\nScenario: Orders over $100 should be shipped for free\nGiven items worth $100 in John's cart\nWhen John proceeds to checkout\nThen he should be offered free shipping\nListing 5.4\n[GOOD] Simple free-shipping example\n",
      "content_length": 2738,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 133,
      "content": "107\nFinding key examples for scenario outlines\nIt’s a good starting point, but it’s simplistic. With a scenario like this one, you only\nknow that a $100 purchase is in the range eligible for free shipping. You know nothing\nabout less- or more-expensive purchases. You don’t even know whether this is the low-\nest price point eligible for free shipping. In theory, the free-shipping threshold will be\nmentioned in the name of the scenario. But relying on that would mean assuming\nthat all the people who need to see the scenario will read it from cover to cover. It’s a\nrisky assumption; most business people, programmers, designers, and testers will only\nscan text, because they’re busy, on deadline, and looking for quick answers.\n To improve this scenario, look for a visual way to highlight the contrast between\norders that qualify for free shipping and orders that don’t. A scenario outline can do\nexactly that.\nFeature: Free shipping\nScenario Outline: Orders over $100 should be shipped for free\nGiven items worth <purchase> in John's cart\nWhen John proceeds to checkout\nThen he should be offered <shipping>\nExamples:\n| purchase | shipping\n|\n| $99\n| $5 shipping\n|\n| $100\n| free shipping |\nYou could even throw in a third example showing a $101 purchase being offered free\nshipping. You’ll see why and when a similar example can be useful in section 5.4.4,\nwhere I talk about classes of equivalence and the Goldilocks principle.\nCounterexamples support the delivery team by drawing clearer boundaries between\ndifferent combinations of inputs and outcomes. They can be used to illustrate edge\ncases, show contrasting areas of implementation, and define blank-slate states and\nextreme conditions. Readers benefit from counterexamples the same way pedestrians\nbenefit from red and green lights: they know when they have a clear go and when they\nmust stop and look around. It’s a simple but effective heuristic. \n5.3.3\nExploratory outcomes\nBalancing examples with counterexamples isn’t the only heuristic you can use to your\nadvantage. I like to say that most engineers, analysts, designers, and testers are forced\nListing 5.5\n[BETTER] Example contrasted with a counterexample\nExercise 3\nWhen an item that’s on sale is featured as a daily deal, what will a table with an exam-\nple and a counterexample look like? Write a scenario outline with an answer. You can\nuse the discounts from listing 5.6.\n",
      "content_length": 2398,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 134,
      "content": "108\nCHAPTER 5\nChoosing examples for scenario outlines\nto be optimists due to the chaotic, uncertain nature of the software development pro-\ncess. If they truly care about a meaningful result, the journey requires at least some\ndegree of optimism.\n This optimism can blind you to less obvious or less probable examples and cause\nyou to focus on positive outcomes only. Chapter 2 mentioned that testers often call\nscenarios with positive outcomes happy paths and that scenario outlines can account\nfor a multitude of other paths including angry paths, scary paths, embarrassing paths,\nand forgetful paths. This chapter expands on the topic of these exploratory outcomes.\n In general, exploratory outcomes pursue possible unhappy paths, leading to new test-\ning ideas. They belong mainly to the analysis phase and can be used to stimulate\ngroup thinking and brainstorming during specification workshops or when a single\nperson is analyzing a requirement.\n I found the “go beyond the happy path” heuristic in the excellent book Fifty Quick\nIdeas to Improve Your Tests by Gojko Adžic´, David Evans, and Tom Roden (Neuri Con-\nsulting, 2015). On a daily basis, you can use the following subsections as a checklist to\ngenerate new testing ideas. These questions can guide your conversations with stake-\nholders as you mine them for possible input.\nTHE HAPPY PATH\nFind the main success scenario, usually describing the most straightforward example.\nWhat happens if everything goes all right? Should anyone be rewarded? What changes\nshould be made in the system? Should the successful result be logged anywhere?\nTHE ANGRY PATH\nLook for the main failure scenario: anything that will make the application throw\nerrors, quit, or break. Maybe the angry path is a counterexample for the happy path.\nOr perhaps it’s the most frustrating scenario imaginable, where only one thing\ngoes wrong, but it breaks the entire process. An example could be a server error that\nappears when the user is completing a form six screens long and can’t save their\nprogress. \nTHE SCARY PATH\nThink about the areas of highest risk. I usually try to imagine misunderstandings and\nerrors that could get me or the end user fired. One of my projects dealt with sending\na lot of paid text messages automatically. I was always scared that a bug would send\nthousands of messages at once that I would have to pay for. What failure scenarios and\ncode would I, as the developer of the project, devise to relieve myself of my fear?\nTHE EMBARRASSING PATH\nWrite down all the things that, if they broke, would cause huge embarrassment on all\nfronts. Imagine you’re the CEO, and you’re giving a demo in front of investors or\nimportant customers. You’re trying to create a new account, and you can’t. Or you’re\ntrying to order something, and the payment can’t be processed. “Maybe next time,”\nyou hear. Can you think of an example that would create a similar situation?\n",
      "content_length": 2917,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 135,
      "content": "109\nFinding key examples for scenario outlines\nTHE DELINQUENT PATH\nShould the functionality be secured in any special way? Who is authorized to use it?\nAre any special permissions needed? Does any third-party regulatory body require\nlegal compliance? If anyone saw the data produced by this functionality, would some-\none be in trouble?\nTHE STRESSFUL PATH\nIf scale, speed, and performance are important business aspects of the function or\ncomponent you have to work with, give your projections for future changes of busi-\nness volume. For example, a one-year business report could contain so much data that\nit might be impossible to download on the fly. Is there an example that would stretch\nyour system to its limits?\nNOTE\nScale, speed, and performance are nonfunctional requirements, and it\nisn’t obvious whether those are a good fit for Gherkin and SBE. We’ll get back\nto this issue in chapter 8. \nTHE GREEDY PATH\nSelect everything, tick every box, opt into every option, and order lots of everything.\nSometimes, following the greedy path results in examples that apply to power users—\nexcessive users who will try to use your application to the fullest. But other times, the\ngreedy path will remind you about behaviors of casual users, such as those who wait\nuntil the last day of the last deadline and suddenly want your application to do 60\nthings at once. Will it be ready? Or will it break?\nTHE FORGETFUL PATH\nFill up all the memory available in the system, and check what happens. Leave a shop-\nping cart full of items, but never finish the order. Be an admin user who forgets to\napprove new accounts. Nobody has a perfect memory. Can you find any forgetful\nexamples and deploy appropriate countermeasures?\nTHE DESOLATE PATH\nWhat does your functionality look like before the user uses it for the first time? What\nhappens when users don’t want to provide required input? What if they can’t? They\nmay not have the necessary information yet. On the desolate path, provide your fea-\nture with examples of nothingness. Give too little information. Don’t upload enough\nphotos. Write nothing. \nTHE INDECISIVE PATH\nI’m an indecisive user every time I have to publish anything. I check all the tabs in the\neditor, rewrite all the headlines multiple times, add and remove tags, and reposition\nimages. Are you sure your feature will work correctly with similar users?\nEXAMPLE EXPLORATORY OUTCOMES\nIf you were to apply the exploratory-outcomes method to your e-commerce shopping\napplication, you might use it to build a scenario outline for checking out. The check-\nout process is a good candidate because it involves many moving parts—payments,\n",
      "content_length": 2644,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 136,
      "content": "110\nCHAPTER 5\nChoosing examples for scenario outlines\ncart management, and shipping—and each of these parts can break at any moment,\nyielding a different outcome.\nFeature: Checkout\nScenario Outline: Processing purchases at checkout\nGiven <prerequisite>\nWhen checkout proceeds\nThen the contents of the cart should be <bought?>\nAnd the credit card should be <charged?> for it\nExamples: The happy path\n| prerequisite\n| bought? | charged? |\n| John adds an item to the cart | bought\n| charged\n|\nExamples: The angry path\n| prerequisite\n| bought?\n| charged?\n|\n| the item is in stock\n| bought\n| charged\n|\n| the item goes out of stock | not bought | not charged |\nExamples: The embarrassing path\n| prerequisite\n| bought?\n| charged?\n|\n| John can pay\n| bought\n| charged\n|\n| John can't pay | not bought | not charged |\nExamples: The delinquent path\n| prerequisite\n| bought?\n| charged?\n|\n| minors try to buy an R rated movie | not bought | not charged |\n| adults try to buy an R rated movie | bought\n| charged\n|\nTIP\nYou may have noticed that listing 5.6 features a <prerequisite> param-\neter that’s substituted for an entire Given step. This is possible because test\nrunners go through the parameters before execution and literally generate\nnew scenarios out of the scenario outlines—and only then are the scenarios\nexecuted. In this case, a test runner like Cucumber will generate as many\nGivens as there are examples in the table for the <prerequisite> parameter,\nmaking the outline possible.\nTo make things clear at a glance, each table has examples that describe only one busi-\nness rule. And, as discussed earlier, each table has both an example and a correspond-\ning counterexample to clearly show boundaries.\n You could also use techniques like outcome questioning and context questioning,\nwhich you learned about in chapter 3. That way, you could see whether any of the tables\ncould create more standalone examples, by asking, “Is there another outcome that also\nmatters?” or “Is there a context that, for the same event, produces a different outcome?”\nTIP\nExploring outcomes can help elicit better requirements, too. Asking for\nalternative examples can make whoever is asking for a feature think twice\nabout whether the proposed solution is the best one. And you don’t even\nhave to write any Gherkin to ask this question early in the process.\nListing 5.6\n[GOOD] Generating diverse exploratory outcomes\nMain success\nscenario\nExamples \nthat may \ncause errors\nEmbarrassing\nscenarios that\ncan’t happen if\nyou want to\nmake money\nExamples \nrequiring legal \ncompliance\n",
      "content_length": 2558,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 137,
      "content": "111\nFinding key examples for scenario outlines\nExploratory outcomes help the delivery team view the feature they’re working with\nfrom multiple angles. They can also help discover troublesome edge cases. But not all\noutcomes have to generate meaningful corresponding examples. It’s valuable to go\nthrough the list with most new features; such a checklist can come in handy in stress-\nful, time-sensitive situations. In The Checklist Manifesto (Metropolitan Books, 2009),\nAtul Gawande talks about the risks of routine and repetitive tasks in a complex envi-\nronment, where experts are up against the deficits of human memory and attention.\nUnder pressure, people tend to skip some steps. A checklist with possible testing\nideas, ingrained in your development process, can help you avoid that and can result\nin better coverage. \n5.3.4\nBoomerangs\nBoomerangs are functionalities that keep breaking every now and then, returning from\nproduction to development despite your team’s best efforts to fix the broken code for\ngood. They negatively affect budgets, deadlines, and morale, because the team wastes\ntime returning to the same functionality while other features have to wait. Boomer-\nangs are also important to identify and contain because they clearly highlight areas\nwhere you lack domain knowledge and where there are communication issues. It’s not\nas easy to prevent boomerangs as is it to identify them, but executable specifications\ncan help you decrease the risk of a boomerang appearing.\n Boomerangs can appear in the following situations:\nFunctionality deals with complex domain rules that are difficult for industry\noutsiders to understand.\nThe team didn’t identify a major stakeholder who had a say in the decision-\nmaking process.\nThe team underestimated such a stakeholder’s requests and didn’t satisfy the\nstakeholder.\nThe team allowed for a bus factor of one. A bus factor is the number of people\nwho need to get hit by a bus for the project or team to stop functioning. There-\nfore, a bus factor of one is the riskiest. If a feature that used to be fine becomes\na boomerang only after somebody’s departure, it means some knowledge disap-\npeared along with the person.\nCustomers aren’t satisfied with the solution, even though it was implemented\nexactly as it was designed.\nExecutable specifications with examples can help you reduce the likelihood of most of\nthese issues.\n Some boomerangs can be prevented before they happen. For instance, collecting\nexamples directly from end users and customers can increase the probability that your\nproduct will answer real customer needs. Examples can also help you understand\ncomplicated domain processes, as you saw in previous chapters—in chapter 3, for\nexample, which talked about outside-in development. Other boomerangs can’t be\n",
      "content_length": 2795,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 138,
      "content": "112\nCHAPTER 5\nChoosing examples for scenario outlines\nprevented before they happen—but executable specifications can still help you make\nsure they won’t reappear.\n Let’s focus again on the scenario outline for free shipping. I used it to explain the\nrule for using counterexamples in section 5.1.2.\nFeature: Free shipping\nScenario Outline: Orders over $100 should be shipped for free\nGiven items worth <purchase> in John's cart\nWhen John proceeds to checkout\nThen he should be offered <shipping>\nExamples:\n| purchase | shipping\n|\n| $99\n| $5 shipping\n|\n| $100\n| free shipping |\nAt the time you wrote it, this was a good outline: simple to grasp and self-explanatory,\nwith two contrasting examples. But as soon as the coding was finished and the func-\ntionality hit production, the delivery team learned that they forgot about a simple yet\ncrucial example.\n After the release, it turned out that free shipping is location-restricted to custom-\ners based in the United States. Business stakeholders said the company couldn’t afford\nto offer free shipping to other countries. You rework the scenario outline as follows, to\nreflect that decision.\nFeature: Free shipping\nScenario Outline: Orders over $100 should be shipped for free\nGiven items worth <purchase> in John's cart\nAnd shipment to <country>\nWhen John proceeds to checkout\nThen he should be offered <shipping>\nExamples: Restrict free shipping to the USA\n| country | purchase | shipping\n|\n| US\n| $99\n| $5 shipping\n|\n| US\n| $100\n| free shipping |\nExamples: Other countries don't have free shipping\n| country | purchase | shipping\n|\n| Canada\n| $99\n| $5 shipping\n|\n| Canada\n| $100\n| $5 shipping\n|\n| Poland\n| $99\n| $5 shipping\n|\n| Poland\n| $100\n| $5 shipping\n|\n| Egypt\n| $99\n| $5 shipping\n|\n| Egypt\n| $100\n| $5 shipping\n|\n| Japan\n| $99\n| $5 shipping\n|\n| Japan\n| $100\n| $5 shipping\n|\nListing 5.7\n[GOOD] Scenario outline for free shipping\nListing 5.8\n[BETTER] Reworked boomerang scenario outline\n",
      "content_length": 1944,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 139,
      "content": "113\nFinding key examples for scenario outlines\nSometimes, boomerangs return multiple times. The more often they return, the more\nprominence they deserve—more tests and more examples, which then become docu-\nmentation. Chapter 1 talked about how a specification suite can become a living docu-\nmentation system and a single source of truth. Being a single source of truth means that\nwhen stakeholders prepare to implement a new user story or repair a bug fix, they can\nuse the suite to read relevant scenarios and check important examples. Relying on long-\nterm, written knowledge instead of fallible human memory can help you spot inconsis-\ntencies and troublesome areas sooner and more easily. That’s why boomerangs, should\nthey appear, deserve a prominent place in your scenario outlines. We’ll return to the\ntopic of boomerangs as part of a living documentation system in chapter 7. \nAnalyzing boomerangs in depth\nSpotting, analyzing, and fixing boomerangs is extremely important when it comes to\neliciting better requirements. One technique you can use to understand the root\ncauses of misunderstood requirements is the Five Whys technique.\nFive Whys is an iterative interrogative technique used to explore the cause-and-effect\nrelationships underlying a particular problem. The primary goal of the technique is to\ndetermine the root cause of a defect or problem by repeating the question “Why?”\nEach answer suggests the next question.\nHere’s a classic example of using Five Whys to analyze a problem. The issue is that\na vehicle won’t start:\n1 Why? The battery is dead.\n2 Why? The alternator isn’t functioning.\n3 Why? The alternator belt has broken.\n4 Why? The alternator belt was well beyond its useful service life and not\nreplaced.\n5 Why? The vehicle was not maintained according to the recommended ser-\nvice schedule.\nAs you can see, this technique, even though it’s simple, can be used to deeply inves-\ntigate the problems that cause boomerangs.\nSome analysts use the Five Whys technique not only to prevent defects, but also to\nelicit new requirements by asking why a requested feature is needed. Asking why\nsomething is needed can sound like a challenge and may put the other person in a\ndefensive position, especially in larger organizations; instead, you can ask for a high-\nlevel example of how a feature would be useful, to start a discussion without chal-\nlenging authority.\nFive Whys was first developed by Toyota Motor Corporation. If you’re interested, you\ncan find more about it in most teaching resources about lean methodologies.\n",
      "content_length": 2553,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 140,
      "content": "114\nCHAPTER 5\nChoosing examples for scenario outlines\n5.4\nAvoiding scenario outline anti-patterns\nScenario outlines are like programs. They can help you automate. But one of the basic\nrules of technology is that automation, when applied to an efficient operation, will\nmagnify the efficiency—but automation applied to an inefficient operation will mag-\nnify the inefficiency. So scenario outlines can hurt you, too, if you aren’t careful. This\nsection discusses examples that you shouldn’t test with Gherkin; automating them\nwould only magnify the inefficiency of the entire specification suite.\n5.4.1\nTypical data validations\nInputs in your application need to be validated against model rules, database-consis-\ntency constraints, I/O rules, and other parameters that depend on the type of data\nprovided. These rules don’t belong to your domain only; they’re general data-valida-\ntion rules. Should you include examples like these in your specifications?\n For example, when dealing with numbers, should you write automated tests for\naccepting numerical formats such as 1,234,567, 1.234.567, 1234567, and 1 234\n567? Or, with strings, should you deal with entering accented characters, like ð? Or,\nwith dates, should you add examples of invalid dates, such as February 30 and Sep-\ntember 31?\n Executable specifications are only one part of the entire test suite a software appli-\ncation can have. The main role of scenarios is to provide a communication framework\nfor talking with stakeholders that lets you build a living documentation system. You\nshouldn’t try to use a specification suite to replace other kinds of tests—if you do, it\nwill quickly become cluttered. Executable specifications should only optimize for\nthree simple things: being clear, self-explanatory, and readable for both technical and\nnontechnical team members.\n Usually, data validations are too low-level to satisfy these three criteria. You can eas-\nily validate this statement by trying to get business stakeholders to read scenarios with\ntechnical examples. Decision makers don’t have time to read about strings or date val-\nidations. They want to read about their businesses. They want to make sure the scenar-\nios cover cases needed by their sales teams to satisfy contracts that they want to sign\nwith clients. \n5.4.2\nSimple combinatorial outcomes\nSometimes a functionality has to accept many different inputs that generate hundreds\nof outcomes. If you try to write a scenario to cover all the inputs and outputs, the\nExamples table will grow so large that it will be unreadable. Let’s think about what to\ndo in such a situation. Do you use all the examples and accept a scenario that’s hard to\nread, or do you keep the Examples table short and possibly leave an important edge\ncase without a test?\n \n \n",
      "content_length": 2783,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 141,
      "content": "115\nAvoiding scenario outline anti-patterns\n For example, suppose your website has a complex filtering system to help custom-\ners find new products more quickly. The shopping search engine has to deal with\nmany attributes, such as keywords, author, title, ISBN, publisher, subject, format, lan-\nguage, and publication date—and these are just for books. Your shop also sells video\ngames, groceries, gift cards, pet supplies, and so on, and each of these categories has\nits own filtering options.\n Imagine a scenario outline like this (I intentionally left the Examples table empty):\nFeature: Search\nScenario Outline: Filtering\nGiven books:\n| title\n| genre\n| author\n| release |\n| \"Sorrow\"\n| adventure | Damion Melville | 1994\n|\n| \"Setup\"\n| humor\n| Beyhan Topuz\n| 2000\n|\n| \"Recruits\" | adventure | Fionna Walker\n| 2005\n|\n| \"Aliens\"\n| sci-fi\n| Phan Uoc\n| 2013\n|\n| \"Invent\"\n| horror\n| Stela Vánová\n| 1988\n|\nWhen Simona searches for <filter>\nAnd she wants to find <value>\nThen she should see <results>\nExamples:\n| filter | value | results |\n| [...]\n| [...] | [...]\n|\nHow many different combinations could you test here? How many would be meaning-\nful? How many would you be including in the scenario just in case?\n In this example, the business domain is simple. But the temptation to write exam-\nples exhaustively instead of illustratively increases when even the simple outcomes for a\nproduct are complicated—for example, when the team is new to the domain. Self\ndoubt leads to scenarios with too many examples—examples that are too simple and\nboring for the business stakeholders and domain experts to read, but, at the same\ntime, are too confusing and difficult for the delivery team to maintain. In my experi-\nence, this is the number-one reason teams become discouraged with SBE. Instead, you\ncan reap the benefits of an approach called pairwise testing.\nDEFINITION\nPairwise testing—A testing heuristic based on the observation that\nmost faults are caused by a combination of at most two factors. Pairwise exam-\nples are shorter than exhaustive ones, but they can still be effective in finding\ndefects.\nPairwise testing is an effective heuristic that should let you pay attention to both\nreadability and preventing defects. Let’s fill the Examples table with pairs to see if\nthat’s true.\n",
      "content_length": 2288,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 142,
      "content": "116\nCHAPTER 5\nChoosing examples for scenario outlines\n \nFeature: Search\nScenario Outline: Filtering\nGiven books:\n| title\n| genre\n| author\n| release |\n| \"Sorrow\"\n| adventure | Damion Melville | 1994\n|\n| \"Setup\"\n| humor\n| Beyhan Topuz\n| 2000\n|\n| \"Recruits\" | adventure | Fionna Walker\n| 2005\n|\n| \"Aliens\"\n| sci-fi\n| Phan Uoc\n| 2013\n|\n| \"Invent\"\n| horror\n| Stela Vánová\n| 1988\n|\nWhen Simona searches for <filter>\nAnd she wants to find <value>\nThen she should see <results>\nExamples:\n| filter\n| value\n| results\n|\n| title\n| \"Lord of the Rings\"\n| no results\n|\n| title\n| \"Setup\" or \"Invent\"\n| \"Setup\", \"Invent\"\n|\n| genre\n| adventure\n| \"Sorrow\", \"Recruits\" |\n| author and release | Phan Uoc, 2013\n| \"Aliens\"\n|\n| author and release | Phan Uoc, 1994\n| no results\n|\nEach example tests a different combination of two factors:\nB Combines searching by a title and an empty set of results to test whether it’s possi-\nble to create a failing query\nC Combines two alternative titles to check whether advanced OR filtering works\nD Combines two books belonging to the same genre to test whether the genre filter\nwill return all possible results\nE Combines an existing author and a correct release year to make sure filtering by\ntwo distinct attributes is possible\nF Combines an existing author with an incorrect release year to check whether the\nadvanced logic behind the two-attribute filter yields correct results\nIf you think there may be more possible edge cases, you’re right. But remember that\nthe process of collecting examples and refining executable specifications is continu-\nous. It starts before anyone writes the first line of code, and it doesn’t end with\nproduction deployment. I guarantee that this table will change—growing or\nListing 5.9\n[GOOD] Using pairs of factors to generate outcomes\nB\nProvides a title.\nThe book\ndoesn’t exist.\nC\nProvides\ntwo titles.\nD\nProvides a genre. \nThe test should \nyield two results.\nE\nProvides a release \nyear and author.\nF\nProvides an author. The\nrelease year is false.\nExercise 4\nPrepare a list of pairwise examples for another search scenario in which Simona\nlooks for a new smartphone.\n",
      "content_length": 2119,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 143,
      "content": "117\nAvoiding scenario outline anti-patterns\nshrinking—throughout the product’s lifetime. You don’t have to get it all right on the\nfirst try; you only have to do enough to begin writing code. You can always improve the\nmodel later. \n5.4.3\nDatabase models\nA database model is a type of data model that determines the logical structure of a data-\nbase. It can be a representation of all the attributes you need to store in the database\nto allow your application to persist data. For example, when a new user signs up, you\nneed to store their username and password, but also their last sign-in date, number of\nsign-ins, and their IPs. Databases like Postgres and MySQL store data in tables, just as\nGherkin does, so some programmers and testers are tempted by their old habits to\nwrite Gherkin just like SQL.\n To see an example of such an approach, let’s look at a feature file for a standard\nreviewing functionality. Every time a customer buys something, they can rate the item\nafterward, which can help you promote popular, high-quality items on the website and\nremove bad items from the store. When an item gets bad reviews, you should ask\nwhether buyers want to tell you how you could improve their experience in the future.\nAnd if an item is rated well, you should try to persuade happy customers to recom-\nmend it to their friends.\n Here’s a scenario showing what happens when the author doesn’t care about mak-\ning the specification readable for nontechnical readers.\nFeature: Reviews\nBackground:\nGiven customers:\n| id | name\n| email\n|\n| 1\n| Dominic Advice | doad@exmaple.com |\nAnd items:\n| id | name\n| price\n| type |\n| 1\n| Writing Great Specifications | $44.99 | book |\nAnd publishers:\n| id | name\n|\n| 1\n| Manning Publications |\nAnd publications:\n| publisher_id | item_id |\n| 1\n| 1\n|\nAnd authors:\n| id | name\n|\n| 1\n| Kamil Nicieja |\nAnd book authored by:\n| author_id | item_id |\n| 1\n| 1\n|\nListing 5.10\n[BAD] Gherkin tables that look like SQL\nBecause both Postgres and MySQL \nare RDBMS databases, based on the \nrelational model of data, you need \nto explicitly define relationships \nbetween the book and its author, \nand between the book and its \npublisher, by linking item_id and \nauthor_id or publisher_id.\nPublishers and authors are in the specification only because \nthey’re required to save a book in the database; without them, \nthe book object wouldn’t pass necessary internal validations.\n",
      "content_length": 2401,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 144,
      "content": "118\nCHAPTER 5\nChoosing examples for scenario outlines\nScenario Outline: Reviewing sold items by customers\nGiven customer <user_id> bought item <item_id>\nWhen the customer gives the item <rating> stars\nThen we should <outcome>\nExamples:\n| item_id | user_id | rating | outcome\n|\n| 1\n| 1\n| 0\n| ask_how_can_we_improve |\n| 1\n| 1\n| 1\n| ask_how_can_we_improve |\n| 1\n| 1\n| 2\n| ask_how_can_we_improve |\n| 1\n| 1\n| 3\n| do_nothing\n|\n| 1\n| 1\n| 4\n| ask_for_recommendation |\n| 1\n| 1\n| 5\n| ask_for_recommendation |\nThere are two major problems with this specification:\nIt’s full of technicalities that aren’t in any way related to what is being\nspecified.\nInstead of specifying the business context, it’s mostly concerned with setting up\nthe database in a way that won’t break the test suite on execution.\nYou can see that many lines of the specification aren’t necessarily connected to the\ntopic of reviews. For example, are the price and type of a reviewed item required to\nunderstand how reviews work? They’re important if you want to talk about market-\ning—but not from an implementation perspective. All these lines are probably\nincluded because the author decided to reuse steps written for another scenario\nwhere prices, authors, and publishers were relevant. But that’s just lazy writing.\n Now, look at the Background section at the beginning of the specification. These\ntables are included only to create required relationships between database objects.\nBecause the author chose a book as the item that’s being reviewed, you’re forced to\nread about its publisher and author. You can only guess that without the publisher and\nthe author, the book object couldn’t be saved in the database, making the tests unable\nto proceed. Instead of solving the problem in the automation layer, the author\ndecided to write steps that would make it easy to manipulate the testing code directly\nfrom the specification layer.\n In general, technical stuff like managing database models should always be han-\ndled in the automation layer. Sometimes, though, delivery teams forget about the\nneed for a healthy balance between the specification layer and the automation layer—\nthey decide to handle database modeling in the specification layer to reduce redun-\ndancy and simplify step definitions.\n Here’s how to write the previous specification if you handle technicalities in the\nautomation layer.\n",
      "content_length": 2373,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 145,
      "content": "119\nAvoiding scenario outline anti-patterns\n \nFeature: Reviews\nScenario Outline: Reviewing items by customers\nGiven Dominic bought \"Writing Great Specifications\"\nWhen he rates it with <rating> stars\nThen we should <ask> for <feedback>\nExamples:\n| rating | ask\n| feedback\n|\n| 0\n| ask\n| tips to make it better |\n| 1\n| ask\n| tips to make it better |\n| 2\n| ask\n| tips to make it better |\n| 3\n| don't ask | no feedback\n|\n| 4\n| ask\n| a recommendation\n|\n| 5\n| ask\n| a recommendation\n|\nThe specification is much easier to read, you got rid of the artificial Background tables,\nand readers can easily see that the only thing being tested in this simple scenario out-\nline is the numerical scale of ratings that need to be implemented in the system.\nWARNING\nWriting outlines that look like SQL tables is an anti-pattern. As a\nrule, you should always solve technical difficulties in the automation layer,\ninstead of trying to solve them in the specification layer of your specifications.\nGherkin is, by definition, a business-readable, domain-specific language. There’s nothing\nbusiness-y, readable, or domain-specific about database rows. I think the confusion\ncomes from the fact that some people don’t treat Gherkin as a wrapper for automat-\ning conversations about requirements. Instead, they want to use it as a wrapper that\nmakes writing tests easier, without having to write new testing code all the time. This\nmay sound like a strong opinion, but I think this is a lazy, technology-oriented way to\nuse executable specifications that should be—at all costs—avoided. \n5.4.4\nClasses of equivalence\nClasses of equivalence are examples such as “X is less than Y,” as in the following step:\nGiven a user who is less than 18 years old\nWhen the user tries to buy a violent movie or game\nThen the purchase should be blocked\nA step like this can be used, for example, to make sure young users can’t purchase vio-\nlent movies or games. I don’t recommend using classes of equivalence, though,\nbecause they can create an illusion of shared understanding, which is the gravest mis-\ntake an executable specification can make. Every class of equivalence is, in fact, a set,\nand mental operations on sets don’t come naturally to most people. If you talk about\nsets expressed as domain-specific examples, the difficulty is twofold. When reading\nsuch a specification, your short-term memory has to maintain both the boundaries of\nListing 5.11\n[GOOD] Scenario outline without unnecessary technical detail\nClass of \nequivalence\n",
      "content_length": 2504,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 146,
      "content": "120\nCHAPTER 5\nChoosing examples for scenario outlines\nthe set and the new business domain concepts that the specification is trying to teach\nyou. In such circumstances, mistakes come easily.\n Examples that use classes of equivalence should be rewritten using a testing heuris-\ntic called the Goldilocks principle. This principle is derived from the children’s story\n“The Three Bears,” in which a little girl named Goldilocks finds a house inhabited by\nthree bears. Each bear has its own food and bed. After testing all three choices of both\nitems, Goldilocks determines that the first is to one extreme—too hot or too large.\nThe second is to the opposite extreme—too cold or too small. But the third, she\ndetermines, is “just right.”\nDEFINITION\nGoldilocks principle—A principle that requires at least three testing\nsamples whenever possible. The samples should include an average (or\nacceptable) example and two or more extreme examples (edge cases).\nThe Goldilocks principle is a good heuristic to convey classes of equivalence in sce-\nnario outlines. You can even use it if you don’t have three clear-cut boundary exam-\nples. For example, you could rewrite the previous snippet something like this:\nGiven a user who is <age> years old\nWhen the user tries to buy a violent movie or game\nThen the purchase should be <blocked>\nExamples:\n| age | blocked\n|\n| 17\n| blocked\n|\n| 18\n| not blocked |\n| 19\n| not blocked |\nThree examples illustrate the rule. The middle example in the table is the boundary\ncondition: the age of majority. The first example is there to illustrate that 18 isn’t the\nonly age that’s blocked from purchasing restricted content, so the reader can expect\nthat the same applies to ages below 17 as well. The last example shows what should\nhappen when you successfully cross the boundary condition specified in the middle\nexample.\nYou always need to be extremely careful when dealing with boundary conditions.\nWherever you find yourself trying to express an example as a class of equivalence,\nrewrite it using the Goldilocks principle with concrete examples of the boundaries. It\nmay seem like too much trouble at first, but it’s a good, safe habit that can spare you\nmany misunderstandings. \nExercise 5\nRewrite the following Given so that it will use a parameter, similar to the <age>\nparameter in the previous snippet, and a table with three Goldilocks examples:\nGiven a discount that is higher than 10% and lower than 12%\n",
      "content_length": 2441,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 147,
      "content": "121\nAnswers to exercises\n5.5\nAnswers to exercises\nEXERCISE 1\nRewrite the table of examples in Gherkin:\nExamples:\n| region\n| commission |\n| North America | 10%\n|\n| South America | 11.4%\n|\n| Europe\n| 12.9%\n|\n| Asia\n| 12.9%\n|\n| Africa\n| 13.5%\n|\nEXERCISE 2\nPrepare a list of the most representative examples that will illustrate what\nyour online shop is selling to someone who didn’t read this chapter or chapter 4:\nExamples:\n| item\n| category\n|\n| \"Sorrow\" by Damion Melville | paperback\n|\n| \"Setup\" by Beyhan Topuz\n| hardcover\n|\n| \"Recruits\" by Fionna Walker | e-book\n|\n| \"Aliens\" by Phan Uoc\n| audiobook\n|\n| \"Invent\" by Stela Vánová\n| audio CD\n|\n| Kindle Paperwhite 3\n| e-reader\n|\n| Apple iPad\n| tablet\n|\n| Beats Solo 2\n| headphones |\n| \"Inception\"\n| movie\n|\nEXERCISE 3\nWhen an item that’s on sale is featured as a daily deal, what will a table\nwith an example and a counterexample look like?\nExamples:\n| item\n| discount\n| price\n|\n| Kindle Paperwhite 3 | N/A\n| $119.99 |\n| Kindle Paperwhite 3 | Daily Deal | $99.59\n|\nEXERCISE 4\nPrepare a list of pairwise examples for another search scenario in which\nSimona looks for a new tablet:\nExamples:\n| filter\n| value\n| results\n|\n| manufacturer and line | \"Samsung\", \"S2\"\n| Galaxy Tab S2\n|\n| manufacturer and line | \"Samsung\", empty | Galaxy Tab S2, Tab E |\n| year and manufacturer | \"2013\", \"Apple\"\n| iPad Air\n|\nEXERCISE 5\nRewrite the Given so that it will use a parameter, similar to the <age>\nparameter in the previous snippet, and a table with three Goldilocks examples:\nGiven a <discount>\nExamples:\n| discount\n|\n| 10% discount |\n| 11% discount |\n| 12% discount |\n",
      "content_length": 1607,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 148,
      "content": "122\nCHAPTER 5\nChoosing examples for scenario outlines\n5.6\nSummary\nOutside-in scenario outlines are written directly from examples gathered\nduring an analysis phase rather than by merging similar scenarios.\nIllustrative examples are tests that only test the key inputs and outputs. They’re\ndifferent from exhaustive tests that test every possible combination of inputs\nand outputs to maximize test coverage.\nScenario outlines work well with representative examples illustrating each\nimportant aspect of business functionality.\nExamples should always be illustrated with counterexamples in order to show\nclear boundaries between business rules.\nThe Goldilocks principle states that in a given sample of tests, there may be\nentities belonging to extremes, but there will always be an entity belonging to\nthe average.\nBoomerangs are difficult areas of implementation, troubled with production\nbugs, and they also make good candidates to include in scenario outlines.\nExamples that prevent data-type attacks, such as testing input field validations,\nare usually too low level to be included in executable specifications.\nExamples created by combining all possible inputs often make executable spec-\nifications unreadable, brittle, and slow.\nYou should always solve technical difficulties in the automation layer, instead of\ntrying to solve them in the specification layer of your specifications.\n",
      "content_length": 1400,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 149,
      "content": "123\nThe life cycle of\nexecutable specifications\nIn its original meaning in systems theory, feedback is the exchange of data about how\none part of a system is working—with the understanding that one part affects all\nothers in the system—so that if any part heads off course, it can be changed for the\nbetter. In SBE, a specification suite is the system, every executable specification is a\npart of that system, and the delivery team is the recipient of the feedback.\n As anyone who works in a corporate environment knows, there are two kinds of\nfeedback:\nSupporting that lets people know they’re doing their job well\nCritiquing that’s meant to correct the current course of action\nThis chapter covers\nWorking with an executable specification \nthroughout its life cycle\nUnderstanding requirements’ precision level\nUsing examples in different development phases\nUnderstanding what happens after \nimplementation\n",
      "content_length": 914,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 150,
      "content": "124\nCHAPTER 6\nThe life cycle of executable specifications\nThe same rules apply to the systems of feedback in SBE. Back in 2003, Brian Marick\nwrote a series of blog posts about the concept of an agile testing matrix.1 The series is\nalso one of the oldest articles about modern testing methods I know of that suggested\ndropping the name tests and replacing it with examples for business-facing testing.\n Marick organized his quadrant into distinct quadrants with two axes (see figure 6.1).\nThe vertical axis splits the matrix into business-facing tests, such as prototypes and\nexploratory testing, and technology-facing tests, such as unit tests and performance\ntests. Unit tests deal with low-level testing; they make sure small components of code\nrun well. Performance tests determine how a system performs in terms of responsive-\nness and stability under workload.\n Our area of interest lies in the upper half of the matrix, though: it’s split into tests\nthat support the team’s progress and tests that critique the product. Tests that support the team\nhelp the team write new code before they have a working product. Tests that critique\nthe product look at a finished product with the intent of discovering inadequacies. As\nyou can see, this is similar to the feedback system that powers any human organization.\n The question we’ll explore throughout this chapter is when examples should sup-\nport the team’s work and when they should critique the product. You’ll see how exam-\nples and automation can give delivery teams feedback of both kinds. And you’ll come\nto understand how feedback forces at the core of every executable specification suite\nwork much like a development manager: constantly evaluating the job done by\n1 See Brian Marick, “My Agile Testing Project,” on his blog, “Exploration Through Example,” August 21, 2003,\nhttp://mng.bz/TkO1.\nExamples\nFunctional tests\nStory tests\nPrototypes\nSimulations\nAcceptance tests\nExploratory testing\nScenarios\nUsability testing\nAlpha and beta versions\nUnit tests\nComponent tests\nPerformance tests\nSecurity tests\nCritique\nthe\nproduct\nSupport\nthe team\nBusiness facing\nTechnology facing\nFigure 6.1\nThe agile testing quadrants. I’ve highlighted the tests that will be important \nin this analysis.\n",
      "content_length": 2246,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 151,
      "content": "125\nprogrammers, analysts, designers, and testers; praising the team for their successes;\nand pointing out failures.\n To see how feedback loops in SBE help uncover contradictions and uncertainty that\ncan hide even in well-analyzed requirements, I’ll also talk about the life cycle of an exe-\ncutable specification. In product design, life cycle can be defined as the process of bring-\ning a new product or a new feature to market and then maintaining it over time.\n Chapter 1 said that all software development processes follow similar phases as a\nfunctionality progresses from conception to release, such as planning, building,\nreleasing, and getting feedback. These phases are also a called the software development\nlife cycle. I also said that, traditionally, specifications belong to the planning phase\nbecause that’s when delivery teams first interact with new requirements (as presented\nin figure 6.2).\nSBE is different because it doesn’t see specification as a singular phase but rather as a\nprocess that spreads across multiple phases as requirements evolve and change (see\nfigure 6.3). Specifications become tests; and tests, as you’ll see in chapter 7, become\ndocumentation.\n By evolving requirements, I mean that the precision level of your requirements\nchanges throughout the life cycle of an executable specification. Every requirement\nstarts as a vague goal with a high level of uncertainty. As you implement it, uncer-\ntainty decreases, because the requirement gradually becomes working code. As you’ll\nsee, SBE and Gherkin have a different feedback loop at each stage of the life cycle,\nwhich helps decrease uncertainty even further than in other software development\nprocesses.\n To understand this process thoroughly, we’ll track how a raw requirement becomes a\nGherkin specification—from a broad concept to a working implementation. This time\n1. Plan\nSoftware\ndevelopment\nlife cycle\n3. Launch\n4. Feedback\n2. Build\nTraditional specification\nFigure 6.2\nThe software development \nprocess. Traditional specification \nbelongs to the analysis phase.\n",
      "content_length": 2062,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 152,
      "content": "126\nCHAPTER 6\nThe life cycle of executable specifications\naround, you’ll specify a new feature in a simple mapping application called Mapper.\nMaps are by definition instruments of changing precision. You can use one to look at\ncontinents and countries from a high-level view, but you can also buy a local map of\nyour city and use it to find your home. A map is a great metaphor: just as there are\nlow-resolution and high-resolution maps, there are low-resolution requirements and\nhigh-resolution executable specifications.\n6.1\nEnd-to-end overview of the process\nIn this and the next section, we’ll look at a full overview of what life cycle and precision\nlevel mean. Every software feature goes through several development phases such as\nanalysis, design, implementation, testing, and maintenance. This is what a life cycle is.\nAs discussed in chapter 2, Gherkin specifications are also called features, and they go\nthrough similar phases.\n At its core, every executable specification is the result of a five-step process (see fig-\nure 6.4):\n1\nUnderstanding business goals\n2\nAnalyzing the scope of requirements through examples\n3\nDesigning the solution by deriving scenarios from acceptance criteria and\nexamples\n4\nRefining scenarios until you can implement the behaviors from the specification\n5\nIterating the specification over time\n1. Plan\nSoftware\ndevelopment\nlife cycle\n3. Launch\n4. Feedback\n2. Build\nSpecification by example\nFigure 6.3\nSBE in the software development process. Specification spreads throughout \nmultiple phases.\n",
      "content_length": 1534,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 153,
      "content": "127\nUnderstanding business goals\nAs you cross each threshold, the precision level of your analysis increases (see figure\n6.5). The more precise you are, the better you understand the implications of imple-\nmenting a requirement.\n Business goals are broad directives that sometimes don’t provide a specific solu-\ntion. Requirements are less abstract; they define what needs to be built for whom in\norder to achieve the high-level goal. Solutions are precise plans for features, interac-\ntion flows, and user interfaces. Because software is comprised of thousands of moving\nparts, no solution is fully precise until it’s implemented as working code. And only\nafter the code is released to production do you get the feedback needed to asses\nwhether a business goal has been met, which removes any remaining ambiguity. \n6.2\nUnderstanding business goals\nTo see how the precision level increases throughout the life cycle of an executable\nspecification, we need to start with the least specific phase: discussing business goals\n(see figure 6.6). For this example, assume on the Mapper project, your responsibility\nis to lead a team of developers, designers, and testers. Management is looking for a\nway to increase Mapper’s presence among small businesses and get smaller enterprises\nto pay to be featured on your online maps. Right now, your maps feature only a few of\nthe most popular outlets of international companies located at prominent locations,\nbut management would like to include more firms. Your team has been tasked with\nmaking that change happen.\nUnderstanding\nbusiness goals\nRefining\nscenarios\nAnalyzing\nrequirements\nwith examples\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.4\nThe life cycle of executable specifications\nNeed for\ndetail\nPriorities,\nsolutions, scope,\nestimates\nOpportunities,\nrisks, goals,\nobjectives\nDocumentation,\nregression tests,\ncustomer feedback\nDesign rules,\nacceptance tests\nAnalysis\nPlanning\nImplementation\nStage\nMaintenance\nFigure 6.5\nAs the need for \ndetail increases, so does the \nprecision of artifacts that \nappear during development.\n",
      "content_length": 2107,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 154,
      "content": "128\nCHAPTER 6\nThe life cycle of executable specifications\nTIP\nWhen you’re trying to elicit requirements, raising the discussion to the\nlevel of business goals lets you deal with scope and priorities more efficiently.\nAs you raise the discussion to the level of goals, the number of things you have\nto talk about decreases. That makes it easier to focus on the essentials.\nYou and management agree on actionable goals that the team should aim to meet in\nthe next six months; see table 6.1. You have to understand both the short-term and\nthe long-term contexts. If you knew only the short-term goal, you’d devise a tempo-\nrary solution. For example, your team could add new businesses to the platform man-\nually and still achieve the goal. Because the absolute number of businesses featured\non Mapper is low at the moment, doubling that number would take only a few min-\nutes of work.\nOnly when you also look at the long-term goal you can see that the company is look-\ning for a solution that will let it achieve sustainable growth in a new market segment.\nMeeting such a goal will require you to take different actions.\n \nTable 6.1\nHigh-level goals for the next six months\nPerspective\nGoal\nShort-term\n2x increase in businesses featured on Mapper’s platform\nLong-term\nEstablish presence in the unsaturated segment of small \nbusinesses in order to seek growth\nUnderstanding\nbusiness goals\nRefining\nscenarios\nAnalyzing\nrequirements\nwith examples\nAnalyzing\nlong-term\ngoals\nAnalyzing\nshort-term\ngoals\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.6\nTo understand why a feature request arises, you \nneed to understand the business goals it aims to achieve. \nUnderstanding business goals will let you define proper scope.\nOther resources for strategic planning\nImpact mapping is one of the best methods I know for creating medium-term strategic\nplans. An impact map is a visualization of scope and underlying assumptions, created\ncollaboratively by senior technical and business staff. It’s a mind map that’s grown\nduring a discussion that considers the following four aspects:\n",
      "content_length": 2101,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 155,
      "content": "129\nUnderstanding business goals\nGoal—Why are we doing this?\nActors—Who can produce the desired effect? Who can obstruct it? Who are\nthe consumers or users of our product? Who will be impacted by it?\nImpacts—How should our actors’ behavior change? How can they help us to\nachieve the goal? How can they obstruct us or prevent us from succeeding?\nDeliverables—What can we do, as an organization or a delivery team, to sup-\nport the required impacts?\nI like impact maps because they make assumptions hierarchical and testable. What\ndoes that mean? Let’s say you have an impact map with a goal to grow mobile adver-\ntising for a website.\nFirst, you define the success metrics for your goal. Then, you identify several actors\nwho can help reach you that goal, including super-fans with mobile devices. One pos-\nsible impact could be that they stay longer on your website and increase advertising\nexposure. You figure that features such as forums and chats, among others, might\nhelp achieve that impact.\nLet’s say that after implementing several deliverables, you realize that you were\nwrong in thinking that forums and chats would increase engagement. You may have\nseveral other, similar deliverables on your map, but now you know that this branch of\nthe map isn’t as impactful as you thought it would be—so you might discard that\nimpact or even discard that actor. If you did the latter, all the other deliverables for\nsuper-fans with mobile devices would be automatically discarded as well, because\nthe map is hierarchical. Thus you can treat the map as an easy-to-maintain, visual,\ntestable product backlog that keeps changing its shape as your knowledge about the\nworld grows.\nYou can read more about impact maps in Impact Mapping by Gojko Adžic´  (Provoking\nThoughts, 2012). \nExample of an impact map \nfrom www.impactmapping\n.org/drawing.html\n",
      "content_length": 1848,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 156,
      "content": "130\nCHAPTER 6\nThe life cycle of executable specifications\n6.3\nAnalyzing requirements with examples\nAs you may recall from chapter 1, an SBE process starts with deriving scope from goals.\nThe previous section provided you with a goal. Now you need the scope. There are\nseveral methods to derive scope (see figure 6.7). In recent years, user stories have\nrisen to become the most popular method for defining and discussing scope among\nagile teams; this section will guide you through the process of creating user stories,\nillustrated with examples.\n6.3.1\nConveying requirements as user stories\nA user story lets you convey a glimpse of a requirement as a product backlog item. The\nitem becomes a ticket for a future conversation. Through user stories, you can negotiate\nthe priority of any given requirement, discuss possible solutions and scope, and make\nsome estimates. They’re used for planning.\n The previous section talked about short- and long-term business goals. Even if you\nacknowledge both contexts that are important to your company, that’s only one side\nof the story. Customers don’t care about the goals of businesses; they want businesses\nto bring them value. Customer-oriented firms know that and use user-centered tools\nto align their strategies to their customers’ interests.\n That’s what user stories are for. Writing a user story lets you restate your business\nobjective as a customer benefit.\nIn order to let new customers discover my company\nAs an owner of a small business\nI want to add my company to Mapper's platform\nListing 6.1\n[OK] Your first user story\nRefining user\nstories with\nexamples\nUnderstanding\nbusiness goals\nRefining\nscenarios\nAnalyzing\nrequirements\nwith examples\nCollecting\nexamples\nConveying\nrequirements in\nuser stories\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.7\nTeams hold collaborative \nspecification workshops to find examples that \nillustrate requirements. The examples help the \nteam to refine the scope of their user stories.\n",
      "content_length": 2006,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 157,
      "content": "131\nAnalyzing requirements with examples\nTIP\nI talk more about user stories in chapter 8. You’ll learn alternative for-\nmats to express your stories so that you’ll be able to aim for understanding\nrather than strict conformance to any single format. Stay tuned! Right now,\nyou only have to focus on the three key elements that all user stories share—\nwho, what, and why.\nThanks to your knowledge about your market, you know that making Mapper a new\ndistribution channel will encourage small businesses to add themselves to the plat-\nform. They will essentially do the job for you, if you help them find new clients.\n User stories are crucial to increasing precision to the level an executable specifica-\ntion needs. But stories and scenarios are separate creatures, as shown in table 6.2.\nUser stories have acceptance criteria. Executable specifications have acceptance tests.\nWithout the criteria, there can be no tests. A delivery team derives new executable\nspecifications and new scenarios from user stories.\nAt this stage, you already suspect that your team will have to build some kind of a form\nthat will allow companies to sign up and mark themselves on your maps. You know that\nbecause analyzing business goals and writing the user story increased the precision\nlevel of the requirement to the point that you can begin to devise a specific solution.\n Placing the responsibility for a solution on the development team is a great way to\nobtain the right scope for a goal. The executive team may already have ideas about the\nsolution, derived from their intuitions and expertise; but they made you the product\nowner, so you’re the decision maker.\n When a requirement or a business objective contains implementation details, it\nusually means somebody’s trying to slip in a predetermined solution, binding it\nunnecessarily with the problem your organization is trying to solve. It could be a team\nmember, a manager, someone from marketing and sales, or even a bossy customer.\n Henry Ford famously said, “If I had asked people what they wanted, they would\nhave said faster horses.” Visionaries use this quote as a beaten-to-death excuse for\nignoring customer feedback. I think customers clearly told Ford what they wanted:\nthey told him that speed is the key requirement for transport. But because they\nweren’t engineers, they weren’t able to say that cars would satisfy the requirement.\n People will always use solutions to help themselves imagine consequences of any\ngiven requirement, because it’s a natural way of thinking. But as someone who works\nTable 6.2\nA comparison of user stories and executable specifications\nUser story\nExecutable specification\nDiscarded after implementation\nKept after implementation\nA unit of change\nAn effect of the change\nHas acceptance criteria\nIs an acceptance test\nProduces short-term results, such as cards or tasks\nProduces long-term, living documentation\n",
      "content_length": 2898,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 158,
      "content": "132\nCHAPTER 6\nThe life cycle of executable specifications\nwith technology, you should strive to extract unbiased, pure requirements from their\nsolutions. Only when you decide what will work best for the company should you\nmove on to writing down an executable specification.\nStoring user stories in a product backlog\nA user story is only a token for a future conversation. It’s a reminder that when the\nright time comes, you’ll have to discuss the such-and-such requirement with your\nstakeholders in order to implement it correctly.\nEven though user stories shouldn’t by any measure replace conversations, you can\nprepare notes in advance that will help you get up to speed after you pull a story out\nof the product backlog. (A backlog is a lot like a freezer: some stories don’t age well.)\nYou don’t want to be overly specific, of course. Specificity at this stage could con-\nstrain your flexibility in the future. You should never treat user stories as a to-do list.\nThey’re more like a list of guidelines: directions that you suspect you might explore\nin the future. But stories can stay in the freezer for months, so you may want to pro-\nvide some details to remind you of its purpose back when you put that particular story\nin the backlog.\nTo specify my stories, I use a four-element template based on a simplified story-\nelements template first shown to me during a workshop by David Evans, who is a vet-\neran of agile testing and an active member of the agile community. For each story, I\nwrite down the following:\nStakeholders and their interests—Along with the primary actor who has the\nmost interest in the story and is featured in the story, I sometimes list other\nstakeholders who could be affected by the story.\nA trigger—The event that causes the new behavior to be initiated or invoked\nby a user or by the system itself.\nThe main success scenario—Intentions and outcomes that should guarantee\nthe primary actor’s success (remember not to over-specify UI or implementa-\ntion details!).\nAcceptance criteria—Two to five one-line descriptions that sufficiently identify\neach testing condition for the story to be verified.\nI put these notes in the description of the story in the backlog.\nYou can see that each of the four notes will help me prepare Gherkin scenarios more\nquickly after I pull the user story from the backlog. I’ll already know the primary actor.\nFrom the trigger, I’ll have some idea about the Givens. The main success scenario\nwill help me imagine the Whens and Thens. And from the list of acceptance criteria,\nI’ll be able to estimate how many scenarios an executable specification for this user\nstory will have.\nSometimes notes don’t age well. Requirements can change over time. But notes can\nstill help you in such situations: you can always compare your past notes with your\ncurrent direction. The difference between the former and the latter will be the sum of\nthe learning your team has accomplished during the freezer time.\n",
      "content_length": 2965,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 159,
      "content": "133\nAnalyzing requirements with examples\n \n6.3.2\nCollecting examples\nYou now have a user story that you can put in your team’s backlog. You also have a\nrough sense of the amount of work you’ll face: you know what’s expected of you, and\nyou’ve shared the news with the engineers, who told you their first impressions and\ninitial ideas of what could be done to meet the requirements. What happens next?\n Chapter 1 taught you that after you derive scope from goals, you should start speci-\nfying collaboratively to illustrate requirements with examples. Specifying collaboratively\nmeans domain experts, product managers, developers, testers, and designers working\ntogether to explore and discover examples that will become Gherkin scenarios. Let’s\nassume that in the Mapper example scenario, you decide to organize a workshop.\nTIP\nIt’s your job to be a facilitator and to extract relevant information from\nwhatever is said. Starting by asking for rules is okay as long as you don’t expect\nthe rules to be a fully developed list of acceptance criteria. They’ll be messy\nand, probably, contradictory or inconsistent. As a technologist, you should\nconstantly challenge and refine the requirements your team takes on.\nDuring the workshop, your team comes up with examples of small businesses based in\nyour town that would be most likely to join Mapper’s platform (see table 6.3). You also\nadd a few ideas of how particular businesses may use Mapper to lead new customers\nthrough their conversion channels.\nTable 6.3\nExamples of relevant small businesses\nBusiness name\nBusiness type\nFeatures for lead generation\nDeep Lemon\nRestaurant\nShowing customers business hours\nThe Pace Gallery\nArt gallery\nAdvertising expositions\nFrench Quarter Inn\nHotel\nBooking rooms\nGreen Pencil\nBistro\nShowing customers business hours\nRadio Music Hall\nConcert hall\nAdvertising concert programs\nCity Cinema\nMovies\nShowcasing new films and ticket prices\nChristie’s\nPub\nShowing customers business hours\nThe template can also be useful when you gain new insights about the story, but it’s\nstill not the right time to implement that story—for example, when you gather new\ncustomer feedback, but have other priorities at the moment. Updating the template\ncan preserve your new insights for the future discussion. \n",
      "content_length": 2277,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 160,
      "content": "134\nCHAPTER 6\nThe life cycle of executable specifications\nWhat a diverse bunch of businesses! Having them sign up to Mapper would lead to a lot\nof healthy growth. The difficult part is that they would require different features in order\nto find the platform valuable, and some of those features would be as complex as inte-\ngrating with external booking systems and payment processors. But for now, Mapper’s\ncustomers will have to deal with the limited scope that we’ll implement in this chapter.\n At the analysis stage, delivery teams use examples to understand the business con-\ntext of their requirements—just as you did when you illustrated your business goals\nwith examples of use cases that might help you achieve those goals. Delivery teams can\nalso use examples to check whether the designers, programmers, and testers are in\nsync with the domain experts—again, just as you did during your specification work-\nshop. This is clearly the supporting role of examples that I talked about when I introduced\nthe agile testing matrix in figure 6.1. Is there a relationship between the two critical\ndiagrams in this chapter—the matrix from figure 6.1 and the life cycle diagram from\nfigure 6.5? As you can see in figure 6.8, you could easily rework the life cycle diagram\nto show the supporting role of examples in the early stages of development.\nThe supporting role of early examples means delivery teams can use them to support\nwriting new code when they work on new functionalities. In a way, the right examples\nprovoke the right code, guiding the development process.\n But as the requirements become more precise, the supporting role becomes less\nimportant than the critiquing role (see figure 6.9). By critiquing, I mean that examples\nbegin to challenge the requirement. For example, what if the examples collected by the\ndelivery team are wrong? Some surely will be.\n Examples at the critiquing stage usually have something they didn’t have earlier:\nan actual iteration of working software. When working software becomes available, it’s\nSupport role \nimportant at first,\ndiminishes later\nSupport\nCritique\nAnalysis\nPlanning\nImplementation\nStage\nMaintenance\nFigure 6.8\nBefore they’re automated, examples support delivery teams \nin understanding the scope of requirements—which is important at the \nbeginning of the life cycle.\n",
      "content_length": 2332,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 161,
      "content": "135\nAnalyzing requirements with examples\neasier to verify whether your initial analysis was right. Sometimes, the business expert\nwill forget things that real users will need. They may also be misguided or may cham-\npion a preferred solution due to a personal agenda. And sometimes, you can end up\noverengineering the solution and worrying about too many examples that aren’t use-\nful in the real world. \n6.3.3\nRefining user stories with examples\nLet’s assume that building a feature for so many kinds of businesses proved to be too\ndifficult for Mapper. Having a deadline to meet and limited resources you can use,\nyou decide to reduce the scope. To choose a customer segment that will allow you to\neasily expand to other businesses in the future, you must look for a carryover customer.\nDEFINITION\nCarryover customer—An example of a real customer who shares\nbehavioral traits with as many other customers as possible and becomes a\nmodel for an average consumer. If you design a product or a feature for the\nright carryover customer, other segments of the market should find it valu-\nable, too.\nDid you notice that all of the gastronomy businesses in table 6.3 share the same feature—\nshowing customers business hours—that would drive their conversion rates? Other busi-\nnesses, such as shops, pubs, and clubs, share this trait, too. After some discussion, the\nMapper team agree that restaurants and bistros make good carryover customers.\nIn order to let my customer know where and when they can come in\nAs an owner of a gastronomy business\nI want to add my company to Mapper's platform\nListing 6.2\n[BETTER] Refined user story\nWhen a functionality is implemented,\nacceptance tests start to critique the product.\nSupport\nCritique\nAnalysis\nPlanning\nImplementation\nStage\nMaintenance\nFigure 6.9\nAs requirements get more precise, examples are challenged \nby the working product.\n",
      "content_length": 1875,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 162,
      "content": "136\nCHAPTER 6\nThe life cycle of executable specifications\nYou believe that implementing this user story will fulfill the short-term business goal\nyou were tasked with. While you test the waters with gastronomy, the user stories for\nother businesses will wait patiently in the backlog for their turn.\nTIP\nFeatures can usually be split only based on technology. This is a limiting\napproach. For example, if you wanted to split a report-generating feature into\nsmaller portions, your first instinct would probably be to split it based on its\ntechnological ability to generate reports in different formats such as .pdf, .csv,\nand .xls. User stories and requirements, on the other hand, can be split by\nvalue. In your analysis of Mapper’s platform, you choose the most valuable\ncustomer segment and split a small capability that would bring this segment a\nlot of value without a lot of effort on your side.\nYou wouldn’t be able to make a confident decision without the validation provided by\nthe examples you collected. That’s their power.\n Collecting, analyzing, and refining examples creates a powerful feedback loop\nwithin any project that uses SBE. Examples helped you define the scope of the features\nand split user stories into smaller, more precise backlog items. Even though you’re yet\nto see an executable specification that your Mapper team could use, it should already\nbe clear why examples lie at Gherkin’s center.\nEliciting better requirements with Feature Injection\nThe process you’ve been using throughout the chapter to elicit requirements is sim-\nilar in design to feature injection: a technique that iteratively derives scope from goals\nthrough high-level examples.a In feature injection, teams first “hunt for value” by cre-\nating a model for delivering business value and listing underlying assumptions\ninstead of trying to describe the value with simple numbers such as revenue goals.\nYou created a simple model for value delivery when we discussed Mapper’s short-\nterm and long-term goals, why the goals are important, how they influence Mapper’s\nbusiness model, and which stakeholders demand that you achieve the metrics.\nOnce a model is defined, you do more than just evaluate whether to accept or reject\na suggested feature. You can proactively create a list of features that drive toward\ndelivery of business value based on your models. You did that when you wrote your\nfirst user story and refined it to better fit the value model.\nInjecting features provides a set of happy paths to create the outputs that will deliver\nthe business value. But doing so doesn’t provide all possible variations of input that\ncan occur and that may affect the outputs, or all cases that need to be considered\nfor successful delivery. You may recall happy paths from section 5.3.3, where I talked\nabout exploratory outcomes. Exploratory outcomes pursue possible unhappy paths,\nleading to new testing ideas. When new examples are generated, you can put them\ntogether in an executable specification—which is what you’re about to do for Mapper. \na Feature injection was created by Chris Matts and then expanded with Rohit Darji, Andy Pols,\nSanela Hodzic, and David Anderson over the years 2003–2011. For more information, see\n“Feature Injection: Three Steps to Success” by Chris Matts and Gojko Adžic´, InfoQ, Decem-\nber 14, 2011, http://mng.bz/E5fS.\n",
      "content_length": 3351,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 163,
      "content": "137\nDeriving scenarios from examples\n6.4\nDeriving scenarios from examples\nIn this section, you’ll step over another precision threshold as the user story you chose\n(listing 6.2) finally transforms into a draft of an executable specification. To do so,\nyou’ll finally write your scenarios (see figure 6.10).\nTIP\nA story becomes an executable specification when you’re sure it’s worth\ninvesting time and effort in it.\nFrom the examples you collected, you derive a list of acceptance criteria for the user\nstory:\nEvery new business should provide a name and a location to display on the\nmap.\nEvery business should provide business hours for each day of the week.\nLet’s take the relevant examples of pubs, restaurants, and bistros from the previous\nsection to write the first draft of an executable specification.\nFeature: New businesses\nScenario Outline: Businesses should provide required data\nGiven a restaurant <business> on <location>\nWhen <business> signs up to Mapper\nThen it should be added to the platform\nAnd its name should appear on the map at <location>\nExamples:\n| business\n| location\n|\n| Deep Lemon\n| 6750 South Street, Reno\n|\n| Matt's\n| 9593 Riverside Drive, St. Louis |\n| Back to Black | 8114 2nd Street, Stockton\n|\n| Green Pencil\n| 8583 Williams Street, Glendale\n|\n| Le Chef\n| 3318 Summit Avenue, Tampa\n|\n| Paris\n| 2105 Briarwood Court, Fresno\n|\n| Christie's\n| 714 Beechwood Drive, Boston\n|\n| The Monument\n| 77 Chapel Street, Pittsburgh\n|\n| Anchor\n| 110 Cambridge Road, Chicago\n|\nListing 6.3\n[OK] First draft of an executable specification\nWriting\nscenarios\nUnderstanding\nbusiness goals\nRefining\nscenarios\nAnalyzing\nrequirements\nwith examples\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.10\nExamples serve as a basis for all scenarios to come. Over time, the team should \noptimize scenarios for readability and remove confusing, redundant examples.\n",
      "content_length": 1897,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 164,
      "content": "138\nCHAPTER 6\nThe life cycle of executable specifications\nStraightforward, isn’t it? You take the first acceptance criterion from your list, rework\nit to fit the Given-When-Then template, and use a scenario outline to include all the\nrelevant examples you collected during the previous phase of your analysis.\n The increased precision level allows your team to spot a possible edge case: what if\na restaurant has two establishments in two different locations in the same city? There\nmight be one Deep Lemon in Reno at 6750 South Street and a second one at 289 Lau-\nrel Drive, for example.\n Should you allow that in your application? And if the answer is yes, should you\nmake that process easier? In the end, you decide there’s nothing wrong with accept-\ning multiple locations, but you don’t have time to optimize the process. Users will\nhave to make do with what they have. To finalize the decision, you add another exam-\nple to the outline.\nFeature: New businesses\nScenario Outline: Businesses should provide required data\nGiven a restaurant <business> on <location>\nWhen <business> signs up to Mapper\nThen it should be added to the platform\nAnd its name should appear on the map at <location>\nExamples:\n| business\n| location\n|\n| Deep Lemon\n| 6750 Street South, Reno\n|\n| Deep Lemon\n| 289 Laurel Drive, Reno\n|\n| Matt's\n| 9593 Riverside Drive, St. Louis |\n| Back to Black | 8114 2nd Street, Stockton\n|\n| Green Pencil\n| 8583 Williams Street, Glendale\n|\n| Le Chef\n| 3318 Summit Avenue, Tampa\n|\n| Paris\n| 2105 Briarwood Court, Fresno\n|\n| Christie's\n| 714 Beechwood Drive, Boston\n|\n| The Monument\n| 77 Chapel Street, Pittsburgh\n|\n| Anchor\n| 110 Cambridge Road, Chicago\n|\nThis is a fine example of a typical SBE tendency: tests guiding implementation. Only\nwhen you get to the precision level of test cases can you see that you overlooked an\nimportant element of the design. That’s because tests and requirements are essentially\nconnected. In 1968, Alan Perlis wrote that “a simulation which matches the require-\nments contains the control which organizes the design of the system.”2 A test pre-\ndefines “ideal” outputs and inputs up front; the application code must then be\ndesigned so that the real inputs and outputs match the ideal ones defined by the test.\nOtherwise, the test will fail.\nListing 6.4\n[BETTER] Second draft of the executable specification\n2 Software Engineering: Report on a conference sponsored by the NATO SCIENCE COMMITTEE, Garmisch, Germany, 7th to\n11th October 1968, eds. Peter Naur and Brian Randell (Scientific Affairs Division, NATO, 1969),\nhttp://mng.bz/jn3d.\nFirst location \nof a business\nSecond \nlocation of \nthe same \nbusiness\n",
      "content_length": 2654,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 165,
      "content": "139\nRefining scenarios\nTIP\nHere’s a rule of thumb: good code designs usually don’t need complex\ntests. If your tests are too complicated, you may be missing an important\ndomain concept or tackling a known concept the wrong way.\nFor the second time in this chapter, the feedback mechanisms of the SBE process have\nled you to discover something you missed in your initial analysis. You should expect to\nmake such discoveries multiple times during any feature’s development. You’ll proba-\nbly go back and forth multiple times during development or even after implementa-\ntion (as represented in figure 6.11). SBE practitioners should adopt the mindset that\nthere’s no such thing as a single moment when a feature is finished—features only get\nreleased. These are two different things.\n You can begin analyzing requirements either by looking for examples, as you did\nin Mapper’s case, or by perfecting a list of acceptance criteria. Either way, feedback\nlets you spot inconsistencies more quickly and easily. You shouldn’t expect to get\neverything right the first time; that’s typical. \n6.5\nRefining scenarios\nWith a scenario now in place, your team can implement it. Implementing the behav-\niors described by a scenario is the stage with the highest possible precision before a\nfeature is released to customers who validate its business value in the real world. This\nsection will show you what happens when a raw scenario first meets working code, and\nhow that meeting increases precision to a release-ready level.\n In chapters 1 and 2, you saw that after you write the first draft of a new executable\nspecification, you often need to refine scenarios and choose key examples to improve the\nreadability of your executable specification (see figure 6.12). That happens when\nteams refine their specifications to merge similar examples, reject the ones that intro-\nduce noise, and choose the most meaningful or descriptive ones.\nAcceptance \ncriteria\nGenerate\nChallenge\nExamples\nFigure 6.11\nCollecting, \nanalyzing, and refining examples \nis a continuous, never-ending \nprocess that exists within a \npowerful feedback loop.\nChoosing key\nexamples\nUnderstanding\nbusiness goals\nRefining\nscenarios\nRefining\nexamples for\nreadability\nAnalyzing\nrequirements\nwith examples\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.12\nTeams refine their specifications by \nextracting key examples and turning scenarios \ninto clear, unambiguous, organized documents.\n",
      "content_length": 2468,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 166,
      "content": "140\nCHAPTER 6\nThe life cycle of executable specifications\nReturning to Mapper, after your team begins to implement the behaviors from the\nscenario, they notice that the examples used in the previous section don’t test any\nedge cases other than a business with two locations. The examples don’t specify what\nhappens when any attribute of a business is missing. All the examples in the outline\nend with the business successfully joining Mapper’s platform. Why aren’t there any\ncounterexamples?\n Let’s think for a moment and look for a few counterexamples that would go astray\nfrom the happy path:\nThe applicant might forget to fill out the input field with the business name on\nthe registration form.\nThe applicant might forget to mark the location on the map.\nThe applicant might make both of the previous mistakes.\nThe applicant might provide a location, but it might be inaccurate; for exam-\nple, the user might mark the middle of a river as a location for their business.\nHaving defined new examples, you should now do two things. First, you need to\nremove redundant examples that don’t bring any value to the specification. Second,\nadd new examples and counterexamples that express the failure scenarios. You can\nalso split the examples into multiple tables to improve readability.\nFeature: New businesses\nScenario Outline: Businesses should provide required data\nGiven a restaurant <business> on <location>\nWhen <business> signs up to Mapper\nThen it <should?> be added to the platform\nAnd its name <should?> appear on the map at <location>\nExamples: Business name and location should be required\n| business\n| location | should?\n|\n| UNNAMED BUSINESS | NOWHERE\n| shouldn't |\nExamples: Allow only businesses with correct names\n| business\n| location\n| should?\n|\n| Back to Black\n| 8114 2nd Street, Stockton | should\n|\n| UNNAMED BUSINESS | 8114 2nd Street, Stockton | shouldn't |\nExamples: Allow businesses with two or more establishments\n| business\n| location\n| should? |\n| Deep Lemon | 6750 Street South, Reno | should\n|\n| Deep Lemon | 289 Laurel Drive, Reno\n| should\n|\nExamples: Allow only suitable locations\n| business | location\n| should?\n|\n| Anchor\n| 110 Cambridge Road, Chicago | should\n|\n| Anchor\n| Chicago River, Chicago\n| shouldn't |\n| Anchor\n| NOWHERE\n| shouldn't |\nListing 6.5\n[BEST] Executable specification with refined key examples\nFailure scenario \nwith no name \nor location\nFailure\nscenario\nwith no\nname\nFailure scenario \nwith an \ninaccurate \nlocation\nFailure\nscenario\nwith no\nlocation\n",
      "content_length": 2505,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 167,
      "content": "141\nIterating specifications over time\nTIP\nYou may have noticed that in listing 6.5, UNNAMED BUSINESS and NOWHERE\nare uppercase. To be honest, this isn’t a Gherkin convention; but the capital\nletters make these examples stand out, which improves readability.\nThe reworked outline is much easier to read and has more-comprehensive scenarios.\nYou need only to glance at it to recognize what it tests and why. It clearly distinguishes\nbetween success examples and failure examples. To my eye, the precision level of this\nscenario looks like it’s release ready. Congratulations!\n6.6\nIterating specifications over time\nYou don’t stop working on an executable specification after you write it (see figure 6.13).\nIt’s a continuous process. The team should validate the specification suite frequently to\nspot any integration errors as soon as possible, keeping the suite consistent at all times.\nThis section will show you how.\nWhen the specifications are consistent and up to date, they evolve into a living docu-\nmentation system that acts as a single source of truth about the system’s behaviors.\nEverybody on the team can use the system freely to solve their disagreements. We’ll\nenlarge on that, too.\n6.6.1\nValidating the specification suite\nIn the heat of the battle, while revising your scenario outline, you almost forgot that\nthe user story you wrote at the beginning of this chapter specified two acceptance\ncriteria:\nEvery new business should provide a name and a location to display on the\nmap.\nEvery business should provide specific business hours for each day of the week.\nSo far, you’ve only taken care of the first criterion. Let’s use what you’ve learned to\nwrite the second scenario.\nUnderstanding\nbusiness goals\nRefining\nscenarios\nEvolving the\ndocumentation\nsystem\nValidating the\nspecification\nsuite\nAnalyzing\nrequirements\nwith examples\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.13\nThe process of iterating specifications over time \nmeans validating frequently, keeping the specification suite \nconsistent over time, and evolving a living documentation system.\n",
      "content_length": 2109,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 168,
      "content": "142\nCHAPTER 6\nThe life cycle of executable specifications\n \nFeature: New businesses\nScenario Outline: Businesses should provide required data\n[...]\nScenario Outline: Businesses should be able to set their hours\nGiven a restaurant <business> on <location>\nWhen it schedules its hours to be <times> every day\nThen the hours should appear on the map at <location>\nExamples: Restaurants\n| business\n| location\n| times\n|\n| Deep Lemon | 6750 Street South, Reno\n| 7 AM-8 PM |\nExamples: Bistros\n| business\n| location\n| times\n|\n| Le Chef\n| 3318 Summit Avenue, Tampa | 9 AM-9 PM |\nExamples: Pubs\n| business\n| location\n| times\n|\n| Anchor\n| 77 Chapel Road, Chicago\n| 3 PM-3 AM |\nAfter you agree on the shape of the scenario, the team proceeds to automate it. They\nwrite new application code and generate the step definitions required to test the\ncode. Having done that, they run the test-execution engine to make sure the modified\nsystem works as they expect it to.\n And that’s when they find out that implementing the behavior from the new sce-\nnario breaks another scenario in the specification suite.\nFeature: Show sightseeing objects on the map\nScenario: Tourists should be able to see sightseeing objects\nGiven a sightseeing object:\n| name\n| location\n|\n| Memorial Monument | Oak Street |\nWhen Janet, who is a tourist, looks at Oak Street\nThen she should see Memorial Monument on the map\nIt turns out that the new attributes of business hours don’t work well with other types\nof entities that Mapper features on its maps, such as sightseeing objects. Not all sight-\nseeing objects—such as monuments—have opening and closing times.\n Your team forgot about that, and the validations they added prevented sightseeing\nobjects from being created in the database. To fix that, you decide to make the valida-\ntions optional instead of required. As soon as you do, the system starts working again,\nand the feature is ready to be deployed to production.\n Before we move on, let’s dissect what happened. The specification suite has to be con-\nsistent. When the team implements the behaviors from a new executable specification,\nListing 6.6\nAdding another scenario to the specification\nListing 6.7\nBroken scenario\n",
      "content_length": 2194,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 169,
      "content": "143\nIterating specifications over time\nthey should execute the existing specifications in order to check whether they still\nwork. The team must test the existing specifications every time changes are introduced\nto the system.\n If a scenarios breaks after you introduce a new feature, you can take only two\nactions:\nUpdate the broken scenario so it complies with the changes.\nChange the new feature so it won’t break the scenario.\nAs you can see, whereas new scenarios influence old scenarios, the old ones can also affect\nnew features (see figure 6.14). It’s another feedback loop within the process of SBE.\nI’ve already talked about it in chapter 1, which listed validating frequently as one of SBE’s\nkey practices.\nWhen you validate frequently, you once again operate in the product-critique quad-\nrant of the testing matrix. As soon as you automate the critiques, the test-execution\nengine will check the application regularly against new examples, protecting the qual-\nity of your product (see figure 6.15). Modern development practices take advantage of\nthat in various ways. For example, teams that employ continuous integration (CI)\npractices will integrate as often as possible, leading to multiple integrations per day.\nEach integration will then be verified by an automated build that can detect errors\nalmost instantly. Some teams trust their specification suites so much that they let every\nchange be automatically deployed to production if the tests pass—a practice known as\ncontinuous deployment.\nThe specification\nsuite\nThe new changes the old.\nThe old influences the new.\nThe new feature\nFigure 6.14\nThe feedback loop \nbetween new features and the \nexisting specification suite\nContinuous \nintegration\nSupport\nCritique\nAnalysis\nPlanning\nImplementation\nStage\nMaintenance\nFigure 6.15\nAfter release, examples become automated tests that \ncritique the finished product, if they’re validated frequently.\n",
      "content_length": 1917,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 170,
      "content": "144\nCHAPTER 6\nThe life cycle of executable specifications\nMost often, integration tests are followed by user acceptance testing (UAT). A popular\nargument for performing UAT manually is that getting your hands on the product\nactivates a different type of perception and judgment than thinking about automa-\ntion. Manipulation is different than cogitation. For example, when you test-drive a car,\nyou notice things you wouldn’t spot when poring over its specs, like the seats being\ntoo stiff or the leather not looking right.\nDEFINITION\nUser acceptance testing (UAT)—The last phase of the software-test-\ning process. During UAT, actual end users test the product to make sure it can\nhandle the tasks required by the specifications.\nBut when business stakeholders trust in their executable specifications, they can\nreplace simple, manual, boring checks with automated tests from the specification\nsuite, streamlining the UAT process. (I’m not saying they should remove manual tests\naltogether; they can just have fewer trivial ones.) Such trust is an ultimate sign that\nyou’re doing SBE well and that the stakeholders understand why examples and scenar-\nios are important. \n6.6.2\nEvolving the documentation system\nAfter you deploy the feature to production, it starts living a life of its own. A bug may\noccur from time to time; you fix it, write a regression test, and move on. As with any\nother feature, when development ends, maintenance begins. This section covers what\nhappens with an executable specification at the end of its life cycle, when it reaches\nthe highest precision level.\n The Mapper features turn out to be a success. Gastronomy businesses sign up like\ncrazy. You hope that implementing the user stories about other types of businesses will\nhappen in the future. For now, management is happy. You’re proud of your team, too.\nThe code is good; the specification looks fine.\n At least, you think so, until your team comes back to the specification two months\nlater. That’s when Martha, a fresh hire on your team, takes on a new user story con-\nnected to small businesses. To implement it, she needs to understand the feature bet-\nter, so she reads the specification the team created a few months ago. She still has\nsome questions, though, so she talks to you:\n“Hey,” she says. “What are popular hours?”\n“No idea. Why?”\n“Here’s a user story you created two months ago, before I joined the team. It only mentions\nthat you might also want to consider letting gastronomy businesses specify popular\nhours.”\n“OK … that does ring a bell. But I’m not sure …”\n“If it helps, I read the specification, and it already has a scenario that allows businesses\nto schedule some kind of hours. Maybe somebody already implemented that user story but\nforgot to mark it as done.”\n",
      "content_length": 2773,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 171,
      "content": "145\nIterating specifications over time\n“Let’s ask Gus. I think he was the last one to work with this feature. Hey, Gus, have you\nalready implemented something called popular hours?”\n“Didn’t we do that two months ago? Or wait, maybe it was business hours, not popular\nhours. Let me check the code …”\nYou get the gist.\n Two months ago, you made a frequent development mistake: mid battle, you\nthought the specifications you wrote were perfectly clear, because you still had all\nthe domain concepts in your short-term memory. After the dust settled, you realized\nthat your feeling of clarity was illusionary. Martha bravely brought a fresh perspec-\ntive that helped you realize that issue. You cringe at the thought of how many other\ndecisions were made without clear distinctions between domain concepts like the\none she noticed.\n You decide to rewrite the scenario in question and include some clarifying definitions.\nFeature: New businesses\nScenario Outline: Businesses should provide required data\n[...]\nScenario Outline: Businesses should be able to set relevant hours\nBUSINESS HOURS define when a business opens and closes.\nBusinesses provide POPULAR HOURS to help their customers\ndecide when it's the best time to come in.\nGiven a restaurant <business> on <location>\nWhen it schedules <hours> to be <times>\nThen the <hours> should appear on the map at <location>\nExamples: Restaurants\n| business\n| location\n  | hours\n| times\n|\n| Deep Lemon | 6750 Street South, Reno   | business hours     | 7 AM-8 PM |\n| Deep Lemon | 6750 Street South, Reno  | popular hours\n| 3 PM-5 PM |\nExamples: Bistros\n| business   | location\n| hours\n| times\n|\n| Le Chef   | 3318 Summit Avenue, Tampa | business hours     | 9 AM-9 PM |\n| Le Chef   | 3318 Summit Avenue, Tampa | popular hours\n| 8 PM-9 PM |\nExamples: Pubs\n| business   | location\n  \n| hours\n| times\n|\n| Anchor\n  | 77 Chapel Road, Chicago  | business hours     | 3 PM-3 AM |\n| Anchor\n  | 77 Chapel Road, Chicago  | popular hours\n| 9 PM-2 AM |\nBuilding and evolving a documentation system is the last step in the life cycle of any exe-\ncutable specification. Your work on a specification is rarely finished after you deploy\nListing 6.8\n[BETTER] Executable specification with clarifications\nAdded\ndefinition\nfor business\nhours\nSeparate \ndefinition for \npopular hours \nthat explains \nthe difference\nExamples\nof\nbusiness\nhours\nExamples of popular hours\n",
      "content_length": 2389,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 172,
      "content": "146\nCHAPTER 6\nThe life cycle of executable specifications\nthe new feature to production. You’ll likely come back to rewrite the steps, or change\nthe structure of the scenarios, or, as in the case we just discussed, add clarifications to\nthe specification layer. Chapter 7 goes into depth on these topics.\nAs the application changes and you discover new requirements, you may realize that\nsome of the scenarios you thought were distinct are parts of a bigger whole and\nshould be combined in a single specification. Sometimes the scenarios you thought\nwere connected will branch out into their own requirements. As the business evolves,\nyour specification suite should evolve with it. Changes in a specification suite often\ndirectly reflect the changes in a delivery team’s understanding of the business\ndomain. It’s a fascinating subject that we’ll explore deeply in chapters 8–11.\n Before we finish this chapter, figure 6.16 takes another look at the full life cycle of\nany executable specification. The next chapter focuses on the last box in this life\ncycle. As you may remember from chapter 1, fully fledged executable specifications\nare also called living documentation. Living documentation is always up to date because\nit changes alongside the system, thanks to the link between the documentation and\nautomated tests. When an executable specification evolves into living documentation,\nits active life cycle ends. That doesn’t mean the specification won’t change anymore, of\ncourse, but it’ll be more passive from now on. Usually, it’ll be changed and influenced\nby new specifications that enter the specification suite as the product matures. In\nchapter 7, which talks about the details of building a living documentation system, I\ndiscuss techniques that help you manage and maintain specifications in the passive\nstage of their life cycle (see figure 6.16).\nGall’s Law\nWhy do I keep talking about gradual evolution of requirements and domain concepts\ninstead of trying to find the perfect system design from scratch? Gall’s Law is the\nreason.\nGall’s Law is a rule of thumb for systems design that comes from John Gall’s book\nSystemantics: How Systems Really Work and How They Fail (General Systemantics\nPress, 2002):\nA complex system that works is invariably found to have evolved from\na simple system that worked. A complex system designed from\nscratch never works and can’t be patched up to make it work. You\nhave to start over with a working simple system.\n—Gall’s law\nI’m a strong believer in the power of this law. That’s why I keep repeating that you\nshould look for simple things that work, in terms of both the requirements and the\nimplementation, and then build on them. Moreover, SBE’s feedback loops will help\nyou spot systems that work, and thus never break, and systems that don’t work, and\nthus break constantly.\n",
      "content_length": 2836,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 173,
      "content": "147\nSummary\n6.7\nSummary\nAn executable specification evolves throughout a project’s life cycle.\nAs the project progresses, executable specifications become more precise. The\nlater the life cycle’s phase, the greater the need for detail.\nExploring examples is a process of discovery: you start with little certainty about\nthe examples’ completeness, and as you contest them and improve the list, you\nbecome more certain that your understanding is sound.\nKey examples should be chosen to illustrate the acceptance criteria clearly and\ncompletely. As acceptance criteria change, the list of key examples evolves.\nSome examples support the team in their attempts to write new code, and some\nexamples critique the product, aiming to improve its quality.\nNew features add new specification documents to the specification suite, but\nthe existing specification suite can also cause changes in new features. The new\ninfluences the old, but the old can also change the new.\nRefining user\nstories with\nexamples\nWriting\nscenarios\nChoosing key\nexamples\nUnderstanding\nbusiness goals\nRefining\nscenarios\nRefining\nexamples for\nreadability\nEvolving the\ndocumentation\nsystem\nValidating the\nspecification\nsuite\nAnalyzing\nrequirements\nwith examples\nCollecting\nexamples\nConveying\nrequirements in\nuser stories\nAnalyzing\nlong-term\ngoals\nAnalyzing\nshort-term\ngoals\nDeriving\nscenarios from\nexamples\nIterating\nspecifications\nover time\nFigure 6.16\nThe full life cycle of \nan executable specification\n",
      "content_length": 1477,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 174,
      "content": "148\nLiving documentation\nEverybody who’s ever worked with software has probably dealt with documentation\nat some point. Documentation can be provided on paper or online, or on digital or\nanalog media, such as audiotape or CDs. SBE introduces a different type of docu-\nmentation.\nDEFINITION\nLiving documentation—Documentation that changes along with\nthe system it describes. Thanks to frequently validated acceptance tests, the\nliving documentation system is aware of changes you make to the system; if\nthe changes yield different results than the results expected by the living\ndocumentation system, running acceptance tests will yield an error.\nSBE is actually a system of documentation. What I mean is that living documentation\nis a suite of acceptance tests written in a domain-specific language like Gherkin and\nThis chapter covers\nUnderstanding living documentation\nHelping new team members with living \ndocumentation\nDefining domain concepts consistently\nDocumenting product changes and troublesome \nareas\n",
      "content_length": 1016,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 175,
      "content": "149\nreadable by nontechnical team members. Through acceptance tests, automated sce-\nnarios are tied to application code. This means scenarios that describe functional and\nbehavioral requirements can be used to create a living documentation system that\nevolves every time the code changes.\n Moreover, writing documentation isn’t a separate activity or a standalone phase.\nThe scenarios are the documentation. In chapter 6, you saw that every executable\nspecification evolves during development, increasing its precision level throughout its\nlife cycle. You start with high-level requirements that vaguely describe business goals,\nand you end up with a set of automated acceptance tests that are low-level and precise\nbecause they’re actual working code. At the high-fidelity end of that spectrum, when\nthe first drafts of scenarios are finished and approved, executable specifications\nbecome living documentation. Having already explored how to write scenarios in\nchapters 2 and 3 and how to write scenario outlines in chapters 4 and 5, it’s high time\nwe talk about creating high-precision living documentation from specification drafts.\n Even though I didn’t dwell on it, you used some of the techniques for building a\nliving documentation system in previous chapters to do the following:\nExplain difficult domain concepts\nHighlight differences between dangerously similar domain concepts\nDocument troublesome areas of implementation\nGive more context about business goals\nThanks to these activities, living documentation can be of great value to software\ncompanies:\nIt allows team leads to get new hires up to speed much more quickly, because\nthey can take advantage of documentation that is brief, concise, customer ori-\nented, and always up to date.\nWhen teams validate frequently and make the specification suite part of a con-\ntinuous integration system, they can easily trace an integration error back to its\ntest and, beyond, to a scenario linked to the broken part of the application.\nSuch scenarios can be used as documentation to repair the bug more quickly.\nI talked about continuous integration in section 1.6.2: it’s a software development\npractice where members of a team integrate their work frequently, and each integra-\ntion is verified by an automated build to detect integration errors quickly. And\nthroughout chapters 5 and 6, we investigated how valuable good, meaningful tests in\nscenario outlines can be in terms of product quality.\n This chapter talks in depth about each of the activities needed to create great doc-\numentation that evolves along with the system. By the end of the chapter, you’ll know\nwhat a minimally qualified reader is and why writing for a specific reader in your orga-\nnization matters. A reader-oriented mindset will teach you to better document changes\nin the specification suite. You’ll practice creating definitions for new concepts in the\nubiquitous language of your projects. In the long term, this will help you manage the\nthat language in a growing specification suite.\n",
      "content_length": 3032,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 176,
      "content": "150\nCHAPTER 7\nLiving documentation\n7.1\nLiving documentation in action\nFirst, we’ll look at living documentation from a practical perspective. Throughout this\nchapter, you’ll be using as an example an application called HouseKeeper. House-\nKeeper is free property-management software for independent tenants and landlords.\nLet’s suppose that thousands of property managers save time and money every month\nwith HouseKeeper, whether they’re managing one unit or hundreds. HouseKeeper\nhandles online rent payment, tenant screening, and credit and background checks.\nThis example will show you documentation practices in action in a domain that’s both\nfamiliar and difficult.\n One day, a coworker named Peter comes to you because he saw in the version con-\ntrol system that you were the last person who contributed to the specification docu-\nment he’s having trouble with. Peter is new to the team. He’s also from Poland, where\nrenting works much differently than in the United States; there are fewer legal obliga-\ntions in Poland, and the market is less saturated, because most people buy their own\napartments and the only renters are college students. Understandably, Peter is having\na rough time with the transition, but he’s trying his best to learn fast.\n Peter mentions that he has some questions about the documentation—mainly the\nlack of it. You’re surprised. Before you can get to the bottom of the problem, you read\nthe scenario in question. It’s about qualifying and scoring the best candidates when a\nproperty is vacant and no lease has yet been signed.\nFeature: Qualifying tenant leads\nScenario Outline: Screening candidates\nGiven a lead:\n| name\n| credit used | total debt |\n| Simona Jenkins | <used>\n| <debt>\n|\nAnd that the lead waits in the queue to the tenants pipeline\nWhen the candidate has a <score>\nThen we should <result> the lead\nExamples:\n| used | debt\n| score\n| result |\n| 40%\n| $202,704 | credit score of 499 | reject |\n| 41%\n| $202,704 | credit score of 500 | accept |\nYou then ask Peter what’s wrong.\n“I’m just confused,” he says. “There’s a lot of terminology that isn’t explained anywhere.\nFor example, what’s a tenants pipeline?”\n“It’s a list of verified tenants that landlords get … but I see your point. Are there any\nother issues you’ve noticed?”\n“Yes. Are screening and qualifying leads the same? And, while we’re at it, are tenant\nleads and candidates the same? Or is a candidate some special kind of a lead? Or maybe\nit’s the other way around.”\nListing 7.1\n[BAD] Executable specification with no documentation\n",
      "content_length": 2542,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 177,
      "content": "151\nLiving documentation in action\n“You’re right, that might be confusing. They’re actually the same. I suppose I didn’t want\nto use the same expression so often.”\n“Yeah. By the way, is the credit score rating the entire screening process? If so, why can’t it\nbe called a credit report? Why invent an additional name?”\n“Actually, the credit score is just one part of the screening process, which can involve other\nsteps as well. We just don’t support them right now.”\n“Oh, I see. That might not be obvious for some people, like me. And that might become a\nlarger issue in the future, because I noticed that we’re hiring more engineers from all over\nthe world. And renting doesn’t work the same everywhere!”\nAs you can see, there are several troublesome areas when it comes to the documenta-\ntion aspect of your scenario outline:\nYou need to make the naming consistent, making sure the same concepts are\nalways referred to by the same name. Doing so should remove the trouble with\ncandidates and leads, as well as screening and qualifying.\nWhen you first wrote the text, you had some assumptions about your team\nmembers’ prerequisite knowledge, regardless of their experience. The tenants\npipeline is an example. And even though screening is the main criterion for\nlandlords considering tenant leads, it’s not explained anywhere. That has to\nchange.\nSome domain concepts, like screening and credit scores, may be new to some\nteam members and difficult for them to understand. That means you didn’t\ntake into account the idiosyncrasies of your team when you wrote the scenario.\nIt’s out of touch.\nWhat could you do to change that? Here are some ideas.\nFeature: Screening tenant leads\nSCREENING is the process of evaluating a tenant lead before\nsigning a lease in order to choose the best candidate.\nTENANT LEAD is a potential tenant who applied to live in\nan apartment managed by our rental platform.\nPlease note that the manual screening process is more complex\nthan the one we currently support in our product. For example,\nin the future we might want to support checking criminal or\neviction history, or even terrorist watchlist search.\nScenario Outline: Screening tenant leads based on credit score\nListing 7.2\n[GOOD] Documented specification with fixed issues\n“Qualifying” is now called \n“screening” everywhere the \nconcept is mentioned.\nDefinition of “screening” supplied\nin the specification brief\nDefinition of\n“tenant lead”\nsupplied in the\nspecification\nbrief\nExplanation of the screening \nprocess’s business context and your \nteam’s progress on implementing it\nCandidates are now consistently\ncalled tenant leads.\n",
      "content_length": 2625,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 178,
      "content": "152\nCHAPTER 7\nLiving documentation\nTENANTS PIPELINE is a list of verified tenant\nleads a landlord can choose from.\nCredit score is calculated by an external auditor\nthrough their API and has a range of 300-850.\nGiven a tenant lead:\n| name\n| credit used | total debt |\n| Simona Jenkins | <used>\n| <debt>\n|\nAnd that the lead waits in the queue to the tenants pipeline\nWhen the tenant lead has a <score>\nThen we should <result> the lead\nExamples:\n| used | debt\n| score\n| result |\n| 40%\n| $202,704 | credit score of 499 | reject |\n| 41%\n| $202,704 | credit score of 500 | accept |\nLet’s sum up the changes:\nYou added a few short definitions that explain the most important domain con-\ncepts. This should ensure that every team member who reads the scenario,\nregardless of their experience, has more or less the same knowledge when they\nstart working with the specification.\nYou cleared up the naming issues so there’s no way to confuse a domain con-\ncept with any other domain concept.\nYou added notes about screening and the credit score that explain the business\ncontext of the feature. You let the reader know that you’re at the beginning of a\njourney to create a great screening process; even at this early stage, you need\nhelp from other companies who do credit reports and background checks,\nbecause those aren’t your company’s area of expertise.\nNote that although all of these changes could have been made earlier in the life cycle\nof the executable specification—when it was first written, for example—there’s noth-\ning wrong with the fact that the changes are only happening now, after Peter pointed\nthem out. That’s why we talk about a living documentation system. Such a system\nemploys feedback loops to correct itself over time. These feedback loops can be man-\nual—as in Peter’s case, when he had to read the specification before tackling a bug\nerror connected with that area of your product. But feedback loops can also be auto-\nmated. For example, if a particularly nasty bug breaks your continuous integration sys-\ntem periodically, you can progressively add more regression examples to ensure that\nthe system doesn’t break again. That, too, is documentation.\n You saw how such automated living documentation works in section 5.3.4, when we\ndiscussed boomerangs. Executable specifications can eventually stop boomerangs—\nfunctionalities that break every now and then—if you automate each new edge case as\na regression example.\nDefinition of “tenants pipeline” \nsupplied in the scenario brief\nExplanation of how a \ncredit score is calculated \nand what the range is\nCandidates are now\nconsistently called\ntenant leads.\n",
      "content_length": 2633,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 179,
      "content": "153\nWriting documentation\n In chapter 6, you saw automated living documentation in action when we dis-\ncussed iterating executable specifications over time. Section 6.1 showed that when a\ndelivery team implements a new executable specification, they should also execute\nexisting specifications in order to check whether they still work after changes are\nintroduced to the system. Only in this way can the team verify that the specification\nsuite is still consistent—and that the living documentation is up to date.\n Because previous chapters covered many areas related to automation, I focus here\non writing high-precision documentation instead of having up-to-date tests. In SBE,\niterations are the common thread between automated documentation and manual\ndocumentation. Either way, manual or automated, the living documentation system\nworks iteratively—so you can let go of the expectation that you should nail things\ndown on the first try every time.\nNOTE\nWhen I say living documentation in the context of this book, I mean that\nthe documentation changes along with the product; tests help to achieve this\nresult, but they aren’t the only component. Be aware that other authors may\nmean regression tests, discussed in chapters 6. \n7.2\nWriting documentation\nThe example in the previous section showed some documentation challenges and\npractical solutions to deal with them. Let’s now talk in depth about each of these\nmethods. You’ll see how to use them effectively and what their major use cases are.\n From a 50,000-foot view, Gherkin scenarios are high level and talk about the busi-\nness instead of technology specifics; as a result, business stakeholders will read and\ncontribute to them, which helps bridge the communication gap between delivery\nteams and the business. Because scenarios explain the most important user flows as\nwell as the inputs and outputs of features, high-level documentation for a business can\ndo two other important jobs:\nDocument the business domain for people who are unfamiliar with it\nDocument the delivery team’s decision-making process for future reference\nWithout business domain documentation, scenarios will be difficult for anyone unfa-\nmiliar with the product to understand. For example, let’s say I’m a product manager\nand you’re a new hire on the team. I’m onboarding you to the product. I could start\nby telling you about the steps needed to make the application generate a tenants pipe-\nline—you need to click here, write that, go there—but that doesn’t guarantee you’ll\nknow what the pipeline is. Sometimes seeing doesn’t equal understanding.\n Living documentation can include decision making because executable specifica-\ntions have a long life cycle that covers every phase of development. Scenarios can\nreflect decisions made in analysis, design, or development. The life cycle even expands\nbeyond implementation. When acceptance tests that are part of the continuous inte-\ngration process break, the specification suite prohibits integration or deployment, thus\n",
      "content_length": 3015,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 180,
      "content": "154\nCHAPTER 7\nLiving documentation\navoiding errors in production. Teams can use that to spot and document troublesome\nareas that break often. If any errors still slip through, they can be documented as\nregression tests later, after they’re fixed. Why should you do that? Because document-\ning the decision-making process will let you and your peers recreate your thought pro-\ncess in the future and make sure future decisions are consistent with past ones.\n Next, let’s explore documenting domain concepts and documenting decisions. \n7.3\nDefining important domain concepts\nThe two most popular and practical uses of any documentation are these:\nLearning about things you don’t know\nRecalling details you learned in the past but have forgotten\nFor example, if you hear somebody mention a domain concept called a price index, and\nyou have no idea what that means, you can check the documentation. And if you work\non that feature again in a few months, you’ll check the docs again to refresh your mem-\nory. Defining new concepts and making the definitions easy to find under quickly\nsearchable names is one of the most important jobs of any documentation.\n7.3.1\nWriting lexical definitions\nChapter 1 talked about the ubiquitous language: a common language for developers,\nbusiness stakeholders, and end users. To illustrate the concept of such a language and\nthe cost of mental translations, I talked about a public transport mobile app that sug-\ngested Edison Street to the user as a final destination, because it couldn’t fetch Edison\nBusiness Center—the user’s intended destination—from the database. The mistake\nhappened because the user and the developers associated different domain concepts\nwith the term destination. The delivery team thought of bus stops; but the user wanted\nto get to a specific place regardless of whether it was a bus stop, a street, or a building.\n In that case, a wrong definition led to wrong code. To avoid similar mistakes, the\nteam could add a refined definition to the executable scenario and use it as documen-\ntation for future reference.\n In the example of the real estate application at the beginning of this chapter, you\ndid a similar thing to clarify the domain concepts of screening, tenant leads, and a ten-\nants pipeline. Here’s a definition within a scenario outline:\nScenario Outline: Screening leads based on credit score\nTENANTS PIPELINE is a list of verified tenant\nleads a landlord can choose from.\nYou used the scenario brief to write a short note that explains what the pipeline is.\n(You also used the specification brief for the same reason with a second definition.)\nTruth be told, this isn’t the most advanced definition in the history of definitions—it’s\na simple clarification that gives the reader more context. When it comes to the art of\n",
      "content_length": 2798,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 181,
      "content": "155\nDefining important domain concepts\ndefinitions, Gherkin favors a utilitarian approach: use anything that works for your\nteam, and refine it in case of any misunderstandings.\nTIP\nWrite lexical definitions in specification and scenario briefs when you\nwant to explain a domain concept in your own words. Use specification briefs\nfor global definitions that are important to the entire specification. Use sce-\nnario briefs for local definitions that are relevant to specific scenarios only.\nBecause specification and scenario briefs are free-flowing text sections in Gherkin’s\nsyntax, there’s no specific way to format definitions. Many Gherkin practitioners use\nsystems like Markdown, with its headings and text formatting. Personally, I favor com-\nmon text files, using uppercase to define new domain concepts. The choice is almost\nentirely aesthetic, but I also like that it’s the simplest possible way to make definitions\nstand out—you don’t have to know a formatting system to see that a brief includes\nsomething important.\nExercise 1\nCreate a short definition that explains what a scenario outline is.\nUsing connotative definitions\nDefinitions used in this section are called connotative definitions. A connotative defi-\nnition specifies the necessary and sufficient conditions for a thing to be a member\nof a specific set.\nHere are two examples of connotative definitions:\nTriangle: a plane figure that has three straight bounding sides\nQuadrilateral: a plane figure that has four straight bounding sides\nAs you can see, connotative meaning relates to the associations, overtones, and feel\nof a concept, rather than what it refers to explicitly—which is what denotative defini-\ntions do.\nIn terms of logic, connotative definitions create a decision tree of questions whose\nanswers can be used to state whether an objects fits the definition. For example, in\nthe case of the definition of a triangle, you can ask two questions that let you define\nwhether any object is a triangle. The first question is whether the object is a plane\nfigure. If it isn’t, it can’t be a triangle. If the object is a plane figure, you need to ask\nthe second question: whether the object has three straight bounding sides. If it does,\nit can’t be a triangle—but only in terms of pure logic, of course. (And every person\nwho has ever built software knows how difficult it can be to find perfect boundary con-\nditions while also taking care of all the edge cases and exceptions.)\n",
      "content_length": 2466,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 182,
      "content": "156\nCHAPTER 7\nLiving documentation\n7.3.2\nWriting illustrative definitions\nOther ways to define a domain concept can also be considered. Sometimes, it may be\ntoo difficult to write a clear, concise definition that captures the essence of a problem.\nIn that case, you can use the second popular way to create definitions: illustrating, list-\ning examples that belong to the set you’re trying to define. Gherkin works great with\nthis method, because illustrating is Gherkin’s core job. Even the term specification by\nexample reflects that.\n Let’s look at how you can use a definition by example. Suppose the HouseKeeper\napp can work with multiple types of tenancies, by which I mean that some landlords\nwant to rent an entire apartment, some want to rent a single bedroom, and others\nrent a single bed in a shared bedroom. You could try to define these tenancies under\nthe umbrella term housing unit, and you could try to define units the same way you did\nwith the previous definitions. For example, you might say that a unit is a place where\nthe occupants live and eat separately from other residents in the structure or building.\nBut is that the best approach? It sounds horribly abstract.\n Instead, you can create an illustrative scenario that lists all the types of units. This\nway, the scenario itself becomes a definition of a domain concept. Here’s how that\nmight look.\n(continued)\nThe type of connotative definition used in the previous examples of a triangle and a\nquadrilateral is called a genus-differentia definition. It’s a type of definition that takes\na large category (the genus) and narrows it down to a smaller category based on a\ndistinguishing characteristic (the differentia). For the triangle definition, the genus is\nplane figure and the differentia is with three straight bounding sides: three bounding\nsides are what distinguish triangles from quadrilaterals, which have four bounding\nsides, and other plane figures, which have even more. \nPlane figure\nEssence\nNot a plane figure\nThree straight\nbounding sides\nTriangle\nNot three straight\nbounding sides\nThe decision tree of a connotative \ndefinition of a triangle\n",
      "content_length": 2136,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 183,
      "content": "157\nDefining important domain concepts\nFeature: Units\nScenario Outline: Defining types of units\nGiven a <unit>\nWhen a new tenant moves in\nThen the tenant should have a lease on <rent>\nExamples:\n| unit\n| rent\n|\n| apartment\n| the entire flat\n|\n| room\n| their room only\n|\n| shared bedroom | share the rent with a roommate |\nThis scenario outline isn’t a great test. It’s simple, like the definitions you created\nbefore, and it doesn’t test anything mission critical. But it does its job well: it illustrates\nby example a new domain concept better than you could define the concept with an\nabstract definition.\nTIP\nUse a definition by example when it’s easier to imagine and understand\nthe properties of a given set of items by listing the items within that set than\nby trying to capture the set’s essence with a concise definition in the specifica-\ntion brief.\nListing 7.3\nDefining by example using a scenario outline\nExercise 2\nCreate a definition by example that will define the concept of Gherkin keywords like\nGiven, When, and Then.\nUsing denotative definitions\nDefinitions by example can also be called denotative definitions. A denotative defini-\ntion means a list that names the objects that belong to the set being defined; for\nexample, “A plane figure is something like circles, triangles, squares, rectangles, and\nso on.” Denotative definitions are practical; they state what is, as is.\nThey can be inefficient, though—for example, a complete list of plane figures will be\nlong. A connotative definition creates a hierarchical decision tree of investigative\nquestions, whereas a denotative definition creates a flat decision tree of all possibil-\nities in a given set—a plane figure can be a circle or a triangle, or a square, or a rect-\nangle, and so on. The listing is safer, because the only thing you have to do is to\ncheck whether an item belongs to the specified set, but it’s also longer and more\ndifficult to maintain in the long run. The list can grow or shrink; you have to keep it\nup to date. \n",
      "content_length": 2012,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 184,
      "content": "158\nCHAPTER 7\nLiving documentation\n7.3.3\nUsing glossaries\nAlthough putting a definition in a scenario that required clarification in the first place\ncomes naturally, it also has some downsides. The most obvious is that various scenarios\ncan mention the same domain concepts multiple times throughout the specification\nsuite. For example, the scenario outline used in this chapter’s main example mentions\na tenants pipeline, so you put the definition there; but if you had to deal with the com-\nplete specification suite of the HouseKeeper application, you’d probably have to men-\ntion the pipeline in many other feature files, too. Should you define each domain\nconcept from scratch in every scenario that mentions it? If you did so, you’d quickly\ndiscover that having so many definitions is difficult to maintain over time.\n One way to solve the dilemma is to define a domain concept only in the scenario in\nwhich it originates. In that case, you’ll only have a definition for the tenants pipeline in\nthe scenario outline about tenant leads from this chapter—because that’s where the\nconcept appears for the first time in the domain. This isn’t the perfect solution,\nthough, because it forces readers to search for the definition in other feature files. But\nformatting definitions in a consistent way may make searching the specification suite\nmuch easier.\n Another approach is to quit writing definitions in the briefs and instead create a\nseparate file in the specification suite that contains all the definitions. Such a file can\nfunction as the project’s glossary. It doesn’t even have to be written in Gherkin; if you\nwrite a simple .txt file (or perhaps a .md document formatted in Markdown), every\ntest runner will ignore it during validation. I’ve used glossaries several times and been\nhappy with the results, especially in projects with complex domains where concepts\nrequired frequent clarification. The downside of having a glossary is that maintaining\nit requires additional effort; a plain text file isn’t connected to the automation system\nthat keeps the living documentation up to date. Whenever you change a scenario in a\nway that redefines a corresponding domain concept, you must remember to update\nits definition in the glossary—which is more difficult because the definition is no lon-\nger in the same file and can’t serve as an obvious reminder.\nNOTE\nWe’ll come back to the concept of glossaries in chapter 11. The prob-\nlem with glossaries is that they depend heavily on context. For example, a sin-\ngle term can have multiple meanings, depending on context. Such terms are\ncalled polysemes. In chapter 11, you’ll learn how to deal with polysemes and\ncreate unequivocal glossaries. \n7.3.4\nNaming important domain concepts\nClosely connected to the area of definitions is naming. Naming domain concepts\nappropriately is important because people involved in development may call the same\nconcept by the same or different names, which can lead to potentially disastrous mis-\nunderstandings. You saw something like this in the HouseKeeper project, when Peter\nwasn’t sure whether screening and the process of qualifying tenants were the same; he\nhad similar doubts regarding candidates and tenant leads.\n",
      "content_length": 3222,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 185,
      "content": "159\nDefining important domain concepts\nTIP\nA single domain concept should always be referred to by the same\nname. Even slight changes in naming can cause people to wonder whether\nthey’re dealing with an existing domain concept or a new one—is it the\nsame, or similar but slightly different? There’s no way to know without addi-\ntional clarification.\nNames have power. As the saying goes, “There are only two hard things in computer\nscience: cache invalidation and naming things.” A lot of the effort involved in writing\nGherkin also concerns naming, because Gherkin is a domain-specific language that\nlooks similar to plain, business-readable speech. And, as in any language, Gherkin\nwriters must be careful when creating or giving names.\nTIP\nDon’t invent a new name if you’re modeling a domain concept that\nexists in the real world outside of your application. Delivery teams should\nstrive to understand and use the language of domain experts and not replace\nit with their own technical language. For example, don’t call screening some-\nthing like validating candidates, even if you think it’s a better name for what’s\ngoing on behind the scenes in the backend. (You can use your own names for\ndomain concepts that the delivery team invented to help users do their jobs\nmore quickly and easily.)\nIn Gherkin, naming has three crucial areas: naming actors, naming actions, and nam-\ning beginning and ending states.\nNAMING THE ACTORS THAT APPEAR IN SCENARIOS\nLet’s say you have two scenarios that are unrelated to each other. The first scenario\nmentions Simona Jenkins, who is an admin in the application. The second scenario\ntalks about Adam Johnstone but calls him a user with admin privileges. Are admins\nand users with admin privileges the same or different? The reader of the scenarios can\nonly assume. And you know what they say about assuming ... \nNAMING THE ACTIONS IN SCENARIOS\nI talked about naming actions with regard to screening and qualifying tenant leads. In\nthe example domain, these two terms describe the same activity. They have different\nnames, though, which made Peter think they might be two separate, although related,\ndomain concepts. \nNAMING THE STATES IN WHICH SCENARIOS BEGIN AND END\nIn the strictest sense of the word state, the subsection on naming actors inferred states:\ntwo actors were in the state of having an admin account. Similar inconsistencies hap-\npen so often that I wanted to talk about them separately. But there are also problems\nwith naming other states.\n For example, you should focus on maintaining consistency between initial states and\nexpected states. The initial state is set in the Givens and talks about how things look at\nthe beginning of a scenario. The expected state is the state at the end of the scenario,\nwhen the change described in the main action of the steps has taken place. Initial states\nand expected states are extremely important to the testing aspect of each executable\n",
      "content_length": 2938,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 186,
      "content": "160\nCHAPTER 7\nLiving documentation\nspecification. They tell testers and developers the intended consequences behind the\nscenario—the consequences they have to make sure take place. So naming the same\nstate one way when it’s an initial state and another way when it’s an expected state can\nresult in misunderstood features and rework.\nTIP\nYou should favor simple names that are easy to search for. Doing so will\ncome in handy when you have to find a single definition in a huge specifica-\ntion suite. \n7.4\nDocumenting decisions using briefs\nIn section 7.2.1, you saw how specification and scenario briefs can contain useful\ninformation such as definitions. Specification and scenario briefs are versatile; they\ncan contain any free-flowing information—and because the life cycle of an executable\nspecification is long, starting in the analysis phase and expanding even beyond the\nimplementation phase, you may want to include information in addition to defini-\ntions. For example, you could explain why you wrote a scenario the way you wrote it,\nor you could give some context about the scope of the feature. These decisions can\nalso be documented in briefs, in several ways.\n7.4.1\nUsing warning notes to highlight problematic areas\nA warning note is meant to highlight troublesome areas of any given specification. A\nwarning can indicate, for instance, difficult testing or implementation issues that\nshouldn’t be missed if the delivery team decides to rework the feature.\n Here’s an example of a warning note. You may have seen it before, because it’s a\npopular joke, but it always makes me smile:\nOnce you are done trying to 'optimize' this routine,\nand have realized what a terrible mistake that was,\nplease increment the following counter as a warning\nto the next guy:\ntotal_hours_wasted_here = 42\nThis warning note was originally a code comment, which makes it ineligible for a\nbusiness-level specification suite, but I mention it because you can have similar warn-\nings for domain concepts and requirements. For instance, section 5.3.4 discussed\nboomerangs (functionalities that break repeatedly) as a good source of examples for\nscenarios. A warning note in the table brief would be perfect to explain the context\nbehind any given boomerang and maybe give some tips to the maintainers about how\nto avoid repeating mistakes the team made in the past. \n7.4.2\nUsing context notes to deepen the business context\nContext notes explain the details of a feature’s business context. You can use them to\nelaborate on the current scope of the functionality, talk about industry standards,\nmake a quick analysis of similar features used by competitors, or describe the circum-\nstances of taking on the feature in the first place.\n",
      "content_length": 2726,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 187,
      "content": "161\nHigh-level overview of the documentation process\n The HouseKeeper example uses a context note when the specification brief\nexplains the minimized scope of the screening feature, which, in this case, only covers\ncredit score reports:\nPlease note that the manual screening process is more complex\nthan the one we currently support in our product. For example,\nin the future we might want to support checking criminal or\neviction history, or even terrorist watchlist search.\n7.4.3\nUsing maintenance notes for internal purposes\nBy maintenance notes, I mean notes that aren’t related to the functionality itself.\nInstead, they help readers navigate the specification suite and maintain it in the long\nterm if they choose to edit a scenario or add a new Gherkin file.\n A maintenance note is a meta-note. It doesn’t elaborate on any particular step in\nthe scenario; it talks about the scenario itself. For example, it can explain where cer-\ntain scenarios are located or why they were split between various Gherkin documents\nin a certain way:\nSince screening is a huge functionality, this\nspecification file describes only the most important\nhigh-level scenarios.\nYou can find more detailed scenarios in the rest\nof the files inside the \"screening\" folder in the\nspecification suite.\n7.5\nHigh-level overview of the documentation process\nSo far, this chapter has taken you on a whirlwind tour of the most important docu-\nmentation techniques an SBE practitioner may want to use. But when you’re working\nday to day with real teams, knowing the techniques may not be enough. Knowing that\nyou can document product changes using notes is different than knowing when to doc-\nument these changes and when not to document them. Both of these questions can be\nequally important, and the answers can vary depending on the particular team. Some\nteams may need more documentation; some teams need less. Every team needs differ-\nent documentation. In this section, I’ll talk about how to understand your team’s idio-\nsyncrasies, choose the best strategy to achieve your documentation goals, and tweak\nthe content of your scenarios so everyone on your team can benefit from the docu-\nmentation.\n From a high-level perspective, the main purpose of documentation is communica-\ntion. Documentation can communicate relevant instructions and applications, dan-\ngerous bottlenecks, potential issues, and proven solutions.\n In communications theory, a message is the smallest unit of communication. Every\nmessage is made out of three elements:\nSender\nReceiver\nContent\n",
      "content_length": 2547,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 188,
      "content": "162\nCHAPTER 7\nLiving documentation\nFigure 7.1 illustrates these three elements.\n We can translate such a diagram to the domain of SBE as follows:\nA sender is anybody who writes documentation.\nA receiver is anybody who reads the documentation, intending to use it in work.\nContent means Gherkin scenarios that are refined and precise enough to be\nused not only as short-term specifications but also as long-term documentation.\nI’ve already talked about the techniques you can use to create fine documentation\ncontent. You were able to do so thanks to a well-defined example. The example,\nthough, is always just an example; it’s a static snapshot of an imaginary application\nthat’s designed to be easy to digest in order to facilitate learning. The real world is\nmessier.\n While working with your documentation, you may feel the urge to jump straight to\nwriting the content of your scenarios, as you did earlier. This isn’t always a good idea.\nIn this section, I’ll argue that senders and receivers can greatly influence the final\nshape of living documentation, and—if these elements aren’t given enough care—not\nalways in a positive way. Even a crafted message can be met with a dismissive shrug if\nthe message isn’t tailored to the audience, highlighting passages they’re most likely to\nagree with. On the other hand, sometimes a good message with a well-defined audi-\nence misses its mark because the sender wasn’t the right person to drive its point\nhome. Think of a politician who runs on a platform of getting rid of corrupt officials\nin a country where corruption is the number-one issue—but at the same time, that\npolitician has a history of corruption scandals.\n To create great documentation, you need three elements: people who can create a\nmeaningful message, a well-defined audience, and engaging content that’s full of\nhelpful tips (see figure 7.2). I covered the topic of engaging content at the beginning\nof this chapter, when describing useful documentation techniques, and in the other\nchapters, when I talked about writing great scenarios. Now let’s look at writers and\nreaders.\nSender\nMessage\nReceiver\nContent\nFigure 7.1\nThe general \nschema of communication\n",
      "content_length": 2179,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 189,
      "content": "163\nWho creates living documentation?\n  \n7.6\nWho creates living documentation?\nTraditionally, professionals whose field of work is documentation are technical writers\nand corporate communicators. A technical writer is a professional writer who pro-\nduces technical documentation. Technical writers can sometimes be domain experts\nwho know the ins and outs of the business they’re writing about. Most of the time,\nthough, they collaborate with domain experts, engineers, and—if documentation is\npublicly available—end users to create full documentation.\n Why are communication and collaboration important? Melvin Conway had a good\nanswer. He was the computer programmer behind Conway’s Law, which is an adage\nintroduced in 1968: “Organizations that design systems are constrained to produce\ndesigns that are copies of the communication structures of these organizations.” In\nother words, healthy communication produces healthy designs—and dysfunctional\ncommunication produces dysfunctional designs.\n With Gherkin, documentation is a result of the entire team’s work and is every-\nbody’s responsibility. Every engineer, designer, analyst, and tester can write Gherkin\ndocumentation, just as anyone can write or edit scenarios. It’s not only encouraged;\nsometimes it’s necessary. SBE is a process that by definition requires interdisciplinary\ncollaboration. Most of the time, analysts and designers can provide the correct behav-\nior—but developers and testers know the best way to write a test so that it’s easy to\nautomate later and fits into the rest of the living documentation system.\n If analysts or designers worked alone, they would most likely write brittle tests. If\ndevelopers and testers worked alone, they would probably optimize for automation\ntoo much and write scenarios that were difficult for nonprogrammers to understand.\nBalance is key.\nWho writes it\n and when?\nDelivery team when\nthey must make\nnew decisions\nParticipants of the\nworkshops before\nimplementation\nLiving\ndocumentation\nWho reads it\n and when?\nExisting team\nmembers when they\nrevisit the features\nNew team\nmembers during\nonboarding\nWhat’s the\ncontent?\nDocumentation of\nthe on-the-fly\ndecision making\nDocumentation \nof the business \ndomain\nFigure 7.2\nWhen working \nwith a living documentation \nsystem, you must take into \naccount three aspects: the \npeople who create the \ndocumentation, the people \nwho will read it, and the kind \nof content that should be \ncreated by the former to \nsatisfy the latter.\n",
      "content_length": 2484,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 190,
      "content": "164\nCHAPTER 7\nLiving documentation\n7.6.1\nCreating documentation through all-team \nspecification workshops\nSection 1.5.3 talked about how SBE encourages you to specify collaboratively by invit-\ning stakeholders to specification workshops or holding smaller, more regular meet-\nings within the delivery team. Because automated tests let specifications become\ndocumentation, the same workshops can be used to work on the most important\naspects of future documentation: for example, clarifying difficult domain concepts.\n Big, all-team workshops can help teams that have recently started working with SBE.\nThey’re intense domain- and scope-exploration exercises. Although most of the time\nin workshops is spent collecting relevant examples and building the short-term under-\nstanding required for the delivery team to kick off development, you can just as easily\ndesign exercises to facilitate long-term learning that later pays off in documentation.\n For example, one of the most effective exercises I’ve ever seen has participants\nwrite in their own words a definition for a particular domain concept—while forbid-\nding them to talk to each other. Comparing differences in definitions almost always\nyields interesting results and gets everyone on the same page.\n Another interesting exercise is to delegate one person to be a note taker and later\nuse the notes in creating documentation. Having a single delegate often frees the\nother participants to fully immerse themselves in the workshop, although having\nmore people taking notes is also fine.\nTIP\nIf you need more inspiration for conducting workshops, read Gamestorm-\ning: A Playbook for Innovators, Rulebreakers, and Changemakers by Dave Gray,\nSunni Brown, and James Macanufo (O’Reilly Media, 2010). The book\nincludes more than 80 games to help you break down barriers, communicate\nbetter, and generate new ideas, insights, and strategies. The authors have\nidentified tools and techniques from some of the world’s most innovative pro-\nfessionals, whose teams collaborate and make great things happen. \n7.6.2\nCreating documentation through Three Amigos meetings\nTeams who’ve been doing SBE for a while don’t need as much time or as many people\nin their workshops. They often opt to hold smaller meetings and include only the peo-\nple who are required. For example, a team may choose to delegate a developer, a tes-\nter, and a designer or an analyst to represent each of the key roles required to ship the\nright software.\n Such meetings are typically called Three Amigos meetings and are run when the\ndomain still requires frequent clarification, but the most important stakeholders\naren’t available on demand. Such meetings yield most of the benefits of big, all-team\nworkshops while being much leaner, faster, and easier to organize; but they require\nadditional effort to get the delivery team and the business stakeholders on the same\npage if a stakeholder representative such as a product owner isn’t present.\n At the same time, the Three Amigos have to be careful not to force their ideas, per-\nspectives, and experiences on others by remembering that they only represent the\n",
      "content_length": 3133,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 191,
      "content": "165\nWho creates living documentation?\ndelivery team. For example, it can be easy for the Amigos to document one area well\nbecause they find it interesting, while leaving other areas unexplored because they\nunderstood them intuitively. It’s a good idea not to have the same people be the\nAmigos repeatedly and instead to change the squad from time to time.\n If you choose the right participants, workshops—both big and small—can be a\ngreat step to fight information asymmetry. Chapter 1 defined information asymmetry as\na situation where one party has more or better information than another. Such asym-\nmetry can sometimes drastically impair the delivery team’s ability to make indepen-\ndent decisions in the face of a crisis. Good workshops naturally reduce information\nasymmetry among the participants; but the best workshops leave a long-term imprint,\nusually in written form, that can help people who weren’t present during the meeting. \n7.6.3\nCreating documentation through individual people\nDocumentation can also be written by a single individual chosen by the team. That may\nbe, for example, the most experienced developer on the team or the only analyst who\nhas direct access to the client because of the way the organization is structured and\nmanaged. I played such a role in some of the projects I worked on; I worked on prepar-\ning detailed examples and documenting new domain concepts ahead of the team.\n This isn’t necessarily a bad practice, even though it may sound like it. After all, isn’t\nSBE all about collaboration? It is—but having a single person work ahead of the team\ndoesn’t rule out collaboration. That person can speed up development by laying a\nfoundation for future work while the rest of the team is still working on the current\niteration.\n A problem emerges when the person becomes a single source of truth about require-\nments by controlling the flow of information between business stakeholders and the\ndelivery team. For example, they may want to present their perspective on a particular\ndomain concept as the only way to understand it correctly. In such a case, the single\nsource of truth can easily become a single source of failure. Both the person who’s\nworking ahead and the delivery team must be aware of that.\nNOTE\nKeeping the rest of the team in the loop and reviewing the new domain\nconcepts shortly after the initial analysis is done are good steps toward elimi-\nnating the possibility of a single point of failure, but reducing bottlenecks is\nmore of a management topic and beyond the scope of this book. If you’re\ninterested, you can read Elastic Leadership: Growing Self-Organizing Teams by Roy\nOsherove (Manning, 2016); chapter 3 in the book, “Bus Factors,” talks about\nbottlenecks and how to eliminate them.\nSometimes a single person can write documentation after development, too. Chapter 6\nexamined SBE as an iterative process that starts when the delivery team is still highly\nuncertain about implementation detail. Writing documentation in such conditions, at\nthe beginning of the process, can be wasteful because the delivery team is probably\nwrong about some things. For example, a delivery team working with a corporation’s\nlegacy software can be sufficiently sure of the requirements even early in development,\n",
      "content_length": 3270,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 192,
      "content": "166\nCHAPTER 7\nLiving documentation\nbecause a big company has established processes. But almost every time you work on\nsomething new, whether for a corporation or a startup, things will be less certain. A\nteam may hold workshops and draft some scenarios without worrying about long-term\ndefinitions and notes; these can be added later, as the living documentation evolves\nalong with the feature.\n Unfortunately, in the real world, most teams can’t afford the luxury of holding\nanother workshop with several participants to work on documentation after a feature\nis implemented. Teams that can’t work on documentation collaboratively early in the\nprocess must train designers, testers, programmers, and analysts to write documenta-\ntion iteratively. Let me give you an example of what I mean when I say iteratively. Let’s\nsay a programmer was delegated to fix a bug that resulted from a misunderstanding of\na domain concept. That programmer may work on the bug alone. The programmer\nshould be able not only to fix the bug but also to fix the scenarios by clarifying the rel-\nevant domain concept and, therefore, making sure nobody repeats the same mistake\nin the future. They must either write the documentation with enough empathy to\nkeep less technical teammates in mind or be communicative enough to find and\nengage other viewpoints as they make the changes, thus making the effort more\ncollaborative. \n7.7\nChoosing the right audience for living documentation\nBefore you can start thinking about writing documentation, you need to consider who\nyou want to document for. Do you remember the last time you read well-written docu-\nmentation? As you were reading, did the text seem to know most of the questions you\nwere going to ask, and address most of the doubts in your mind? That’s how it should\nbe if the authors considered their audience. This section talks about techniques that\ncan help you become such an author.\n A single warning before we start—when you hold specification workshops fre-\nquently, you may think you’re covered in terms of including diverse perspectives in\nyour documentation. That may be true with regard to technical skill if testers, design-\ners, developers, and analysts collaborate during the workshops. But there are other\naspects you may want to consider. For example, I think we can agree that it’s reason-\nable to choose senior personnel to run Three Amigos meetings and write new scenar-\nios. After all, they’re the most likely to analyze requirements correctly due to their\nexperience and skill. The problem is, they may write scenarios for junior and mid-\nlevel personnel and lose track of what other team members need from the specifica-\ntion. The reason is the same as the reason you chose them in the first place—their\nexperience and skill. Their seniority may cause them to underestimate some issues\nand focus on others, which they consider interesting or worth tackling.\n7.7.1\nWho’s a minimally qualified reader?\nAmong its many useful purposes, documentation is a teaching tool. By documenting\nfeatures, user stories, and code, you teach readers everything they need to know to get\n",
      "content_length": 3122,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 193,
      "content": "167\nChoosing the right audience for living documentation\nthe feature to work. It seems logical, then, to draw some inspiration for creating better\nliving documentations from the realm of education. But in school, everyone learns at\na different pace—for example, students who are curious may already know some of\nthe material from other sources. Even if we come from similar backgrounds, every-\nbody’s knowledge base is a little different. Yet the textbook is the same for all students.\n To do their jobs well, authors who write textbooks must first establish a baseline of\nknowledge and skills that every student must possess in order to successfully complete\nthe course. Only if they do so will they know which skills need to be covered in detail,\nforming the main body of the text. If they don’t, the results will be catastrophic. To\nunderstand why, let’s consider an average student in an average class. Being average\nmeans half of the students are doing worse than the chosen student and half of them\nare doing better—which means if the textbook was written for the average student, at\nleast half of the kids will find it more or less difficult to read. That’s why textbook\nauthors spend a lot of time thinking about the right minimally qualified reader (MQR)\nand write as if for that person only, keeping in mind what that person likely does and\ndoesn’t know.\nDEFINITION\nMinimally qualified reader (MQR)—The persona of a typical stu-\ndent with the basic skills needed to benefit from the information. Knowing\nthe MQR means understanding what that person already knows, and teaching\nwhat that person doesn’t yet know. Defining the reader is an essential part of\nmaking good, useful living documentation.\n7.7.2\nFinding the perfect MQR in an organization\nJust like students, people on teams and in organizations aren’t uniform. For example,\nlet’s consider a junior-level engineer, straight out of college, who joined the team a\nfew months ago; an analyst who’s fairly senior but as a new hire hasn’t yet fully grasped\nthe business domain; a mid-level designer; and a senior tester who has been around\nforever and knows the ins and outs of the system. They all have different work experi-\nences and skills. How can you write documentation for all of them?\n Each profession—engineer, analyst, designer, and tester—already has its own doc-\numentation. Engineers can document their work with code comments or architecture\ndiagrams. Analysts also use diagrams, and they can write user stories or use cases.\nDesigners build design systems that explain their decisions and make sure elements\nand styles are used consistently. Testers document their work by building matrices for\nmanual tests, refining acceptance criteria, and writing down bugs and errors by creat-\ning regression tests.\n Engineers write documentation for other engineers, analysts write for other ana-\nlysts, designers write for other designers, and testers write for other testers. But living\ndocumentation is documentation that can and should be written by all the team mem-\nbers. The content is different, too. Gherkin scenarios talk about business features, the\nbusiness domain, and broad-concept examples, which may be new and difficult for\nthe delivery team to understand, regardless of their role and technical skill.\n",
      "content_length": 3288,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 194,
      "content": "168\nCHAPTER 7\nLiving documentation\n So living documentation can be written by all the team members as well as written for\nall the team members. But if everyone on the team is the audience, how do you\nchoose the MQR? In the previous section, I told you that it’s a good practice to write as\nif for that person only, keeping in mind what that person likely does and doesn’t\nknow. In my experience, it’s best to choose an actual person in your organization as\nthe MQR, because you can always run your scenarios past that person, watch the reac-\ntion, and then revise accordingly.\n How do you spot that person? What criteria should you look for?\n The MQR should\nBe experienced enough to be confident in their craft, so you don’t feel the urge\nto explain any universal solutions, either in design or in technology.\nHave at least some technical understanding due to working with a technical\nteam, but programming skills aren’t necessary.\nBe new to the business domain. It’s expected that the MQR doesn’t know the\nterminology, business-related concepts, industry standards and regulations,\ncompany workflows, or competitive advantages.\nTIP\nThe MQR should be a mid-level new hire who knows the basics of their\ncraft but doesn’t yet understand the business domain of the project. The ideal\nperson is a basic, solid programmer, designer, analyst, or tester who maybe\nhas a couple of years on the job.\nThinking about the MQR, you can also consider creating a list of prerequisites to\nexplicitly define the areas of knowledge your team members must have before work-\ning with the specification suite. Creating such a list is usually unnecessary when you’re\ndealing with easier business domains that the team thinks they know well, but some-\ntimes such a list can be of help in projects that are more difficult.\nWhen dealing with any particular feature, you may want to think about the takeaways\nyou want future readers to understand. Defining the takeaways up front will let you\ndecide on the best method for teaching the reader each skill. Some takeaways will\nExercise 3\nFind a good MQR in your organization. Can you think of anyone? They may be a\ncoworker sitting at the desk next to you.\nExercise 4\nBased on the HouseKeeper example, make a list of three to five domain prerequi-\nsites for your team in your latest project. Are you sure the MQR will know all of them?\n",
      "content_length": 2361,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 195,
      "content": "169\nSummary\nrequire their own scenarios; some will work well as examples within other scenarios;\nand others just need a short note in the specification brief or the scenario briefs.\n7.8\nAnswers to exercises\nEXERCISE 1\nCreate a short definition that explains what a scenario outline is:\nA scenario outline is a scenario that can take multiple examples at once.\nEXERCISE 2\nCreate a definition by example that will define the concept of Gherkin\nkeywords like Given, When, and Then:\nA Gherkin keyword is any special word like Given, When, Then, But, And, Scenario,\nFeature, and so on. Keywords are always placed at the beginning of a new line.\nEXERCISE 3\nFind a good MQR in your organization:\nIt’s tricky to provide an answer for this exercise, but I’ll try. A good MQR in my last\nmedium-sized project was Mark, a great programmer who recently joined the company but\nhad no idea about the products we were working with, because we were an agency and\nhad multiple rotating clients. Mark, if you’re reading this—hello!\nEXERCISE 4\nBased on the HouseKeeper example, make a list of three to five domain\nprerequisites for your team in your latest project:\nWhat property management is\nRental process differences in the countries you support\nThe details of signing a lease\nEXERCISE 5\nMake a list of takeaways for the screening feature from listing 7.2:\nA reader should know what the screening process is.\nA reader should know what you’re screening for.\nA reader should know what you don’t screen for and why.\nA reader should know what a credit score is.\nA reader should know when a candidate is accepted.\n7.9\nSummary\nLiving documentation is documentation that changes along with the system it\ndescribes.\nGherkin can document the business domain for people unfamiliar with it or\ndocument the delivery team’s decision-making process for future reference.\nExercise 5\nMake a list of takeaways for the screening feature from listing 7.2. \n",
      "content_length": 1932,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 196,
      "content": "170\nCHAPTER 7\nLiving documentation\nA lexical definition explains domain concepts in specification briefs and sce-\nnario briefs.\nA definition by example is a list naming the objects that belong to the set being\ndefined.\nA single domain concept—such as an actor, an action, or a state—should always\nbe called by the same name throughout the specification suite, to avoid confu-\nsion and misunderstandings.\nSpecification briefs and scenario briefs can be used to document various deci-\nsions made during the development process for future reference, including\nbusiness context, warnings, and maintenance notes.\nCreating Gherkin documentation is an iterative process that starts during team\nworkshops. The documentation is progressively refined as the feature evolves.\nA minimally qualified reader (MQR) is a persona of a person in your organiza-\ntion with the basic skills needed to benefit from the documentation on their\nown.\nA good MQR is a mid-level new hire who knows the basics of their craft but\ndoesn’t yet understand the business domain of the project.\n",
      "content_length": 1066,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 197,
      "content": "Part 2\nManaging\nspecification suites\nThis part of this book is a four-chapter series about managing specification\nsuites. Chapter 8 talks about organizing scenarios into specifications. Chapter 9\nexamines refactoring large specifications into smaller ones, chapter 10 discusses\ndesigning domain models in a specification suite, and chapter 11 talks about\nmanaging multiple domain models in large projects.\n Unlike in part 1, each chapter in part 2 discusses the same example: Activi-\ntee, an online platform for Fortune 500 companies that want to achieve better\nbusiness results by improving employee engagement. Whether a company is\nlooking to enhance health and wellness or foster team building, the HR depart-\nment can tap into Activitee’s extensive library of suggested events or charge up\nexisting internal team events—like company retreats and annual staff picnics.\n",
      "content_length": 872,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 199,
      "content": "173\nOrganizing scenarios\ninto a specification suite\nI remember one particular specification my team and I worked on. The scenarios\nwere meant to describe a highly personalized management panel for the organiza-\ntion’s key performance indicators (KPIs). We started with a few KPIs and no option\nto combine them to create custom reports. Putting the scenarios in a single feature\nfile seemed an obvious choice back then—but in the end, that turned out to have\nbeen a bad decision.\n The file kept growing as new KPIs appeared. At the time, we didn’t recognize\nthe difference between exhaustive and illustrative examples, so we tested too many\nThis chapter covers\nOrganizing scenarios into specifications\nOrganizing specifications by outcome and \nstakeholder\nWorking with functional and nonfunctional \nrequirements\nChoosing among features, abilities, and business \nneeds\n",
      "content_length": 871,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 200,
      "content": "174\nCHAPTER 8\nOrganizing scenarios into a specification suite\ncombinations. The specification ended up being unreadable. It had 508 lines of\ntext—about 10 times as many as the longest ones you’ve seen in this book so far. When\nwe finally rewrote the specification, we found that we had specified the same option in\ntwo separate scenarios because we hadn’t noticed that a similar example already\nexisted. If we’d had a different, more focused organization system, we would have\nbeen able to consider the granularity of our scenarios from the start.\n These are the types of issues discussed in this chapter, and for good reason. If all of\nthe 50 or so scenarios in part 1 were written for the same project, you’d end up with a\nrespectable specification suite. But real projects can have hundreds or even thousands\nof scenarios, depending on the size of the product. They have to be organized some-\nhow—a real specification suite is never just a single feature file. I’ve blissfully skipped\nover such challenges so far, because each chapter in part 1 deals with a single feature\nfile. Such conditions exist only in training exercises, though.\n The sections to come focus on the topic of organizing scenarios into specifications.\nWe’ll analyze two methods:\nOrganizing scenarios by features—Cucumber-flavored Gherkin’s default method of\norganization\nOrganizing scenarios by user stories—The default for other SBE tools, but only an\nunofficial (although popular) method in the Gherkin community\nIn this chapter, we’ll determine that the second method is better when it comes to spec-\nifying requirements. We’ll also discuss choosing the correct granularity level for speci-\nfications based on user stories, to make sure your scenarios don’t get out of control.\n To create a more complete theory of organizing requirements, we’ll expand the\ndiscussion by adding some notes about working with functional and nonfunctional\nrequirements. (I realize that some experts see this terminology as a minefield—we’ll\ndiscuss that, too.) And we’ll also talk about two new keywords that will let you organize\nyour specifications in a systematic manner: Ability and Business Need.\n The example discussed in chapters 8–11 concerns Activitee: an online platform for\nFortune 500 companies that want to improve employee engagement. Let’s say that\nyou and I are a part of an Activitee team. Encouraged by chapter 7’s praise of collabo-\nrative specification, we decide to hold a specification workshop. Because it’s our first\nworkshop together, we purposely choose a simple area to specify: the capabilities of an\nHR administrator role in Activitee’s employee-management module. We want to\nanswer this question: what are the behaviors that HR admins can perform that casual\nemployees can’t?\n Assume that the following are some of the scenarios we come up with. Don’t worry\nabout the Given-When-Then aspects of these scenarios—the names are sufficient for\nthe purpose of this story:\nEditing employee profiles\nRemoving former employees\nManaging other HR administrators\n",
      "content_length": 3045,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 201,
      "content": "175\nIs organizing scenarios by features a good idea?\nSeeing the list of all employees\nApproving new employees\nAssigning a new employee to a company branch\nAssigning a new employee to a department\nSyncing Activitee’s organogram with an external source\nOnboarding new employees\nEmailing employees with important announcements\nGranting limited admin access to team leaders\nCreating common interest groups\nSome of these scenarios relate to employee management, and others specify self man-\nagement between HR administrators; there’s even a scenario about email announce-\nments, which will become yet another area of implementation. If we keep brainstorming,\nwe could easily come up with more ideas.\n This process of starting with multiple disorganized ideas that are later organized\ninto more coherent material is common in all specification meetings. But how should\nwe organize our new scenarios coherently? We already suspect that we won’t be able to\nput them all in the same feature file. We wouldn’t even be sure what to call it. Would Fea-\nture: Admins be an expressive name for a specification? It sounds more like a catchall.\n If keeping the results in the same file isn’t a viable option, then the only possibility\nis to split the scenarios into several specifications. But how should we split them?\n As you write scenarios, such questions constantly arise. Which scenarios should be\nin which specifications? Should we establish a hierarchy of feature files, or will a flat\nstructure, such as putting everything in a single directory, work? Even the simplest\nquestion—how long a standard specification should be—doesn’t have an obvious\nanswer. So far, the specification documents in this book have been short. But short\ndocuments may only have been a consequence of the simplicity of the exercises. And\neven if keeping specifications short is a good practice to follow—which it is—how\nshould you split scenarios when dealing with large functionalities like modules?\n8.1\nIs organizing scenarios by features a good idea?\nCucumber-flavored Gherkin does offer a default way to organize scenarios into specifi-\ncations. Every time you wrote a specification in previous chapters, you started with the\nFeature keyword, indicating that you were specifying system features. The files that\ncontain scenarios are called feature files, which is official Cucumber nomenclature that\nisn’t used in other tools for making executable specifications. (We’ll get to that later.)\n In the case of the long list of scenarios for Activitee, you’d normally create a fea-\nture file like this:\nFeature: Employee management\n[...]\nYou’d put all the scenarios in this feature file and call it a day.\n",
      "content_length": 2684,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 202,
      "content": "176\nCHAPTER 8\nOrganizing scenarios into a specification suite\n I have a couple of issues with features, though:\nAnything can be a feature. A single button, like the Share button in Facebook,\ncan be a feature. A new screen, such as a user profile, can be a feature, too.\nEven a brand-new module (like a simple payment system) can be a feature. The\nword feature is often nothing more than an umbrella term for anything that’s\nbeing added to the product.\nA reasonably sized feature can change as the product evolves. If a feature turns\nout to be more important than you initially thought, it will grow larger—and so\nwill its feature file. The question is, how do you split it? Unfortunately, there’s\nno clear answer, because, once again, anything can be a feature. Without a clear\nmethodology in place, your team may split features differently each time a simi-\nlar problem appears. (Goodbye, consistency.)\nNonetheless, it’s easy to understand why Cucumber-flavored Gherkin uses features as\nthe default option. If anything can be a Gherkin feature, people who only recently\nstarted using the language will be less intimidated by it. At first, this choice can facili-\ntate faster learning. (It’s also the reason previous chapters used the Feature keyword.\nI warned you in chapter 2 not to become too attached to it!) But as you write more\nscenarios, and your specification suites become larger, you’ll realize that organizing\nscenarios by features may not be the best idea. Let’s look for something better. \n8.2\nOrganizing scenarios by user stories\nIf features aren’t the best choice, do we have other options? Earlier, I said that other\ntest runners that execute specifications don’t use the terms feature or feature file.\nLet’s examine one such tool: JBehave, a Java testing framework for behavior-driven\ndevelopment.\n JBehave calls executable specifications stories. In chapters 1 and 2, I described sce-\nnarios as short stories about the behaviors of particular actors. But JBehave takes the\nmetaphor even further: each story file can have an optional narrative section at the top\nof the specification brief. Here’s an example from JBehave’s official tutorial:\nNarrative:\nIn order to communicate effectively to the business some functionality\nAs a development team\nI want to use Behaviour-Driven Development\nIt’s not only a “narrative”—it’s a user story! User stories are one of the most popular\nmethods among technical teams for defining and discussing scope. It makes sense\nthat stories should be able to define the scope of a specification, too. In section 6.3.1,\nyou wrote a user story in a similar format when you were working on the Mapper\napplication and wanted to see how executable specifications fit into a real-world pro-\ncess of delivering software; so the concept of narratives should be more or less familiar\nto you by now.\n",
      "content_length": 2840,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 203,
      "content": "177\nOrganizing scenarios by user stories\n With stories, JBehave presents a different answer to the dilemma of organizing sce-\nnarios. You can organize scenarios according to the user stories that brought them to\nlife, which results in a more chronological model of organization. Because each file is\na separate user story and the implementation of each story can be placed in time, you\ncan track which user stories created which scenarios and when. In a way, you can see\nhow the product evolved from the first user story the team implemented to the last\none. This already sounds like a more exciting possibility than features for organizing\nspecification suites. The rest of this section look at other benefits.\n Unfortunately, unlike JBehave, Cucumber doesn’t support the Narrative keyword.\nInstead, a new Ability keyword will replace the sometimes-troublesome Feature\nkeyword.\n8.2.1\nIntroducing the Ability keyword\nThe Ability keyword is simple to use. To keep changes minimal, you only have to\nreplace the Feature keyword at the beginning of each Gherkin specification with\nAbility. No changes are needed in the automation layer, and you should keep the\n.feature extension for your files.\nNOTE\nStrangely, although features and abilities are synonymous, you won’t\nfind a word about Ability in Cucumber’s official documentation. I stumbled\non it when looking at Cucumber’s source code. I later learned that the key-\nword is listed in a table that appears if you type cucumber --i18n en in a com-\nmand shell.\nThis section takes a somewhat more elaborate route to show how to link abilities with\nuser stories. By setting scope boundaries, you can make a user story answer the ques-\ntion of which scenarios belong together in the same specification. Let’s begin by creat-\ning a simple feature. You’ll then rewrite it as an ability. Here’s the user story I chose as\nan inspiration:\nIn order to increase my engagement\nAs an employee\nI want to see relevant events and courses in my news feed\nNOTE\nI wrote this story in feature injection format. Section 8.2.2 will talk\nmore about different formats.\nAfter an HR admin assigns an employee to the correct branch and department, the\nemployee should be able to see events, courses, and discussions from interest groups\nthat are relevant to their job title. Employees from New York shouldn’t see events at\nthe Atlanta branch; likewise, engineering employees won’t be interested in training\nworkshops meant for the sales department. But sometimes an engineer from Atlanta\nmay be interested in an engineering course that takes place in New York. Here’s the\nspecification.\n",
      "content_length": 2609,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 204,
      "content": "178\nCHAPTER 8\nOrganizing scenarios into a specification suite\n \nFeature: Branches and departments\nScenario Outline: Employees should only see content relevant to them\nGiven <person> from <branch> who works in <department>\nWhen <person> looks at the company dashboard on Activitee\nThen <person> should see <type> <content>\nExamples: Employees should see after-\nwork content only from their location\n| person | branch\n| department\n| type\n| content |\n| Jane\n| New York | Engineering | New York after-work\n| events\n|\n| Mike\n| New York | HR\n| New York after-work\n| posts\n|\n| Tom\n| Atlanta\n| Sales\n| Atlanta after-work\n| events\n|\n| Ramona | Atlanta\n| Engineering | Atlanta after-work\n| posts\n|\nExamples: Employees should see work-related content from all locations\n| person | branch\n| department\n| type\n| content |\n| Mike\n| New York | HR\n| Atlanta HR\n| events\n|\n| Jane\n| New York | Engineering | Atlanta engineering\n| posts\n|\n| Jane\n| New York | Engineering | New York engineering | events\n|\n| Tom\n| Atlanta\n| Sales\n| Atlanta sales\n| events\n|\n| Ramona | Atlanta\n| Engineering | Atlanta engineering\n| posts\n|\n| Ramona | Atlanta\n| Engineering | New York engineering | events\n|\nEach employee has a few examples that specify the different types of content they\nshould be allowed to see. Only people from New York will see New York after-work activ-\nities such as bowling and collective outings. When it comes to work-related events and\ndiscussions within departments, people from all locations can participate. But, most\nimportant, this specification uses the Feature keyword. Let’s attempt to replace it.\nREWORKING FEATURES INTO ABILITIES\nLet’s begin by replacing the Feature keyword with the Ability keyword.\nAbility: Branches and departments\nThat’s a good start. The second step is to write down the expected business outcome.\nAbility: Engage with content I like\nNext, let’s clarify which stakeholder has this capability.\nAbility: Employees can engage with content they like\nListing 8.1\n[OK] Specification derived from a user story as a feature\nListing 8.2\n[BETTER] Feature reworked into an ability\nListing 8.3\n[BETTER] Ability with an outcome\nListing 8.4\n[BETTER] Ability with a stakeholder and an outcome\n",
      "content_length": 2200,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 205,
      "content": "179\nOrganizing scenarios by user stories\nTo complete the translation process, you should also specify the proposed technical\nsolution: it was the last part of the user story and will help you achieve your objective.\nAbility: Employees can engage with content they like in their news feeds\nNOTE\nFor a fully working content management system, you also need a spec-\nification that takes care of assigning events to particular branches and depart-\nments. Chapter 9 discusses that.\nThe line now looks slightly different than the original story. The reasons are simple:\nTo keep the line short and easy to read.\nTo make it fit well with the Ability keyword.\nDifferent user stories can be written in different formats, as discussed in section\n8.2.2. \nORGANIZING THE SPECIFICATION SUITE WITH ABILITIES\nSimilar to this example, you can group scenarios into abilities in a specification suite\nbased on the following, in this order:\n1\nStakeholders\n2\nBusiness capabilities of these stakeholders\n3\nReasonably small common outcomes\nIf you used the system in figure 8.1 to organize the specification suite, you’d end up\nwith something like figure 8.2. Note that neither figure includes a proposed technical\nsolution, even though that’s typically part of every user story. The figures only include\nthe expected abilities of stakeholders—for example, the ability to update a map (even\nthough a map can be updated many different ways). That’s because each specification\nspecifies the technical solution in the scenarios, so you don’t have to include it again\nin your system of hierarchy.\nNOTE\nYou’ll create a more complex example of a specification suite based\non abilities in chapter 9.\nListing 8.5\n[BEST] Ability with stakeholder, outcome, and technical solution\nAbility\nStakeholder\nOutcome\nFigure 8.1\nThe progression from left to right indicates \nhierarchy. First is the Ability keyword, which \ncreates a space for user stories in the specification \nsuite. Then come different stakeholders. In the end, \nstakeholders can achieve concrete outcomes.\nmanaging employees.feature\nHR\nAbilities\nFeatures\nFigure 8.2\nA specification suite \norganized according to figure 8.1\n",
      "content_length": 2152,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 206,
      "content": "180\nCHAPTER 8\nOrganizing scenarios into a specification suite\nHere’s a short cheat sheet summing up everything you need to know in order to use\nabilities in practice:\nTwo scenarios for two different stakeholders are, by definition, two different\nrequirements—so they should be two different abilities.\nTwo scenarios that describe two different business outcomes are probably two\ndifferent requirements—so they, too, should be split into two abilities.\nIf behaviors that look similar at first yield different outcomes in the end, they\nshould be put into separate abilities, because they’re probably from two differ-\nent domains. For example, a simple behavior like a company can join the\nActivitee platform could yield two or more outcomes like these:\n– The employees should be invited to create their Activitee accounts (an\nemployee management behavior)\n– Activitee’s sales department should be notified about a new company\non trial (a sales behavior)\nIn the end, you’d need to split these scenarios into two separate abilities.\nFollowing these rules will yield a specification suite full of short feature files, especially\nif you decide to use scenario outlines as you did in chapters 4 and 5. Each scenario\noutline would be a different ability for a different stakeholder, with similar outcomes\ngrouped in a few tables with examples. I also like to keep one to three edge cases as\nadditional scenarios in the same feature file if they’re small variations of the behavior\nfrom the outline. (You can find such edge cases by using techniques like context ques-\ntioning and outcome questioning, which we discussed in sections 3.3.3 and 3.3.4.)\nYou’ll probably end up with a specification that’s 50–100 lines long, which is a good\nlength for an executable specification; any reader will be able to understand its gen-\neral purpose at a glance. \nCHOOSING THE RIGHT LEVEL OF GRANULARITY FOR ABILITIES\nIn the list of rules in the previous section, I mentioned that the common outcomes\nshould be reasonably small. Let’s expand on what that means and look at another\nexample.\n Some companies on the Activitee platform have so many events that the applica-\ntion will be unusable without a good search engine to find those events. To create\nsuch a search engine, the engineering team has to deal with many filters: searching by\nname, department, branch, event type, participants, and so on.\nFeature: Event search\nScenario Outline: Filtering events\nGiven events:\n| name\n| department | branch\n| type\n| users\n|\n| Sales 101\n| Sales\n| New York | work-related | Mike, John\n|\n| Weekly status | HR\n| New York | work-related | Simona, John |\n| Bowling\n| -\n| Atlanta\n| after-work\n| Jane\n|\nListing 8.6\n[BAD] Searching for events\n",
      "content_length": 2711,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 207,
      "content": "181\nOrganizing scenarios by user stories\nWhen Simona searches for events by <filter>\nAnd she wants to find <value>\nThen she should see <results>\nExamples:\n| filter\n| value\n| results\n|\n| name\n| \"Staff picnic\" | no results\n|\n| department | \"Sales\"\n| \"Sales 101\"\n|\n| branch\n| \"New York\"\n| \"Sales 101\", \"Weekly status\" |\n| type\n| \"After-work\"\n| \"Bowling\"\n|\n| user\n| \"Mike\"\n| \"Sales 101\"\n|\nYou could obviously think of more search filters on the spot:\nAdd AND and OR filters.\nFilter by date and time.\nFilter by organizers.\nFilter by distance from location.\nThe real question is this: in terms of granularity, should you add more scenarios to the\nsame specification, or split scenarios for different filters between different abilities?\nIt’s an interesting dilemma. There are reasons to consider putting these scenarios in\nthe same feature file. The behavior would probably stay the same, regardless of the\ntype of filter. Inputs and outputs would differ a little, but they would be acceptably\nsimilar. The differences between filters would be solved in the automation layer. But\ndue to the number of scenarios, the resulting feature file would be so long that its\nlength could affect readability.\n This is why I mentioned reasonably small common outcomes. In this case, I can think of\ntwo possible solutions:\nSplit the scenarios into several abilities based on the rule of thumb provided\nearlier, which says that a single file should generally contain a single outline and\na few scenarios for possible edge cases. Thus, you’d give each filter its own fea-\nture file.\nRedefine what key examples means for this particular case. I like this solution bet-\nter. You should probably have only one example for each filter instead of multi-\nple repetitive scenarios.\nEither way, this is what I mean by reasonably small: when other rules fail, split your sce-\nnarios in a way that’s not overwhelming. \nExercise 1\nMake a [BAD] specification a [GOOD] one by rewriting the Feature line from listing\n8.6 into an ability with a clear outcome and a stakeholder.\n",
      "content_length": 2048,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 208,
      "content": "182\nCHAPTER 8\nOrganizing scenarios into a specification suite\n8.2.2\nUnderstanding the structure of user stories\nThis section deals with user stories. The chapter has used them already, but I haven’t\nexplained much about them.\n The user stories we’ve analyzed so far were written in the feature injection format:\nIn order to [achieve a business outcome]\nAs [an actor or a stakeholder]\nI want [a technical solution]\nThis format was first proposed by Chris Matts, an agile business analysis thought\nleader. You first used feature injection in chapter 6, to derive scope. Teams “hunt for\nvalue” by creating a model for business-value delivery and listing underlying assump-\ntions instead of trying to describe the value model with simple numbers. (That’s why\n“achieving a business objective” is on the first line of the template.) A well-phrased\nuser story that’s illustrated with high-level examples and that yields a fruitful discus-\nsion about expected business value can help create such a model.\n The assumption is that if you create a value model first and only then “inject” a\nfunctionality derived from the model, you’ll eliminate pet features, and the function-\nality will more likely be accepted by users and deliver real value. Therefore, abilities\nbased on user stories will be more likely to deliver value, because they enable you to\nconnect your specification process with feature injection and to derive scenarios\ndirectly from the value model.\n The feature injection format isn’t the only format; most agile coaches can come up\nwith four or five. It isn’t even the most popular format for user stories. The most pop-\nular is the Connextra format:\nAs [an actor or a stakeholder]\nI want [a solution]\nSo that [I can achieve a business benefit]\nThe general format we presented for abilities is a mix of the feature injection format\nand the Connextra template. It doesn’t follow them exactly, so it should be familiar to\npeople who’ve used either one. If you don’t like it, feel free to tweak it so it looks more\nlike your format of choice. The specific format isn’t important—what matters is\nunderstanding the value-delivery process for a requirement. Any user story that will\nbring you and your team closer to understanding this model is a good story, regardless\nof the format. Just make sure the template is easy for everyone to understand—even\npeople who weren’t present during implementation.\nTIP\nIf you’re looking for more resources about user stories, I recommend\nreading Fifty Quick Ideas to Improve Your User Stories by Gojko Adžic´ and David\nEvans (Neuri Consulting LLP, 2014) and User Stories Applied by Mike Cohn\n(Addison-Wesley Professional, 2004). \n",
      "content_length": 2670,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 209,
      "content": "183\nOrganizing scenarios by user stories\n8.2.3\nAnalyzing the relationship between user stories \nand executable specifications\nOrganizing a specification suite by user stories engenders an important question: are\nexecutable specifications extended user stories? Making abilities look similar to user\nstories only makes the issue more difficult. This section explores the similarities and\ndifferences between user stories and executable specifications.\n If user stories and executable specifications are one and the same, you’d expect\nthat every user story would become an executable specification and that your projects\nwould have as many stories as specifications. In practice, this isn’t true. A typical pro-\nject has many more stories than specifications. There must be differences between\nthem, despite their similarities.\nSIMILARITIES BETWEEN USER STORIES AND EXECUTABLE SPECIFICATIONS\nWe’ll start with the similarities. In 2001, Ron Jeffries—the creator of Extreme Pro-\ngramming—wrote that “user stories have three critical aspects. We can call these Card,\nConversation, and Confirmation.” He considers the textual artifact—the card—noth-\ning more than a piece of text to put on a Trello board or hang on the wall as a sticky\nnote. The card only captures a glimpse of the requirement behind the user story. It\ndoesn’t matter how refined it is; you still need to discuss acceptance criteria, tests, and\nsuccess and failure scenarios, as well as define confirmation metrics to produce a\nworking capability. In short, you must take care of the conversation and confirmation.\nThat’s why experts often call the card only a ticket for a conversation.\n In this sense, an executable specification is similar to a fully realized user story.\nGherkin scenarios often consist of recorded conversations between stakeholders, and\nthe underlying tests confirm and validate the acceptance criteria automatically. If you\nphrase the abilities similarly to how you phrase user stories, you’ll even have a link\nbetween every card and the title of the user story’s Gherkin ability.\nDIFFERENCES BETWEEN USER STORIES AND EXECUTABLE SPECIFICATIONS\nEven with all their similarities, there are some crucial differences between user stories\nand Gherkin specifications, as outlined in table 8.1; I talked some about them in sec-\ntion 6.3.1, when you wrote your first user story. Unfortunately, these differences mean\nthat ultimately you can’t treat stories and specifications the same way.\nTable 8.1\nComparison of user stories and executable specifications\nA user story…\nAn executable specification…\nIs discarded after implementation\nIs kept after implementation\nIs a unit of change\nIs an effect of the change\nHas acceptance criteria\nIs an acceptance test\nProduces short-term results, such as cards or tasks\nProduces long-term living documentation\n",
      "content_length": 2825,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 210,
      "content": "184\nCHAPTER 8\nOrganizing scenarios into a specification suite\nUser stories have acceptance criteria—but executable specifications are acceptance\ntests. Obviously, without the criteria, there can be no tests—but that doesn’t mean\nexecutable specifications and user stories are the same thing. They only share some\nunderlying core similarities that spring from the fact that they’re both tools to talk\nabout requirements.\n The main difference is that user stories\nRepresent the future scope of work (see the right side of figure 8.3)\nDiscuss changes that have to be made to the system\nExpire if they stay in the product backlog too long\nWhereas, executable specifications\nRepresent the scope of the work that has been done so far (see the left side of fig-\nure 8.3)\nDiscuss the current state of the chosen part of the system\nBecome more precise as time passes, thanks to automated tests and feedback\nloops like those you saw in action throughout chapters 6 and 7\nAlthough it may have seemed at the start of the chapter that I was encouraging you to\nconsider user stories and specifications as equal, we should take a more conservative\napproach and say that new executable specifications and new scenarios are only\nderived from user stories. What I mean is that even though user stories can generate\nnew scenarios, they can also change or remove existing scenarios. A model of organi-\nzation based on user stories can’t assume a 1:1 relationship between a single story and\na single specification. Any single specification will most likely be changed by multiple\nuser stories as the product evolves. If you assume that specifications are extended sto-\nries, you’ll end up creating a false equivalence between stories and specifications. \n8.2.4\nIterative dangers of organizing scenarios by user stories\nWhy would an equivalence between stories and specifications be false? Because user\nstories are requirements—just like executable specifications are requirements—but\nuser stories are often requirements only for the current iteration.\n For example, in Scrum, the backlog holds all the user stories; at the beginning of\nevery sprint, the development team and the product owner select the user stories for\nRequirements\nFuture\nPast and current\nUser stories\nExecutable\nspecifications\nFigure 8.3\nExecutable specifications represent requirements that \nhave been implemented so far or are currently being implemented. \nUser stories represent the future scope of work and are often used \nas reminders for a future conversation about the requirement.\n",
      "content_length": 2544,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 211,
      "content": "185\nOrganizing scenarios by user stories\nthe current sprint. Scrum requires the development team to deliver a fully functional\niteration of the product at the end of each sprint. So for some bigger features, you’ll\nend up simplifying the solution, only to make it more complex iteratively. A blogging\nplatform might at first introduce a full-text search that only lets readers search by title,\nand then add a capability to search by body text in the next iteration. The second\ncapability would become a separate user story, but it would still have to build on a pre-\nviously completed story. Should you create two specifications because there are two\nuser stories? Or should you treat the second story as an expansion of the first story?\nTIP\nTo those who argue that every user story must be independent—and\nthat thus you can’t have a story that builds on another story—I say you can\nimplement a title search or body search in any order, so there’s no depen-\ndency between the stories. Nonetheless, some stories inevitably build on pre-\nviously implemented solutions.\nFrom a technical point of view, a user story can only be a complete requirement when\nit introduces a brand-new capability to the system. If a user story changes an existing\ncapability, the requirement is now formed from two user stories: the one that intro-\nduced it in the past and the one modifying it right now.\n User stories don’t have to be full units of the requirements. They’re often only\nunits of change in the requirements. They’re like commits in Git or any other version\ncontrol system. Every story is a new layer of changes you introduce to the application.\nTo recreate requirements from them, you’d have to juxtapose all stories related to a\nsingle functionality chronologically and reason the final shape of the requirement\ncurrently in effect out of the changes made to the original story by newer stories.\nThat’s way too much effort.\nThinking of user stories in terms of geometry and geography\nI like thinking about user stories and executable specifications in spatial ways. A user\nstory is like a Euclidean vector: it has a direction (in which the delivery team wants to\ngo) and length (a scope estimate). A story is merely a planning tool that helps teams\norganize themselves in order to get from point A to point B. When you want to get\nfrom A to B, you know that your current plan is temporary—the same route that got\nyou from A to B won’t automatically get you from B to C, and so on.\nAn executable specification, on the other hand, is more like a two-dimensional plane.\nIt’s an overview of what the vectors created. It’s like a map that your team has\ncharted along the way during your journey. It shows your current knowledge about the\nrequirements. You’ll probably improve the map as you venture into new territories.\nBut because most of the hard work is already done, you can be more thoughtful about\nthe long term and organize the map in a way that won’t get you lost in the woods in\nthe future.\n",
      "content_length": 2990,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 212,
      "content": "186\nCHAPTER 8\nOrganizing scenarios into a specification suite\nThe iteration problem is why putting user stories in the specification brief is a prob-\nlematic method that I don’t advise practicing. Which of multiple user stories influenc-\ning the specification should the brief contain? All of them, in chronological order? (I\nwas surprised to learn that JBehave embraced this pattern back in the day.) How can\nyou do better than that? Here are a few thoughts:\nDon’t store user stories in specification briefs. Instead, extract desired business\noutcomes from your stories, and name specifications after the outcomes. Men-\ntion stakeholders to put actors in context.\nMake brand-new executable specifications only from user stories that imply\nbrand-new business outcomes.\nIf a user story implies a change in the behavior of an existing outcome, review\nthe existing specification to see if the new scenarios are important enough to\nwarrant a change in the contents of the Ability keyword.\nSometimes a change in behavior is so significant that adding new examples or\nscenarios isn’t enough. In this case, check whether the change results in creat-\ning a brand-new capability for an existing actor or a new actor; if the answer is\nyes, split the old ability into two new, separate specifications. \n8.3\nWhat about nonfunctional requirements?\nBy default, abilities imply capabilities of specific actors. We can say that such and such\na user should be able to do such and such a thing. But what about requirements that\ndon’t apply to particular actors? Think of security, usability, testability, maintainability,\nextensibility, scalability, and so on. Trying to specify an ability that makes sure every\nfunctionality in your system is fast could result in a feature file with hundreds of sce-\nnarios, rendering your effort to create small specifications pointless. Such require-\nments are often called nonfunctional requirements.\nDEFINITION\nNonfunctional requirement—A requirement that defines a general\nquality that the entire system must stick to horizontally\nIf you decide to use the nonfunctional terminology, you can also say that a require-\nment that defines a capability of an actor is a functional requirement.\nDEFINITION\nFunctional requirement—A requirement that defines a function of\na system as an ability to solve a problem or achieve an objective at hand\nWhereas functional requirements define the utility of a system, nonfunctional\nrequirements define its architecture. They aren’t related to any particular vertical\nfunctionality. So, if we said that a specification suite is like a map of requirements,\nshould nonfunctional requirements be on the map, too? The answer isn’t unequivo-\ncal. In this section, we’ll look at the question from two angles:\nHow to handle nonfunctional requirements according to SBE’s key patterns\nThe difficulty of writing nonfunctional requirements in Gherkin\n",
      "content_length": 2900,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 213,
      "content": "187\nWhat about nonfunctional requirements?\nI have to admit that conveying nonfunctional requirements in Gherkin isn’t an estab-\nlished practice. I haven’t seen any Gherkin thought leaders advising this approach.\nOther than one practical use case, which you’ll see in section 8.3.4, most of the ideas\noutlined in this case are theoretical. So if you’re only interested in learning practical\ntechniques, go straight to section 8.3.4.\n I was even advised to drop the terms functional and nonfunctional requirements,\nbecause the differences between them can cause confusion. I decided to keep the ter-\nminology intact, because I assume that many readers are already familiar with it.\nThere’s no point in pretending the terms and the controversy don’t exist. This is also\nan interesting topic to explore. With some hesitation, I decided to include it here so\nthat you can build a more complete understanding of requirements in your specifica-\ntion suites.\n8.3.1\nDealing with nonfunctional requirements according to SBE\nTeams that use SBE illustrate requirements using concrete examples to build a better\nmental model of whatever they’re about to do. Although illustrating functional\nrequirements with examples comes naturally, because each behavior needs concrete\ninputs and outputs, most people intuitively think that nonfunctional requirements\ndon’t fit this process pattern as well. For example, some nonfunctionals aren’t dis-\ncrete. Think of a fun requirement for a game: how could you specify fun?\n To illustrate nonfunctional requirements with examples, you need to adopt a\nbeginner’s mindset and stop thinking about your system, which you do when you work\nwith functionals. Instead, you should think about other systems that you know of and\ncan use as an inspiration, a standard, or a benchmark. For example, for a security\nrequirement, you could find examples of the most secure systems in your product cat-\negory and see whether you could replicate what they did. In the case of a usability\nrequirement, you could ask your UX designers to showcase some useful patterns from\nproducts they like, and UI requirements could be illustrated with low-fidelity mockups\nor interactive prototypes and animations. For a performance requirement, you could\nlook at your competitors if they’re better than you; or, if they aren’t, make a list of\nproducts from other industries that the team should look at as gold standards. And\nfinally, for the problematic fun requirement, you could find examples of game\nmechanics that you or your players enjoyed in the past.\n Unfortunately, nonfunctional requirements are usually difficult to automate,\nexcept for security tests or performance tests. (For example, performance require-\nments are usually discrete, which makes automation easier: “The system has to process\nX GB of data within Y hours on a Z hard drive.”) But lack of automation doesn’t mean\nExercise 2\nCan you identify more nonfunctional requirements?\n",
      "content_length": 2947,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 214,
      "content": "188\nCHAPTER 8\nOrganizing scenarios into a specification suite\nyou can’t use these examples to discuss such requirements with business stakeholders\nor during specification workshops and reap the benefits. \n8.3.2\nCan Gherkin specify nonfunctional requirements?\nThroughout the book, I’ve treated Gherkin scenarios as behavioral requirements. As\nbehaviors, scenarios should by definition be functional requirements. But the rela-\ntionship between behaviors, functional requirements, and nonfunctional require-\nments is more complicated than it may seem. For example, security requirements may\nimply a two-factor authentication function; in this case, a nonfunctional requirement\nis generating a functional requirement. And some nonfunctional requirements can\nbe phrased as behaviors, like this scenario:\nGiven a search form\nWhen the user submits a query\nThen the user should see the result in less than 100 seconds\nI’ll agree that, in this case, the nonfunctional requirement sounds like it’s being\nforced into the template. That’s because I mixed two domains—the search domain\nand the performance domain—while trying to write the scenario in the outside-in\nstyle you’ve been practicing throughout the book. Unfortunately, only the search\ndomain fits the outside-in style meant for stakeholders; the performance domain,\nwhich is the main domain of this scenario, must be written in another style. But is that\npossible? I’m playing devil’s advocate right now, but let’s think about that for a\nmoment.\n As we examined advanced techniques for writing scenarios in chapter 3, you saw\nthat every scenario must be written from the perspective of an actor. Because anything\nthat influences an action or a process taking place in the system under design can be\nan actor, three kinds of actors come to mind: stakeholders, organizations, and systems.\nAs I mentioned, scenarios in which the actor is a stakeholder are written in the\noutside-in style. But that leaves out organizations and systems.\n I’ll argue that you could rewrite the previous example scenario without using the\noutside-in style and with the system in the role of an actor. You could even use good\ntechnical practices from performance testing, such as averaging query run time to get\nbetter results. Here’s the same nonfunctional requirement written from the system’s\nperspective:\nGiven a search query\nWhen the system runs the query 100 times\nThen the average execution time should be less than 100 seconds\nThe system style matches performance much better, because they’re both technologi-\ncal at heart, whereas the outside-in style required a more empathetic approach. But\nbetter phrasing doesn’t get rid of all the issues:\nYou can’t use the Goldilocks principle (discussed in section 5.4.4) and get rid of\nthe class of equivalence from the Then step (less than 100 seconds) due to\nthe nondeterministic nature of the requirement.\n",
      "content_length": 2886,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 215,
      "content": "189\nWhat about nonfunctional requirements?\nThe scenario is more technical and may seem boring to nontechnical stake-\nholders. This could possibly be solved with good stakeholder management: for\nexample, you could show the system scenarios only to technical stakeholders\nwho are interested in the performance domain, and keep the outside-in scenar-\nios for the nontechnical stakeholders. It’s an interesting idea that we’ll talk\nabout in section 8.3.3.\nThe scenario only tests the average execution time of search queries, without\ntesting whether the results are rendered on the screen quickly enough.\nIf you decided to simulate a full user experience in order to test whether the\nsearch was fast enough from a user perspective, you’d need to test every screen\nwhere a user could execute a search query.\nEven though we still have many unanswered questions, let’s set them aside for a\nmoment and say that we will try to use Gherkin to specify this requirement. But how\ndo we do that?\n8.3.3\nIntroducing the Business Need keyword\nTheoretically, if you wanted to specify a nonfunctional requirement with Gherkin, you\ncould. Syntax would be problematic, though. Keywords like Feature and Ability\nseem out of place. Performance isn’t a feature. It could be an ability, but that would\nsound as phony as the initial scenario that mixed the empathetic outside-in style with\nthe technical performance domain. Fortunately, Gherkin has a third keyword that’s\nsimilar to these two: Business Need. Here’s how it looks in practice:\nBusiness Need: Performance\nLike abilities, business needs don’t influence the automation layer, and you store\nthem in files with the .feature extension. Here’s the search scenario, phrased as a busi-\nness need.\nBusiness Need: Performance\nScenario: Searches must run faster than 100 seconds\nGiven a search query\nWhen the system runs the query 100 times\nThen the average execution time should be less than 100 seconds\nAdding business needs to figure 8.1, which outlined the structure of functional abili-\nties, yields the diagram shown in figure 8.4.\nListing 8.7\nPerformance requirement phrased as a business need\nAbilities\nRequirements\nStakeholder\nOutcomes\nBusiness needs\nQuality measures\nFigure 8.4\nRequirements in a \nspecification suite. Abilities specify \nfunctional requirements, and \nbusiness needs specify \nnonfunctionals. Instead of \nstakeholders and outcomes, \nbusiness needs talk about required \nquality measures.\n",
      "content_length": 2441,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 216,
      "content": "190\nCHAPTER 8\nOrganizing scenarios into a specification suite\nFigure 8.5 shows the example specification suite when it includes the business need\nfor performance.\n Impatient readers may say that dedicating an entire section to the mostly theoreti-\ncal concept of business needs in Gherkin was extravagant. They’re probably right—\nbut I had an ulterior motive, which I’ll reveal in the next section. In my opinion, if a\nspecification suite were to truly become a map of requirements for an entire product,\nit would have to include nonfunctional requirements. And in some cases, it can do so\nmore easily than in our previous problematic example. \n8.3.4\nUsing the Business Need keyword to identify new stakeholders\nAs I said at the beginning of section 8.3.2, the relationship between functional and\nnonfunctional requirements is more complicated than it seems at first. I used the\nexample of a security requirement that might imply a two-factor authentication func-\ntion to show that, sometimes, nonfunctional requirements create functions and\nbehaviors that can be described in Gherkin—and even in the outside-in style. We’ll now\nexamine such situations in depth. When do they occur? And are there consequences\nyou should be aware of?\nMEETING THE CHAMPIONS BEHIND REQUIREMENTS\nTo keep things simple, we’ll stay in the security domain introduced by the two-factor\nauthentication example. But to discuss the issue fully, we’ll need something more: a\nstory.\n Let’s say it’s Monday, and you’re at the weekly status meeting where you discuss the\nstories your Activitee team chose to implement during this iteration. The product\nowner unexpectedly adds a new story to this week’s backlog. The story is about making\npasswords in the system more secure. The team decides that the simplest way to\nachieve results this week, given the team’s current capacity, is to force users to create\npasswords that are harder to crack.\n Together, the team creates a list of acceptance criteria for new passwords:\nPasswords should have a minimum of eight characters.\nDon’t use repetitive or sequential characters.\nUsernames, first names, surnames, and so on shouldn’t qualify as passwords.\nThe team then collects a list of examples and drafts a scenario that checks whether\neach example is strong enough to pass the security measures. A few weeks ago, the\nmanaging employees.feature\nHR\nAbilities\nperformance.feature\nBusiness needs\nFeatures\nFigure 8.5\nA specification suite \norganized according to figure 8.4\n",
      "content_length": 2487,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 217,
      "content": "191\nWhat about nonfunctional requirements?\nteam would probably have added this scenario to an existing feature file connected to\naccount management; but let’s say you’ve just read the first half of this chapter and\nknow that Gherkin specifications can be organized as requirements and that non-\nfunctional requirements, such as security, can be specified using the Business Need\nkeyword.\nBusiness Need: Security\nScenario Outline: Passwords should be secure\nGiven Simona has to set a password\nWhen she tries to set the password to <password>\nThen the password should be considered <secure>\nExamples: Too short\n| password | secure\n|\n| shorty\n| insecure |\nExamples: No repetitive or sequential characters\n| password | secure\n|\n| aaaaaaaa | insecure |\nExamples: No usernames, first names, or surnames\n| password\n| secure\n|\n| simonajenkins | insecure |\nExamples: Good password\n| password\n| secure\n|\n| nevergonnagiveyouup | secure\n|\nIt’s a classic case of a functional behavior that the end user can interact with. To make\nthe examples easy to read, you put them in a scenario outline. Each acceptance crite-\nrion has its own table—isn’t that what you’d do with any other requirement? In a way,\nthis is a standard Gherkin specification. But if you remember that it was created from\na nonfunctional requirement, some interesting questions appear. For example, what\nprompted the security requirement to emerge in the first place? (Yes, I know. I, too,\nam sure that a real-world delivery team would ask this question before writing the speci-\nfication. I admit that I structured the story so I could ask the question dramatically\nnow. Sorry about that!) In a software development agency, the request for the security\nrequirement would come from the clients—but who or what planted it in their heads\nin the first place? The same goes for in-house teams, where the requirement might be\nhanded off to the product owner by someone from management.\n Requirements listed as nonfunctional usually imply that there’s a stakeholder\nwhom the team hasn’t yet explicitly identified. For example, the company might have\nhired a chief security officer, who, unbeknownst to the team, ordered a security audit.\nThe request for stronger passwords may be only the first step, if the functional behav-\nior for forcing stronger passwords was just the easiest fix on the CSIO’s list. In that\ncase, you can assume that more security requirements will emerge in the future.\nListing 8.8\nBusiness need for security\n",
      "content_length": 2481,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 218,
      "content": "192\nCHAPTER 8\nOrganizing scenarios into a specification suite\n Another reason for the security requirement to appear might be that the company\nsigned a contract with an enterprise client that cares about security. Some stakehold-\ners work behind the scenes for a long time and become more active only when an\nissue that interests them is on the table—they’re identified when new nonfunctional\nrequirements crop up, seemingly out of nowhere. Even if business needs can’t create a\ncomplete map of nonfunctionals, you can use them to mark potentially dangerous\nareas from which you suspect new stakeholders may emerge.\nAPPLYING A FRAMEWORK TO WORK WITH BUSINESS NEEDS OVER TIME\nI suggest the following simple framework to work with requirements like those just\ndiscussed:\nInclude nonfunctional requirements in the specification suite if they can be\nspecified as functional behaviors, such as a two-factor authentication scenario\nin a security requirement.\nMark nonfunctional requirements as business needs with general names such\nas Security, Usability, and so on.\nLet each business need grow naturally by adding new functional scenarios over\ntime.\nIf one of the business needs grows too large and has too many functional\naspects, consider splitting it into several smaller abilities. By now, you should\nhave enough functional scenarios to justify doing so.\n– If you haven’t already, work to identify the stakeholder behind the business\nneed that had to be split, and try to include that stakeholder in your software\ndevelopment process.\n– Having identified the stakeholder, move the acquired abilities under the abil-\nities filesystem tree.\nYou’ll see this framework work in practice in chapter 9.\nExercise 3\nThink of some other examples of behavioral functions that could be derived from non-\nfunctional requirements. You can use the requirements you prepared in exercise 2.\nExercise 4\nAdd a two-factor authentication scenario to the business need for security as another\nquality measure.\n",
      "content_length": 1992,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 219,
      "content": "193\nAnswers to exercises\n8.4\nAnswers to exercises\nEXERCISE 1\nMake a [BAD] specification a [GOOD] one by rewriting the Feature line\nfrom listing 8.6 into an ability with a clear outcome and a stakeholder:\nAbility: Employees can find events by using advanced search filters\nEXERCISE 2\nCan you identify more nonfunctional requirements?\nTestability\nMaintainability\nExtensibility\nScalability\nReporting\nEXERCISE 3\nThink of some other examples of behavioral functions that could be\nderived from nonfunctional requirements. You can use the requirements you pre-\npared in exercise 2:\nA nonfunctional reporting requirement can imply functions such as generating reports,\ndownloading reports, archiving reports, and so on.\nEXERCISE 4\nAdd a two-factor authentication scenario to the business need for secu-\nrity as another quality measure:\nScenario Outline: Use two-factor authentication for more security\nGiven <authentication> for Simona\nAnd Simona's desire to log in\nWhen she provides her username\nAnd she provides her password\nAnd she enters <code>\nThen she should be <authenticated>\nExamples: Two-factor authentication\n| authentication\n| code\n| authenticated |\n| two-factor auth\n| the correct code | logged in\n|\n| two-factor auth\n| the wrong code\n| not logged in |\nExamples: Make sure single-factor authentication still works\n| authentication\n| code\n| authenticated |\n| traditional auth | no code | logged in\n|\nExercise 5\nSplit the business need for security into two abilities: one for secure passwords, and\nanother for two-factor authentication. \n",
      "content_length": 1547,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 220,
      "content": "194\nCHAPTER 8\nOrganizing scenarios into a specification suite\nEXERCISE 5\nSplit the business need for security into two abilities: one for secure pass-\nwords, and another for two-factor authentication:\nAbility: Users can secure their account with strong passwords\nScenario Outline: Passwords should be secure\nGiven Simona has to set a password\nWhen she tries to set the password to <password>\nThen the password should be considered <secure>\n[...]\nAbility: Users can turn two-factor authentication on for more security\nScenario Outline: Use two-factor authentication\nGiven <authentication> for Simona\nAnd Simona's desire to log in\nWhen she provides her username\nAnd she provides her password\nAnd she enters <code>\nThen she should be <authenticated>\n[...]\n8.5\nSummary\nCucumber organizes Gherkin scenarios into specifications through feature\nfiles.\nEven though the default way to organize scenarios in Cucumber-flavored Gher-\nkin is through the Feature keyword, features are difficult to organize consis-\ntently because anything can be a feature.\nTesting tools like JBehave use user stories to organize scenarios; but more often,\nexecutable specifications are only derived from user stories, because they can not\nonly add, but also change or remove existing scenarios.\nIf you don’t use user stories, you can organize your scenarios by any other kind\nof functional requirement.\nA functional requirement defines a function of a system as an ability to solve a\nproblem or achieve an objective at hand.\nYou can specify user stories or functional requirements as abilities of particular\nstakeholders.\nBe careful with user stories that are iterative!\nNonfunctional requirements define general qualities that the entire system\nmust stick to, such as security, usability, and testability.\nYou can specify nonfunctional requirements as business needs that define par-\nticular quality measures.\nSome nonfunctional requirements can imply functionality.\nRequirements listed as nonfunctional usually imply that there’s a stakeholder\nwhom the team hasn’t yet explicitly identified.\n",
      "content_length": 2075,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 221,
      "content": "195\nRefactoring features into\nabilities and business needs\nThis is the second chapter in a four-chapter series about managing large specifica-\ntion suites. Chapter 8 focused on organizing scenarios into specifications, discuss-\ning the optimal length of an average executable specification and the theoretical\naspects of deciding to put a scenario into one specification or another. In this chap-\nter, we’ll put the theory into practice by refactoring larger executable specifications\ninto smaller ones that will be easier to manage.\n We’ll continue to work with Activitee, an online platform for Fortune 500 com-\npanies that want to improve employee engagement. Chapter 8 introduced two new\ntypes of executable specifications: abilities and business needs. They replaced the\nFeature keyword because they’re easier to organize. But it’s one thing to know a\nThis chapter covers\nManaging functional and nonfunctional \nrequirements\nRefactoring features into abilities\nRecognizing and refactoring business needs\nIdentifying new stakeholders with business needs\n",
      "content_length": 1061,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 222,
      "content": "196\nCHAPTER 9\nRefactoring features into abilities and business needs\ntheory and another to apply it in practice. In this chapter, we’ll deal with two core\naspects of the Activitee experience—events and application security—in order to\ndetermine which is an ability and which is a business need.\n9.1\nAnalyzing user stories: a practical example\nBefore you can talk about abilities and business needs, you need to learn about the\nrequirements in question. This section looks at two Activitee teams who are getting to\nknow the scope of work ahead of them. Imagine that the two teams have just finished\ntheir previous iterations. They’re ready to take two new user stories from the top of\ntheir backlog, which has recently been prioritized by Activitee’s product management.\n The first team—which I’ll refer to from this point on as the events team—will work\non a user story connected with Activitee’s core value proposition: organizing and man-\naging events. The user story introduces a new capability for team leaders to create\nevents with an attendance fee:\nIn order to organize informal company outings online\nAs a team leader\nI want to create events that let people pay for attendance on Activitee\nThe use case for paid events is to let team leaders organize informal team outings\nwithout involving the entire HR department. The team may just want to go bowling\nafter work—and Activitee should let employees organize and pay for the event up\nfront online. Section 9.2 covers the actions of the events team.\n The second team, which I’ll call the application security team, will work on a user\nstory that deals with security:\nIn order to meet my company's security policy\nAs a Fortune 500 company employee\nI want to increase my account security\nAs of this moment, the team doesn’t have a lot of information about this story, which\npopped up in the backlog recently and was quickly prioritized to the top. Activitee’s\nprimary clients—Fortune 500 companies with thousands of employees—always have\ntheir own security policies. It makes sense that Activitee should work on its security\nmeasures in order to meet their standards; but right now, the team has to wait to see\nwhat kind of solution will be required. We’ll look at that in section 9.3.\n As the teams talk about requirements with relevant stakeholders and draft new\nGherkin scenarios in response, they must determine what kinds of requirements\nthey’re dealing with. Chapter 8 provided frameworks for working with two types of\nrequirements in Gherkin: defining system functions using abilities, and using business\nneeds to define functional aspects of general system qualities like security and perfor-\nmance. You may already suspect which keyword will help with which Activitee user story. \n9.2\nRefactoring features into abilities\nLet’s examine how the events team works with the user story about paid events. The\nstory introduces a new capability for team leaders to create events with an attendance\n",
      "content_length": 2955,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 223,
      "content": "197\nRefactoring features into abilities\nfee. It’s fitting, then, to suspect that the team will use the Ability keyword to define\nsuch a requirement.\n Throughout the rest of this section, you’ll see the challenges of organizing func-\ntional scenarios over time, how they can accumulate into executable specifications\nthat are too long to manage without significant effort, and what steps are necessary to\nbreak such specifications into smaller parts. As you’ll see, we can’t talk about these\nissues without touching on the topic of the legacy Feature keyword, too—but let’s not\nget ahead of ourselves just yet.\n9.2.1\nDeriving new scenarios from user stories\nIn the case of the events team, finding relevant stakeholders and discussing the user\nstory with them isn’t difficult. Most of Activitee’s HR and team leadership use the com-\npany’s own product. The team gathers a few team leaders in a conference room, and\ntogether they come up with a scenario that they think will satisfy both their own needs\nand the needs of their clients.\nScenario: Users should be able to pay for events online\nGiven an event created by team lead Mike for his team:\n| name\n|\n| 2nd Bowling Night |\nAnd an attendance fee of $25 set by the team lead\nWhen Jane pays for the event online\nThen she should become a confirmed attendee\nActivitee’s specification suite has grown significantly since the company adopted SBE\nand Gherkin. So, the team must decide where to put this new scenario. \n9.2.2\nStarting with simple features\nAfter reading the previous paragraph, you’ve probably thought about finding an exist-\ning ability or creating a new one. But remember that when teams begin using Gher-\nkin, they almost always define new system functions using the Feature keyword, which\nis Cucumber-flavored Gherkin’s default way of defining requirements. Activitee’s very\nfirst executable specification is no different (see the following listing).\nFeature: Creating events\nScenario: HR admins should be able to create company events\nGiven a Fortune 500 company like Coca-Cola\nAnd James, an HR admin in that company\nWhen James organizes a company-wide event:\n| name\n| date\n| time\n|\n| Annual staff picnic | 10-03-2017 | 10 AM |\nThen the employees in other departments should be notified\nListing 9.1\nEvents team: scenario derived from the user story\nListing 9.2\nActivitee’s first executable specification\n",
      "content_length": 2368,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 224,
      "content": "198\nCHAPTER 9\nRefactoring features into abilities and business needs\nAs it happens, the current events team is the same team who worked on this scenario,\nback when Activitee was still striving to launch its product. They imagine that their\nnew scenario will seamlessly fit into what they remember as a one-scenario feature\nabout the catchall topic of creating events. We’ll soon see if they’re right. \n9.2.3\nAdding scenarios over time\nThe event system lies at the heart of Activitee’s value proposition. Over time, multiple\nteams have been tasked with delivering new functionalities in the events space. They\ntook artistic license with the initially simple feature by adding new scenarios as they\nsaw fit. The word feature is an umbrella term, so anything can be a feature—if a ham-\nmer is the only tool you have, everything looks like a nail.\n The current events team is surprised by how many different scenarios have been\nadded. You can imagine the questions that pop into their heads when they read the\nlatest version of the specification (shown in the following listing): How are these sce-\nnarios related? What’s going on? Will we break anything?\nFeature: Creating events\nScenario: HR admins should be able to create company events\nGiven a Fortune 500 company like Coca-Cola\nAnd James, an HR admin in that company\nWhen James organizes a company-wide event:\n| name\n| date\n| time\n|\n| Annual staff picnic | 10-03-2017 | 10 AM |\nThen the employees in other departments should be notified\nScenario Outline: Managing invited participants\nGiven James drafted a new event\nWhen he invites <invitee>\nThen only <invitee> should be notified about the invite\nBut <uninvited> should not be notified\nExamples: Invites to one-on-one events such as annual reviews\n| invitee | uninvited |\n| Simona\n| Jane\n|\nExamples: Invites to local events in specific locations\n| invitee\n| uninvited\n|\n| Atlanta employees | New York employees |\nExamples: Inviting one department, but not the other (all locations)\n| invitee\n| uninvited\n|\n| engineers | salespeople |\nExamples: Inviting a specific department from a specific location\n| invitee\n| uninvited\n|\n| Atlanta engineers | New York engineers, salespeople |\nScenario Outline: Managing simple events and serial events\nListing 9.3\n[BAD] Feature with loosely related scenarios added over time\nBasic success\nscenario for\ncreating company-\nwide events\nScenario outline that \ndeals with managing \nparticipants\nScenarios\nthat deal\nwith time\nand date\nmanagement\n",
      "content_length": 2480,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 225,
      "content": "199\nRefactoring features into abilities\nGiven a company-wide event called <name>\nAnd that it takes place <date> at <time>\nWhen Simona wants to attend the event\nThen she should get a reminder <date> before <time>\nExamples:\n| name\n| date\n| time\n|\n| Annual staff picnic | on 10-03-2017 | 10 AM |\n| Yoga classes\n| every Monday\n| 10 AM |\nScenario Outline: Managing scheduling conflicts for company-wide events\nGiven a company-wide event created by James:\n| name\n| date\n| time\n|\n| Annual staff picnic | 10-03-2017 | 10 AM |\nAnd that Terry wants to organize another company-wide event:\n| name\n| date\n| time\n|\n| The Move with Purpose Marathon | 10-03-2017 | 10 AM |\nWhen Terry does <action> that the scheduling conflict is OK\nThen the event should be <result>\nAnd the employees in other departments should get <email>\nExamples:\n| action\n| result\n| email\n|\n| confirm\n| published\n| a notification\n|\n| not confirm | not published | no notification |\nScenario: Managing scheduling conflicts for local events\nEvents from local branches shouldn't cause conflicts.\nGiven an Atlanta event created by James:\n| name\n| date\n| time\n|\n| Local staff picnic | 10-03-2017 | 10 AM |\nWhen Terry wants to organize another event in New York:\n| name\n| date\n| time\n|\n| The Move with Purpose Marathon | 10-03-2017 | 10 AM |\nThen the event should be successfully published\nAnd the employees in other departments should be notified\nNOTE\nDon’t worry about the details of these scenarios right now. We’ll dis-\ncuss them at length soon.\nThis specification has 10 examples in a single file that spans more than 75 lines of\ntext! These examples cover three important areas of implementation:\nCreating and scheduling events—The first scenario introduces the concept of\ncompany-wide events that are visible to all employees.\nManaging participants by location and department—These four scenarios discuss\nevents that are either local or limited to particular departments or specific\nemployees.\nManaging participants by date and time—These three scenarios introduce the\nthird type of events, serial events, which can take place in multiple time slots\n(think of yoga classes that take place over several months).\nScenarios that deal\nwith time and date\nmanagement\nScenarios \nthat deal \nwith time \nand date \nmanagement\n",
      "content_length": 2276,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 226,
      "content": "200\nCHAPTER 9\nRefactoring features into abilities and business needs\nAdding the scenario about paid events would enlarge the text to 6 scenarios and 84\nlines, talking about 4 loosely connected areas of implementation. Given that an aver-\nage scenario in this feature file has about 10 lines of text, adding just 2 more scenarios\nto each of these 4 areas would result in 80 additional lines, making the entire specifi-\ncation 164 lines long. Early reviewers of this book shared that the specification suites\nthey encounter in their environments often deal with hundreds or even thousands of\nscenarios! There is a dire need for a more granular organization system.\n When the Activitee events team tries to fit the new scenario into this overgrown\nfeature, they come to the same conclusion. Fortunately, while they searching for a\ngood solution, they stumble on the Ability keyword and decide to break their huge\nfeature into several smaller abilities. \n9.2.4\nSplitting huge features into small abilities\nThe events team choose to split their feature according to the four areas of implemen-\ntation specified in the previous section. This decision is driven by the fact that they\nwere able to track the source of each area to a different user story in the archives of\ntheir backlog—just as we did back in section 8.2.1.\nSPLITTING SCENARIOS BETWEEN ABILITIES\nThe first ability created by the Activitee team deals with company-wide events and the\nbasic success scenario for creating events.\nAbility: HR reps can organize their wellness programs through online events\nScenario: HR admins should be able to create company events\nGiven a Fortune 500 company like Coca-Cola\nAnd James, an HR admin in that company\nWhen James organizes a company-wide event:\n| name\n| date\n| time\n|\n| Annual staff picnic | 10-03-2017 | 10 AM |\nThen the employees in other departments should be notified\nThis ability shows the basic flow of events being created and scheduled for entire com-\npanies by HR departments, which are Activitee’s primary users. You can expect that\nthe behaviors and examples from this ability will always be required to create the most\nbasic type of event on the Activitee platform.\n Soon after, the Activitee events team prepares the second ability for the user story that\nstarted the rewriting process in the first place: the paid informal events functionality.\nAbility: Team leads can facilitate teamwork by organizing team outings online\nScenario: Users should be able to pay for events online\nGiven an event created by team lead Mike for his team:\nListing 9.4\n[GOOD] Ability allowing HR reps to create company-wide events\nListing 9.5\n[GOOD] Ability that lets team leaders create paid informal events\n",
      "content_length": 2702,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 227,
      "content": "201\nRefactoring features into abilities\n| name\n|\n| 2nd Bowling Night |\nAnd an attendance fee of $25 set by the team lead\nWhen Jane pays for the event online\nThen she should become a confirmed attendee\nOnce the events team deals with the newest user story, they can move on to reorganize\nthe other requirements that have been added to the specification by different teams\nover time. They start with the scenarios that specify managing and inviting partici-\npants (see listing 9.6). There are four use cases:\nInviting selected individuals\nInviting all people from a specific location\nInviting all people from a specific department\nInviting all people from a specific department in a specific location\nAll of these scenarios deal with targeting. HR representatives want to target different\nevents to different people. They don’t want people from Atlanta to see events that are\norganized for the New York branch. They also know from experience that engineers may\nbe interested in different after-work activities than employees in the sales department.\nAbility: HR reps can target wellness programs by choosing specific audiences\nScenario Outline: Managing invited participants\nGiven James drafted a new event\nWhen he invites <invitee>\nThen only <invitee> should be notified about the invite\nBut <uninvited> should not be notified\nExamples: Invites to one-on-one events such as annual reviews\n| invitee | uninvited |\n| Simona\n| Jane\n|\nExamples: Invites to local events in specific locations\n| invitee\n| uninvited\n|\n| Atlanta employees | New York employees |\nExamples: Inviting one department, but not the other (all locations)\n| invitee\n| uninvited\n|\n| engineers | salespeople |\nExamples: Inviting a specific department from a specific location\n| invitee\n| uninvited\n|\n| Atlanta engineers | New York engineers, salespeople |\nThe remaining three scenarios are related to scheduling issues, so the events team\ndecides to group them together under managing the company’s event calendar.\nListing 9.6\n[GOOD] Ability for targeting event programs\n",
      "content_length": 2039,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 228,
      "content": "202\nCHAPTER 9\nRefactoring features into abilities and business needs\n \nAbility: HR reps can manage their wellness program's calendar by scheduling events\nScenario Outline: Managing simple events and serial events\nGiven a company-wide event called <name>\nAnd that it takes place <date> at <time>\nWhen Simona wants to attend the event\nThen she should get a reminder <date> before <time>\nExamples:\n| name\n| date\n| time\n|\n| Annual staff picnic | on 10-03-2017 | 10 AM |\n| Yoga classes\n| every Monday\n| 10 AM |\nScenario Outline: Managing scheduling conflicts for company-wide events\nGiven a company-wide event created by James:\n| name\n| date\n| time\n|\n| Annual staff picnic | 10-03-2017 | 10 AM |\nAnd that Terry wants to organize another company-wide event:\n| name\n| date\n| time\n|\n| The Move with Purpose Marathon | 10-03-2017 | 10 AM |\nWhen Terry does <action> that the scheduling conflict is OK\nThen the event should be <result>\nAnd the employees in other departments should get <email>\nExamples:\n| action\n| result\n| email\n|\n| confirm\n| published\n| a notification\n|\n| not confirm | not published | no notification |\nScenario: Managing scheduling conflicts for local events\nEvents from local branches shouldn't cause conflicts.\nGiven an Atlanta event created by James:\n| name\n| date\n| time\n|\n| Local staff picnic | 10-03-2017 | 10 AM |\nWhen Terry wants to organize another event in New York:\n| name\n| date\n| time\n|\n| The Move with Purpose Marathon | 10-03-2017 | 10 AM |\nThen the event should be successfully published\nAnd the employees in other departments should be notified\nThe events team ends up with four small specifications split from a single long one.\nEach of the four new feature files deals with a specific area of implementation. Being\nsmaller, they’re also easier to comprehend, and they can be expanded in the future\nwithout losing their readability. The team also splits the scenarios among the stake-\nholders that are relevant to their content. Under the previous system, the feature\ntalked about events created by both HR representatives and individual team leaders.\nNow, each stakeholder has their own specification with their own scenarios.\nListing 9.7\n[GOOD] Ability for managing the event calendar\n",
      "content_length": 2215,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 229,
      "content": "203\nRecognizing and refactoring business needs\nMANAGING THE HIERARCHY OF FEATURE FILES IN THE SPECIFICATION SUITE\nThe last thing we need to discuss before moving on to the second Activitee team is the\nhierarchy of feature files in the specification suite created as a result of the changes\nmade to the suite in this section. In chapter 8, we established a hierarchy of feature\nfiles for abilities (see figure 9.1).\nThe events team uses that hierarchy to organize the four new executable specifica-\ntions (see figure 9.2). They end up with a specification suite organized by abilities and\nstakeholders. Each stakeholder can achieve different outcomes valuable to them.\nThus, the specification suite is now organized as a map of Activitee clients and the\nvalue the company delivers. As you’ll learn in section 9.3, the system is also flexible\nand can be easily expanded to fit other requirements, such as functional aspects of\nnonfunctional requirements.   \n9.3\nRecognizing and refactoring business needs\nNow, let’s move on to the application security team, who take on the user story about\nsecurity:\nIn order to meet my company's security policy\nAs a Fortune 500 company employee\nI want to make sure only I can access my account\nThis section focuses on specifying the functional aspects of the nonfunctional security\nrequirement using the Business Need keyword. You’ll also see how a business need\nAbility\nStakeholder\nOutcome\nFigure 9.1\nThe progression indicates hierarchy. At the \ntop is the Ability keyword, which creates a space for \nuser stories in the specification suite. Next are different \nstakeholders. At the bottom are outcomes that \nstakeholders can achieve.\nHR\nevents.feature\nscheduling.feature\ntargeting.feature\nAbilities\nFeatures\noutings.feature\nTeam leads\nFigure 9.2\nA specification suite \norganized according to abilities of \nstakeholders such as HR \nadministrators and team leads\n",
      "content_length": 1897,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 230,
      "content": "204\nCHAPTER 9\nRefactoring features into abilities and business needs\ncan grow in size over time and how to react when that happens, by slicing the specifi-\ncation into smaller abilities—similar to what the events team did in section 9.2.\n The goal of the application security team is to find and implement solutions that\ncould increase the security of the Activitee platform according to industry standards.\nThey didn’t have to start from scratch. You may remember the business need shown in\nthe following listing, which you wrote for Activitee in chapter 8. An Activitee product\nowner unexpectedly added to the backlog a new story about making passwords in the\nsystem more secure. The team decided that the simplest way to achieve results quickly,\ngiven Activitee’s current capacity, would be to force users to create passwords that are\nharder to crack:\nBusiness Need: Security\nScenario Outline: Passwords should be secure\nGiven Simona has to set a password\nWhen she tries to set the password to <password>\nThen the password should be considered <secure>\nExamples: Too short\n| password | secure\n|\n| shorty\n| insecure |\nExamples: No repetitive or sequential characters\n| password | secure\n|\n| aaaaaaaa | insecure |\nExamples: No usernames, first names, or surnames\n| password\n| secure\n|\n| simonajenkins | insecure |\nExamples: Good password\n| password\n| secure\n|\n| nevergonnagiveyouup | secure\n|\nThe password scenario looked like a good starting point. But the new user story\nimplied a larger scope than just passwords. In order to decide on the most suitable\nsolution, the team needed to understand the broader context of how the new story\nappeared in the backlog in the first place.\n9.3.1\nAdding functional scenarios to business needs\nA quick investigation by the Activitee team determined the origin of the new security\nrequirement. Activitee is a technology platform, and it works best with technologically\nsavvy companies—but most of its early clients were less technologically oriented and\nhad never used software for employee wellness. Such clients were easier to capture,\nbut they also paid less and required more customer service. Most of Activitee’s target\ncustomers already use some kind of wellness program. Activitee, as a new player on\nthe market, had to catch up to its competitors.\n When asked about the security requirement, the sales team confirmed that the\ncompany had reached the point that it could successfully compete with existing\n",
      "content_length": 2453,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 231,
      "content": "205\nRecognizing and refactoring business needs\nemployee wellness solutions, and that the sales team had entered into contract negoti-\nations with some desirable potential clients. But seducing technologically oriented\ncustomers meant the product would have to excel in areas where nontechnical clients\nwere more forgiving—such as application security.\n The application security team was pleasantly surprised to hear from the sales team\nthat at this stage in the negotiations, the business value could be brought by preparing\na few security scenarios showing that Activitee had something in the works. Enterprise\nsales often take months to close, so the team would have lots of time to implement the\nsolutions they would suggest. Saying they were working on something and actually\ndoing it wouldn’t make much of a difference—the sales representatives just wanted a\nfew scenarios to discuss during their sales pitches. Questions about security were pop-\nping up more often, and they needed some leverage. They said that an upcoming\nmeeting with a potential client would be a good opportunity to try the scenarios.\n The application security team decided to add new functional scenarios to the exist-\ning security business need. The first scenario was simple and was requested by the\nteam’s UX designer, who wanted to improve the experience of choosing a strong\nenough password by adding a password strength meter. The designer had wanted to\naddress this omission for a long time, but there was always something more important.\nThe team agreed that they could include it in the scope this time. The scenario out-\nline was as follows.\nScenario Outline: Users should be able to see a password strength meter\nGiven Simona has to set a password\nWhen she tries to set the password to <password>\nThen Simona should see that her password is <strength>\nExamples: Short passwords\n| password | strength |\n| shorty\n| weak\n|\nExamples: Longer passwords that are common dictionary words\n| password\n| strength |\n| imagination | medium\n|\n| countryside | medium\n|\n| inimitable | medium\n|\nExamples: Long, non-obvious passwords\n| password\n| strength |\n| nevergonnagiveyouup | strong\n|\nThe next scenario was suggested by the technical team. Increasingly, two-factor\nauthentication is required for both enterprise-oriented and customer-oriented appli-\ncations. The two-factor authentication the team agreed on would involve entering a\ncombination of a password and a random code sent over SMS.\nListing 9.8\nScenario outline for a password strength meter\n",
      "content_length": 2528,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 232,
      "content": "206\nCHAPTER 9\nRefactoring features into abilities and business needs\n \nScenario Outline: Users should be able to use two-factor authentication\nGiven <authentication> for Simona\nAnd Simona's desire to log in\nWhen she provides her username\nAnd she provides her password\nAnd she enters <code>\nThen she should be <authenticated>\nExamples: Two-factor authentication\n| authentication\n| code\n| authenticated |\n| two-factor auth\n| the correct code | logged in\n|\n| two-factor auth\n| a wrong code\n| not logged in |\nExamples: Make sure single-factor authentication still works\n| authentication\n| code\n| authenticated |\n| traditional auth | no code | logged in\n|\nThe third scenario the team decided to suggest was another industry standard: a\nreviewable login history. With a login history, a user would be able to see where and\nwhen their account was recently used. The team used a simple example of a hacker\nfrom a distant location who somehow got access to the account of an unlucky Activitee\nuser. They also suggested that the user should be able to log out from all devices\nremotely in case of a security breach.\nScenario Outline: Users should be able to review their login history\nGiven Simona's previous logins were from <country>\nWhen somebody logs in to her account from <login>\nThen her account should be considered <compromised>\nAnd Simona should be notified about the security breach\nExamples:\n| country | login\n| compromised |\n| the USA | the USA | secure\n|\n| the USA | the UK\n| compromised |\n| the UK\n| the UK\n| secure\n|\n| the UK\n| the USA | compromised |\nScenario: Users should be able to log out remotely\nGiven Simona was notified about the security breach\nWhen she confirms her identity via two-factor authentication\nThen she should be able to log herself out from all devices remotely\nThe team was happy with the scenarios they prepared. But when the sales representa-\ntives came back from the meeting with the prospective client, they didn’t mention the\nscenarios. They were confused and had only one question: what is SSO, and why don’t\nwe have it?\n We’ll address that question in the next section. \nListing 9.9\nScenario outline to introduce two-factor authentication\nListing 9.10\nScenarios for a login history\n",
      "content_length": 2219,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 233,
      "content": "207\nRecognizing and refactoring business needs\n9.3.2\nIdentifying new stakeholders with business needs\nIn chapter 8, I said that requirements listed as nonfunctional and defined as business\nneeds usually imply that there’s a stakeholder the team hasn’t yet explicitly identified.\nFor example, some stakeholders work behind the scenes and become more active only\nif an issue that interests them is on the table. Such stakeholders can be identified\nwhen new nonfunctional requirements appear, seemingly out of nowhere.\n It turns out this was exactly what happened during the sales meeting that confused\nActivitee’s representatives. The prospective client was interested in security because it\nhad a very active Chief Information Security Officer who was responsible for the com-\npany’s IT and computer systems. The CISO was involved in the process from the get-\ngo, which was something Activitee’s reps hadn’t seen in less technologically savvy com-\npanies. The CISO turned out to be a competent, demanding stakeholder who was the\nultimate decision maker but worked behind the scenes, leaving the negotiations to\nanother executive. But as Activitee reps kept coming back with proposals that weren’t\nsatisfying, the CISO decided to become personally involved.\n During the meeting, the CISO took for granted the scenarios presented by Activi-\ntee’s sales team, which meant they officially became part of the future scope and not\njust proposals, as they were first pitched. Moreover, the CISO wanted Activitee to satisfy\nanother requirement: that’s right, the SSO thing.\nDEFINITION\nSingle sign-on—A session- and user-authentication service that\npermits a user to use one set of login credentials (such as username and pass-\nword) to access multiple applications\nSSO stands for single-sign on. You use consumer-facing versions of SSO every time you\nuse Facebook or Twitter to sign up on a website. In such cases, Facebook and Twitter\nplay the role of identity providers that manage aspects of your accounts. For example,\na website can ask the identity provider for your real name or profile picture and\nupdate it if you changed it on Facebook or Twitter.\n Enterprises need SSO because every day their employees use dozens of applica-\ntions to get the job done. I myself have mostly worked at small-to-medium agencies\nand startups, but even there I used 20 or 30 apps to manage my work—without SSO. It\nwas a pain. For companies with thousands of employees, the pain must be a thousand\ntimes stronger. Enterprise identity providers like okta.com can help teams alleviate\nthe pain and manage their application stack.\n Having investigated the topic, the application security team came up with a few\nnew scenarios to make the business need for security more complete.\nScenario: CISOs should be able to have the IT Security team set SSO up\nGiven a valid SSO API endpoint provided by an IT Security team\nAnd a client ID\nAnd a client secret\nListing 9.11\nSSO scenarios\n",
      "content_length": 2953,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 234,
      "content": "208\nCHAPTER 9\nRefactoring features into abilities and business needs\nAnd a callback URL\nWhen IT Security team activates SSO\nThen the company's Activitee should start pointing to the Identity Provider\nScenario: SSO-enabled users should be authenticated and let in\nGiven an SSO-enabled company\nAnd James, an employee who's logged in to the Identity Provider's system\nWhen he doesn't re-enter his credentials on Activitee when he logs in\nThen he should still be authenticated and let in\nScenario: A company deactivates SSO\nGiven an SSO-enabled company\nWhen their CISO decides to disable SSO\nThen the employees need to enter credentials in order to get in\nThe scenarios require the IT security team to point Activitee’s software toward a work-\ning API endpoint that gives the user account information Activitee needs after identity\nconfirmation. The security team also provides a client ID and a client secret, which the\nidentity provider uses to select the correct company’s user base. A callback URL is then\nrequired to redirect the user back to Activitee. The third new scenario deals with a\ncompany that decides to stop using a given SSO provider; in this case, Activitee must\nforce employees to generate new passwords, because the Activitee platform didn’t\nstore them (the SSO provider did).\n The overarching lesson here is that the Activitee team could have reacted more\nquickly to the fact that a new business need emerged and became increasingly\ndemanding. Had they done so, they would have understood much earlier that there\nwas a stakeholder they hadn’t identified who was working behind the scenes, influenc-\ning their results. If they had talked to that stakeholder directly in the first place, they\nwould have been able to present a scope that was smaller and tailored to the CISO’s\nneeds from the outset. Instead, they ended up committing to scenarios they thought\nwere only proposals—and also had to implement three new SSO-related scenarios. In\nthe end, it was all an issue of stakeholder management. \n9.3.3\nRefactoring functional scenarios in business \nneeds into individual abilities\nSo far, all the security-related scenarios are in a single business need. Figure 9.3 shows\nthe specification suite.\n Although Activitee’s business need started as a simple feature file with a single sce-\nnario, it’s now vastly different. After all the iterations, there are eight different scenarios\nrelated to various areas of the product, such as passwords, two-factor authentication,\nand SSO integration. Now that we know CISOs are important stakeholders with their\nown requests, we suspect that the number of scenarios will keep growing—which means\nit’s time to break the business need into several smaller abilities that will grow inde-\npendently in the future.\n Let’s start with the SSO scenarios, because they’re distinct from the scenarios pre-\npared by the application security team and will be the easiest to extract. Extracting\n",
      "content_length": 2937,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 235,
      "content": "209\nRecognizing and refactoring business needs\nthese SSO scenarios lets us add a specification brief with a lexical definition—just like\nyou practiced doing in chapter 7.\nAbility: CISOs can manage employees easily by integrating with an SSO provider\nSINGLE SIGN-ON (SSO) is a session and user authentication service\nthat permits a user to use one set of login credentials\n(e.g., name and password) to access multiple applications.\nBig companies with hundreds of employees find it hard to manage\nemployees' data across many different internal services while adhering\nto internal security or privacy policies (e.g. some organizations\nchange employees' passwords once a month because of security issues).\nSome might want to implement a custom registration process due\nto legal reasons. All of them will eventually part ways with some of\ntheir employees and will have to make sure that these ex-employees'\nprivate data is deleted across all of the internal services.\nScenario: CISOs should be able to have the IT Security team set SSO up\nGiven a valid SSO API endpoint provided by an IT Security team\nAnd a client ID\nAnd a client secret\nAnd a callback URL\nWhen IT Security team activates SSO\nThen the company's Activitee should start pointing to the Identity Provider\nScenario: SSO-enabled users should be authenticated and let in\nGiven an SSO-enabled company\nAnd James, an employee who's logged in to the Identity Provider's system\nWhen he doesn't re-enter his credentials on Activitee when he logs in\nThen he should still be authenticated and let in\nListing 9.12\nSSO ability broken up from the previous business need\nHR\nevents.feature\nscheduling.feature\ntargeting.feature\nAbilities\nFeatures\nBusiness needs\noutings.feature\nsecurity.feature\nTeam leads\nFigure 9.3\nA specification suite \nwith both abilities and business \nneeds becomes a map of functional \nrequirements and stakeholders \nwho find them important, as well as \nfunctional aspects of nonfunctional \nrequirements important to the \nentire system.\n",
      "content_length": 2002,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 236,
      "content": "210\nCHAPTER 9\nRefactoring features into abilities and business needs\nScenario: A company deactivates SSO\nGiven an SSO-enabled company\nWhen their CISO decides to disable SSO\nThen the employees need to enter credentials in order to get in\nThe application security team also decides to extract the password-strength scenarios\ninto their own ability.\nAbility: Employees can secure their passwords\nScenario Outline: Passwords should be secure\nGiven Simona has to set a password\nWhen she tries to set the password to <password>\nThen the password should be considered <secure>\nExamples: Too short\n| password | secure\n|\n| shorty\n| insecure |\nExamples: No repetitive or sequential characters\n| password | secure\n|\n| aaaaaaaa | insecure |\nExamples: No usernames, first names, or surnames\n| password\n| secure\n|\n| simonajenkins | insecure |\nExamples: Good password\n| password\n| secure\n|\n| nevergonnagiveyouup | secure\n|\nScenario Outline: Users should be able to see a password strength meter\nGiven Simona has to set a password\nWhen she tries to set the password to <password>\nThen Simona should see that her password is <strength>\nExamples: Short passwords\n| password | strength |\n| shorty\n| weak\n|\nExamples: Longer passwords that are common dictionary words\n| password\n| strength |\n| imagination | medium\n|\n| imagination | medium\n|\n| imagination | medium\n|\nExamples: Long, non-obvious passwords\n| password\n| strength |\n| nevergonnagiveyouup | strong\n|\nThe only scenarios that remain in the security business need deal with employees\nauthenticating themselves and managing their identity.\nListing 9.13\nPassword-strength ability\n",
      "content_length": 1616,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 237,
      "content": "211\nRecognizing and refactoring business needs\n \nAbility: Employees can authenticate and manage their identity\nScenario Outline: Users should be able to use two-factor authentication\nGiven <authentication> for Simona\nAnd Simona's desire to log in\nWhen she provides her username\nAnd she provides her password\nAnd she enters <code>\nThen she should be <authenticated>\nExamples: Two-factor authentication\n| authentication\n| code\n| authenticated |\n| two-factor auth\n| the correct code | logged in\n|\n| two-factor auth\n| a wrong code\n| not logged in |\nExamples: Make sure single-factor authentication still works\n| authentication\n| code\n| authenticated |\n| traditional auth | no code | logged in\n|\nScenario Outline: Users should be able to review their login history\nGiven Simona's previous logins were from <country>\nWhen somebody logs in to her account from <login>\nThen her account should be considered <compromised>\nAnd Simona should be notified about the security breach\nExamples:\n| country | login\n| compromised |\n| the USA | the USA | secure\n|\n| the USA | the UK\n| compromised |\n| the UK\n| the UK\n| secure\n|\n| the UK\n| the USA | compromised |\nScenario: Users should be able to log out remotely\nGiven Simona was notified about the security breach\nWhen she confirms her identity via two-factor authentication\nThen she should be able to log herself out from all devices remotely\nWe have three more feature files than we started with, but the upside is that the appli-\ncation security team will be able to grow each area of implementation independently\nin the future. You can also see that each of the specifications we ended up with has two\nor three tightly connected scenarios instead of eight scenarios that try to specify the\nsecurity aspect holistically within a single business need.\n It’s not that the previous business need was bad; it just outgrew its purpose. Busi-\nness needs are used to identify areas where new stakeholders may potentially emerge.\nAs soon as that happens, you can begin working with the stakeholders to develop their\nareas of interest—and abilities are much better for doing that (see figure 9.4).\nListing 9.14\nAbility for employee authentication and identity management\n",
      "content_length": 2197,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 238,
      "content": "212\nCHAPTER 9\nRefactoring features into abilities and business needs\n    \n9.4\nSummary\nYou can convey your requirements as abilities or business needs when deriving\nthem from user stories.\nAdding too many new scenarios to existing executable specifications makes\nthem cover too many topics at once.\nTo avoid covering too many topics, refactor large specifications into smaller\nones.\nEven though many teams use the Feature keyword at the beginning of their\nGherkin journey, they should consider switching to abilities and business needs\nlater on.\nYou can refactor existing features into smaller abilities by splitting the scenarios\njust like the user stories from which they were derived.\nSpecify functional aspects of nonfunctional requirements like security using\nbusiness needs.\nNew business needs usually imply that there’s a stakeholder whom the team\nhasn’t yet explicitly identified.\nWhen a business need grows into having too many functional scenarios, you can\nmove each function to its own ability.\nEmployees\nauthentication.feature\npasswords.feature\nAbilities\nFeatures\nsso.feature\nCISO\nHR\nevents.feature\nscheduling.feature\ntargeting.feature\noutings.feature\nTeam leads\nFigure 9.4\nThe specification \nsuite with new security \nstakeholders, such as CISOs, and \nnew security abilities, such as \nauthentication, which were \nbroken out from a prior business \nneed when it had too many \nfunctional aspects to keep in a \nsingle feature file\n",
      "content_length": 1446,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 239,
      "content": "213\nBuilding a domain-driven\nspecification suite\nThis is the third chapter in a four-chapter series about managing large specification\nsuites. Chapters 8 and 9 discussed actors and using their abilities and business\nneeds as replacements for the Feature keyword. In this chapter, we’ll analyze what\nhappens when actors have too many scenarios and another level of hierarchy is\nneeded—which usually happens in medium-sized projects.\n Figure 10.1 shows a specification suite for the fictional company Activitee of\nchapters 8–11. We built most of this suite in chapters 8 and 9; the figure presents a\nslightly expanded version, after the product has grown into a medium-sized pro-\nject. We’ll talk about the new specifications in section 10.3.\nThis chapter covers\nRecognizing good domain models\nAnalyzing a ubiquitous language\nDistilling business domains from scenarios\nRecognizing different kinds of business domains\nOrganizing a specification suite according to \navailable domains\n",
      "content_length": 985,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 240,
      "content": "214\nCHAPTER 10\nBuilding a domain-driven specification suite\nCISO\nHR\nauthentication.feature\nevents.feature\ninterest groups.feature\nsso.feature\nnews feed.feature\npasswords.feature\nprofile.feature\nredeeming bonuses.feature\nsearch.feature\ngranting bonuses.feature\noutings.feature\nkpi.feature\nevents.feature\ninviting employees.feature\nkpi.feature\nmanaging employees.feature\nonboarding employees.feature\norganization structure.feature\nrewards program.feature\ntargeting.feature\nperformance.feature\nEmployees\nAbilities\nFeatures\nBusiness needs\nTeam leads\nFigure 10.1\nActors in medium-sized projects can have too many abilities, which makes the \nspecification suite more difficult to understand.\n",
      "content_length": 686,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 241,
      "content": "215\nDistilling business domains from a ubiquitous language\nBefore writing this chapter, I looked at some of the real projects I’ve worked on over\nthe last few years. In one of these projects, a specification suite with about 60 scenarios\nhad 380 steps spread between two actors. If you had such a project, then assuming\nevery feature file had about three scenarios, as I advised in chapter 8, you’d end up\nwith about 20 feature files in the suite—10 per actor. A slightly bigger project of mine\nhad 170 scenarios written for 4 actors, 1,120 steps, and about 60 feature files—15 per\nactor. In such cases, a simple split between actors’ abilities and the system’s business\nneeds, introduced in chapter 8, may not be enough. We’re approaching a similar\nthreshold with the Activitee specification suite.\n The concepts we’ll be using to manipulate and comprehend these large domains\ncome from the field of domain-driven design (DDD). This chapter and the next one\nwill rely heavily on ideas borrowed from DDD. You may be familiar with DDD; I first\nmentioned it in chapter 1 when I talked about ubiquitous languages in specifications.\nIn this chapter, we’ll discuss domains—subdomains, core domains, secondary\ndomains, and generic domains—as well as domain models, a ubiquitous language,\nglossaries, bounded contexts, and context maps. This chapter is be a high-level sum-\nmary of the most important concepts of strategic domain-driven design and shows how\nyou can use these techniques in designing your specification suites.\n You’ll begin by distilling business domains from a ubiquitous language. Then,\nyou’ll use the distilled domain to build a domain model. Finally, you’ll reorganize a\nlarge specification suite according to that model, grouping similar feature files\ntogether. Some of these methods were discussed earlier in the book; for example, I\ntalked about a ubiquitous language in various parts of chapters 1, 2, 5, and 7. Chapter\n7, which discussed living documentation, also talked about creating glossaries. We’ll\nnow revisit these concepts in the context of DDD and also introduce new ideas. Keep\nin mind that this chapter is by no means a full introduction to DDD. If interested, you\ncan read more in Eric Evans’ canonical work on the topic: Domain-Driven Design (Addi-\nson-Wesley, 2003). In this case, just as in Evans’ book, everything starts with a ubiqui-\ntous language.\n10.1\nDistilling business domains from \na ubiquitous language\nA ubiquitous language, first mentioned in section 1.2.2, is a language cultivated in the\nintersection of technical and business jargons, derived from multiple sources (see fig-\nure 10.2). Each project has its own ubiquitous language. It’s not the language of the\nbusiness, nor is it the language of technology. It’s a mix of both.\n Domain experts—people with authority in a particular area or topic—have different\ndesign jargons. Technology experts—such as designers, testers, analysts, and engi-\nneers—also have their own jargons. Design jargon is just as bad as technical jargon.\nWhen bankers talk too much about their work, they can be as annoying at the dinner\ntables as programmers, designers, or testers—and they can be just as difficult to under-\nstand for a layperson inexperienced in their domain. The narrower the business\n",
      "content_length": 3281,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 242,
      "content": "216\nCHAPTER 10\nBuilding a domain-driven specification suite\ndomain of a project, the more difficult the language seems to outsiders. But most peo-\nple can understand the consumer-facing aspects of businesses. Pop culture can help,\ntoo: for example, movies about Wall Street have helped people understand basic\nfinance keywords such as shorting, popularized by the 2015 movie The Big Short; and ini-\ntial public offering (IPO), depicted in the critically acclaimed The Wolf of Wall Street in 2013.\n Businesses like Activitee aren’t likely to receive that type of publicity. So, a ubiqui-\ntous language must grow out of blending technological expertise with business exper-\ntise in reasonable proportions. This section explores how you can analyze a\nubiquitous language to derive a model of the business domains used in a specification\nsuite. Deriving the model is the first step in getting to the end goal: creating a proper\nsystem for organizing large specification suites according to the business domain.\n Before we continue our work on Activitee’s specification suite, let’s analyze a sim-\npler example.\n10.1.1 Spotting different domains in your scenarios\nUbiquitous language lies at the heart of DDD. Gherkin scenarios can be a great source\nof a ubiquitous language, because each scenario is a recording of a conversation that\nbusiness experts had with technology experts about requirements. If the recording is\ntruthful, the scenario should easily capture a ubiquitous language that the experts cre-\nated during their conversations, both face-to-face and in writing.\n Naturally, a raw record won’t be perfect. Let’s say you’re sitting in a specification\nworkshop for a simple cloud storage service similar to Dropbox, Google Drive, Apple\niCloud, or Microsoft OneDrive. A domain expert is explaining a behavior, and you’re\nwriting it down as a Gherkin draft. The following record ends up on the whiteboard.\nGiven a 2 GB limit on free cloud drive accounts\nAnd 2 GB of files on Simona's free cloud drive account\nWhen she upgrades to the premium plan\nListing 10.1\nConversation recorded as a Gherkin scenario\nDomain\nexperts\nUbiquitous\nlanguage\nDocumentation\nDelivery\nteam\nSpecifications\nConversations\nTesting code\nApplication\ncode\nFigure 10.2\nThe sources of a ubiquitous \nlanguage—a language that’s created by \nmixing the jargons of technology and \nbusiness in order to build a unified lingual \nmodel that can be used by both the domain \nexperts and the technology experts\n",
      "content_length": 2473,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 243,
      "content": "217\nDistilling business domains from a ubiquitous language\nThen her credit card should be charged $5\nAnd her storage should be upgraded to a 40 GB limit\nIt’s a good enough draft—at least for the brainstorming stage. But if you look at the\nscenario more closely, you’ll see that it introduces terms from several domains into a\nubiquitous language for the team:\nTerms like cloud drive are from the cloud domain.\nGigabytes, files, and storage are from the more general storage domain, which,\nnonetheless, must stay connected to the cloud domain.\nTerms like premium plan, free, and credit card are from the payments domain, also\ncalled the commercial offering domain, which all nonfree products share.\nTIP\nChapter 7 discussed which elements of Gherkin scenarios are important\nparts of a ubiquitous language. They’re elements such as actors, states, out-\ncomes, domain concepts, and actions.\nWe can easily illustrate how different domains map onto the scenario, as shown in fig-\nure 10.3. Notice that some of the domains don’t have to be tightly coupled. For exam-\nple, the payments domain doesn’t have to be connected so closely to the storage\ndomain. Upgrading an account to the premium plan will also make available other,\nnonstorage features, such as team collaboration—so maybe you should look for a\nmore general way to specify the details of the business model. But that doesn’t mean\nyou can uncouple all domains. The storage domain, for example, often remains con-\nnected to the cloud domain, because there can be no cloud storage without having\nstorage in the first place.\n \nGiven a 2 GB limit on free cloud drive accounts\nAnd 2 GB of files on Simona's free cloud drive account\nWhen she upgrades to the premium plan\nThen her credit card should be charged $5\nAnd her storage should be upgraded to a 40 GB limit\nCloud domain\nStorage domain\nPayments domain\nFigure 10.3\nDifferent domains can appear in a single scenario, depending \non how you formulate the behavior using a ubiquitous language.\nExercise 1\nChoose one state, one action, and one outcome from listing 10.1, and assign a\ndomain to each one. If you notice multiple domains in any of the steps, decide which\ndomain should be the most important in this step.\n",
      "content_length": 2221,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 244,
      "content": "218\nCHAPTER 10\nBuilding a domain-driven specification suite\n10.1.2 Distilling the core domain from scenarios\nDomain design, like any other design, is an art of trade-offs. We can clearly see that\nthe domains in listing 10.1 aren’t equal. Delivering products and services is a complex\nendeavor that requires many different activities coordinated among many diverse\ndepartments. Some domains are inherently more important than others, and some\nare more generic than others. This is natural. Your task is to untangle and prioritize\ndomains so that you can decide which ones to focus on. DDD calls such a prioritization\nprocess distillation.\nDEFINITION\nDistillation—A procedure whereby the components of a mixture\nare separated in order to extract the various ingredients, particularly the most\nvaluable one: the heart of the distillate\nWhat should you do about all the different domains in a scenario?\nListing 10.1 presents a scenario that contains multiple subdomains. Should you\nleave it that way or refine it?\nYou faced a similar dilemma in section 3.3.4, which talked about a technique called\noutcome questioning. This technique requires you to ask, “Is there another outcome\nthat also matters but isn’t included in the scenario?” When you asked that question\nin chapter 3, you found another outcome—but it belonged to a completely different\nbusiness domain!\nYou’re facing a similar problem here. In fact, I based this example on the example\nfrom section 3.3.4, with some modifications. You can see the similarities if you com-\npare listing 10.1 with the scenario from chapter 3, repeated here:\nScenario: Upgrading cloud plans\nGiven a 50 MB limit on Vladimir's cloud drive\nAnd 50 MB of text documents on Vladimir's cloud drive\nWhen Vladimir tries to save a new revision in the cloud\nThen he should be upgraded to a plan with more space\nAnd his credit card should be charged $5\nIn the suggested answer to the exercise, which asked you to consider whether the\noutcomes from different domains that appeared back in chapter 3 should be sepa-\nrated, I wrote that, in my opinion, you should specify cloud functionality and paid plan\nlimits separately. I stand by this opinion.\nThe cloud and storage domains can stay together because they’re closely related, but\nthe payments domain should be specified elsewhere in the specification suite. You\ncould, for example, reword the scenario in terms of dealing only with remaining free\nspace on a user’s cloud drive and block the user’s ability to upload new files. Then,\nin a separate specification, you could have all the scenarios that deal with premium\naccounts and payments. Among them, you’d be able to include a scenario to specify\nhow much disk space free and premium accounts have. \n",
      "content_length": 2730,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 245,
      "content": "219\nDistilling business domains from a ubiquitous language\nIn the case of the storage service, if you were to distill the business into the several\ndomains mentioned in section 10.1.1, the cloud domain would clearly be the heart of\nthe distillate. In other words, the cloud domain is the core domain.\nDEFINITION\nCore domain—A domain most closely associated with the strategy\nand market positioning of a company. It’s a domain of the utmost value.\nA competitive company must excel at its core domain. The cloud storage company in\nthe example must excel at the cloud domain if it wants to deliver enough value to its\ncustomers in this crowded market. By distilling the core domain, you can understand\nwhich scenarios and domain concepts are the heart of your software system and there-\nfore should be more important than others. \n10.1.3 Distilling subdomains accompanying the core domain\nIn addition to the core cloud domain, the example company distills into two other\ndomains: storage and payments. If the core domain is the most important domain,\nthen, by definition, you can have only one core domain. What are the other domains?\nThey’re subdomains: domains other than the core domain, which aren’t at the heart of\nthe company but are nonetheless necessary to sustain its strategic mission.\n To understand the concept of subdomains more easily, look at your own life. We all\nhave something important at the center of our lives. For some people, it’s family. For\nother people, it’s a passionate interest. This is a core domain. Although you know that\nit matters to you above all else, you know that a full human life has other, less important\naspects, too, which support your well-being. Work is a good example. Other aspects are\nmore mundane—like going shopping and paying taxes. They’re the remaining sub-\ndomains of your life.\nSUPPORTING SUBDOMAINS\nLet’s get back to the storage service. If you were to point out the domain that’s next-\nmost-important after the core domain, you’d probably choose the storage subdo-\nmain. Cloud storage obviously differs from physical storage, but the company needs\nsome classic storage expertise, too, to become a viable player in the cloud industry.\nThis is why domains like the storage domain from the example are called supporting\nsubdomains.\nDEFINITION\nSupporting subdomain—A domain that indirectly supports the\ncore domain without belonging to it. Even though only one domain can lie at\nthe heart of a company, each core domain needs subdomains to support its\nstrategic mission.\nA company doesn’t have to excel at its supporting subdomains. The value of support-\ning domains, in isolation, is weak. You just have be good enough not to fall too far\nbehind the competition. In the example, storage is a well-penetrated area with multi-\nple industry standards and established solutions that we don’t have to develop on our\nown. The company doesn’t have to drive innovation in this subdomain. You only\n",
      "content_length": 2941,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 246,
      "content": "220\nCHAPTER 10\nBuilding a domain-driven specification suite\nneed to make sure it works at a standard level that customers have learned to gener-\nally accept.\n By distilling supporting subdomains, you learn which domain concepts should be\ntaken care of after you deal with your core domain. Learning that is important\nbecause it lets you allocate appropriate resources to the supporting subdomains and,\ntherefore, avoid over- and underinvestments.\nGENERIC SUBDOMAINS\nThe payments domain is also a subdomain—but it’s different than storage. Storage is\nat least thematically related to the core domain. The payments domain is, in this case,\na generic domain, like authentication or account management. It’s like paying taxes\nin my earlier metaphor comparing subdomains to areas of life.\n Such domains are required for the software to function, but they don’t come from\nor influence the core domain. This is why we call such domains generic subdomains.\nDEFINITION\nGeneric subdomain—A universal subdomain that can appear in\nany kind of software and includes standardized solutions such as account\nmanagement and support functionalities. Whereas supporting subdomains\nsupport the core domain without belonging to it, generic subdomains don’t\nhave to be related to the core domain; they’re meant to increase utility and\nmake basic services work.\nSome other classic examples are accounting, human resources, and project manage-\nment. Some technical solutions, such as search, can also be generic subdomains.\nGeneric subdomains are usually the least important subdomains in terms of market\ncompetition—I’ve never heard of anyone choosing a product or a service because of its\ngreat payments system. Still, generic subdomains are essential and can’t be ignored. For\nexample, you instinctively know that you can’t ignore the payments subdomain—but at\nthe same time, you could delegate it or even outsource it to a third-party service.\nExercise 2\nThink of one more supporting subdomain that could be relevant to the cloud storage\nservice.\nExercise 3\nCan you think of another generic subdomain?\n",
      "content_length": 2082,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 247,
      "content": "221\nCreating a domain model from distilled domains\n10.2\nCreating a domain model from distilled domains\nTogether, the core domain and the subdomains, distilled from a ubiquitous language,\ncreate a domain model. Chapter 1 said that a domain model is a simplification of the\nreal-world business domain—an interpretation of reality that abstracts only the\naspects relevant to solving the problem at hand.\n Better models help you solve problems more reliably and easily. If you can not only\norganize scenarios by requirements, as you did in chapter 8, but also organize require-\nments by their corresponding domains, then you can build better domain models—which,\nin turn, will help you maintain and organize large enterprise systems and start har-\nnessing DDD’s benefits. In this section, you’ll prepare to create a domain model from\nthe subdomains distilled from the ubiquitous language. We’ll look at why good mod-\nels are important and what makes a good model.\n10.2.1 The domain model and the specification suite\nHere’s a quick example of how you can organize the requirements in a specification\nsuite by their corresponding domains, thus creating a visual representation of the\ndomain model included in that specification suite. This example is also based on the\ncloud storage service, to maintain continuity.\n Let’s assume that the distillation process is finished, and you’ve extracted all the rel-\nevant subdomains. You end up with a complete list of actors and their abilities, pre-\npared based on the practices covered in chapter 8, as well as several business needs that\nspecify a few functional aspects of your nonfunctional requirements (see figure 10.4).\n As you can see, the abilities—or functional requirements—in the system are orga-\nnized by their corresponding subdomains. (I added a new generic subdomain for\naccess control to make the specification suite a little more complex.) Now, even if a\nsingle actor has multiple capabilities, you can split all of them among various subdo-\nmains. You can also see which actors are present in which subdomains, which will help\nyou understand which subdomains are important to which stakeholders. In addition,\nyou can make an inverse deduction: you’re able to see which stakeholders can be\ninstrumental in developing the subdomains. Also notice that you haven’t done any-\nthing with business needs; they’re nonfunctional requirements, and nonfunctionals\nare general qualities like speed or usability—they belong to the entire system instead\nof specific subdomains.\n Such a specification suite can become a visual representation of the domain model\nspecified by this suite. You can see a clear hierarchy of subdomains, actors, and\nrequirements. Moreover, a representation like this can evolve naturally over time,\nbecause the requirements are tied to the domain logic code by the automated tests. If\nyou change the requirements or change the domain logic, you’ll probably need to\nadd, delete, or move the feature files related to the changed requirements—and your\nvisualization of the model will change alongside the model.\n",
      "content_length": 3078,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 248,
      "content": "222\nCHAPTER 10\nBuilding a domain-driven specification suite\n10.2.2 Why are good domain models important?\nNow that you know how to create a simple domain model based on a ubiquitous lan-\nguage, we can discuss why good models are important. In chapter 1, you learned that\n80% of all product defects are inserted when delivery teams define their require-\nments. If you look at each requirement as a problem to solve on behalf of your cus-\ntomers, you can assume that building better domain models will result in fewer\nmisunderstood requirements. To build a realistic model of your business domain, you\nAccess\ncontrol\n[Some feature files]\n[Some feature files]\n[Some feature files]\n[Some feature files]\nPayments\n[Some feature files]\nCloud\nAdmins\nManagers\nGuests\nEmployees\nAdmins\nAdmins\nEmployees\n[Some feature files]\n[Some feature files]\nAbilities\nFeatures\nBusiness\nneeds\n[Some feature files]\nStorage\nActors in subdomains\nA generic subdomain\nThe core domain\nA generic subdomain\nFunctional\nrequirements\nNonfunctional\nrequirements\nA supporting\nsubdomain\nFigure 10.4\nA specification suite organized by the subdomains present in the suite. Each \nsubdomain features a list of actors relevant to this subdomain. Every actor can have various \ncapabilities in each of the subdomains.\n",
      "content_length": 1271,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 249,
      "content": "223\nCreating a domain model from distilled domains\nmust not only understand particular requirements, but also understand how they\nrelate to each other.\n Maps can help. Maps often show how we think about the world around us. When\nthe model depicted in a map is wrong, the decisions made based on the incorrect map\nare more likely to be wrong, too. By more likely, I mean that you won’t necessarily be\nwrong every time you use a wrong model—but you’ll increase the long-term risk factor of\nbeing wrong. Let me explain what I mean.\n The geocentric map of the solar system, also called the Ptolemaic model, depicted\na universe where the sun, moon, stars, and planets all circled Earth. The geocentric\nmodel was eventually replaced by the heliocentric model, including Copernican helio-\ncentrism. But the Ptolemaic model was good enough for scientists to successfully per-\nform many calculations. Both the Copernican and Ptolemaic models provided\nidentical results for identical inputs. Only after Kepler demonstrated that the sun is\ndirectly involved in determining a planet’s orbit was a new model required. If you\nabstain from talking about the real world for a moment, the geocentric model is only\nwrong when you go deep into the details.\n At times, something similar happens with software. I’ve seen projects that didn’t\ncare much about mapping the business domain but that still delivered working soft-\nware, even though it was based on imperfect models. Some of these projects worked\nwell enough for a long time because they were all the business owners needed. Good\nfor them. But other projects turned out to be unmaintainable in the long term and\nfailed spectacularly when the teams tried to modify the scope by adding new require-\nments or expanding existing capabilities. Every time, it was a truly Copernican\nmoment, in the sense that finding out a Ptolemaic model is wrong is usually very pain-\nful—and very expensive. \nWhy organize specification suites by subdomains?\nAn early reviewer of this book asked the following question:\nThe book talks about the idea of organizing specifications by domains. Fine, but\nwhy not organize them by actors instead?\nIt’s an interesting question. Chapter 8 left you with a simpler organization system\nthat had actors at the top. Why should you now adopt a different system, with busi-\nness domains at a higher level of the hierarchy?\nThe reason is that actors and stakeholders don’t always define business domains,\nbut business domains always define the stakeholders and actors. Business value is\nalways dictated by the core domain. For example, a banking company will only hire\nbanking personnel—the actors are derived from the business domain. The ubiquitous\nlanguage, too, is created out of particular domains: you aren’t interested in the way\ndomain experts talk, but rather in their subject-matter expertise. \n",
      "content_length": 2858,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 250,
      "content": "224\nCHAPTER 10\nBuilding a domain-driven specification suite\n10.2.3 What makes a good domain model in software?\nBad models lead you to make wrong decisions. Good models, on the other hand, have\nthese characteristics:\nAccurate enough to find a good solution to a problem\nUnified, as in “the model is internally consistent”\nStable in finding good solutions over time\nRealistic and empirically based on the real world\nAttributes such as accuracy are easy to accept. But some attributes are more controversial.\n If a good model has to be stable, should you advocate iterative software develop-\nment? Throughout the book, I’ve talked about the process of discovering require-\nments and refining models over time. Discovering requirements sounds fine, but what\nif your discoveries lead you to a painful Copernican moment, as described in the pre-\nvious section?\n Just as software development can be iterative, so can science. New theories replace\nold theories and tend to be better. The same is true with software development. New\ndomain models tend to be better than old models. The challenging issue is how to\nmanage the transition risk between the old and new models. The risk is lowered if the\ntransition is small and the model improves iteratively over small batches of changes.\nThe risk is also reduced if the model is strengthened by automated tests. In general,\ntests make a model stronger because automation ensures that you’re tying the model\ndirectly to code, which creates powerful feedback loops between changes in the\nmodel and changes in the code. (Feedback loops were discussed in chapter 6.) SBE\nand Gherkin, as explained in this book, employ both of these practices.\n Feedback loops help with unification of the model, too. When a model is fre-\nquently validated by automated tests, you can be sure that it’s internally consistent to\nthe level covered by the tests. \n10.3\nBuilding a domain-driven specification suite \nin practice\nWe can now get back to the Activitee example. In this section, we’ll derive domains\nfrom a few of the specifications created for Activitee in the previous chapters. We’ll do\nthe same for a few new specifications shown in figure 10.1, when we were imagining\nwhat a medium-sized suite could look like in Activitee’s case. Thanks to the distillation\nprocess, you’ll be able to add another layer to your suite-building skills as we organize\nActivitee’s specifications and actors by their subdomains. The new layer should result\nin something we’ll call a domain-driven specification suite.\nDEFINITION\nDomain-driven specification suite—A specification suite organized\naccording to its various domains. Domain-driven suites are easier to manage\nwhen you have too many actors or when actors have too many abilities.\n",
      "content_length": 2753,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 251,
      "content": "225\nBuilding a domain-driven specification suite in practice\n10.3.1 Distilling subdomains from unequivocal scenarios\nLet’s begin with an easy, unequivocal example. Back in chapter 9, we wrote the follow-\ning ability, which specifies how employees can authenticate and manage their identity\non the Activitee platform.\nAbility: Employees can authenticate and manage their identity\nScenario Outline: Users should be able to use two-factor authentication\nGiven <authentication> for Simona\nAnd Simona's desire to log in\nWhen she provides her username\nAnd she provides her password\nAnd she enters <code>\nThen she should be <authenticated>\nExamples: Two-factor authentication\n| authentication\n| code\n| authenticated |\n| two-factor auth\n| the correct code | logged in\n|\n| two-factor auth\n| a wrong code\n| not logged in |\nExamples: Make sure single-factor authentication still works\n| authentication\n| code\n| authenticated |\n| traditional auth | no code | logged in\n|\nScenario Outline: Users should be able to review their login history\nGiven Simona's previous logins were from <country>\nWhen somebody logs in to her account from <login>\nThen her account should be considered <compromised>\nAnd Simona should be notified about the security breach\nExamples:\n| country | login\n| compromised |\n| the USA | the USA | secure\n|\n| the USA | the UK\n| compromised |\n| the UK\n| the UK\n| secure\n|\n| the UK\n| the USA | compromised |\nScenario: Users should be able to log out remotely\nGiven Simona was notified about the security breach\nWhen she confirms her identity via two-factor authentication\nThen she should be able to log herself out from all devices remotely\nThe three scenarios are very focused. They talk about one thing, and one thing only:\nsecurity (see table 10.1). Their business context explains that; they were created when\nActivitee signed a new client that had an active Chief Information Security Officer\nresponsible for its IT and computer systems.\nListing 10.2\nfeatures/abilities/security/employees/authentication.feature\n",
      "content_length": 2020,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 252,
      "content": "226\nCHAPTER 10\nBuilding a domain-driven specification suite\n \nSpecifications like this are easy to analyze, because they’re unequivocal. You can derive\nthe domain easily, because the scenarios talk about a single topic. If all Gherkin speci-\nfications maintained this one-to-one relationship between scenarios and domains, our\njob in this section would almost be done. Unfortunately, as you saw in figure 10.3, and\nas you’ll see in the sections to come, reality isn’t always organized so neatly. \n10.3.2 Distilling subdomains from mixed scenarios\nSecurity wasn’t the only topic covered in chapter 9. You also prepared specifications\nthat allowed HR representatives to target programs to specific audiences.\nAbility: HR reps can target wellness programs by choosing specific audiences\nScenario Outline: Managing invited participants\nGiven James drafted a new event\nWhen he invites <invitee>\nThen only <invitee> should be notified about the invite\nBut <uninvited> should not be notified\nExamples: Invites to one-on-one events such as annual reviews\n| invitee | uninvited |\n| Simona\n| Jane\n|\nExamples: Invites to local events in specific locations\n| invitee\n| uninvited\n|\n| Atlanta employees | New York employees |\nExamples: Inviting one department, but not the other (all locations)\n| invitee\n| uninvited\n|\n| engineers | salespeople |\nExamples: Inviting a specific department from a specific location\n| invitee\n| uninvited\n|\n| Atlanta engineers | New York engineers, salespeople |\nThe language in the four scenarios from listing 10.3 isn’t as unequivocal as in the pre-\nvious specification (see table 10.2). At least two domains can be derived from the new\nsteps. Some domain concepts refer to the events domain, others to the domain of\norganization.\n If we only wanted to analyze the ubiquitous language of the specification suite, say-\ning that there are two distinct domains at play would be fine. The problem is that we\nwant to organize the suite by its domains. Because the file system is a hierarchical\nstructure, we can only assign the feature file that includes the ability from listing 10.4\nTable 10.1\nDomain in listing 10.3\nDomain\nUbiquitous language\nSecurity\nAuthentication, two-factor authentication, password, compro-\nmised account, secure, security breach, identity, remote logout\nListing 10.3\nfeatures/abilities/events/HR/targeting.feature\n",
      "content_length": 2353,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 253,
      "content": "227\nBuilding a domain-driven specification suite in practice\nto a single domain (if we want various directories to represent various domains).\nThat’s why we have to choose between the two domains we just distilled.\n We can make the choice based on multiple approaches:\nTreat the core domain as more important than other subdomains. In Activitee’s case,\nthe events domain clearly is the core domain. The downside of this approach is\nthat the core domain will always take precedence in every scenario it appears\nin—which isn’t something we want, because most scenarios have to deal with\nthe core domain in one way or another.\nCount the domain concepts (terms) in each domain, and assume that the more popular\ndomain is also more important. The first downside is that we have no guidelines for\ndealing with draws (ties). The second downside is that some domains will be\nmore popular only because they’re more generic than others or because they\nhave more nonfunctional aspects, making it easier for them to spread horizon-\ntally across the suite.\nCombine the two previous approaches in an attempt to calculate the relative weight of each\ndomain. This approach acknowledges that some domains (such as the core\ndomain) are inherently more important than others. But it also acknowledges\nthat domains with more domain concepts can, in some cases, be even more\nessential than the core domain.\nTable 10.2 shows that the specification from listing 10.4 is close to a draw, with a 5-4\nresult. We can assume that the distilled domains are almost equally important to the\ndistillate. Personally, I recommend choosing the events domain, because the scenarios\nonly talk about managing participants, and the core domain can take precedence in\nthis case.\n Next, let’s talk about an example where the opposite is true. In chapter 8, we pre-\npared a specification similar to the one from listing 10.4. It said that employees should\nonly see Activitee content that’s relevant to them—and that relevancy should be calcu-\nlated based on their branches and departments.\nAbility: Employees can see content they like in the news feeds for their branches\nScenario Outline: Employees should only see content relevant to them\nGiven <person> from <branch> who works in <department>\nWhen <person> looks at the company dashboard on Activitee\nThen <person> should see <type> <content>\nTable 10.2\nDomains in listing 10.4\nDomain\nUbiquitous language\nEvents\nEvent, draft, invite, participants, annual review\nOrganization\nEmployee, team, location, department\nListing 10.4\nfeatures/abilities/organization/employees/news feed.feature\n",
      "content_length": 2599,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 254,
      "content": "228\nCHAPTER 10\nBuilding a domain-driven specification suite\nExamples: Employees should see after-work content only from their location\n| person | branch\n| department\n| type\n| content |\n| Jane\n| New York | Engineering | New York after-work\n| events\n|\n| Mike\n| New York | HR\n| New York after-work\n| posts\n|\n| Tom\n| Atlanta\n| Sales\n| Atlanta after-work\n| events\n|\n| Ramona | Atlanta\n| Engineering | Atlanta after-work\n| posts\n|\nExamples: Employees should see work-related content from all locations\n| person | branch\n| department\n| type\n| content |\n| Mike\n| New York | HR\n| Atlanta HR\n| events\n|\n| Jane\n| New York | Engineering | Atlanta engineering\n| posts\n|\n| Jane\n| New York | Engineering | New York engineering | events\n|\n| Tom\n| Atlanta\n| Sales\n| Atlanta sales\n| events\n|\n| Ramona | Atlanta\n| Engineering | Atlanta engineering\n| posts\n|\n| Ramona | Atlanta\n| Engineering | New York engineering | events\n|\nNOTE\nI counted posts as part of the organization subdomain because Activi-\ntee’s news feed treats posts as pieces of content published in various interest\ngroups. Groups belong to the organization domain.\nIf you look at table 10.3, you’ll see that listing 10.5 is the opposite of listing 10.4. It’s\nclose to a draw again—but this time, it’s a 3-5 result in favor of the organization subdo-\nmain. This, together with the fact that the examples talk not only about events but also\nabout posts in interest groups, impels me to recommend adding this specification to\nthe organization subdomain.\n10.3.3 Distilling subdomains from other scenarios\nWe now have three domains with at least one scenario assigned: security, events, and\norganization. We can use the same decision-making framework for other specifica-\ntions in the suite, so we won’t focus as much on the distillation process as in the previ-\nous examples. Instead, we’ll look at examples that introduce new subdomains, so that\nour analysis will be more diverse.\n Let’s analyze a specification that wasn’t included in chapters 8 or 9. At the begin-\nning of the chapter, I added it to figure 10.1: the kpi.feature file.\n Key performance indicators (KPIs) are a common type of performance measure-\nment. KPIs evaluate the success of an organization or a particular activity in which it\nengages. Activitee provides HR departments with analytical tools that help them track\ntheir KPIs. The rationale is that analytics give HR representatives a sense of current\ndirection and let them plan their event strategy in the long term. One of the KPIs in\nActivitee is the adoption metric.\nTable 10.3\nDomains in listing 10.5\nDomain\nUbiquitous language\nEvents\nEvents, after-work, work-related\nOrganization\nEmployee, branch, department, location, posts \n",
      "content_length": 2700,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 255,
      "content": "229\nBuilding a domain-driven specification suite in practice\n \nAbility: HR can analyze adoption metrics to keep track of their KPIs\nScenario Outline: Calculating adoption goals\nOur assumption is that employee distribution\nbetween interests should be that every\ninterest group should aim to have at least 5%\nof the overall employee base. This is meant to ensure\nthat there are no \"dead\" interests nobody\nlikes.\nTHE FORMULA FOR THE ADOPTION GOAL\nthe adoption goal = (`active_groups` * 100%) / all interest groups\n`active_groups` = groups with more users than `required_users_per_group`\n`required_users_per_group` = 5% of all employees\nGiven HR set the adoption goal to 60%\nAnd the company has <users> employees registered\nAnd there are <groups> interest groups in the organization\nAnd only <active> interest groups have more members than <required>\nWhen the current adoption goal is calculated\nThen it should be at <goal>\nAnd Mike's company <should> be meeting their KPIs\nExamples: Must be enough active groups\n| users | groups | active | required | goal | should\n|\n| 200\n| 20\n| 12\n| 10\n| 60%\n| should\n|\n| 200\n| 20\n| 11\n| 10\n| 55%\n| should not |\nExamples: The size of the user base should affect the goal\n| users | groups | active | required | goal | should\n|\n| 2000\n| 20\n| 12\n| 100\n| 60%\n| should\n|\n| 2000\n| 20\n| 11\n| 100\n| 55%\n| should not |\nThis time, the choice is easy. The analytics subdomain is both the most frequently\nmentioned and, based on the examples, is the most important subdomain in listing\n10.6 (see table 10.4).\nThe last specification we’ll analyze is an ability for employees to redeem bonus points\nas engagement rewards (see listing 10.6). Team leaders who use Activitee can grant\ntheir subordinates bonus points for teamwork. The employees can later redeem the\npoints to get rewards from a special rewards catalog prepared by the HR department.\nListing 10.5\nfeatures/abilities/analytics/HR/kpi.feature\nTable 10.4\nDomains in listing 10.6\nDomain\nUbiquitous language\nEvents\nInterests\nOrganization\nEmployee, employee base, interest groups\nAnalytics\nKPI, adoption, goal, activity\n",
      "content_length": 2095,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 256,
      "content": "230\nCHAPTER 10\nBuilding a domain-driven specification suite\n \nAbility: Employees can redeem their bonuses to get engagement rewards\nScenario Outline: Redeeming a bonus as an employee\nGiven a Fortune 500 company like Coca-Cola\nAnd a bonus of 100 points granted to Simona by her team lead\nAnd a company rewards catalog:\n| reward\n| points needed |\n| A Starbucks Gift Card | 100\n|\n| A dinner with the CEO | 100000\n|\nWhen Simona tries to redeem her bonus points to <reward>\nThen she should <outcome>\nExamples:\n| reward\n| outcome\n|\n| A Starbucks Gift Card | get her reward\n|\n| A dinner with the CEO | see she doesn't have enough points |\nTable 10.5 shows that the bonuses subdomain is the clear winner in this case.\n10.3.4 Creating a specification suite from distilled domains\nWe end up with five distinct domains (see table 10.6). We’re also able to prioritize the\ndomains. I’ve already said that the events domain is the core domain because it lies at\nthe heart of Activitee’s platform. Security, on the other hand, is a classic generic sub-\ndomain: the company is only required to adhere to industry standards that almost all\nenterprise applications have to deal with. We’ll automatically treat all the other\ndomains as supporting subdomains.\nNOTE\nAn early reviewer of this book argued that the analytics domain should\nbe a generic subdomain instead of a supporting subdomain. I would usually\nagree, but I think Activitee’s case is different. Metrics are becoming more\nimportant in the HR world. Activitee’s sales team uses their data-driven prod-\nuct and analytical tools as important parts of their sales pitch. That’s why I\nListing 10.6\nfeatures/abilities/bonuses/employees/redeeming bonuses.feature\nTable 10.5\nDomains in listing 10.6\nDomain\nUbiquitous language\nOrganization\nCompany, team lead\nBonuses\nBonus, points, reward, rewards catalog, redeeming \nTable 10.6\nDomains in Activitee’s specification suite\nType\nDomains\nCore domain\nEvents\nSupporting subdomains\nOrganization, bonuses, analytics\nGeneric subdomains\nSecurity\n",
      "content_length": 2022,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 257,
      "content": "231\nAnswers to exercises\ndecided to list the analytics domain as a supporting subdomain: it’s important\nto the most important stakeholders—HR representatives.\nNow that all the important subdomains have been distilled, we can reorganize Activitee’s\nspecification suite according to everything learned in this chapter (see figure 10.5).\nHere’s what you can do with a domain-driven suite like this one:\nClose branches of the directory tree to reduce noise from the many subdomains\nin the specification suite.\nGrade subdomains on their importance by counting how many specifications\nare featured in each subdomain.\nTrack subdomains’ growth over time.\nSee how many actors each subdomain has to deal with, and map the relevant\nstakeholders and their interests.\nWatch new stakeholders appear in selected subdomains.\nIf you’re using a version control system to store your specification suite, you should be\nable to track all that at any point in time—the feature files and their file structure will\nbe stored in the commits. For example, you should be able to rewind and statistically\ndetermine which areas of your product have grown the most in the last six months.\nAnd because domains are mostly derived from the business aspects of a project and are\nseldom dictated by technology, you can also determine where the most business value\nwas added. If you do that, you will, for example, be able to say which aspects of your\nproduct you should continue investing in—and which maybe aren’t worth the effort. \n10.4\nAnswers to exercises\nEXERCISE 1\nChoose one state, one action, and one outcome from listing 10.1, and\nassign a domain to each one. If you notice multiple domains in any of the steps,\ndecide which domain should be the most important in this step:\nA storage state: a 2 GB limit\nA commercial offering action: upgrade to the premium plan\nA payments outcome: her credit card should be charged\nEXERCISE 2\nThink of one more supporting subdomain that could be relevant to the\ncloud storage service:\nA file access-control subdomain can be a good example. Some files should only be\naccessible to the people they were shared with.\nEXERCISE 3\nCan you think of another generic subdomain?\nA user access-control subdomain would be generic in most systems. Although file access\ncontrol would be connected to the core domain of the cloud storage system and thus be a\nsupporting subdomain, a user ACL, regulating which user could access which teams,\nwould be a generic subdomain. User access control, along with authentication, could\neven be in the same bounded context for account management.\n",
      "content_length": 2587,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 258,
      "content": "232\nCHAPTER 10\nBuilding a domain-driven specification suite\nHR\nkpi.feature\nTeam leads\ntracking performance.feature\nEmployees\nredeeming bonuses.feature\nHR\nrewards program.feature\nTeam leads\ngranting bonuses.feature\nevents.feature\nEmployees\nsearch.feature\nevents.feature\nHR\nscheduling.feature\ntargeting.feature\nTeam leads\noutings.feature\ninterest groups.feature\nEmployees\nnews feed.feature\nperformance.feature\nprofile.feature\ninviting employees.feature\nmanaging employees.feature\nonboarding employees.feature\norganization structure.feature\nCISO\nsso.feature\nEmployees\nauthentication.feature\npasswords.feature\nHR\nHR\npermissions.feature\nAbilities\nFeatures\nBusiness\nneeds\nSecurity\nOrganization\nEvents\nBonuses\nAnalytics\nFigure 10.5\nA medium-sized Activitee specification suite, \norganized by domains such as the core events domain; \nsupporting subdomains including organization, bonuses, \nand analytics; and a generic security subdomain\n",
      "content_length": 930,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 259,
      "content": "233\nSummary\n10.5\nSummary\nGherkin helps you build better domain models by capturing a ubiquitous lan-\nguage, one of the main concepts from a software development methodology\ncalled domain-driven design (DDD).\n\nDDD is an approach to software development for complex needs that connects\nthe implementation to an evolving model created with domain experts.\nDomain experts are the people who know the most about a high-priority area of\nthe business. When domain experts and technical experts communicate, they\nuse—and simultaneously create—a shared, ubiquitous language.\nThrough a ubiquitous language, you can distill all the different subdomains\nand build a better map of your business domain by organizing the require-\nments in the specification suite according to their subdomains.\nThe core domain is the domain where the most value should be added in your\nsystem.\nA supporting subdomain models some aspect of the business that is essential,\nbut not core.\nA generic domain captures nothing special to the business, but it’s required for\nthe overall business solution.\n",
      "content_length": 1073,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 260,
      "content": "234\nManaging large projects\nwith bounded contexts\nThis is the final chapter in our four-chapter series about managing specification\nsuites. Chapters 8, 9, and 10 talked about managing small- to medium-sized suites.\nIn this chapter, we’ll split a large specification suite into several smaller suites, each\nof which will be a unified model of a particular subarea of a complex business\ndomain. In doing this, you’ll see how the challenge of managing large specification\nsuites can be viewed as a task of managing multiple medium-sized suites, which is\nsomething you already know how to do.\n One of the biggest projects I’ve worked on while using SBE and Gherkin spread\ninto multiple applications, each having its own specification suite. The applications\nThis chapter covers\nRefactoring large specification suites\nRecognizing false cognates and duplicate concepts\nManaging bounded contexts\nDrawing context maps\nFitting domain-driven design into an SBE process\n",
      "content_length": 964,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 261,
      "content": "235\nAnalyzing domain concepts in context\ndealt with the same business domain, but they were managed by separate teams, some\nof which were outsourced. As systems grow too complex to know completely at the\nlevel of individual capabilities, you need techniques for manipulating and compre-\nhending large domains easily, as well as sharing consistent organization models\namong multiple technical teams.\n This hasn’t yet happened in the Activitee example. In the previous chapters, you\nsaw Activitee evolve from having a small specification suite to a medium-sized one. In\nthis chapter, we’ll fast-forward its evolution to a later stage so that you can learn the\ntechniques necessary to deal with really large suites. By large, I mean that it would be\npointless to try to show you an illustration of this suite—it wouldn’t fit on a single\npage, and we’d have to take too much time to analyze it.\n Given the way I’ve been talking about the domain model, you might assume that\nthe goal is to create a single, cohesive, all-inclusive model of the organization’s entire\nbusiness domain. That’s not correct. Experience shows that no matter how hard you\ntry, you’ll never be able to create a unified model for an entire organization. The\nsubject-matter experts will keep expanding their ubiquitous languages by adding,\nmodifying, and removing domain concepts as they see fit—often without maintaining\nconsistency within the larger organization. In this regard, ubiquitous languages are\nlike dialects. Dialects are based on the same core language, just as ubiquitous lan-\nguages are based on the same core domain in the corporate world. If you tried to\nforce people to unify their dialects into a single official language, the task would take\nyears—even if you assumed total cooperation. The process wouldn’t be impossible,\nbut the cost could end up outweighing the benefit. Now, imagine the same challenge\nin the corporate world. Yuck, right?\n Integrating different ubiquitous languages isn’t worth the effort required to create\na unified model of the entire business domain. If making a unified model of a com-\nplex domain isn’t an optimal choice, how can you organize large enterprise specifica-\ntion suites according to a domain model? Fortunately, domain-driven design (DDD)\nhas an answer to this question. The answer, as often happens in DDD, begins with the\nconcept of ubiquitous language and the process of translation.\n11.1\nAnalyzing domain concepts in context\nThis section explores the process of translation among dialects that appear in a speci-\nfication suite as it grows larger and includes more subdomains. Each subdomain\ncomes with its own dialect; in different dialects, the same word can mean opposite\nthings, or the same thing can have two names. Soon, you’ll see how to spot such words\nin a specification suite and how to deal with them. If you understand the problem of\ndealing with coexisting dialects, you’ll be able to solve it later in the chapter and learn\nhow to manage large specification suites.\n",
      "content_length": 3013,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 262,
      "content": "236\nCHAPTER 11\nManaging large projects with bounded contexts\n11.1.1 Spotting false cognates\nActivitee is becoming larger. The product is growing, the specification suite is grow-\ning—and there have been growing pains. For example, a new team member will\nquickly notice that there’s something called an event in multiple places in the growing\nspecification suite. Sometimes events are put in an obvious context (see listing 11.1),\nbut other times they’re found in places where, at face value, they shouldn’t be—like\nthe application security subdomain (see listing 11.2).\nScenario: Team leads and HR should be able to cancel events\nGiven an event created by Mike for his team:\n| name\n| date\n| time\n|\n| Bowling | 10-03-2017 | 10 AM |\nAnd Simona's confirmed attendance\nWhen Mike cancels the event\nThen Simona should receive a cancellation notification\nScenario: Employees can review events in the security log\nGiven Simona's previous logins were from the USA\nAnd her latest login was from the UK\nAnd somebody attempted to change her password\nWhen she reviews her activity log\nThen she should see the following events:\n| event\n| from | created at |\n| log in\n| USA\n| yesterday\n|\n| log in\n| USA\n| yesterday\n|\n| log in\n| UK\n| today\n|\n| change password attempt | UK\n| today\n|\nIt turns out that there are two different kinds of events in the specification suite (see\nalso figure 11.1):\nCore domain events—Events that take place in the real world and at which\nemployees have fun\nApplication security events—Digital footprints on the Activitee platform that can\nbe used to review suspicious activity\nDDD calls such concepts false cognates.\nDEFINITION\nFalse cognate—A domain concept that shares its name with\nanother domain concept. False cognates lead people to think they’re talking\nabout the same thing when they aren’t.\nIn linguistics, false cognates are also called polysemes: words that can have multiple\nmeanings depending on the context. Polysemy is distinct from homonymy, which is an\nListing 11.1\nEvent concept in the core events domain\nListing 11.2\nEvent concept in the application security subdomain\n",
      "content_length": 2101,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 263,
      "content": "237\nAnalyzing domain concepts in context\naccidental similarity between two words; whereas homonymy is often a linguistic coin-\ncidence, polysemy isn’t. The difference between polysemy and homonymy is that poly-\nsemy is more contextual. You’ve already seen that difference: context led us to\ndetermine that events in listing 11.1 aren’t the same as events in listing 11.2 and that\nthey belong to different domains. The context was provided by the examples in the\ntables and by the differences in ubiquitous languages used in the scenarios. \n11.1.2 Dealing with false cognates\nFalse cognates aren’t necessarily mistakes. As I said before, different groups of people\nwill use subtly different vocabularies in different parts of a large organization. You\ncan’t force security experts to abandon their vocabulary—in which the concept of\nevent as a logged activity is used often—just because you have another domain that\nuses a similar name for a different concept.\n But false cognates, like polysemes in natural languages, can introduce confusion.\nTrying to eradicate them isn’t a domain-driven way of dealing with false cognates.\nInstead, you can try to explicitly define the relationships between different contexts in\nwhich the domain concepts in question appear. Gherkin and Cucumber let you do\nthat with glossaries.\n In chapter 7, we defined a glossary as a separate file in the specification suite that\ncontains the definitions of all domain concepts required to understand a suite. This\ndefinition was fine for small specification suites of limited complexity. But now you\nknow that in larger suites, some names can have multiple meanings in different con-\ntexts. And I’ve already said that trying to create a single, unified, all-encompassing\nglossary is often too difficult and yields little return on investment.\n But what if you tried to create multiple contextual glossaries, like the ones shown\nin figure 11.2? A contextual glossary defines domain concepts from a shared context\nwhere no polysemes exist. A glossary for the core domain will define event as unequiv-\nocally a domain concept.\nCore domain\nAn outing in the\nreal world\nSecurity\nA logged activity\nEvent\nDomain\nNames\nFigure 11.1\nTwo different domain concepts can sometimes share the same name \nin the ubiquitous language.\n",
      "content_length": 2290,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 264,
      "content": "238\nCHAPTER 11\nManaging large projects with bounded contexts\n \nEVENT is a social outing in the real world.\nCOMPANY-WIDE EVENT is an event targeted at everyone within an entire\n➥organization.\nLOCAL EVENT is an event targeted for some specific location like New York,\n➥Boston, Atlanta.\n(...)\nA glossary for the security context will define event as a domain concept from the secu-\nrity domain. In this context, events are also unequivocal—as long as you don’t mix\none context with the other.\nEVENT is any logged activity.\nSINGLE SIGN-ON (SSO) is a session and user authentication service that permits\n  a user to use one set of login credentials (e.g., name and password) to\n  access multiple applications.\nTWO-FACTOR AUTHENTICATION (2FA) adds a second level of authentication to an\n  account log-in. When you have to enter only your username and one\n  password, that's considered a single-factor authentication. 2FA requires\n  the user to have two out of three types of credentials before being able\n  to access an account.\n(...)\nListing 11.3\nfeatures/abilities/events/glossary.md\nListing 11.4\nfeatures/abilities/security/glossary.md\nAmbiguous term in the context\nof the core events domain\nevents.feature\nEvents\nSecurity\nTeam leads\nevents.feature\nEmployees\nglossary.md\nglossary.md\nAbilities\nFeatures\nFigure 11.2\nA specification suite can have multiple glossaries, each \ndefining domain concepts in different contexts.\nAmbiguous term in the context of the\napplication security subdomain\n",
      "content_length": 1485,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 265,
      "content": "239\nAnalyzing domain concepts in context\nContext rules everything. The more you think about it, the more often you’ll notice\nthat subdomains, actors, and domain concepts always appear in context. The larger\nthe specification suite, the more you must be aware of the contexts that exist within it.\nYou’ll soon see how contexts will let you manage large specification suites, too. Unfor-\ntunately, you aren’t ready to do that just yet, because specifying false cognates isn’t the\nonly issue you’ll face when dealing with context in specification suites. \n11.1.3 Spotting duplicate concepts\nThe ubiquitous languages of different contexts sometimes interact. That’s why a sin-\ngle domain concept can appear in multiple contexts. It’s an inversion of what we\ntalked about in the previous section, where two domain concepts appeared to be the\nsame but weren’t.\n For example, the Activitee platform uses the concept of interest in multiple contexts\n(see figure 11.3). In the employee context, interests mean hobbies and activities that\nusers are interested in. In the core domain context, interests are used to target events\nat particular employees. In the organization context, each interest has its own interest\ngroup, which is a simple message board for like-minded people.\nIf interests from the three contexts I just mentioned were false cognates, they would\nall be different concepts—and different domain concepts deserve their own defini-\ntions. But in this situation, the domain concept is the same for all, so we only have to\nwrite a single definition for it and duplicate it in every context. Compare the glossaries\nin listings 11.5. and 11.6.\nEVENT is a social outing in the real world.\nCOMPANY-WIDE EVENT is an event targeted at everyone within an entire\n➥organization.\nLOCAL EVENT is an event targeted for some specific location like New York,\n➥Boston, Atlanta.\nINTEREST is a hobby or activity that our employees may want to participate in.\n(...)\nListing 11.5\nfeatures/abilities/events/glossary.md\nInterest\nInterest\nOrganization context\nCore domain context\nThe same concept\nin two different\ncontexts\nFigure 11.3\nDialects and contexts can share the same domain concepts \nunder the same names. Each context usually requires a slightly different \nimplementation, but the underlying concepts remain the same. Each \ncontext uses different aspects of the concept.\nInterests in the core\ndomain context\n",
      "content_length": 2400,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 266,
      "content": "240\nCHAPTER 11\nManaging large projects with bounded contexts\nINTEREST is a hobby or activity that our employees may want to participate in.\nINTEREST GROUP is a group of like-minded people who share the same interest\n➥and can use an Activitee message board to discuss it.\n(...)\nDDD calls such concepts duplicate concepts.\nDEFINITION\nDuplicate concept—One of at least two models of the same domain\nconcept. Each model represents and implements the same domain concept\nin a different context.\nIn chapter 10, I said that a model is an interpretation of reality that abstracts only the\naspects relevant to solving the problem at hand. Because different contexts deal with\ndifferent problems, they can abstract different aspects of the same domain concept\n(see figure 11.4).\nEach context will imply slightly different functions when implemented as code, even\nthough the underlying concept is the same. For example, an Interest model in the\norganization context will implement a create_interest_group() function, which will\ncontain code used to create interest groups. An Interest model in the employee con-\ntext will implement an add_as_hobby() function, which will assign interests to\nemployees who choose them.\nListing 11.6\nfeatures/abilities/organization/glossary.md\nInterests in the \norganization context\nCore domain\nAn outing in the\nreal world\nDomain\nNames\nInterest\nOrganizationInterest\n•create_interest_group()\nEmployeeInterest\n•add_as_hobby()\nModels\nFigure 11.4\nThe same domain concept can have two different models in two \ndifferent contexts, each model having its own implementation with unique functions.\n",
      "content_length": 1609,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 267,
      "content": "241\nModeling specification suites as bounded contexts\n Tracking duplicate concepts is just as important as tracking false cognates, because\nerrors introduced into a duplicate in one context can influence another context—for\nexample, through a shared database. Having multiple possible implementations can\nalso introduce new political issues over ownership of a concept. If two teams work in\ntwo different contexts that share a single domain concept, how do these teams man-\nage the differences between their visions of the concept? This is a common situation.\nI’ll try to answer this question in the next section. \n11.2\nModeling specification suites as bounded contexts\nDuplicate concepts are common and to be expected. Large projects are often decen-\ntralized, and decentralization invites duplication. In the long run, it’s not efficient to\ntry to avoid this. False cognates are less common and more harmful: they can lead to\ndelivery teams prying into each other’s code, inconsistent databases, and confusion in\ncommunication. Uninvited as they are, multiple false cognates often happen in a typi-\ncal large software development project.\n DDD doesn’t deal with duplicate concepts and false cognates by creating an all-\nencompassing domain model where inconsistencies don’t appear. Rather, it recog-\nnizes the splinters and either removes (when they’re design mistakes) or contains the\ninconsistencies within multiple smaller models that interact with each other. The\ninteraction process is key. It’s like translation. Every model must figure out a way to\nresolve the splinters in order to exchange information (send or retrieve data)\nrequired to complete the interaction. Such models are called bounded contexts. I used\nthe word context a lot in previous sections—and that was a conscious decision. In this\nsection, I’ll explain what bounded contexts are and how they can help you manage\nlarge specification suites.\n11.2.1 Understanding bounded contexts\nA bounded context is a fragment of the domain that has a unified model. A model is\nmeaningless unless it’s logically consistent, so each bounded context must have a uni-\nfied model that’s internally valid.\nDEFINITION\nBounded context—A fragment of the domain that has a unified\nmodel\nThe internal consistency of a model—meaning that each term is unambiguous and\nthere are no contradicting rules—is called unification. You know that a model is uni-\nfied when the following are true:\nIt has an unambiguous glossary.\nIt’s validated by specification suite tests.\nIt’s continuously integrated.\nEven though the context is internally consistent, it may not be consistent with other\nbounded contexts. Within the context, you should work to keep the model logically\n",
      "content_length": 2716,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 268,
      "content": "242\nCHAPTER 11\nManaging large projects with bounded contexts\nunified, but don’t worry about applicability outside those bounds. The translation pro-\ncess will handle that job later. We’ll talk more about how to resolve inconsistencies\nbetween contexts in section 11.2.4.\n How do you define contextual bounds? You can use a rule of thumb and identify\ncontexts by their glossaries. Whenever a fragment of the domain has an unambiguous\nglossary, it can be represented as a bounded context. An unambiguous glossary is a\nsign of unification. Other than that, contexts can be flexible.\n Remember that a bounded context is always a model. Models are abstract interpre-\ntations of reality made to solve problems at hand. As long as your interpretation\nmakes sense and you can keep the ubiquitous language consistent, you may choose\nfrom many potential splits between contexts. Any split can be more or less optimal,\ndepending on the problem at hand. You can assume that the more you get to know\nabout the domain and your stakeholders, the more optimal the contexts you create\nwill become. \n11.2.2 Splitting a large specification suite \ninto multiple bounded contexts\nDefining bounded contexts catalyzes the split of a single large specification suite into\nseveral smaller specification suites. Each context is a fragment of the domain. Each\nfragment becomes a potential split line. In this section, we’ll define a few contexts for\nActivitee, based on the contextual glossaries discussed earlier. We’ll then do a few\nsplits based on those contexts. We should end up with a clearly organized project with\na lot of room to grow for new abilities and business needs.\n At the end of the previous chapter, five subdomains were in play (see figure 11.5):\nAnalytics\nBonuses\nEvents\nOrganization\nApplication security\nIn figure 11.2, we use bounded contexts that include only a single subdomain.\nThere’s a separate context for the events subdomain, which has its own glossary—and\nthere’s a second context for the application security subdomain with another glos-\nsary. That can happen, but it doesn’t have to be the case every time. A bounded con-\ntext can easily deal with multiple subdomains, as long as they can share a single\nglossary (see figure 11.6). For example, we can define a bounded context for the\ncore Activitee experience, which deals with subdomains such as events, bonuses, and\norganization. The ubiquitous languages in these subdomains are generally consistent\nand fit together easily.\n \n \n",
      "content_length": 2494,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 269,
      "content": "243\nModeling specification suites as bounded contexts\n \n \nHR\nkpi.feature\nTeam leads\ntracking performance.feature\nEmployees\nredeeming bonuses.feature\nHR\nrewards program.feature\nTeam leads\ngranting bonuses.feature\nevents.feature\nEmployees\nsearch.feature\nevents.feature\nHR\nscheduling.feature\ntargeting.feature\nTeam leads\noutings.feature\ninterest groups.feature\nEmployees\nnews feed.feature\nperformance.feature\nprofile.feature\ninviting employees.feature\nmanaging employees.feature\nonboarding employees.feature\norganization structure.feature\nCISO\nsso.feature\nEmployees\nauthentication.feature\npasswords.feature\nHR\nHR\npermissions.feature\nAbilities\nFeatures\nBusiness\nneeds\nSecurity\nOrganization\nEvents\nBonuses\nAnalytics\nFigure 11.5\nAn Activitee specification \nsuite organized by domains\n",
      "content_length": 778,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 270,
      "content": "244\nCHAPTER 11\nManaging large projects with bounded contexts\nFigure 11.6 shows a specification suite with three subdomains and a single unified glos-\nsary. From the modeling perspective, the unification aspect is the most important.\nFrom the technical perspective, having a separate specification suite for several subdo-\nmains often means you’ve decided to split a so-far-unified product into multiple appli-\ncations called services, each of which is responsible for certain aspects of the business\ndomain. That’s because Cucumber can read only one features directory per project. (If\nyou wanted to keep your bounded contexts in a single application, you’d need to create\na separate folder for each context in the features directory—a less elegant solution.)\n After extracting three subdomains from figure 11.6, we still have two other subdo-\nmains to deal with: analytics and application security. I talked a bit about the security\nsubdomain when we analyzed false cognates. You may remember from chapters 9 and\n10 that this subdomain cares mainly about identity issues, such as authentication,\nauthorization, and SSO. That’s why we can extract it into a separate bounded context\ncalled the identity context (see figure 11.7).\nWe can do the same with the analytics subdomain (see figure 11.8). Although key per-\nformance indicators (KPIs) are an important part of Activitee, they’ve always been sep-\narated from the rest of the platform. There are a couple of reasons to keep this\nsubdomain in a separate bounded context. First, the analytics product doesn’t intro-\nduce any new functionalities on its own; it feeds on data from other features. This data\nfeed product has to interact with other ubiquitous languages on a daily basis. A sepa-\nrate glossary would be a great tool to define the interactions between different dialects\nand resolve possible conflicts. For example, the analytics product could be able to ana-\nlyze the frequency of both HR events and security events, with a glossary specifying\nwhich is which. You can also look at similar products from other companies. For\ninstance, at the time of writing, Twitter Analytics is a separate application, complete\nwith its own design and a URL different than the core Twitter experience.\n[...]\nAbilities\nBonuses\nglossary.md\n[...]\nEvents\n[...]\nOrganization\nFeatures\nFigure 11.6\nA bounded context \nfor the core Activitee experience, \nwith a single unified glossary for \nthree subdomains\nAbilities\nglossary.md\n[...]\nSecurity\nFeatures\nFigure 11.7\nActivitee’s identity \ncontext and its glossary only specify \nscenarios that deal with the application \nsecurity subdomain—for example, \nauthentication and authorization.\n",
      "content_length": 2675,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 271,
      "content": "245\nModeling specification suites as bounded contexts\nThe real relationships between bounded contexts and subdomains is usually more\ncomplex than in these simple examples. For instance, we’ve assumed that the contexts\ncontain entire subdomains, which can happen—but the opposite is just as likely. A\nsubdomain can be split into parts, each part implemented in a different bounded con-\ntext; there’s nothing wrong with that. \n11.2.3 Managing bounded contexts with context maps\nCreating bounded contexts is a good first step toward manipulating and comprehend-\ning large domains easily. It reduces the problem of managing large specification suites\ninto managing multiple medium-sized specification suites. But how can you work with,\norganize, and comprehend multiple bounded contexts? The solution is to create a\ncontext map: a map that describes the points of contact between different bounded\ncontexts. I’ll show you an example in a moment.\nDEFINITION\nContext map—A map that describes the points of contact between\ndifferent bounded contexts (different specification suites), outlining explicit\ntranslations for any communication and highlighting any sharing\nI’ve talked about maps already:\nIn section 8.2.3, when discussing the concept of a specification suite as a map of\nrequirements\nIn section 10.2.2, when likening the domain model to a map of the domain that\nhelps you make good decisions on your journey to deliver software that will be\nvaluable in that domain\nA context map is an entirely new kind of map. If a specification suite is a map of\nrequirements organized according to DDD principles, then a context map is a map of\nspecification suites and the relationships between suites.\n Why are context maps important? Splitting the domain model into multiple con-\ntexts won’t automatically make the domain model smaller, easier to comprehend, or\nless complex. It will decentralize complexity.\n Decentralization is a huge topic in DDD. For example, each time you find out that\ntwo decentralized contexts aren’t synchronized (for example, if you find a false cog-\nnate and haven’t decided what to do with it), you can make one of two decisions:\nPull the model back together, and refine it to prevent fragmentation.\nAccept the fragmentation as a result of diverse groups who want to push the\nmodel in different directions for good reasons, and let them develop their con-\ntexts independently.\nAbilities\nglossary.md\n[...]\nAnalytics\nFeatures\nFigure 11.8\nActivitee’s analytics \ncontext focuses only on analytical \nabilities, with a glossary that can unify the \nubiquitous language in the specification \nsuite presented in the diagram.\n",
      "content_length": 2642,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 272,
      "content": "246\nCHAPTER 11\nManaging large projects with bounded contexts\nIf you make the second decision, you’ll need a way to track fragmentation and see\nwhere different bounded contexts converge and diverge. A good first step is creating\nand maintaining separate glossaries for each bounded context—something you’ve\nalready done. A good second step is to mark relationships such as false cognates and\nduplicate concepts in different contexts. Here’s where context maps come in handy. \n11.2.4 Drawing context maps\nFigure 11.9 shows what a context map looks like in theory. It shows two models, each\nin its own bounded context. Each model is a visual representation of the domain con-\ncepts present in each context as well as the relationships between the concepts. (In\npractice, such diagrams are most often drawn in UML, a popular modeling language\nthat provides a standard way to visualize the design of a system.) You can also see the\ntranslation map, which is a space where you can define the points of contact between\ndifferent bounded contexts. Each point of contact can specify interactions such as\nfalse cognates, duplicate concepts, and any other relation that you deem important.\nFigure 11.10 shows a more practical example based on the Activitee platform and the\nfalse cognates and duplicate concepts we dealt with in section 11.1. Software develop-\nment teams often draw maps like this one to outline explicit translations for any com-\nmunication and highlight any sharing between contexts. The map defines the\nterritory of each context and the borders between contexts. Without a context map,\npeople on other teams may not be aware of contextual bounds and may unknowingly\nmake changes that blur the edges or complicate the interconnections.\n A context map is different than the map I talked about when comparing a specifi-\ncation suite to a map. Due to automation and its link to real working code, a specifica-\ntion suite can only be a model of the bounded contexts in a single codebase. So if you\nhave to split your bounded contexts into separate codebases due to the complexity of\nTranslation\nmap\nModel in context\nModel in context\nFigure 11.9\nA simple context map that lists translations such as false \ncognates and duplicate concepts between two theoretical models in their \nbounded contexts\n",
      "content_length": 2299,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 273,
      "content": "247\nModeling specification suites as bounded contexts\nthe system or your system architecture, each specification suite will be able to map\nonly what it can automate; therefore, it will always be limited to the reach of its testing\ncode. A simple, practical example is that two different subsystems can be written in\ntwo different programming languages, which makes unified testing more difficult.\nYou have to resort to non-automated methods, such as context maps. It really is just a\nsimple drawing. Still, each specification suite with a glossary will help you create better\ncontext maps because it’s an automated, frequently validated, always up-to-date map\nof each bounded context. But the context map itself must be maintained manually.\n In DDD, contexts map are an important element of strategic design. Strategic design\nis not only a way to map a business domain, as in the example, but also a way to show\nwhich parts of the system matter most to the business and where to focus design\nefforts in order to be effective. Eric Evans defined several design patterns.1 The con-\nformist pattern is a good example. A conformist context adheres to other models in\norder to simplify integration by adopting to a provided language and data without\nquestioning it. Therefore, conformity eliminates the complexity of translation.\n Another example is the anticorruption layer pattern, which creates an isolating\nlayer to provide clients with functionality in terms of their own domain model. Thanks\nto DDD’s strategic patterns, you can not only define the points of contact shared by the\nubiquitous languages of different bounded contexts, but also define how, in the long\nterm, each team should manage their context’s interactions with other contexts and,\ntherefore, other teams.\n Unfortunately, it’s beyond the scope of this book to discuss techniques from the field\nof DDD. If you’re interested in the topic, you can read Evans’ book, which is a great\nintroduction to the topic and will give you a fuller overview of what DDD is all about. \n1 Eric Evans, Domain-Driven Design, chapters 14–17 (Addison-Wesley, 2003).\nEvent\nThe security context\nEvent\nFalse cognates\nInterest\nThe analytics context\nInterest\nCore context\nDuplicate concepts\nFigure 11.10\nA simple \ncontext map that lists \npreviously defined false \ncognates and duplicate \nconcepts between Activitee’s \nbounded contexts\n",
      "content_length": 2377,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 274,
      "content": "248\nCHAPTER 11\nManaging large projects with bounded contexts\n11.3\nFitting DDD into an SBE process\nPaired with SBE and Gherkin, DDD can be a powerful tool. To solidify your under-\nstanding before we end the chapter, let’s review the general process, this time from\nstart to finish. This section features some new material that will let you see the pro-\ncesses of modeling and specifying from the perspective of different team members;\nprogrammers, designers, analysts, and testers will be able to understand how the\ndomain-modeling process will affect their jobs.\n Everything starts with the ubiquitous language, created thanks to the cooperation\nof both domain experts and technical experts. When they converse about the require-\nments and their organization’s business domain, they naturally flesh out domain con-\ncepts and mix their jargons to create the ubiquitous language—the language of the\ndomain in a given technological context, also called a bounded context.\n That’s when Gherkin steps in. Gherkin allows for the recording and long-term\nstorage of short-term conversations. When the experts write down their conversations\nin Gherkin, they can refine their domain models more easily. As section 10.2.2\nexplained, you can analyze Gherkin scenarios to distill different domains from each\nconversation and decide which is the core domain and which are secondary or\ngeneric domains (and thus less important). And section 10.2.3 showed that analyzing\nfalse cognates and duplicate concepts between different scenarios can lead to creating\ndifferent bounded contexts, which fragment the domain into several smaller context-\ndependent models.\n Thanks to Gherkin’s connection to the realm of automated testing, each bounded\ncontext binds the testing code of its specification suite and the real code meant to\nimplement the actual requirements. Thanks to automated tests, which frequently ver-\nify the suite’s consistency, as well as Gherkin’s focus on the ubiquitous language, you\ncan be sure that each specification suite based on a bounded context presents a uni-\nfied, consistent model of the subdomain the current code is dealing with.\n The requirements are organized according to their corresponding subdomains.\nYou can quickly inspect the subdomains used in each context by analyzing the struc-\nture of directories within the specification suite, as well as create and maintain a uni-\nfied glossary of domain concepts for each bounded context. The structure of your\nspecification suites becomes a visual and hierarchical domain model—a map of the\nfragments of your business domain that you’ve already specified—in which require-\nments and glossaries are connected to their corresponding domains.\n Thanks to bounded contexts, the problem of managing large specification suites is\nreduced to a problem of managing multiple medium-sized specification suites—a\ntopic we discussed in chapters 8–10 and that you should be ready to deal with. The only\nremaining issue is figuring out how to deal with interactions among multiple suites.\nThe relationships among different specification suites can be clarified by using context\nmaps. By describing the points of contact between different bounded contexts, context\nmaps can give you a fuller overview of your business domain and provide a translation\n",
      "content_length": 3297,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 275,
      "content": "249\nSummary\nframework between the bounded contexts. The translation framework can help you\ndeal with false cognates and duplicate concepts more easily.\n Refining the domain model as well as defining and analyzing bounded contexts\ncan yield multiple positive outcomes to each delivery team. DDD emphasizes that dif-\nferent parts of your system matter differently to your business and provides a method-\nology to focus your team’s design efforts most effectively. Designers and analysts can\nbenefit from DDD by understanding where business value comes from, thanks to see-\ning which domains and contexts grow the fastest.\n Better domain models yield better code designs, without unnecessary coupling of\nconcepts that should stay separate; this makes code more stable for developers and\nautomated testing easier for testers. For free, developers also get a methodology for\nnaming their domain objects in code according to the ubiquitous language—which\nreduces the cost of mental translations.\n On a personal note, I wish I’d known all this years ago when my team and I were\nworking on a particular enterprise project. It would have saved us considerable time\nand stress. The complexity was eating us up on a daily basis. We were on the right\ntrack to curb it, but the project lacked the finishing touches. We knew how to use\nGherkin and Cucumber, but we had no idea how to organize large specification suites.\nWe understood the concept of a ubiquitous language, but we didn’t yet grasp all of its\nimplications for software design. The only element almost completely missing was\nDDD. (We learned about the ubiquitous language through Gherkin.) As I reminisce, I\nsee how we could have used glossaries, bounded contexts, context maps, and DDD\ndesign patterns to improve our processes. I can only hope that this chapter—a culmi-\nnation of the previous lessons—will aid you in writing great specifications so that you\ncan harness the true power of executable Gherkin much more quickly and easily than\nI did. \n11.4\nSummary\nA false cognate is a domain concept that shares its name with another domain\nconcept.\nFalse cognates lead people to think they’re talking about the same thing when\nthey aren’t.\nDuplication of concepts leads to two different implementations of the same\ndomain concept in two different contexts.\nFalse cognates and duplicate concepts are examples of why it’s difficult to cre-\nate a unified, all-encompassing domain model—repetitions, inconsistencies,\nand equivocation creep in.\nEven though domain models lie at the center of domain-driven design, DDD’s\ngoal isn’t to build a single model of an organization’s entire business domain.\nInstead, DDD practitioners use bounded contexts.\n",
      "content_length": 2700,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 276,
      "content": "250\nCHAPTER 11\nManaging large projects with bounded contexts\nA bounded context is only a fragment of the domain with a unified model. A\nfragment can be small and consistent enough to avoid equivocation within its\nmodel.\nA specification suite of a bounded context specifies the ubiquitous language of\nits model.\nThanks to bounded contexts, the problem of managing large specification\nsuites is reduced to a problem of managing multiple medium-sized specifica-\ntion suites.\nEach bounded context needs to figure out how to communicate with other\nbounded contexts, just as different departments learn to share information\nwithin a company.\nBounded contexts share information through context maps. A context map\ndescribes the points of contact between different bounded contexts, outlining\nexplicit translations for any communication and highlighting any sharing.\n",
      "content_length": 864,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 277,
      "content": "251\nappendix\nExecuting specifications\nwith Cucumber\nThis appendix is a quick tutorial on how to write and run simple automated tests\nfor feature files with Cucumber and Gherkin. I do realize that some readers will\nexpect an explanation of the executable part of executable specifications. Execution\nis Cucumber’s role. To execute a specification, you write tests based on a prepared\nscenario, which you later evolve into a scenario outline—and then you automate\nthat, too. I’m assuming you’ve read at least chapters 2 and 5, which talk about sce-\nnarios and scenario outlines. You can, however, proceed up to section A.8 without\nhaving read chapter 5, and then come back later.\n This tutorial will teach you the basic workings of the automation layer based on\nan example of a simple banking application that lets clients deposit and withdraw\nmoney. I’ll try to keep the example simple and explain everything along the way, for\nreaders who are nontechnical but want to learn more about the automation layer.\n You can use the command-line interpreter of your choice. I’ll assume you under-\nstand basic regular expressions and Ruby, which I’m using to write the code, as well\nas how to configure and use RubyGems to install Cucumber. I realize that not every-\nbody needs to know Ruby, so I’m writing the simplest implementation code possible\nand testing it with the simplest testing code I can think of. This choice means the\nresults won’t be perfect according to Ruby’s coding standards, but you should be\nable to understand my code regardless of your language of choice.\nA.1\nIntroducing test-driven development\nThis appendix is more of a high-level overview of fundamental testing techniques\nrather than a complete explanation. It focuses on the two most important topics:\nUnderstanding test-driven development (TDD)\nWriting unit tests\n",
      "content_length": 1837,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 278,
      "content": "252\nCHAPTER \nExecuting specifications with Cucumber\nTDD is one of the best-known practices inside and outside agile software development\ncommunities.\nDEFINITION\nTest-driven development—A software development methodology\nthat requires developers to write failing tests first and then gradually create\nthe implementation code to make the tests pass\nThis appendix relies on TDD heavily, so it’s important that you understand what that\nmeans. Kent Beck, who popularized TDD, explained it as a practice that requires you\nto “test a little, code a little.”1 Each time you have a new feature to implement, Beck\nsaid, you should do the following:\n1\nAdd a failing test first.\n2\nRun all of your tests, and confirm that the new test fails.\n3\nWrite the minimum implementation code that causes the new test to pass.\n4\nRun the tests again to see them pass, thanks to the new code.\n5\nThe minimum implementation code will usually be ugly even though it passes\nthe test. Refactor and polish the code. Use the test repeatedly to check whether\nthe code works as intended even with changes.\n6\nRepeat the entire process every time you want to add a new functionality.\nThis process is sometimes simplified into a three-step loop: red-green-refactor. Most test\nrunners mark failing tests in red and passing tests in green. You start with a red test\nand gradually work to make it a green one. As soon as you get a green test, you refac-\ntor the code to polish it, and then you use the tests to be sure you didn’t break any-\nthing while making your implementation more beautiful.\n If you feel that writing failing tests before writing actual implementation code is\nweird, don’t worry—I remember feeling that way. It becomes more natural as you get\nthe hang of it. The benefit of TDD is that when you focus on writing only the code nec-\nessary to pass tests, your designs will often be cleaner and clearer than you can achieve\nwith other methods. \nA.2\nIntroducing unit tests\nThe tests you’ll write in this appendix are called unit tests.\nDEFINITION\nUnit test—A low-level test that focuses on a small part of the soft-\nware system called a unit of work\nPeople often consider different things to be single units of work. In object-oriented\ndesign, a unit can be an entire interface, such as a class; but in functional design, it\nmay be a single function. In the context of this appendix, it doesn’t matter. I chose to\nuse unit tests because they’re short, simple, and quick, and they don’t require you to\n1 Kent Beck and Erich Gamma, “Test Infected: Programmers Love Writing Tests,” Java Report, 3(7), July 1998,\nhttp://junit.sourceforge.net/doc/testinfected/testing.htm.\n",
      "content_length": 2644,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 279,
      "content": "253\nConfiguring the environment\ncreate an advanced implementation such as a database connection or a user interface.\nYou can copy the code as is and make it run effortlessly on your machine.\n Unit tests aren’t the only type of tests. Most teams use Cucumber and Gherkin to run\nend-to-end tests with a runner like Selenium for web browser automation. Selenium-\ndriven specifications simulate a user working with a real instance of the system. When\nI say real, I mean as real as possible. You can even configure Selenium to run Firefox or\nChrome on your machine in order to watch Cucumber click over the simulated user\ninterface as it tests the system. Personally, I like to use an approach based on domain-\ndriven design (discussed in chapter 10) and write Cucumber tests that validate the\ndomain layer without end-to-end testing, which tends to be slow and performance\nheavy. Unfortunately, a discussion of choosing domain logic tests over end-to-end tests\nis too complex for me to do it justice in an appendix. I wanted to mention it, though,\nin order to show you some possible future learning paths.\n If you want to learn more about the automation aspects of Cucumber and Gher-\nkin, read The Cucumber Book by Matt Wynne and Aslak Hellesøy (Pragmatic Program-\nmers, 2012). If you’re a Java person, you may want to look at BDD in Action by John\nFerguson Smart (Manning, 2014), which features many code examples written in Java.\nYou should have zero problems finding books that talk about any of the topics I’ve just\nmentioned, including TDD, unit tests, and end-to-end testing; they’re all established\nsoftware development practices. \nA.3\nConfiguring the environment\nTo execute any tests, you first need to make sure you have a test runner on board and\nthat your programming environment is configured to make the tests pass. A test run-\nner—in this case, Cucumber—is a type of software written to automatically test other\nsoftware. In this section, you’ll install Cucumber and do the basic configuration\nrequired to execute any specifications.\n You can install Cucumber by running the gem install cucumber command on\nyour terminal:\n$ gem install cucumber\nFetching: cucumber-2.4.0.gem (100%)\nSuccessfully installed cucumber-2.4.0\nParsing documentation for cucumber-2.4.0\nInstalling ri documentation for cucumber-2.4.0\nDone installing documentation for cucumber after 3 seconds\n1 gem installed\nNOTE\nThe gem install cucumber command’s output may be much longer in\na clean Ruby environment, because all kinds of dependencies will have to be\ninstalled. I simplified the output for the sake of space.\nAlso, create a directory where you’ll store your tests and scenarios:\n$ mkdir bank\n$ cd bank\n",
      "content_length": 2688,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 280,
      "content": "254\nCHAPTER \nExecuting specifications with Cucumber\nOnce you’re in the new directory, you can run Cucumber to see what happens:\n$ cucumber\nNo such file or directory - features. You can use `cucumber --init` to get\n➥started.\nTIP\nYou can only use the cucumber command in a directory that contains a\ndirectory called features.\nYou haven’t done any configuration yet, so Cucumber asks you to prepare the environ-\nment for future testing. Executing cucumber --init will create the file structure\nrequired to put your scenarios in the specification suite and write the tests:\n$ cucumber --init\ncreate\nfeatures\ncreate\nfeatures/step_definitions\ncreate\nfeatures/support\ncreate\nfeatures/support/env.rb\nThe file structure is simple enough:\nYou put your .feature files in the features directory.\nStep definitions (the testing code) go in features/step_definitions.\nThe files in the features/support directory can be used to configure the specifi-\ncation suite. Don’t worry about it for now; the default configuration will be all\nyou need.\nThanks to the cucumber --init command, you have a good baseline. You’ve installed\nCucumber and gotten it to work, and you know where to store scenarios and tests.\nNow you need to take care of those, if you want to execute any specifications. \nA.4\nPreparing scenarios for automation\nTDD is a test-first approach, so you first need to write a test. Listing A.1 presents a very\nsimple scenario for depositing money in a bank account. The scenario includes two\nGivens, in which you meet a user—Simona Jenkins—with an empty bank account; a\nWhen where she deposits the money; and a Then that checks whether her account bal-\nance was updated. In this section, you’ll automate each of the Given-When-Thens.\nFeature: Bank account\nScenario: Adding money to your account\nGiven a bank account in Simona's name\nAnd that her current account balance is $0\nWhen she deposits $500\nThen the account balance should be $500\nTIP\nYou can choose any names for your feature files. Cucumber will read\neverything from the features directory.\nListing A.1\nScenario for depositing money\n",
      "content_length": 2088,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 281,
      "content": "255\nPreparing scenarios for automation\nPut the scenario in a feature file called account.feature in the features directory, and\nexecute the cucumber command again. Even though this code looks like a big jump in\ncomplexity, the command just reprints the scenario, returns tests results, and gener-\nates missing code snippets:\n$ cucumber\nFeature: Bank account\nScenario: Adding money to your account\n# features/account.feature:3\nGiven a bank account in Simona's name\n# features/account.feature:5\nAnd that her current account balance is $0 # features/account.feature:6\nWhen she deposits $500\n# features/account.feature:7\nThen the account balance should be $500\n# features/account.feature:8\n1 scenario (1 undefined)\n4 steps (4 undefined)\n0m0.003s\nYou can implement step definitions for undefined steps with these snippets:\nGiven(/^a bank account in Simona's name$/) do\npending # Write code here that turns the phrase above into concrete actions\nend\nGiven(/^that her current account balance is \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nWhen(/^she deposits \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nThen(/^the account balance should be \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nThe test results are classified as undefined because you haven’t written any testing\ncode. That’s why Cucumber generates a code snippet for every Given, When, and Then.\nThe step definitions are marked as pending; Cucumber will ignore them unless you\nput some code in them. At this moment, the step definitions are more placeholders\nfor future tests than real tests. You’ll change that soon. As you write more code, the\npending steps will be classified as either passed or failed.\n Notice that steps and step definitions are matched through regular expressions.\nCucumber lets you use regular expressions to extract attributes from the steps, and to\nmake automation easier and reduce redundancy. For example, if you changed the she\ndeposits $500 step to she deposits $1000, Cucumber wouldn’t need a second step\ndefinition, because it treats \\$(\\d+) as a placeholder that can catch all numbers in\nany step that matches the rest of the regular expression—the she deposits part.\nTIP\nBe careful! Sometimes regular expressions in Cucumber can cause head-\naches. Cucumber reuses steps based on the expressions you write. If you write\na regex that’s too loose, you may end up with a step definition that’s matched\nwith a different step than you had in mind.\nWith a specification in place, you can proceed to writing your first testing code. \nPrinted-out scenario\nTest results\nCode snippets\n",
      "content_length": 2729,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 282,
      "content": "256\nCHAPTER \nExecuting specifications with Cucumber\nA.5\nWriting tests in a test-driven manner\nHere’s where the challenge gets interesting. To make the development process really\ntest-driven, you should write the tests before the implementation. Let’s begin by copy-\ning the snippets generated by Cucumber and putting them in a file called account.rb\nin the features/step_definitions directory.\nGiven(/^a bank account in Simona's name$/) do\npending # Write code here that turns the phrase above into concrete actions\nend\nGiven(/^that her current account balance is \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nWhen(/^she deposits \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nThen(/^the account balance should be \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nA.5.1\nDefining prerequisites with Givens\nIn the case of the first Given in listing A.2, you’ll have to create a bank account in the\nname of a client named Simona. The code should create Simona’s client account with\na hypothetical Client object and then create a bank account—for example, with an\nAccount object—and assign it to Simona (see the following listing). Keep in mind that\nyou haven’t created any real objects yet. Instead, you’re planning which objects and\nmethods you’ll need during implementation.\nGiven(/^a bank account in Simona's name$/) do\n@simona = Client.new(name: \"Simona\")\n@simona.account = Account.new\nend\nYou’ll probably reuse Simona’s Client account in many other scenarios—even those\nthat don’t deal with deposits and don’t interact with the Account object. It would be a\ngood idea to extract creating the Client profile into a separate step, to simplify reus-\ning that step in other scenarios. Cucumber lets you do that with its step method.\nGiven(/^a client called Simona$/) do\n@simona = Client.new(name: \"Simona\")\nend\nGiven(/^a bank account in Simona's name$/) do\nListing A.2\nfeatures/step_definitions/account.rb\nListing A.3\nTesting code for the first Given step\nListing A.4\nInvoking steps from other step definitions\n",
      "content_length": 2169,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 283,
      "content": "257\nWriting tests in a test-driven manner\nstep \"a client called Simona\"\n@simona.account = Account.new\nend\nThe step method takes a String with the name of another step, runs it through\nCucumber’s regex engine, and executes the called step inside another step. You’re\nprobably being too careful, using the step function so soon in this case, because\nthere’s no explicit need for reusability; but the method is so useful that you couldn’t\nleave it aside.\n Having taken care of the first Given, let’s proceed to the second one. This step\nshould make sure the initial balance in Simona’s account is the same in every test run\nso you won’t end up with a different amount of money than defined in the scenario.\nGiven(/^that her current account balance is \\$(\\d+)$/) do |arg1|\n@simona.account.balance = arg1.to_i\nend\nThis step definition uses a regular expression to extract the current account balance\nfrom the scenario. That’s why you can use the arg1 argument in the testing code to\ndefine Simona’s account balance. Using a regular expression means that whatever\nnumber you write in the scenario will be extracted by Cucumber for use as the value\nof the arg1 argument.\nNOTE\nYou have to recast arg1 as an Integer because Cucumber treats every\nargument extracted from regular expressions as a String.\nEven though you don’t yet have any real code for the Account object, you know that it\nshould have a method for setting the initial account balance. If it didn’t, you wouldn’t\nbe able to execute your tests. In Ruby, this means instances of the Account object must\nimplement a method like balance= with a numeric argument. That’s how tests written\nin the TDD manner can influence the implementation code’s design.\nTIP\nIf you want to, you can rename arg1 to something more human friendly,\nlike current_balance. \nA.5.2\nTaking actions with Whens\nTwo steps down, two steps to go. The When should allow the client to deposit the\namount of money specified in the scenario, which is the primary action of the scenario.\nWhen(/^she deposits \\$(\\d+)$/) do |arg1|\n@simona.account.deposit(arg1.to_i)\nend\nListing A.5\nGiven step for setting the account balance\nListing A.6\nDefining the scenario’s primary action in a When\nReusing a Given thanks to \nCucumber’s step method\n",
      "content_length": 2250,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 284,
      "content": "258\nCHAPTER \nExecuting specifications with Cucumber\nAgain, you use an argument from the step definition; and again, you recast arg1 as an\nInteger. You also know that every instance of the Account object will have to imple-\nment a deposit method, which will increase the account balance set by the balance=\nmethod you used in the previous step definition. In this scenario, you know that the\ndeposit method should increase the balance by $500. \nA.5.3\nTesting consequences with Thens\nThis is the last step. It’s a Then, so you programmatically define the consequences you\nexpect from this scenario and test whether the actions you took in the previous steps\nhad the desired effect.\nThen(/^the account balance should be \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nProgrammers and testers test consequences with assertions.\nDEFINITION\nAssertion—A statement that’s expected to always be true when\nexecuted. If an assertion evaluates to false at runtime, an assertion failure\nresults, which typically causes the program to crash or to throw an assertion\nexception.\nI’m using RSpec to write my test assertions. RSpec is a behavior-driven development\n(BDD) testing framework for Ruby. You can easily combine RSpec with Cucumber,\nthanks to the rspec-expectations library; Cucumber will automatically load RSpec’s\nmatchers and expectation methods. The assertions check whether the output\nexpected in the feature file matches the output from the executed tests. If it doesn’t,\nRSpec will raise an error and stop executing the tests.\n To use RSpec’s assertions with Cucumber, you need to install the library using\nRubyGems:\n$ gem install rspec-expectations\nFetching: rspec-support-3.5.0.gem (100%)\nFetching: diff-lcs-1.2.5.gem (100%)\nFetching: rspec-expectations-3.5.0.gem (100%)\nSuccessfully installed rspec-support-3.5.0\nSuccessfully installed diff-lcs-1.2.5\nSuccessfully installed rspec-expectations-3.5.0\n3 gems installed\nAs you can see, rspec expectations loads a few supporting libraries—that’s fine.\nYou’ll need them all to use assertions.\nTIP\nIf you’re using Bundler, you can add gem 'rspec-expectations' to your\nGemfile, instead. Bundler provides a consistent environment for Ruby pro-\njects by tracking and installing the exact gems and versions that are needed.\nListing A.7\nPending Then step\n",
      "content_length": 2348,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 285,
      "content": "259\nWriting implementation code based on tests\nTherefore, you can list the gems your project requires in a Gemfile and install\nthem all at once, instead of going through the list one by one.\nThe last step required to use rspec-expectations in your testing code is to add a\nrequire line at the top of the account.rb file in features/step_definitions, as shown next.\nrequire \"rspec/expectations\"\nGiven(/^a client called Simona$/) do\n@simona = Client.new(name: \"Simona\")\nend\n(...)\nNow you can use RSpec’s expect syntax to create a simple assertion that will check\nwhether Simona’s account balance equals final_balance—the number extracted\nfrom the scenario by Cucumber.\nThen(/^the account balance should be \\$(\\d+)$/) do |final_balance|\nexpect(@simona.account.balance).to eq final_balance.to_i\nend\nIn this case, you know that Simona’s account balance should be $500, because you\nused the deposit method to increase it when you wrote the testing code for the When.\n And that’s all! (For now.) You’ve completed the testing code required to execute\nthe specification. That doesn’t mean, of course, that it will be executed successfully. As\nyou’ll soon see, you still have to write the implementation code. \nA.6\nWriting implementation code based on tests\nDo you remember the red-green-refactor loop I talked about at the beginning of this\nappendix? You should periodically run Cucumber to check whether the code you’ve\nwritten so far is enough to make the tests pass. In this section, you’ll see how failing tests\ncan guide you in writing the implementation code that will later run in production.\nAfter a few iterations, you should end up with working code that makes the tests pass.\n Let’s not get ahead of ourselves, though. First, run Cucumber to see whether any-\nthing has changed since you used it to generate snippets for the step definitions:\n$ cucumber\nFeature: Bank account\nScenario: Adding money to your account\n# features/account.feature:3\nGiven a bank account in Simona's name\n➥# features/step_definitions/tests.rb:3\nuninitialized constant Client (NameError)\n./features/step_definitions/tests.rb:4:in\n➥`/^a bank account in Simona's name$/'\nfeatures/account.feature:5:in `Given a bank account in Simona's name'\nListing A.8\nIncluding the rspec-expectations gem\nListing A.9\nUsing an Rspec assertion to check the final account balance\nNameError exception \nthrown during test execution\n",
      "content_length": 2387,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 286,
      "content": "260\nCHAPTER \nExecuting specifications with Cucumber\nAnd that her current account balance is $0\n➥# features/step_definitions/tests.rb:8\nWhen she deposits $500\n➥# features/step_definitions/tests.rb:12\nThen the account balance should be $500\n➥# features/step_definitions/tests.rb:16\nFailing Scenarios:\ncucumber features/account.feature:3 # Scenario: Adding money to your account\n1 scenario (1 failed)\n4 steps (1 failed, 3 skipped)\n0m0.005s\nOuch! The scenario failed in its first step because Cucumber threw an exception. Let’s\nlook at the step definition to see what’s wrong:\nGiven(/^a client called Simona$/) do\n@simona = Client.new(name: \"Simona\")\nend\nOh, that’s it: there’s a NameError because the step definition tried to use the Client\nobject even though you haven’t defined it. Let’s write some implementation code to\nmake the Client object more real—and make the test pass.\n First, create a directory called features/implementation where you’ll store imple-\nmentation code for Cucumber to see:\nmkdir features/implementation\nTIP\nIn real-world projects, you’ll store your implementation code outside of\nthe features directory. But for now, I want to keep things easy; so, you’re put-\nting the code where Cucumber can see it without your having to reconfigure\nCucumber to see code in other directories.\nYou can now write the following simple implementation of the Client object that\nshould make the step definition from listing A.10 pass.\nclass Client\ndef initialize(name:)\n@name = name\nend\ndef name\n@name\nend\nend\nThe object has two simple methods for setting and reading a client’s name. It’s not\nmuch, but remember that TDD requires you to write only the code necessary to pass\ntests. Because setting the name is where you saw the tests fail, that’s what you should fix.\n To see what you should do next, though, you have to rerun Cucumber:\nListing A.10\nfeatures/implementation/client.rb\n",
      "content_length": 1890,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 287,
      "content": "261\nWriting implementation code based on tests\n$ cucumber\nFeature: Bank account\nScenario: Adding money to your account\n# features/account.feature:3\nGiven a bank account in Simona's name\n➥# features/step_definitions/account.rb:7\nuninitialized constant Account (NameError)\n./features/step_definitions/account.rb:9:in\n➥`/^a bank account in Simona's name$/'\nfeatures/account.feature:5:in `Given a bank account in Simona's name'\nAnd that her current account balance is $0\n➥# features/step_definitions/account.rb:12\nWhen she deposits $500\n➥# features/step_definitions/account.rb:16\nThen the account balance should be $500\n# features/step_definitions/account.rb:20\nFailing Scenarios:\ncucumber features/account.feature:3 # Scenario: Adding money to your account\n1 scenario (1 failed)\n4 steps (1 failed, 3 skipped)\n0m0.008s\nThe tests are still failing, but at least you got a different error. This time, Cucumber\ntracked the source of the exception back to the ninth line of the features/step_defini-\ntions/account.rb file:\nGiven(/^a bank account in Simona's name$/) do\nstep \"a client called Simona\"\n@simona.account = Account.new\nend\nThe step definition is trying to use the Account object even though it doesn’t exist.\nLet’s create the simplest possible implementation of the Account object that should\nmake the tests pass—or at least let you progress to a different error.\nclass Account\nend\nRerun Cucumber:\n$ cucumber\n(...)\nundefined method `account=' for #<Client:0x007f87021cf788 @name=\"Simona\">\n➥(NoMethodError)\n./features/step_definitions/account.rb:9:in\n➥`/^a bank account in Simona's name$/'\nAnother exception. The implementation of the Client object still doesn’t have a\nmethod for connecting bank accounts with their owners—but you use the method in\nListing A.11\nfeatures/implementation/account.rb\nAnother NameError \nexception\nLine 9\n",
      "content_length": 1835,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 288,
      "content": "262\nCHAPTER \nExecuting specifications with Cucumber\nlisting A.12 when you invoke the account= method on the @simona instance of the\nClient object. Let’s fix that.\nclass Client\ndef initialize(name:)\n@name = name\nend\ndef name\n@name\nend\ndef account=(account)\n@account = account\nend\nend\nThe account= method sets the client’s bank account to the account you put in the\nargument—just as the test expects.\n Again, run Cucumber:\n$ cucumber\n(...)\nundefined method `account' for #<Client:0x007fc42d34d9a8>\nDid you mean?\naccount= (NoMethodError)\n./features/step_definitions/account.rb:13:in\n➥`/^that her current account balance is \\$(\\d+)$/'\nAgain, the run fails—and again, with a different error. By this time, you should under-\nstand how TDD works. Writing the tests first lets you progress in small, incremental\nloops driven by tests. You test a little and then code a little.\n This example was a bit far-fetched. In the real world, you wouldn’t wait for Cucum-\nber to notify you if you knew an implementation of an object was missing. Experi-\nenced programmers can sense how much code is needed from the outset and write\nthe final methods on their first try. Now that you know how TDD works, you can skip\nthe incremental changes and go straight to working implementation code.\n Following is the working implementation of the Client object.\nclass Client\ndef initialize(name:)\n@name = name\nend\ndef name\n@name\nend\ndef account=(account)\nListing A.12\nExpended Client object with an account= method\nListing A.13\nfeatures/implementation/client.rb\n",
      "content_length": 1533,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 289,
      "content": "263\nExecuting the working specification\n@account = account\nend\ndef account\n@account\nend\nend\nAnd here’s the working implementation for the Account object.\nclass Account\ndef initialize\n@balance = 0\nend\ndef balance\n@balance\nend\ndef balance=(balance)\n@balance = balance\nend\ndef deposit(transfer)\n@balance += transfer\nend\nend\nWith these two objects, you can expect your next Cucumber run to work without any\nproblem. You’ll soon see if that’s true. \nA.7\nExecuting the working specification\nIf you execute cucumber again, you’ll see that the testing code works well and your sce-\nnarios pass (I cut out the content of the scenarios to make the listing shorter):\n$ cucumber\n(...)\n1 scenario (1 passed)\n4 steps (4 passed)\n0m0.057s\nHooray! Now that the objects and tests work, you can rerun Cucumber every time you\nwant to check whether the underlying implementation code still behaves as the test-\ning code expects it to. Every time you make a change to the codebase—for example,\nwhen you introduce a new feature or fix an error in an existing feature—you can exe-\ncute the cucumber command and see if the Client and Account objects work as they\nshould. \nListing A.14\nfeatures/implementation/account.rb\n",
      "content_length": 1195,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 290,
      "content": "264\nCHAPTER \nExecuting specifications with Cucumber\nA.8\nExecuting scenario outlines\nIn chapter 4, you learned that a scenario outline is a template that similar scenarios\ncan share so you don’t have to repeat the same Given-When-Thens throughout your\nfeature file. Scenario outlines use more-technical elements of Gherkin’s syntax, such\nas dynamic parameters and tables with examples. In this section, we’ll explore\nwhether and how such elements change the automation process for scenario outlines.\n Let’s begin by adding a second scenario with a contrasting outcome that you can\nrewrite as an outline later. You have a scenario for deposits; the following is a scenario\nfor withdrawals.\nFeature: Bank account\nScenario: Adding money to your account\nGiven a bank account in Simona's name\nAnd that her current account balance is $0\nWhen she deposits $500\nThen the account balance should be $500\nScenario: Withdrawing money from your account\nGiven a bank account in Simona's name\nAnd that her current account balance is $500\nWhen she withdraws $500\nThen the account balance should be $0\nNow that you have two similar scenarios, you can rewrite the specification as a single\nscenario outline.\nFeature: Bank account\nScenario Outline: Managing money in your account\nGiven a bank account in Simona's name\nAnd that her current account balance is <balance>\nWhen she <action>\nThen the account balance should be <result>\nExamples:\n| balance | action\n| result |\n| $0\n| deposits $500\n| $500\n|\n| $500\n| withdraws $500 | $0\n|\nHaving done that, run Cucumber to check whether the tests pass or break:\n$ cucumber\n(...)\n2 scenarios (1 undefined, 1 passed)\n8 steps (1 skipped, 1 undefined, 6 passed)\nListing A.15\nAdding a withdrawal scenario to the executable specification\nListing A.16\nTwo similar scenarios reframed as a single scenario outline\n",
      "content_length": 1827,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 291,
      "content": "265\nExecuting scenario outlines\n0m0.009s\nYou can implement step definitions for undefined steps with these snippets:\nWhen(/^she withdraws \\$(\\d+)$/) do |arg1|\npending # Write code here that turns the phrase above into concrete actions\nend\nCucumber generated a snipper for a pending step definition. That’s because the new\nwithdrawal scenario only changed the main action of the scenario from a deposit to a\nwithdrawal.\n Let’s add the snippet to features/step_definitions/account.rb and write the testing\ncode that will be run upon execution.\nWhen(/^she withdraws \\$(\\d+)$/) do |arg1|\n@simona.account.withdraw(arg1.to_i)\nend\nThis code is similar to the code you wrote for the deposit step back in section A.4.3.\nYou just changed the deposit method in the Account object to a new withdraw\nmethod that will handle withdrawals.\n You know what will happen if you run Cucumber: you’ll see a NoMethodError\nexception, because the Account object doesn’t yet know how to handle withdrawals.\nLet’s take care of this now.\nclass Account\ndef initialize\n@balance = 0\nend\ndef balance\n@balance\nend\ndef balance=(balance)\n@balance = balance\nend\ndef deposit(transfer)\n@balance += transfer\nend\ndef withdraw(transfer)\n@balance -= transfer\nend\nend\nThe implementation of the withdraw method is the opposite of the deposit method.\nIt should make the tests run successfully, though. Let’s see if that’s true:\nListing A.17\nTesting code for the step definition added in the outline\nListing A.18\nAdding the withdraw method to the Account object\n",
      "content_length": 1516,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 292,
      "content": "266\nCHAPTER \nExecuting specifications with Cucumber\n$ cucumber\nFeature: Bank account\nScenario Outline: Managing money in your account\n➥# features/outline.feature:3\nGiven a bank account in Simona's name\n➥# features/outline.feature:5\nAnd that her current account balance is <balance>\n➥# features/outline.feature:6\nWhen she <action>\n➥# features/outline.feature:7\nThen the account balance should be <result>\n➥# features/outline.feature:8\nExamples:\n| balance | action\n| result |\n| $0\n| deposits $500\n| $500\n|\n| $500\n| withdraws $500 | $0\n|\n2 scenarios (2 passed)\n8 steps (8 passed)\n0m0.011s\nThat’s it. The examples passed! Even though you may have suspected that the pro-\ngrammatic elements of scenario outlines, such as dynamic parameters and tables,\nwould complicate your code in the automation layer, the testing process looked the\nsame. Cucumber goes through the parameters before execution and generates new\nscenarios out of the scenario outlines—and only then are the scenarios executed.\nThat’s why you didn’t have to change anything in the step definitions from previous\nsections. \nA.9\nTesting systems end to end with Capybara\nIn this appendix, you’ve used Cucumber to write unit tests because they’re short and\neasy to learn. But in the testing community, Cucumber is typically associated with\nusing Capybara for an end-to-end system testing.\nDEFINITION\nCapybara—An integration testing tool for web applications. Capy-\nbara helps you test web applications by simulating how a real user would inter-\nact with your app.\nYou can even configure Capybara to run Firefox or Chrome on your machine as a test\ndriver in order to watch Cucumber click over the simulated user interface when it\ntests the system. The main benefit is that such tests check the system end to end, forc-\ning it to integrate different elements such as the domain layer, API calls, and the user\ninterface. The main drawback is that end-to-end testing is slow and performance\nheavy. In the banking example, the unit tests took 0.011 seconds; a single end-to-end\nintegration test can take up to 30 seconds, depending on how many screens you want\nto test in a single run.\n",
      "content_length": 2138,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 293,
      "content": "267\nTesting systems end to end with Capybara\n We won’t be analyzing a Capybara end-to-end example in this appendix. To do so,\nyou’d need to create a fully working web application—a task that’s definitely beyond\nthe scope of this book. Besides, other resources such as The Cucumber Book, referenced\nearlier, can help you learn more about end-to-end testing. What you can do, though, is\nrewrite one step definition to see what a test using Capybara looks like.\nWhen(/^she deposits \\$(\\d+)$/) do |arg1|\nclick_link \"Deposit\"\nfind(\"input#deposit\", match: :first).set arg1\nclick_button \"Deposit\"\nend\nCapybara provides a new set of methods such as click_link, find, and click_button\nthat you can use to interact with the user interface.\n As of version 5.1, Ruby on Rails has Capybara working out of the box as the default\nsolution for system tests. You get a Capybara wrapper that’s preconfigured for Chrome\nand enhanced to provide failure screenshots as part of Action Dispatch. Different\nframeworks in other programming languages have their own equivalents of Capybara.\n Even if your language doesn’t provide something like Capybara, you can use the\noriginal Ruby version and write Cucumber tests in Ruby that will check your applica-\ntion written in any other language. This is possible because Capybara only interacts\nwith the user interface, so you only have to run a web server behind the scenes that\ncan serve a simulation of your web application. As long as you do that, you’ll be fine. \nListing A.19\nWhen step rewritten to use Capybara\n",
      "content_length": 1538,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 295,
      "content": "269\nA\nabilities 177–181\nchoosing granularity level for 180–181\norganizing specification suite with 179–180\nrefactoring business needs into 208–212\nrefactoring features into 196–203\nadding scenarios over time 198–200\nderiving new scenarios from user \nstories 197\nsplitting features into small abilities 200–203\nstarting with simple features 197–198\nreworking features into 178–179\nAbility keyword 45\nabstraction levels, choosing 71–73\ndisadvantages of over specifying 71–72\nsuggested number of steps in scenarios 72–73\nacceptance criteria\ndefining 5–6\nvetting with examples 75\nacceptance tests 12, 35\nactions in scenarios, naming 159\nactive life cycle 146\nactors\ndefining in scenarios 58–60\nin scenarios 159\nadvanced filtering 116\nadverbs 62\nagile 10\nall-team specification workshops 164\nanalysis paralysis 8\nanalytics domain 230\nanalyzing requirements with examples 130–136\ncollecting examples 133–135\nconveying requirements as user stories\n130–133\nrefining user stories with examples 135–136\nAnd keyword 44\nangle brackets 87\nangry path 108\nanti-patterns, avoiding 114–120\nclasses of equivalence 119–120\ndatabase models 117–119\nsimple combinatorial outcomes 114–117\ntypical data validations 114\napplication security events 236\napplication security team 196\nassertions 258\naudience, for living documentation 166–169\nautomata-machines 12\nautomating\nconversations 14\nbenefits of 19–22\ntests based on examples 19–20\nautomation framework 36\nautomation layers 34–37\ninteracting with specification layers 47–51\noverview 32–34\nB\nbackgrounds, reusing Givens with 69–71\nbacklog, Scrum 184\nBAD listings 32\nBDD (behavior-driven development) 258\nbehavioral requirements 23\nBEST listings 32\nboomerangs 111–113\nbounded contexts\nanalyzing domain concepts in context\n235–241\ndealing with false cognates 237–239\nspotting duplicate concepts 239–241\nspotting false cognates 236–237\nindex\n",
      "content_length": 1868,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 296,
      "content": "270\nINDEX\nbounded contexts (continued)\nfitting DDD into SBE process 248–249\nmodeling specification suites as 241–247\ndrawing context maps 246–247\nmanaging bounded contexts with context \nmaps 245–246\noverview 241–242\nsplitting large specification suite into multi-\nple bounded contexts 242–245\nbounding sides 156\nbuilding living documentation 12\nBusiness Need keyword 45, 189–190\nbusiness needs\nadding functional scenarios to 204–206\nidentifying new stakeholders with 207–208\nidentifying with conversations\nderiving scope from goals 15–16\nillustrating requirements with examples\n16–18\nspecifying collaboratively 18\nrefactoring into abilities 208–212\nbusiness rules, organizing feature files by 89–90\nBut keyword 44\nC\ncapturing conversations 14\nCapybara, testing systems with 266–267\ncarryover customer 135\nchunking up/down 63\nCI (continuous integration) 21, 143\nCISO (Chief Information Security Officer) 207\nclasses, of equivalence 119–120\nclick_link method 267\ncloud domain 79\ncloud drive 217\ncloud features 77\ncode refactoring 94\ncollaborative specification 18\ncollecting examples\nfor outside-in scenario outlines 100\noverview 133–135\ncombinatorial outcomes 114–117\ncompiling 51\ncontent 162\ncontext maps\ndrawing 246–247\nmanaging bounded contexts with 245–246\ncontext notes 160–161\ncontexts, exploring by questioning Givens 75–76\ncontextual glossary 237\ncontinuous deployment 143\nconversations\nbenefits of automating 19–22\nautomating tests based on examples 19–20\nliving documentation 21–22\nvalidating frequently 21\nidentifying business needs with 14–18\nderiving scope from goals 15–16\nillustrating requirements with examples\n16–18\nspecifying collaboratively 18\nConway's Law 163\ncore domain 219, 236\ncorridor testing 73\ncounterexamples 106–107\ncreating events 199\ncriteria, acceptance 75\ncritiquing feedback 123\ncritiquing stage 134\ncucumber --init command 254\nCucumber, executing specifications with\nconfiguring environment 253–254\nexecuting scenario outlines 264–266\nexecuting the working specification 263\npreparing scenarios for automation 254–255\ntest-driven development 251–252\ntesting systems end to end with Capybara\n266–267\nunit tests 252–253\nwriting implementation code based on tests\n259–263\nwriting tests in test-driven manner 256–259\nCukeHub 22\nD\ndata\ngathering 61–62\nvalidations 114\ndatabase models 117–119\nDDD (domain-driven design)\nfitting into SBE process 248–249\noverview 215, 235\ndecentralization 245\ndeclarative style 63\ndefinitions by example 157\ndelinquent path 109\ndesigning acceptance tests 12\ndesolate path 109\ndestination 154\ndistilling business domains\ncore domain from scenarios 218–219\ncreating domain model from distilled domains\n221–224\nimportance of good models 222–223\nspecification suite 221–223\nwhat makes good domain model 224\nspotting different domains in scenarios\n216–218\n",
      "content_length": 2811,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 297,
      "content": "271\nINDEX\ndistilling business domains (continued)\nsubdomains accompanying core domain\n219–220\nsubdomains from mixed scenarios 226–228\nsubdomains from other scenarios 228–230\nsubdomains from unequivocal scenarios\n225–226\ndocumentation. See living documentation\ndomain concepts, naming 158–160\nactions in scenarios 159\nactors that appear in scenarios 159\nstates in which scenarios begin and end\n159–160\ndomain experts 7\ndomain model 7, 221\ndomain-driven design. See DDD\ndomain-driven specification suite, building\ncreating domain model from distilled \ndomains 221–224\nimportance of good models 222–223\nspecification suite 221–223\nwhat makes good domain model 224\ncreating specification suite from distilled \ndomains 230–231\ndistilling business domains 215–220\ncore domain from scenarios 218–219\nspotting different domains in scenarios\n216–218\nsubdomains accompanying core \ndomain 219–220\nsubdomains from mixed scenarios 226–228\nsubdomains from other scenarios 228–230\nsubdomains from unequivocal \nscenarios 225–226\ndomain-specific examples 104–106\nDRY (Don’t Repeat Yourself) 88, 99\ndummies 98\ndummy data 98\nduplicate concepts 240\nE\nembarrassing path 108\nend users 60\nend-to-end tests 62\nequivalence, classes of 119–120\nevents domain 227\nevents team 196\nevolving requirements 125\nexample-counterexample 83\nexamples\nanalyzing requirements with 130–136\ncollecting examples 133–135\nconveying requirements as user stories\n130–133\nrefining user stories with examples 135–136\nautomating tests based on 19–20\nchoosing for scenario outlines\navoiding scenario outline anti-patterns\n114–120\nshopping application example 99\nwriting outside-in scenario outlines 99–102\ncollecting 100, 133–135\nderiving scenarios from 137–139\ndomain-specific 104–106\nillustrating requirements with 16–18\nrefining user stories with 135–136\nvetting acceptance criteria with 75\nwriting outside-in scenario outlines from\n101–102\nSee also key examples\nExamples tables\nin scenario outlines 86\noverview 100\nexecutable scenarios, user stories and 183–184\nexecutable specifications\nlayers of 32–37\nautomation layers 34–37\nspecification layers 33–34\nlife cycle of\nanalyzing requirements with examples\n130–136\nderiving scenarios from examples 137–139\nend-to-end overview 126–127\niterating specifications over time 141–146\nrefining scenarios 139–141\nunderstanding business goals 127–129\nexhaustive examples 102\nexhaustive testing 102\nexpect syntax, RSpec 259\nexpected state 159\nexploratory outcomes 107–111, 136\nangry path 108\ndelinquent path 109\ndesolate path 109\nembarrassing path 108\nexamples of 109–111\nforgetful path 109\ngreedy path 109\nhappy path 108\nindecisive path 109\nscary path 108\nstressful path 109\nF\nfailure scenario 88\nfalse cognates 236\ndealing with 237–239\nspotting 236–237\n",
      "content_length": 2746,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 298,
      "content": "272\nINDEX\nfeature files 34, 175\norganizing by high-level business rules 89–90\nshorter with scenario outlines 89\nfeature injection format 182\nFeature keyword 38–39, 45, 175, 178\nfeatures\norganizing scenarios by 175–176\nrefactoring into abilities 196–203\nadding scenarios over time 198–200\nderiving new scenarios from user stories 197\nsplitting features into small abilities 200–203\nstarting with simple features 197–198\nreworking into abilities 178–179\nfeedback loops 35, 152, 224\nfiction 10\nfiltering advanced 116\nFitNesse 36\nFive Whys technique 113\nforgetful path 109\nfragments 250\nfunctional requirements 186\nG\ngathering realistic data 61–62\ngem install cucumber command 253\ngenus-differentia definition 156\nGherkin language\noutside-in development with 56–61\ndefining actors in scenarios 58–60\nuser-oriented scenarios 56–58, 60–61\nSBE and\nbenefits of automating conversations 19–22\nbenefits of specifications 4–7\ncreating software with 25–27\nidentifying business needs with conversations\n14–18\nintroduction to 11–14\nproblems with specifications 8–11\nspecifications, defined 4\nscenarios 38–43, 64–77\nchoosing abstraction levels 71–73\nchoosing styles for 55–64\nexploring contexts by questioning Givens\n75–76\nexploring outcomes by questioning Thens\n76–77\nFeature keyword 38–39\nGivens 40–41\nScenario line 39–40\nspecifying prerequisites with Givens 67–71\nspotting redundancies in 82–84\nstarting with Thens 64–65\nThens 42–43\nusing one When per scenario 65–67\nvetting acceptance criteria with examples 75\nWhens 42\nwriting warm-up narratives 74–75\nGivens 40–41\ndefining prerequisites with 256–257\nexploring contexts by questioning 75–76\nreusing with backgrounds 69–71\nspecifying prerequisites with 67–71\nGiven-When-Then templates\nchoosing styles for Gherkin scenarios 55–64\ngathering realistic data 61–62\noutside-in development with Gherkin 56–61\nspecifying intentions and outcomes 62–64\nwriting Gherkin scenarios 64–77\nchoosing abstraction levels 71–73\nexploring contexts by questioning Givens\n75–76\nexploring outcomes by questioning Thens\n76–77\nspecifying prerequisites with Givens 67–71\nstarting with Thens 64–65\nusing one When per scenario 65–67\nvetting acceptance criteria with examples 75\nwriting warm-up narratives 74–75\nglobal definitions 155\nglossaries, living documentation 158\ngoals\nderiving scope from 15–16\nof businesses 127–129\nGoldilocks principle 120\nGOOD listings 32\ngreedy path 109\ngrowing scenario outlines 90–94\nH\nhand-offs 8–9\nhappy paths 47, 108, 136\nhigh-level composition 64\nHouseKeeper 150, 161\nI\nidentifying business needs with conversations\nderiving scope from goals 15–16\nillustrating requirements with examples 16–18\nspecifying collaboratively 18\nidentity context 244\nillustrative definitions, writing 156–157\nillustrative testing 103\nimpact map 128\nimperative style 63\nindecisive path 109\ninformation asymmetry 5, 165\n",
      "content_length": 2842,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 299,
      "content": "273\nINDEX\ninitial state 159\nintense domain exercises 164\nintentions, specifying 62–64\ninterface-oriented style 63\niterating specifications 141–146\nevolving documentation systems 144–146\nvalidating specification suites 141–144\niterative documentation 166\nJ\nJBehave 36, 176\nK\nkey examples, finding for scenario outlines\n102–113\nboomerangs 111–113\ncounterexamples 106–107\ndomain-specific examples 104–106\nexploratory outcomes 107–111\nkey process patterns 13–14\nkeywords 44, 169\nKPIs (key performance indicators) 173, 228\nL\nlanguages, building 6–7\nlarge suites 235\nlayers, of executable specifications 32–37\nSee also automation layers; specification layers\nlexical definitions\noverview 170\nwriting 154–156\nlife cycle 125\nliving documentation\naudience for 166–169\ncreating 163–166\nthrough all-team specification workshops\n164\nthrough individual people 165–166\nthrough Three Amigos meetings 164–165\ndocumenting decisions using briefs 160–161\ncontext notes 160–161\nmaintenance notes 161\nwarning notes 160\nin example 150–153\nnaming important domain concepts 158–160\nactions in scenarios 159\nactors that appear in scenarios 159\nstates in which scenarios begin and end\n159–160\nprocess overview 161–163\nusing glossaries 158\nwriting 153–154\nwriting illustrative definitions 156–157\nwriting lexical definitions 154–156\nlocal definitions 155\nlow-level composition 64\nM\nmaintaining scenario outlines 90–94\nmaintenance notes 161\nMapper project 127\nmaps 60\nmarketing myopia 65\nmerging examples 81\nmessages 161\nmeta-note 161\nmethodologies 26\nMQRs (minimally qualified readers) 166–169\nN\nNameError 260\nNarrative keyword 177\nnarrative section, JBehave 176\nnarratives, warm-up 74–75\nnegative outcomes 46\nnew scenarios 184\nNoMethodError 265\nnonfunctional requirements 186–193\nBusiness Need keyword 189–190\ndealing with according to SBE 187–188\nwhether Gherkin scenarios can specify 188–189\nnotes\ncontext notes 160–161\nmaintenance notes 161\nwarning notes 160\nO\nOK listings 32\norganizing scenarios. See scenarios, organizing\noutcome questioning 76, 218\noutcome-oriented style 63\noutcomes\ncombinatorial 114–117\ncommon 181\nexploratory 107–111\nangry path 108\ndelinquent path 109\ndesolate path 109\nembarrassing path 108\nexamples of 109–111\nforgetful path 109\ngreedy path 109\n",
      "content_length": 2247,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 300,
      "content": "274\nINDEX\noutcomes, exploratory (continued)\nhappy path 108\nindecisive path 109\nscary path 108\nstressful path 109\nexploring by questioning Thens 76–77\nspecifying 62–64\ntesting 45–47\noutlines. See scenario outlines\noutside-in development, with Gherkin 56–61\ndefining actors in scenarios 58–60\nuser-oriented scenarios 56–58, 60–61\noutside-in scenario outlines, writing 99–102\ncollecting examples for 100\nfrom collected examples 101–102\nover-specification 8\nP\npairwise testing 115\npassive life cycle 146\npasswords 190\npatterns, key process 13–14\npayments domain 79\npersonas 58\nplane figure 156\nplanning tools 185\npolysemes 158, 236\npositive outcomes 47\nposts 228\nprecision level 126\nprerequisites, specifying with Givens 67–71\nprice index 154\nQ\nquadrilateral connotative definition 155\nquality measures 5\nqueries 189\nR\nraw examples 86\nreceiver 162\nred-green-refactor 252\nredundancies, spotting in Gherkin scenarios\n82–84\nrefactoring code 94\nrefactoring redundant scenarios 84–86\nrefine scenarios 139\nrefining\nscenarios 139–141\nuser stories with examples 135–136\nregression tests 153\nRelish 22\nremoving examples 81\nrequirements\nanalyzing with examples 130–136\ncollecting examples 133–135\nrefining user stories with examples 135–136\nconveying as user stories 130–133\nrestricted keyword 44\nreusing Givens with backgrounds 69–71\nRspec 258\nrspec-expectations library 258\nS\nSBE (specification by example)\ndealing with nonfunctional requirements \naccording to 187–188\nfitting DDD into process 248–249\nGherkin and\nbenefits of automating conversations 19–22\nbenefits of specifications 4–7\ncapturing conversations as executable \nspecifications 22–25\ncreating software with 25–27\nidentifying business needs with conversations\n14–18\nintroduction to 11–14\nproblems with specifications 8–11\nspecifications, defined 4\nscan test 107\nscary path 108\nscenario briefs 170\nScenario keyword 45\nScenario line 39–40\nscenario outlines\nadvantages of 89–90\nfeature files organized by high-level business \nrules 89–90\nshorter feature files 89\navoiding anti-patterns 114–120\nclasses of equivalence 119–120\ndatabase models 117–119\nsimple combinatorial outcomes 114–117\ntypical data validations 114\nchoosing examples for\navoiding scenario outline anti-patterns\n114–120\nwriting outside-in scenario outlines 99–102\ndisadvantages of 95\nfinding key examples for 102–113\nboomerangs 111–113\ncounterexamples 106–107\ndomain-specific examples 104–106\nexploratory outcomes 107–111\ngrowing and maintaining 90–94\n",
      "content_length": 2466,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 301,
      "content": "275\nINDEX\nscenario outlines (continued)\noutside-in, writing 99–102\nrefactoring redundant scenarios with 84–86\nshopping application example 81–82, 99\nstructure of 86–88\nExamples tables 86\nparameters 87–88\nScenario Outline keyword 88\nusing 82–86\nrefactoring redundant scenarios with sce-\nnario outlines 84–86\nspotting redundancies in Gherkin scenarios\n82–84\nscenarios\ndefining actors in 58–60\nderiving from examples 137–139\nin Gherkin\nchoosing styles for 55–64\nspotting redundancies in 82–84\norganizing\nby features 175–176\nby user stories 176–186\nabilities 177–181\nexecutable specifications and 183–184\niterative dangers of 184–186\nstructure of 182\nnonfunctional requirements 186–193\nBusiness Need keyword 189–190\ndealing with according to SBE 187–188\nwhether Gherkin scenarios can specify\n188–189\npreparing for automation 254–255\nredundant, refactoring with scenario outlines\n84–86\nrefining 139–141\nsimplifying 71–72\nsplitting 175, 181\nstructure of 43–45\nsuggested number of steps in 72–73\nuser-oriented\noutside-in development and 60–61\nwriting 56–58\nwriting in Gherkin 38–43, 64–77\nchoosing abstraction levels 71–73\nexploring contexts by questioning Givens\n75–76\nexploring outcomes by questioning Thens\n76–77\nFeature keyword 38–39\nGivens 40–41\nScenario line 39–40\nspecifying prerequisites with Givens 67–71\nstarting with Thens 64–65\nThens 42–43\nusing one When per scenario 65–67\nvetting acceptance criteria with examples 75\nWhens 42\nwriting warm-up narratives 74–75\nSee also scenario outlines\nscheduling events 199\nscope boundaries 177\nscope, deriving from goals 15–16\nscope-exploration exercises 164\nscreening 154\nScrum 184\nsender 162\nserial events 199\nservices 244\nshipping methods 93\nSimona scenario 58\nsimple outcomes 115\nsimplifying scenarios 71–72\nsimulations 35\nsingle sign-on. See SSO\nsingle source of failure 165\nsingle source of truth 165\nsmall characteristics 10\nsnapshots 68\nsoftware\ncreating with Gherkin 25–27\ncreating with SBE 25–27\nsource 61\nspecification briefs 38, 170\nspecification by example. See SBE\nspecification layers\ninteracting with automation layers 47–51\noverview 33–34\nspecification suites\nmodeling as bounded contexts 241–247\ndrawing context maps 246–247\nmanaging bounded contexts with context \nmaps 245–246\noverview 241–242\nsplitting large specification suite into multi-\nple bounded contexts 242–245\nvalidating 141–144\nspecification workshops, all-team 164\nspecifications\nbenefits of 4–7\nbuilding ubiquitous languages 6–7\ndefining acceptance criteria 5–6\ndefined 4\nexecuting with Cucumber\nconfiguring environment 253–254\nexecuting scenario outlines 264–266\nexecuting working specification 263\npreparing scenarios for automation 254–255\ntest-driven development 251–252\ntesting systems with Capybara 266–267\n",
      "content_length": 2738,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 302,
      "content": "276\nINDEX\nspecifications, executing with Cucumber\n(continued)\nunit tests 252–253\nwriting implementation code based on tests\n259–263\nwriting tests in test-driven manner 256–259\niterating 141–146\nevolving documentation systems 144–146\nvalidating specification suites 141–144\nproblems with 8–11\nhand-offs 8–9\nover-specification 8\nspeci-fiction 10\ntest-inability 10–11\nunder-documentation 9–10\nSee also executable specifications\nspeci-fiction 10\nsplitting scenarios 175, 181\nSSO (single sign-on) 207\nstakeholder management 189\nstakeholders 60\nstandard processes 106\nstate of the system 101\nstates, naming 159–160\nstep definitions\nmatching steps with 48–51\noverview 47–48\nstep method 256–257\nsteps\nmatching with step definitions 48–51\nstructure of 43–45\nsuggested number in scenarios 72–73\nstrategic design 247\nstrategic domain-driven design 215\nstressful path 109\nstructure, of scenario outlines 86–88\nExamples tables 86\nparameters 87–88\nScenario Outline keyword 88\nstyles, choosing for Gherkin scenarios 55–64\ngathering realistic data 61–62\noutside-in development with Gherkin 56–61\nspecifying intentions and outcomes 62–64\nsubdomains 219\nsuccess scenario 88\nsupporting feedback 123\nT\ntargeting 201\nTDD (test-driven development) 251\nteam leadership 197\nteam member 41\ntechnological ability 136\ntemplates. See Given-When-Then templates\ntenant leads 154\ntenants pipeline 150\ntest execution engine 36\ntest runner 36, 253\ntest safely 102\ntest suite 35\ntest-inability 10–11\ntesting\nautomating based on examples 19–20\nframework 36\nheuristics 102\noutcomes 45–47\nsystems, with Capybara 266–267\nThens\nexploring outcomes by questioning 76–77\noverview 42–43\ntesting consequences with 258–259\nto begin composing scenarios 64–65\nThree Amigos meetings 164–165\nticket for conversation 183\ntriangle connotative definition 155\ntrigger 132\ntwo-factor authentication 188\nU\nUAT (user acceptance testing) 144\nubiquitous language 33, 154\nUI (user interface), favoring specifying intentions \nand outcomes over 62–64\nuncouple domains 217\nundefined test results 255\nunder-documentation 9–10\nunhappy paths 136\nunification 224\nunit of work 252\nunits 156\nuser journey map 60\nuser stories\nanalyzing 196\nconveying requirements as 130–133\norganizing scenarios by 176–186\nabilities 177–181\nexecutable specifications and user \nstories 183–184\niterative dangers of 184–186\nstructure of 182\nrefining with examples 135–136\nuser-oriented scenarios\noutside-in development and 60–61\nwriting 56–58\n",
      "content_length": 2455,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 303,
      "content": "277\nINDEX\nV\nvalidating\nfrequently 21\nspecification suites 141–144\nvaluable characteristics 10\nvetting acceptance criteria with examples 75\nW\nwarm-up narratives, writing 74–75\nwarning notes 160\nWhens\noverview 42\ntaking actions with 257–258\nusing one per scenario 65–67\nwriting\ndocumentation 153–154\noutside-in scenario outlines 99–102\ncollecting examples for 100\nfrom collected examples 101–102\nscenarios in Gherkin 38–43, 64–77\nchoosing abstraction levels 71–73\nexploring contexts by questioning Givens\n75–76\nexploring outcomes by questioning Thens\n76–77\nFeature keyword 38–39\nGivens 40–41\nScenario line 39–40\nspecifying prerequisites with Givens 67–71\nstarting with Thens 64–65\nThens 42–43\nusing one When per scenario 65–67\nvetting acceptance criteria with examples 75\nWhens 42\nwriting warm-up narratives 74–75\nwarm-up narratives 74–75\n",
      "content_length": 837,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 304,
      "content": "MORE TITLES FROM MANNING\nFor ordering information go to www.manning.com\nSpecification by Example\nHow Successful Teams Deliver the Right Software\nby Gojko Adzic\nISBN: 9781617290084\n296 pages\n$49.99\nJune 2011\nBDD in Action\nBehavior-Driven Development for the whole software lifecycle\nby John Ferguson Smart\nISBN: 9781617291654\n384 pages\n$49.99\nSeptember 2014\nTest Driven\nPractical TDD and Acceptance TDD for Java Developers\nby Lasse Koskela\nISBN: 9781932394856\n544 pages\n$44.99\nAugust 2007\n",
      "content_length": 488,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 305,
      "content": "MORE TITLES FROM MANNING\nFor ordering information go to www.manning.com\nJava Testing with Spock\nby Konstantinos Kapelonis\nISBN: 9781617292538\n304 pages\n$44.99\nMarch 2016\nThe Art of Unit Testing, Second Edition\nwith examples in C#\nby Roy Osherove\nISBN: 9781617290893\n296 pages\n$44.99\nNovember 2013\nEffective Unit Testing\nA guide for Java developers\nby Lasse Koskela\nISBN: 9781935182573\n258 pages\n$39.99\nFebruary 2013\n",
      "content_length": 416,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 306,
      "content": "MORE TITLES FROM MANNING\nFor ordering information go to www.manning.com\nKanban in Action\nby Marcus Hammarberg and Joakim Sundén\nISBN: 9781617291050\n360 pages\n$44.99\nFebruary 2014\nThe Mikado Method\nby Ola Ellnestam and Daniel Brolund\nISBN: 9781617291210\n240 pages\n$44.99\nMarch 2014\nRe-Engineering Legacy Software\nby Chris Birchall\nISBN: 9781617292507\n232 pages\n$64.99\nApril 2016\n",
      "content_length": 378,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 307,
      "content": "Best practices in the book\n \nBest practice\nSection\nDon’t let agile be an excuse to ignore documentation.\n1.3.3\nDon’t let documentation replace communication.\n1.3.2\nDerive scope from goals.\n1.5.1\nIllustrate requirements with examples.\n1.5.2\nSpecify collaboratively.\n1.5.3, 7.4\nValidate frequently.\n1.6.2\nCapture behavioral requirements with scenarios.\n2.2.2\nGather examples from the real world.\n3.1.2\nFavor specifying intentions and outcomes over user interface.\n3.1.3\nStart writing scenarios with the Then keyword.\n3.2.1\nAim for one When keyword per scenario.\n3.2.3\nDon’t use backgrounds.\n3.2.3\nAim for as few Givens, Whens, and Thens as possible.\n3.2.4\nRefactor redundant scenarios with scenario outlines.\n4.2.2\nWrite scenario outlines from examples.\n5.2\nRefine scenarios by keeping only key examples.\n5.3\nAvoid examples of simple combinatorial outcomes.\n5.4.2\nHide the database layer.\n5.4.3\nAvoid classes of equivalence.\n5.4.4\nDocument domain concepts in briefs.\n7.2.1\nWrite documentation for the minimally qualified reader.\n7.5\nUse the Ability keyword to specify functional user stories.\n8.2.1\nUse the Business Need keyword to specify nonfunctional user stories.\n8.3.3\nBreak big business needs into smaller abilities.\n9.3.3\nBuild a domain-driven specification suite.\n10.3\nSplit a large specification suite into multiple bounded contexts.\n11.2\n",
      "content_length": 1346,
      "extraction_method": "PyMuPDF_fallback"
    },
    {
      "page_number": 308,
      "content": "$44.99 / Can $59.99  [INCLUDING eBOOK]\nKamil Nicieja\nT\nhe clearest way to communicate a software speciﬁ cation is \nto provide examples of how it should work. Turning these \nstory-based descriptions into a well-organized dev plan is \nanother matter. Gherkin is a human-friendly, jargon-free lan-\nguage for documenting a suite of examples as an executable \nspeciﬁ cation. It fosters efﬁ cient collaboration between business \nand dev teams, and it’s an excellent foundation for the speciﬁ ca-\ntion by example (SBE)  process.\nWriting Great Specifications teaches you how to capture execut-\nable software designs in Gherkin following the SBE method. \nWritten for both developers and non-technical team members, \nthis practical book starts with collecting individual feature sto-\nries and organizing them into a full, testable spec. You’ll learn to \nchoose the best scenarios, write them in a way that anyone can \nunderstand, and ensure they can be easily updated by anyone. \nWhat’s Inside\n● Reading and writing Gherkin\n● Designing story-based test cases\n● Team collaboration\n● Managing a suite of Gherkin documents\nPrimarily written for developers and architects, this book is \naccessible to any member  of a software design team.\nKamil Nicieja is a seasoned engineer, architect, and project man-\nager with deep expertise in Gherkin and SBE.\nTo download their free eBook in PDF, ePub, and Kindle formats, \nowners of this book should visit \nwww.manning.com/books/writing-great-specifications\nWRITING GREAT SPECIFICATIONS\nSOFTWARE ENGINEERING\nM A N N I N G\n“\nDoes a great job taking \nconcepts from good architec-\ntural practices and applying \nthem to the world of collab-\norative speciﬁ cations.”\n \n—From the Foreword by \n    Gojko Adžic, author of \n    Speciﬁ cation by Example \n“\nThe missing manual for \nwriting great speciﬁ cations. \nI wish this book had existed \nﬁ ve years ago!”\n \n—Craig Smith, Unbound DNA\n“\nWill jolt you into best \npractices, give you fresh \nperspectives, and reinvigorate \nyour commitment to this \nbusiness-critical skill.”\n \n—Dane Balia, Hetzner\n“\nThe complete book on \nhow to write great speciﬁ ca-\ntions. Most of us know bits \nand pieces, but to truly grok \nit, you need this excellent \nguide.”\n—Kumar Unnikrishnan\n    Thomson Reuters \nSEE  INSERT\n´\n",
      "content_length": 2271,
      "extraction_method": "PyMuPDF_fallback"
    }
  ]
}