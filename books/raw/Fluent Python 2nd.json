{
  "metadata": {
    "title": "Fluent Python 2nd",
    "author": "Luciano Ramalho",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 1011,
    "conversion_date": "2025-12-19T18:22:18.739848",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "Fluent Python 2nd.pdf",
    "extraction_method": "Unstructured"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 1-21)",
      "start_page": 1,
      "end_page": 21,
      "detection_method": "synthetic",
      "content": "Fluent Python\n\n2nd Edition Covers Python 3.10\n\nClear, Concise, and Effective Programming\n\nLuciano Ramalho\n\nBeijing Beijing\n\nBoston Boston\n\nSECOND EDITION\n\nFluent Python Clear, Concise, and Effective Programming\n\nLuciano Ramalho\n\nFarnham Sebastopol Farnham Sebastopol\n\nTokyo Tokyo\n\nFluent Python by Luciano Ramalho\n\nCopyright © 2022 Luciano Ramalho. All rights reserved.\n\nPrinted in the United States of America.\n\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\n\nO’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles (http://oreilly.com). For more information, contact our corporate/institu‐ tional sales department: 800-998-9938 or corporate@oreilly.com.\n\nAcquisitions Editor: Amanda Quinn Development Editor: Jeff Bleiel Production Editor: Daniel Elfanbaum Copyeditor: Sonia Saruba Proofreader: Kim Cofer\n\nIndexer: Judith McConville Interior Designer: David Futato Cover Designer: Karen Montgomery Illustrator: Kate Dullea\n\nApril 2022:\n\nSecond Edition\n\nRevision History for the Second Edition 2022-03-31: First Release\n\nSee http://oreilly.com/catalog/errata.csp?isbn=9781492056355 for release details.\n\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. Fluent Python, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.\n\nThe views expressed in this work are those of the author and do not represent the publisher’s views. While the publisher and the author have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the author disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work. Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.\n\n978-1-492-05635-5\n\n[LSI]\n\nPara Marta, com todo o meu amor.\n\nTable of Contents\n\nPreface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xix\n\nPart I. Data Structures\n\n1. The Python Data Model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 What’s New in This Chapter 4 A Pythonic Card Deck 5 How Special Methods Are Used 8 Emulating Numeric Types 9 String Representation 12 Boolean Value of a Custom Type 13 Collection API 14 Overview of Special Methods 15 Why len Is Not a Method 17 Chapter Summary 18 Further Reading 18\n\n2. An Array of Sequences. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 What’s New in This Chapter 22 Overview of Built-In Sequences 22 List Comprehensions and Generator Expressions 25 List Comprehensions and Readability 25 Listcomps Versus map and filter 27 Cartesian Products 27 Generator Expressions 29 Tuples Are Not Just Immutable Lists 30 Tuples as Records 30\n\nv\n\nTuples as Immutable Lists 32 Comparing Tuple and List Methods 34 Unpacking Sequences and Iterables 35 Using * to Grab Excess Items 36 Unpacking with * in Function Calls and Sequence Literals 37 Nested Unpacking 37 Pattern Matching with Sequences 38 Pattern Matching Sequences in an Interpreter 43 Slicing 47 Why Slices and Ranges Exclude the Last Item 47 Slice Objects 48 Multidimensional Slicing and Ellipsis 49 Assigning to Slices 50 Using + and * with Sequences 50 Building Lists of Lists 51 Augmented Assignment with Sequences 53 A += Assignment Puzzler 54 list.sort Versus the sorted Built-In 56 When a List Is Not the Answer 59 Arrays 59 Memory Views 62 NumPy 64 Deques and Other Queues 67 Chapter Summary 70 Further Reading 71\n\n3. Dictionaries and Sets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 What’s New in This Chapter 78 Modern dict Syntax 78 dict Comprehensions 79 Unpacking Mappings 80 Merging Mappings with | 80 Pattern Matching with Mappings 81 Standard API of Mapping Types 83 What Is Hashable 84 Overview of Common Mapping Methods 85 Inserting or Updating Mutable Values 87 Automatic Handling of Missing Keys 90 defaultdict: Another Take on Missing Keys 90 The __missing__ Method 91 Inconsistent Usage of __missing__ in the Standard Library 94 Variations of dict 95\n\nvi\n\n|\n\nTable of Contents\n\ncollections.OrderedDict 95 collections.ChainMap 95 collections.Counter 96 shelve.Shelf 97 Subclassing UserDict Instead of dict 97 Immutable Mappings 99 Dictionary Views 101 Practical Consequences of How dict Works 102 Set Theory 103 Set Literals 105 Set Comprehensions 106 Practical Consequences of How Sets Work 107 Set Operations 107 Set Operations on dict Views 110 Chapter Summary 112 Further Reading 113\n\n4. Unicode Text Versus Bytes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117 What’s New in This Chapter 118 Character Issues 118 Byte Essentials 120 Basic Encoders/Decoders 123 Understanding Encode/Decode Problems 125 Coping with UnicodeEncodeError 125 Coping with UnicodeDecodeError 126 SyntaxError When Loading Modules with Unexpected Encoding 128 How to Discover the Encoding of a Byte Sequence 128 BOM: A Useful Gremlin 129 Handling Text Files 131 Beware of Encoding Defaults 134 Normalizing Unicode for Reliable Comparisons 140 Case Folding 142 Utility Functions for Normalized Text Matching 143 Extreme “Normalization”: Taking Out Diacritics 144 Sorting Unicode Text 148 Sorting with the Unicode Collation Algorithm 150 The Unicode Database 150 Finding Characters by Name 151 Numeric Meaning of Characters 153 Dual-Mode str and bytes APIs 155 str Versus bytes in Regular Expressions 155 str Versus bytes in os Functions 156 vii\n\nChapter Summary 157 Further Reading 158\n\n5. Data Class Builders. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163 What’s New in This Chapter 164 Overview of Data Class Builders 164 Main Features 167 Classic Named Tuples 169 Typed Named Tuples 172 Type Hints 101 173 No Runtime Effect 173 Variable Annotation Syntax 174 The Meaning of Variable Annotations 175 More About @dataclass 179 Field Options 180 Post-init Processing 183 Typed Class Attributes 185 Initialization Variables That Are Not Fields 186 @dataclass Example: Dublin Core Resource Record 187 Data Class as a Code Smell 190 Data Class as Scaffolding 191 Data Class as Intermediate Representation 191 Pattern Matching Class Instances 192 Simple Class Patterns 192 Keyword Class Patterns 193 Positional Class Patterns 194 Chapter Summary 195 Further Reading 196\n\n6. Object References, Mutability, and Recycling. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201 What’s New in This Chapter 202 Variables Are Not Boxes 202 Identity, Equality, and Aliases 204 Choosing Between == and is 206 The Relative Immutability of Tuples 207 Copies Are Shallow by Default 208 Deep and Shallow Copies of Arbitrary Objects 211 Function Parameters as References 213 Mutable Types as Parameter Defaults: Bad Idea 214 Defensive Programming with Mutable Parameters 216 del and Garbage Collection 219 Tricks Python Plays with Immutables 221 Table of Contents\n\n6. Object References, Mutability, and Recycling. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201 What’s New in This Chapter 202 Variables Are Not Boxes 202 Identity, Equality, and Aliases 204 Choosing Between == and is 206 The Relative Immutability of Tuples 207 Copies Are Shallow by Default 208 Deep and Shallow Copies of Arbitrary Objects 211 Function Parameters as References 213 Mutable Types as Parameter Defaults: Bad Idea 214 Defensive Programming with Mutable Parameters 216 del and Garbage Collection 219 Tricks Python Plays with Immutables 221 Table of Contents\n\nChapter Summary 223 Further Reading 224\n\nPart II.\n\nFunctions as Objects\n\n7. Functions as First-Class Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231 What’s New in This Chapter 232 Treating a Function Like an Object 232 Higher-Order Functions 234 Modern Replacements for map, filter, and reduce 235 Anonymous Functions 236 The Nine Flavors of Callable Objects 237 User-Defined Callable Types 239 From Positional to Keyword-Only Parameters 240 Positional-Only Parameters 242 Packages for Functional Programming 243 The operator Module 243 Freezing Arguments with functools.partial 247 Chapter Summary 249 Further Reading 250\n\n8. Type Hints in Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253 What’s New in This Chapter 254 About Gradual Typing 254 Gradual Typing in Practice 255 Starting with Mypy 256 Making Mypy More Strict 257 A Default Parameter Value 258 Using None as a Default 260 Types Are Defined by Supported Operations 260 Types Usable in Annotations 266 The Any Type 266 Simple Types and Classes 269 Optional and Union Types 270 Generic Collections 271 Tuple Types 274 Generic Mappings 276 Abstract Base Classes 278 Iterable 280 Parameterized Generics and TypeVar 282 Static Protocols 286\n\nTable of Contents\n\n|\n\nix\n\nCallable 291 NoReturn 294 Annotating Positional Only and Variadic Parameters 295 Imperfect Typing and Strong Testing 296 Chapter Summary 297 Further Reading 298\n\n9. Decorators and Closures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303 What’s New in This Chapter 304 Decorators 101 304 When Python Executes Decorators 306 Registration Decorators 308 Variable Scope Rules 308 Closures 311 The nonlocal Declaration 315 Variable Lookup Logic 316 Implementing a Simple Decorator 317 How It Works 318 Decorators in the Standard Library 320 Memoization with functools.cache 320 Using lru_cache 323 Single Dispatch Generic Functions 324 Parameterized Decorators 329 A Parameterized Registration Decorator 329 The Parameterized Clock Decorator 332 A Class-Based Clock Decorator 335 Chapter Summary 336 Further Reading 336\n\n10. Design Patterns with First-Class Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341 What’s New in This Chapter 342 Case Study: Refactoring Strategy 342 Classic Strategy 342 Function-Oriented Strategy 347 Choosing the Best Strategy: Simple Approach 350 Finding Strategies in a Module 351 Decorator-Enhanced Strategy Pattern 353 The Command Pattern 355 Chapter Summary 357 Further Reading 358\n\nx\n\n|\n\nTable of Contents\n\nPart III.\n\nClasses and Protocols\n\n11. A Pythonic Object. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 363 What’s New in This Chapter 364 Object Representations 364 Vector Class Redux 365 An Alternative Constructor 368 classmethod Versus staticmethod 369 Formatted Displays 370 A Hashable Vector2d 374 Supporting Positional Pattern Matching 377 Complete Listing of Vector2d, Version 3 378 Private and “Protected” Attributes in Python 382 Saving Memory with __slots__ 384 Simple Measure of __slot__ Savings 387 Summarizing the Issues with __slots__ 388 Overriding Class Attributes 389 Chapter Summary 391 Further Reading 392\n\n12. Special Methods for Sequences. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397 What’s New in This Chapter 398 Vector: A User-Defined Sequence Type 398 Vector Take #1: Vector2d Compatible 399 Protocols and Duck Typing 402 Vector Take #2: A Sliceable Sequence 403 How Slicing Works 404 A Slice-Aware __getitem__ 406 Vector Take #3: Dynamic Attribute Access 407 Vector Take #4: Hashing and a Faster == 411 Vector Take #5: Formatting 418 Chapter Summary 425 Further Reading 426 Interfaces, Protocols, and ABCs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 431 The Typing Map 432 What’s New in This Chapter 433 Two Kinds of Protocols 434 Programming Ducks 435 Python Digs Sequences 436 Monkey Patching: Implementing a Protocol at Runtime 438 Defensive Programming and “Fail Fast” 440\n\nTable of Contents\n\n|\n\nxi\n\n14.\n\nxii\n\n|\n\nGoose Typing 442 Subclassing an ABC 447 ABCs in the Standard Library 449 Defining and Using an ABC 451 ABC Syntax Details 457 Subclassing an ABC 458 A Virtual Subclass of an ABC 460 Usage of register in Practice 463 Structural Typing with ABCs 464 Static Protocols 466 The Typed double Function 466 Runtime Checkable Static Protocols 468 Limitations of Runtime Protocol Checks 471 Supporting a Static Protocol 472 Designing a Static Protocol 474 Best Practices for Protocol Design 476 Extending a Protocol 477 The numbers ABCs and Numeric Protocols 478 Chapter Summary 481 Further Reading 482\n\nInheritance: For Better or for Worse. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487 What’s New in This Chapter 488 The super() Function 488 Subclassing Built-In Types Is Tricky 490 Multiple Inheritance and Method Resolution Order 494 Mixin Classes 500 Case-Insensitive Mappings 500 Multiple Inheritance in the Real World 502 ABCs Are Mixins Too 502 ThreadingMixIn and ForkingMixIn 503 Django Generic Views Mixins 504 Multiple Inheritance in Tkinter 507 Coping with Inheritance 510 Favor Object Composition over Class Inheritance 510 Understand Why Inheritance Is Used in Each Case 510 Make Interfaces Explicit with ABCs 511 Use Explicit Mixins for Code Reuse 511 Provide Aggregate Classes to Users 511 Subclass Only Classes Designed for Subclassing 512 Avoid Subclassing from Concrete Classes 513 Tkinter: The Good, the Bad, and the Ugly 513\n\nTable of Contents\n\nChapter Summary 514 Further Reading 515\n\n15. More About Type Hints. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 519 What’s New in This Chapter 519 Overloaded Signatures 520 Max Overload 521 Takeaways from Overloading max 525 TypedDict 526 Type Casting 534 Reading Type Hints at Runtime 537 Problems with Annotations at Runtime 538 Dealing with the Problem 540 Implementing a Generic Class 541 Basic Jargon for Generic Types 544 Variance 544 An Invariant Dispenser 545 A Covariant Dispenser 546 A Contravariant Trash Can 547 Variance Review 549 Implementing a Generic Static Protocol 552 Chapter Summary 554 Further Reading 555\n\n16. Operator Overloading. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 561 What’s New in This Chapter 562 Operator Overloading 101 562 Unary Operators 563 Overloading + for Vector Addition 566 Overloading * for Scalar Multiplication 572 Using @ as an Infix Operator 574 Wrapping-Up Arithmetic Operators 576 Rich Comparison Operators 577 Augmented Assignment Operators 580 Chapter Summary 585 Further Reading 587 Control Flow\n\n16. Operator Overloading. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 561 What’s New in This Chapter 562 Operator Overloading 101 562 Unary Operators 563 Overloading + for Vector Addition 566 Overloading * for Scalar Multiplication 572 Using @ as an Infix Operator 574 Wrapping-Up Arithmetic Operators 576 Rich Comparison Operators 577 Augmented Assignment Operators 580 Chapter Summary 585 Further Reading 587 Control Flow\n\n17.\n\nIterators, Generators, and Classic Coroutines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593 What’s New in This Chapter 594\n\nTable of Contents\n\n|\n\nxiii\n\nA Sequence of Words 594 Why Sequences Are Iterable: The iter Function 596 Using iter with a Callable 598 Iterables Versus Iterators 599 Sentence Classes with __iter__ 603 Sentence Take #2: A Classic Iterator 603 Don’t Make the Iterable an Iterator for Itself 605 Sentence Take #3: A Generator Function 606 How a Generator Works 607 Lazy Sentences 610 Sentence Take #4: Lazy Generator 610 Sentence Take #5: Lazy Generator Expression 611 When to Use Generator Expressions 613 An Arithmetic Progression Generator 615 Arithmetic Progression with itertools 618 Generator Functions in the Standard Library 619 Iterable Reducing Functions 630 Subgenerators with yield from 632 Reinventing chain 633 Traversing a Tree 634 Generic Iterable Types 639 Classic Coroutines 641 Example: Coroutine to Compute a Running Average 643 Returning a Value from a Coroutine 646 Generic Type Hints for Classic Coroutines 650 Chapter Summary 652 Further Reading 652\n\n18. with, match, and else Blocks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 657 What’s New in This Chapter 658 Context Managers and with Blocks 658 The contextlib Utilities 663 Using @contextmanager 664 Pattern Matching in lis.py: A Case Study 669 Scheme Syntax 669 Imports and Types 671 The Parser 671 The Environment 673 The REPL 675 The Evaluator 676 Procedure: A Class Implementing a Closure 685 Using OR-patterns 686 Table of Contents\n\n18. with, match, and else Blocks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 657 What’s New in This Chapter 658 Context Managers and with Blocks 658 The contextlib Utilities 663 Using @contextmanager 664 Pattern Matching in lis.py: A Case Study 669 Scheme Syntax 669 Imports and Types 671 The Parser 671 The Environment 673 The REPL 675 The Evaluator 676 Procedure: A Class Implementing a Closure 685 Using OR-patterns 686 Table of Contents\n\nDo This, Then That: else Blocks Beyond if 687 Chapter Summary 689 Further Reading 690\n\n19. Concurrency Models in Python. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 695 What’s New in This Chapter 696 The Big Picture 696 A Bit of Jargon 697 Processes, Threads, and Python’s Infamous GIL 699 A Concurrent Hello World 701 Spinner with Threads 701 Spinner with Processes 704 Spinner with Coroutines 706 Supervisors Side-by-Side 711 The Real Impact of the GIL 713 Quick Quiz 713 A Homegrown Process Pool 716 Process-Based Solution 718 Understanding the Elapsed Times 718 Code for the Multicore Prime Checker 719 Experimenting with More or Fewer Processes 723 Thread-Based Nonsolution 724 Python in the Multicore World 725 System Administration 726 Data Science 727 Server-Side Web/Mobile Development 728 WSGI Application Servers 730 Distributed Task Queues 732 Chapter Summary 733 Further Reading 734 Concurrency with Threads and Processes 734 The GIL 736 Concurrency Beyond the Standard Library 736 Concurrency and Scalability Beyond Python 738\n\n20. Concurrent Executors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 743 What’s New in This Chapter 743 Concurrent Web Downloads 744 A Sequential Download Script 746 Downloading with concurrent.futures 749 Where Are the Futures? 751 Launching Processes with concurrent.futures 754\n\nTable of Contents\n\n|\n\nxv\n\nMulticore Prime Checker Redux 755 Experimenting with Executor.map 758 Downloads with Progress Display and Error Handling 762 Error Handling in the flags2 Examples 766 Using futures.as_completed 769 Chapter Summary 772 Further Reading 772\n\n21. Asynchronous Programming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 775 What’s New in This Chapter 776 A Few Definitions 777 An asyncio Example: Probing Domains 778 Guido’s Trick to Read Asynchronous Code 780 New Concept: Awaitable 781 Downloading with asyncio and HTTPX 782 The Secret of Native Coroutines: Humble Generators 784 The All-or-Nothing Problem 785 Asynchronous Context Managers 786 Enhancing the asyncio Downloader 787 Using asyncio.as_completed and a Thread 788 Throttling Requests with a Semaphore 790 Making Multiple Requests for Each Download 794 Delegating Tasks to Executors 797 Writing asyncio Servers 799 A FastAPI Web Service 800 An asyncio TCP Server 804 Asynchronous Iteration and Asynchronous Iterables 811 Asynchronous Generator Functions 812 Async Comprehensions and Async Generator Expressions 818 async Beyond asyncio: Curio 821 Type Hinting Asynchronous Objects 824 How Async Works and How It Doesn’t 825 Running Circles Around Blocking Calls 825 The Myth of I/O-Bound Systems 826 Avoiding CPU-Bound Traps 826 Chapter Summary 827 Further Reading 828 Table of Contents\n\n21. Asynchronous Programming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 775 What’s New in This Chapter 776 A Few Definitions 777 An asyncio Example: Probing Domains 778 Guido’s Trick to Read Asynchronous Code 780 New Concept: Awaitable 781 Downloading with asyncio and HTTPX 782 The Secret of Native Coroutines: Humble Generators 784 The All-or-Nothing Problem 785 Asynchronous Context Managers 786 Enhancing the asyncio Downloader 787 Using asyncio.as_completed and a Thread 788 Throttling Requests with a Semaphore 790 Making Multiple Requests for Each Download 794 Delegating Tasks to Executors 797 Writing asyncio Servers 799 A FastAPI Web Service 800 An asyncio TCP Server 804 Asynchronous Iteration and Asynchronous Iterables 811 Asynchronous Generator Functions 812 Async Comprehensions and Async Generator Expressions 818 async Beyond asyncio: Curio 821 Type Hinting Asynchronous Objects 824 How Async Works and How It Doesn’t 825 Running Circles Around Blocking Calls 825 The Myth of I/O-Bound Systems 826 Avoiding CPU-Bound Traps 826 Chapter Summary 827 Further Reading 828 Table of Contents\n\nPart V. Metaprogramming\n\n22. Dynamic Attributes and Properties. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 835 What’s New in This Chapter 836 Data Wrangling with Dynamic Attributes 836 Exploring JSON-Like Data with Dynamic Attributes 838 The Invalid Attribute Name Problem 842 Flexible Object Creation with __new__ 843 Computed Properties 845 Step 1: Data-Driven Attribute Creation 846 Step 2: Property to Retrieve a Linked Record 848 Step 3: Property Overriding an Existing Attribute 852 Step 4: Bespoke Property Cache 853 Step 5: Caching Properties with functools 855 Using a Property for Attribute Validation 857 LineItem Take #1: Class for an Item in an Order 857 LineItem Take #2: A Validating Property 858 A Proper Look at Properties 860 Properties Override Instance Attributes 861 Property Documentation 864 Coding a Property Factory 865 Handling Attribute Deletion 868 Essential Attributes and Functions for Attribute Handling 869 Special Attributes that Affect Attribute Handling 870 Built-In Functions for Attribute Handling 870 Special Methods for Attribute Handling 871 Chapter Summary 873 Further Reading 873\n\n23. Attribute Descriptors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 879 What’s New in This Chapter 880 Descriptor Example: Attribute Validation 880 LineItem Take #3: A Simple Descriptor 880 LineItem Take #4: Automatic Naming of Storage Attributes 887 LineItem Take #5: A New Descriptor Type 889 Overriding Versus Nonoverriding Descriptors 892 Overriding Descriptors 894 Overriding Descriptor Without __get__ 895 Nonoverriding Descriptor 896 Overwriting a Descriptor in the Class 897 Methods Are Descriptors 898 Descriptor Usage Tips 900\n\nTable of Contents\n\n|\n\nxvii\n\nDescriptor Docstring and Overriding Deletion 902 Chapter Summary 903 Further Reading 904\n\n24. Class Metaprogramming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 907 What’s New in This Chapter 908 Classes as Objects 908 type: The Built-In Class Factory 909 A Class Factory Function 911 Introducing __init_subclass__ 914 Why __init_subclass__ Cannot Configure __slots__ 921 Enhancing Classes with a Class Decorator 922 What Happens When: Import Time Versus Runtime 925 Evaluation Time Experiments 926 Metaclasses 101 931 How a Metaclass Customizes a Class 933 A Nice Metaclass Example 934 Metaclass Evaluation Time Experiment 937 A Metaclass Solution for Checked 942 Metaclasses in the Real World 947 Modern Features Simplify or Replace Metaclasses 947 Metaclasses Are Stable Language Features 948 A Class Can Only Have One Metaclass 948 Metaclasses Should Be Implementation Details 949 A Metaclass Hack with __prepare__ 950 Wrapping Up 952 Chapter Summary 953 Further Reading 954\n\nAfterword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 959\n\nIndex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 963\n\nxviii\n\n|\n\nTable of Contents\n\nPreface\n\nHere’s the plan: when someone uses a feature you don’t understand, simply shoot them. This is easier than learning something new, and before too long the only living coders will be writing in an easily understood, tiny subset of Python 0.9.6 <wink>.1\n\n—Tim Peters, legendary core developer and author of The Zen of Python\n\n“Python is an easy to learn, powerful programming language.” Those are the first words of the official Python 3.10 tutorial. That is true, but there is a catch: because the language is easy to learn and put to use, many practicing Python programmers leverage only a fraction of its powerful features.\n\nAn experienced programmer may start writing useful Python code in a matter of hours. As the first productive hours become weeks and months, a lot of developers go on writing Python code with a very strong accent carried from languages learned before. Even if Python is your first language, often in academia and in introductory books it is presented while carefully avoiding language-specific features.\n\nAs a teacher introducing Python to programmers experienced in other languages, I see another problem that this book tries to address: we only miss stuff we know about. Coming from another language, anyone may guess that Python supports regu‐ lar expressions, and look that up in the docs. But if you’ve never seen tuple unpacking or descriptors before, you will probably not search for them, and you may end up not using those features just because they are specific to Python.\n\nThis book is not an A-to-Z exhaustive reference of Python. Its emphasis is on the lan‐ guage features that are either unique to Python or not found in many other popular languages. This is also mostly a book about the core language and some of its libra‐ ries. I will rarely talk about packages that are not in the standard library, even though the Python package index now lists more than 60,000 libraries, and many of them are incredibly useful.\n\n1 Message to the comp.lang.python Usenet group, Dec. 23, 2002: “Acrimony in c.l.p”.\n\nxix\n\nWho This Book Is For This book was written for practicing Python programmers who want to become pro‐ ficient in Python 3. I tested the examples in Python 3.10—most of them also in Python 3.9 and 3.8. When an example requires Python 3.10, it should be clearly marked.\n\nIf you are not sure whether you know enough Python to follow along, review the top‐ ics of the official Python tutorial. Topics covered in the tutorial will not be explained here, except for some features that are new.\n\nWho This Book Is Not For If you are just learning Python, this book is going to be hard to follow. Not only that, if you read it too early in your Python journey, it may give you the impression that every Python script should leverage special methods and metaprogramming tricks. Premature abstraction is as bad as premature optimization.\n\nFive Books in One I recommend that everyone read Chapter 1, “The Python Data Model”. The core audience for this book should not have trouble jumping directly to any part in this book after Chapter 1, but often I assume you’ve read preceding chapters in each spe‐ cific part. Think of Parts I through V as books within the book.\n\nI tried to emphasize using what is available before discussing how to build your own. For example, in Part I, Chapter 2 covers sequence types that are ready to use, includ‐ ing some that don’t get a lot of attention, like collections.deque. Building user- defined sequences is only addressed in Part III, where we also see how to leverage the abstract base classes (ABCs) from collections.abc. Creating your own ABCs is dis‐ cussed even later in Part III, because I believe it’s important to be comfortable using an ABC before writing your own.\n\nThis approach has a few advantages. First, knowing what is ready to use can save you from reinventing the wheel. We use existing collection classes more often than we implement our own, and we can give more attention to the advanced usage of avail‐ able tools by deferring the discussion on how to create new ones. We are also more likely to inherit from existing ABCs than to create a new ABC from scratch. And finally, I believe it is easier to understand the abstractions after you’ve seen them in action.\n\nThe downside of this strategy is the forward references scattered throughout the chapters. I hope these will be easier to tolerate now that you know why I chose this path.\n\nxx\n\n| Preface\n\nHow the Book Is Organized Here are the main topics in each part of the book:\n\nPart I, “Data Structures”\n\nChapter 1 introduces the Python Data Model and explains why the special meth‐ ods (e.g., __repr__) are the key to the consistent behavior of objects of all types. Special methods are covered in more detail throughout the book. The remaining chapters in this part cover the use of collection types: sequences, mappings, and sets, as well as the str versus bytes split—the cause of much celebration among Python 3 users and much pain for Python 2 users migrating their codebases. Also covered are the high-level class builders in the standard library: named tuple fac‐ tories and the @dataclass decorator. Pattern matching—new in Python 3.10—is covered in sections in Chapters 2, 3, and 5, which discuss sequence patterns, mapping patterns, and class patterns. The last chapter in Part I is about the life cycle of objects: references, mutability, and garbage collection.\n\nPart II, “Functions as Objects”\n\nHere we talk about functions as first-class objects in the language: what that means, how it affects some popular design patterns, and how to implement func‐ tion decorators by leveraging closures. Also covered here is the general concept of callables in Python, function attributes, introspection, parameter annotations, and the new nonlocal declaration in Python 3. Chapter 8 introduces the major new topic of type hints in function signatures.\n\nPart III, “Classes and Protocols”\n\nNow the focus is on building classes “by hand”—as opposed to using the class builders covered in Chapter 5. Like any Object-Oriented (OO) language, Python has its particular set of features that may or may not be present in the language in which you and I learned class-based programming. The chapters explain how to build your own collections, abstract base classes (ABCs), and protocols, as well as how to cope with multiple inheritance, and how to implement operator overloading—when that makes sense. Chapter 15 continues the coverage of type hints.\n\nPart IV, “Control Flow”\n\nCovered in this part are the language constructs and libraries that go beyond tra‐ ditional control flow with conditionals, loops, and subroutines. We start with generators, then visit context managers and coroutines, including the challenging but powerful new yield from syntax. Chapter 18 includes a significant example using pattern matching in a simple but functional language interpreter. Chap‐ ter 19, “Concurrency Models in Python” is a new chapter presenting an overview of alternatives for concurrent and parallel processing in Python, their limitations, and how software architecture allows Python to operate at web scale. I rewrote\n\nPreface\n\n|\n\nxxi",
      "page_number": 1
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 22-40)",
      "start_page": 22,
      "end_page": 40,
      "detection_method": "synthetic",
      "content": "the chapter about asynchronous programming to emphasize core language fea‐ tures—e.g., await, async dev, async for, and async with, and show how they are used with asyncio and other frameworks.\n\nPart V, “Metaprogramming”\n\nThis part starts with a review of techniques for building classes with attributes created dynamically to handle semi-structured data, such as JSON datasets. Next, we cover the familiar properties mechanism, before diving into how object attribute access works at a lower level in Python using descriptors. The relation‐ ship among functions, methods, and descriptors is explained. Throughout Part V, the step-by-step implementation of a field validation library uncovers subtle issues that lead to the advanced tools of the final chapter: class decorators and metaclasses.\n\nHands-On Approach Often we’ll use the interactive Python console to explore the language and libraries. I feel it is important to emphasize the power of this learning tool, particularly for those readers who’ve had more experience with static, compiled languages that don’t pro‐ vide a read-eval-print loop (REPL).\n\nOne of the standard Python testing packages, doctest, works by simulating console sessions and verifying that the expressions evaluate to the responses shown. I used doctest to check most of the code in this book, including the console listings. You don’t need to use or even know about doctest to follow along: the key feature of doctests is that they look like transcripts of interactive Python console sessions, so you can easily try out the demonstrations yourself.\n\nSometimes I will explain what we want to accomplish by showing a doctest before the code that makes it pass. Firmly establishing what is to be done before thinking about how to do it helps focus our coding effort. Writing tests first is the basis of test-driven development (TDD), and I’ve also found it helpful when teaching. If you are unfami‐ liar with doctest, take a look at its documentation and this book’s example code repository.\n\nI also wrote unit tests for some of the larger examples using pytest—which I find eas‐ ier to use and more powerful than the unittest module in the standard library. You’ll find that you can verify the correctness of most of the code in the book by typing python3 -m doctest example_script.py or pytest in the command shell of your OS. The pytest.ini configuration at the root of the example code repository ensures that doctests are collected and executed by the pytest command.\n\nxxii\n\n| Preface\n\nSoapbox: My Personal Perspective I have been using, teaching, and debating Python since 1998, and I enjoy studying and comparing programming languages, their design, and the theory behind them. At the end of some chapters, I have added “Soapbox” sidebars with my own perspec‐ tive about Python and other languages. Feel free to skip these if you are not into such discussions. Their content is completely optional.\n\nCompanion Website: fluentpython.com Covering new features—like type hints, data classes, and pattern matching—made this second edition almost 30% larger than the first. To keep the book luggable, I moved some content to fluentpython.com. You will find links to articles I published there in several chapters. Some sample chapters are also in the companion website. The full text is available online at the O’Reilly Learning subscription service. The example code repository is on GitHub.\n\nConventions Used in This Book The following typographical conventions are used in this book:\n\nItalic\n\nIndicates new terms, URLs, email addresses, filenames, and file extensions.\n\nConstant width\n\nUsed for program listings, as well as within paragraphs to refer to program ele‐ ments such as variable or function names, databases, data types, environment variables, statements, and keywords.\n\nNote that when a line break falls within a constant_width term, a hyphen is not added—it could be misunderstood as part of the term.\n\nConstant width bold\n\nShows commands or other text that should be typed literally by the user.\n\nConstant width italic\n\nShows text that should be replaced with user-supplied values or by values deter‐ mined by context.\n\nPreface\n\n|\n\nxxiii\n\nThis element signifies a tip or suggestion.\n\nThis element signifies a general note.\n\nThis element indicates a warning or caution.\n\nUsing Code Examples Every script and most code snippets that appear in the book are available in the Flu‐ ent Python code repository on GitHub at https://fpy.li/code.\n\nIf you have a technical question or a problem using the code examples, please send email to bookquestions@oreilly.com.\n\nThis book is here to help you get your job done. In general, if example code is offered with this book, you may use it in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing examples from O’Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product’s documentation does require permission.\n\nWe appreciate, but generally do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN, e.g., “Fluent Python, 2nd ed., by Luciano Ramalho (O’Reilly). Copyright 2022 Luciano Ramalho, 978-1-492-05635-5.”\n\nIf you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at permissions@oreilly.com.\n\nxxiv\n\n| Preface\n\nO’Reilly Online Learning\n\nFor more than 40 years, O’Reilly Media has provided technol‐ ogy and business training, knowledge, and insight to help companies succeed.\n\nOur unique network of experts and innovators share their knowledge and expertise through books, articles, and our online learning platform. O’Reilly’s online learning platform gives you on-demand access to live training courses, in-depth learning paths, interactive coding environments, and a vast collection of text and video from O’Reilly and 200+ other publishers. For more information, visit http://oreilly.com.\n\nHow to Contact Us Please address comments and questions concerning this book to the publisher:\n\nO’Reilly Media, Inc. 1005 Gravenstein Highway North Sebastopol, CA 95472 800-998-9938 (in the United States or Canada) 707-829-0515 (international or local) 707-829-0104 (fax)\n\nWe have a web page for this book, where we list errata, examples, and any additional information. You can access this page at https://fpy.li/p-4.\n\nEmail bookquestions@oreilly.com to comment or ask technical questions about this book.\n\nFor news and information about our books and courses, visit http://oreilly.com.\n\nFind us on Facebook: http://facebook.com/oreilly.\n\nFollow us on Twitter: https://twitter.com/oreillymedia.\n\nWatch us on YouTube: http://www.youtube.com/oreillymedia.\n\nAcknowledgments I did not expect updating a Python book five years later to be such a major undertak‐ ing, but it was. Marta Mello, my beloved wife, was always there when I needed her. My dear friend Leonardo Rochael helped me from the earliest writing to the final technical review, including consolidating and double-checking the feedback from the other tech reviewers, readers, and editors. I honestly don’t know if I’d have made it without your support, Marta and Leo. Thank you so much!\n\nPreface\n\n|\n\nxxv\n\nJürgen Gmach, Caleb Hattingh, Jess Males, Leonardo Rochael, and Miroslav Šedivý were the outstanding technical review team for the second edition. They reviewed the whole book. Bill Behrman, Bruce Eckel, Renato Oliveira, and Rodrigo Bernardo Pimentel reviewed specific chapters. Their many suggestions from different perspec‐ tives made the book much better.\n\nMany readers sent corrections or made other contributions during the early release phase, including: Guilherme Alves, Christiano Anderson, Konstantin Baikov, K. Alex Birch, Michael Boesl, Lucas Brunialti, Sergio Cortez, Gino Crecco, Chukwuerika Dike, Juan Esteras, Federico Fissore, Will Frey, Tim Gates, Alexander Hagerman, Chen Hanxiao, Sam Hyeong, Simon Ilincev, Parag Kalra, Tim King, David Kwast, Tina Lapine, Wanpeng Li, Guto Maia, Scott Martindale, Mark Meyer, Andy McFar‐ land, Chad McIntire, Diego Rabatone Oliveira, Francesco Piccoli, Meredith Rawls, Michael Robinson, Federico Tula Rovaletti, Tushar Sadhwani, Arthur Constantino Scardua, Randal L. Schwartz, Avichai Sefati, Guannan Shen, William Simpson, Vivek Vashist, Jerry Zhang, Paul Zuradzki—and others who did not want to be named, sent corrections after I delivered the draft, or are omitted because I failed to record their names—sorry.\n\nDuring my research, I learned about typing, concurrency, pattern matching, and metaprogramming while interacting with Michael Albert, Pablo Aguilar, Kaleb Bar‐ rett, David Beazley, J. S. O. Bueno, Bruce Eckel, Martin Fowler, Ivan Levkivskyi, Alex Martelli, Peter Norvig, Sebastian Rittau, Guido van Rossum, Carol Willing, and Jelle Zijlstra.\n\nO’Reilly editors Jeff Bleiel, Jill Leonard, and Amelia Blevins made suggestions that improved the flow of the book in many places. Jeff Bleiel and production editor Danny Elfanbaum supported me throughout this long marathon.\n\nThe insights and suggestions of every one of them made the book better and more accurate. Inevitably, there will still be bugs of my own creation in the final product. I apologize in advance.\n\nFinally, I want to extend my heartfelt thanks to my colleagues at Thoughtworks Brazil —and especially to my sponsor, Alexey Bôas—who supported this project in many ways, all the way.\n\nOf course, everyone who helped me understand Python and write the first edition now deserves double thanks. There would be no second edition without a successful first.\n\nxxvi\n\n| Preface\n\nAcknowledgments for the First Edition The Bauhaus chess set by Josef Hartwig is an example of excellent design: beautiful, simple, and clear. Guido van Rossum, son of an architect and brother of a master font designer, created a masterpiece of language design. I love teaching Python because it is beautiful, simple, and clear.\n\nAlex Martelli and Anna Ravenscroft were the first people to see the outline of this book and encouraged me to submit it to O’Reilly for publication. Their books taught me idiomatic Python and are models of clarity, accuracy, and depth in technical writ‐ ing. Alex’s 6,200+ Stack Overflow posts are a fountain of insights about the language and its proper use.\n\nMartelli and Ravenscroft were also technical reviewers of this book, along with Len‐ nart Regebro and Leonardo Rochael. Everyone in this outstanding technical review team has at least 15 years of Python experience, with many contributions to high- impact Python projects in close contact with other developers in the community. Together they sent me hundreds of corrections, suggestions, questions, and opinions, adding tremendous value to the book. Victor Stinner kindly reviewed Chapter 21, bringing his expertise as an asyncio maintainer to the technical review team. It was a great privilege and a pleasure to collaborate with them over these past several months.\n\nEditor Meghan Blanchette was an outstanding mentor, helping me improve the orga‐ nization and flow of the book, letting me know when it was boring, and keeping me from delaying even more. Brian MacDonald edited chapters in Part II while Meghan was away. I enjoyed working with them, and with everyone I’ve contacted at O’Reilly, including the Atlas development and support team (Atlas is the O’Reilly book pub‐ lishing platform, which I was fortunate to use to write this book).\n\nMario Domenech Goulart provided numerous, detailed suggestions starting with the first early release. I also received valuable feedback from Dave Pawson, Elias Dor‐ neles, Leonardo Alexandre Ferreira Leite, Bruce Eckel, J. S. Bueno, Rafael Gonçalves, Alex Chiaranda, Guto Maia, Lucas Vido, and Lucas Brunialti.\n\nOver the years, a number of people urged me to become an author, but the most per‐ suasive were Rubens Prates, Aurelio Jargas, Rudá Moura, and Rubens Altimari. Mauricio Bussab opened many doors for me, including my first real shot at writing a book. Renzo Nuccitelli supported this writing project all the way, even if that meant a slow start for our partnership at python.pro.br.\n\nThe wonderful Brazilian Python community is knowledgeable, generous, and fun. The Python Brasil group has thousands of people, and our national conferences bring together hundreds, but the most influential in my journey as a Pythonista were Leo‐ nardo Rochael, Adriano Petrich, Daniel Vainsencher, Rodrigo RBP Pimentel, Bruno Gola, Leonardo Santagada, Jean Ferri, Rodrigo Senra, J. S. Bueno, David Kwast, Luiz\n\nPreface\n\n|\n\nxxvii\n\nIrber, Osvaldo Santana, Fernando Masanori, Henrique Bastos, Gustavo Niemayer, Pedro Werneck, Gustavo Barbieri, Lalo Martins, Danilo Bellini, and Pedro Kroger.\n\nDorneles Tremea was a great friend (incredibly generous with his time and knowl‐ edge), an amazing hacker, and the most inspiring leader of the Brazilian Python Association. He left us too early.\n\nMy students over the years taught me a lot through their questions, insights, feed‐ back, and creative solutions to problems. Érico Andrei and Simples Consultoria made it possible for me to focus on being a Python teacher for the first time.\n\nMartijn Faassen was my Grok mentor and shared invaluable insights with me about Python and Neanderthals. His work and that of Paul Everitt, Chris McDonough, Tres Seaver, Jim Fulton, Shane Hathaway, Lennart Regebro, Alan Runyan, Alexander Limi, Martijn Pieters, Godefroid Chapelle, and others from the Zope, Plone, and Pyr‐ amid planets have been decisive in my career. Thanks to Zope and surfing the first web wave, I was able to start making a living with Python in 1998. José Octavio Cas‐ tro Neves was my partner in the first Python-centric software house in Brazil.\n\nI have too many gurus in the wider Python community to list them all, but besides those already mentioned, I am indebted to Steve Holden, Raymond Hettinger, A.M. Kuchling, David Beazley, Fredrik Lundh, Doug Hellmann, Nick Coghlan, Mark Pil‐ grim, Martijn Pieters, Bruce Eckel, Michele Simionato, Wesley Chun, Brandon Craig Rhodes, Philip Guo, Daniel Greenfeld, Audrey Roy, and Brett Slatkin for teaching me new and better ways to teach Python.\n\nMost of these pages were written in my home office and in two labs: CoffeeLab and Garoa Hacker Clube. CoffeeLab is the caffeine-geek headquarters in Vila Madalena, São Paulo, Brazil. Garoa Hacker Clube is a hackerspace open to all: a community lab where anyone can freely try out new ideas.\n\nThe Garoa community provided inspiration, infrastructure, and slack. I think Aleph would enjoy this book.\n\nMy mother, Maria Lucia, and my father, Jairo, always supported me in every way. I wish he was here to see the book; I am glad I can share it with her.\n\nMy wife, Marta Mello, endured 15 months of a husband who was always working, but remained supportive and coached me through some critical moments in the project when I feared I might drop out of the marathon.\n\nThank you all, for everything.\n\nxxviii\n\n| Preface\n\nPART I Data Structures\n\nCHAPTER 1 The Python Data Model\n\nGuido’s sense of the aesthetics of language design is amazing. I’ve met many fine lan‐ guage designers who could build theoretically beautiful languages that no one would ever use, but Guido is one of those rare people who can build a language that is just slightly less theoretically beautiful but thereby is a joy to write programs in.\n\n—Jim Hugunin, creator of Jython, cocreator of AspectJ, and architect of the .Net DLR1\n\nOne of the best qualities of Python is its consistency. After working with Python for a while, you are able to start making informed, correct guesses about features that are new to you.\n\nHowever, if you learned another object-oriented language before Python, you may find it strange to use len(collection) instead of collection.len(). This apparent oddity is the tip of an iceberg that, when properly understood, is the key to every‐ thing we call Pythonic. The iceberg is called the Python Data Model, and it is the API that we use to make our own objects play well with the most idiomatic language features.\n\nYou can think of the data model as a description of Python as a framework. It formal‐ izes the interfaces of the building blocks of the language itself, such as sequences, functions, iterators, coroutines, classes, context managers, and so on.\n\nWhen using a framework, we spend a lot of time coding methods that are called by the framework. The same happens when we leverage the Python Data Model to build new classes. The Python interpreter invokes special methods to perform basic object operations, often triggered by special syntax. The special method names are always written with leading and trailing double underscores. For example, the syntax\n\n1 “Story of Jython”, written as a foreword to Jython Essentials by Samuele Pedroni and Noel Rappin (O’Reilly).\n\n3\n\nobj[key] is supported by the __getitem__ special method. In order to evaluate my_collection[key], the interpreter calls my_collection.__getitem__(key).\n\nWe implement special methods when we want our objects to support and interact with fundamental language constructs such as:\n\nCollections\n\nAttribute access • Iteration (including asynchronous iteration using async for)\n\nOperator overloading\n\nFunction and method invocation\n\nString representation and formatting • Asynchronous programming using await\n\nObject creation and destruction • Managed contexts using the with or async with statements\n\nMagic and Dunder\n\nThe term magic method is slang for special method, but how do we talk about a specific method like __getitem__? I learned to say “dunder-getitem” from author and teacher Steve Holden. “Dun‐ der” is a shortcut for “double underscore before and after.” That’s why the special methods are also known as dunder methods. The “Lexical Analysis” chapter of The Python Language Reference warns that “Any use of __*__ names, in any context, that does not follow explicitly documented use, is subject to breakage without warning.”\n\nWhat’s New in This Chapter This chapter had few changes from the first edition because it is an introduction to the Python Data Model, which is quite stable. The most significant changes are:\n\nSpecial methods supporting asynchronous programming and other new features, added to the tables in “Overview of Special Methods” on page 15.\n\nFigure 1-2 showing the use of special methods in “Collection API” on page 14, including the collections.abc.Collection abstract base class introduced in Python 3.6.\n\n4\n\n|\n\nChapter 1: The Python Data Model\n\nAlso, here and throughout this second edition I adopted the f-string syntax intro‐ duced in Python 3.6, which is more readable and often more convenient than the older string formatting notations: the str.format() method and the % operator.\n\nOne reason to still use my_fmt.format() is when the definition of my_fmt must be in a different place in the code than where the for‐ matting operation needs to happen. For instance, when my_fmt has multiple lines and is better defined in a constant, or when it must come from a configuration file, or from the database. Those are real needs, but don’t happen very often.\n\nA Pythonic Card Deck Example 1-1 is simple, but it demonstrates the power of implementing just two spe‐ cial methods, __getitem__ and __len__.\n\nExample 1-1. A deck as a sequence of playing cards\n\nimport collections\n\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n\nclass FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split()\n\ndef __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\ndef __len__(self): return len(self._cards)\n\ndef __getitem__(self, position): return self._cards[position]\n\nThe first thing to note is the use of collections.namedtuple to construct a simple class to represent individual cards. We use namedtuple to build classes of objects that are just bundles of attributes with no custom methods, like a database record. In the example, we use it to provide a nice representation for the cards in the deck, as shown in the console session:\n\n>>> beer_card = Card('7', 'diamonds') >>> beer_card Card(rank='7', suit='diamonds')\n\nA Pythonic Card Deck\n\n|\n\n5\n\nBut the point of this example is the FrenchDeck class. It’s short, but it packs a punch. First, like any standard Python collection, a deck responds to the len() function by returning the number of cards in it:\n\n>>> deck = FrenchDeck() >>> len(deck) 52\n\nReading specific cards from the deck—say, the first or the last—is easy, thanks to the __getitem__ method:\n\n>>> deck[0] Card(rank='2', suit='spades') >>> deck[-1] Card(rank='A', suit='hearts')\n\nShould we create a method to pick a random card? No need. Python already has a function to get a random item from a sequence: random.choice. We can use it on a deck instance:\n\n>>> from random import choice >>> choice(deck) Card(rank='3', suit='hearts') >>> choice(deck) Card(rank='K', suit='spades') >>> choice(deck) Card(rank='2', suit='clubs')\n\nWe’ve just seen two advantages of using special methods to leverage the Python Data Model:\n\nUsers of your classes don’t have to memorize arbitrary method names for stan‐ dard operations. (“How to get the number of items? Is it .size(), .length(), or what?”)\n\nIt’s easier to benefit from the rich Python standard library and avoid reinventing the wheel, like the random.choice function.\n\nBut it gets better.\n\nBecause our __getitem__ delegates to the [] operator of self._cards, our deck automatically supports slicing. Here’s how we look at the top three cards from a brand-new deck, and then pick just the aces by starting at index 12 and skipping 13 cards at a time:\n\n>>> deck[:3] [Card(rank='2', suit='spades'), Card(rank='3', suit='spades'), Card(rank='4', suit='spades')] >>> deck[12::13] [Card(rank='A', suit='spades'), Card(rank='A', suit='diamonds'), Card(rank='A', suit='clubs'), Card(rank='A', suit='hearts')]\n\n6\n\n|\n\nChapter 1: The Python Data Model\n\nJust by implementing the __getitem__ special method, our deck is also iterable:\n\n>>> for card in deck: # doctest: +ELLIPSIS ... print(card) Card(rank='2', suit='spades') Card(rank='3', suit='spades') Card(rank='4', suit='spades') ...\n\nWe can also iterate over the deck in reverse:\n\n>>> for card in reversed(deck): # doctest: +ELLIPSIS ... print(card) Card(rank='A', suit='hearts') Card(rank='K', suit='hearts') Card(rank='Q', suit='hearts') ...\n\nEllipsis in doctests\n\nWhenever possible, I extracted the Python console listings in this book from doctest to ensure accuracy. When the output was too long, the elided part is marked by an ellipsis (...), like in the last line in the preceding code. In such cases, I used the # doctest: +ELLIPSIS directive to make the doctest pass. If you are trying these examples in the interactive console, you may omit the doctest comments altogether.\n\nIteration is often implicit. If a collection has no __contains__ method, the in opera‐ tor does a sequential scan. Case in point: in works with our FrenchDeck class because it is iterable. Check it out:\n\n>>> Card('Q', 'hearts') in deck True >>> Card('7', 'beasts') in deck False\n\nHow about sorting? A common system of ranking cards is by rank (with aces being highest), then by suit in the order of spades (highest), hearts, diamonds, and clubs (lowest). Here is a function that ranks cards by that rule, returning 0 for the 2 of clubs and 51 for the ace of spades:\n\nsuit_values = dict(spades=3, hearts=2, diamonds=1, clubs=0)\n\ndef spades_high(card): rank_value = FrenchDeck.ranks.index(card.rank) return rank_value * len(suit_values) + suit_values[card.suit]\n\nGiven spades_high, we can now list our deck in order of increasing rank:\n\nA Pythonic Card Deck\n\n|\n\n7\n\n>>> for card in sorted(deck, key=spades_high): # doctest: +ELLIPSIS ... print(card) Card(rank='2', suit='clubs') Card(rank='2', suit='diamonds') Card(rank='2', suit='hearts') ... (46 cards omitted) Card(rank='A', suit='diamonds') Card(rank='A', suit='hearts') Card(rank='A', suit='spades')\n\nAlthough FrenchDeck implicitly inherits from the object class, most of its function‐ ality is not inherited, but comes from leveraging the data model and composition. By implementing the special methods __len__ and __getitem__, our FrenchDeck behaves like a standard Python sequence, allowing it to benefit from core language features (e.g., iteration and slicing) and from the standard library, as shown by the examples using random.choice, reversed, and sorted. Thanks to composition, the __len__ and __getitem__ implementations can delegate all the work to a list object, self._cards.\n\nHow About Shuffling?\n\nAs implemented so far, a FrenchDeck cannot be shuffled because it is immutable: the cards and their positions cannot be changed, except by violating encapsulation and handling the _cards attribute directly. In Chapter 13, we will fix that by adding a one- line __setitem__ method.\n\nHow Special Methods Are Used The first thing to know about special methods is that they are meant to be called by the Python interpreter, and not by you. You don’t write my_object.__len__(). You write len(my_object) and, if my_object is an instance of a user-defined class, then Python calls the __len__ method you implemented.\n\nBut the interpreter takes a shortcut when dealing for built-in types like list, str, bytearray, or extensions like the NumPy arrays. Python variable-sized collections written in C include a struct2 called PyVarObject, which has an ob_size field holding the number of items in the collection. So, if my_object is an instance of one of those built-ins, then len(my_object) retrieves the value of the ob_size field, and this is much faster than calling a method.\n\n2 A C struct is a record type with named fields.\n\n8\n\n|\n\nChapter 1: The Python Data Model\n\nMore often than not, the special method call is implicit. For example, the statement for i in x: actually causes the invocation of iter(x), which in turn may call x.__iter__() if that is available, or use x.__getitem__(), as in the FrenchDeck example.\n\nNormally, your code should not have many direct calls to special methods. Unless you are doing a lot of metaprogramming, you should be implementing special meth‐ ods more often than invoking them explicitly. The only special method that is fre‐ quently called by user code directly is __init__ to invoke the initializer of the superclass in your own __init__ implementation.\n\nIf you need to invoke a special method, it is usually better to call the related built-in function (e.g., len, iter, str, etc.). These built-ins call the corresponding special method, but often provide other services and—for built-in types—are faster than method calls. See, for example, “Using iter with a Callable” on page 598 in Chapter 17.\n\nIn the next sections, we’ll see some of the most important uses of special methods:\n\nEmulating numeric types\n\nString representation of objects\n\nBoolean value of an object\n\nImplementing collections\n\nEmulating Numeric Types Several special methods allow user objects to respond to operators such as +. We will cover that in more detail in Chapter 16, but here our goal is to further illustrate the use of special methods through another simple example.\n\nWe will implement a class to represent two-dimensional vectors—that is, Euclidean vectors like those used in math and physics (see Figure 1-1).\n\nThe built-in complex type can be used to represent two- dimensional vectors, but our class can be extended to represent n- dimensional vectors. We will do that in Chapter 17.\n\nHow Special Methods Are Used\n\n|\n\n9\n\nFigure 1-1. Example of two-dimensional vector addition; Vector(2, 4) + Vector(2, 1) results in Vector(4, 5).\n\nWe will start designing the API for such a class by writing a simulated console session that we can use later as a doctest. The following snippet tests the vector addition pic‐ tured in Figure 1-1:\n\n>>> v1 = Vector(2, 4) >>> v2 = Vector(2, 1) >>> v1 + v2 Vector(4, 5)\n\nNote how the + operator results in a new Vector, displayed in a friendly format at the console.\n\nThe abs built-in function returns the absolute value of integers and floats, and the magnitude of complex numbers, so to be consistent, our API also uses abs to calcu‐ late the magnitude of a vector:\n\n>>> v = Vector(3, 4) >>> abs(v) 5.0\n\nWe can also implement the * operator to perform scalar multiplication (i.e., multi‐ plying a vector by a number to make a new vector with the same direction and a multiplied magnitude):\n\n>>> v * 3 Vector(9, 12) >>> abs(v * 3) 15.0\n\n10\n\n|\n\nChapter 1: The Python Data Model\n\nExample 1-2 is a Vector class implementing the operations just described, through the use of the special methods __repr__, __abs__, __add__, and __mul__.\n\nExample 1-2. A simple two-dimensional vector class\n\n\"\"\" vector2d.py: a simplistic class demonstrating some special methods\n\nIt is simplistic for didactic reasons. It lacks proper error handling, especially in the ``__add__`` and ``__mul__`` methods.\n\nThis example is greatly expanded later in the book.\n\nAddition::\n\n>>> v1 = Vector(2, 4) >>> v2 = Vector(2, 1) >>> v1 + v2 Vector(4, 5)\n\nAbsolute value::\n\n>>> v = Vector(3, 4) >>> abs(v) 5.0\n\nScalar multiplication::\n\n>>> v * 3 Vector(9, 12) >>> abs(v * 3) 15.0\n\n\"\"\"\n\nimport math\n\nclass Vector:\n\ndef __init__(self, x=0, y=0): self.x = x self.y = y\n\ndef __repr__(self): return f'Vector({self.x!r}, {self.y!r})'\n\ndef __abs__(self): return math.hypot(self.x, self.y)\n\ndef __bool__(self):\n\nHow Special Methods Are Used\n\n|\n\n11\n\nreturn bool(abs(self))\n\ndef __add__(self, other): x = self.x + other.x y = self.y + other.y return Vector(x, y)\n\ndef __mul__(self, scalar): return Vector(self.x * scalar, self.y * scalar)\n\nWe implemented five special methods in addition to the familiar __init__. Note that none of them is directly called within the class or in the typical usage of the class illustrated by the doctests. As mentioned before, the Python interpreter is the only frequent caller of most special methods.\n\nExample 1-2 implements two operators: + and *, to show basic usage of __add__ and __mul__. In both cases, the methods create and return a new instance of Vector, and do not modify either operand—self or other are merely read. This is the expected behavior of infix operators: to create new objects and not touch their operands. I will have a lot more to say about that in Chapter 16.\n\nAs implemented, Example 1-2 allows multiplying a Vector by a number, but not a number by a Vector, which violates the commu‐ tative property of scalar multiplication. We will fix that with the special method __rmul__ in Chapter 16.\n\nIn the following sections, we discuss the other special methods in Vector.\n\nString Representation The __repr__ special method is called by the repr built-in to get the string represen‐ tation of the object for inspection. Without a custom __repr__, Python’s console would display a Vector instance <Vector object at 0x10e100070>.\n\nThe interactive console and debugger call repr on the results of the expressions eval‐ uated, as does the %r placeholder in classic formatting with the % operator, and the !r conversion field in the new format string syntax used in f-strings the str.format method.\n\nNote that the f-string in our __repr__ uses !r to get the standard representation of the attributes to be displayed. This is good practice, because it shows the crucial dif‐ ference between Vector(1, 2) and Vector('1', '2')—the latter would not work in the context of this example, because the constructor’s arguments should be numbers, not str.\n\n12\n\n|\n\nChapter 1: The Python Data Model\n\nThe string returned by __repr__ should be unambiguous and, if possible, match the source code necessary to re-create the represented object. That is why our Vector representation looks like calling the constructor of the class (e.g., Vector(3, 4)).\n\nIn contrast, __str__ is called by the str() built-in and implicitly used by the print function. It should return a string suitable for display to end users.\n\nSometimes same string returned by __repr__ is user-friendly, and you don’t need to code __str__ because the implementation inherited from the object class calls __repr__ as a fallback. Example 5-2 is one of several examples in this book with a custom __str__.\n\nProgrammers with prior experience in languages with a toString method tend to implement __str__ and not __repr__. If you only implement one of these special methods in Python, choose __repr__. “What is the difference between __str__ and __repr__ in Python?” is a Stack Overflow question with excellent contributions from Pythonistas Alex Martelli and Martijn Pieters.\n\nBoolean Value of a Custom Type Although Python has a bool type, it accepts any object in a Boolean context, such as the expression controlling an if or while statement, or as operands to and, or, and not. To determine whether a value x is truthy or falsy, Python applies bool(x), which returns either True or False.\n\nBy default, instances of user-defined classes are considered truthy, unless either __bool__ or __len__ is implemented. Basically, bool(x) calls x.__bool__() and uses the result. If __bool__ is not implemented, Python tries to invoke x.__len__(), and if that returns zero, bool returns False. Otherwise bool returns True.\n\nOur implementation of __bool__ is conceptually simple: it returns False if the mag‐ nitude of the vector is zero, True otherwise. We convert the magnitude to a Boolean using bool(abs(self)) because __bool__ is expected to return a Boolean. Outside of __bool__ methods, it is rarely necessary to call bool() explicitly, because any object can be used in a Boolean context.\n\nNote how the special method __bool__ allows your objects to follow the truth value testing rules defined in the “Built-in Types” chapter of The Python Standard Library documentation.\n\nHow Special Methods Are Used\n\n|\n\n13",
      "page_number": 22
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 41-58)",
      "start_page": 41,
      "end_page": 58,
      "detection_method": "synthetic",
      "content": "A faster implementation of Vector.__bool__ is this:\n\ndef __bool__(self): return bool(self.x or self.y)\n\nThis is harder to read, but avoids the trip through abs, __abs__, the squares, and square root. The explicit conversion to bool is needed because __bool__ must return a Boolean, and or returns either operand as is: x or y evaluates to x if that is truthy, otherwise the result is y, whatever that is.\n\nCollection API Figure 1-2 documents the interfaces of the essential collection types in the language. All the classes in the diagram are ABCs—abstract base classes. ABCs and the collec tions.abc module are covered in Chapter 13. The goal of this brief section is to give a panoramic view of Python’s most important collection interfaces, showing how they are built from special methods.\n\nFigure 1-2. UML class diagram with fundamental collection types. Method names in italic are abstract, so they must be implemented by concrete subclasses such as list and dict. The remaining methods have concrete implementations, therefore subclasses can inherit them.\n\nEach of the top ABCs has a single special method. The Collection ABC (new in Python 3.6) unifies the three essential interfaces that every collection should implement:\n\n14\n\n|\n\nChapter 1: The Python Data Model\n\nIterable to support for, unpacking, and other forms of iteration • Sized to support the len built-in function • Container to support the in operator\n\nPython does not require concrete classes to actually inherit from any of these ABCs. Any class that implements __len__ satisfies the Sized interface.\n\nThree very important specializations of Collection are:\n\nSequence, formalizing the interface of built-ins like list and str • Mapping, implemented by dict, collections.defaultdict, etc. • Set, the interface of the set and frozenset built-in types\n\nOnly Sequence is Reversible, because sequences support arbitrary ordering of their contents, while mappings and sets do not.\n\nSince Python 3.7, the dict type is officially “ordered,” but that only means that the key insertion order is preserved. You cannot rearrange the keys in a dict however you like.\n\nAll the special methods in the Set ABC implement infix operators. For example, a & b computes the intersection of sets a and b, and is implemented in the __and__ special method.\n\nThe next two chapters will cover standard library sequences, mappings, and sets in detail.\n\nNow let’s consider the major categories of special methods defined in the Python Data Model.\n\nOverview of Special Methods The “Data Model” chapter of The Python Language Reference lists more than 80 spe‐ cial method names. More than half of them implement arithmetic, bitwise, and com‐ parison operators. As an overview of what is available, see the following tables.\n\nTable 1-1 shows special method names, excluding those used to implement infix operators or core math functions like abs. Most of these methods will be covered throughout the book, including the most recent additions: asynchronous special methods such as __anext__ (added in Python 3.5), and the class customization hook, __init_subclass__ (from Python 3.6).\n\nOverview of Special Methods\n\n|\n\n15\n\nTable 1-1. Special method names (operators excluded)\n\nCategory String/bytes representation\n\nMethod names\n\n__repr__ __str__ __format__ __bytes__ __fspath__\n\nConversion to number\n\n__bool__ __complex__ __int__ __float__ __hash__ __index__\n\nEmulating collections\n\n__len__ __getitem__ __setitem__ __delitem__ __contains__\n\nIteration\n\n__iter__ __aiter__ __next__ __anext__ __reversed__\n\nCallable or coroutine execution\n\n__call__ __await__\n\nContext management\n\n__enter__ __exit__ __aexit__ __aenter__\n\nInstance creation and destruction __new__ __init__ __del__\n\nAttribute management\n\n__getattr__ __getattribute__ __setattr__ __delattr__ __dir__\n\nAttribute descriptors\n\n__get__ __set__ __delete__ __set_name__\n\nAbstract base classes\n\n__instancecheck__ __subclasscheck__\n\nClass metaprogramming\n\n__prepare__ __init_subclass__ __class_getitem__ __mro_entries__\n\nInfix and numerical operators are supported by the special methods listed in Table 1-2. Here the most recent names are __matmul__, __rmatmul__, and __imat mul__, added in Python 3.5 to support the use of @ as an infix operator for matrix multiplication, as we’ll see in Chapter 16.\n\nTable 1-2. Special method names and symbols for operators\n\nOperator category Unary numeric\n\nSymbols\n\n+ abs()\n\nMethod names\n\n__neg__ __pos__ __abs__\n\nRich comparison\n\n< <= == != > >=\n\n__lt__ __le__ __eq__ __ne__ __gt__ __ge__\n\nArithmetic\n\n+ - * / // % @ divmod() round() ** pow()\n\n__add__ __sub__ __mul__ __truediv__ __floordiv__ __mod__ __matmul__ __div mod__ __round__ __pow__\n\nReversed arithmetic\n\n(arithmetic operators with swapped operands)\n\n__radd__ __rsub__ __rmul__ __rtrue div__ __rfloordiv__ __rmod__ __rmat mul__ __rdivmod__ __rpow__\n\nAugmented assignment arithmetic\n\n+= -= *= /= //= %= @= **=\n\n__iadd__ __isub__ __imul__ __itrue div__ __ifloordiv__ __imod__ __imat mul__ __ipow__\n\nBitwise\n\n& | ^ << >> ~\n\n__and__ __or__ __xor__ __lshift__ __rshift__ __invert__\n\nReversed bitwise\n\n(bitwise operators with swapped operands)\n\n__rand__ __ror__ __rxor__ __rlshift__ __rrshift__\n\n16\n\n|\n\nChapter 1: The Python Data Model\n\nOperator category Augmented assignment bitwise\n\nSymbols\n\n&= |= ^= <<= >>=\n\nMethod names\n\n__iand__ __ior__ __ixor__ __ilshift__ __irshift__\n\nPython calls a reversed operator special method on the second operand when the corresponding special method on the first operand cannot be used. Augmented assignments are shortcuts combining an infix operator with variable assignment, e.g., a += b.\n\nChapter 16 explains reversed operators and augmented assignment in detail.\n\nWhy len Is Not a Method I asked this question to core developer Raymond Hettinger in 2013, and the key to his answer was a quote from “The Zen of Python”: “practicality beats purity.” In “How Special Methods Are Used” on page 8, I described how len(x) runs very fast when x is an instance of a built-in type. No method is called for the built-in objects of CPython: the length is simply read from a field in a C struct. Getting the number of items in a collection is a common operation and must work efficiently for such basic and diverse types as str, list, memoryview, and so on.\n\nIn other words, len is not called as a method because it gets special treatment as part of the Python Data Model, just like abs. But thanks to the special method __len__, you can also make len work with your own custom objects. This is a fair compromise between the need for efficient built-in objects and the consistency of the language. Also from “The Zen of Python”: “Special cases aren’t special enough to break the rules.”\n\nIf you think of abs and len as unary operators, you may be more inclined to forgive their functional look and feel, as opposed to the method call syntax one might expect in an object-oriented lan‐ guage. In fact, the ABC language—a direct ancestor of Python that pioneered many of its features—had an # operator that was the equivalent of len (you’d write #s). When used as an infix operator, written x#s, it counted the occurrences of x in s, which in Python you get as s.count(x), for any sequence s.\n\nWhy len Is Not a Method\n\n|\n\n17\n\nChapter Summary By implementing special methods, your objects can behave like the built-in types, enabling the expressive coding style the community considers Pythonic.\n\nA basic requirement for a Python object is to provide usable string representations of itself, one used for debugging and logging, another for presentation to end users. That is why the special methods __repr__ and __str__ exist in the data model.\n\nEmulating sequences, as shown with the FrenchDeck example, is one of the most common uses of the special methods. For example, database libraries often return query results wrapped in sequence-like collections. Making the most of existing sequence types is the subject of Chapter 2. Implementing your own sequences will be covered in Chapter 12, when we create a multidimensional extension of the Vector class.\n\nThanks to operator overloading, Python offers a rich selection of numeric types, from the built-ins to decimal.Decimal and fractions.Fraction, all supporting infix arithmetic operators. The NumPy data science libraries support infix operators with matrices and tensors. Implementing operators—including reversed operators and augmented assignment—will be shown in Chapter 16 via enhancements of the Vector example.\n\nThe use and implementation of the majority of the remaining special methods of the Python Data Model are covered throughout this book.\n\nFurther Reading The “Data Model” chapter of The Python Language Reference is the canonical source for the subject of this chapter and much of this book.\n\nPython in a Nutshell, 3rd ed. by Alex Martelli, Anna Ravenscroft, and Steve Holden (O’Reilly) has excellent coverage of the data model. Their description of the mechan‐ ics of attribute access is the most authoritative I’ve seen apart from the actual C source code of CPython. Martelli is also a prolific contributor to Stack Overflow, with more than 6,200 answers posted. See his user profile at Stack Overflow.\n\nDavid Beazley has two books covering the data model in detail in the context of Python 3: Python Essential Reference, 4th ed. (Addison-Wesley), and Python Cook‐ book, 3rd ed. (O’Reilly), coauthored with Brian K. Jones.\n\nThe Art of the Metaobject Protocol (MIT Press) by Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow explains the concept of a metaobject protocol, of which the Python Data Model is one example.\n\n18\n\n|\n\nChapter 1: The Python Data Model\n\nSoapbox\n\nData Model or Object Model?\n\nWhat the Python documentation calls the “Python Data Model,” most authors would say is the “Python object model.” Martelli, Ravenscroft, and Holden’s Python in a Nutshell, 3rd ed., and David Beazley’s Python Essential Reference, 4th ed. are the best books covering the Python Data Model, but they refer to it as the “object model.” On Wikipedia, the first definition of “object model” is: “The properties of objects in gen‐ eral in a specific computer programming language.” This is what the Python Data Model is about. In this book, I will use “data model” because the documentation favors that term when referring to the Python object model, and because it is the title of the chapter of The Python Language Reference most relevant to our discussions.\n\nMuggle Methods\n\nThe Original Hacker’s Dictionary defines magic as “yet unexplained, or too compli‐ cated to explain” or “a feature not generally publicized which allows something other‐ wise impossible.”\n\nThe Ruby community calls their equivalent of the special methods magic methods. Many in the Python community adopt that term as well. I believe the special methods are the opposite of magic. Python and Ruby empower their users with a rich metaob‐ ject protocol that is fully documented, enabling muggles like you and me to emulate many of the features available to core developers who write the interpreters for those languages.\n\nIn contrast, consider Go. Some objects in that language have features that are magic, in the sense that we cannot emulate them in our own user-defined types. For exam‐ ple, Go arrays, strings, and maps support the use brackets for item access, as in a[i]. But there’s no way to make the [] notation work with a new collection type that you define. Even worse, Go has no user-level concept of an iterable interface or an iterator object, therefore its for/range syntax is limited to supporting five “magic” built-in types, including arrays, strings, and maps.\n\nMaybe in the future, the designers of Go will enhance its metaobject protocol. But currently, it is much more limited than what we have in Python or Ruby.\n\nMetaobjects\n\nThe Art of the Metaobject Protocol (AMOP) is my favorite computer book title. But I mention it because the term metaobject protocol is useful to think about the Python Data Model and similar features in other languages. The metaobject part refers to the objects that are the building blocks of the language itself. In this context, protocol is a synonym of interface. So a metaobject protocol is a fancy synonym for object model: an API for core language constructs.\n\nFurther Reading\n\n|\n\n19\n\n20\n\nA rich metaobject protocol enables extending a language to support new program‐ ming paradigms. Gregor Kiczales, the first author of the AMOP book, later became a pioneer in aspect-oriented programming and the initial author of AspectJ, an exten‐ sion of Java implementing that paradigm. Aspect-oriented programming is much easier to implement in a dynamic language like Python, and some frameworks do it. The most important example is zope.interface, part of the framework on which the Plone content management system is built.\n\n|\n\nChapter 1: The Python Data Model\n\nCHAPTER 2 An Array of Sequences\n\nAs you may have noticed, several of the operations mentioned work equally for texts, lists and tables. Texts, lists and tables together are called ‘trains’. [...] The FOR com‐ mand also works generically on trains.\n\n—Leo Geurts, Lambert Meertens, and Steven Pembertonm, ABC Programmer’s Handbook1\n\nBefore creating Python, Guido was a contributor to the ABC language—a 10-year research project to design a programming environment for beginners. ABC intro‐ duced many ideas we now consider “Pythonic”: generic operations on different types of sequences, built-in tuple and mapping types, structure by indentation, strong typing without variable declarations, and more. It’s no accident that Python is so user-friendly.\n\nPython inherited from ABC the uniform handling of sequences. Strings, lists, byte sequences, arrays, XML elements, and database results share a rich set of common operations, including iteration, slicing, sorting, and concatenation.\n\nUnderstanding the variety of sequences available in Python saves us from reinventing the wheel, and their common interface inspires us to create APIs that properly sup‐ port and leverage existing and future sequence types.\n\nMost of the discussion in this chapter applies to sequences in general, from the famil‐ iar list to the str and bytes types added in Python 3. Specific topics on lists, tuples, arrays, and queues are also covered here, but the specifics of Unicode strings and byte sequences appear in Chapter 4. Also, the idea here is to cover sequence types that are ready to use. Creating your own sequence types is the subject of Chapter 12.\n\n1 Leo Geurts, Lambert Meertens, and Steven Pemberton, ABC Programmer’s Handbook, p. 8. (Bosko Books).\n\n21\n\nThese are the main topics this chapter will cover:\n\nList comprehensions and the basics of generator expressions\n\nUsing tuples as records versus using tuples as immutable lists\n\nSequence unpacking and sequence patterns\n\nReading from slices and writing to slices\n\nSpecialized sequence types, like arrays and queues\n\nWhat’s New in This Chapter The most important update in this chapter is “Pattern Matching with Sequences” on page 38. That’s the first time the new pattern matching feature of Python 3.10 appears in this second edition.\n\nOther changes are not updates but improvements over the first edition:\n\nNew diagram and description of the internals of sequences, contrasting contain‐ ers and flat sequences\n\nBrief comparison of the performance and storage characteristics of list versus tuple\n\nCaveats of tuples with mutable elements, and how to detect them if needed\n\nI moved coverage of named tuples to “Classic Named Tuples” on page 169 in Chapter 5, where they are compared to typing.NamedTuple and @dataclass.\n\nTo make room for new content and keep the page count within reason, the section “Managing Ordered Sequences with Bisect” from the first edition is now a post in the fluentpython.com com‐ panion website.\n\nOverview of Built-In Sequences The standard library offers a rich selection of sequence types implemented in C:\n\nContainer sequences\n\nCan hold items of different types, including nested containers. Some examples: list, tuple, and collections.deque.\n\nFlat sequences\n\nHold items of one simple type. Some examples: str, bytes, and array.array.\n\n22\n\n|\n\nChapter 2: An Array of Sequences\n\nA container sequence holds references to the objects it contains, which may be of any type, while a flat sequence stores the value of its contents in its own memory space, not as distinct Python objects. See Figure 2-1.\n\nFigure 2-1. Simplified memory diagrams for a tuple and an array, each with three items. Gray cells represent the in-memory header of each Python object—not drawn to proportion. The tuple has an array of references to its items. Each item is a separate Python object, possibly holding references to other Python objects, like that two-item list. In contrast, the Python array is a single object, holding a C language array of three doubles.\n\nThus, flat sequences are more compact, but they are limited to holding primitive machine values like bytes, integers, and floats.\n\nEvery Python object in memory has a header with metadata. The simplest Python object, a float, has a value field and two metadata fields:\n\nob_refcnt: the object’s reference count • ob_type: a pointer to the object’s type • ob_fval: a C double holding the value of the float\n\nOn a 64-bit Python build, each of those fields takes 8 bytes. That’s why an array of floats is much more compact than a tuple of floats: the array is a single object holding the raw values of the floats, while the tuple consists of several objects—the tuple itself and each float object contained in it.\n\nOverview of Built-In Sequences\n\n|\n\n23\n\nAnother way of grouping sequence types is by mutability:\n\nMutable sequences\n\nFor example, list, bytearray, array.array, and collections.deque.\n\nImmutable sequences\n\nFor example, tuple, str, and bytes.\n\nFigure 2-2 helps visualize how mutable sequences inherit all methods from immuta‐ ble sequences, and implement several additional methods. The built-in concrete sequence types do not actually subclass the Sequence and MutableSequence abstract base classes (ABCs), but they are virtual subclasses registered with those ABCs—as we’ll see in Chapter 13. Being virtual subclasses, tuple and list pass these tests:\n\n>>> from collections import abc >>> issubclass(tuple, abc.Sequence) True >>> issubclass(list, abc.MutableSequence) True\n\nFigure 2-2. Simplified UML class diagram for some classes from collections.abc (super‐ classes are on the left; inheritance arrows point from subclasses to superclasses; names in italic are abstract classes and abstract methods).\n\nKeep in mind these common traits: mutable versus immutable; container versus flat. They are helpful to extrapolate what you know about one sequence type to others.\n\nThe most fundamental sequence type is the list: a mutable container. I expect you are very familiar with lists, so we’ll jump right into list comprehensions, a powerful way of building lists that is sometimes underused because the syntax may look unusual at first. Mastering list comprehensions opens the door to generator expres‐ sions, which—among other uses—can produce elements to fill up sequences of any type. Both are the subject of the next section.\n\n24\n\n|\n\nChapter 2: An Array of Sequences\n\nList Comprehensions and Generator Expressions A quick way to build a sequence is using a list comprehension (if the target is a list) or a generator expression (for other kinds of sequences). If you are not using these syntactic forms on a daily basis, I bet you are missing opportunities to write code that is more readable and often faster at the same time.\n\nIf you doubt my claim that these constructs are “more readable,” read on. I’ll try to convince you.\n\nFor brevity, many Python programmers refer to list comprehen‐ sions as listcomps, and generator expressions as genexps. I will use these words as well.\n\nList Comprehensions and Readability Here is a test: which do you find easier to read, Example 2-1 or Example 2-2?\n\nExample 2-1. Build a list of Unicode code points from a string\n\n>>> symbols = '$¢£¥€¤' >>> codes = [] >>> for symbol in symbols: ... codes.append(ord(symbol)) ... >>> codes [36, 162, 163, 165, 8364, 164]\n\nExample 2-2. Build a list of Unicode code points from a string, using a listcomp\n\n>>> symbols = '$¢£¥€¤' >>> codes = [ord(symbol) for symbol in symbols] >>> codes [36, 162, 163, 165, 8364, 164]\n\nAnybody who knows a little bit of Python can read Example 2-1. However, after learning about listcomps, I find Example 2-2 more readable because its intent is explicit.\n\nA for loop may be used to do lots of different things: scanning a sequence to count or pick items, computing aggregates (sums, averages), or any number of other tasks. The code in Example 2-1 is building up a list. In contrast, a listcomp is more explicit. Its goal is always to build a new list.\n\nList Comprehensions and Generator Expressions\n\n|\n\n25\n\nOf course, it is possible to abuse list comprehensions to write truly incomprehensible code. I’ve seen Python code with listcomps used just to repeat a block of code for its side effects. If you are not doing something with the produced list, you should not use that syntax. Also, try to keep it short. If the list comprehension spans more than two lines, it is probably best to break it apart or rewrite it as a plain old for loop. Use your best judgment: for Python, as for English, there are no hard-and-fast rules for clear writing.\n\nSyntax Tip\n\nIn Python code, line breaks are ignored inside pairs of [], {}, or (). So you can build multiline lists, listcomps, tuples, dictionaries, etc., without using the \\ line continuation escape, which doesn’t work if you accidentally type a space after it. Also, when those delimiter pairs are used to define a literal with a comma-separated series of items, a trailing comma will be ignored. So, for example, when cod‐ ing a multiline list literal, it is thoughtful to put a comma after the last item, making it a little easier for the next coder to add one more item to that list, and reducing noise when reading diffs.\n\nLocal Scope Within Comprehensions and Generator Expressions In Python 3, list comprehensions, generator expressions, and their siblings set and dict comprehensions, have a local scope to hold the variables assigned in the for clause.\n\nHowever, variables assigned with the “Walrus operator” := remain accessible after those comprehensions or expressions return—unlike local variables in a function. PEP 572—Assignment Expressions defines the scope of the target of := as the enclos‐ ing function, unless there is a global or nonlocal declaration for that target.2\n\n>>> x = 'ABC' >>> codes = [ord(x) for x in x] >>> x 'ABC' >>> codes [65, 66, 67] >>> codes = [last := ord(c) for c in x] >>> last 67 >>> c Traceback (most recent call last):\n\n2 Thanks to reader Tina Lapine for pointing this out.\n\n26\n\n|\n\nChapter 2: An Array of Sequences\n\nFile \"<stdin>\", line 1, in <module> NameError: name 'c' is not defined\n\nx was not clobbered: it’s still bound to 'ABC'.\n\nlast remains.\n\nc is gone; it existed only inside the listcomp.\n\nList comprehensions build lists from sequences or any other iterable type by filtering and transforming items. The filter and map built-ins can be composed to do the same, but readability suffers, as we will see next.\n\nListcomps Versus map and filter Listcomps do everything the map and filter functions do, without the contortions of the functionally challenged Python lambda. Consider Example 2-3.\n\nExample 2-3. The same list built by a listcomp and a map/filter composition\n\n>>> symbols = '$¢£¥€¤' >>> beyond_ascii = [ord(s) for s in symbols if ord(s) > 127] >>> beyond_ascii [162, 163, 165, 8364, 164] >>> beyond_ascii = list(filter(lambda c: c > 127, map(ord, symbols))) >>> beyond_ascii [162, 163, 165, 8364, 164]\n\nI used to believe that map and filter were faster than the equivalent listcomps, but Alex Martelli pointed out that’s not the case—at least not in the preceding examples. The 02-array-seq/listcomp_speed.py script in the Fluent Python code repository is a simple speed test comparing listcomp with filter/map.\n\nI’ll have more to say about map and filter in Chapter 7. Now we turn to the use of listcomps to compute Cartesian products: a list containing tuples built from all items from two or more lists.\n\nCartesian Products Listcomps can build lists from the Cartesian product of two or more iterables. The items that make up the Cartesian product are tuples made from items from every input iterable. The resulting list has a length equal to the lengths of the input iterables multiplied. See Figure 2-3.\n\nList Comprehensions and Generator Expressions\n\n|\n\n27\n\nFigure 2-3. The Cartesian product of 3 card ranks and 4 suits is a sequence of 12 pairings.\n\nFor example, imagine you need to produce a list of T-shirts available in two colors and three sizes. Example 2-4 shows how to produce that list using a listcomp. The result has six items.\n\nExample 2-4. Cartesian product using a list comprehension\n\n>>> colors = ['black', 'white'] >>> sizes = ['S', 'M', 'L'] >>> tshirts = [(color, size) for color in colors for size in sizes] >>> tshirts [('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'), ('white', 'M'), ('white', 'L')] >>> for color in colors: ... for size in sizes: ... print((color, size)) ... ('black', 'S') ('black', 'M') ('black', 'L') ('white', 'S') ('white', 'M') ('white', 'L') >>> tshirts = [(color, size) for size in sizes ... for color in colors] >>> tshirts [('black', 'S'), ('white', 'S'), ('black', 'M'), ('white', 'M'), ('black', 'L'), ('white', 'L')]\n\n28\n\n|\n\nChapter 2: An Array of Sequences\n\nThis generates a list of tuples arranged by color, then size.\n\nNote how the resulting list is arranged as if the for loops were nested in the same order as they appear in the listcomp.\n\nTo get items arranged by size, then color, just rearrange the for clauses; adding a line break to the listcomp makes it easier to see how the result will be ordered.\n\nIn Example 1-1 (Chapter 1), I used the following expression to initialize a card deck with a list made of 52 cards from all 13 ranks of each of the 4 suits, sorted by suit, then rank:\n\nself._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\nListcomps are a one-trick pony: they build lists. To generate data for other sequence types, a genexp is the way to go. The next section is a brief look at genexps in the context of building sequences that are not lists.\n\nGenerator Expressions To initialize tuples, arrays, and other types of sequences, you could also start from a listcomp, but a genexp (generator expression) saves memory because it yields items one by one using the iterator protocol instead of building a whole list just to feed another constructor.\n\nGenexps use the same syntax as listcomps, but are enclosed in parentheses rather than brackets.\n\nExample 2-5 shows basic usage of genexps to build a tuple and an array.\n\nExample 2-5. Initializing a tuple and an array from a generator expression\n\n>>> symbols = '$¢£¥€¤' >>> tuple(ord(symbol) for symbol in symbols) (36, 162, 163, 165, 8364, 164) >>> import array >>> array.array('I', (ord(symbol) for symbol in symbols)) array('I', [36, 162, 163, 165, 8364, 164])\n\nIf the generator expression is the single argument in a function call, there is no need to duplicate the enclosing parentheses.\n\nThe array constructor takes two arguments, so the parentheses around the gen‐ erator expression are mandatory. The first argument of the array constructor defines the storage type used for the numbers in the array, as we’ll see in “Arrays” on page 59.\n\nList Comprehensions and Generator Expressions\n\n|\n\n29\n\nExample 2-6 uses a genexp with a Cartesian product to print out a roster of T-shirts of two colors in three sizes. In contrast with Example 2-4, here the six-item list of T- shirts is never built in memory: the generator expression feeds the for loop produc‐ ing one item at a time. If the two lists used in the Cartesian product had a thousand items each, using a generator expression would save the cost of building a list with a million items just to feed the for loop.\n\nExample 2-6. Cartesian product in a generator expression\n\n>>> colors = ['black', 'white'] >>> sizes = ['S', 'M', 'L'] >>> for tshirt in (f'{c} {s}' for c in colors for s in sizes): ... print(tshirt) ... black S black M black L white S white M white L\n\nThe generator expression yields items one by one; a list with all six T-shirt varia‐ tions is never produced in this example.\n\nChapter 17 explains how generators work in detail. Here the idea was just to show the use of generator expressions to initialize sequences other than lists, or to produce output that you don’t need to keep in memory.\n\nNow we move on to the other fundamental sequence type in Python: the tuple.\n\nTuples Are Not Just Immutable Lists Some introductory texts about Python present tuples as “immutable lists,” but that is short selling them. Tuples do double duty: they can be used as immutable lists and also as records with no field names. This use is sometimes overlooked, so we will start with that.\n\nTuples as Records Tuples hold records: each item in the tuple holds the data for one field, and the posi‐ tion of the item gives its meaning.\n\nIf you think of a tuple just as an immutable list, the quantity and the order of the items may or may not be important, depending on the context. But when using a\n\n30\n\n|\n\nChapter 2: An Array of Sequences\n\ntuple as a collection of fields, the number of items is usually fixed and their order is always important.\n\nExample 2-7 shows tuples used as records. Note that in every expression, sorting the tuple would destroy the information because the meaning of each field is given by its position in the tuple.\n\nExample 2-7. Tuples used as records\n\n>>> lax_coordinates = (33.9425, -118.408056) >>> city, year, pop, chg, area = ('Tokyo', 2003, 32_450, 0.66, 8014) >>> traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'), ... ('ESP', 'XDA205856')] >>> for passport in sorted(traveler_ids): ... print('%s/%s' % passport) ... BRA/CE342567 ESP/XDA205856 USA/31195855 >>> for country, _ in traveler_ids: ... print(country) ... USA BRA ESP\n\nLatitude and longitude of the Los Angeles International Airport.\n\nData about Tokyo: name, year, population (thousands), population change (%), and area (km²).\n\nA list of tuples of the form (country_code, passport_number).\n\nAs we iterate over the list, passport is bound to each tuple.\n\nThe % formatting operator understands tuples and treats each item as a separate field.\n\nThe for loop knows how to retrieve the items of a tuple separately—this is called “unpacking.” Here we are not interested in the second item, so we assign it to _, a dummy variable.\n\nTuples Are Not Just Immutable Lists\n\n|\n\n31",
      "page_number": 41
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 59-81)",
      "start_page": 59,
      "end_page": 81,
      "detection_method": "synthetic",
      "content": "In general, using _ as a dummy variable is just a convention. It’s just a strange but valid variable name. However, in a match/case statement, _ is a wildcard that matches any value but is not bound to a value. See “Pattern Matching with Sequences” on page 38. And in the Python console, the result of the preceding command is assigned to _—unless the result is None.\n\nWe often think of records as data structures with named fields. Chapter 5 presents two ways of creating tuples with named fields.\n\nBut often, there’s no need to go through the trouble of creating a class just to name the fields, especially if you leverage unpacking and avoid using indexes to access the fields. In Example 2-7, we assigned ('Tokyo', 2003, 32_450, 0.66, 8014) to city, year, pop, chg, area in a single statement. Then, the % operator assigned each item in the passport tuple to the corresponding slot in the format string in the print argument. Those are two examples of tuple unpacking.\n\nThe term tuple unpacking is widely used by Pythonistas, but itera‐ ble unpacking is gaining traction, as in the title of PEP 3132 — Extended Iterable Unpacking.\n\n“Unpacking Sequences and Iterables” on page 35 presents a lot more about unpacking not only tuples, but sequences and iterables in general.\n\nNow let’s consider the tuple class as an immutable variant of the list class.\n\nTuples as Immutable Lists The Python interpreter and standard library make extensive use of tuples as immuta‐ ble lists, and so should you. This brings two key benefits:\n\nClarity\n\nWhen you see a tuple in code, you know its length will never change.\n\nPerformance\n\nA tuple uses less memory than a list of the same length, and it allows Python to do some optimizations.\n\nHowever, be aware that the immutability of a tuple only applies to the references contained in it. References in a tuple cannot be deleted or replaced. But if one of those references points to a mutable object, and that object is changed, then the value of the tuple changes. The next snippet illustrates this point by creating two tuples—a and b—which are initially equal. Figure 2-4 represents the initial layout of the b tuple in memory.\n\n32\n\n|\n\nChapter 2: An Array of Sequences\n\nFigure 2-4. The content of the tuple itself is immutable, but that only means the refer‐ ences held by the tuple will always point to the same objects. However, if one of the ref‐ erenced objects is mutable—like a list—its content may change.\n\nWhen the last item in b is changed, b and a become different:\n\n>>> a = (10, 'alpha', [1, 2]) >>> b = (10, 'alpha', [1, 2]) >>> a == b True >>> b[-1].append(99) >>> a == b False >>> b (10, 'alpha', [1, 2, 99])\n\nTuples with mutable items can be a source of bugs. As we’ll see in “What Is Hasha‐ ble” on page 84, an object is only hashable if its value cannot ever change. An unhasha‐ ble tuple cannot be inserted as a dict key, or a set element.\n\nIf you want to determine explicitly if a tuple (or any object) has a fixed value, you can use the hash built-in to create a fixed function like this:\n\n>>> def fixed(o): ... try: ... hash(o) ... except TypeError: ... return False ... return True ... >>> tf = (10, 'alpha', (1, 2)) >>> tm = (10, 'alpha', [1, 2]) >>> fixed(tf) True\n\nTuples Are Not Just Immutable Lists\n\n|\n\n33\n\n>>> fixed(tm) False\n\nWe explore this issue further in “The Relative Immutability of Tuples” on page 207.\n\nDespite this caveat, tuples are widely used as immutable lists. They offer some perfor‐ mance advantages explained by Python core developer Raymond Hettinger in a StackOverflow answer to the question: “Are tuples more efficient than lists in Python?”. To summarize, Hettinger wrote:\n\nTo evaluate a tuple literal, the Python compiler generates bytecode for a tuple constant in one operation; but for a list literal, the generated bytecode pushes each element as a separate constant to the data stack, and then builds the list. • Given a tuple t, tuple(t) simply returns a reference to the same t. There’s no need to copy. In contrast, given a list l, the list(l) constructor must create a new copy of l.\n\nBecause of its fixed length, a tuple instance is allocated the exact memory space it needs. Instances of list, on the other hand, are allocated with room to spare, to amortize the cost of future appends.\n\nThe references to the items in a tuple are stored in an array in the tuple struct, while a list holds a pointer to an array of references stored elsewhere. The indi‐ rection is necessary because when a list grows beyond the space currently alloca‐ ted, Python needs to reallocate the array of references to make room. The extra indirection makes CPU caches less effective.\n\nComparing Tuple and List Methods When using a tuple as an immutable variation of list, it is good to know how similar their APIs are. As you can see in Table 2-1, tuple supports all list methods that do not involve adding or removing items, with one exception—tuple lacks the __reversed__ method. However, that is just for optimization; reversed(my_tuple) works without it.\n\nTable 2-1. Methods and attributes found in list or tuple (methods implemented by object are omitted for brevity)\n\nlist\n\ntuple\n\ns.__add__(s2)\n\n\n\n\n\ns + s2—concatenation\n\ns.__iadd__(s2)\n\n\n\ns += s2—in-place concatenation\n\ns.append(e)\n\n\n\nAppend one element after last\n\ns.clear()\n\n\n\nDelete all items\n\ns.__contains__(e)\n\n\n\n\n\ne in s\n\ns.copy()\n\n\n\nShallow copy of the list\n\n34\n\n|\n\nChapter 2: An Array of Sequences\n\nlist\n\ntuple\n\ns.count(e)\n\n\n\n\n\nCount occurrences of an element\n\ns.__delitem__(p)\n\n\n\nRemove item at position p\n\ns.extend(it)\n\n\n\nAppend items from iterable it\n\ns.__getitem__(p)\n\n\n\n\n\ns[p]—get item at position\n\ns.__getnewargs__()\n\n\n\nSupport for optimized serialization with pickle\n\ns.index(e)\n\n\n\n\n\nFind position of first occurrence of e\n\ns.insert(p, e)\n\n\n\nInsert element e before the item at position p\n\ns.__iter__()\n\n\n\n\n\nGet iterator\n\ns.__len__()\n\n\n\n\n\nlen(s)—number of items\n\ns.__mul__(n)\n\n\n\n\n\ns * n—repeated concatenation\n\ns.__imul__(n)\n\ns.__rmul__(n)\n\n\n\n\n\n\n\ns *= n—in-place repeated concatenation n * s—reversed repeated concatenationa\n\ns.pop([p])\n\n\n\nRemove and return last item or item at optional position p\n\ns.remove(e)\n\n\n\nRemove first occurrence of element e by value\n\ns.reverse()\n\n\n\nReverse the order of the items in place\n\ns.__reversed__()\n\n\n\nGet iterator to scan items from last to first\n\ns.__setitem__(p, e)\n\n\n\ns[p] = e—put e in position p, overwriting existing itemb\n\ns.sort([key], [reverse]) ●\n\nSort items in place with optional keyword arguments key and reverse\n\na Reversed operators are explained in Chapter 16. b Also used to overwrite a subsequence. See “Assigning to Slices” on page 50.\n\nNow let’s switch to an important subject for idiomatic Python programming: tuple, list, and iterable unpacking.\n\nUnpacking Sequences and Iterables Unpacking is important because it avoids unnecessary and error-prone use of indexes to extract elements from sequences. Also, unpacking works with any iterable object as the data source—including iterators, which don’t support index notation ([]). The only requirement is that the iterable yields exactly one item per variable in the receiving end, unless you use a star (*) to capture excess items, as explained in “Using * to Grab Excess Items” on page 36.\n\nThe most visible form of unpacking is parallel assignment; that is, assigning items from an iterable to a tuple of variables, as you can see in this example:\n\n>>> lax_coordinates = (33.9425, -118.408056) >>> latitude, longitude = lax_coordinates # unpacking >>> latitude\n\nUnpacking Sequences and Iterables\n\n|\n\n35\n\n33.9425 >>> longitude -118.408056\n\nAn elegant application of unpacking is swapping the values of variables without using a temporary variable:\n\n>>> b, a = a, b\n\nAnother example of unpacking is prefixing an argument with * when calling a function:\n\n>>> divmod(20, 8) (2, 4) >>> t = (20, 8) >>> divmod(*t) (2, 4) >>> quotient, remainder = divmod(*t) >>> quotient, remainder (2, 4)\n\nThe preceding code shows another use of unpacking: allowing functions to return multiple values in a way that is convenient to the caller. As another example, the os.path.split() function builds a tuple (path, last_part) from a filesystem path:\n\n>>> import os >>> _, filename = os.path.split('/home/luciano/.ssh/id_rsa.pub') >>> filename 'id_rsa.pub'\n\nAnother way of using just some of the items when unpacking is to use the * syntax, as we’ll see right away.\n\nUsing * to Grab Excess Items Defining function parameters with *args to grab arbitrary excess arguments is a classic Python feature.\n\nIn Python 3, this idea was extended to apply to parallel assignment as well:\n\n>>> a, b, *rest = range(5) >>> a, b, rest (0, 1, [2, 3, 4]) >>> a, b, *rest = range(3) >>> a, b, rest (0, 1, [2]) >>> a, b, *rest = range(2) >>> a, b, rest (0, 1, [])\n\nIn the context of parallel assignment, the * prefix can be applied to exactly one vari‐ able, but it can appear in any position:\n\n36\n\n|\n\nChapter 2: An Array of Sequences\n\n>>> a, *body, c, d = range(5) >>> a, body, c, d (0, [1, 2], 3, 4) >>> *head, b, c, d = range(5) >>> head, b, c, d ([0, 1], 2, 3, 4)\n\nUnpacking with * in Function Calls and Sequence Literals PEP 448—Additional Unpacking Generalizations introduced more flexible syntax for iterable unpacking, best summarized in “What’s New In Python 3.5”.\n\nIn function calls, we can use * multiple times:\n\n>>> def fun(a, b, c, d, *rest): ... return a, b, c, d, rest ... >>> fun(*[1, 2], 3, *range(4, 7)) (1, 2, 3, 4, (5, 6))\n\nThe * can also be used when defining list, tuple, or set literals, as shown in these examples from “What’s New In Python 3.5”:\n\n>>> *range(4), 4 (0, 1, 2, 3, 4) >>> [*range(4), 4] [0, 1, 2, 3, 4] >>> {*range(4), 4, *(5, 6, 7)} {0, 1, 2, 3, 4, 5, 6, 7}\n\nPEP 448 introduced similar new syntax for **, which we’ll see in “Unpacking Map‐ pings” on page 80.\n\nFinally, a powerful feature of tuple unpacking is that it works with nested structures.\n\nNested Unpacking The target of an unpacking can use nesting, e.g., (a, b, (c, d)). Python will do the right thing if the value has the same nesting structure. Example 2-8 shows nested unpacking in action.\n\nExample 2-8. Unpacking nested tuples to access the longitude\n\nmetro_areas = [ ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)), ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)), ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)), ]\n\nUnpacking Sequences and Iterables\n\n|\n\n37\n\ndef main(): print(f'{\"\":15} | {\"latitude\":>9} | {\"longitude\":>9}') for name, _, _, (lat, lon) in metro_areas: if lon <= 0: print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')\n\nif __name__ == '__main__': main()\n\nEach tuple holds a record with four fields, the last of which is a coordinate pair.\n\nBy assigning the last field to a nested tuple, we unpack the coordinates.\n\nThe lon <= 0: test selects only cities in the Western hemisphere.\n\nThe output of Example 2-8 is:\n\n| latitude | longitude Mexico City | 19.4333 | -99.1333 New York-Newark | 40.8086 | -74.0204 São Paulo | -23.5478 | -46.6358\n\nThe target of an unpacking assignment can also be a list, but good use cases are rare. Here is the only one I know: if you have a database query that returns a single record (e.g., the SQL code has a LIMIT 1 clause), then you can unpack and at the same time make sure there’s only one result with this code:\n\n>>> [record] = query_returning_single_row()\n\nIf the record has only one field, you can get it directly, like this:\n\n>>> [[field]] = query_returning_single_row_with_single_field()\n\nBoth of these could be written with tuples, but don’t forget the syntax quirk that single-item tuples must be written with a trailing comma. So the first target would be (record,) and the second ((field,),). In both cases you get a silent bug if you for‐ get a comma.3\n\nNow let’s study pattern matching, which supports even more powerful ways to unpack sequences.\n\nPattern Matching with Sequences The most visible new feature in Python 3.10 is pattern matching with the match/case statement proposed in PEP 634—Structural Pattern Matching: Specification.\n\n3 Thanks to tech reviewer Leonardo Rochael for this example.\n\n38\n\n|\n\nChapter 2: An Array of Sequences\n\nPython core developer Carol Willing wrote the excellent introduc‐ tion to pattern matching in the “Structural Pattern Matching” sec‐ tion of “What’s New In Python 3.10”. You may want to read that quick overview. In this book, I chose to split the coverage of pat‐ tern matching over different chapters, depending on the pattern types: “Pattern Matching with Mappings” on page 81 and “Pattern Matching Class Instances” on page 192. An extended example is in “Pattern Matching in lis.py: A Case Study” on page 669.\n\nHere is a first example of match/case handling sequences. Imagine you are designing a robot that accepts commands sent as sequences of words and numbers, like BEEPER 440 3. After splitting into parts and parsing the numbers, you’d have a message like ['BEEPER', 440, 3]. You could use a method like this to handle such messages:\n\nExample 2-9. Method from an imaginary Robot class\n\ndef handle_command(self, message): match message: case ['BEEPER', frequency, times]: self.beep(times, frequency) case ['NECK', angle]: self.rotate_neck(angle) case ['LED', ident, intensity]: self.leds[ident].set_brightness(ident, intensity) case ['LED', ident, red, green, blue]: self.leds[ident].set_color(ident, red, green, blue) case _: raise InvalidCommand(message)\n\nThe expression after the match keyword is the subject. The subject is the data that Python will try to match to the patterns in each case clause.\n\nThis pattern matches any subject that is a sequence with three items. The first item must be the string 'BEEPER'. The second and third item can be anything, and they will be bound to the variables frequency and times, in that order.\n\nThis matches any subject with two items, the first being 'NECK'.\n\nThis will match a subject with three items starting with 'LED'. If the number of items does not match, Python proceeds to the next case.\n\nAnother sequence pattern starting with 'LED', now with five items—including the 'LED' constant.\n\nPattern Matching with Sequences\n\n|\n\n39\n\nThis is the default case. It will match any subject that did not match a previous pattern. The _ variable is special, as we’ll soon see.\n\nOn the surface, match/case may look like the switch/case statement from the C lan‐ guage—but that’s only half the story.4 One key improvement of match over switch is destructuring—a more advanced form of unpacking. Destructuring is a new word in the Python vocabulary, but it is commonly used in the documentation of languages that support pattern matching—like Scala and Elixir.\n\nAs a first example of destructuring, Example 2-10 shows part of Example 2-8 rewrit‐ ten with match/case.\n\nExample 2-10. Destructuring nested tuples—requires Python ≥ 3.10\n\nmetro_areas = [ ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)), ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)), ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)), ]\n\ndef main(): print(f'{\"\":15} | {\"latitude\":>9} | {\"longitude\":>9}') for record in metro_areas: match record: case [name, _, _, (lat, lon)] if lon <= 0: print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')\n\nThe subject of this match is record— i.e., each of the tuples in metro_areas.\n\nA case clause has two parts: a pattern and an optional guard with the if keyword.\n\nIn general, a sequence pattern matches the subject if:\n\n1. The subject is a sequence and;\n\n2. The subject and the pattern have the same number of items and;\n\n3. Each corresponding item matches, including nested items.\n\n4 In my view, a sequence of if/elif/elif/.../else blocks is a fine replacement for switch/case. It doesn’t\n\nsuffer from the fallthrough and dangling else problems that some language designers irrationally copied from C—decades after they were widely known as the cause of countless bugs.\n\n40\n\n|\n\nChapter 2: An Array of Sequences\n\nFor example, the pattern [name, _, _, (lat, lon)] in Example 2-10 matches a sequence with four items, and the last item must be a two-item sequence.\n\nSequence patterns may be written as tuples or lists or any combination of nested tuples and lists, but it makes no difference which syntax you use: in a sequence pat‐ tern, square brackets and parentheses mean the same thing. I wrote the pattern as a list with a nested 2-tuple just to avoid repeating brackets or parentheses in Example 2-10.\n\nA sequence pattern can match instances of most actual or virtual subclasses of collec tions.abc.Sequence, with the exception of str, bytes, and bytearray.\n\nInstances of str, bytes, and bytearray are not handled as sequen‐ ces in the context of match/case. A match subject of one of those types is treated as an “atomic” value—like the integer 987 is treated as one value, not a sequence of digits. Treating those three types as sequences could cause bugs due to unintended matches. If you want to treat an object of those types as a sequence subject, convert it in the match clause. For example, see tuple(phone) in the following:\n\nmatch tuple(phone): case ['1', *rest]: # North America and Caribbean ... case ['2', *rest]: # Africa and some territories ... case ['3' | '4', *rest]: # Europe ...\n\nIn the standard library, these types are compatible with sequence patterns:\n\nlist memoryview array.array tuple range collections.deque\n\nUnlike unpacking, patterns don’t destructure iterables that are not sequences (such as iterators).\n\nThe _ symbol is special in patterns: it matches any single item in that position, but it is never bound to the value of the matched item. Also, the _ is the only variable that can appear more than once in a pattern.\n\nYou can bind any part of a pattern with a variable using the as keyword:\n\ncase [name, _, _, (lat, lon) as coord]:\n\nGiven the subject ['Shanghai', 'CN', 24.9, (31.1, 121.3)], the preceding pat‐ tern will match, and set the following variables:\n\nPattern Matching with Sequences\n\n|\n\n41\n\nVariable\n\nSet Value\n\nname\n\n'Shanghai'\n\nlat\n\n31.1\n\nlon\n\n121.3\n\ncoord\n\n(31.1, 121.3)\n\nWe can make patterns more specific by adding type information. For example, the following pattern matches the same nested sequence structure as the previous exam‐ ple, but the first item must be an instance of str, and both items in the 2-tuple must be instances of float:\n\ncase [str(name), _, _, (float(lat), float(lon))]:\n\nThe expressions str(name) and float(lat) look like constructor calls, which we’d use to convert name and lat to str and float. But in the context of a pattern, that syntax performs a runtime type check: the preceding pattern will match a four-item sequence in which item 0 must be a str, and item 3 must be a pair of floats. Additionally, the str in item 0 will be bound to the name variable, and the floats in item 3 will be bound to lat and lon, respectively. So, although str(name) borrows the syntax of a constructor call, the semantics are completely different in the context of a pattern. Using arbitrary classes in patterns is covered in “Pattern Matching Class Instances” on page 192.\n\nOn the other hand, if we want to match any subject sequence starting with a str, and ending with a nested sequence of two floats, we can write:\n\ncase [str(name), *_, (float(lat), float(lon))]:\n\nThe *_ matches any number of items, without binding them to a variable. Using *extra instead of *_ would bind the items to extra as a list with 0 or more items.\n\nThe optional guard clause starting with if is evaluated only if the pattern matches, and can reference variables bound in the pattern, as in Example 2-10:\n\nmatch record: case [name, _, _, (lat, lon)] if lon <= 0: print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')\n\nThe nested block with the print statement runs only if the pattern matches and the guard expression is truthy.\n\n42\n\n|\n\nChapter 2: An Array of Sequences\n\nDestructuring with patterns is so expressive that sometimes a match with a single case can make code simpler. Guido van Ros‐ sum has a collection of case/match examples, including one that he titled “A very deep iterable and type match with extraction”.\n\nExample 2-10 is not an improvement over Example 2-8. It’s just an example to con‐ trast two ways of doing the same thing. The next example shows how pattern match‐ ing contributes to clear, concise, and effective code.\n\nPattern Matching Sequences in an Interpreter Peter Norvig of Stanford University wrote lis.py: an interpreter for a subset of the Scheme dialect of the Lisp programming language in 132 lines of beautiful and reada‐ ble Python code. I took Norvig’s MIT-licensed source and updated it to Python 3.10 to showcase pattern matching. In this section, we’ll compare a key part of Norvig’s code—which uses if/elif and unpacking—with a rewrite using match/case.\n\nThe two main functions of lis.py are parse and evaluate.5 The parser takes Scheme parenthesized expressions and returns Python lists. Here are two examples:\n\n>>> parse('(gcd 18 45)') ['gcd', 18, 45] >>> parse(''' ... (define double ... (lambda (n) ... (* n 2))) ... ''') ['define', 'double', ['lambda', ['n'], ['*', 'n', 2]]]\n\nThe evaluator takes lists like these and executes them. The first example is calling a gcd function with 18 and 45 as arguments. When evaluated, it computes the greatest common divisor of the arguments: 9. The second example is defining a function named double with a parameter n. The body of the function is the expression (* n 2). The result of calling a function in Scheme is the value of the last expression in its body.\n\nOur focus here is destructuring sequences, so I will not explain the evaluator actions. See “Pattern Matching in lis.py: A Case Study” on page 669 to learn more about how lis.py works.\n\nExample 2-11 shows Norvig’s evaluator with minor changes, abbreviated to show only the sequence patterns.\n\n5 The latter is named eval in Norvig’s code; I renamed it to avoid confusion with Python’s eval built-in.\n\nPattern Matching with Sequences\n\n|\n\n43\n\nExample 2-11. Matching patterns without match/case\n\ndef evaluate(exp: Expression, env: Environment) -> Any: \"Evaluate an expression in an environment.\" if isinstance(exp, Symbol): # variable reference return env[exp] # ... lines omitted elif exp[0] == 'quote': # (quote exp) (_, x) = exp return x elif exp[0] == 'if': # (if test conseq alt) (_, test, consequence, alternative) = exp if evaluate(test, env): return evaluate(consequence, env) else: return evaluate(alternative, env) elif exp[0] == 'lambda': # (lambda (parm…) body…) (_, parms, *body) = exp return Procedure(parms, body, env) elif exp[0] == 'define': (_, name, value_exp) = exp env[name] = evaluate(value_exp, env) # ... more lines omitted\n\nNote how each elif clause checks the first item of the list, and then unpacks the list, ignoring the first item. The extensive use of unpacking suggests that Norvig is a fan of pattern matching, but he wrote that code originally for Python 2 (though it now works with any Python 3).\n\nUsing match/case in Python ≥ 3.10, we can refactor evaluate as shown in Example 2-12.\n\nExample 2-12. Pattern matching with match/case—requires Python ≥ 3.10\n\ndef evaluate(exp: Expression, env: Environment) -> Any: \"Evaluate an expression in an environment.\" match exp: # ... lines omitted case ['quote', x]: return x case ['if', test, consequence, alternative]: if evaluate(test, env): return evaluate(consequence, env) else: return evaluate(alternative, env) case ['lambda', [*parms], *body] if body: return Procedure(parms, body, env) case ['define', Symbol() as name, value_exp]: env[name] = evaluate(value_exp, env) # ... more lines omitted\n\n44\n\n|\n\nChapter 2: An Array of Sequences\n\ncase _: raise SyntaxError(lispstr(exp))\n\nMatch if subject is a two-item sequence starting with 'quote'.\n\nMatch if subject is a four-item sequence starting with 'if'.\n\nMatch if subject is a sequence of three or more items starting with 'lambda'. The guard ensures that body is not empty.\n\nMatch if subject is a three-item sequence starting with 'define', followed by an instance of Symbol.\n\nIt is good practice to have a catch-all case. In this example, if exp doesn’t match any of the patterns, the expression is malformed, and I raise SyntaxError.\n\nWithout a catch-all, the whole match statement does nothing when a subject does not match any case—and this can be a silent failure.\n\nNorvig deliberately avoided error checking in lis.py to keep the code easy to under‐ stand. With pattern matching, we can add more checks and still keep it readable. For example, in the 'define' pattern, the original code does not ensure that name is an instance of Symbol—that would require an if block, an isinstance call, and more code. Example 2-12 is shorter and safer than Example 2-11.\n\nAlternative patterns for lambda\n\nThis is the syntax of lambda in Scheme, using the syntactic convention that the suffix … means the element may appear zero or more times:\n\n(lambda (parms…) body1 body2…)\n\nA simple pattern for the lambda case 'lambda' would be this:\n\ncase ['lambda', parms, *body] if body:\n\nHowever, that matches any value in the parms position, including the first 'x' in this invalid subject:\n\n['lambda', 'x', ['*', 'x', 2]]\n\nThe nested list after the lambda keyword in Scheme holds the names of the formal parameters for the function, and it must be a list even if it has only one element. It may also be an empty list, if the function takes no parameters—like Python’s ran dom.random().\n\nIn Example 2-12, I made the 'lambda' pattern safer using a nested sequence pattern:\n\nPattern Matching with Sequences\n\n|\n\n45\n\ncase ['lambda', [*parms], *body] if body: return Procedure(parms, body, env)\n\nIn a sequence pattern, * can appear only once per sequence. Here we have two sequences: the outer and the inner.\n\nAdding the characters [*] around parms made the pattern look more like the Scheme syntax it handles, and gave us an additional structural check.\n\nShortcut syntax for function definition\n\nScheme has an alternative define syntax to create a named function without using a nested lambda. This is the syntax:\n\n(define (name parm…) body1 body2…)\n\nThe define keyword is followed by a list with the name of the new function and zero or more parameter names. After that list comes the function body with one or more expressions.\n\nAdding these two lines to the match takes care of the implementation:\n\ncase ['define', [Symbol() as name, *parms], *body] if body: env[name] = Procedure(parms, body, env)\n\nI’d place that case after the other define case in Example 2-12. The order between the define cases is irrelevant in this example because no subject can match both of these patterns: the second element must be a Symbol in the original define case, but it must be a sequence starting with a Symbol in the define shortcut for function definition.\n\nNow consider how much work we’d have adding support for this second define syn‐ tax without the help of pattern matching in Example 2-11. The match statement does a lot more than the switch in C-like languages.\n\nPattern matching is an example of declarative programming: the code describes “what” you want to match, instead of “how” to match it. The shape of the code fol‐ lows the shape of the data, as Table 2-2 illustrates.\n\nTable 2-2. Some Scheme syntactic forms and case patterns to handle them\n\nScheme syntax\n\nSequence pattern\n\n(quote exp)\n\n['quote', exp]\n\n(if test conseq alt)\n\n['if', test, conseq, alt]\n\n(lambda (parms…) body1 body2…)\n\n['lambda', [*parms], *body] if body\n\n(define name exp)\n\n['define', Symbol() as name, exp]\n\n(define (name parms…) body1 body2…)\n\n['define', [Symbol() as name, *parms], *body] if body\n\n46\n\n|\n\nChapter 2: An Array of Sequences\n\nI hope this refactoring of Norvig’s evaluate with pattern matching convinced you that match/case can make your code more readable and safer.\n\nWe’ll see more of lis.py in “Pattern Matching in lis.py: A Case Study” on page 669, when we’ll review the complete match/case example in evaluate. If you want to learn more about Norvig’s lis.py, read his wonderful post “(How to Write a (Lisp) Interpreter (in Python))”.\n\nThis concludes our first tour of unpacking, destructuring, and pattern matching with sequences. We’ll cover other types of patterns in later chapters.\n\nEvery Python programmer knows that sequences can be sliced using the s[a:b] syn‐ tax. We now turn to some less well-known facts about slicing.\n\nSlicing A common feature of list, tuple, str, and all sequence types in Python is the sup‐ port of slicing operations, which are more powerful than most people realize.\n\nIn this section, we describe the use of these advanced forms of slicing. Their imple‐ mentation in a user-defined class will be covered in Chapter 12, in keeping with our philosophy of covering ready-to-use classes in this part of the book, and creating new classes in Part III.\n\nWhy Slices and Ranges Exclude the Last Item The Pythonic convention of excluding the last item in slices and ranges works well with the zero-based indexing used in Python, C, and many other languages. Some convenient features of the convention are:\n\nIt’s easy to see the length of a slice or range when only the stop position is given: range(3) and my_list[:3] both produce three items.\n\nIt’s easy to compute the length of a slice or range when start and stop are given: just subtract stop - start.\n\nIt’s easy to split a sequence in two parts at any index x, without overlapping: sim‐ ply get my_list[:x] and my_list[x:]. For example:\n\n>>> l = [10, 20, 30, 40, 50, 60] >>> l[:2] # split at 2 [10, 20] >>> l[2:] [30, 40, 50, 60] >>> l[:3] # split at 3 [10, 20, 30]\n\nSlicing\n\n|\n\n47\n\n>>> l[3:] [40, 50, 60]\n\nThe best arguments for this convention were written by the Dutch computer scientist Edsger W. Dijkstra (see the last reference in “Further Reading” on page 71).\n\nNow let’s take a close look at how Python interprets slice notation.\n\nSlice Objects This is no secret, but worth repeating just in case: s[a:b:c] can be used to specify a stride or step c, causing the resulting slice to skip items. The stride can also be nega‐ tive, returning items in reverse. Three examples make this clear:\n\n>>> s = 'bicycle' >>> s[::3] 'bye' >>> s[::-1] 'elcycib' >>> s[::-2] 'eccb'\n\nAnother example was shown in Chapter 1 when we used deck[12::13] to get all the aces in the unshuffled deck:\n\n>>> deck[12::13] [Card(rank='A', suit='spades'), Card(rank='A', suit='diamonds'), Card(rank='A', suit='clubs'), Card(rank='A', suit='hearts')]\n\nThe notation a:b:c is only valid within [] when used as the indexing or subscript operator, and it produces a slice object: slice(a, b, c). As we will see in “How Slic‐ ing Works” on page 404, to evaluate the expression seq[start:stop:step], Python calls seq.__getitem__(slice(start, stop, step)). Even if you are not imple‐ menting your own sequence types, knowing about slice objects is useful because it lets you assign names to slices, just like spreadsheets allow naming of cell ranges.\n\nSuppose you need to parse flat-file data like the invoice shown in Example 2-13. Instead of filling your code with hardcoded slices, you can name them. See how read‐ able this makes the for loop at the end of the example.\n\nExample 2-13. Line items from a flat-file invoice\n\n>>> invoice = \"\"\" ... 0.....6.................................40........52...55........ ... 1909 Pimoroni PiBrella $17.50 3 $52.50 ... 1489 6mm Tactile Switch x20 $4.95 2 $9.90 ... 1510 Panavise Jr. - PV-201 $28.00 1 $28.00 ... 1601 PiTFT Mini Kit 320x240 $34.95 1 $34.95 ... \"\"\"\n\n48\n\n|\n\nChapter 2: An Array of Sequences\n\n>>> SKU = slice(0, 6) >>> DESCRIPTION = slice(6, 40) >>> UNIT_PRICE = slice(40, 52) >>> QUANTITY = slice(52, 55) >>> ITEM_TOTAL = slice(55, None) >>> line_items = invoice.split('\\n')[2:] >>> for item in line_items: ... print(item[UNIT_PRICE], item[DESCRIPTION]) ... $17.50 Pimoroni PiBrella $4.95 6mm Tactile Switch x20 $28.00 Panavise Jr. - PV-201 $34.95 PiTFT Mini Kit 320x240\n\nWe’ll come back to slice objects when we discuss creating your own collections in “Vector Take #2: A Sliceable Sequence” on page 403. Meanwhile, from a user perspec‐ tive, slicing includes additional features such as multidimensional slices and ellipsis (...) notation. Read on.\n\nMultidimensional Slicing and Ellipsis The [] operator can also take multiple indexes or slices separated by commas. The __getitem__ and __setitem__ special methods that handle the [] operator simply receive the indices in a[i, j] as a tuple. In other words, to evaluate a[i, j], Python calls a.__getitem__((i, j)).\n\nThis is used, for instance, in the external NumPy package, where items of a two- dimensional numpy.ndarray can be fetched using the syntax a[i, j] and a two-dimensional slice obtained with an expression like a[m:n, k:l]. Example 2-22 later in this chapter shows the use of this notation.\n\nExcept for memoryview, the built-in sequence types in Python are one-dimensional, so they support only one index or slice, and not a tuple of them.6\n\nThe ellipsis—written with three full stops (...) and not … (Unicode U+2026)—is rec‐ ognized as a token by the Python parser. It is an alias to the Ellipsis object, the sin‐ gle instance of the ellipsis class.7 As such, it can be passed as an argument to functions and as part of a slice specification, as in f(a, ..., z) or a[i:...]. NumPy uses ... as a shortcut when slicing arrays of many dimensions; for example,\n\n6 In “Memory Views” on page 62 we show that specially constructed memory views can have more than one\n\ndimension.\n\n7 No, I did not get this backwards: the ellipsis class name is really all lowercase, and the instance is a built-in\n\nnamed Ellipsis, just like bool is lowercase but its instances are True and False.\n\nSlicing\n\n|\n\n49\n\nif x is a four-dimensional array, x[i, ...] is a shortcut for x[i, :, :, :,]. See “NumPy quickstart” to learn more about this.\n\nAt the time of this writing, I am unaware of uses of Ellipsis or multidimensional indexes and slices in the Python standard library. If you spot one, let me know. These syntactic features exist to support user-defined types and extensions such as NumPy.\n\nSlices are not just useful to extract information from sequences; they can also be used to change mutable sequences in place—that is, without rebuilding them from scratch.\n\nAssigning to Slices Mutable sequences can be grafted, excised, and otherwise modified in place using slice notation on the lefthand side of an assignment statement or as the target of a del statement. The next few examples give an idea of the power of this notation:\n\n>>> l = list(range(10)) >>> l [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> l[2:5] = [20, 30] >>> l [0, 1, 20, 30, 5, 6, 7, 8, 9] >>> del l[5:7] >>> l [0, 1, 20, 30, 5, 8, 9] >>> l[3::2] = [11, 22] >>> l [0, 1, 20, 11, 5, 22, 9] >>> l[2:5] = 100 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can only assign an iterable >>> l[2:5] = [100] >>> l [0, 1, 100, 22, 9]\n\nWhen the target of the assignment is a slice, the righthand side must be an itera‐ ble object, even if it has just one item.\n\nEvery coder knows that concatenation is a common operation with sequences. Intro‐ ductory Python tutorials explain the use of + and * for that purpose, but there are some subtle details on how they work, which we cover next.\n\nUsing + and * with Sequences Python programmers expect that sequences support + and *. Usually both operands of + must be of the same sequence type, and neither of them is modified, but a new sequence of that same type is created as result of the concatenation.\n\n50\n\n|\n\nChapter 2: An Array of Sequences\n\nTo concatenate multiple copies of the same sequence, multiply it by an integer. Again, a new sequence is created:\n\n>>> l = [1, 2, 3] >>> l * 5 [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] >>> 5 * 'abcd' 'abcdabcdabcdabcdabcd'\n\nBoth + and * always create a new object, and never change their operands.\n\nBeware of expressions like a * n when a is a sequence containing mutable items, because the result may surprise you. For example, trying to initialize a list of lists as my_list = [[]] * 3 will result in a list with three references to the same inner list, which is proba‐ bly not what you want.\n\nThe next section covers the pitfalls of trying to use * to initialize a list of lists.\n\nBuilding Lists of Lists Sometimes we need to initialize a list with a certain number of nested lists—for example, to distribute students in a list of teams or to represent squares on a game board. The best way of doing so is with a list comprehension, as in Example 2-14.\n\nExample 2-14. A list with three lists of length 3 can represent a tic-tac-toe board\n\n>>> board = [['_'] * 3 for i in range(3)] >>> board [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']] >>> board[1][2] = 'X' >>> board [['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]\n\nCreate a list of three lists of three items each. Inspect the structure.\n\nPlace a mark in row 1, column 2, and check the result.\n\nA tempting, but wrong, shortcut is doing it like Example 2-15.\n\nExample 2-15. A list with three references to the same list is useless\n\n>>> weird_board = [['_'] * 3] * 3 >>> weird_board [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']] >>> weird_board[1][2] = 'O'\n\nUsing + and * with Sequences\n\n|\n\n51\n\n>>> weird_board [['_', '_', 'O'], ['_', '_', 'O'], ['_', '_', 'O']]\n\nThe outer list is made of three references to the same inner list. While it is unchanged, all seems right.\n\nPlacing a mark in row 1, column 2, reveals that all rows are aliases referring to the same object.\n\nThe problem with Example 2-15 is that, in essence, it behaves like this code:\n\nrow = ['_'] * 3 board = [] for i in range(3): board.append(row)\n\nThe same row is appended three times to board.\n\nOn the other hand, the list comprehension from Example 2-14 is equivalent to this code:\n\n>>> board = [] >>> for i in range(3): ... row = ['_'] * 3 ... board.append(row) ... >>> board [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']] >>> board[2][0] = 'X' >>> board [['_', '_', '_'], ['_', '_', '_'], ['X', '_', '_']]\n\nEach iteration builds a new row and appends it to board.\n\nOnly row 2 is changed, as expected.\n\nIf either the problem or the solution in this section is not clear to you, relax. Chapter 6 was written to clarify the mechanics and pit‐ falls of references and mutable objects.\n\nSo far we have discussed the use of the plain + and * operators with sequences, but there are also the += and *= operators, which produce very different results, depend‐ ing on the mutability of the target sequence. The following section explains how that works.\n\n52\n\n|\n\nChapter 2: An Array of Sequences\n\nAugmented Assignment with Sequences The augmented assignment operators += and *= behave quite differently, depending on the first operand. To simplify the discussion, we will focus on augmented addition first (+=), but the concepts also apply to *= and to other augmented assignment operators.\n\nThe special method that makes += work is __iadd__ (for “in-place addition”).\n\nHowever, if __iadd__ is not implemented, Python falls back to calling __add__. Con‐ sider this simple expression:\n\n>>> a += b\n\nIf a implements __iadd__, that will be called. In the case of mutable sequences (e.g., list, bytearray, array.array), a will be changed in place (i.e., the effect will be sim‐ ilar to a.extend(b)). However, when a does not implement __iadd__, the expression a += b has the same effect as a = a + b: the expression a + b is evaluated first, producing a new object, which is then bound to a. In other words, the identity of the object bound to a may or may not change, depending on the availability of __iadd__.\n\nIn general, for mutable sequences, it is a good bet that __iadd__ is implemented and that += happens in place. For immutable sequences, clearly there is no way for that to happen.\n\nWhat I just wrote about += also applies to *=, which is implemented via __imul__. The __iadd__ and __imul__ special methods are discussed in Chapter 16. Here is a demonstration of *= with a mutable sequence and then an immutable one:\n\n>>> l = [1, 2, 3] >>> id(l) 4311953800 >>> l *= 2 >>> l [1, 2, 3, 1, 2, 3] >>> id(l) 4311953800 >>> t = (1, 2, 3) >>> id(t) 4312681568 >>> t *= 2 >>> id(t) 4301348296\n\nID of the initial list.\n\nAfter multiplication, the list is the same object, with new items appended.\n\nUsing + and * with Sequences\n\n|\n\n53\n\nID of the initial tuple.\n\nAfter multiplication, a new tuple was created.\n\nRepeated concatenation of immutable sequences is inefficient, because instead of just appending new items, the interpreter has to copy the whole target sequence to create a new one with the new items concatenated.8\n\nWe’ve seen common use cases for +=. The next section shows an intriguing corner case that highlights what “immutable” really means in the context of tuples.\n\nA += Assignment Puzzler Try to answer without using the console: what is the result of evaluating the two expressions in Example 2-16?9\n\nExample 2-16. A riddle\n\n>>> t = (1, 2, [30, 40]) >>> t[2] += [50, 60]\n\nWhat happens next? Choose the best answer:\n\nA. t becomes (1, 2, [30, 40, 50, 60]). B. TypeError is raised with the message 'tuple' object does not support item\n\nassignment.\n\nC. Neither.\n\nD. Both A and B.\n\nWhen I saw this, I was pretty sure the answer was B, but it’s actually D, “Both A and B”! Example 2-17 is the actual output from a Python 3.9 console.10\n\n8 str is an exception to this description. Because string building with += in loops is so common in real codeba‐ ses, CPython is optimized for this use case. Instances of str are allocated in memory with extra room, so that concatenation does not require copying the whole string every time.\n\n9 Thanks to Leonardo Rochael and Cesar Kawakami for sharing this riddle at the 2013 PythonBrasil\n\nConference.\n\n10 Readers suggested that the operation in the example can be done with t[2].extend([50,60]), without errors. I am aware of that, but my intent is to show the strange behavior of the += operator in this case.\n\n54\n\n|\n\nChapter 2: An Array of Sequences",
      "page_number": 59
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 82-100)",
      "start_page": 82,
      "end_page": 100,
      "detection_method": "synthetic",
      "content": "Example 2-17. The unexpected result: item t2 is changed and an exception is raised\n\n>>> t = (1, 2, [30, 40]) >>> t[2] += [50, 60] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'tuple' object does not support item assignment >>> t (1, 2, [30, 40, 50, 60])\n\nOnline Python Tutor is an awesome online tool to visualize how Python works in detail. Figure 2-5 is a composite of two screenshots showing the initial and final states of the tuple t from Example 2-17.\n\nFigure 2-5. Initial and final state of the tuple assignment puzzler (diagram generated by Online Python Tutor).\n\nIf you look at the bytecode Python generates for the expression s[a] += b (Example 2-18), it becomes clear how that happens.\n\nExample 2-18. Bytecode for the expression s[a] += b\n\n>>> dis.dis('s[a] += b') 1 0 LOAD_NAME 0 (s) 3 LOAD_NAME 1 (a) 6 DUP_TOP_TWO 7 BINARY_SUBSCR 8 LOAD_NAME 2 (b) 11 INPLACE_ADD 12 ROT_THREE 13 STORE_SUBSCR 14 LOAD_CONST 0 (None) 17 RETURN_VALUE\n\nUsing + and * with Sequences\n\n|\n\n55\n\nPut the value of s[a] on TOS (Top Of Stack).\n\nPerform TOS += b. This succeeds if TOS refers to a mutable object (it’s a list, in Example 2-17).\n\nAssign s[a] = TOS. This fails if s is immutable (the t tuple in Example 2-17).\n\nThis example is quite a corner case—in 20 years using Python, I have never seen this strange behavior actually bite somebody.\n\nI take three lessons from this:\n\nAvoid putting mutable items in tuples.\n\nAugmented assignment is not an atomic operation—we just saw it throwing an exception after doing part of its job.\n\nInspecting Python bytecode is not too difficult, and can be helpful to see what is going on under the hood.\n\nAfter witnessing the subtleties of using + and * for concatenation, we can change the subject to another essential operation with sequences: sorting.\n\nlist.sort Versus the sorted Built-In The list.sort method sorts a list in place—that is, without making a copy. It returns None to remind us that it changes the receiver11 and does not create a new list. This is an important Python API convention: functions or methods that change an object in place should return None to make it clear to the caller that the receiver was changed, and no new object was created. Similar behavior can be seen, for example, in the ran dom.shuffle(s) function, which shuffles the mutable sequence s in place, and returns None.\n\nThe convention of returning None to signal in-place changes has a drawback: we cannot cascade calls to those methods. In contrast, methods that return new objects (e.g., all str methods) can be cas‐ caded in the fluent interface style. See Wikipedia’s “Fluent inter‐ face” entry for further description of this topic.\n\nIn contrast, the built-in function sorted creates a new list and returns it. It accepts any iterable object as an argument, including immutable sequences and generators\n\n11 Receiver is the target of a method call, the object bound to self in the method body.\n\n56\n\n|\n\nChapter 2: An Array of Sequences\n\n(see Chapter 17). Regardless of the type of iterable given to sorted, it always returns a newly created list.\n\nBoth list.sort and sorted take two optional, keyword-only arguments:\n\nreverse\n\nIf True, the items are returned in descending order (i.e., by reversing the compar‐ ison of the items). The default is False.\n\nkey\n\nA one-argument function that will be applied to each item to produce its sorting key. For example, when sorting a list of strings, key=str.lower can be used to perform a case-insensitive sort, and key=len will sort the strings by character length. The default is the identity function (i.e., the items themselves are compared).\n\nYou can also use the optional keyword parameter key with the min() and max() built-ins and with other functions from the stan‐ dard library (e.g., itertools.groupby() and heapq.nlargest()).\n\nHere are a few examples to clarify the use of these functions and keyword arguments. The examples also demonstrate that Python’s sorting algorithm is stable (i.e., it pre‐ serves the relative ordering of items that compare equally):12\n\n>>> fruits = ['grape', 'raspberry', 'apple', 'banana'] >>> sorted(fruits) ['apple', 'banana', 'grape', 'raspberry'] >>> fruits ['grape', 'raspberry', 'apple', 'banana'] >>> sorted(fruits, reverse=True) ['raspberry', 'grape', 'banana', 'apple'] >>> sorted(fruits, key=len) ['grape', 'apple', 'banana', 'raspberry'] >>> sorted(fruits, key=len, reverse=True) ['raspberry', 'banana', 'grape', 'apple'] >>> fruits ['grape', 'raspberry', 'apple', 'banana'] >>> fruits.sort() >>> fruits ['apple', 'banana', 'grape', 'raspberry']\n\n12 Python’s main sorting algorithm is named Timsort after its creator, Tim Peters. For a bit of Timsort trivia, see\n\nthe “Soapbox” on page 73.\n\nlist.sort Versus the sorted Built-In\n\n|\n\n57\n\nThis produces a new list of strings sorted alphabetically.13\n\nInspecting the original list, we see it is unchanged.\n\nThis is the previous “alphabetical” ordering, reversed.\n\nA new list of strings, now sorted by length. Because the sorting algorithm is stable, “grape” and “apple,” both of length 5, are in the original order.\n\nThese are the strings sorted by length in descending order. It is not the reverse of the previous result because the sorting is stable, so again “grape” appears before “apple.”\n\nSo far, the ordering of the original fruits list has not changed.\n\nThis sorts the list in place, and returns None (which the console omits).\n\nNow fruits is sorted.\n\nBy default, Python sorts strings lexicographically by character code. That means ASCII uppercase letters will come before lowercase let‐ ters, and non-ASCII characters are unlikely to be sorted in a sensi‐ ble way. “Sorting Unicode Text” on page 148 covers proper ways of sorting text as humans would expect.\n\nOnce your sequences are sorted, they can be very efficiently searched. A binary search algorithm is already provided in the bisect module of the Python standard library. That module also includes the bisect.insort function, which you can use to make sure that your sorted sequences stay sorted. You’ll find an illustrated introduction to the bisect module in the “Managing Ordered Sequences with Bisect” post in the flu‐ entpython.com companion website.\n\nMuch of what we have seen so far in this chapter applies to sequences in general, not just lists or tuples. Python programmers sometimes overuse the list type because it is so handy—I know I’ve done it. For example, if you are processing large lists of numbers, you should consider using arrays instead. The remainder of the chapter is devoted to alternatives to lists and tuples.\n\n13 The words in this example are sorted alphabetically because they are 100% made of lowercase ASCII charac‐\n\nters. See the warning after the example.\n\n58\n\n|\n\nChapter 2: An Array of Sequences\n\nWhen a List Is Not the Answer The list type is flexible and easy to use, but depending on specific requirements, there are better options. For example, an array saves a lot of memory when you need to handle millions of floating-point values. On the other hand, if you are constantly adding and removing items from opposite ends of a list, it’s good to know that a deque (double-ended queue) is a more efficient FIFO14 data structure.\n\nIf your code frequently checks whether an item is present in a col‐ lection (e.g., item in my_collection), consider using a set for my_collection, especially if it holds a large number of items. Sets are optimized for fast membership checking. They are also iterable, but they are not sequences because the ordering of set items is unspecified. We cover them in Chapter 3.\n\nFor the remainder of this chapter, we discuss mutable sequence types that can replace lists in many cases, starting with arrays.\n\nArrays If a list only contains numbers, an array.array is a more efficient replacement. Arrays support all mutable sequence operations (including .pop, .insert, and .extend), as well as additional methods for fast loading and saving, such as .frombytes and .tofile.\n\nA Python array is as lean as a C array. As shown in Figure 2-1, an array of float values does not hold full-fledged float instances, but only the packed bytes repre‐ senting their machine values—similar to an array of double in the C language. When creating an array, you provide a typecode, a letter to determine the underlying C type used to store each item in the array. For example, b is the typecode for what C calls a signed char, an integer ranging from –128 to 127. If you create an array('b'), then each item will be stored in a single byte and interpreted as an inte‐ ger. For large sequences of numbers, this saves a lot of memory. And Python will not let you put any number that does not match the type for the array.\n\nExample 2-19 shows creating, saving, and loading an array of 10 million floating- point random numbers.\n\n14 First in, first out—the default behavior of queues.\n\nWhen a List Is Not the Answer\n\n|\n\n59\n\nExample 2-19. Creating, saving, and loading a large array of floats\n\n>>> from array import array >>> from random import random >>> floats = array('d', (random() for i in range(10**7))) >>> floats[-1] 0.07802343889111107 >>> fp = open('floats.bin', 'wb') >>> floats.tofile(fp) >>> fp.close() >>> floats2 = array('d') >>> fp = open('floats.bin', 'rb') >>> floats2.fromfile(fp, 10**7) >>> fp.close() >>> floats2[-1] 0.07802343889111107 >>> floats2 == floats True\n\nImport the array type.\n\nCreate an array of double-precision floats (typecode 'd') from any iterable object —in this case, a generator expression.\n\nInspect the last number in the array.\n\nSave the array to a binary file.\n\nCreate an empty array of doubles.\n\nRead 10 million numbers from the binary file.\n\nInspect the last number in the array.\n\nVerify that the contents of the arrays match.\n\nAs you can see, array.tofile and array.fromfile are easy to use. If you try the example, you’ll notice they are also very fast. A quick experiment shows that it takes about 0.1 seconds for array.fromfile to load 10 million double-precision floats from a binary file created with array.tofile. That is nearly 60 times faster than reading the numbers from a text file, which also involves parsing each line with the float built-in. Saving with array.tofile is about seven times faster than writing one float per line in a text file. In addition, the size of the binary file with 10 million dou‐ bles is 80,000,000 bytes (8 bytes per double, zero overhead), while the text file has 181,515,739 bytes for the same data.\n\n60\n\n|\n\nChapter 2: An Array of Sequences\n\nFor the specific case of numeric arrays representing binary data, such as raster images, Python has the bytes and bytearray types discussed in Chapter 4.\n\nWe wrap up this section on arrays with Table 2-3, comparing the features of list and array.array.\n\nTable 2-3. Methods and attributes found in list or array (deprecated array methods and those also implemented by object are omitted for brevity)\n\nlist\n\narray\n\ns.__add__(s2)\n\n\n\n\n\ns + s2—concatenation\n\ns.__iadd__(s2)\n\n\n\n\n\ns += s2—in-place concatenation\n\ns.append(e)\n\n\n\n\n\nAppend one element after last\n\ns.byteswap()\n\n\n\nSwap bytes of all items in array for endianness conversion\n\ns.clear()\n\n\n\nDelete all items\n\ns.__contains__(e)\n\n\n\n\n\ne in s\n\ns.copy()\n\n\n\nShallow copy of the list\n\ns.__copy__()\n\n\n\nSupport for copy.copy\n\ns.count(e)\n\n\n\n\n\nCount occurrences of an element\n\ns.__deepcopy__()\n\n\n\nOptimized support for copy.deepcopy\n\ns.__delitem__(p)\n\n\n\n\n\nRemove item at position p\n\ns.extend(it)\n\n\n\n\n\nAppend items from iterable it\n\ns.frombytes(b)\n\n\n\nAppend items from byte sequence interpreted as packed machine values\n\ns.fromfile(f, n)\n\n\n\nAppend n items from binary file f interpreted as packed machine values\n\ns.fromlist(l)\n\n\n\nAppend items from list; if one causes TypeError, none are appended\n\ns.__getitem__(p)\n\n\n\n\n\ns[p]—get item or slice at position\n\ns.index(e)\n\n\n\n\n\nFind position of first occurrence of e\n\ns.insert(p, e)\n\n\n\n\n\nInsert element e before the item at position p\n\ns.itemsize\n\n\n\nLength in bytes of each array item\n\ns.__iter__()\n\n\n\n\n\nGet iterator\n\ns.__len__()\n\n\n\n\n\nlen(s)—number of items\n\ns.__mul__(n)\n\n\n\n\n\ns * n—repeated concatenation\n\ns.__imul__(n)\n\ns.__rmul__(n)\n\n\n\n\n\n\n\n\n\ns *= n—in-place repeated concatenation n * s—reversed repeated concatenationa\n\ns.pop([p])\n\n\n\n\n\nRemove and return item at position p (default: last)\n\ns.remove(e)\n\n\n\n\n\nRemove first occurrence of element e by value\n\ns.reverse()\n\n\n\n\n\nReverse the order of the items in place\n\ns.__reversed__()\n\n\n\nGet iterator to scan items from last to first\n\ns.__setitem__(p, e)\n\n\n\n\n\ns[p] = e—put e in position p, overwriting existing item or slice\n\nWhen a List Is Not the Answer\n\n|\n\n61\n\nlist\n\narray\n\ns.sort([key], [reverse]) ●\n\nSort items in place with optional keyword arguments key and reverse\n\ns.tobytes()\n\n\n\nReturn items as packed machine values in a bytes object\n\ns.tofile(f)\n\n\n\nSave items as packed machine values to binary file f\n\ns.tolist()\n\n\n\nReturn items as numeric objects in a list\n\ns.typecode a Reversed operators are explained in Chapter 16.\n\n\n\nOne-character string identifying the C type of the items\n\nAs of Python 3.10, the array type does not have an in-place sort method like list.sort(). If you need to sort an array, use the built-in sorted function to rebuild the array:\n\na = array.array(a.typecode, sorted(a))\n\nTo keep a sorted array sorted while adding items to it, use the bisect.insort function.\n\nIf you do a lot of work with arrays and don’t know about memoryview, you’re missing out. See the next topic.\n\nMemory Views The built-in memoryview class is a shared-memory sequence type that lets you handle slices of arrays without copying bytes. It was inspired by the NumPy library (which we’ll discuss shortly in “NumPy” on page 64). Travis Oliphant, lead author of NumPy, answers the question, “When should a memoryview be used?” like this:\n\nA memoryview is essentially a generalized NumPy array structure in Python itself (without the math). It allows you to share memory between data-structures (things like PIL images, SQLite databases, NumPy arrays, etc.) without first copying. This is very important for large data sets.\n\nUsing notation similar to the array module, the memoryview.cast method lets you change the way multiple bytes are read or written as units without moving bits around. memoryview.cast returns yet another memoryview object, always sharing the same memory.\n\nExample 2-20 shows how to create alternate views on the same array of 6 bytes, to operate on it as a 2×3 matrix or a 3×2 matrix.\n\nExample 2-20. Handling 6 bytes of memory as 1×6, 2×3, and 3×2 views\n\n>>> from array import array >>> octets = array('B', range(6))\n\n62\n\n|\n\nChapter 2: An Array of Sequences\n\n>>> m1 = memoryview(octets) >>> m1.tolist() [0, 1, 2, 3, 4, 5] >>> m2 = m1.cast('B', [2, 3]) >>> m2.tolist() [[0, 1, 2], [3, 4, 5]] >>> m3 = m1.cast('B', [3, 2]) >>> m3.tolist() [[0, 1], [2, 3], [4, 5]] >>> m2[1,1] = 22 >>> m3[1,1] = 33 >>> octets array('B', [0, 1, 2, 33, 22, 5])\n\nBuild array of 6 bytes (typecode 'B').\n\nBuild memoryview from that array, then export it as a list.\n\nBuild new memoryview from that previous one, but with 2 rows and 3 columns.\n\nYet another memoryview, now with 3 rows and 2 columns.\n\nOverwrite byte in m2 at row 1, column 1 with 22.\n\nOverwrite byte in m3 at row 1, column 1 with 33.\n\nDisplay original array, proving that the memory was shared among octets, m1, m2, and m3.\n\nThe awesome power of memoryview can also be used to corrupt. Example 2-21 shows how to change a single byte of an item in an array of 16-bit integers.\n\nExample 2-21. Changing the value of a 16-bit integer array item by poking one of its bytes\n\n>>> numbers = array.array('h', [-2, -1, 0, 1, 2]) >>> memv = memoryview(numbers) >>> len(memv) 5 >>> memv[0] -2 >>> memv_oct = memv.cast('B') >>> memv_oct.tolist() [254, 255, 255, 255, 0, 0, 1, 0, 2, 0] >>> memv_oct[5] = 4 >>> numbers array('h', [-2, -1, 1024, 1, 2])\n\nWhen a List Is Not the Answer\n\n|\n\n63\n\nBuild memoryview from array of 5 16-bit signed integers (typecode 'h').\n\nmemv sees the same 5 items in the array.\n\nCreate memv_oct by casting the elements of memv to bytes (typecode 'B').\n\nExport elements of memv_oct as a list of 10 bytes, for inspection.\n\nAssign value 4 to byte offset 5.\n\nNote the change to numbers: a 4 in the most significant byte of a 2-byte unsigned integer is 1024.\n\nYou’ll find an example of inspecting memoryview with the struct package at fluentpython.com: “Parsing binary records with struct”.\n\nMeanwhile, if you are doing advanced numeric processing in arrays, you should be using the NumPy libraries. We’ll take a brief look at them right away.\n\nNumPy Throughout this book, I make a point of highlighting what is already in the Python standard library so you can make the most of it. But NumPy is so awesome that a detour is warranted.\n\nFor advanced array and matrix operations, NumPy is the reason why Python became mainstream in scientific computing applications. NumPy implements multi- dimensional, homogeneous arrays and matrix types that hold not only numbers but also user-defined records, and provides efficient element-wise operations.\n\nSciPy is a library, written on top of NumPy, offering many scientific computing algo‐ rithms from linear algebra, numerical calculus, and statistics. SciPy is fast and reliable because it leverages the widely used C and Fortran codebase from the Netlib Reposi‐ tory. In other words, SciPy gives scientists the best of both worlds: an interactive prompt and high-level Python APIs, together with industrial-strength number- crunching functions optimized in C and Fortran.\n\nAs a very brief NumPy demo, Example 2-22 shows some basic operations with two- dimensional arrays.\n\n64\n\n|\n\nChapter 2: An Array of Sequences\n\nExample 2-22. Basic operations with rows and columns in a numpy.ndarray\n\n>>> import numpy as np >>> a = np.arange(12) >>> a array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) >>> type(a) <class 'numpy.ndarray'> >>> a.shape (12,) >>> a.shape = 3, 4 >>> a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) >>> a[2] array([ 8, 9, 10, 11]) >>> a[2, 1] 9 >>> a[:, 1] array([1, 5, 9]) >>> a.transpose() array([[ 0, 4, 8], [ 1, 5, 9], [ 2, 6, 10], [ 3, 7, 11]])\n\nImport NumPy, after installing (it’s not in the Python standard library). Conven‐ tionally, numpy is imported as np.\n\nBuild and inspect a numpy.ndarray with integers 0 to 11.\n\nInspect the dimensions of the array: this is a one-dimensional, 12-element array.\n\nChange the shape of the array, adding one dimension, then inspecting the result.\n\nGet row at index 2.\n\nGet element at index 2, 1.\n\nGet column at index 1.\n\nCreate a new array by transposing (swapping columns with rows).\n\nNumPy also supports high-level operations for loading, saving, and operating on all elements of a numpy.ndarray:\n\n>>> import numpy >>> floats = numpy.loadtxt('floats-10M-lines.txt')\n\nWhen a List Is Not the Answer\n\n|\n\n65\n\n>>> floats[-3:] array([ 3016362.69195522, 535281.10514262, 4566560.44373946]) >>> floats *= .5 >>> floats[-3:] array([ 1508181.34597761, 267640.55257131, 2283280.22186973]) >>> from time import perf_counter as pc >>> t0 = pc(); floats /= 3; pc() - t0 0.03690556302899495 >>> numpy.save('floats-10M', floats) >>> floats2 = numpy.load('floats-10M.npy', 'r+') >>> floats2 *= 6 >>> floats2[-3:] memmap([ 3016362.69195522, 535281.10514262, 4566560.44373946])\n\nLoad 10 million floating-point numbers from a text file.\n\nUse sequence slicing notation to inspect the last three numbers.\n\nMultiply every element in the floats array by .5 and inspect the last three elements again.\n\nImport the high-resolution performance measurement timer (available since Python 3.3).\n\nDivide every element by 3; the elapsed time for 10 million floats is less than 40 milliseconds.\n\nSave the array in a .npy binary file.\n\nLoad the data as a memory-mapped file into another array; this allows efficient processing of slices of the array even if it does not fit entirely in memory.\n\nInspect the last three elements after multiplying every element by 6.\n\nThis was just an appetizer.\n\nNumPy and SciPy are formidable libraries, and are the foundation of other awesome tools such as the Pandas—which implements efficient array types that can hold non‐ numeric data and provides import/export functions for many different formats, like .csv, .xls, SQL dumps, HDF5, etc.—and scikit-learn, currently the most widely used Machine Learning toolset. Most NumPy and SciPy functions are implemented in C or C++, and can leverage all CPU cores because they release Python’s GIL (Global Interpreter Lock). The Dask project supports parallelizing NumPy, Pandas, and scikit-learn processing across clusters of machines. These packages deserve entire books about them. This is not one of those books. But no overview of Python sequen‐ ces would be complete without at least a quick look at NumPy arrays.\n\n66\n\n|\n\nChapter 2: An Array of Sequences\n\nHaving looked at flat sequences—standard arrays and NumPy arrays—we now turn to a completely different set of replacements for the plain old list: queues.\n\nDeques and Other Queues The .append and .pop methods make a list usable as a stack or a queue (if you use .append and .pop(0), you get FIFO behavior). But inserting and removing from the head of a list (the 0-index end) is costly because the entire list must be shifted in memory.\n\nThe class collections.deque is a thread-safe double-ended queue designed for fast inserting and removing from both ends. It is also the way to go if you need to keep a list of “last seen items” or something of that nature, because a deque can be bounded —i.e., created with a fixed maximum length. If a bounded deque is full, when you add a new item, it discards an item from the opposite end. Example 2-23 shows some typ‐ ical operations performed on a deque.\n\nExample 2-23. Working with a deque\n\n>>> from collections import deque >>> dq = deque(range(10), maxlen=10) >>> dq deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10) >>> dq.rotate(3) >>> dq deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10) >>> dq.rotate(-4) >>> dq deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10) >>> dq.appendleft(-1) >>> dq deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10) >>> dq.extend([11, 22, 33]) >>> dq deque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10) >>> dq.extendleft([10, 20, 30, 40]) >>> dq deque([40, 30, 20, 10, 3, 4, 5, 6, 7, 8], maxlen=10)\n\nThe optional maxlen argument sets the maximum number of items allowed in this instance of deque; this sets a read-only maxlen instance attribute.\n\nRotating with n > 0 takes items from the right end and prepends them to the left; when n < 0 items are taken from left and appended to the right.\n\nWhen a List Is Not the Answer\n\n|\n\n67\n\nAppending to a deque that is full (len(d) == d.maxlen) discards items from the other end; note in the next line that the 0 is dropped.\n\nAdding three items to the right pushes out the leftmost -1, 1, and 2.\n\nNote that extendleft(iter) works by appending each successive item of the iter argument to the left of the deque, therefore the final position of the items is reversed.\n\nTable 2-4 compares the methods that are specific to list and deque (removing those that also appear in object).\n\nNote that deque implements most of the list methods, and adds a few that are spe‐ cific to its design, like popleft and rotate. But there is a hidden cost: removing items from the middle of a deque is not as fast. It is really optimized for appending and popping from the ends.\n\nThe append and popleft operations are atomic, so deque is safe to use as a FIFO queue in multithreaded applications without the need for locks.\n\nTable 2-4. Methods implemented in list or deque (those that are also implemented by object are omitted for brevity)\n\nlist deque\n\ns.__add__(s2)\n\n\n\ns + s2—concatenation\n\ns.__iadd__(s2)\n\n\n\n\n\ns += s2—in-place concatenation\n\ns.append(e)\n\n\n\n\n\nAppend one element to the right (after last)\n\ns.appendleft(e)\n\n\n\nAppend one element to the left (before first)\n\ns.clear()\n\n\n\n\n\nDelete all items\n\ns.__contains__(e)\n\n\n\ne in s\n\ns.copy()\n\n\n\nShallow copy of the list\n\ns.__copy__()\n\n\n\nSupport for copy.copy (shallow copy)\n\ns.count(e)\n\n\n\n\n\nCount occurrences of an element\n\ns.__delitem__(p)\n\n\n\n\n\nRemove item at position p\n\ns.extend(i)\n\n\n\n\n\nAppend items from iterable i to the right\n\ns.extendleft(i)\n\n\n\nAppend items from iterable i to the left\n\ns.__getitem__(p)\n\n\n\n\n\ns[p]—get item or slice at position\n\ns.index(e)\n\n\n\nFind position of first occurrence of e\n\ns.insert(p, e)\n\n\n\nInsert element e before the item at position p\n\ns.__iter__()\n\n\n\n\n\nGet iterator\n\ns.__len__()\n\n\n\n\n\nlen(s)—number of items\n\n68\n\n|\n\nChapter 2: An Array of Sequences\n\nlist deque\n\ns.__mul__(n)\n\n\n\ns * n—repeated concatenation\n\ns.__imul__(n)\n\ns.__rmul__(n)\n\ns.pop()\n\n\n\n\n\n\n\n\n\ns *= n—in-place repeated concatenation n * s—reversed repeated concatenationa Remove and return last itemb\n\ns.popleft()\n\n\n\nRemove and return first item\n\ns.remove(e)\n\n\n\n\n\nRemove first occurrence of element e by value\n\ns.reverse()\n\n\n\n\n\nReverse the order of the items in place\n\ns.__reversed__()\n\n\n\n\n\nGet iterator to scan items from last to first\n\ns.rotate(n)\n\n\n\nMove n items from one end to the other\n\ns.__setitem__(p, e)\n\n\n\n\n\ns[p] = e—put e in position p, overwriting existing item or slice\n\ns.sort([key], [reverse]) ●\n\nSort items in place with optional keyword arguments key and reverse\n\na Reversed operators are explained in Chapter 16. b a_list.pop(p) allows removing from position p, but deque does not support that option.\n\nBesides deque, other Python standard library packages implement queues:\n\nqueue\n\nThis provides the synchronized (i.e., thread-safe) classes SimpleQueue, Queue, LifoQueue, and PriorityQueue. These can be used for safe communication between threads. All except SimpleQueue can be bounded by providing a max size argument greater than 0 to the constructor. However, they don’t discard items to make room as deque does. Instead, when the queue is full, the insertion of a new item blocks—i.e., it waits until some other thread makes room by taking an item from the queue, which is useful to throttle the number of live threads.\n\nmultiprocessing\n\nImplements its own unbounded SimpleQueue and bounded Queue, very similar to those in the queue package, but designed for interprocess communication. A specialized multiprocessing.JoinableQueue is provided for task management.\n\nasyncio\n\nProvides Queue, LifoQueue, PriorityQueue, and JoinableQueue with APIs inspired by the classes in the queue and multiprocessing modules, but adapted for managing tasks in asynchronous programming.\n\nheapq\n\nIn contrast to the previous three modules, heapq does not implement a queue class, but provides functions like heappush and heappop that let you use a muta‐ ble sequence as a heap queue or priority queue.\n\nWhen a List Is Not the Answer\n\n|\n\n69\n\nThis ends our overview of alternatives to the list type, and also our exploration of sequence types in general—except for the particulars of str and binary sequences, which have their own chapter (Chapter 4).\n\nChapter Summary Mastering the standard library sequence types is a prerequisite for writing concise, effective, and idiomatic Python code.\n\nPython sequences are often categorized as mutable or immutable, but it is also useful to consider a different axis: flat sequences and container sequences. The former are more compact, faster, and easier to use, but are limited to storing atomic data such as numbers, characters, and bytes. Container sequences are more flexible, but may sur‐ prise you when they hold mutable objects, so you need to be careful to use them cor‐ rectly with nested data structures.\n\nUnfortunately, Python has no foolproof immutable container sequence type: even “immutable” tuples can have their values changed when they contain mutable items like lists or user-defined objects.\n\nList comprehensions and generator expressions are powerful notations to build and initialize sequences. If you are not yet comfortable with them, take the time to master their basic usage. It is not hard, and soon you will be hooked.\n\nTuples in Python play two roles: as records with unnamed fields and as immutable lists. When using a tuple as an immutable list, remember that a tuple value is only guaranteed to be fixed if all the items in it are also immutable. Calling hash(t) on a tuple is a quick way to assert that its value is fixed. A TypeError will be raised if t contains mutable items.\n\nWhen a tuple is used as a record, tuple unpacking is the safest, most readable way of extracting the fields of the tuple. Beyond tuples, * works with lists and iterables in many contexts, and some of its use cases appeared in Python 3.5 with PEP 448— Additional Unpacking Generalizations. Python 3.10 introduced pattern matching with match/case, supporting more powerful unpacking, known as destructuring.\n\nSequence slicing is a favorite Python syntax feature, and it is even more powerful than many realize. Multidimensional slicing and ellipsis (...) notation, as used in NumPy, may also be supported by user-defined sequences. Assigning to slices is a very expressive way of editing mutable sequences.\n\nRepeated concatenation as in seq * n is convenient and, with care, can be used to initialize lists of lists containing immutable items. Augmented assignment with += and *= behaves differently for mutable and immutable sequences. In the latter case, these operators necessarily build new sequences. But if the target sequence is\n\n70\n\n|\n\nChapter 2: An Array of Sequences\n\nmutable, it is usually changed in place—but not always, depending on how the sequence is implemented.\n\nThe sort method and the sorted built-in function are easy to use and flexible, thanks to the optional key argument: a function to calculate the ordering criterion. By the way, key can also be used with the min and max built-in functions.\n\nBeyond lists and tuples, the Python standard library provides array.array. Although NumPy and SciPy are not part of the standard library, if you do any kind of numeri‐ cal processing on large sets of data, studying even a small part of these libraries can take you a long way.\n\nWe closed by visiting the versatile and thread-safe collections.deque, comparing its API with that of list in Table 2-4 and mentioning other queue implementations in the standard library.\n\nFurther Reading Chapter 1, “Data Structures,” of the Python Cookbook, 3rd ed. (O’Reilly) by David Beazley and Brian K. Jones, has many recipes focusing on sequences, including “Recipe 1.11. Naming a Slice,” from which I learned the trick of assigning slices to variables to improve readability, illustrated in our Example 2-13.\n\nThe second edition of the Python Cookbook was written for Python 2.4, but much of its code works with Python 3, and a lot of the recipes in Chapters 5 and 6 deal with sequences. The book was edited by Alex Martelli, Anna Ravenscroft, and David Ascher, and it includes contributions by dozens of Pythonistas. The third edition was rewritten from scratch, and focuses more on the semantics of the language—particu‐ larly what has changed in Python 3—while the older volume emphasizes pragmatics (i.e., how to apply the language to real-world problems). Even though some of the second edition solutions are no longer the best approach, I honestly think it is worth‐ while to have both editions of the Python Cookbook on hand.\n\nThe official Python “Sorting HOW TO” has several examples of advanced tricks for using sorted and list.sort.\n\nPEP 3132—Extended Iterable Unpacking is the canonical source to read about the new use of *extra syntax on the lefthand side of parallel assignments. If you’d like a glimpse of Python evolving, “Missing *-unpacking generalizations” is a bug tracker issue proposing enhancements to the iterable unpacking notation. PEP 448—Addi‐ tional Unpacking Generalizations resulted from the discussions in that issue.\n\nFurther Reading\n\n|\n\n71\n\nAs I mentioned in “Pattern Matching with Sequences” on page 38, Carol Willing’s “Structural Pattern Matching” section of “What’s New In Python 3.10” is a great introduction to this major new feature in about 1,400 words (that’s less than 5 pages when Firefox makes a PDF from the HTML). PEP 636—Structural Pattern Matching: Tutorial is also good, but longer. The same PEP 636 includes “Appendix A—Quick Intro”. It is shorter than Willing’s intro because it omits high-level considerations about why pattern matching is good for you. If you need more arguments to con‐ vince yourself or others that pattern matching is good for Python, read the 22-page PEP 635—Structural Pattern Matching: Motivation and Rationale.\n\nEli Bendersky’s blog post “Less copies in Python with the buffer protocol and memo‐ ryviews” includes a short tutorial on memoryview.\n\nThere are numerous books covering NumPy in the market, and many don’t mention “NumPy” in the title. Two examples are the open access Python Data Science Hand‐ book by Jake VanderPlas, and the second edition of Wes McKinney’s Python for Data Analysis.\n\n“NumPy is all about vectorization.” That is the opening sentence of Nicolas P. Rou‐ gier’s open access book From Python to NumPy. Vectorized operations apply mathe‐ matical functions to all elements of an array without an explicit loop written in Python. They can operate in parallel, using special vector instructions in modern CPUs, leveraging multiple cores or delegating to the GPU, depending on the library. The first example in Rougier’s book shows a speedup of 500 times after refactoring a nice Pythonic class using a generator method, into a lean and mean function calling a couple of NumPy vector functions.\n\nTo learn how to use deque (and other collections), see the examples and practical rec‐ ipes in “Container datatypes” in the Python documentation.\n\nThe best defense of the Python convention of excluding the last item in ranges and slices was written by Edsger W. Dijkstra himself, in a short memo titled “Why Num‐ bering Should Start at Zero”. The subject of the memo is mathematical notation, but it’s relevant to Python because Dijkstra explains with rigor and humor why a sequence like 2, 3, …, 12 should always be expressed as 2 ≤ i < 13. All other reason‐ able conventions are refuted, as is the idea of letting each user choose a convention. The title refers to zero-based indexing, but the memo is really about why it is desira‐ ble that 'ABCDE'[1:3] means 'BC' and not 'BCD' and why it makes perfect sense to write range(2, 13) to produce 2, 3, 4, …, 12. By the way, the memo is a handwritten note, but it’s beautiful and totally readable. Dijkstra’s handwriting is so clear that someone created a font out of his notes.\n\n72\n\n|\n\nChapter 2: An Array of Sequences\n\nSoapbox\n\nThe Nature of Tuples\n\nIn 2012, I presented a poster about the ABC language at PyCon US. Before creating Python, Guido van Rossum had worked on the ABC interpreter, so he came to see my poster. Among other things, we talked about the ABC compounds, which are clearly the predecessors of Python tuples. Compounds also support parallel assign‐ ment and are used as composite keys in dictionaries (or tables, in ABC parlance). However, compounds are not sequences. They are not iterable and you cannot retrieve a field by index, much less slice them. You either handle the compound as whole or extract the individual fields using parallel assignment, that’s all.\n\nI told Guido that these limitations make the main purpose of compounds very clear: they are just records without field names. His response: “Making tuples behave as sequences was a hack.”\n\nThis illustrates the pragmatic approach that made Python more practical and more successful than ABC. From a language implementer perspective, making tuples behave as sequences costs little. As a result, the main use case for tuples as records is not so obvious, but we gained immutable lists—even if their type is not as clearly named as frozenlist.\n\nFlat Versus Container Sequences\n\nTo highlight the different memory models of the sequence types, I used the terms container sequence and flat sequence. The “container” word is from the “Data Model” documentation:\n\nSome objects contain references to other objects; these are called containers.\n\nI used the term “container sequence” to be specific, because there are containers in Python that are not sequences, like dict and set. Container sequences can be nested because they may contain objects of any type, including their own type.\n\nOn the other hand, flat sequences are sequence types that cannot be nested because they only hold simple atomic types like integers, floats, or characters.\n\nI adopted the term flat sequence because I needed something to contrast with “con‐ tainer sequence.”\n\nDespite the previous use of the word “containers” in the official documentation, there is an abstract class in collections.abc called Container. That ABC has just one method, __contains__—the special method behind the in operator. This means that strings and arrays, which are not containers in the traditional sense, are virtual sub‐ classes of Container because they implement __contains__. This is just one more example of humans using a word to mean different things. In this book I’ll write “container” with lowercase letters to mean “an object that contains references to\n\nFurther Reading\n\n|\n\n73",
      "page_number": 82
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 101-122)",
      "start_page": 101,
      "end_page": 122,
      "detection_method": "synthetic",
      "content": "74\n\nother objects,” and Container with a capitalized initial in a single-spaced font to refer to collections.abc.Container.\n\nMixed-Bag Lists\n\nIntroductory Python texts emphasize that lists can contain objects of mixed types, but in practice that feature is not very useful: we put items in a list to process them later, which implies that all items should support at least some operation in common (i.e., they should all “quack” whether or not they are genetically 100% ducks). For exam‐ ple, you can’t sort a list in Python 3 unless the items in it are comparable:\n\n>>> l = [28, 14, '28', 5, '9', '1', 0, 6, '23', 19] >>> sorted(l) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: unorderable types: str() < int()\n\nUnlike lists, tuples often hold items of different types. That’s natural: if each item in a tuple is a field, then each field may have a different type.\n\nkey Is Brilliant\n\nThe optional key argument of list.sort, sorted, max, and min is a great idea. Other languages force you to provide a two-argument comparison function like the depre‐ cated cmp(a, b) function in Python 2. Using key is both simpler and more efficient. It’s simpler because you just define a one-argument function that retrieves or calcu‐ lates whatever criterion you want to use to sort your objects; this is easier than writing a two-argument function to return –1, 0, 1. It is also more efficient because the key function is invoked only once per item, while the two-argument comparison is called every time the sorting algorithm needs to compare two items. Of course, Python also has to compare the keys while sorting, but that comparison is done in optimized C code and not in a Python function that you wrote.\n\nBy the way, using key we can sort a mixed bag of numbers and number-like strings. We just need to decide whether we want to treat all items as integers or strings:\n\n>>> l = [28, 14, '28', 5, '9', '1', 0, 6, '23', 19] >>> sorted(l, key=int) [0, '1', 5, 6, '9', 14, 19, '23', 28, '28'] >>> sorted(l, key=str) [0, '1', 14, 19, '23', 28, '28', 5, 6, '9']\n\nOracle, Google, and the Timbot Conspiracy\n\nThe sorting algorithm used in sorted and list.sort is Timsort, an adaptive algo‐ rithm that switches from insertion sort to merge sort strategies, depending on how ordered the data is. This is efficient because real-world data tends to have runs of sor‐ ted items. There is a Wikipedia article about it.\n\n|\n\nChapter 2: An Array of Sequences\n\nTimsort was first used in CPython in 2002. Since 2009, Timsort is also used to sort arrays in both standard Java and Android, a fact that became widely known when Oracle used some of the code related to Timsort as evidence of Google infringement of Sun’s intellectual property. For example, see this order by Judge William Alsup from 2012. In 2021, the US Supreme Court ruled Google’s use of Java code as “fair use.”\n\nTimsort was invented by Tim Peters, a Python core developer so prolific that he is believed to be an AI, the Timbot. You can read about that conspiracy theory in “Python Humor”. Tim also wrote “The Zen of Python”: import this.\n\nFurther Reading\n\n|\n\n75\n\nCHAPTER 3 Dictionaries and Sets\n\nPython is basically dicts wrapped in loads of syntactic sugar.\n\n—Lalo Martins, early digital nomad and Pythonista\n\nWe use dictionaries in all our Python programs. If not directly in our code, then indi‐ rectly because the dict type is a fundamental part of Python’s implementation. Class and instance attributes, module namespaces, and function keyword arguments are some of the core Python constructs represented by dictionaries in memory. The __builtins__.__dict__ stores all built-in types, objects, and functions.\n\nBecause of their crucial role, Python dicts are highly optimized—and continue to get improvements. Hash tables are the engines behind Python’s high-performance dicts.\n\nOther built-in types based on hash tables are set and frozenset. These offer richer APIs and operators than the sets you may have encountered in other popular lan‐ guages. In particular, Python sets implement all the fundamental operations from set theory, like union, intersection, subset tests, etc. With them, we can express algo‐ rithms in a more declarative way, avoiding lots of nested loops and conditionals.\n\nHere is a brief outline of this chapter:\n\nModern syntax to build and handle dicts and mappings, including enhanced unpacking and pattern matching\n\nCommon methods of mapping types\n\nSpecial handling for missing keys • Variations of dict in the standard library • The set and frozenset types\n\nImplications of hash tables in the behavior of sets and dictionaries\n\n77\n\nWhat’s New in This Chapter Most changes in this second edition cover new features related to mapping types:\n\n“Modern dict Syntax” on page 78 covers enhanced unpacking syntax and different ways of merging mappings—including the | and |= operators supported by dicts since Python 3.9.\n\n“Pattern Matching with Mappings” on page 81 illustrates handling mappings with match/case, since Python 3.10.\n\n“collections.OrderedDict” on page 95 now focuses on the small but still relevant differences between dict and OrderedDict—considering that dict keeps the key insertion order since Python 3.6.\n\nNew sections on the view objects returned by dict.keys, dict.items, and dict.values: “Dictionary Views” on page 101 and “Set Operations on dict Views” on page 110.\n\nThe underlying implementation of dict and set still relies on hash tables, but the dict code has two important optimizations that save memory and preserve the inser‐ tion order of the keys in dict. “Practical Consequences of How dict Works” on page 102 and “Practical Consequences of How Sets Work” on page 107 summarize what you need to know to use them well.\n\nAfter adding more than 200 pages in this second edition, I moved the optional section “Internals of sets and dicts” to the fluentpy‐ thon.com companion website. The updated and expanded 18-page post includes explanations and diagrams about:\n\nThe hash table algorithm and data structures, starting with its use in set, which is simpler to understand.\n\nThe memory optimization that preserves key insertion order in dict instances (since Python 3.6).\n\nThe key-sharing layout for dictionaries holding instance attributes—the __dict__ of user-defined objects (optimiza‐ tion implemented in Python 3.3).\n\nModern dict Syntax The next sections describe advanced syntax features to build, unpack, and process mappings. Some of these features are not new in the language, but may be new to you. Others require Python 3.9 (like the | operator) or Python 3.10 (like match/ case). Let’s start with one of the best and oldest of these features.\n\n78\n\n|\n\nChapter 3: Dictionaries and Sets\n\ndict Comprehensions Since Python 2.7, the syntax of listcomps and genexps was adapted to dict compre‐ hensions (and set comprehensions as well, which we’ll soon visit). A dictcomp (dict comprehension) builds a dict instance by taking key:value pairs from any iterable. Example 3-1 shows the use of dict comprehensions to build two dictionaries from the same list of tuples.\n\nExample 3-1. Examples of dict comprehensions\n\n>>> dial_codes = [ ... (880, 'Bangladesh'), ... (55, 'Brazil'), ... (86, 'China'), ... (91, 'India'), ... (62, 'Indonesia'), ... (81, 'Japan'), ... (234, 'Nigeria'), ... (92, 'Pakistan'), ... (7, 'Russia'), ... (1, 'United States'), ... ] >>> country_dial = {country: code for code, country in dial_codes} >>> country_dial {'Bangladesh': 880, 'Brazil': 55, 'China': 86, 'India': 91, 'Indonesia': 62, 'Japan': 81, 'Nigeria': 234, 'Pakistan': 92, 'Russia': 7, 'United States': 1} >>> {code: country.upper() ... for country, code in sorted(country_dial.items()) ... if code < 70} {55: 'BRAZIL', 62: 'INDONESIA', 7: 'RUSSIA', 1: 'UNITED STATES'}\n\nAn iterable of key-value pairs like dial_codes can be passed directly to the dict constructor, but…\n\n…here we swap the pairs: country is the key, and code is the value.\n\nSorting country_dial by name, reversing the pairs again, uppercasing values, and filtering items with code < 70.\n\nIf you’re used to listcomps, dictcomps are a natural next step. If you aren’t, the spread of the comprehension syntax means it’s now more profitable than ever to become fluent in it.\n\nModern dict Syntax\n\n|\n\n79\n\nUnpacking Mappings PEP 448—Additional Unpacking Generalizations enhanced the support of mapping unpackings in two ways, since Python 3.5.\n\nFirst, we can apply ** to more than one argument in a function call. This works when keys are all strings and unique across all arguments (because duplicate keyword argu‐ ments are forbidden):\n\n>>> def dump(**kwargs): ... return kwargs ... >>> dump(**{'x': 1}, y=2, **{'z': 3}) {'x': 1, 'y': 2, 'z': 3}\n\nSecond, ** can be used inside a dict literal—also multiple times:\n\n>>> {'a': 0, **{'x': 1}, 'y': 2, **{'z': 3, 'x': 4}} {'a': 0, 'x': 4, 'y': 2, 'z': 3}\n\nIn this case, duplicate keys are allowed. Later occurrences overwrite previous ones— see the value mapped to x in the example.\n\nThis syntax can also be used to merge mappings, but there are other ways. Please read on.\n\nMerging Mappings with | Python 3.9 supports using | and |= to merge mappings. This makes sense, since these are also the set union operators.\n\nThe | operator creates a new mapping:\n\n>>> d1 = {'a': 1, 'b': 3} >>> d2 = {'a': 2, 'b': 4, 'c': 6} >>> d1 | d2 {'a': 2, 'b': 4, 'c': 6}\n\nUsually the type of the new mapping will be the same as the type of the left operand —d1 in the example—but it can be the type of the second operand if user-defined types are involved, according to the operator overloading rules we explore in Chapter 16.\n\nTo update an existing mapping in place, use |=. Continuing from the previous exam‐ ple, d1 was not changed, but now it is:\n\n>>> d1 {'a': 1, 'b': 3} >>> d1 |= d2 >>> d1 {'a': 2, 'b': 4, 'c': 6}\n\n80\n\n|\n\nChapter 3: Dictionaries and Sets\n\nIf you need to maintain code to run on Python 3.8 or earlier, the “Motivation” section of PEP 584—Add Union Operators To dict provides a good summary of other ways to merge mappings.\n\nNow let’s see how pattern matching applies to mappings.\n\nPattern Matching with Mappings The match/case statement supports subjects that are mapping objects. Patterns for mappings look like dict literals, but they can match instances of any actual or virtual subclass of collections.abc.Mapping.1\n\nIn Chapter 2 we focused on sequence patterns only, but different types of patterns can be combined and nested. Thanks to destructuring, pattern matching is a power‐ ful tool to process records structured like nested mappings and sequences, which we often need to read from JSON APIs and databases with semi-structured schemas, like MongoDB, EdgeDB, or PostgreSQL. Example 3-2 demonstrates that. The simple type hints in get_creators make it clear that it takes a dict and returns a list.\n\nExample 3-2. creator.py: get_creators() extracts names of creators from media records\n\ndef get_creators(record: dict) -> list: match record: case {'type': 'book', 'api': 2, 'authors': [*names]}: return names case {'type': 'book', 'api': 1, 'author': name}: return [name] case {'type': 'book'}: raise ValueError(f\"Invalid 'book' record: {record!r}\") case {'type': 'movie', 'director': name}: return [name] case _: raise ValueError(f'Invalid record: {record!r}')\n\n1 A virtual subclass is any class registered by calling the .register() method of an ABC, as explained in “A Virtual Subclass of an ABC” on page 460. A type implemented via Python/C API is also eligible if a specific marker bit is set. See Py_TPFLAGS_MAPPING.\n\nPattern Matching with Mappings\n\n|\n\n81\n\nMatch any mapping with 'type': 'book', 'api' :2, and an 'authors' key mapped to a sequence. Return the items in the sequence, as a new list.\n\nMatch any mapping with 'type': 'book', 'api' :1, and an 'author' key mapped to any object. Return the object inside a list.\n\nAny other mapping with 'type': 'book' is invalid, raise ValueError.\n\nMatch any mapping with 'type': 'movie' and a 'director' key mapped to a single object. Return the object inside a list.\n\nAny other subject is invalid, raise ValueError.\n\nExample 3-2 shows some useful practices for handling semi-structured data such as JSON records:\n\nInclude a field describing the kind of record (e.g., 'type': 'movie') • Include a field identifying the schema version (e.g., 'api': 2') to allow for future evolution of public APIs\n\nHave case clauses to handle invalid records of a specific type (e.g., 'book'), as well as a catch-all\n\nNow let’s see how get_creators handles some concrete doctests:\n\n>>> b1 = dict(api=1, author='Douglas Hofstadter', ... type='book', title='Gödel, Escher, Bach') >>> get_creators(b1) ['Douglas Hofstadter'] >>> from collections import OrderedDict >>> b2 = OrderedDict(api=2, type='book', ... title='Python in a Nutshell', ... authors='Martelli Ravenscroft Holden'.split()) >>> get_creators(b2) ['Martelli', 'Ravenscroft', 'Holden'] >>> get_creators({'type': 'book', 'pages': 770}) Traceback (most recent call last): ... ValueError: Invalid 'book' record: {'type': 'book', 'pages': 770} >>> get_creators('Spam, spam, spam') Traceback (most recent call last): ... ValueError: Invalid record: 'Spam, spam, spam'\n\nNote that the order of the keys in the patterns is irrelevant, even if the subject is an OrderedDict as b2.\n\n82\n\n|\n\nChapter 3: Dictionaries and Sets\n\nIn contrast with sequence patterns, mapping patterns succeed on partial matches. In the doctests, the b1 and b2 subjects include a 'title' key that does not appear in any 'book' pattern, yet they match.\n\nThere is no need to use **extra to match extra key-value pairs, but if you want to capture them as a dict, you can prefix one variable with **. It must be the last in the pattern, and **_ is forbidden because it would be redundant. A simple example:\n\n>>> food = dict(category='ice cream', flavor='vanilla', cost=199) >>> match food: ... case {'category': 'ice cream', **details}: ... print(f'Ice cream details: {details}') ... Ice cream details: {'flavor': 'vanilla', 'cost': 199}\n\nIn “Automatic Handling of Missing Keys” on page 90 we’ll study defaultdict and other mappings where key lookups via __getitem__ (i.e., d[key]) succeed because missing items are created on the fly. In the context of pattern matching, a match suc‐ ceeds only if the subject already has the required keys at the top of the match statement.\n\nThe automatic handling of missing keys is not triggered because pattern matching always uses the d.get(key, sentinel) method —where the default sentinel is a special marker value that cannot occur in user data.\n\nMoving on from syntax and structure, let’s study the API of mappings.\n\nStandard API of Mapping Types The collections.abc module provides the Mapping and MutableMapping ABCs describing the interfaces of dict and similar types. See Figure 3-1.\n\nThe main value of the ABCs is documenting and formalizing the standard interfaces for mappings, and serving as criteria for isinstance tests in code that needs to sup‐ port mappings in a broad sense:\n\n>>> my_dict = {} >>> isinstance(my_dict, abc.Mapping) True >>> isinstance(my_dict, abc.MutableMapping) True\n\nStandard API of Mapping Types\n\n|\n\n83\n\nUsing isinstance with an ABC is often better than checking whether a function argument is of the concrete dict type, because then alternative mapping types can be used. We’ll discuss this in detail in Chapter 13.\n\nFigure 3-1. Simplified UML class diagram for the MutableMapping and its superclasses from collections.abc (inheritance arrows point from subclasses to superclasses; names in italic are abstract classes and abstract methods).\n\nTo implement a custom mapping, it’s easier to extend collections.UserDict, or to wrap a dict by composition, instead of subclassing these ABCs. The collec tions.UserDict class and all concrete mapping classes in the standard library encap‐ sulate the basic dict in their implementation, which in turn is built on a hash table. Therefore, they all share the limitation that the keys must be hashable (the values need not be hashable, only the keys). If you need a refresher, the next section explains.\n\nWhat Is Hashable Here is part of the definition of hashable adapted from the Python Glossary:\n\nAn object is hashable if it has a hash code which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same hash code.2\n\nNumeric types and flat immutable types str and bytes are all hashable. Container types are hashable if they are immutable and all contained objects are also hashable. A frozenset is always hashable, because every element it contains must be hashable\n\n2 The Python Glossary entry for “hashable” uses the term “hash value” instead of hash code. I prefer hash code because that is a concept often discussed in the context of mappings, where items are made of keys and val‐ ues, so it may be confusing to mention the hash code as a value. In this book, I only use hash code.\n\n84\n\n|\n\nChapter 3: Dictionaries and Sets\n\nby definition. A tuple is hashable only if all its items are hashable. See tuples tt, tl, and tf:\n\n>>> tt = (1, 2, (30, 40)) >>> hash(tt) 8027212646858338501 >>> tl = (1, 2, [30, 40]) >>> hash(tl) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: unhashable type: 'list' >>> tf = (1, 2, frozenset([30, 40])) >>> hash(tf) -4118419923444501110\n\nThe hash code of an object may be different depending on the version of Python, the machine architecture, and because of a salt added to the hash computation for secu‐ rity reasons.3 The hash code of a correctly implemented object is guaranteed to be constant only within one Python process.\n\nUser-defined types are hashable by default because their hash code is their id(), and the __eq__() method inherited from the object class simply compares the object IDs. If an object implements a custom __eq__() that takes into account its internal state, it will be hashable only if its __hash__() always returns the same hash code. In practice, this requires that __eq__() and __hash__() only take into account instance attributes that never change during the life of the object.\n\nNow let’s review the API of the most commonly used mapping types in Python: dict, defaultdict, and OrderedDict.\n\nOverview of Common Mapping Methods The basic API for mappings is quite rich. Table 3-1 shows the methods implemented by dict and two popular variations: defaultdict and OrderedDict, both defined in the collections module.\n\n3 See PEP 456—Secure and interchangeable hash algorithm to learn about the security implications and solu‐\n\ntions adopted.\n\nStandard API of Mapping Types\n\n|\n\n85\n\nTable 3-1. Methods of the mapping types dict, collections.defaultdict, and collec tions.OrderedDict (common object methods omitted for brevity); optional arguments are enclosed in […]\n\ndict\n\ndefaultdict\n\nOrderedDict\n\nd.clear()\n\n\n\n\n\n\n\nRemove all items\n\nd.__contains__(k)\n\n\n\n\n\n\n\nk in d\n\nd.copy()\n\n\n\n\n\n\n\nShallow copy\n\nd.__copy__()\n\n\n\nSupport for copy.copy(d)\n\nd.default_factory\n\n\n\nCallable invoked by __missing__ to set missing valuesa\n\nd.__delitem__(k)\n\n\n\n\n\n\n\ndel d[k]—remove item with key k\n\nd.fromkeys(it, [ini tial])\n\n\n\n\n\n\n\nNew mapping from keys in iterable, with optional initial value (defaults to None)\n\nd.get(k, [default])\n\n\n\n\n\n\n\nGet item with key k, return default or None if missing\n\nd.__getitem__(k)\n\n\n\n\n\n\n\nd[k]—get item with key k\n\nd.items()\n\n\n\n\n\n\n\nGet view over items—(key, value) pairs\n\nd.__iter__()\n\n\n\n\n\n\n\nGet iterator over keys\n\nd.keys()\n\n\n\n\n\n\n\nGet view over keys\n\nd.__len__()\n\n\n\n\n\n\n\nlen(d)—number of items\n\nd.__missing__(k)\n\n\n\nCalled when __getitem__ cannot find the key\n\nd.move_to_end(k, [last])\n\n\n\nMove k first or last position (last is True by default)\n\nd.__or__(other)\n\n\n\n\n\n\n\nSupport for d1 | d2 to create new dict merging d1 and d2 (Python ≥ 3.9)\n\nd.__ior__(other)\n\n\n\n\n\n\n\nSupport for d1 |= d2 to update d1 with d2 (Python ≥ 3.9)\n\nd.pop(k, [default])\n\n\n\n\n\n\n\nRemove and return value at k, or default or None if missing\n\nd.popitem()\n\n\n\n\n\n\n\nRemove and return the last inserted item as (key, value) b\n\nd.__reversed__()\n\n\n\n\n\n\n\nSupport for reverse(d)—returns iterator for keys from last to first inserted.\n\nd.__ror__(other)\n\n\n\n\n\n\n\nSupport for other | dd— reversed union operator (Python ≥ 3.9)c\n\n86\n\n|\n\nChapter 3: Dictionaries and Sets\n\ndict\n\ndefaultdict\n\nOrderedDict\n\nd.setdefault(k, [default])\n\n\n\n\n\n\n\nIf k in d, return d[k]; else set d[k] = default and return it\n\nd.__setitem__(k, v)\n\n\n\n\n\n\n\nd[k] = v—put v at k\n\nd.update(m, [**kwargs])\n\n\n\n\n\n\n\nUpdate d with items from mapping or iterable of (key, value) pairs\n\nd.values()\n\n\n\n\n\n\n\nGet view over values\n\na default_factory is not a method, but a callable attribute set by the end user when a defaultdict is instantiated. b OrderedDict.popitem(last=False) removes the first item inserted (FIFO). The last keyword argument is not supported in dict or defaultdict as recently as Python 3.10b3. c Reversed operators are explained in Chapter 16.\n\nThe way d.update(m) handles its first argument m is a prime example of duck typing: it first checks whether m has a keys method and, if it does, assumes it is a mapping. Otherwise, update() falls back to iterating over m, assuming its items are (key, value) pairs. The constructor for most Python mappings uses the logic of update() internally, which means they can be initialized from other mappings or from any iterable object producing (key, value) pairs.\n\nA subtle mapping method is setdefault(). It avoids redundant key lookups when we need to update the value of an item in place. The next section shows how to use it.\n\nInserting or Updating Mutable Values In line with Python’s fail-fast philosophy, dict access with d[k] raises an error when k is not an existing key. Pythonistas know that d.get(k, default) is an alternative to d[k] whenever a default value is more convenient than handling KeyError. How‐ ever, when you retrieve a mutable value and want to update it, there is a better way.\n\nConsider a script to index text, producing a mapping where each key is a word, and the value is a list of positions where that word occurs, as shown in Example 3-3.\n\nExample 3-3. Partial output from Example 3-4 processing the “Zen of Python”; each line shows a word and a list of occurrences coded as pairs: (line_number, column_number)\n\n$ python3 index0.py zen.txt a [(19, 48), (20, 53)] Although [(11, 1), (16, 1), (18, 1)] ambiguity [(14, 16)] and [(15, 23)] are [(21, 12)] aren [(10, 15)] at [(16, 38)] bad [(19, 50)]\n\nStandard API of Mapping Types\n\n|\n\n87\n\nbe [(15, 14), (16, 27), (20, 50)] beats [(11, 23)] Beautiful [(3, 1)] better [(3, 14), (4, 13), (5, 11), (6, 12), (7, 9), (8, 11), (17, 8), (18, 25)] ...\n\nExample 3-4 is a suboptimal script written to show one case where dict.get is not the best way to handle a missing key. I adapted it from an example by Alex Martelli.4\n\nExample 3-4. index0.py uses dict.get to fetch and update a list of word occurrences from the index (a better solution is in Example 3-5)\n\n\"\"\"Build an index mapping word -> list of occurrences\"\"\"\n\nimport re import sys\n\nWORD_RE = re.compile(r'\\w+')\n\nindex = {} with open(sys.argv[1], encoding='utf-8') as fp: for line_no, line in enumerate(fp, 1): for match in WORD_RE.finditer(line): word = match.group() column_no = match.start() + 1 location = (line_no, column_no) # this is ugly; coded like this to make a point occurrences = index.get(word, []) occurrences.append(location) index[word] = occurrences\n\n# display in alphabetical order for word in sorted(index, key=str.upper): print(word, index[word])\n\nGet the list of occurrences for word, or [] if not found.\n\nAppend new location to occurrences.\n\nPut changed occurrences into index dict; this entails a second search through the index.\n\n4 The original script appears in slide 41 of Martelli’s “Re-learning Python” presentation. His script is actually a\n\ndemonstration of dict.setdefault, as shown in our Example 3-5.\n\n88\n\n|\n\nChapter 3: Dictionaries and Sets\n\nIn the key= argument of sorted, I am not calling str.upper, just passing a refer‐ ence to that method so the sorted function can use it to normalize the words for sorting.5\n\nThe three lines dealing with occurrences in Example 3-4 can be replaced by a single line using dict.setdefault. Example 3-5 is closer to Alex Martelli’s code.\n\nExample 3-5. index.py uses dict.setdefault to fetch and update a list of word occurrences from the index in a single line; contrast with Example 3-4\n\n\"\"\"Build an index mapping word -> list of occurrences\"\"\"\n\nimport re import sys\n\nWORD_RE = re.compile(r'\\w+')\n\nindex = {} with open(sys.argv[1], encoding='utf-8') as fp: for line_no, line in enumerate(fp, 1): for match in WORD_RE.finditer(line): word = match.group() column_no = match.start() + 1 location = (line_no, column_no) index.setdefault(word, []).append(location)\n\n# display in alphabetical order for word in sorted(index, key=str.upper): print(word, index[word])\n\nGet the list of occurrences for word, or set it to [] if not found; setdefault returns the value, so it can be updated without requiring a second search.\n\nIn other words, the end result of this line…\n\nmy_dict.setdefault(key, []).append(new_value)\n\n…is the same as running…\n\nif key not in my_dict: my_dict[key] = [] my_dict[key].append(new_value)\n\n…except that the latter code performs at least two searches for key—three if it’s not found—while setdefault does it all with a single lookup.\n\n5 This is an example of using a method as a first-class function, the subject of Chapter 7.\n\nStandard API of Mapping Types\n\n|\n\n89\n\nA related issue, handling missing keys on any lookup (and not only when inserting), is the subject of the next section.\n\nAutomatic Handling of Missing Keys Sometimes it is convenient to have mappings that return some made-up value when a missing key is searched. There are two main approaches to this: one is to use a defaultdict instead of a plain dict. The other is to subclass dict or any other map‐ ping type and add a __missing__ method. Both solutions are covered next.\n\ndefaultdict: Another Take on Missing Keys A collections.defaultdict instance creates items with a default value on demand whenever a missing key is searched using d[k] syntax. Example 3-6 uses default dict to provide another elegant solution to the word index task from Example 3-5.\n\nHere is how it works: when instantiating a defaultdict, you provide a callable to produce a default value whenever __getitem__ is passed a nonexistent key argument.\n\nFor example, given a defaultdict created as dd = defaultdict(list), if 'new-key' is not in dd, the expression dd['new-key'] does the following steps:\n\n1. Calls list() to create a new list. 2. Inserts the list into dd using 'new-key' as key.\n\n3. Returns a reference to that list.\n\nThe callable that produces the default values is held in an instance attribute named default_factory.\n\nExample 3-6. index_default.py: using defaultdict instead of the setdefault method\n\n\"\"\"Build an index mapping word -> list of occurrences\"\"\"\n\nimport collections import re import sys\n\nWORD_RE = re.compile(r'\\w+')\n\nindex = collections.defaultdict(list) with open(sys.argv[1], encoding='utf-8') as fp: for line_no, line in enumerate(fp, 1): for match in WORD_RE.finditer(line): word = match.group() column_no = match.start() + 1 location = (line_no, column_no)\n\n90\n\n|\n\nChapter 3: Dictionaries and Sets\n\nindex[word].append(location)\n\n# display in alphabetical order for word in sorted(index, key=str.upper): print(word, index[word])\n\nCreate a defaultdict with the list constructor as default_factory.\n\nIf word is not initially in the index, the default_factory is called to produce the missing value, which in this case is an empty list that is then assigned to index[word] and returned, so the .append(location) operation always suc‐ ceeds.\n\nIf no default_factory is provided, the usual KeyError is raised for missing keys.\n\nThe default_factory of a defaultdict is only invoked to provide default values for __getitem__ calls, and not for the other meth‐ ods. For example, if dd is a defaultdict, and k is a missing key, dd[k] will call the default_factory to create a default value, but dd.get(k) still returns None, and k in dd is False.\n\nThe mechanism that makes defaultdict work by calling default_factory is the __missing__ special method, a feature that we discuss next.\n\nThe __missing__ Method Underlying the way mappings deal with missing keys is the aptly named __missing__ method. This method is not defined in the base dict class, but dict is aware of it: if you subclass dict and provide a __missing__ method, the standard dict.__geti tem__ will call it whenever a key is not found, instead of raising KeyError.\n\nSuppose you’d like a mapping where keys are converted to str when looked up. A concrete use case is a device library for IoT,6 where a programmable board with general-purpose I/O pins (e.g., a Raspberry Pi or an Arduino) is represented by a Board class with a my_board.pins attribute, which is a mapping of physical pin iden‐ tifiers to pin software objects. The physical pin identifier may be just a number or a string like \"A0\" or \"P9_12\". For consistency, it is desirable that all keys in board.pins are strings, but it is also convenient looking up a pin by number, as in my_ardu ino.pin[13], so that beginners are not tripped when they want to blink the LED on pin 13 of their Arduinos. Example 3-7 shows how such a mapping would work.\n\n6 One such library is Pingo.io, no longer under active development.\n\nAutomatic Handling of Missing Keys\n\n|\n\n91\n\nExample 3-7. When searching for a nonstring key, StrKeyDict0 converts it to str when it is not found\n\nTests for item retrieval using `d[key]` notation::\n\n>>> d = StrKeyDict0([('2', 'two'), ('4', 'four')]) >>> d['2'] 'two' >>> d[4] 'four' >>> d[1] Traceback (most recent call last): ... KeyError: '1'\n\nTests for item retrieval using `d.get(key)` notation::\n\n>>> d.get('2') 'two' >>> d.get(4) 'four' >>> d.get(1, 'N/A') 'N/A'\n\nTests for the `in` operator::\n\n>>> 2 in d True >>> 1 in d False\n\nExample 3-8 implements a class StrKeyDict0 that passes the preceding doctests.\n\nA better way to create a user-defined mapping type is to subclass collections.UserDict in Example 3-9). Here we subclass dict just to show that __miss ing__ is supported by the built-in dict.__getitem__ method.\n\ninstead of dict (as we will do\n\nExample 3-8. StrKeyDict0 converts nonstring keys to str on lookup (see tests in Example 3-7)\n\nclass StrKeyDict0(dict):\n\ndef __missing__(self, key): if isinstance(key, str): raise KeyError(key) return self[str(key)]\n\n92\n\n|\n\nChapter 3: Dictionaries and Sets\n\ndef get(self, key, default=None): try: return self[key] except KeyError: return default\n\ndef __contains__(self, key): return key in self.keys() or str(key) in self.keys()\n\nStrKeyDict0 inherits from dict.\n\nCheck whether key is already a str. If it is, and it’s missing, raise KeyError.\n\nBuild str from key and look it up.\n\nThe get method delegates to __getitem__ by using the self[key] notation; that gives the opportunity for our __missing__ to act.\n\nIf a KeyError was raised, __missing__ already failed, so we return the default.\n\nSearch for unmodified key (the instance may contain non-str keys), then for a str built from the key.\n\nTake a moment to consider why the test isinstance(key, str) is necessary in the __missing__ implementation.\n\nWithout that test, our __missing__ method would work OK for any key k—str or not str—whenever str(k) produced an existing key. But if str(k) is not an existing key, we’d have an infinite recursion. In the last line of __missing__, self[str(key)] would call __getitem__, passing that str key, which in turn would call __missing__ again.\n\nThe __contains__ method is also needed for consistent behavior in this example, because the operation k in d calls it, but the method inherited from dict does not fall back to invoking __missing__. There is a subtle detail in our implementation of __contains__: we do not check for the key in the usual Pythonic way—k in my_dict —because str(key) in self would recursively call __contains__. We avoid this by explicitly looking up the key in self.keys().\n\nA search like k in my_dict.keys() is efficient in Python 3 even for very large map‐ pings because dict.keys() returns a view, which is similar to a set, as we’ll see in “Set Operations on dict Views” on page 110. However, remember that k in my_dict does the same job, and is faster because it avoids the attribute lookup to find the .keys method.\n\nAutomatic Handling of Missing Keys\n\n|\n\n93\n\nI had a specific reason to use self.keys() in the __contains__ method in Example 3-8. The check for the unmodified key—key in self.keys()—is necessary for correctness because StrKeyDict0 does not enforce that all keys in the dictionary must be of type str. Our only goal with this simple example is to make searching “friendlier” and not enforce types.\n\nUser-defined classes derived from standard library mappings may or may not use __missing__ as a fallback in their implementations of __getitem__, get, or __contains__, as explained in the next section.\n\nInconsistent Usage of __missing__ in the Standard Library Consider the following scenarios, and how the missing key lookups are affected:\n\ndict subclass\n\nA subclass of dict implementing only __missing__ and no other method. In this case, __missing__ may be called only on d[k], which will use the __getitem__ inherited from dict.\n\ncollections.UserDict subclass\n\nLikewise, a subclass of UserDict implementing only __missing__ and no other method. The get method inherited from UserDict calls __getitem__. This means __missing__ may be called to handle lookups with d[k] and d.get(k).\n\nabc.Mapping subclass with the simplest possible __getitem__\n\nA minimal subclass of abc.Mapping implementing __missing__ and the required abstract methods, including an implementation of __getitem__ that does not call __missing__. The __missing__ method is never triggered in this class.\n\nabc.Mapping subclass with __getitem__ calling __missing__\n\nA minimal subclass of abc.Mapping implementing __missing__ and the required abstract methods, including an implementation of __getitem__ that calls __miss ing__. The __missing__ method is triggered in this class for missing key lookups made with d[k], d.get(k), and k in d.\n\nSee missing.py in the example code repository for demonstrations of the scenarios described here.\n\nThe four scenarios just described assume minimal implementations. If your subclass implements __getitem__, get, and __contains__, then you can make those methods use __missing__ or not, depending on your needs. The point of this section is to show that you must be careful when subclassing standard library mappings to use __missing__, because the base classes support different behaviors by default.\n\n94\n\n|\n\nChapter 3: Dictionaries and Sets\n\nDon’t forget that the behavior of setdefault and update is also affected by key lookup. And finally, depending on the logic of your __missing__, you may need to implement special logic in __setitem__, to avoid inconsistent or surprising behavior. We’ll see an example of this in “Subclassing UserDict Instead of dict” on page 97.\n\nSo far we have covered the dict and defaultdict mapping types, but the standard library comes with other mapping implementations, which we discuss next.\n\nVariations of dict In this section is an overview of mapping types included in the standard library, besides defaultdict, already covered in “defaultdict: Another Take on Missing Keys” on page 90.\n\ncollections.OrderedDict Now that the built-in dict also keeps the keys ordered since Python 3.6, the most common reason to use OrderedDict is writing code that is backward compatible with earlier Python versions. Having said that, Python’s documentation lists some remain‐ ing differences between dict and OrderedDict, which I quote here—only reordering the items for relevance in daily use:\n\nThe equality operation for OrderedDict checks for matching order. • The popitem() method of OrderedDict has a different signature. It accepts an optional argument to specify which item is popped.\n\nOrderedDict has a move_to_end() method to efficiently reposition an element to an endpoint.\n\nThe regular dict was designed to be very good at mapping operations. Tracking insertion order was secondary.\n\nOrderedDict was designed to be good at reordering operations. Space efficiency, iteration speed, and the performance of update operations were secondary.\n\nAlgorithmically, OrderedDict can handle frequent reordering operations better than dict. This makes it suitable for tracking recent accesses (for example, in an LRU cache).\n\ncollections.ChainMap A ChainMap instance holds a list of mappings that can be searched as one. The lookup is performed on each input mapping in the order it appears in the constructor call, and succeeds as soon as the key is found in one of those mappings. For example:\n\nVariations of dict\n\n|\n\n95\n\n>>> d1 = dict(a=1, b=3) >>> d2 = dict(a=2, b=4, c=6) >>> from collections import ChainMap >>> chain = ChainMap(d1, d2) >>> chain['a'] 1 >>> chain['c'] 6\n\nThe ChainMap instance does not copy the input mappings, but holds references to them. Updates or insertions to a ChainMap only affect the first input mapping. Con‐ tinuing from the previous example:\n\n>>> chain['c'] = -1 >>> d1 {'a': 1, 'b': 3, 'c': -1} >>> d2 {'a': 2, 'b': 4, 'c': 6}\n\nChainMap is useful to implement interpreters for languages with nested scopes, where each mapping represents a scope context, from the innermost enclosing scope to the outermost scope. The “ChainMap objects” section of the collections docs has sev‐ eral examples of ChainMap usage, including this snippet inspired by the basic rules of variable lookup in Python:\n\nimport builtins pylookup = ChainMap(locals(), globals(), vars(builtins))\n\nExample 18-14 shows a ChainMap subclass used to implement an interpreter for a subset of the Scheme programming language.\n\ncollections.Counter A mapping that holds an integer count for each key. Updating an existing key adds to its count. This can be used to count instances of hashable objects or as a multiset (dis‐ cussed later in this section). Counter implements the + and - operators to combine tallies, and other useful methods such as most_common([n]), which returns an ordered list of tuples with the n most common items and their counts; see the docu‐ mentation. Here is Counter used to count letters in words:\n\n>>> ct = collections.Counter('abracadabra') >>> ct Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1}) >>> ct.update('aaaaazzz') >>> ct Counter({'a': 10, 'z': 3, 'b': 2, 'r': 2, 'c': 1, 'd': 1}) >>> ct.most_common(3) [('a', 10), ('z', 3), ('b', 2)]\n\n96\n\n|\n\nChapter 3: Dictionaries and Sets",
      "page_number": 101
    },
    {
      "number": 7,
      "title": "Segment 7 (pages 123-142)",
      "start_page": 123,
      "end_page": 142,
      "detection_method": "synthetic",
      "content": "Note that the 'b' and 'r' keys are tied in third place, but ct.most_common(3) shows only three counts.\n\nTo use collections.Counter as a multiset, pretend each key is an element in the set, and the count is the number of occurrences of that element in the set.\n\nshelve.Shelf The shelve module in the standard library provides persistent storage for a mapping of string keys to Python objects serialized in the pickle binary format. The curious name of shelve makes sense when you realize that pickle jars are stored on shelves.\n\nThe shelve.open module-level function returns a shelve.Shelf instance—a simple key-value DBM database backed by the dbm module, with these characteristics:\n\nshelve.Shelf subclasses abc.MutableMapping, so it provides the essential meth‐ ods we expect of a mapping type.\n\nIn addition, shelve.Shelf provides a few other I/O management methods, like sync and close.\n\nA Shelf instance is a context manager, so you can use a with block to make sure it is closed after use.\n\nKeys and values are saved whenever a new value is assigned to a key.\n\nThe keys must be strings. • The values must be objects that the pickle module can serialize.\n\nThe documentation for the shelve, dbm, and pickle modules provides more details and some caveats.\n\nPython’s pickle is easy to use in the simplest cases, but has several drawbacks. Read Ned Batchelder’s “Pickle’s nine flaws” before adopting any solution involving pickle. In his post, Ned mentions other serialization formats to consider.\n\nOrderedDict, ChainMap, Counter, and Shelf are ready to use but can also be custom‐ ized by subclassing. In contrast, UserDict is intended only as a base class to be extended.\n\nSubclassing UserDict Instead of dict It’s better to create a new mapping type by extending collections.UserDict rather than dict. We realize that when we try to extend our StrKeyDict0 from Example 3-8 to make sure that any keys added to the mapping are stored as str.\n\nVariations of dict\n\n|\n\n97\n\nThe main reason why it’s better to subclass UserDict rather than dict is that the built-in has some implementation shortcuts that end up forcing us to override meth‐ ods that we can just inherit from UserDict with no problems.7\n\nNote that UserDict does not inherit from dict, but uses composition: it has an inter‐ nal dict instance, called data, which holds the actual items. This avoids undesired recursion when coding special methods like __setitem__, and simplifies the coding of __contains__, compared to Example 3-8.\n\nThanks to UserDict, StrKeyDict (Example 3-9) is more concise than StrKeyDict0 (Example 3-8), but it does more: it stores all keys as str, avoiding unpleasant sur‐ prises if the instance is built or updated with data containing nonstring keys.\n\nExample 3-9. StrKeyDict always converts nonstring keys to str on insertion, update, and lookup\n\nimport collections\n\nclass StrKeyDict(collections.UserDict):\n\ndef __missing__(self, key): if isinstance(key, str): raise KeyError(key) return self[str(key)]\n\ndef __contains__(self, key): return str(key) in self.data\n\ndef __setitem__(self, key, item): self.data[str(key)] = item\n\nStrKeyDict extends UserDict.\n\n__missing__ is exactly as in Example 3-8.\n\n__contains__ is simpler: we can assume all stored keys are str, and we can check on self.data instead of invoking self.keys() as we did in StrKeyDict0.\n\n__setitem__ converts any key to a str. This method is easier to overwrite when we can delegate to the self.data attribute.\n\n7 The exact problem with subclassing dict and other built-ins is covered in “Subclassing Built-In Types Is\n\nTricky” on page 490.\n\n98\n\n|\n\nChapter 3: Dictionaries and Sets\n\nBecause UserDict extends abc.MutableMapping, the remaining methods that make StrKeyDict a full-fledged mapping are inherited from UserDict, MutableMapping, or Mapping. The latter have several useful concrete methods, in spite of being abstract base classes (ABCs). The following methods are worth noting:\n\nMutableMapping.update\n\nThis powerful method can be called directly but is also used by __init__ to load the instance from other mappings, from iterables of (key, value) pairs, and keyword arguments. Because it uses self[key] = value to add items, it ends up calling our implementation of __setitem__.\n\nMapping.get\n\nIn StrKeyDict0 (Example 3-8), we had to code our own get to return the same results as __getitem__, but in Example 3-9 we inherited Mapping.get, which is implemented exactly like StrKeyDict0.get (see the Python source code).\n\nAntoine Pitrou authored PEP 455—Adding a key-transforming dictionary to collections and a patch to enhance the collections module with a TransformDict, that is more general than StrKey Dict and preserves the keys as they are provided, before the trans‐ formation is applied. PEP 455 was rejected in May 2015—see Raymond Hettinger’s rejection message. To experiment with Trans formDict, I extracted Pitrou’s patch from issue18986 into a stand‐ alone module (03-dict-set/transformdict.py in the Fluent Python second edition code repository).\n\nWe know there are immutable sequence types, but how about an immutable map‐ ping? Well, there isn’t a real one in the standard library, but a stand-in is available. That’s next.\n\nImmutable Mappings The mapping types provided by the standard library are all mutable, but you may need to prevent users from changing a mapping by accident. A concrete use case can be found, again, in a hardware programming library like Pingo, mentioned in “The __missing__ Method” on page 91: the board.pins mapping represents the physical GPIO pins on the device. As such, it’s useful to prevent inadvertent updates to board.pins because the hardware can’t be changed via software, so any change in the mapping would make it inconsistent with the physical reality of the device.\n\nThe types module provides a wrapper class called MappingProxyType, which, given a mapping, returns a mappingproxy instance that is a read-only but dynamic proxy for the original mapping. This means that updates to the original mapping can be seen in\n\nImmutable Mappings\n\n|\n\n99\n\nthe mappingproxy, but changes cannot be made through it. See Example 3-10 for a brief demonstration.\n\nExample 3-10. MappingProxyType builds a read-only mappingproxy instance from a dict\n\n>>> from types import MappingProxyType >>> d = {1: 'A'} >>> d_proxy = MappingProxyType(d) >>> d_proxy mappingproxy({1: 'A'}) >>> d_proxy[1] 'A' >>> d_proxy[2] = 'x' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'mappingproxy' object does not support item assignment >>> d[2] = 'B' >>> d_proxy mappingproxy({1: 'A', 2: 'B'}) >>> d_proxy[2] 'B' >>>\n\nItems in d can be seen through d_proxy.\n\nChanges cannot be made through d_proxy.\n\nd_proxy is dynamic: any change in d is reflected.\n\nHere is how this could be used in practice in the hardware programming scenario: the constructor in a concrete Board subclass would fill a private mapping with the pin objects, and expose it to clients of the API via a public .pins attribute implemented as a mappingproxy. That way the clients would not be able to add, remove, or change pins by accident.\n\nNext, we’ll cover views—which allow high-performance operations on a dict, without unnecessary copying of data.\n\n100\n\n|\n\nChapter 3: Dictionaries and Sets\n\nDictionary Views The dict instance methods .keys(), .values(), and .items() return instances of classes called dict_keys, dict_values, and dict_items, respectively. These dictio‐ nary views are read-only projections of the internal data structures used in the dict implementation. They avoid the memory overhead of the equivalent Python 2 meth‐ ods that returned lists duplicating data already in the target dict, and they also replace the old methods that returned iterators.\n\nExample 3-11 shows some basic operations supported by all dictionary views.\n\nExample 3-11. The .values() method returns a view of the values in a dict\n\n>>> d = dict(a=10, b=20, c=30) >>> values = d.values() >>> values dict_values([10, 20, 30]) >>> len(values) 3 >>> list(values) [10, 20, 30] >>> reversed(values) <dict_reversevalueiterator object at 0x10e9e7310> >>> values[0] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'dict_values' object is not subscriptable\n\nThe repr of a view object shows its content.\n\nWe can query the len of a view.\n\nViews are iterable, so it’s easy to create lists from them.\n\nViews implement __reversed__, returning a custom iterator.\n\nWe can’t use [] to get individual items from a view.\n\nA view object is a dynamic proxy. If the source dict is updated, you can immediately see the changes through an existing view. Continuing from Example 3-11:\n\n>>> d['z'] = 99 >>> d {'a': 10, 'b': 20, 'c': 30, 'z': 99} >>> values dict_values([10, 20, 30, 99])\n\nDictionary Views\n\n|\n\n101\n\nThe classes dict_keys, dict_values, and dict_items are internal: they are not avail‐ able via __builtins__ or any standard library module, and even if you get a reference to one of them, you can’t use it to create a view from scratch in Python code:\n\n>>> values_class = type({}.values()) >>> v = values_class() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: cannot create 'dict_values' instances\n\nThe dict_values class is the simplest dictionary view—it implements only the __len__, __iter__, and __reversed__ special methods. In addition to these meth‐ ods, dict_keys and dict_items implement several set methods, almost as many as the frozenset class. After we cover sets, we’ll have more to say about dict_keys and dict_items in “Set Operations on dict Views” on page 110.\n\nNow let’s see some rules and tips informed by the way dict is implemented under the hood.\n\nPractical Consequences of How dict Works The hash table implementation of Python’s dict is very efficient, but it’s important to understand the practical effects of this design:\n\nKeys must be hashable objects. They must implement proper __hash__ and __eq__ methods as described in “What Is Hashable” on page 84.\n\nItem access by key is very fast. A dict may have millions of keys, but Python can locate a key directly by computing the hash code of the key and deriving an index offset into the hash table, with the possible overhead of a small number of tries to find a matching entry.\n\nKey ordering is preserved as a side effect of a more compact memory layout for dict in CPython 3.6, which became an official language feature in 3.7.\n\nDespite its new compact layout, dicts inevitably have a significant memory over‐ head. The most compact internal data structure for a container would be an array of pointers to the items.8 Compared to that, a hash table needs to store more data per entry, and Python needs to keep at least one-third of the hash table rows empty to remain efficient.\n\nTo save memory, avoid creating instance attributes outside of the __init__ method.\n\n8 That’s how tuples are stored.\n\n102\n\n|\n\nChapter 3: Dictionaries and Sets\n\nThat last tip about instance attributes comes from the fact that Python’s default behavior is to store instance attributes in a special __dict__ attribute, which is a dict attached to each instance.9 Since PEP 412—Key-Sharing Dictionary was implemented in Python 3.3, instances of a class can share a common hash table, stored with the class. That common hash table is shared by the __dict__ of each new instance that has the same attributes names as the first instance of that class when __init__ returns. Each instance __dict__ can then hold only its own attribute values as a sim‐ ple array of pointers. Adding an instance attribute after __init__ forces Python to create a new hash table just for the __dict__ of that one instance (which was the default behavior for all instances before Python 3.3). According to PEP 412, this opti‐ mization reduces memory use by 10% to 20% for object-oriented programs.\n\nThe details of the compact layout and key-sharing optimizations are rather complex. For more, please read “Internals of sets and dicts” at fluentpython.com.\n\nNow let’s dive into sets.\n\nSet Theory Sets are not new in Python, but are still somewhat underused. The set type and its immutable sibling frozenset first appeared as modules in the Python 2.3 standard library, and were promoted to built-ins in Python 2.6.\n\nIn this book, I use the word “set” to refer both to set and frozen set. When talking specifically about the set class, I use constant width font: set.\n\nA set is a collection of unique objects. A basic use case is removing duplication:\n\n>>> l = ['spam', 'spam', 'eggs', 'spam', 'bacon', 'eggs'] >>> set(l) {'eggs', 'spam', 'bacon'} >>> list(set(l)) ['eggs', 'spam', 'bacon']\n\n9 Unless the class has a __slots__ attribute, as explained in “Saving Memory with __slots__” on page 384.\n\nSet Theory\n\n|\n\n103\n\nIf you want to remove duplicates but also preserve the order of the first occurrence of each item, you can now use a plain dict to do it, like this:\n\n>>> dict.fromkeys(l).keys() dict_keys(['spam', 'eggs', 'bacon']) >>> list(dict.fromkeys(l).keys()) ['spam', 'eggs', 'bacon']\n\nSet elements must be hashable. The set type is not hashable, so you can’t build a set with nested set instances. But frozenset is hashable, so you can have frozenset elements inside a set.\n\nIn addition to enforcing uniqueness, the set types implement many set operations as infix operators, so, given two sets a and b, a | b returns their union, a & b computes the intersection, a - b the difference, and a ^ b the symmetric difference. Smart use of set operations can reduce both the line count and the execution time of Python programs, at the same time making code easier to read and reason about—by remov‐ ing loops and conditional logic.\n\nFor example, imagine you have a large set of email addresses (the haystack) and a smaller set of addresses (the needles) and you need to count how many needles occur in the haystack. Thanks to set intersection (the & operator) you can code that in a simple line (see Example 3-12).\n\nExample 3-12. Count occurrences of needles in a haystack, both of type set\n\nfound = len(needles & haystack)\n\nWithout the intersection operator, you’d have to write Example 3-13 to accomplish the same task as Example 3-12.\n\nExample 3-13. Count occurrences of needles in a haystack (same end result as Example 3-12)\n\nfound = 0 for n in needles: if n in haystack: found += 1\n\nExample 3-12 runs slightly faster than Example 3-13. On the other hand, Example 3-13 works for any iterable objects needles and haystack, while Example 3-12 requires that both be sets. But, if you don’t have sets on hand, you can always build them on the fly, as shown in Example 3-14.\n\n104\n\n|\n\nChapter 3: Dictionaries and Sets\n\nExample 3-14. Count occurrences of needles in a haystack; these lines work for any iterable types\n\nfound = len(set(needles) & set(haystack))\n\n# another way: found = len(set(needles).intersection(haystack))\n\nOf course, there is an extra cost involved in building the sets in Example 3-14, but if either the needles or the haystack is already a set, the alternatives in Example 3-14 may be cheaper than Example 3-13.\n\nAny one of the preceding examples are capable of searching 1,000 elements in a hay stack of 10,000,000 items in about 0.3 milliseconds—that’s close to 0.3 microseconds per element.\n\nBesides the extremely fast membership test (thanks to the underlying hash table), the set and frozenset built-in types provide a rich API to create new sets or, in the case of set, to change existing ones. We will discuss the operations shortly, but first a note about syntax.\n\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nSyntax Quirk\n\nDon’t forget that to create an empty set, you should use the con‐ structor without an argument: set(). If you write {}, you’re creat‐ ing an empty dict—this hasn’t changed in Python 3.\n\nIn Python 3, the standard string representation of sets always uses the {…} notation, except for the empty set:\n\n>>> s = {1} >>> type(s) <class 'set'> >>> s {1} >>> s.pop() 1 >>> s set()\n\nSet Theory\n\n|\n\n105\n\nLiteral set syntax like {1, 2, 3} is both faster and more readable than calling the constructor (e.g., set([1, 2, 3])). The latter form is slower because, to evaluate it, Python has to look up the set name to fetch the constructor, then build a list, and finally pass it to the constructor. In contrast, to process a literal like {1, 2, 3}, Python runs a specialized BUILD_SET bytecode.10\n\nThere is no special syntax to represent frozenset literals—they must be created by calling the constructor. The standard string representation in Python 3 looks like a frozenset constructor call. Note the output in the console session:\n\n>>> frozenset(range(10)) frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})\n\nSpeaking of syntax, the idea of listcomps was adapted to build sets as well.\n\nSet Comprehensions Set comprehensions (setcomps) were added way back in Python 2.7, together with the dictcomps that we saw in “dict Comprehensions” on page 79. Example 3-15 shows how.\n\nExample 3-15. Build a set of Latin-1 characters that have the word “SIGN” in their Unicode names\n\n>>> from unicodedata import name >>> {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i),'')} {'§', '=', '¢', '#', '¤', '<', '¥', 'µ', '×', '$', '¶', '£', '©', '°', '+', '÷', '±', '>', '¬', '®', '%'}\n\nImport name function from unicodedata to obtain character names.\n\nBuild set of characters with codes from 32 to 255 that have the word 'SIGN' in their names.\n\nThe order of the output changes for each Python process, because of the salted hash mentioned in “What Is Hashable” on page 84.\n\nSyntax matters aside, let’s now consider the behavior of sets.\n\n10 This may be interesting, but is not super important. The speed up will happen only when a set literal is evalu‐ ated, and that happens at most once per Python process—when a module is initially compiled. If you’re curi‐ ous, import the dis function from the dis module and use it to disassemble the bytecodes for a set literal— e.g., dis('{1}')—and a set call—dis('set([1])')\n\n106\n\n|\n\nChapter 3: Dictionaries and Sets\n\nPractical Consequences of How Sets Work The set and frozenset types are both implemented with a hash table. This has these effects:\n\nSet elements must be hashable objects. They must implement proper __hash__ and __eq__ methods as described in “What Is Hashable” on page 84.\n\nMembership testing is very efficient. A set may have millions of elements, but an element can be located directly by computing its hash code and deriving an index offset, with the possible overhead of a small number of tries to find a matching element or exhaust the search.\n\nSets have a significant memory overhead, compared to a low-level array pointers to its elements—which would be more compact but also much slower to search beyond a handful of elements.\n\nElement ordering depends on insertion order, but not in a useful or reliable way. If two elements are different but have the same hash code, their position depends on which element is added first.\n\nAdding elements to a set may change the order of existing elements. That’s because the algorithm becomes less efficient if the hash table is more than two- thirds full, so Python may need to move and resize the table as it grows. When this happens, elements are reinserted and their relative ordering may change.\n\nSee “Internals of sets and dicts” at fluentpython.com for details.\n\nLet’s now review the rich assortment of operations provided by sets.\n\nSet Operations Figure 3-2 gives an overview of the methods you can use on mutable and immutable sets. Many of them are special methods that overload operators, such as & and >=. Table 3-2 shows the math set operators that have corresponding operators or meth‐ ods in Python. Note that some operators and methods perform in-place changes on the target set (e.g., &=, difference_update, etc.). Such operations make no sense in the ideal world of mathematical sets, and are not implemented in frozenset.\n\nPractical Consequences of How Sets Work\n\n|\n\n107\n\nThe infix operators in Table 3-2 require that both operands be sets, but all other methods take one or more iterable arguments. For example, to produce the union of four collections, a, b, c, and d, you can call a.union(b, c, d), where a must be a set, but b, c, and d can be iterables of any type that produce hashable items. If you need to create a new set with the union of four iterables, instead of updating an existing set, you can write {*a, *b, *c, *d} since Python 3.5 thanks to PEP 448—Additional Unpacking Generalizations.\n\nFigure 3-2. Simplified UML class diagram for MutableSet and its superclasses from collections.abc (names in italic are abstract classes and abstract methods; reverse operator methods omitted for brevity).\n\nTable 3-2. Mathematical set operations: these methods either produce a new set or update the target set in place, if it’s mutable\n\nMath symbol S ∩ Z\n\nPython operator\n\ns & z\n\nMethod\n\ns.__and__(z)\n\nDescription\n\nIntersection of s and z\n\nz & s\n\ns.__rand__(z)\n\nReversed & operator\n\ns.intersection(it, …)\n\nIntersection of s and all sets built from iterables it, etc.\n\ns &= z\n\ns.__iand__(z)\n\ns updated with intersection of s and z\n\ns.intersection_update(it, …)\n\ns updated with intersection of s and all sets built from iterables it, etc.\n\nS ∪ Z\n\ns | z\n\ns.__or__(z)\n\nUnion of s and z\n\nz | s\n\ns.__ror__(z)\n\nReversed |\n\ns.union(it, …)\n\nUnion of s and all sets built from iterables it, etc.\n\n108\n\n|\n\nChapter 3: Dictionaries and Sets\n\nMath symbol\n\nPython operator\n\nMethod\n\nDescription\n\ns |= z\n\ns.__ior__(z)\n\ns updated with union of s and z\n\ns.update(it, …)\n\ns updated with union of s and all sets built from iterables it, etc.\n\nS \\ Z\n\ns - z\n\ns.__sub__(z)\n\nRelative complement or difference between s and z\n\nz - s\n\ns.__rsub__(z)\n\nReversed - operator\n\ns.difference(it, …)\n\nDifference between s and all sets built from iterables it, etc.\n\ns -= z\n\ns.__isub__(z)\n\ns updated with difference between s and z\n\ns.difference_update(it, …)\n\ns updated with difference between s and all sets built from iterables it, etc.\n\nS ∆ Z\n\ns ^ z\n\ns.__xor__(z)\n\nSymmetric difference (the complement of the intersection s & z)\n\nz ^ s\n\ns.__rxor__(z)\n\nReversed ^ operator\n\ns.symmetric_difference(it)\n\nComplement of s & set(it)\n\ns ^= z\n\ns.__ixor__(z)\n\ns updated with symmetric difference of s and z\n\ns.symmetric_differ ence_update(it, …)\n\ns updated with symmetric difference of s and all sets built from iterables it, etc.\n\nTable 3-3 lists set predicates: operators and methods that return True or False.\n\nTable 3-3. Set comparison operators and methods that return a bool\n\nMath symbol Python operator Method S ∩ Z = ∅\n\ns.isdisjoint(z)\n\nDescription s and z are disjoint (no elements in common)\n\ne ∈ S\n\ne in s\n\ns.__contains__(e) Element e is a member of s\n\nS ⊆ Z\n\ns <= z\n\ns.__le__(z)\n\ns is a subset of the z set\n\ns.issubset(it)\n\ns is a subset of the set built from the iterable it\n\nS ⊂ Z\n\ns < z\n\ns.__lt__(z)\n\ns is a proper subset of the z set\n\nS ⊇ Z\n\ns >= z\n\ns.__ge__(z)\n\ns is a superset of the z set\n\ns.issuperset(it)\n\ns is a superset of the set built from the iterable it\n\nS ⊃ Z\n\ns > z\n\ns.__gt__(z)\n\ns is a proper superset of the z set\n\nIn addition to the operators and methods derived from math set theory, the set types implement other methods of practical use, summarized in Table 3-4.\n\nPractical Consequences of How Sets Work\n\n|\n\n109\n\nTable 3-4. Additional set methods\n\nset\n\nfrozenset\n\ns.add(e)\n\n\n\nAdd element e to s\n\ns.clear()\n\n\n\nRemove all elements of s\n\ns.copy()\n\n●\n\nShallow copy of s\n\ns.discard(e) ●\n\nRemove element e from s if it is present\n\ns.__iter__() ● ●\n\nGet iterator over s\n\ns.__len__()\n\n●\n\nlen(s)\n\ns.pop()\n\n\n\nRemove and return an element from s, raising KeyError if s is empty\n\ns.remove(e)\n\n\n\nRemove element e from s, raising KeyError if e not in s\n\nThis completes our overview of the features of sets. As promised in “Dictionary Views” on page 101, we’ll now see how two of the dictionary view types behave very much like a frozenset.\n\nSet Operations on dict Views Table 3-5 shows that the view objects returned by the dict methods .keys() and .items() are remarkably similar to frozenset.\n\nTable 3-5. Methods implemented by frozenset, dict_keys, and dict_items\n\nfrozenset dict_keys dict_items Description\n\ns.__and__(z)\n\n\n\n\n\n\n\ns & z (intersection of s and z)\n\ns.__rand__(z)\n\n\n\n\n\n\n\nReversed & operator\n\ns.__contains__()\n\n\n\n\n\n\n\ne in s\n\ns.copy()\n\n\n\nShallow copy of s\n\ns.difference(it, …)\n\n\n\nDifference between s and iterables it, etc.\n\ns.intersection(it, …)\n\n\n\nIntersection of s and iterables it, etc.\n\ns.isdisjoint(z)\n\n\n\n\n\n\n\ns and z are disjoint (no elements in common)\n\ns.issubset(it)\n\n\n\ns is a subset of iterable it\n\ns.issuperset(it)\n\n\n\ns is a superset of iterable it\n\ns.__iter__()\n\n\n\n\n\n\n\nGet iterator over s\n\ns.__len__()\n\n\n\n\n\n\n\nlen(s)\n\ns.__or__(z)\n\n\n\n\n\n\n\ns | z (union of s and z)\n\ns.__ror__()\n\n\n\n\n\n\n\nReversed | operator\n\ns.__reversed__()\n\n\n\n\n\nGet iterator over s in reverse order\n\ns.__rsub__(z)\n\n\n\n\n\n\n\nReversed - operator\n\ns.__sub__(z)\n\n\n\n\n\n\n\ns - z (difference between s and z)\n\n110\n\n|\n\nChapter 3: Dictionaries and Sets\n\nfrozenset dict_keys dict_items Description\n\ns.symmetric_differ ence(it)\n\n\n\nComplement of s & set(it)\n\ns.union(it, …)\n\n\n\nUnion of s and iterables it, etc.\n\ns.__xor__()\n\n\n\n\n\n\n\ns ^ z (symmetric difference of s and z)\n\ns.__rxor__()\n\n\n\n\n\n\n\nReversed ^ operator\n\nIn particular, dict_keys and dict_items implement the special methods to support the powerful set operators & (intersection), | (union), - (difference), and ^ (symmet‐ ric difference).\n\nFor example, using & is easy to get the keys that appear in two dictionaries:\n\n>>> d1 = dict(a=1, b=2, c=3, d=4) >>> d2 = dict(b=20, d=40, e=50) >>> d1.keys() & d2.keys() {'b', 'd'}\n\nNote that the return value of & is a set. Even better: the set operators in dictionary views are compatible with set instances. Check this out:\n\n>>> s = {'a', 'e', 'i'} >>> d1.keys() & s {'a'} >>> d1.keys() | s {'a', 'c', 'b', 'd', 'i', 'e'}\n\nA dict_items view only works as a set if all values in the dict are hashable. Attempting set operations on a dict_items view with an unhashable value raises TypeError: unhashable type 'T', with T as the type of the offending value. On the other hand, a dict_keys view can always be used as a set, because every key is hashable—by definition.\n\nUsing set operators with views will save a lot of loops and ifs when inspecting the contents of dictionaries in your code. Let Python’s efficient implementation in C work for you!\n\nWith this, we can wrap up this chapter.\n\nSet Operations on dict Views\n\n|\n\n111\n\nChapter Summary Dictionaries are a keystone of Python. Over the years, the familiar {k1: v1, k2: v2} literal syntax was enhanced to support unpacking with **, pattern matching, as well as dict comprehensions.\n\nBeyond the basic dict, the standard library offers handy, ready-to-use specialized mappings like defaultdict, ChainMap, and Counter, all defined in the collections module. With the new dict implementation, OrderedDict is not as useful as before, but should remain in the standard library for backward compatibility—and has spe‐ cific characteristics that dict doesn’t have, such as taking into account key ordering in == comparisons. Also in the collections module is the UserDict, an easy to use base class to create custom mappings.\n\nTwo powerful methods available in most mappings are setdefault and update. The setdefault method can update items holding mutable values—for example, in a dict of list values—avoiding a second search for the same key. The update method allows bulk insertion or overwriting of items from any other mapping, from iterables providing (key, value) pairs, and from keyword arguments. Mapping constructors also use update internally, allowing instances to be initialized from mappings, itera‐ bles, or keyword arguments. Since Python 3.9, we can also use the |= operator to update a mapping, and the | operator to create a new one from the union of two mappings.\n\nA clever hook in the mapping API is the __missing__ method, which lets you cus‐ tomize what happens when a key is not found when using the d[k] syntax that invokes __getitem__.\n\nThe collections.abc module provides the Mapping and MutableMapping abstract base classes as standard interfaces, useful for runtime type checking. The Mapping ProxyType from the types module creates an immutable façade for a mapping you want to protect from accidental change. There are also ABCs for Set and MutableSet.\n\nDictionary views were a great addition in Python 3, eliminating the memory over‐ head of the Python 2 .keys(), .values(), and .items() methods that built lists duplicating data in the target dict instance. In addition, the dict_keys and dict_items classes support the most useful operators and methods of frozenset.\n\n112\n\n|\n\nChapter 3: Dictionaries and Sets\n\nFurther Reading In The Python Standard Library documentation, “collections—Container datatypes”, includes examples and practical recipes with several mapping types. The Python source code for the module Lib/collections/__init__.py is a great reference for anyone who wants to create a new mapping type or grok the logic of the existing ones. Chap‐ ter 1 of the Python Cookbook, 3rd ed. (O’Reilly) by David Beazley and Brian K. Jones has 20 handy and insightful recipes with data structures—the majority using dict in clever ways.\n\nGreg Gandenberger advocates for the continued use of collections.OrderedDict, on the grounds that “explicit is better than implicit,” backward compatibility, and the fact that some tools and libraries assume the ordering of dict keys is irrelevant—his post: “Python Dictionaries Are Now Ordered. Keep Using OrderedDict”.\n\nPEP 3106—Revamping dict.keys(), .values() and .items() is where Guido van Rossum presented the dictionary views feature for Python 3. In the abstract, he wrote that the idea came from the Java Collections Framework.\n\nPyPy was the first Python interpreter to implement Raymond Hettinger’s proposal of compact dicts, and they blogged about it in “Faster, more memory efficient and more ordered dictionaries on PyPy”, acknowledging that a similar layout was adopted in PHP 7, described in PHP’s new hashtable implementation. It’s always great when cre‐ ators cite prior art.\n\nAt PyCon 2017, Brandon Rhodes presented “The Dictionary Even Mightier”, a sequel to his classic animated presentation “The Mighty Dictionary”—including animated hash collisions! Another up-to-date, but more in-depth video on the internals of Python’s dict is “Modern Dictionaries” by Raymond Hettinger, where he tells that after initially failing to sell compact dicts to the CPython core devs, he lobbied the PyPy team, they adopted it, the idea gained traction, and was finally contributed to CPython 3.6 by INADA Naoki. For all details, check out the extensive comments in the CPython code for Objects/dictobject.c and the design document Objects/dict‐ notes.txt.\n\nThe rationale for adding sets to Python is documented in PEP 218—Adding a Built- In Set Object Type. When PEP 218 was approved, no special literal syntax was adop‐ ted for sets. The set literals were created for Python 3 and backported to Python 2.7, along with dict and set comprehensions. At PyCon 2019, I presented “Set Practice: learning from Python’s set types” describing use cases of sets in real programs, cover‐ ing their API design, and the implementation of uintset, a set class for integer ele‐ ments using a bit vector instead of a hash table, inspired by an example in Chapter 6 of the excellent The Go Programming Language, by Alan Donovan and Brian Ker‐ nighan (Addison-Wesley).\n\nFurther Reading\n\n|\n\n113\n\nIEEE’s Spectrum magazine has a story about Hans Peter Luhn, a prolific inventor who patented a punched card deck to select cocktail recipes depending on ingredi‐ ents available, among other diverse inventions including…hash tables! See “Hans Peter Luhn and the Birth of the Hashing Algorithm”.\n\nSoapbox\n\nSyntactic Sugar\n\nMy friend Geraldo Cohen once remarked that Python is “simple and correct.”\n\nProgramming language purists like to dismiss syntax as unimportant.\n\nSyntactic sugar causes cancer of the semicolon.\n\n—Alan Perlis\n\nSyntax is the user interface of a programming language, so it does matter in practice.\n\nBefore finding Python, I did some web programming using Perl and PHP. The syntax for mappings in these languages is very useful, and I badly miss it whenever I have to use Java or C.\n\nA good literal syntax for mappings is very convenient for configuration, table-driven implementations, and to hold data for prototyping and testing. That’s one lesson the designers of Go learned from dynamic languages. The lack of a good way to express structured data in code pushed the Java community to adopt the verbose and overly complex XML as a data format.\n\nJSON was proposed as “The Fat-Free Alternative to XML” and became a huge suc‐ cess, replacing XML in many contexts. A concise syntax for lists and dictionaries makes an excellent data interchange format.\n\nPHP and Ruby imitated the hash syntax from Perl, using => to link keys to values. JavaScript uses : like Python. Why use two characters when one is readable enough?\n\nJSON came from JavaScript, but it also happens to be an almost exact subset of Python syntax. JSON is compatible with Python except for the spelling of the values true, false, and null.\n\nArmin Ronacher tweeted that he likes to hack Python’s global namespace to add JSON-compatible aliases for Python’s True, False, and None so he can paste JSON directly in the console. The basic idea:\n\n114\n\n|\n\nChapter 3: Dictionaries and Sets\n\n>>> true, false, null = True, False, None >>> fruit = { ... \"type\": \"banana\", ... \"avg_weight\": 123.2, ... \"edible_peel\": false, ... \"species\": [\"acuminata\", \"balbisiana\", \"paradisiaca\"], ... \"issues\": null, ... } >>> fruit {'type': 'banana', 'avg_weight': 123.2, 'edible_peel': False, 'species': ['acuminata', 'balbisiana', 'paradisiaca'], 'issues': None}\n\nThe syntax everybody now uses for exchanging data is Python’s dict and list syn‐ tax. Now we have the nice syntax with the convenience of preserved insertion order.\n\nSimple and correct.\n\nFurther Reading\n\n|\n\n115\n\nCHAPTER 4 Unicode Text Versus Bytes\n\nHumans use text. Computers speak bytes.\n\n—Esther Nam and Travis Fischer, “Character Encoding and Unicode in Python”1\n\nPython 3 introduced a sharp distinction between strings of human text and sequen‐ ces of raw bytes. Implicit conversion of byte sequences to Unicode text is a thing of the past. This chapter deals with Unicode strings, binary sequences, and the encod‐ ings used to convert between them.\n\nDepending on the kind of work you do with Python, you may think that understand‐ ing Unicode is not important. That’s unlikely, but anyway there is no escaping the str versus byte divide. As a bonus, you’ll find that the specialized binary sequence types provide features that the “all-purpose” Python 2 str type did not have.\n\nIn this chapter, we will visit the following topics:\n\nCharacters, code points, and byte representations • Unique features of binary sequences: bytes, bytearray, and memoryview\n\nEncodings for full Unicode and legacy character sets\n\nAvoiding and dealing with encoding errors\n\nBest practices when handling text files\n\nThe default encoding trap and standard I/O issues\n\nSafe Unicode text comparisons with normalization\n\n1 Slide 12 of PyCon 2014 talk “Character Encoding and Unicode in Python” (slides, video).\n\n117",
      "page_number": 123
    },
    {
      "number": 8,
      "title": "Segment 8 (pages 143-162)",
      "start_page": 143,
      "end_page": 162,
      "detection_method": "synthetic",
      "content": "Utility functions for normalization, case folding, and brute-force diacritic removal\n\nProper sorting of Unicode text with locale and the pyuca library\n\nCharacter metadata in the Unicode database • Dual-mode APIs that handle str and bytes\n\nWhat’s New in This Chapter Support for Unicode in Python 3 has been comprehensive and stable, so the most notable addition is “Finding Characters by Name” on page 151, describing a utility for searching the Unicode database—a great way to find circled digits and smiling cats from the command line.\n\nOne minor change worth mentioning is the Unicode support on Windows, which is better and simpler since Python 3.6, as we’ll see in “Beware of Encoding Defaults” on page 134.\n\nLet’s start with the not-so-new, but fundamental concepts of characters, code points, and bytes.\n\nFor the second edition, I expanded the section about the struct module and published it online at “Parsing binary records with struct”, in the fluentpython.com companion website.\n\nThere you will also find “Building Multi-character Emojis”, describing how to make country flags, rainbow flags, people with different skin tones, and diverse family icons by combining Uni‐ code characters.\n\nCharacter Issues The concept of “string” is simple enough: a string is a sequence of characters. The problem lies in the definition of “character.”\n\nIn 2021, the best definition of “character” we have is a Unicode character. Accord‐ ingly, the items we get out of a Python 3 str are Unicode characters, just like the items of a unicode object in Python 2—and not the raw bytes we got from a Python 2 str.\n\nThe Unicode standard explicitly separates the identity of characters from specific byte representations:\n\n118\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nThe identity of a character—its code point—is a number from 0 to 1,114,111 (base 10), shown in the Unicode standard as 4 to 6 hex digits with a “U+” prefix, from U+0000 to U+10FFFF. For example, the code point for the letter A is U +0041, the Euro sign is U+20AC, and the musical symbol G clef is assigned to code point U+1D11E. About 13% of the valid code points have characters assigned to them in Unicode 13.0.0, the standard used in Python 3.10.0b4.\n\nThe actual bytes that represent a character depend on the encoding in use. An encoding is an algorithm that converts code points to byte sequences and vice versa. The code point for the letter A (U+0041) is encoded as the single byte \\x41 in the UTF-8 encoding, or as the bytes \\x41\\x00 in UTF-16LE encoding. As another example, UTF-8 requires three bytes—\\xe2\\x82\\xac—to encode the Euro sign (U+20AC), but in UTF-16LE the same code point is encoded as two bytes: \\xac\\x20.\n\nConverting from code points to bytes is encoding; converting from bytes to code points is decoding. See Example 4-1.\n\nExample 4-1. Encoding and decoding\n\n>>> s = 'café' >>> len(s) 4 >>> b = s.encode('utf8') >>> b b'caf\\xc3\\xa9' >>> len(b) 5 >>> b.decode('utf8') 'café'\n\nThe str 'café' has four Unicode characters.\n\nEncode str to bytes using UTF-8 encoding.\n\nbytes literals have a b prefix.\n\nbytes b has five bytes (the code point for “é” is encoded as two bytes in UTF-8).\n\nDecode bytes to str using UTF-8 encoding.\n\nCharacter Issues\n\n|\n\n119\n\nIf you need a memory aid to help distinguish .decode() from .encode(), convince yourself that byte sequences can be cryptic machine core dumps, while Unicode str objects are “human” text. Therefore, it makes sense that we decode bytes to str to get human-readable text, and we encode str to bytes for storage or transmission.\n\nAlthough the Python 3 str is pretty much the Python 2 unicode type with a new name, the Python 3 bytes is not simply the old str renamed, and there is also the closely related bytearray type. So it is worthwhile to take a look at the binary sequence types before advancing to encoding/decoding issues.\n\nByte Essentials The new binary sequence types are unlike the Python 2 str in many regards. The first thing to know is that there are two basic built-in types for binary sequences: the immutable bytes type introduced in Python 3 and the mutable bytearray, added way back in Python 2.6.2 The Python documentation sometimes uses the generic term “byte string” to refer to both bytes and bytearray. I avoid that confusing term.\n\nEach item in bytes or bytearray is an integer from 0 to 255, and not a one-character string like in the Python 2 str. However, a slice of a binary sequence always produces a binary sequence of the same type—including slices of length 1. See Example 4-2.\n\nExample 4-2. A five-byte sequence as bytes and as bytearray\n\n>>> cafe = bytes('café', encoding='utf_8') >>> cafe b'caf\\xc3\\xa9' >>> cafe[0] 99 >>> cafe[:1] b'c' >>> cafe_arr = bytearray(cafe) >>> cafe_arr bytearray(b'caf\\xc3\\xa9') >>> cafe_arr[-1:] bytearray(b'\\xa9')\n\nbytes can be built from a str, given an encoding.\n\nEach item is an integer in range(256).\n\n2 Python 2.6 and 2.7 also had bytes, but it was just an alias to the str type.\n\n120\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nSlices of bytes are also bytes—even slices of a single byte.\n\nThere is no literal syntax for bytearray: they are shown as bytearray() with a bytes literal as argument.\n\nA slice of bytearray is also a bytearray.\n\nThe fact that my_bytes[0] retrieves an int but my_bytes[:1] returns a bytes sequence of length 1 is only surprising because we are used to Python’s str type, where s[0] == s[:1]. For all other sequence types in Python, 1 item is not the same as a slice of length 1.\n\nAlthough binary sequences are really sequences of integers, their literal notation reflects the fact that ASCII text is often embedded in them. Therefore, four different displays are used, depending on each byte value:\n\nFor bytes with decimal codes 32 to 126—from space to ~ (tilde)—the ASCII char‐ acter itself is used.\n\nFor bytes corresponding to tab, newline, carriage return, and \\, the escape sequences \\t, \\n, \\r, and \\\\ are used.\n\nIf both string delimiters ' and \" appear in the byte sequence, the whole sequence is delimited by ', and any ' inside are escaped as \\'.3\n\nFor other byte values, a hexadecimal escape sequence is used (e.g., \\x00 is the null byte).\n\nThat is why in Example 4-2 you see b'caf\\xc3\\xa9': the first three bytes b'caf' are in the printable ASCII range, the last two are not.\n\nBoth bytes and bytearray support every str method except those that do format‐ ting (format, format_map) and those that depend on Unicode data, including case fold, isdecimal, isidentifier, isnumeric, isprintable, and encode. This means that you can use familiar string methods like endswith, replace, strip, translate, upper, and dozens of others with binary sequences—only using bytes and not str arguments. In addition, the regular expression functions in the re module also work\n\n3 Trivia: the ASCII “single quote” character that Python uses by default as the string delimiter is actually named APOSTROPHE in the Unicode standard. The real single quotes are asymmetric: left is U+2018 and right is U+2019.\n\nByte Essentials\n\n|\n\n121\n\non binary sequences, if the regex is compiled from a binary sequence instead of a str. Since Python 3.5, the % operator works with binary sequences again.4\n\nBinary sequences have a class method that str doesn’t have, called fromhex, which builds a binary sequence by parsing pairs of hex digits optionally separated by spaces:\n\n>>> bytes.fromhex('31 4B CE A9') b'1K\\xce\\xa9'\n\nThe other ways of building bytes or bytearray instances are calling their construc‐ tors with:\n\nA str and an encoding keyword argument\n\nAn iterable providing items with values from 0 to 255 • An object that implements the buffer protocol (e.g., bytes, bytearray, memory view, array.array) that copies the bytes from the source object to the newly cre‐ ated binary sequence\n\nUntil Python 3.5, it was also possible to call bytes or bytearray with a single integer to create a binary sequence of that size initial‐ ized with null bytes. This signature was deprecated in Python 3.5 and removed in Python 3.6. See PEP 467—Minor API improve‐ ments for binary sequences.\n\nBuilding a binary sequence from a buffer-like object is a low-level operation that may involve type casting. See a demonstration in Example 4-3.\n\nExample 4-3. Initializing bytes from the raw data of an array\n\n>>> import array >>> numbers = array.array('h', [-2, -1, 0, 1, 2]) >>> octets = bytes(numbers) >>> octets b'\\xfe\\xff\\xff\\xff\\x00\\x00\\x01\\x00\\x02\\x00'\n\nTypecode 'h' creates an array of short integers (16 bits).\n\noctets holds a copy of the bytes that make up numbers.\n\nThese are the 10 bytes that represent the 5 short integers.\n\n4 It did not work in Python 3.0 to 3.4, causing much pain to developers dealing with binary data. The reversal is\n\ndocumented in PEP 461—Adding % formatting to bytes and bytearray.\n\n122\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nCreating a bytes or bytearray object from any buffer-like source will always copy the bytes. In contrast, memoryview objects let you share memory between binary data structures, as we saw in “Memory Views” on page 62.\n\nAfter this basic exploration of binary sequence types in Python, let’s see how they are converted to/from strings.\n\nBasic Encoders/Decoders The Python distribution bundles more than 100 codecs (encoder/decoders) for text to byte conversion and vice versa. Each codec has a name, like 'utf_8', and often aliases, such as 'utf8', 'utf-8', and 'U8', which you can use as the encoding argu‐ ment in functions like open(), str.encode(), bytes.decode(), and so on. Example 4-4 shows the same text encoded as three different byte sequences.\n\nExample 4-4. The string “El Niño” encoded with three codecs producing very different byte sequences\n\n>>> for codec in ['latin_1', 'utf_8', 'utf_16']: ... print(codec, 'El Niño'.encode(codec), sep='\\t') ... latin_1 b'El Ni\\xf1o' utf_8 b'El Ni\\xc3\\xb1o' utf_16 b'\\xff\\xfeE\\x00l\\x00 \\x00N\\x00i\\x00\\xf1\\x00o\\x00'\n\nFigure 4-1 demonstrates a variety of codecs generating bytes from characters like the letter “A” through the G-clef musical symbol. Note that the last three encodings are variable-length, multibyte encodings.\n\nFigure 4-1. Twelve characters, their code points, and their byte representation (in hex) in 7 different encodings (asterisks indicate that the character cannot be represented in that encoding).\n\nBasic Encoders/Decoders\n\n|\n\n123\n\nAll those asterisks in Figure 4-1 make clear that some encodings, like ASCII and even the multibyte GB2312, cannot represent every Unicode character. The UTF encod‐ ings, however, are designed to handle every Unicode code point.\n\nThe encodings shown in Figure 4-1 were chosen as a representative sample:\n\nlatin1 a.k.a. iso8859_1\n\nImportant because it is the basis for other encodings, such as cp1252 and Uni‐ code itself (note how the latin1 byte values appear in the cp1252 bytes and even in the code points).\n\ncp1252\n\nA useful latin1 superset created by Microsoft, adding useful symbols like curly quotes and € (euro); some Windows apps call it “ANSI,” but it was never a real ANSI standard.\n\ncp437\n\nThe original character set of the IBM PC, with box drawing characters. Incom‐ patible with latin1, which appeared later.\n\ngb2312\n\nLegacy standard to encode the simplified Chinese ideographs used in mainland China; one of several widely deployed multibyte encodings for Asian languages.\n\nutf-8\n\nThe most common 8-bit encoding on the web, by far, as of July 2021, “W3Techs: Usage statistics of character encodings for websites” claims that 97% of sites use UTF-8, up from 81.4% when I wrote this paragraph in the first edition of this book in September 2014.\n\nutf-16le\n\nOne form of the UTF 16-bit encoding scheme; all UTF-16 encodings support code points beyond U+FFFF through escape sequences called “surrogate pairs.”\n\nUTF-16 superseded the original 16-bit Unicode 1.0 encoding— UCS-2—way back in 1996. UCS-2 is still used in many systems despite being deprecated since the last century because it only sup‐ ports code points up to U+FFFF. As of 2021, more than 57% of the allocated code points are above U+FFFF, including the all- important emojis.\n\nWith this overview of common encodings now complete, we move to handling issues in encoding and decoding operations.\n\n124\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nUnderstanding Encode/Decode Problems Although there is a generic UnicodeError exception, the error reported by Python is usually more specific: either a UnicodeEncodeError (when converting str to binary sequences) or a UnicodeDecodeError (when reading binary sequences into str). Loading Python modules may also raise SyntaxError when the source encoding is unexpected. We’ll show how to handle all of these errors in the next sections.\n\nThe first thing to note when you get a Unicode error is the exact type of the exception. Is it a UnicodeEncodeError, a UnicodeDeco deError, or some other error (e.g., SyntaxError) that mentions an encoding problem? To solve the problem, you have to understand it first.\n\nCoping with UnicodeEncodeError Most non-UTF codecs handle only a small subset of the Unicode characters. When converting text to bytes, if a character is not defined in the target encoding, Unico deEncodeError will be raised, unless special handling is provided by passing an errors argument to the encoding method or function. The behavior of the error han‐ dlers is shown in Example 4-5.\n\nExample 4-5. Encoding to bytes: success and error handling\n\n>>> city = 'São Paulo' >>> city.encode('utf_8') b'S\\xc3\\xa3o Paulo' >>> city.encode('utf_16') b'\\xff\\xfeS\\x00\\xe3\\x00o\\x00 \\x00P\\x00a\\x00u\\x00l\\x00o\\x00' >>> city.encode('iso8859_1') b'S\\xe3o Paulo' >>> city.encode('cp437') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"/.../lib/python3.4/encodings/cp437.py\", line 12, in encode return codecs.charmap_encode(input,errors,encoding_map) UnicodeEncodeError: 'charmap' codec can't encode character '\\xe3' in position 1: character maps to <undefined> >>> city.encode('cp437', errors='ignore') b'So Paulo' >>> city.encode('cp437', errors='replace') b'S?o Paulo' >>> city.encode('cp437', errors='xmlcharrefreplace') b'S&#227;o Paulo'\n\nUnderstanding Encode/Decode Problems\n\n|\n\n125\n\nThe UTF encodings handle any str.\n\niso8859_1 also works for the 'São Paulo' string.\n\ncp437 can’t encode the 'ã' (“a” with tilde). The default error handler —'strict'—raises UnicodeEncodeError.\n\nThe error='ignore' handler skips characters that cannot be encoded; this is usually a very bad idea, leading to silent data loss.\n\nWhen encoding, error='replace' substitutes unencodable characters with '?'; data is also lost, but users will get a clue that something is amiss.\n\n'xmlcharrefreplace' replaces unencodable characters with an XML entity. If you can’t use UTF, and you can’t afford to lose data, this is the only option.\n\nThe codecs error handling is extensible. You may register extra strings for the errors argument by passing a name and an error handling function to the codecs.register_error function. See the codecs.register_error documentation.\n\nASCII is a common subset to all the encodings that I know about, therefore encoding should always work if the text is made exclusively of ASCII characters. Python 3.7 added a new boolean method str.isascii() to check whether your Unicode text is 100% pure ASCII. If it is, you should be able to encode it to bytes in any encoding without raising UnicodeEncodeError.\n\nCoping with UnicodeDecodeError Not every byte holds a valid ASCII character, and not every byte sequence is valid UTF-8 or UTF-16; therefore, when you assume one of these encodings while convert‐ ing a binary sequence to text, you will get a UnicodeDecodeError if unexpected bytes are found.\n\nOn the other hand, many legacy 8-bit encodings like 'cp1252', 'iso8859_1', and 'koi8_r' are able to decode any stream of bytes, including random noise, without reporting errors. Therefore, if your program assumes the wrong 8-bit encoding, it will silently decode garbage.\n\n126\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nGarbled characters are known as gremlins or mojibake (文字化け —Japanese for “transformed text”).\n\nExample 4-6 illustrates how using the wrong codec may produce gremlins or a UnicodeDecodeError.\n\nExample 4-6. Decoding from str to bytes: success and error handling\n\n>>> octets = b'Montr\\xe9al' >>> octets.decode('cp1252') 'Montréal' >>> octets.decode('iso8859_7') 'Montrιal' >>> octets.decode('koi8_r') 'MontrИal' >>> octets.decode('utf_8') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe9 in position 5: invalid continuation byte >>> octets.decode('utf_8', errors='replace') 'Montr�al'\n\nThe word “Montréal” encoded as latin1; '\\xe9' is the byte for “é”.\n\nDecoding with Windows 1252 works because it is a superset of latin1.\n\nISO-8859-7 is intended for Greek, so the '\\xe9' byte is misinterpreted, and no error is issued.\n\nKOI8-R is for Russian. Now '\\xe9' stands for the Cyrillic letter “И”.\n\nThe 'utf_8' codec detects that octets is not valid UTF-8, and raises UnicodeDe codeError.\n\nUsing 'replace' error handling, the \\xe9 is replaced by “�” (code point U+FFFD), the official Unicode REPLACEMENT CHARACTER intended to represent unknown characters.\n\nUnderstanding Encode/Decode Problems\n\n|\n\n127\n\nSyntaxError When Loading Modules with Unexpected Encoding UTF-8 is the default source encoding for Python 3, just as ASCII was the default for Python 2. If you load a .py module containing non-UTF-8 data and no encoding dec‐ laration, you get a message like this:\n\nSyntaxError: Non-UTF-8 code starting with '\\xe1' in file ola.py on line 1, but no encoding declared; see https://python.org/dev/peps/pep-0263/ for details\n\nBecause UTF-8 is widely deployed in GNU/Linux and macOS systems, a likely sce‐ nario is opening a .py file created on Windows with cp1252. Note that this error hap‐ pens even in Python for Windows, because the default encoding for Python 3 source is UTF-8 across all platforms.\n\nTo fix this problem, add a magic coding comment at the top of the file, as shown in Example 4-7.\n\nExample 4-7. ola.py: “Hello, World!” in Portuguese\n\n# coding: cp1252\n\nprint('Olá, Mundo!')\n\nNow that Python 3 source code is no longer limited to ASCII and defaults to the excellent UTF-8 encoding, the best “fix” for source code in legacy encodings like 'cp1252' is to convert them to UTF-8 already, and not bother with the coding comments. If your editor does not support UTF-8, it’s time to switch.\n\nSuppose you have a text file, be it source code or poetry, but you don’t know its encoding. How do you detect the actual encoding? Answers in the next section.\n\nHow to Discover the Encoding of a Byte Sequence How do you find the encoding of a byte sequence? Short answer: you can’t. You must be told.\n\nSome communication protocols and file formats, like HTTP and XML, contain head‐ ers that explicitly tell us how the content is encoded. You can be sure that some byte streams are not ASCII because they contain byte values over 127, and the way UTF-8 and UTF-16 are built also limits the possible byte sequences.\n\n128\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nLeo’s Hack for Guessing UTF-8 Decoding (The next paragraphs come from a note left by tech reviewer Leonardo Rochael in the draft of this book.)\n\nThe way UTF-8 was designed, it’s almost impossible for a random sequence of bytes, or even a nonrandom sequence of bytes coming from a non-UTF-8 encoding, to be decoded accidentally as garbage in UTF-8, instead of raising UnicodeDecodeError.\n\nThe reasons for this are that UTF-8 escape sequences never use ASCII characters, and these escape sequences have bit patterns that make it very hard for random data to be valid UTF-8 by accident.\n\nSo if you can decode some bytes containing codes > 127 as UTF-8, it’s probably UTF-8.\n\nIn dealing with Brazilian online services, some of which were attached to legacy back‐ ends, I’ve had, on occasion, to implement a decoding strategy of trying to decode via UTF-8 and treat a UnicodeDecodeError by decoding via cp1252. It was ugly but effective.\n\nHowever, considering that human languages also have their rules and restrictions, once you assume that a stream of bytes is human plain text, it may be possible to sniff out its encoding using heuristics and statistics. For example, if b'\\x00' bytes are common, it is probably a 16- or 32-bit encoding, and not an 8-bit scheme, because null characters in plain text are bugs. When the byte sequence b'\\x20\\x00' appears often, it is more likely to be the space character (U+0020) in a UTF-16LE encoding, rather than the obscure U+2000 EN QUAD character—whatever that is.\n\nThat is how the package “Chardet—The Universal Character Encoding Detector” works to guess one of more than 30 supported encodings. Chardet is a Python library that you can use in your programs, but also includes a command-line utility, charde tect. Here is what it reports on the source file for this chapter:\n\n$ chardetect 04-text-byte.asciidoc 04-text-byte.asciidoc: utf-8 with confidence 0.99\n\nAlthough binary sequences of encoded text usually don’t carry explicit hints of their encoding, the UTF formats may prepend a byte order mark to the textual content. That is explained next.\n\nBOM: A Useful Gremlin In Example 4-4, you may have noticed a couple of extra bytes at the beginning of a UTF-16 encoded sequence. Here they are again:\n\nUnderstanding Encode/Decode Problems\n\n|\n\n129\n\n>>> u16 = 'El Niño'.encode('utf_16') >>> u16 b'\\xff\\xfeE\\x00l\\x00 \\x00N\\x00i\\x00\\xf1\\x00o\\x00'\n\nThe bytes are b'\\xff\\xfe'. That is a BOM—byte-order mark—denoting the “little- endian” byte ordering of the Intel CPU where the encoding was performed.\n\nOn a little-endian machine, for each code point the least significant byte comes first: the letter 'E', code point U+0045 (decimal 69), is encoded in byte offsets 2 and 3 as 69 and 0:\n\n>>> list(u16) [255, 254, 69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 111, 0]\n\nOn a big-endian CPU, the encoding would be reversed; 'E' would be encoded as 0 and 69.\n\nTo avoid confusion, the UTF-16 encoding prepends the text to be encoded with the special invisible character ZERO WIDTH NO-BREAK SPACE (U+FEFF). On a little- endian system, that is encoded as b'\\xff\\xfe' (decimal 255, 254). Because, by design, there is no U+FFFE character in Unicode, the byte sequence b'\\xff\\xfe' must mean the ZERO WIDTH NO-BREAK SPACE on a little-endian encoding, so the codec knows which byte ordering to use.\n\nThere is a variant of UTF-16—UTF-16LE—that is explicitly little-endian, and another one explicitly big-endian, UTF-16BE. If you use them, a BOM is not generated:\n\n>>> u16le = 'El Niño'.encode('utf_16le') >>> list(u16le) [69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 111, 0] >>> u16be = 'El Niño'.encode('utf_16be') >>> list(u16be) [0, 69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 111]\n\nIf present, the BOM is supposed to be filtered by the UTF-16 codec, so that you only get the actual text contents of the file without the leading ZERO WIDTH NO-BREAK SPACE. The Unicode standard says that if a file is UTF-16 and has no BOM, it should be assumed to be UTF-16BE (big-endian). However, the Intel x86 architecture is little-endian, so there is plenty of little-endian UTF-16 with no BOM in the wild.\n\nThis whole issue of endianness only affects encodings that use words of more than one byte, like UTF-16 and UTF-32. One big advantage of UTF-8 is that it produces the same byte sequence regardless of machine endianness, so no BOM is needed. Nevertheless, some Windows applications (notably Notepad) add the BOM to UTF-8 files anyway—and Excel depends on the BOM to detect a UTF-8 file, otherwise it assumes the content is encoded with a Windows code page. This UTF-8 encoding with BOM is called UTF-8-SIG in Python’s codec registry. The character U+FEFF\n\n130\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nencoded in UTF-8-SIG is the three-byte sequence b'\\xef\\xbb\\xbf'. So if a file starts with those three bytes, it is likely to be a UTF-8 file with a BOM.\n\nCaleb’s Tip about UTF-8-SIG\n\nCaleb Hattingh—one of the tech reviewers—suggests always using the UTF-8-SIG codec when reading UTF-8 files. This is harmless because UTF-8-SIG reads files with or without a BOM correctly, and does not return the BOM itself. When writing, I recommend using UTF-8 for general interoperability. For example, Python scripts can be made executable in Unix systems if they start with the comment: #!/usr/bin/env python3. The first two bytes of the file must be b'#!' for that to work, but the BOM breaks that con‐ vention. If you have a specific requirement to export data to apps that need the BOM, use UTF-8-SIG but be aware that Python’s codecs documentation says: “In UTF-8, the use of the BOM is dis‐ couraged and should generally be avoided.”\n\nWe now move on to handling text files in Python 3.\n\nHandling Text Files The best practice for handling text I/O is the “Unicode sandwich” (Figure 4-2).5 This means that bytes should be decoded to str as early as possible on input (e.g., when opening a file for reading). The “filling” of the sandwich is the business logic of your program, where text handling is done exclusively on str objects. You should never be encoding or decoding in the middle of other processing. On output, the str are enco‐ ded to bytes as late as possible. Most web frameworks work like that, and we rarely touch bytes when using them. In Django, for example, your views should output Unicode str; Django itself takes care of encoding the response to bytes, using UTF-8 by default.\n\nPython 3 makes it easier to follow the advice of the Unicode sandwich, because the open() built-in does the necessary decoding when reading and encoding when writing files in text mode, so all you get from my_file.read() and pass to my_file.write(text) are str objects.\n\nTherefore, using text files is apparently simple. But if you rely on default encodings, you will get bitten.\n\n5 I first saw the term “Unicode sandwich” in Ned Batchelder’s excellent “Pragmatic Unicode” talk at US PyCon\n\n2012.\n\nHandling Text Files\n\n|\n\n131\n\nFigure 4-2. Unicode sandwich: current best practice for text processing.\n\nConsider the console session in Example 4-8. Can you spot the bug?\n\nExample 4-8. A platform encoding issue (if you try this on your machine, you may or may not see the problem)\n\n>>> open('cafe.txt', 'w', encoding='utf_8').write('café') 4 >>> open('cafe.txt').read() 'cafÃ©'\n\nThe bug: I specified UTF-8 encoding when writing the file but failed to do so when reading it, so Python assumed Windows default file encoding—code page 1252—and the trailing bytes in the file were decoded as characters 'Ã©' instead of 'é'.\n\nI ran Example 4-8 on Python 3.8.1, 64 bits, on Windows 10 (build 18363). The same statements running on recent GNU/Linux or macOS work perfectly well because their default encoding is UTF-8, giving the false impression that everything is fine. If the encoding argument was omitted when opening the file to write, the locale default encoding would be used, and we’d read the file correctly using the same encoding. But then this script would generate files with different byte contents depending on the platform or even depending on locale settings in the same platform, creating compatibility problems.\n\nCode that has to run on multiple machines or on multiple occa‐ sions should never depend on encoding defaults. Always pass an explicit encoding= argument when opening text files, because the default may change from one machine to the next, or from one day to the next.\n\n132\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nA curious detail in Example 4-8 is that the write function in the first statement reports that four characters were written, but in the next line five characters are read. Example 4-9 is an extended version of Example 4-8, explaining that and other details.\n\nExample 4-9. Closer inspection of Example 4-8 running on Windows reveals the bug and how to fix it\n\n>>> fp = open('cafe.txt', 'w', encoding='utf_8') >>> fp <_io.TextIOWrapper name='cafe.txt' mode='w' encoding='utf_8'> >>> fp.write('café') 4 >>> fp.close() >>> import os >>> os.stat('cafe.txt').st_size 5 >>> fp2 = open('cafe.txt') >>> fp2 <_io.TextIOWrapper name='cafe.txt' mode='r' encoding='cp1252'> >>> fp2.encoding 'cp1252' >>> fp2.read() 'cafÃ©' >>> fp3 = open('cafe.txt', encoding='utf_8') >>> fp3 <_io.TextIOWrapper name='cafe.txt' mode='r' encoding='utf_8'> >>> fp3.read() 'café' >>> fp4 = open('cafe.txt', 'rb') >>> fp4 <_io.BufferedReader name='cafe.txt'> >>> fp4.read() b'caf\\xc3\\xa9'\n\nBy default, open uses text mode and returns a TextIOWrapper object with a spe‐ cific encoding.\n\nThe write method on a TextIOWrapper returns the number of Unicode charac‐ ters written.\n\nos.stat says the file has 5 bytes; UTF-8 encodes 'é' as 2 bytes, 0xc3 and 0xa9.\n\nOpening a text file with no explicit encoding returns a TextIOWrapper with the encoding set to a default from the locale.\n\nA TextIOWrapper object has an encoding attribute that you can inspect: cp1252 in this case.\n\nHandling Text Files\n\n|\n\n133\n\nIn the Windows cp1252 encoding, the byte 0xc3 is an “Ã” (A with tilde), and 0xa9 is the copyright sign.\n\nOpening the same file with the correct encoding.\n\nThe expected result: the same four Unicode characters for 'café'.\n\nThe 'rb' flag opens a file for reading in binary mode.\n\nThe returned object is a BufferedReader and not a TextIOWrapper.\n\nReading that returns bytes, as expected.\n\nDo not open text files in binary mode unless you need to analyze the file contents to determine the encoding—even then, you should be using Chardet instead of reinventing the wheel (see “How to Discover the Encoding of a Byte Sequence” on page 128). Ordinary code should only use binary mode to open binary files, like raster images.\n\nThe problem in Example 4-9 has to do with relying on a default setting while opening a text file. There are several sources for such defaults, as the next section shows.\n\nBeware of Encoding Defaults Several settings affect the encoding defaults for I/O in Python. See the default_encod‐ ings.py script in Example 4-10.\n\nExample 4-10. Exploring encoding defaults\n\nimport locale import sys\n\nexpressions = \"\"\" locale.getpreferredencoding() type(my_file) my_file.encoding sys.stdout.isatty() sys.stdout.encoding sys.stdin.isatty() sys.stdin.encoding sys.stderr.isatty() sys.stderr.encoding sys.getdefaultencoding() sys.getfilesystemencoding() \"\"\"\n\n134\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nmy_file = open('dummy', 'w')\n\nfor expression in expressions.split(): value = eval(expression) print(f'{expression:>30} -> {value!r}')\n\nThe output of Example 4-10 on GNU/Linux (Ubuntu 14.04 to 19.10) and macOS (10.9 to 10.14) is identical, showing that UTF-8 is used everywhere in these systems:\n\n$ python3 default_encodings.py locale.getpreferredencoding() -> 'UTF-8' type(my_file) -> <class '_io.TextIOWrapper'> my_file.encoding -> 'UTF-8' sys.stdout.isatty() -> True sys.stdout.encoding -> 'utf-8' sys.stdin.isatty() -> True sys.stdin.encoding -> 'utf-8' sys.stderr.isatty() -> True sys.stderr.encoding -> 'utf-8' sys.getdefaultencoding() -> 'utf-8' sys.getfilesystemencoding() -> 'utf-8'\n\nOn Windows, however, the output is Example 4-11.\n\nExample 4-11. Default encodings on Windows 10 PowerShell (output is the same on cmd.exe)\n\n> chcp Active code page: 437 > python default_encodings.py locale.getpreferredencoding() -> 'cp1252' type(my_file) -> <class '_io.TextIOWrapper'> my_file.encoding -> 'cp1252' sys.stdout.isatty() -> True sys.stdout.encoding -> 'utf-8' sys.stdin.isatty() -> True sys.stdin.encoding -> 'utf-8' sys.stderr.isatty() -> True sys.stderr.encoding -> 'utf-8' sys.getdefaultencoding() -> 'utf-8' sys.getfilesystemencoding() -> 'utf-8'\n\nchcp shows the active code page for the console: 437.\n\nRunning default_encodings.py with output to console.\n\nlocale.getpreferredencoding() is the most important setting.\n\nText files use locale.getpreferredencoding() by default.\n\nHandling Text Files\n\n|\n\n135\n\nThe output is going to the console, so sys.stdout.isatty() is True.\n\nNow, sys.stdout.encoding is not the same as the console code page reported by chcp!\n\nUnicode support in Windows itself, and in Python for Windows, got better since I wrote the first edition of this book. Example 4-11 used to report four different encod‐ ings in Python 3.4 on Windows 7. The encodings for stdout, stdin, and stderr used to be the same as the active code page reported by the chcp command, but now they’re all utf-8 thanks to PEP 528—Change Windows console encoding to UTF-8 implemented in Python 3.6, and Unicode support in PowerShell in cmd.exe (since Windows 1809 from October 2018).6 It’s weird that chcp and sys.stdout.encoding say different things when stdout is writing to the console, but it’s great that now we can print Unicode strings without encoding errors on Windows—unless the user redirects output to a file, as we’ll soon see. That does not mean all your favorite emo‐ jis will appear in the console: that also depends on the font the console is using.\n\nAnother change was PEP 529—Change Windows filesystem encoding to UTF-8, also implemented in Python 3.6, which changed the filesystem encoding (used to repre‐ sent names of directories and files) from Microsoft’s proprietary MBCS to UTF-8.\n\nHowever, if the output of Example 4-10 is redirected to a file, like this:\n\nZ:\\>python default_encodings.py > encodings.log\n\nthen, the value of sys.stdout.isatty() becomes False, and sys.stdout.encoding is set by locale.getpreferredencoding(), 'cp1252' in that machine—but sys.stdin.encoding and sys.stderr.encoding remain utf-8.\n\nIn Example 4-12 I use the '\\N{}' escape for Unicode literals, where we write the official name of the character inside the \\N{}. It’s rather verbose, but explicit and safe: Python raises SyntaxError if the name doesn’t exist—much better than writing a hex number that could be wrong, but you’ll only find out much later. You’d probably want to write a comment explaining the character codes anyway, so the verbosity of \\N{} is easy to accept.\n\nThis means that a script like Example 4-12 works when printing to the console, but may break when output is redirected to a file.\n\n6 Source: “Windows Command-Line: Unicode and UTF-8 Output Text Buffer”.\n\n136\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nExample 4-12. stdout_check.py\n\nimport sys from unicodedata import name\n\nprint(sys.version) print() print('sys.stdout.isatty():', sys.stdout.isatty()) print('sys.stdout.encoding:', sys.stdout.encoding) print()\n\ntest_chars = [ '\\N{HORIZONTAL ELLIPSIS}', # exists in cp1252, not in cp437 '\\N{INFINITY}', # exists in cp437, not in cp1252 '\\N{CIRCLED NUMBER FORTY TWO}', # not in cp437 or in cp1252 ]\n\nfor char in test_chars: print(f'Trying to output {name(char)}:') print(char)\n\nExample 4-12 displays the result of sys.stdout.isatty(), the value of sys. stdout.encoding, and these three characters:\n\n'…' HORIZONTAL ELLIPSIS—exists in CP 1252 but not in CP 437. • '∞' INFINITY—exists in CP 437 but not in CP 1252. • '㊷' CIRCLED NUMBER FORTY TWO—doesn’t exist in CP 1252 or CP 437.\n\nWhen I run stdout_check.py on PowerShell or cmd.exe, it works as captured in Figure 4-3.\n\nFigure 4-3. Running stdout_check.py on PowerShell.\n\nHandling Text Files\n\n|\n\n137",
      "page_number": 143
    },
    {
      "number": 9,
      "title": "Segment 9 (pages 163-181)",
      "start_page": 163,
      "end_page": 181,
      "detection_method": "synthetic",
      "content": "Despite chcp reporting the active code as 437, sys.stdout.encoding is UTF-8, so the HORIZONTAL ELLIPSIS and INFINITY both output correctly. The CIRCLED NUMBER FORTY TWO is replaced by a rectangle, but no error is raised. Presumably it is recog‐ nized as a valid character, but the console font doesn’t have the glyph to display it.\n\nHowever, when I redirect the output of stdout_check.py to a file, I get Figure 4-4.\n\nFigure 4-4. Running stdout_check.py on PowerShell, redirecting output.\n\nThe first problem demonstrated by Figure 4-4 is the UnicodeEncodeError mention‐ ing character '\\u221e', because sys.stdout.encoding is 'cp1252'—a code page that doesn’t have the INFINITY character.\n\nReading out.txt with the type command—or a Windows editor like VS Code or Sub‐ lime Text—shows that instead of HORIZONTAL ELLIPSIS, I got 'à' (LATIN SMALL LETTER A WITH GRAVE). As it turns out, the byte value 0x85 in CP 1252 means '…', but in CP 437 the same byte value represents 'à'. So it seems the active code page does matter, not in a sensible or useful way, but as partial explanation of a bad Uni‐ code experience.\n\nI used a laptop configured for the US market, running Windows 10 OEM to run these experiments. Windows versions localized for other countries may have different encoding configurations. For example, in Brazil the Windows console uses code page 850 by default—not 437.\n\nTo wrap up this maddening issue of default encodings, let’s give a final look at the different encodings in Example 4-11:\n\n138\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nIf you omit the encoding argument when opening a file, the default is given by locale.getpreferredencoding() ('cp1252' in Example 4-11).\n\nThe encoding of sys.stdout|stdin|stderr used to be set by the PYTHONIOENCOD ING environment variable before Python 3.6—now that variable is ignored, unless PYTHONLEGACYWINDOWSSTDIO is set to a nonempty string. Otherwise, the encoding for standard I/O is UTF-8 for interactive I/O, or defined by locale.getpreferredencoding() if the output/input is redirected to/from a file. • sys.getdefaultencoding() is used internally by Python in implicit conversions of binary data to/from str. Changing this setting is not supported.\n\nsys.getfilesystemencoding() is used to encode/decode filenames (not file contents). It is used when open() gets a str argument for the filename; if the file‐ name is given as a bytes argument, it is passed unchanged to the OS API.\n\nOn GNU/Linux and macOS, all of these encodings are set to UTF-8 by default, and have been for several years, so I/O handles all Unicode characters. On Windows, not only are different encod‐ ings used in the same system, but they are usually code pages like 'cp850' or 'cp1252' that support only ASCII, with 127 additional characters that are not the same from one encoding to the other. Therefore, Windows users are far more likely to face encoding errors unless they are extra careful.\n\nTo summarize, the most important encoding setting is that returned by locale.get preferredencoding(): it is the default for opening text files and for sys.stdout/ stdin/stderr when they are redirected to files. However, the documentation reads (in part):\n\nlocale.getpreferredencoding(do_setlocale=True)\n\nReturn the encoding used for text data, according to user preferences. User pref‐ erences are expressed differently on different systems, and might not be available programmatically on some systems, so this function only returns a guess. […]\n\nTherefore, the best advice about encoding defaults is: do not rely on them.\n\nYou will avoid a lot of pain if you follow the advice of the Unicode sandwich and always are explicit about the encodings in your programs. Unfortunately, Unicode is painful even if you get your bytes correctly converted to str. The next two sections cover subjects that are simple in ASCII-land, but get quite complex on planet Uni‐ code: text normalization (i.e., converting text to a uniform representation for comparisons) and sorting.\n\nHandling Text Files\n\n|\n\n139\n\nNormalizing Unicode for Reliable Comparisons String comparisons are complicated by the fact that Unicode has combining charac‐ ters: diacritics and other marks that attach to the preceding character, appearing as one when printed.\n\nFor example, the word “café” may be composed in two ways, using four or five code points, but the result looks exactly the same:\n\n>>> s1 = 'café' >>> s2 = 'cafe\\N{COMBINING ACUTE ACCENT}' >>> s1, s2 ('café', 'café') >>> len(s1), len(s2) (4, 5) >>> s1 == s2 False\n\nPlacing COMBINING ACUTE ACCENT (U+0301) after “e” renders “é”. In the Unicode standard, sequences like 'é' and 'e\\u0301' are called “canonical equivalents,” and applications are supposed to treat them as the same. But Python sees two different sequences of code points, and considers them not equal.\n\nThe solution is unicodedata.normalize(). The first argument to that function is one of four strings: 'NFC', 'NFD', 'NFKC', and 'NFKD'. Let’s start with the first two.\n\nNormalization Form C (NFC) composes the code points to produce the shortest equivalent string, while NFD decomposes, expanding composed characters into base characters and separate combining characters. Both of these normalizations make comparisons work as expected, as the next example shows:\n\n>>> from unicodedata import normalize >>> s1 = 'café' >>> s2 = 'cafe\\N{COMBINING ACUTE ACCENT}' >>> len(s1), len(s2) (4, 5) >>> len(normalize('NFC', s1)), len(normalize('NFC', s2)) (4, 4) >>> len(normalize('NFD', s1)), len(normalize('NFD', s2)) (5, 5) >>> normalize('NFC', s1) == normalize('NFC', s2) True >>> normalize('NFD', s1) == normalize('NFD', s2) True\n\nKeyboard drivers usually generate composed characters, so text typed by users will be in NFC by default. However, to be safe, it may be good to normalize strings with normalize('NFC', user_text) before saving. NFC is also the normalization form recommended by the W3C in “Character Model for the World Wide Web: String Matching and Searching”.\n\n140\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nSome single characters are normalized by NFC into another single character. The symbol for the ohm (Ω) unit of electrical resistance is normalized to the Greek upper‐ case omega. They are visually identical, but they compare as unequal, so it is essential to normalize to avoid surprises:\n\n>>> from unicodedata import normalize, name >>> ohm = '\\u2126' >>> name(ohm) 'OHM SIGN' >>> ohm_c = normalize('NFC', ohm) >>> name(ohm_c) 'GREEK CAPITAL LETTER OMEGA' >>> ohm == ohm_c False >>> normalize('NFC', ohm) == normalize('NFC', ohm_c) True\n\nThe other two normalization forms are NFKC and NFKD, where the letter K stands for “compatibility.” These are stronger forms of normalization, affecting the so-called “compatibility characters.” Although one goal of Unicode is to have a single “canoni‐ cal” code point for each character, some characters appear more than once for compatibility with preexisting standards. For example, the MICRO SIGN, µ (U+00B5), was added to Unicode to support round-trip conversion to latin1, which includes it, even though the same character is part of the Greek alphabet with code point U+03BC (GREEK SMALL LETTER MU). So, the micro sign is considered a “compatibility character.”\n\nIn the NFKC and NFKD forms, each compatibility character is replaced by a “com‐ patibility decomposition” of one or more characters that are considered a “preferred” representation, even if there is some formatting loss—ideally, the formatting should be the responsibility of external markup, not part of Unicode. To exemplify, the compatibility decomposition of the one-half fraction '½' (U+00BD) is the sequence of three characters '1/2', and the compatibility decomposition of the micro sign 'µ' (U +00B5) is the lowercase mu 'μ' (U+03BC).7\n\nHere is how the NFKC works in practice:\n\n>>> from unicodedata import normalize, name >>> half = '\\N{VULGAR FRACTION ONE HALF}' >>> print(half) ½ >>> normalize('NFKC', half) '1⁄2'\n\n7 Curiously, the micro sign is considered a “compatibility character,” but the ohm symbol is not. The end result\n\nis that NFC doesn’t touch the micro sign but changes the ohm symbol to capital omega, while NFKC and NFKD change both the ohm and the micro into Greek characters.\n\nNormalizing Unicode for Reliable Comparisons\n\n|\n\n141\n\n>>> for char in normalize('NFKC', half): ... print(char, name(char), sep='\\t') ... 1 DIGIT ONE ⁄ FRACTION SLASH 2 DIGIT TWO >>> four_squared = '4²' >>> normalize('NFKC', four_squared) '42' >>> micro = 'µ' >>> micro_kc = normalize('NFKC', micro) >>> micro, micro_kc ('µ', 'μ') >>> ord(micro), ord(micro_kc) (181, 956) >>> name(micro), name(micro_kc) ('MICRO SIGN', 'GREEK SMALL LETTER MU')\n\nAlthough '1⁄2' is a reasonable substitute for '½', and the micro sign is really a low‐ ercase Greek mu, converting '4²' to '42' changes the meaning. An application could store '4²' as '4<sup>2</sup>', but the normalize function knows nothing about formatting. Therefore, NFKC or NFKD may lose or distort information, but they can produce convenient intermediate representations for searching and indexing.\n\nUnfortunately, with Unicode everything is always more complicated than it first seems. For the VULGAR FRACTION ONE HALF, the NFKC normalization produced 1 and 2 joined by FRACTION SLASH, instead of SOLIDUS, a.k.a. “slash”—the familiar character with ASCII code decimal 47. Therefore, searching for the three-character ASCII sequence '1/2' would not find the normalized Unicode sequence.\n\nNFKC and NFKD normalization cause data loss and should be applied only in special cases like search and indexing, and not for permanent storage of text.\n\nWhen preparing text for searching or indexing, another operation is useful: case fold‐ ing, our next subject.\n\nCase Folding Case folding is essentially converting all text to lowercase, with some additional transformations. It is supported by the str.casefold() method.\n\nFor any string s containing only latin1 characters, s.casefold() produces the same result as s.lower(), with only two exceptions—the micro sign 'µ' is changed to the\n\n142\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nGreek lowercase mu (which looks the same in most fonts) and the German Eszett or “sharp s” (ß) becomes “ss”:\n\n>>> micro = 'µ' >>> name(micro) 'MICRO SIGN' >>> micro_cf = micro.casefold() >>> name(micro_cf) 'GREEK SMALL LETTER MU' >>> micro, micro_cf ('µ', 'μ') >>> eszett = 'ß' >>> name(eszett) 'LATIN SMALL LETTER SHARP S' >>> eszett_cf = eszett.casefold() >>> eszett, eszett_cf ('ß', 'ss')\n\nThere are nearly 300 code points for which str.casefold() and str.lower() return different results.\n\nAs usual with anything related to Unicode, case folding is a hard issue with plenty of linguistic special cases, but the Python core team made an effort to provide a solution that hopefully works for most users.\n\nIn the next couple of sections, we’ll put our normalization knowledge to use develop‐ ing utility functions.\n\nUtility Functions for Normalized Text Matching As we’ve seen, NFC and NFD are safe to use and allow sensible comparisons between Unicode strings. NFC is the best normalized form for most applications. str.case fold() is the way to go for case-insensitive comparisons.\n\nIf you work with text in many languages, a pair of functions like nfc_equal and fold_equal in Example 4-13 are useful additions to your toolbox.\n\nExample 4-13. normeq.py: normalized Unicode string comparison\n\n\"\"\" Utility functions for normalized Unicode string comparison.\n\nUsing Normal Form C, case sensitive:\n\n>>> s1 = 'café' >>> s2 = 'cafe\\u0301' >>> s1 == s2 False >>> nfc_equal(s1, s2) True\n\nNormalizing Unicode for Reliable Comparisons\n\n|\n\n143\n\n>>> nfc_equal('A', 'a') False\n\nUsing Normal Form C with case folding:\n\n>>> s3 = 'Straße' >>> s4 = 'strasse' >>> s3 == s4 False >>> nfc_equal(s3, s4) False >>> fold_equal(s3, s4) True >>> fold_equal(s1, s2) True >>> fold_equal('A', 'a') True\n\n\"\"\"\n\nfrom unicodedata import normalize\n\ndef nfc_equal(str1, str2): return normalize('NFC', str1) == normalize('NFC', str2)\n\ndef fold_equal(str1, str2): return (normalize('NFC', str1).casefold() == normalize('NFC', str2).casefold())\n\nBeyond Unicode normalization and case folding—which are both part of the Uni‐ code standard—sometimes it makes sense to apply deeper transformations, like changing 'café' into 'cafe'. We’ll see when and how in the next section.\n\nExtreme “Normalization”: Taking Out Diacritics The Google Search secret sauce involves many tricks, but one of them apparently is ignoring diacritics (e.g., accents, cedillas, etc.), at least in some contexts. Removing diacritics is not a proper form of normalization because it often changes the meaning of words and may produce false positives when searching. But it helps coping with some facts of life: people sometimes are lazy or ignorant about the correct use of dia‐ critics, and spelling rules change over time, meaning that accents come and go in liv‐ ing languages.\n\nOutside of searching, getting rid of diacritics also makes for more readable URLs, at least in Latin-based languages. Take a look at the URL for the Wikipedia article about the city of São Paulo:\n\nhttps://en.wikipedia.org/wiki/S%C3%A3o_Paulo\n\n144\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nThe %C3%A3 part is the URL-escaped, UTF-8 rendering of the single letter “ã” (“a” with tilde). The following is much easier to recognize, even if it is not the right spelling:\n\nhttps://en.wikipedia.org/wiki/Sao_Paulo\n\nTo remove all diacritics from a str, you can use a function like Example 4-14.\n\nExample 4-14. simplify.py: function to remove all combining marks\n\nimport unicodedata import string\n\ndef shave_marks(txt): \"\"\"Remove all diacritic marks\"\"\" norm_txt = unicodedata.normalize('NFD', txt) shaved = ''.join(c for c in norm_txt if not unicodedata.combining(c)) return unicodedata.normalize('NFC', shaved)\n\nDecompose all characters into base characters and combining marks.\n\nFilter out all combining marks.\n\nRecompose all characters.\n\nExample 4-15 shows a couple of uses of shave_marks.\n\nExample 4-15. Two examples using shave_marks from Example 4-14\n\n>>> order = '“Herr Voß: • ½ cup of Œtker™ caffè latte • bowl of açaí.”' >>> shave_marks(order) '“Herr Voß: • ½ cup of Œtker™ caffe latte • bowl of acai.”' >>> Greek = 'Ζέφυρος, Zéfiro' >>> shave_marks(Greek) 'Ζεφυρος, Zefiro'\n\nOnly the letters “è”, “ç”, and “í” were replaced.\n\nBoth “έ” and “é” were replaced.\n\nThe function shave_marks from Example 4-14 works all right, but maybe it goes too far. Often the reason to remove diacritics is to change Latin text to pure ASCII, but shave_marks also changes non-Latin characters—like Greek letters—which will never become ASCII just by losing their accents. So it makes sense to analyze each base\n\nNormalizing Unicode for Reliable Comparisons\n\n|\n\n145\n\ncharacter and to remove attached marks only if the base character is a letter from the Latin alphabet. This is what Example 4-16 does.\n\nExample 4-16. Function to remove combining marks from Latin characters (import statements are omitted as this is part of the simplify.py module from Example 4-14)\n\ndef shave_marks_latin(txt): \"\"\"Remove all diacritic marks from Latin base characters\"\"\" norm_txt = unicodedata.normalize('NFD', txt) latin_base = False preserve = [] for c in norm_txt: if unicodedata.combining(c) and latin_base: continue # ignore diacritic on Latin base char preserve.append(c) # if it isn't a combining char, it's a new base char if not unicodedata.combining(c): latin_base = c in string.ascii_letters shaved = ''.join(preserve) return unicodedata.normalize('NFC', shaved)\n\nDecompose all characters into base characters and combining marks.\n\nSkip over combining marks when base character is Latin.\n\nOtherwise, keep current character.\n\nDetect new base character and determine if it’s Latin.\n\nRecompose all characters.\n\nAn even more radical step would be to replace common symbols in Western texts (e.g., curly quotes, em dashes, bullets, etc.) into ASCII equivalents. This is what the function asciize does in Example 4-17.\n\nExample 4-17. Transform some Western typographical symbols into ASCII (this snippet is also part of simplify.py from Example 4-14)\n\nsingle_map = str.maketrans(\"\"\"‚ƒ„ˆ‹‘’“”•–—˜›\"\"\", \"\"\"'f\"^<''\"\"---~>\"\"\")\n\nmulti_map = str.maketrans({ '€': 'EUR', '…': '...', 'Æ': 'AE', 'æ': 'ae', 'Œ': 'OE', 'œ': 'oe',\n\n146\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\n'™': '(TM)', '‰': '<per mille>', '†': '**', '‡': '***', })\n\nmulti_map.update(single_map)\n\ndef dewinize(txt): \"\"\"Replace Win1252 symbols with ASCII chars or sequences\"\"\" return txt.translate(multi_map)\n\ndef asciize(txt): no_marks = shave_marks_latin(dewinize(txt)) no_marks = no_marks.replace('ß', 'ss') return unicodedata.normalize('NFKC', no_marks)\n\nBuild mapping table for char-to-char replacement.\n\nBuild mapping table for char-to-string replacement.\n\nMerge mapping tables.\n\ndewinize does not affect ASCII or latin1 text, only the Microsoft additions to latin1 in cp1252.\n\nApply dewinize and remove diacritical marks.\n\nReplace the Eszett with “ss” (we are not using case fold here because we want to preserve the case).\n\nApply NFKC normalization to compose characters with their compatibility code points.\n\nExample 4-18 shows asciize in use.\n\nExample 4-18. Two examples using asciize from Example 4-17\n\n>>> order = '“Herr Voß: • ½ cup of Œtker™ caffè latte • bowl of açaí.”' >>> dewinize(order) '\"Herr Voß: - ½ cup of OEtker(TM) caffè latte - bowl of açaí.\"' >>> asciize(order) '\"Herr Voss: - 1⁄2 cup of OEtker(TM) caffe latte - bowl of acai.\"'\n\nNormalizing Unicode for Reliable Comparisons\n\n|\n\n147\n\ndewinize replaces curly quotes, bullets, and ™ (trademark symbol).\n\nasciize applies dewinize, drops diacritics, and replaces the 'ß'.\n\nDifferent languages have their own rules for removing diacritics. For example, Germans change the 'ü' into 'ue'. Our asciize function is not as refined, so it may or not be suitable for your lan‐ guage. It works acceptably for Portuguese, though.\n\nTo summarize, the functions in simplify.py go way beyond standard normalization and perform deep surgery on the text, with a good chance of changing its meaning. Only you can decide whether to go so far, knowing the target language, your users, and how the transformed text will be used.\n\nThis wraps up our discussion of normalizing Unicode text.\n\nNow let’s sort out Unicode sorting.\n\nSorting Unicode Text Python sorts sequences of any type by comparing the items in each sequence one by one. For strings, this means comparing the code points. Unfortunately, this produces unacceptable results for anyone who uses non-ASCII characters.\n\nConsider sorting a list of fruits grown in Brazil:\n\n>>> fruits = ['caju', 'atemoia', 'cajá', 'açaí', 'acerola'] >>> sorted(fruits) ['acerola', 'atemoia', 'açaí', 'caju', 'cajá']\n\nSorting rules vary for different locales, but in Portuguese and many languages that use the Latin alphabet, accents and cedillas rarely make a difference when sorting.8 So “cajá” is sorted as “caja,” and must come before “caju.”\n\nThe sorted fruits list should be:\n\n['açaí', 'acerola', 'atemoia', 'cajá', 'caju']\n\nThe standard way to sort non-ASCII text in Python is to use the locale.strxfrm function which, according to the locale module docs, “transforms a string to one that can be used in locale-aware comparisons.”\n\n8 Diacritics affect sorting only in the rare case when they are the only difference between two words—in that\n\ncase, the word with a diacritic is sorted after the plain word.\n\n148\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nTo enable locale.strxfrm, you must first set a suitable locale for your application, and pray that the OS supports it. The sequence of commands in Example 4-19 may work for you.\n\nExample 4-19. locale_sort.py: using the locale.strxfrm function as the sort key\n\nimport locale my_locale = locale.setlocale(locale.LC_COLLATE, 'pt_BR.UTF-8') print(my_locale) fruits = ['caju', 'atemoia', 'cajá', 'açaí', 'acerola'] sorted_fruits = sorted(fruits, key=locale.strxfrm) print(sorted_fruits)\n\nRunning Example 4-19 on GNU/Linux (Ubuntu 19.10) with the pt_BR.UTF-8 locale installed, I get the correct result:\n\n'pt_BR.UTF-8' ['açaí', 'acerola', 'atemoia', 'cajá', 'caju']\n\nSo you need to call setlocale(LC_COLLATE, «your_locale») before using locale.strxfrm as the key when sorting.\n\nThere are some caveats, though:\n\nBecause locale settings are global, calling setlocale in a library is not recom‐ mended. Your application or framework should set the locale when the process starts, and should not change it afterward.\n\nThe locale must be installed on the OS, otherwise setlocale raises a locale.Error: unsupported locale setting exception.\n\nYou must know how to spell the locale name.\n\nThe locale must be correctly implemented by the makers of the OS. I was suc‐ cessful on Ubuntu 19.10, but not on macOS 10.14. On macOS, the call setlo cale(LC_COLLATE, 'pt_BR.UTF-8') returns the string 'pt_BR.UTF-8' with no complaints. But sorted(fruits, key=locale.strxfrm) produced the same incorrect result as sorted(fruits) did. I also tried the fr_FR, es_ES, and de_DE locales on macOS, but locale.strxfrm never did its job.9\n\nSo the standard library solution to internationalized sorting works, but seems to be well supported only on GNU/Linux (perhaps also on Windows, if you are an expert). Even then, it depends on locale settings, creating deployment headaches.\n\n9 Again, I could not find a solution, but did find other people reporting the same problem. Alex Martelli, one of the tech reviewers, had no problem using setlocale and locale.strxfrm on his Macintosh with macOS 10.9. In summary: your mileage may vary.\n\nSorting Unicode Text\n\n|\n\n149\n\nFortunately, there is a simpler solution: the pyuca library, available on PyPI.\n\nSorting with the Unicode Collation Algorithm James Tauber, prolific Django contributor, must have felt the pain and created pyuca, a pure-Python implementation of the Unicode Collation Algorithm (UCA). Example 4-20 shows how easy it is to use.\n\nExample 4-20. Using the pyuca.Collator.sort_key method\n\n>>> import pyuca >>> coll = pyuca.Collator() >>> fruits = ['caju', 'atemoia', 'cajá', 'açaí', 'acerola'] >>> sorted_fruits = sorted(fruits, key=coll.sort_key) >>> sorted_fruits ['açaí', 'acerola', 'atemoia', 'cajá', 'caju']\n\nThis is simple and works on GNU/Linux, macOS, and Windows, at least with my small sample.\n\npyuca does not take the locale into account. If you need to customize the sorting, you can provide the path to a custom collation table to the Collator() constructor. Out of the box, it uses allkeys.txt, which is bundled with the project. That’s just a copy of the Default Unicode Collation Element Table from Unicode.org.\n\nPyICU: Miro’s Recommendation for Unicode Sorting\n\n(Tech reviewer Miroslav Šedivý is a polyglot and an expert on Uni‐ code. This is what he wrote about pyuca.)\n\npyuca has one sorting algorithm that does not respect the sorting order in individual languages. For instance, Ä in German is between A and B, while in Swedish it comes after Z. Have a look at PyICU that works like locale without changing the locale of the process. It is also needed if you want to change the case of iİ/ıI in Turkish. PyICU includes an extension that must be compiled, so it may be harder to install in some systems than pyuca, which is just Python.\n\nBy the way, that collation table is one of the many data files that comprise the Uni‐ code database, our next subject.\n\nThe Unicode Database The Unicode standard provides an entire database—in the form of several structured text files—that includes not only the table mapping code points to character names,\n\n150\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nbut also metadata about the individual characters and how they are related. For example, the Unicode database records whether a character is printable, is a letter, is a decimal digit, or is some other numeric symbol. That’s how the str methods isal pha, isprintable, isdecimal, and isnumeric work. str.casefold also uses infor‐ mation from a Unicode table.\n\nThe unicodedata.category(char) function returns the two-letter category of char from the Unicode database. The higher-level str methods are easier to use. For example, label.isalpha() returns True if every character in label belongs to one of these categories: Lm, Lt, Lu, Ll, or Lo. To learn what those codes mean, see “General Category” in the English Wikipedia’s “Unicode character property” article.\n\nFinding Characters by Name The unicodedata module has functions to retrieve character metadata, including uni codedata.name(), which returns a character’s official name in the standard. Figure 4-5 demonstrates that function.10\n\nFigure 4-5. Exploring unicodedata.name() in the Python console.\n\nYou can use the name() function to build apps that let users search for characters by name. Figure 4-6 demonstrates the cf.py command-line script that takes one or more words as arguments, and lists the characters that have those words in their official Unicode names. The full source code for cf.py is in Example 4-21.\n\n10 That’s an image—not a code listing—because emojis are not well supported by O’Reilly’s digital publishing\n\ntoolchain as I write this.\n\nThe Unicode Database\n\n|\n\n151\n\nFigure 4-6. Using cf.py to find smiling cats.\n\nEmoji support varies widely across operating systems and apps. In recent years the macOS terminal offers the best support for emojis, followed by modern GNU/Linux graphic terminals. Windows cmd.exe and PowerShell now support Unicode output, but as I write this section in January 2020, they still don’t display emojis— at least not “out of the box.” Tech reviewer Leonardo Rochael told me about a new, open source Windows Terminal by Microsoft, which may have better Unicode support than the older Microsoft consoles. I did not have time to try it.\n\nIn Example 4-21, note the if statement in the find function using the .issubset() method to quickly test whether all the words in the query set appear in the list of words built from the character’s name. Thanks to Python’s rich set API, we don’t need a nested for loop and another if to implement this check.\n\nExample 4-21. cf.py: the character finder utility\n\n#!/usr/bin/env python3 import sys import unicodedata\n\nSTART, END = ord(' '), sys.maxunicode + 1\n\ndef find(*query_words, start=START, end=END): query = {w.upper() for w in query_words} for code in range(start, end): char = chr(code) name = unicodedata.name(char, None) if name and query.issubset(name.split()): print(f'U+{code:04X}\\t{char}\\t{name}')\n\ndef main(words): if words: find(*words) else: print('Please provide words to find.')\n\nif __name__ == '__main__': main(sys.argv[1:])\n\n152\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nSet defaults for the range of code points to search.\n\nfind accepts query_words and optional keyword-only arguments to limit the range of the search, to facilitate testing.\n\nConvert query_words into a set of uppercased strings.\n\nGet the Unicode character for code.\n\nGet the name of the character, or None if the code point is unassigned.\n\nIf there is a name, split it into a list of words, then check that the query set is a subset of that list.\n\nPrint out line with code point in U+9999 format, the character, and its name.\n\nThe unicodedata module has other interesting functions. Next, we’ll see a few that are related to getting information from characters that have numeric meaning.\n\nNumeric Meaning of Characters The unicodedata module includes functions to check whether a Unicode character represents a number and, if so, its numeric value for humans—as opposed to its code point number. Example 4-22 shows the use of unicodedata.name() and unicode data.numeric(), along with the .isdecimal() and .isnumeric() methods of str.\n\nExample 4-22. Demo of Unicode database numerical character metadata (callouts describe each column in the output)\n\nimport unicodedata import re\n\nre_digit = re.compile(r'\\d')\n\nsample = '1\\xbc\\xb2\\u0969\\u136b\\u216b\\u2466\\u2480\\u3285'\n\nfor char in sample: print(f'U+{ord(char):04x}', char.center(6), 're_dig' if re_digit.match(char) else '-', 'isdig' if char.isdigit() else '-', 'isnum' if char.isnumeric() else '-', f'{unicodedata.numeric(char):5.2f}', unicodedata.name(char), sep='\\t')\n\nThe Unicode Database\n\n|\n\n153\n\nCode point in U+0000 format.\n\nCharacter centralized in a str of length 6.\n\nShow re_dig if character matches the r'\\d' regex.\n\nShow isdig if char.isdigit() is True.\n\nShow isnum if char.isnumeric() is True.\n\nNumeric value formatted with width 5 and 2 decimal places.\n\nUnicode character name.\n\nRunning Example 4-22 gives you Figure 4-7, if your terminal font has all those glyphs.\n\nFigure 4-7. macOS terminal showing numeric characters and metadata about them; re_dig means the character matches the regular expression r'\\d'.\n\nThe sixth column of Figure 4-7 is the result of calling unicodedata.numeric(char) on the character. It shows that Unicode knows the numeric value of symbols that represent numbers. So if you want to create a spreadsheet application that supports Tamil digits or Roman numerals, go for it!\n\nFigure 4-7 shows that the regular expression r'\\d' matches the digit “1” and the Devanagari digit 3, but not some other characters that are considered digits by the isdigit function. The re module is not as savvy about Unicode as it could be. The new regex module available on PyPI was designed to eventually replace re and pro‐ vides better Unicode support.11 We’ll come back to the re module in the next section.\n\n11 Although it was not better than re at identifying digits in this particular sample.\n\n154\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nThroughout this chapter we’ve used several unicodedata functions, but there are many more we did not cover. See the standard library documentation for the unicode data module.\n\nNext we’ll take a quick look at dual-mode APIs offering functions that accept str or bytes arguments with special handling depending on the type.\n\nDual-Mode str and bytes APIs Python’s standard library has functions that accept str or bytes arguments and behave differently depending on the type. Some examples can be found in the re and os modules.\n\nstr Versus bytes in Regular Expressions If you build a regular expression with bytes, patterns such as \\d and \\w only match ASCII characters; in contrast, if these patterns are given as str, they match Unicode digits or letters beyond ASCII. Example 4-23 and Figure 4-8 compare how letters, ASCII digits, superscripts, and Tamil digits are matched by str and bytes patterns.\n\nExample 4-23. ramanujan.py: compare behavior of simple str and bytes regular expressions\n\nimport re\n\nre_numbers_str = re.compile(r'\\d+') re_words_str = re.compile(r'\\w+') re_numbers_bytes = re.compile(rb'\\d+') re_words_bytes = re.compile(rb'\\w+')\n\ntext_str = (\"Ramanujan saw \\u0be7\\u0bed\\u0be8\\u0bef\" \" as 1729 = 1³ + 12³ = 9³ + 10³.\")\n\ntext_bytes = text_str.encode('utf_8')\n\nprint(f'Text\\n {text_str!r}') print('Numbers') print(' str :', re_numbers_str.findall(text_str)) print(' bytes:', re_numbers_bytes.findall(text_bytes)) print('Words') print(' str :', re_words_str.findall(text_str)) print(' bytes:', re_words_bytes.findall(text_bytes))\n\nThe first two regular expressions are of the str type.\n\nThe last two are of the bytes type.\n\nDual-Mode str and bytes APIs\n\n|\n\n155\n\nUnicode text to search, containing the Tamil digits for 1729 (the logical line con‐ tinues until the right parenthesis token).\n\nThis string is joined to the previous one at compile time (see “2.4.2. String literal concatenation” in The Python Language Reference).\n\nA bytes string is needed to search with the bytes regular expressions.\n\nThe str pattern r'\\d+' matches the Tamil and ASCII digits.\n\nThe bytes pattern rb'\\d+' matches only the ASCII bytes for digits.\n\nThe str pattern r'\\w+' matches the letters, superscripts, Tamil, and ASCII digits.\n\nThe bytes pattern rb'\\w+' matches only the ASCII bytes for letters and digits.\n\nFigure 4-8. Screenshot of running ramanujan.py from Example 4-23.\n\nExample 4-23 is a trivial example to make one point: you can use regular expressions on str and bytes, but in the second case, bytes outside the ASCII range are treated as nondigits and nonword characters.\n\nFor str regular expressions, there is a re.ASCII flag that makes \\w, \\W, \\b, \\B, \\d, \\D, \\s, and \\S perform ASCII-only matching. See the documentation of the re module for full details.\n\nAnother important dual-mode module is os.\n\nstr Versus bytes in os Functions The GNU/Linux kernel is not Unicode savvy, so in the real world you may find file‐ names made of byte sequences that are not valid in any sensible encoding scheme, and cannot be decoded to str. File servers with clients using a variety of OSes are particularly prone to this problem.\n\n156\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "page_number": 163
    },
    {
      "number": 10,
      "title": "Segment 10 (pages 182-201)",
      "start_page": 182,
      "end_page": 201,
      "detection_method": "synthetic",
      "content": "In order to work around this issue, all os module functions that accept filenames or pathnames take arguments as str or bytes. If one such function is called with a str argument, the argument will be automatically converted using the codec named by sys.getfilesystemencoding(), and the OS response will be decoded with the same codec. This is almost always what you want, in keeping with the Unicode sandwich best practice.\n\nBut if you must deal with (and perhaps fix) filenames that cannot be handled in that way, you can pass bytes arguments to the os functions to get bytes return values. This feature lets you deal with any file or pathname, no matter how many gremlins you may find. See Example 4-24.\n\nExample 4-24. listdir with str and bytes arguments and results\n\n>>> os.listdir('.') ['abc.txt', 'digits-of-π.txt'] >>> os.listdir(b'.') [b'abc.txt', b'digits-of-\\xcf\\x80.txt']\n\nThe second filename is “digits-of-π.txt” (with the Greek letter pi).\n\nGiven a byte argument, listdir returns filenames as bytes: b'\\xcf\\x80' is the UTF-8 encoding of the Greek letter pi.\n\nTo help with manual handling of str or bytes sequences that are filenames or path‐ names, the os module provides special encoding and decoding functions os.fsen code(name_or_path) and os.fsdecode(name_or_path). Both of these functions accept an argument of type str, bytes, or an object implementing the os.PathLike interface since Python 3.6.\n\nUnicode is a deep rabbit hole. Time to wrap up our exploration of str and bytes.\n\nChapter Summary We started the chapter by dismissing the notion that 1 character == 1 byte. As the world adopts Unicode, we need to keep the concept of text strings separated from the binary sequences that represent them in files, and Python 3 enforces this separation.\n\nAfter a brief overview of the binary sequence data types—bytes, bytearray, and memoryview—we jumped into encoding and decoding, with a sampling of important codecs, followed by approaches to prevent or deal with the infamous UnicodeEnco deError, UnicodeDecodeError, and the SyntaxError caused by wrong encoding in Python source files.\n\nChapter Summary\n\n|\n\n157\n\nWe then considered the theory and practice of encoding detection in the absence of metadata: in theory, it can’t be done, but in practice the Chardet package pulls it off pretty well for a number of popular encodings. Byte order marks were then presented as the only encoding hint commonly found in UTF-16 and UTF-32 files—sometimes in UTF-8 files as well.\n\nIn the next section, we demonstrated opening text files, an easy task except for one pitfall: the encoding= keyword argument is not mandatory when you open a text file, but it should be. If you fail to specify the encoding, you end up with a program that manages to generate “plain text” that is incompatible across platforms, due to con‐ flicting default encodings. We then exposed the different encoding settings that Python uses as defaults and how to detect them. A sad realization for Windows users is that these settings often have distinct values within the same machine, and the val‐ ues are mutually incompatible; GNU/Linux and macOS users, in contrast, live in a happier place where UTF-8 is the default pretty much everywhere.\n\nUnicode provides multiple ways of representing some characters, so normalizing is a prerequisite for text matching. In addition to explaining normalization and case fold‐ ing, we presented some utility functions that you may adapt to your needs, including drastic transformations like removing all accents. We then saw how to sort Unicode text correctly by leveraging the standard locale module—with some caveats—and an alternative that does not depend on tricky locale configurations: the external pyuca package.\n\nWe leveraged the Unicode database to program a command-line utility to search for characters by name—in 28 lines of code, thanks to the power of Python. We glanced at other Unicode metadata, and had a brief overview of dual-mode APIs where some functions can be called with str or bytes arguments, producing different results.\n\nFurther Reading Ned Batchelder’s 2012 PyCon US talk “Pragmatic Unicode, or, How Do I Stop the Pain?” was outstanding. Ned is so professional that he provides a full transcript of the talk along with the slides and video.\n\n“Character encoding and Unicode in Python: How to (╯°□°)╯︵ ┻━┻ with dig‐ nity” (slides, video) was the excellent PyCon 2014 talk by Esther Nam and Travis Fischer, where I found this chapter’s pithy epigraph: “Humans use text. Computers speak bytes.”\n\nLennart Regebro—one of the technical reviewers for the first edition of this book— shares his “Useful Mental Model of Unicode (UMMU)” in the short post “Unconfus‐ ing Unicode: What Is Unicode?”. Unicode is a complex standard, so Lennart’s UMMU is a really useful starting point.\n\n158\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nThe official “Unicode HOWTO” in the Python docs approaches the subject from sev‐ eral different angles, from a good historic intro, to syntax details, codecs, regular expressions, filenames, and best practices for Unicode-aware I/O (i.e., the Unicode sandwich), with plenty of additional reference links from each section. Chapter 4, “Strings”, of Mark Pilgrim’s awesome book Dive into Python 3 (Apress) also provides a very good intro to Unicode support in Python 3. In the same book, Chapter 15 describes how the Chardet library was ported from Python 2 to Python 3, a valuable case study given that the switch from the old str to the new bytes is the cause of most migration pains, and that is a central concern in a library designed to detect encodings.\n\nIf you know Python 2 but are new to Python 3, Guido van Rossum’s “What’s New in Python 3.0” has 15 bullet points that summarize what changed, with lots of links. Guido starts with the blunt statement: “Everything you thought you knew about binary data and Unicode has changed.” Armin Ronacher’s blog post “The Updated Guide to Unicode on Python” is deep and highlights some of the pitfalls of Unicode in Python 3 (Armin is not a big fan of Python 3).\n\nChapter 2, “Strings and Text,” of the Python Cookbook, 3rd ed. (O’Reilly), by David Beazley and Brian K. Jones, has several recipes dealing with Unicode normalization, sanitizing text, and performing text-oriented operations on byte sequences. Chapter 5 covers files and I/O, and it includes “Recipe 5.17. Writing Bytes to a Text File,” show‐ ing that underlying any text file there is always a binary stream that may be accessed directly when needed. Later in the cookbook, the struct module is put to use in “Recipe 6.11. Reading and Writing Binary Arrays of Structures.”\n\nNick Coghlan’s “Python Notes” blog has two posts very relevant to this chapter: “Python 3 and ASCII Compatible Binary Protocols” and “Processing Text Files in Python 3”. Highly recommended.\n\nA list of encodings supported by Python is available at “Standard Encodings” in the codecs module documentation. If you need to get that list programmatically, see how it’s done in the /Tools/unicode/listcodecs.py script that comes with the CPython source code.\n\nThe books Unicode Explained by Jukka K. Korpela (O’Reilly) and Unicode Demysti‐ fied by Richard Gillam (Addison-Wesley) are not Python-specific but were very help‐ ful as I studied Unicode concepts. Programming with Unicode by Victor Stinner is a free, self-published book (Creative Commons BY-SA) covering Unicode in general, as well as tools and APIs in the context of the main operating systems and a few pro‐ gramming languages, including Python.\n\nThe W3C pages “Case Folding: An Introduction” and “Character Model for the World Wide Web: String Matching” cover normalization concepts, with the former being a gentle introduction and the latter a working group note written in dry\n\nFurther Reading\n\n|\n\n159\n\nstandard-speak—the same tone of the “Unicode Standard Annex #15—Unicode Nor‐ malization Forms”. The “Frequently Asked Questions, Normalization” section from Unicode.org is more readable, as is the “NFC FAQ” by Mark Davis—author of several Unicode algorithms and president of the Unicode Consortium at the time of this writing.\n\nIn 2016, the Museum of Modern Art (MoMA) in New York added to its collection the original emoji, the 176 emojis designed by Shigetaka Kurita in 1999 for NTT DOCOMO—the Japanese mobile carrier. Going further back in history, Emojipedia published “Correcting the Record on the First Emoji Set”, crediting Japan’s SoftBank for the earliest known emoji set, deployed in cell phones in 1997. SoftBank’s set is the source of 90 emojis now in Unicode, including U+1F4A9 (PILE OF POO). Matthew Rothenberg’s emojitracker.com is a live dashboard showing counts of emoji usage on Twitter, updated in real time. As I write this, FACE WITH TEARS OF JOY (U+1F602) is the most popular emoji on Twitter, with more than 3,313,667,315 recorded occurrences.\n\nSoapbox\n\nNon-ASCII Names in Source Code: Should You Use Them?\n\nPython 3 allows non-ASCII identifiers in source code:\n\n>>> ação = 'PBR' # ação = stock >>> ε = 10**-6 # ε = epsilon\n\nSome people dislike the idea. The most common argument to stick with ASCII iden‐ tifiers is to make it easy for everyone to read and edit code. That argument misses the point: you want your source code to be readable and editable by its intended audi‐ ence, and that may not be “everyone.” If the code belongs to a multinational corpora‐ tion or is open source and you want contributors from around the world, the identifiers should be in English, and then all you need is ASCII.\n\nBut if you are a teacher in Brazil, your students will find it easier to read code that uses Portuguese variable and function names, correctly spelled. And they will have no difficulty typing the cedillas and accented vowels on their localized keyboards.\n\nNow that Python can parse Unicode names and UTF-8 is the default source encod‐ ing, I see no point in coding identifiers in Portuguese without accents, as we used to do in Python 2 out of necessity—unless you need the code to run on Python 2 also. If the names are in Portuguese, leaving out the accents won’t make the code more read‐ able to anyone.\n\nThis is my point of view as a Portuguese-speaking Brazilian, but I believe it applies across borders and cultures: choose the human language that makes the code easier to read by the team, then use the characters needed for correct spelling.\n\n160\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nWhat Is “Plain Text”?\n\nFor anyone who deals with non-English text on a daily basis, “plain text” does not imply “ASCII.” The Unicode Glossary defines plain text like this:\n\nComputer-encoded text that consists only of a sequence of code points from a given standard, with no other formatting or structural information.\n\nThat definition starts very well, but I don’t agree with the part after the comma. HTML is a great example of a plain-text format that carries formatting and structural information. But it’s still plain text because every byte in such a file is there to repre‐ sent a text character, usually using UTF-8. There are no bytes with nontext meaning, as you can find in a .png or .xls document where most bytes represent packed binary values like RGB values and floating-point numbers. In plain text, numbers are repre‐ sented as sequences of digit characters.\n\nI am writing this book in a plain-text format called—ironically—AsciiDoc, which is part of the toolchain of O’Reilly’s excellent Atlas book publishing platform. AsciiDoc source files are plain text, but they are UTF-8, not ASCII. Otherwise, writing this chapter would have been really painful. Despite the name, AsciiDoc is just great.\n\nThe world of Unicode is constantly expanding and, at the edges, tool support is not always there. Not all characters I wanted to show were available in the fonts used to render the book. That’s why I had to use images instead of listings in several examples in this chapter. On the other hand, the Ubuntu and macOS terminals display most Unicode text very well—including the Japanese characters for the word “mojibake”: 文字化け.\n\nHow Are str Code Points Represented in RAM?\n\nThe official Python docs avoid the issue of how the code points of a str are stored in memory. It is really an implementation detail. In theory, it doesn’t matter: whatever the internal representation, every str must be encoded to bytes on output.\n\nIn memory, Python 3 stores each str as a sequence of code points using a fixed num‐ ber of bytes per code point, to allow efficient direct access to any character or slice.\n\nSince Python 3.3, when creating a new str object, the interpreter checks the charac‐ ters in it and chooses the most economic memory layout that is suitable for that par‐ ticular str: if there are only characters in the latin1 range, that str will use just one byte per code point. Otherwise, two or four bytes per code point may be used, depending on the str. This is a simplification; for the full details, look up PEP 393— Flexible String Representation.\n\nThe flexible string representation is similar to the way the int type works in Python 3: if the integer fits in a machine word, it is stored in one machine word. Otherwise, the interpreter switches to a variable-length representation like that of the Python 2 long type. It is nice to see the spread of good ideas.\n\nFurther Reading\n\n|\n\n161\n\nHowever, we can always count on Armin Ronacher to find problems in Python 3. He explained to me why that was not such as great idea in practice: it takes a single RAT (U+1F400) to inflate an otherwise all-ASCII text into a memory-hogging array using four bytes per character, when one byte would suffice for each character except the RAT. In addition, because of all the ways Unicode characters combine, the ability to quickly retrieve an arbitrary character by position is overrated—and extracting arbi‐ trary slices from Unicode text is naïve at best, and often wrong, producing mojibake. As emojis become more popular, these problems will only get worse.\n\n162\n\n|\n\nChapter 4: Unicode Text Versus Bytes\n\nCHAPTER 5 Data Class Builders\n\nData classes are like children. They are okay as a starting point, but to participate as a grownup object, they need to take some responsibility.\n\n—Martin Fowler and Kent Beck1\n\nPython offers a few ways to build a simple class that is just a collection of fields, with little or no extra functionality. That pattern is known as a “data class”—and data classes is one of the packages that supports this pattern. This chapter covers three different class builders that you may use as shortcuts to write data classes:\n\ncollections.namedtuple\n\nThe simplest way—available since Python 2.6.\n\ntyping.NamedTuple\n\nAn alternative that requires type hints on the fields—since Python 3.5, with class syntax added in 3.6.\n\n@dataclasses.dataclass\n\nA class decorator that allows more customization than previous alternatives, adding lots of options and potential complexity—since Python 3.7.\n\nAfter covering those class builders, we will discuss why Data Class is also the name of a code smell: a coding pattern that may be a symptom of poor object-oriented design.\n\n1 From Refactoring, first edition, Chapter 3, “Bad Smells in Code, Data Class” section, page 87 (Addison-\n\nWesley).\n\n163\n\ntyping.TypedDict may seem like another data class builder. It uses similar syntax and is described right after typing.NamedTuple in the typing module documentation for Python 3.9. However, TypedDict does not build concrete classes that you can instantiate. It’s just syntax to write type hints for function parame‐ ters and variables that will accept mapping values used as records, with keys as field names. We’ll see them in Chapter 15, “TypedDict” on page 526.\n\nWhat’s New in This Chapter This chapter is new in the second edition of Fluent Python. The section “Classic Named Tuples” on page 169 appeared in Chapter 2 of the first edition, but the rest of the chapter is completely new.\n\nWe begin with a high-level overview of the three class builders.\n\nOverview of Data Class Builders Consider a simple class to represent a geographic coordinate pair, as shown in Example 5-1.\n\nExample 5-1. class/coordinates.py\n\nclass Coordinate:\n\ndef __init__(self, lat, lon): self.lat = lat self.lon = lon\n\nThat Coordinate class does the job of holding latitude and longitude attributes. Writ‐ ing the __init__ boilerplate becomes old real fast, especially if your class has more than a couple of attributes: each of them is mentioned three times! And that boiler‐ plate doesn’t buy us basic features we’d expect from a Python object:\n\n>>> from coordinates import Coordinate >>> moscow = Coordinate(55.76, 37.62) >>> moscow <coordinates.Coordinate object at 0x107142f10> >>> location = Coordinate(55.76, 37.62) >>> location == moscow False >>> (location.lat, location.lon) == (moscow.lat, moscow.lon) True\n\n164\n\n|\n\nChapter 5: Data Class Builders\n\n__repr__ inherited from object is not very helpful.\n\nMeaningless ==; the __eq__ method inherited from object compares object IDs.\n\nComparing two coordinates requires explicit comparison of each attribute.\n\nThe data class builders covered in this chapter provide the necessary __init__, __repr__, and __eq__ methods automatically, as well as other useful features.\n\nNone of the class builders discussed here depend on inheritance to do their work. Both collections.namedtuple and typing.Name dTuple build classes that are tuple subclasses. @dataclass is a class decorator that does not affect the class hierarchy in any way. Each of them uses different metaprogramming techniques to inject methods and data attributes into the class under construction.\n\nHere is a Coordinate class built with namedtuple—a factory function that builds a subclass of tuple with the name and fields you specify:\n\n>>> from collections import namedtuple >>> Coordinate = namedtuple('Coordinate', 'lat lon') >>> issubclass(Coordinate, tuple) True >>> moscow = Coordinate(55.756, 37.617) >>> moscow Coordinate(lat=55.756, lon=37.617) >>> moscow == Coordinate(lat=55.756, lon=37.617) True\n\nUseful __repr__.\n\nMeaningful __eq__.\n\nThe newer typing.NamedTuple provides the same functionality, adding a type anno‐ tation to each field:\n\n>>> import typing >>> Coordinate = typing.NamedTuple('Coordinate', ... [('lat', float), ('lon', float)]) >>> issubclass(Coordinate, tuple) True >>> typing.get_type_hints(Coordinate) {'lat': <class 'float'>, 'lon': <class 'float'>}\n\nOverview of Data Class Builders\n\n|\n\n165\n\nA typed named tuple can also be constructed with the fields given as keyword arguments, like this:\n\nCoordinate = typing.NamedTuple('Coordinate', lat=float, lon=float)\n\nThis is more readable, and also lets you provide the mapping of fields and types as **fields_and_types.\n\nSince Python 3.6, typing.NamedTuple can also be used in a class statement, with type annotations written as described in PEP 526—Syntax for Variable Annotations. This is much more readable, and makes it easy to override methods or add new ones. Example 5-2 is the same Coordinate class, with a pair of float attributes and a cus‐ tom __str__ to display a coordinate formatted like 55.8°N, 37.6°E.\n\nExample 5-2. typing_namedtuple/coordinates.py\n\nfrom typing import NamedTuple\n\nclass Coordinate(NamedTuple): lat: float lon: float\n\ndef __str__(self): ns = 'N' if self.lat >= 0 else 'S' we = 'E' if self.lon >= 0 else 'W' return f'{abs(self.lat):.1f}°{ns}, {abs(self.lon):.1f}°{we}'\n\nAlthough NamedTuple appears in the class statement as a super‐ class, it’s actually not. typing.NamedTuple uses the advanced func‐ tionality of a metaclass2 to customize the creation of the user’s class. Check this out:\n\n>>> issubclass(Coordinate, typing.NamedTuple) False >>> issubclass(Coordinate, tuple) True\n\nIn the __init__ method generated by typing.NamedTuple, the fields appear as parameters in the same order they appear in the class statement.\n\nLike typing.NamedTuple, the dataclass decorator supports PEP 526 syntax to declare instance attributes. The decorator reads the variable annotations and auto‐ matically generates methods for your class. For comparison, check out the equivalent\n\n2 Metaclasses are one of the subjects covered in Chapter 24, “Class Metaprogramming”.\n\n166\n\n|\n\nChapter 5: Data Class Builders\n\nCoordinate class written with the help of the dataclass decorator, as shown in Example 5-3.\n\nExample 5-3. dataclass/coordinates.py\n\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True) class Coordinate: lat: float lon: float\n\ndef __str__(self): ns = 'N' if self.lat >= 0 else 'S' we = 'E' if self.lon >= 0 else 'W' return f'{abs(self.lat):.1f}°{ns}, {abs(self.lon):.1f}°{we}'\n\nNote that the body of the classes in Example 5-2 and Example 5-3 are identical—the difference is in the class statement itself. The @dataclass decorator does not depend on inheritance or a metaclass, so it should not interfere with your own use of these mechanisms.3 The Coordinate class in Example 5-3 is a subclass of object.\n\nMain Features The different data class builders have a lot in common, as summarized in Table 5-1.\n\nTable 5-1. Selected features compared across the three data class builders; x stands for an instance of a data class of that kind\n\nmutable instances\n\nnamedtuple NO\n\nNamedTuple NO\n\ndataclass YES\n\nclass statement syntax\n\nNO\n\nYES\n\nYES\n\nconstruct dict\n\nx._asdict()\n\nx._asdict()\n\ndataclasses.asdict(x)\n\nget field names\n\nx._fields\n\nx._fields\n\n[f.name for f in dataclasses.fields(x)]\n\nget defaults\n\nx._field_defaults\n\nx._field_defaults\n\n[f.default for f in dataclasses.fields(x)]\n\nget field types\n\nN/A\n\nx.__annotations__\n\nx.__annotations__\n\nnew instance with changes\n\nx._replace(…)\n\nx._replace(…)\n\ndataclasses.replace(x, …)\n\nnew class at runtime\n\nnamedtuple(…)\n\nNamedTuple(…)\n\ndataclasses.make_dataclass(…)\n\n3 Class decorators are covered in Chapter 24, “Class Metaprogramming,” along with metaclasses. Both are ways\n\nof customizing class behavior beyond what is possible with inheritance.\n\nOverview of Data Class Builders\n\n|\n\n167\n\nThe classes built by typing.NamedTuple and @dataclass have an __annotations__ attribute holding the type hints for the fields. However, reading from __annotations__ directly is not recom‐ mended. Instead, the recommended best practice to get that information is to call inspect.get_annotations(MyClass) (added in Python 3.10) or typing.get_type_hints(MyClass) (Python 3.5 to 3.9). That’s because those functions provide extra services, like resolving forward references in type hints. We’ll come back to this issue much later in the book, in “Problems with Annotations at Runtime” on page 538.\n\nNow let’s discuss those main features.\n\nMutable instances\n\nA key difference between these class builders is that collections.namedtuple and typing.NamedTuple build tuple subclasses, therefore the instances are immutable. By default, @dataclass produces mutable classes. But the decorator accepts a key‐ word argument frozen—shown in Example 5-3. When frozen=True, the class will raise an exception if you try to assign a value to a field after the instance is initialized.\n\nClass statement syntax\n\nOnly typing.NamedTuple and dataclass support the regular class statement syn‐ tax, making it easier to add methods and docstrings to the class you are creating.\n\nConstruct dict\n\nBoth named tuple variants provide an instance method (._asdict) to construct a dict object from the fields in a data class instance. The dataclasses module pro‐ vides a function to do it: dataclasses.asdict.\n\nGet field names and default values\n\nAll three class builders let you get the field names and default values that may be con‐ figured for them. In named tuple classes, that metadata is in the ._fields and ._fields_defaults class attributes. You can get the same metadata from a data class decorated class using the fields function from the dataclasses module. It returns a tuple of Field objects that have several attributes, including name and default.\n\n168\n\n|\n\nChapter 5: Data Class Builders\n\nGet field types\n\nClasses defined with the help of typing.NamedTuple and @dataclass have a mapping of field names to type the __annotations__ class attribute. As mentioned, use the typing.get_type_hints function instead of reading __annotations__ directly.\n\nNew instance with changes\n\nGiven a named tuple instance x, the call x._replace(**kwargs) returns a new instance with some attribute values replaced according to the keyword arguments given. The dataclasses.replace(x, **kwargs) module-level function does the same for an instance of a dataclass decorated class.\n\nNew class at runtime\n\nAlthough the class statement syntax is more readable, it is hardcoded. A framework may need to build data classes on the fly, at runtime. For that, you can use the default function call syntax of collections.namedtuple, which is likewise supported by typing.NamedTuple. The dataclasses module provides a make_dataclass function for the same purpose.\n\nAfter this overview of the main features of the data class builders, let’s focus on each of them in turn, starting with the simplest.\n\nClassic Named Tuples The collections.namedtuple function is a factory that builds subclasses of tuple enhanced with field names, a class name, and an informative __repr__. Classes built with namedtuple can be used anywhere where tuples are needed, and in fact many functions of the Python standard library that are used to return tuples now return named tuples for convenience, without affecting the user’s code at all.\n\nEach instance of a class built by namedtuple takes exactly the same amount of memory as a tuple because the field names are stored in the class.\n\nExample 5-4 shows how we could define a named tuple to hold information about a city.\n\nExample 5-4. Defining and using a named tuple type\n\n>>> from collections import namedtuple >>> City = namedtuple('City', 'name country population coordinates')\n\nClassic Named Tuples\n\n|\n\n169\n\n>>> tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667)) >>> tokyo City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667)) >>> tokyo.population 36.933 >>> tokyo.coordinates (35.689722, 139.691667) >>> tokyo[1] 'JP'\n\nTwo parameters are required to create a named tuple: a class name and a list of field names, which can be given as an iterable of strings or as a single space- delimited string.\n\nField values must be passed as separate positional arguments to the constructor (in contrast, the tuple constructor takes a single iterable).\n\nYou can access the fields by name or position.\n\nAs a tuple subclass, City inherits useful methods such as __eq__ and the special methods for comparison operators—including __lt__, which allows sorting lists of City instances.\n\nA named tuple offers a few attributes and methods in addition to those inherited from the tuple. Example 5-5 shows the most useful: the _fields class attribute, the class method _make(iterable), and the _asdict() instance method.\n\nExample 5-5. Named tuple attributes and methods (continued from the previous example)\n\n>>> City._fields ('name', 'country', 'population', 'location') >>> Coordinate = namedtuple('Coordinate', 'lat lon') >>> delhi_data = ('Delhi NCR', 'IN', 21.935, Coordinate(28.613889, 77.208889)) >>> delhi = City._make(delhi_data) >>> delhi._asdict() {'name': 'Delhi NCR', 'country': 'IN', 'population': 21.935, 'location': Coordinate(lat=28.613889, lon=77.208889)} >>> import json >>> json.dumps(delhi._asdict()) '{\"name\": \"Delhi NCR\", \"country\": \"IN\", \"population\": 21.935, \"location\": [28.613889, 77.208889]}'\n\n._fields is a tuple with the field names of the class.\n\n._make() builds City from an iterable; City(*delhi_data) would do the same.\n\n170\n\n|\n\nChapter 5: Data Class Builders\n\n._asdict() returns a dict built from the named tuple instance.\n\n._asdict() is useful to serialize the data in JSON format, for example.\n\nThe _asdict method returned an OrderedDict until Python 3.7. Since Python 3.8, it returns a simple dict—which is OK now that we can rely on key insertion order. If you must have an Ordered Dict, the _asdict documentation recommends building one from the result: OrderedDict(x._asdict()).\n\nSince Python 3.7, namedtuple accepts the defaults keyword-only argument provid‐ ing an iterable of N default values for each of the N rightmost fields of the class. Example 5-6 shows how to define a Coordinate named tuple with a default value for a reference field.\n\nExample 5-6. Named tuple attributes and methods, continued from Example 5-5\n\n>>> Coordinate = namedtuple('Coordinate', 'lat lon reference', defaults=['WGS84']) >>> Coordinate(0, 0) Coordinate(lat=0, lon=0, reference='WGS84') >>> Coordinate._field_defaults {'reference': 'WGS84'}\n\nIn “Class statement syntax” on page 168, I mentioned it’s easier to code methods with the class syntax supported by typing.NamedTuple and @dataclass. You can also add methods to a namedtuple, but it’s a hack. Skip the following box if you’re not interes‐ ted in hacks.\n\nHacking a namedtuple to Inject a Method\n\nRecall how we built the Card class in Example 1-1 in Chapter 1:\n\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n\nLater in Chapter 1, I wrote a spades_high function for sorting. It would be nice if that logic was encapsulated in a method of Card, but adding spades_high to Card without the benefit of a class statement requires a quick hack: define the function and then assign it to a class attribute. Example 5-7 shows how.\n\nExample 5-7. frenchdeck.doctest: Adding a class attribute and a method to Card, the namedtuple from “A Pythonic Card Deck” on page 5\n\n>>> Card.suit_values = dict(spades=3, hearts=2, diamonds=1, clubs=0) >>> def spades_high(card): ... rank_value = FrenchDeck.ranks.index(card.rank)\n\nClassic Named Tuples\n\n|\n\n171\n\n... suit_value = card.suit_values[card.suit] ... return rank_value * len(card.suit_values) + suit_value ... >>> Card.overall_rank = spades_high >>> lowest_card = Card('2', 'clubs') >>> highest_card = Card('A', 'spades') >>> lowest_card.overall_rank() 0 >>> highest_card.overall_rank() 51\n\nAttach a class attribute with values for each suit.\n\nspades_high will become a method; the first argument doesn’t need to be named self. Anyway, it will get the receiver when called as a method.\n\nAttach the function to the Card class as a method named overall_rank.\n\nIt works!\n\nFor readability and future maintenance, it’s much better to code methods inside a class statement. But it’s good to know this hack is possible, because it may come in handy.4\n\nThis was a small detour to showcase the power of a dynamic language.\n\nNow let’s check out the typing.NamedTuple variation.\n\nTyped Named Tuples The Coordinate class with a default field from Example 5-6 can be written using typing.NamedTuple, as shown in Example 5-8.\n\nExample 5-8. typing_namedtuple/coordinates2.py\n\nfrom typing import NamedTuple\n\nclass Coordinate(NamedTuple): lat: float lon: float reference: str = 'WGS84'\n\n4 If you know Ruby, you know that injecting methods is a well-known but controversial technique among\n\nRubyists. In Python, it’s not as common, because it doesn’t work with any built-in type—str, list, etc. I con‐ sider this limitation of Python a blessing.\n\n172\n\n|\n\nChapter 5: Data Class Builders\n\nEvery instance field must be annotated with a type.\n\nThe reference instance field is annotated with a type and a default value.\n\nClasses built by typing.NamedTuple don’t have any methods beyond those that col lections.namedtuple also generates—and those that are inherited from tuple. The only difference is the presence of the __annotations__ class attribute—which Python completely ignores at runtime.\n\nGiven that the main feature of typing.NamedTuple are the type annotations, we’ll take a brief look at them before resuming our exploration of data class builders.\n\nType Hints 101 Type hints—a.k.a. type annotations—are ways to declare the expected type of func‐ tion arguments, return values, variables, and attributes.\n\nThe first thing you need to know about type hints is that they are not enforced at all by the Python bytecode compiler and interpreter.\n\nThis is a very brief introduction to type hints, just enough to make sense of the syntax and meaning of the annotations used in typ ing.NamedTuple and @dataclass declarations. We will cover type hints for function signatures in Chapter 8 and more advanced annotations in Chapter 15. Here we’ll mostly see hints with simple built-in types, such as str, int, and float, which are probably the most common types used to annotate fields of data classes.\n\nNo Runtime Effect Think about Python type hints as “documentation that can be verified by IDEs and type checkers.”\n\nThat’s because type hints have no impact on the runtime behavior of Python pro‐ grams. Check out Example 5-9.\n\nExample 5-9. Python does not enforce type hints at runtime\n\n>>> import typing >>> class Coordinate(typing.NamedTuple): ... lat: float ... lon: float ... >>> trash = Coordinate('Ni!', None) >>> print(trash) Coordinate(lat='Ni!', lon=None)\n\nType Hints 101\n\n|\n\n173\n\nI told you: no type checking at runtime!\n\nIf you type the code of Example 5-9 in a Python module, it will run and display a meaningless Coordinate, with no error or warning:\n\n$ python3 nocheck_demo.py Coordinate(lat='Ni!', lon=None)\n\nThe type hints are intended primarily to support third-party type checkers, like Mypy or the PyCharm IDE built-in type checker. These are static analysis tools: they check Python source code “at rest,” not running code.\n\nTo see the effect of type hints, you must run one of those tools on your code—like a linter. For instance, here is what Mypy has to say about the previous example:\n\n$ mypy nocheck_demo.py nocheck_demo.py:8: error: Argument 1 to \"Coordinate\" has incompatible type \"str\"; expected \"float\" nocheck_demo.py:8: error: Argument 2 to \"Coordinate\" has incompatible type \"None\"; expected \"float\"\n\nAs you can see, given the definition of Coordinate, Mypy knows that both arguments to create an instance must be of type float, but the assignment to trash uses a str and None.5\n\nNow let’s talk about the syntax and meaning of type hints.\n\nVariable Annotation Syntax Both typing.NamedTuple and @dataclass use the syntax of variable annotations defined in PEP 526. This is a quick introduction to that syntax in the context defining attributes in class statements.\n\nThe basic syntax of variable annotation is:\n\nvar_name: some_type\n\nThe “Acceptable type hints” section in PEP 484 explains what are acceptable types, but in the context of defining a data class, these types are more likely to be useful:\n\nA concrete class, for example, str or FrenchDeck • A parameterized collection type, like list[int], tuple[str, float], etc.\n\n5 In the context of type hints, None is not the NoneType singleton, but an alias for NoneType itself. This is strange when we stop to think about it, but appeals to our intuition and makes function return annotations easier to read in the common case of functions that return None.\n\n174\n\n|\n\nChapter 5: Data Class Builders\n\ntyping.Optional, for example, Optional[str]—to declare a field that can be a str or None\n\nYou can also initialize the variable with a value. In a typing.NamedTuple or @data class declaration, that value will become the default for that attribute if the corre‐ sponding argument is omitted in the constructor call:\n\nvar_name: some_type = a_value\n\nThe Meaning of Variable Annotations We saw in “No Runtime Effect” on page 173 that type hints have no effect at runtime. But at import time—when a module is loaded—Python does read them to build the __annotations__ dictionary that typing.NamedTuple and @dataclass then use to enhance the class.\n\nWe’ll start this exploration with a simple class in Example 5-10, so that we can later see what extra features are added by typing.NamedTuple and @dataclass.\n\nExample 5-10. meaning/demo_plain.py: a plain class with type hints\n\nclass DemoPlainClass: a: int b: float = 1.1 c = 'spam'\n\na becomes an entry in __annotations__, but is otherwise discarded: no attribute named a is created in the class.\n\nb is saved as an annotation, and also becomes a class attribute with value 1.1.\n\nc is just a plain old class attribute, not an annotation.\n\nWe can verify that in the console, first reading the __annotations__ of the Demo PlainClass, then trying to get its attributes named a, b, and c:\n\n>>> from demo_plain import DemoPlainClass >>> DemoPlainClass.__annotations__ {'a': <class 'int'>, 'b': <class 'float'>} >>> DemoPlainClass.a Traceback (most recent call last): File \"<stdin>\", line 1, in <module> AttributeError: type object 'DemoPlainClass' has no attribute 'a' >>> DemoPlainClass.b 1.1 >>> DemoPlainClass.c 'spam'\n\nType Hints 101\n\n|\n\n175\n\nNote that the __annotations__ special attribute is created by the interpreter to record the type hints that appear in the source code—even in a plain class.\n\nThe a survives only as an annotation. It doesn’t become a class attribute because no value is bound to it.6 The b and c are stored as class attributes because they are bound to values.\n\nNone of those three attributes will be in a new instance of DemoPlainClass. If you create an object o = DemoPlainClass(), o.a will raise AttributeError, while o.b and o.c will retrieve the class attributes with values 1.1 and 'spam'—that’s just nor‐ mal Python object behavior.\n\nInspecting a typing.NamedTuple\n\nNow let’s examine a class built with typing.NamedTuple (Example 5-11), using the same attributes and annotations as DemoPlainClass from Example 5-10.\n\nExample 5-11. meaning/demo_nt.py: a class built with typing.NamedTuple\n\nimport typing\n\nclass DemoNTClass(typing.NamedTuple): a: int b: float = 1.1 c = 'spam'\n\na becomes an annotation and also an instance attribute.\n\nb is another annotation, and also becomes an instance attribute with default value 1.1.\n\nc is just a plain old class attribute; no annotation will refer to it.\n\nInspecting the DemoNTClass, we get:\n\n>>> from demo_nt import DemoNTClass >>> DemoNTClass.__annotations__ {'a': <class 'int'>, 'b': <class 'float'>} >>> DemoNTClass.a <_collections._tuplegetter object at 0x101f0f940> >>> DemoNTClass.b <_collections._tuplegetter object at 0x101f0f8b0> >>> DemoNTClass.c 'spam'\n\n6 Python has no concept of undefined, one of the silliest mistakes in the design of JavaScript. Thank Guido!\n\n176\n\n|\n\nChapter 5: Data Class Builders",
      "page_number": 182
    },
    {
      "number": 11,
      "title": "Segment 11 (pages 202-220)",
      "start_page": 202,
      "end_page": 220,
      "detection_method": "synthetic",
      "content": "Here we have the same annotations for a and b as we saw in Example 5-10. But typ ing.NamedTuple creates a and b class attributes. The c attribute is just a plain class attribute with the value 'spam'.\n\nThe a and b class attributes are descriptors—an advanced feature covered in Chap‐ ter 23. For now, think of them as similar to property getters: methods that don’t require the explicit call operator () to retrieve an instance attribute. In practice, this means a and b will work as read-only instance attributes—which makes sense when we recall that DemoNTClass instances are just fancy tuples, and tuples are immutable.\n\nDemoNTClass also gets a custom docstring:\n\n>>> DemoNTClass.__doc__ 'DemoNTClass(a, b)'\n\nLet’s inspect an instance of DemoNTClass:\n\n>>> nt = DemoNTClass(8) >>> nt.a 8 >>> nt.b 1.1 >>> nt.c 'spam'\n\nTo construct nt, we need to give at least the a argument to DemoNTClass. The con‐ structor also takes a b argument, but it has a default value of 1.1, so it’s optional. The nt object has the a and b attributes as expected; it doesn’t have a c attribute, but Python retrieves it from the class, as usual.\n\nIf you try to assign values to nt.a, nt.b, nt.c, or even nt.z, you’ll get Attribute Error exceptions with subtly different error messages. Try that and reflect on the messages.\n\nInspecting a class decorated with dataclass\n\nNow, we’ll examine Example 5-12.\n\nExample 5-12. meaning/demo_dc.py: a class decorated with @dataclass\n\nfrom dataclasses import dataclass\n\n@dataclass class DemoDataClass: a: int b: float = 1.1 c = 'spam'\n\nType Hints 101\n\n|\n\n177\n\na becomes an annotation and also an instance attribute controlled by a descriptor.\n\nb is another annotation, and also becomes an instance attribute with a descriptor and a default value 1.1.\n\nc is just a plain old class attribute; no annotation will refer to it.\n\nNow let’s check out __annotations__, __doc__, and the a, b, c attributes on Demo DataClass:\n\n>>> from demo_dc import DemoDataClass >>> DemoDataClass.__annotations__ {'a': <class 'int'>, 'b': <class 'float'>} >>> DemoDataClass.__doc__ 'DemoDataClass(a: int, b: float = 1.1)' >>> DemoDataClass.a Traceback (most recent call last): File \"<stdin>\", line 1, in <module> AttributeError: type object 'DemoDataClass' has no attribute 'a' >>> DemoDataClass.b 1.1 >>> DemoDataClass.c 'spam'\n\nThe __annotations__ and __doc__ are not surprising. However, there is no attribute named a in DemoDataClass—in contrast with DemoNTClass from Example 5-11, which has a descriptor to get a from the instances as read-only attributes (that myste‐ rious <_collections._tuplegetter>). That’s because the a attribute will only exist in instances of DemoDataClass. It will be a public attribute that we can get and set, unless the class is frozen. But b and c exist as class attributes, with b holding the default value for the b instance attribute, while c is just a class attribute that will not be bound to the instances.\n\nNow let’s see how a DemoDataClass instance looks:\n\n>>> dc = DemoDataClass(9) >>> dc.a 9 >>> dc.b 1.1 >>> dc.c 'spam'\n\nAgain, a and b are instance attributes, and c is a class attribute we get via the instance.\n\nAs mentioned, DemoDataClass instances are mutable—and no type checking is done at runtime:\n\n178\n\n|\n\nChapter 5: Data Class Builders\n\n>>> dc.a = 10 >>> dc.b = 'oops'\n\nWe can do even sillier assignments:\n\n>>> dc.c = 'whatever' >>> dc.z = 'secret stash'\n\nNow the dc instance has a c attribute—but that does not change the c class attribute. And we can add a new z attribute. This is normal Python behavior: regular instances can have their own attributes that don’t appear in the class.7\n\nMore About @dataclass We’ve only seen simple examples of @dataclass use so far. The decorator accepts several keyword arguments. This is its signature:\n\n@dataclass(*, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)\n\nThe * in the first position means the remaining parameters are keyword-only. Table 5-2 describes them.\n\nTable 5-2. Keyword parameters accepted by the @dataclass decorator\n\nOption\n\ninit\n\nMeaning Generate __init__\n\nDefault\n\nTrue\n\nNotes Ignored if __init__ is implemented by user.\n\nrepr\n\nGenerate __repr__\n\nTrue\n\nIgnored if __repr__ is implemented by user.\n\neq\n\nGenerate __eq__\n\nTrue\n\nIgnored if __eq__ is implemented by user.\n\norder\n\nGenerate __lt__, __le__, __gt__, __ge__\n\nFalse\n\nIf True, raises exceptions if eq=False, or if any of the comparison methods that would be generated are defined or inherited.\n\nunsafe_hash\n\nGenerate __hash__\n\nFalse\n\nComplex semantics and several caveats— see: dataclass documentation.\n\nfrozen\n\nMake instances “immutable”\n\nFalse\n\nInstances will be reasonably safe from accidental change, but not really immutable.a\n\na @dataclass emulates immutability by generating __setattr__ and __delattr__, which raise data class.FrozenInstanceError—a subclass of AttributeError—when the user attempts to set or delete a field.\n\n7 Setting an attribute after __init__ defeats the __dict__ key-sharing memory optimization mentioned in\n\n“Practical Consequences of How dict Works” on page 102.\n\nMore About @dataclass\n\n|\n\n179\n\nThe defaults are really the most useful settings for common use cases. The options you are more likely to change from the defaults are:\n\nfrozen=True\n\nProtects against accidental changes to the class instances.\n\norder=True\n\nAllows sorting of instances of the data class.\n\nGiven the dynamic nature of Python objects, it’s not too hard for a nosy programmer to go around the protection afforded by frozen=True. But the necessary tricks should be easy to spot in a code review.\n\nIf the eq and frozen arguments are both True, @dataclass produces a suitable __hash__ method, so the instances will be hashable. The generated __hash__ will use data from all fields that are not individually excluded using a field option we’ll see in “Field Options” on page 180. If frozen=False (the default), @dataclass will set __hash__ to None, signalling that the instances are unhashable, therefore overriding __hash__ from any superclass.\n\nPEP 557—Data Classes has this to say about unsafe_hash:\n\nAlthough not recommended, you can force Data Classes to create a __hash__ method with unsafe_hash=True. This might be the case if your class is logically immutable but can nonetheless be mutated. This is a specialized use case and should be considered carefully.\n\nI will leave unsafe_hash at that. If you feel you must use that option, check the data classes.dataclass documentation.\n\nFurther customization of the generated data class can be done at a field level.\n\nField Options We’ve already seen the most basic field option: providing (or not) a default value with the type hint. The instance fields you declare will become parameters in the gen‐ erated __init__. Python does not allow parameters without defaults after parameters with defaults, therefore after you declare a field with a default value, all remaining fields must also have default values.\n\nMutable default values are a common source of bugs for beginning Python develop‐ ers. In function definitions, a mutable default value is easily corrupted when one invocation of the function mutates the default, changing the behavior of further invo‐ cations—an issue we’ll explore in “Mutable Types as Parameter Defaults: Bad Idea” on page 214 (Chapter 6). Class attributes are often used as default attribute values for instances, including in data classes. And @dataclass uses the default values in the\n\n180\n\n|\n\nChapter 5: Data Class Builders\n\ntype hints to generate parameters with defaults for __init__. To prevent bugs, @data class rejects the class definition in Example 5-13.\n\nExample 5-13. dataclass/club_wrong.py: this class raises ValueError\n\n@dataclass class ClubMember: name: str guests: list = []\n\nIf you load the module with that ClubMember class, this is what you get:\n\n$ python3 club_wrong.py Traceback (most recent call last): File \"club_wrong.py\", line 4, in <module> class ClubMember: ...several lines omitted... ValueError: mutable default <class 'list'> for field guests is not allowed: use default_factory\n\nThe ValueError message explains the problem and suggests a solution: use default_factory. Example 5-14 shows how to correct ClubMember.\n\nExample 5-14. dataclass/club.py: this ClubMember definition works\n\nfrom dataclasses import dataclass, field\n\n@dataclass class ClubMember: name: str guests: list = field(default_factory=list)\n\nIn the guests field of Example 5-14, instead of a literal list, the default value is set by calling the dataclasses.field function with default_factory=list.\n\nThe default_factory parameter lets you provide a function, class, or any other call‐ able, which will be invoked with zero arguments to build a default value each time an instance of the data class is created. This way, each instance of ClubMember will have its own list—instead of all instances sharing the same list from the class, which is rarely what we want and is often a bug.\n\nIt’s good that @dataclass rejects class definitions with a list default value in a field. However, be aware that it is a partial solu‐ tion that only applies to list, dict, and set. Other mutable values used as defaults will not be flagged by @dataclass. It’s up to you to understand the problem and remember to use a default factory to set mutable default values.\n\nMore About @dataclass\n\n|\n\n181\n\nIf you browse the dataclasses module documentation, you’ll see a list field defined with a novel syntax, as in Example 5-15.\n\nExample 5-15. dataclass/club_generic.py: this ClubMember definition is more precise\n\nfrom dataclasses import dataclass, field\n\n@dataclass class ClubMember: name: str guests: list[str] = field(default_factory=list)\n\nlist[str] means “a list of str.”\n\nThe new syntax list[str] is a parameterized generic type: since Python 3.9, the list built-in accepts that bracket notation to specify the type of the list items.\n\nPrior to Python 3.9, the built-in collections did not support generic type notation. As a temporary workaround, there are correspond‐ ing collection types in the typing module. If you need a parameter‐ ized list type hint in Python 3.8 or earlier, you must import the List type from typing and use it: List[str]. For more about this issue, see “Legacy Support and Deprecated Collection Types” on page 272.\n\nWe’ll cover generics in Chapter 8. For now, note that Examples 5-14 and 5-15 are both correct, and the Mypy type checker does not complain about either of those class definitions.\n\nThe difference is that guests: list means that guests can be a list of objects of any kind, while guests: list[str] says that guests must be a list in which every item is a str. This will allow the type checker to find (some) bugs in code that puts invalid items in the list, or that read items from it.\n\nThe default_factory is likely to be the most common option of the field function, but there are several others, listed in Table 5-3.\n\nTable 5-3. Keyword arguments accepted by the field function\n\nOption\n\ndefault\n\nMeaning Default value for field\n\nDefault _MISSING_TYPEa\n\ndefault_factory\n\n0-parameter function used to produce a default _MISSING_TYPE\n\ninit\n\nInclude field in parameters to __init__\n\nTrue\n\nrepr\n\nInclude field in __repr__\n\nTrue\n\n182\n\n|\n\nChapter 5: Data Class Builders\n\nOption\n\ncompare\n\nMeaning Use field in comparison methods __eq__, __lt__, etc.\n\nDefault\n\nTrue\n\nhash\n\nInclude field in __hash__ calculation\n\nNoneb\n\nmetadata\n\nMapping with user-defined data; ignored by the @dataclass\n\nNone\n\na dataclass._MISSING_TYPE is a sentinel value indicating the option was not provided. It exists so we can set None as an actual default value, a common use case. b The option hash=None means the field will be used in __hash__ only if compare=True.\n\nThe default option exists because the field call takes the place of the default value in the field annotation. If you want to create an athlete field with a default value of False, and also omit that field from the __repr__ method, you’d write this:\n\n@dataclass class ClubMember: name: str guests: list = field(default_factory=list) athlete: bool = field(default=False, repr=False)\n\nPost-init Processing The __init__ method generated by @dataclass only takes the arguments passed and assigns them—or their default values, if missing—to the instance attributes that are instance fields. But you may need to do more than that to initialize the instance. If that’s the case, you can provide a __post_init__ method. When that method exists, @dataclass will add code to the generated __init__ to call __post_init__ as the last step.\n\nCommon use cases for __post_init__ are validation and computing field values based on other fields. We’ll study a simple example that uses __post_init__ for both of these reasons.\n\nFirst, let’s look at the expected behavior of a ClubMember subclass named HackerClub Member, as described by doctests in Example 5-16.\n\nExample 5-16. dataclass/hackerclub.py: doctests for HackerClubMember\n\n\"\"\" ``HackerClubMember`` objects accept an optional ``handle`` argument::\n\n>>> anna = HackerClubMember('Anna Ravenscroft', handle='AnnaRaven') >>> anna HackerClubMember(name='Anna Ravenscroft', guests=[], handle='AnnaRaven')\n\nIf ``handle`` is omitted, it's set to the first part of the member's name::\n\nMore About @dataclass\n\n|\n\n183\n\n>>> leo = HackerClubMember('Leo Rochael') >>> leo HackerClubMember(name='Leo Rochael', guests=[], handle='Leo')\n\nMembers must have a unique handle. The following ``leo2`` will not be created, because its ``handle`` would be 'Leo', which was taken by ``leo``::\n\n>>> leo2 = HackerClubMember('Leo DaVinci') Traceback (most recent call last): ... ValueError: handle 'Leo' already exists.\n\nTo fix, ``leo2`` must be created with an explicit ``handle``::\n\n>>> leo2 = HackerClubMember('Leo DaVinci', handle='Neo') >>> leo2 HackerClubMember(name='Leo DaVinci', guests=[], handle='Neo') \"\"\"\n\nNote that we must provide handle as a keyword argument, because HackerClubMem ber inherits name and guests from ClubMember, and adds the handle field. The gen‐ erated docstring for HackerClubMember shows the order of the fields in the constructor call:\n\n>>> HackerClubMember.__doc__ \"HackerClubMember(name: str, guests: list = <factory>, handle: str = '')\"\n\nHere, <factory> is a short way of saying that some callable will produce the default value for guests (in our case, the factory is the list class). The point is: to provide a handle but no guests, we must pass handle as a keyword argument.\n\nThe “Inheritance” section of the dataclasses module documentation explains how the order of the fields is computed when there are several levels of inheritance.\n\nIn Chapter 14 we’ll talk about misusing inheritance, particularly when the superclasses are not abstract. Creating a hierarchy of data classes is usually a bad idea, but it served us well here to make Example 5-17 shorter, focusing on the handle field declaration and __post_init__ validation.\n\nExample 5-17 shows the implementation.\n\nExample 5-17. dataclass/hackerclub.py: code for HackerClubMember\n\nfrom dataclasses import dataclass from club import ClubMember\n\n184\n\n|\n\nChapter 5: Data Class Builders\n\n@dataclass class HackerClubMember(ClubMember): all_handles = set() handle: str = ''\n\ndef __post_init__(self): cls = self.__class__ if self.handle == '': self.handle = self.name.split()[0] if self.handle in cls.all_handles: msg = f'handle {self.handle!r} already exists.' raise ValueError(msg) cls.all_handles.add(self.handle)\n\nHackerClubMember extends ClubMember.\n\nall_handles is a class attribute.\n\nhandle is an instance field of type str with an empty string as its default value; this makes it optional.\n\nGet the class of the instance.\n\nIf self.handle is the empty string, set it to the first part of name.\n\nIf self.handle is in cls.all_handles, raise ValueError.\n\nAdd the new handle to cls.all_handles.\n\nExample 5-17 works as intended, but is not satisfactory to a static type checker. Next, we’ll see why, and how to fix it.\n\nTyped Class Attributes If we type check Example 5-17 with Mypy, we are reprimanded:\n\n$ mypy hackerclub.py hackerclub.py:37: error: Need type annotation for \"all_handles\" (hint: \"all_handles: Set[<type>] = ...\") Found 1 error in 1 file (checked 1 source file)\n\nUnfortunately, the hint provided by Mypy (version 0.910 as I review this) is not help‐ ful in the context of @dataclass usage. First, it suggests using Set, but I am using Python 3.9 so I can use set—and avoid importing Set from typing. More impor‐ tantly, if we add a type hint like set[…] to all_handles, @dataclass will find that annotation and make all_handles an instance field. We saw this happening in “Inspecting a class decorated with dataclass” on page 177.\n\nMore About @dataclass\n\n|\n\n185\n\nThe workaround defined in PEP 526—Syntax for Variable Annotations is ugly. To code a class variable with a type hint, we need to use a pseudotype named typ ing.ClassVar, which leverages the generics [] notation to set the type of the variable and also declare it a class attribute.\n\nTo make the type checker and @dataclass happy, this is how we are supposed to declare all_handles in Example 5-17:\n\nall_handles: ClassVar[set[str]] = set()\n\nThat type hint is saying:\n\nall_handles is a class attribute of type set-of-str, with an empty set as its default value.\n\nTo code that annotation, we must import ClassVar from the typing module.\n\nThe @dataclass decorator doesn’t care about the types in the annotations, except in two cases, and this is one of them: if the type is ClassVar, an instance field will not be generated for that attribute.\n\nThe other case where the type of the field is relevant to @dataclass is when declaring init-only variables, our next topic.\n\nInitialization Variables That Are Not Fields Sometimes you may need to pass arguments to __init__ that are not instance fields. Such arguments are called init-only variables by the dataclasses documentation. To declare an argument like that, the dataclasses module provides the pseudotype Init Var, which uses the same syntax of typing.ClassVar. The example given in the doc‐ umentation is a data class that has a field initialized from a database, and the database object must be passed to the constructor.\n\nExample 5-18 shows the code that illustrates the “Init-only variables” section.\n\nExample 5-18. Example from the dataclasses module documentation\n\n@dataclass class C: i: int j: int = None database: InitVar[DatabaseType] = None\n\ndef __post_init__(self, database): if self.j is None and database is not None: self.j = database.lookup('j')\n\nc = C(10, database=my_database)\n\n186\n\n|\n\nChapter 5: Data Class Builders\n\nNote how the database attribute is declared. InitVar will prevent @dataclass from treating database as a regular field. It will not be set as an instance attribute, and the dataclasses.fields function will not list it. However, database will be one of the arguments that the generated __init__ will accept, and it will be also passed to __post_init__. If you write that method, you must add a corresponding argument to the method signature, as shown in Example 5-18.\n\nThis rather long overview of @dataclass covered the most useful features—some of them appeared in previous sections, like “Main Features” on page 167 where we cov‐ ered all three data class builders in parallel. The dataclasses documentation and PEP 526—Syntax for Variable Annotations have all the details.\n\nIn the next section, I present a longer example with @dataclass.\n\n@dataclass Example: Dublin Core Resource Record Often, classes built with @dataclass will have more fields than the very short exam‐ ples presented so far. Dublin Core provides the foundation for a more typical @data class example.\n\nThe Dublin Core Schema is a small set of vocabulary terms that can be used to describe digital resources (video, images, web pages, etc.), as well as physical resources such as books or CDs, and objects like artworks.8\n\n—Dublin Core on Wikipedia\n\nThe standard defines 15 optional fields; the Resource class in Example 5-19 uses 8 of them.\n\nExample 5-19. dataclass/resource.py: code for Resource, a class based on Dublin Core terms\n\nfrom dataclasses import dataclass, field from typing import Optional from enum import Enum, auto from datetime import date\n\nclass ResourceType(Enum): BOOK = auto() EBOOK = auto() VIDEO = auto()\n\n@dataclass\n\n8 Source: Dublin Core article in the English Wikipedia.\n\nMore About @dataclass\n\n|\n\n187\n\nclass Resource: \"\"\"Media resource description.\"\"\" identifier: str title: str = '<untitled>' creators: list[str] = field(default_factory=list) date: Optional[date] = None type: ResourceType = ResourceType.BOOK description: str = '' language: str = '' subjects: list[str] = field(default_factory=list)\n\nThis Enum will provide type-safe values for the Resource.type field.\n\nidentifier is the only required field.\n\ntitle is the first field with a default. This forces all fields below to provide defaults.\n\nThe value of date can be a datetime.date instance, or None.\n\nThe type field default is ResourceType.BOOK.\n\nExample 5-20 shows a doctest to demonstrate how a Resource record appears in code.\n\nExample 5-20. dataclass/resource.py: code for Resource, a class based on Dublin Core terms\n\n>>> description = 'Improving the design of existing code' >>> book = Resource('978-0-13-475759-9', 'Refactoring, 2nd Edition', ... ['Martin Fowler', 'Kent Beck'], date(2018, 11, 19), ... ResourceType.BOOK, description, 'EN', ... ['computer programming', 'OOP']) >>> book # doctest: +NORMALIZE_WHITESPACE Resource(identifier='978-0-13-475759-9', title='Refactoring, 2nd Edition', creators=['Martin Fowler', 'Kent Beck'], date=datetime.date(2018, 11, 19), type=<ResourceType.BOOK: 1>, description='Improving the design of existing code', language='EN', subjects=['computer programming', 'OOP'])\n\nThe __repr__ generated by @dataclass is OK, but we can make it more readable. This is the format we want from repr(book):\n\n>>> book # doctest: +NORMALIZE_WHITESPACE Resource( identifier = '978-0-13-475759-9', title = 'Refactoring, 2nd Edition', creators = ['Martin Fowler', 'Kent Beck'], date = datetime.date(2018, 11, 19), type = <ResourceType.BOOK: 1>,\n\n188\n\n|\n\nChapter 5: Data Class Builders\n\ndescription = 'Improving the design of existing code', language = 'EN', subjects = ['computer programming', 'OOP'], )\n\nExample 5-21 is the code of __repr__ to produce the format shown in the last snip‐ pet. This example uses dataclass.fields to get the names of the data class fields.\n\nExample 5-21. dataclass/resource_repr.py: code for __repr__ method implemented in the Resource class from Example 5-19\n\ndef __repr__(self): cls = self.__class__ cls_name = cls.__name__ indent = ' ' * 4 res = [f'{cls_name}('] for f in fields(cls): value = getattr(self, f.name) res.append(f'{indent}{f.name} = {value!r},')\n\nres.append(')') return '\\n'.join(res)\n\nStart the res list to build the output string with the class name and open parenthesis.\n\nFor each field f in the class…\n\n…get the named attribute from the instance.\n\nAppend an indented line with the name of the field and repr(value)—that’s what the !r does.\n\nAppend closing parenthesis.\n\nBuild a multiline string from res and return it.\n\nWith this example inspired by the soul of Dublin, Ohio, we conclude our tour of Python’s data class builders.\n\nData classes are handy, but your project may suffer if you overuse them. The next section explains.\n\nMore About @dataclass\n\n|\n\n189\n\nData Class as a Code Smell Whether you implement a data class by writing all the code yourself or leveraging one of the class builders described in this chapter, be aware that it may signal a prob‐ lem in your design.\n\nIn Refactoring: Improving the Design of Existing Code, 2nd ed. (Addison-Wesley), Martin Fowler and Kent Beck present a catalog of “code smells”—patterns in code that may indicate the need for refactoring. The entry titled “Data Class” starts like this:\n\nThese are classes that have fields, getting and setting methods for fields, and nothing else. Such classes are dumb data holders and are often being manipulated in far too much detail by other classes.\n\nIn Fowler’s personal website, there’s an illuminating post titled “Code Smell”. The post is very relevant to our discussion because he uses data class as one example of a code smell and suggests how to deal with it. Here is the post, reproduced in full.9\n\nCode Smell\n\nBy Martin Fowler\n\nA code smell is a surface indication that usually corresponds to a deeper problem in the system. The term was first coined by Kent Beck while helping me with my Refac‐ toring book.\n\nThe quick definition above contains a couple of subtle points. Firstly, a smell is by definition something that’s quick to spot—or sniffable as I’ve recently put it. A long method is a good example of this—just looking at the code and my nose twitches if I see more than a dozen lines of Java.\n\nThe second is that smells don’t always indicate a problem. Some long methods are just fine. You have to look deeper to see if there is an underlying problem there— smells aren’t inherently bad on their own—they are often an indicator of a problem rather than the problem themselves.\n\nThe best smells are something that’s easy to spot and most of the time lead you to really interesting problems. Data classes (classes with all data and no behavior) are good examples of this. You look at them and ask yourself what behavior should be in this class. Then you start refactoring to move that behavior in there. Often simple questions and initial refactorings can be the vital step in turning anemic objects into something that really has class.\n\n9 I am fortunate to have Martin Fowler as a colleague at Thoughtworks, so it took just 20 minutes to get his\n\npermission.\n\n190\n\n|\n\nChapter 5: Data Class Builders\n\nOne of the nice things about smells is that it’s easy for inexperienced people to spot them, even if they don’t know enough to evaluate if there’s a real problem or to cor‐ rect them. I’ve heard of lead developers who will pick a “smell of the week” and ask people to look for the smell and bring it up with the senior members of the team. Doing it one smell at a time is a good way of gradually teaching people on the team to be better programmers.\n\nThe main idea of object-oriented programming is to place behavior and data together in the same code unit: a class. If a class is widely used but has no significant behavior of its own, it’s possible that code dealing with its instances is scattered (and even duplicated) in methods and functions throughout the system—a recipe for mainte‐ nance headaches. That’s why Fowler’s refactorings to deal with a data class involve bringing responsibilities back into it.\n\nTaking that into account, there are a couple of common scenarios where it makes sense to have a data class with little or no behavior.\n\nData Class as Scaffolding In this scenario, the data class is an initial, simplistic implementation of a class to jump-start a new project or module. With time, the class should get its own methods, instead of relying on methods of other classes to operate on its instances. Scaffolding is temporary; eventually your custom class may become fully independent from the builder you used to start it.\n\nPython is also used for quick problem solving and experimentation, and then it’s OK to leave the scaffolding in place.\n\nData Class as Intermediate Representation A data class can be useful to build records about to be exported to JSON or some other interchange format, or to hold data that was just imported, crossing some sys‐ tem boundary. Python’s data class builders all provide a method or function to con‐ vert an instance to a plain dict, and you can always invoke the constructor with a dict used as keyword arguments expanded with **. Such a dict is very close to a JSON record.\n\nIn this scenario, the data class instances should be handled as immutable objects— even if the fields are mutable, you should not change them while they are in this intermediate form. If you do, you’re losing the key benefit of having data and behav‐ ior close together. When importing/exporting requires changing values, you should implement your own builder methods instead of using the given “as dict” methods or standard constructors.\n\nData Class as a Code Smell\n\n|\n\n191\n\nNow we change the subject to see how to write patterns that match instances of arbi‐ trary classes, and not just the sequences and mappings we’ve seen in “Pattern Match‐ ing with Sequences” on page 38 and “Pattern Matching with Mappings” on page 81.\n\nPattern Matching Class Instances Class patterns are designed to match class instances by type and—optionally—by attributes. The subject of a class pattern can be any class instance, not only instances of data classes.10\n\nThere are three variations of class patterns: simple, keyword, and positional. We’ll study them in that order.\n\nSimple Class Patterns We’ve already seen an example with simple class patterns used as subpatterns in “Pat‐ tern Matching with Sequences” on page 38:\n\ncase [str(name), _, _, (float(lat), float(lon))]:\n\nThat pattern matches a four-item sequence where the first item must be an instance of str, and the last item must be a 2-tuple with two instances of float.\n\nThe syntax for class patterns looks like a constructor invocation. The following is a class pattern that matches float values without binding a variable (the case body can refer to x directly if needed):\n\nmatch x: case float(): do_something_with(x)\n\nBut this is likely to be a bug in your code:\n\nmatch x: case float: # DANGER!!! do_something_with(x)\n\nIn the preceding example, case float: matches any subject, because Python sees float as a variable, which is then bound to the subject.\n\nThe simple pattern syntax of float(x) is a special case that applies only to nine blessed built-in types, listed at the end of the “Class Patterns” section of PEP 634— Structural Pattern Matching: Specification:\n\nbytes dict float frozenset int list set str tuple\n\n10 I put this content here because it is the earliest chapter focusing on user-defined classes, and I thought pattern matching with classes was too important to wait until Part II of the book. My philosophy: it’s more important to know how to use classes than to define classes.\n\n192\n\n|\n\nChapter 5: Data Class Builders\n\nIn those classes, the variable that looks like a constructor argument—e.g., the x in float(x)—is bound to the whole subject instance or the part of the subject that matches a subpattern, as exemplified by str(name) in the sequence pattern we saw earlier:\n\ncase [str(name), _, _, (float(lat), float(lon))]:\n\nIf the class is not one of those nine blessed built-ins, then the argument-like variables represent patterns to be matched against attributes of an instance of that class.\n\nKeyword Class Patterns To understand how to use keyword class patterns, consider the following City class and five instances in Example 5-22.\n\nExample 5-22. City class and a few instances\n\nimport typing\n\nclass City(typing.NamedTuple): continent: str name: str country: str\n\ncities = [ City('Asia', 'Tokyo', 'JP'), City('Asia', 'Delhi', 'IN'), City('North America', 'Mexico City', 'MX'), City('North America', 'New York', 'US'), City('South America', 'São Paulo', 'BR'), ]\n\nGiven those definitions, the following function would return a list of Asian cities:\n\ndef match_asian_cities(): results = [] for city in cities: match city: case City(continent='Asia'): results.append(city) return results\n\nThe pattern City(continent='Asia') matches any City instance where the conti nent attribute value is equal to 'Asia', regardless of the values of the other attributes.\n\nIf you want to collect the value of the country attribute, you could write:\n\ndef match_asian_countries(): results = [] for city in cities:\n\nPattern Matching Class Instances\n\n|\n\n193\n\nmatch city: case City(continent='Asia', country=cc): results.append(cc) return results\n\nThe pattern City(continent='Asia', country=cc) matches the same Asian cities as before, but now the cc variable is bound to the country attribute of the instance. This also works if the pattern variable is called country as well:\n\nmatch city: case City(continent='Asia', country=country): results.append(country)\n\nKeyword class patterns are very readable, and work with any class that has public instance attributes, but they are somewhat verbose.\n\nPositional class patterns are more convenient in some cases, but they require explicit support by the class of the subject, as we’ll see next.\n\nPositional Class Patterns Given the definitions from Example 5-22, the following function would return a list of Asian cities, using a positional class pattern:\n\ndef match_asian_cities_pos(): results = [] for city in cities: match city: case City('Asia'): results.append(city) return results\n\nThe pattern City('Asia') matches any City instance where the first attribute value is 'Asia', regardless of the values of the other attributes.\n\nIf you want to collect the value of the country attribute, you could write:\n\ndef match_asian_countries_pos(): results = [] for city in cities: match city: case City('Asia', _, country): results.append(country) return results\n\nThe pattern City('Asia', _, country) matches the same cities as before, but now the country variable is bound to the third attribute of the instance.\n\nI’ve mentioned “first” or “third” attribute, but what does that really mean?\n\n194\n\n|\n\nChapter 5: Data Class Builders\n\nWhat makes City or any class work with positional patterns is the presence of a spe‐ cial class attribute named __match_args__, which the class builders in this chapter automatically create. This is the value of __match_args__ in the City class:\n\n>>> City.__match_args__ ('continent', 'name', 'country')\n\nAs you can see, __match_args__ declares the names of the attributes in the order they will be used in positional patterns.\n\nIn “Supporting Positional Pattern Matching” on page 377 we’ll write code to define __match_args__ for a class we’ll create without the help of a class builder.\n\nYou can combine keyword and positional arguments in a pattern. Some, but not all, of the instance attributes available for matching may be listed in __match_args__. Therefore, sometimes you may need to use keyword arguments in addition to positional argu‐ ments in a pattern.\n\nTime for a chapter summary.\n\nChapter Summary The main topic of this chapter was the data class builders collections.namedtuple, typing.NamedTuple, and dataclasses.dataclass. We saw that each generates data classes from descriptions provided as arguments to a factory function, or from class statements with type hints in the case of the latter two. In particular, both named tuple variants produce tuple subclasses, adding only the ability to access fields by name, and providing a _fields class attribute listing the field names as a tuple of strings.\n\nNext we studied the main features of the three class builders side by side, including how to extract instance data as a dict, how to get the names and default values of fields, and how to make a new instance from an existing one.\n\nThis prompted our first look into type hints, particularly those used to annotate attributes in a class statement, using the notation introduced in Python 3.6 with PEP 526—Syntax for Variable Annotations. Probably the most surprising aspect of type hints in general is the fact that they have no effect at all at runtime. Python remains a dynamic language. External tools, like Mypy, are needed to take advantage of typing information to detect errors via static analysis of the source code. After a basic overview of the syntax from PEP 526, we studied the effect of annotations in a plain class and in classes built by typing.NamedTuple and @dataclass.\n\nChapter Summary\n\n|\n\n195",
      "page_number": 202
    },
    {
      "number": 12,
      "title": "Segment 12 (pages 221-244)",
      "start_page": 221,
      "end_page": 244,
      "detection_method": "synthetic",
      "content": "Next, we covered the most commonly used features provided by @dataclass and the default_factory option of the dataclasses.field function. We also looked into the special pseudotype hints typing.ClassVar and dataclasses.InitVar that are important in the context of data classes. This main topic concluded with an example based on the Dublin Core Schema, which illustrated how to use dataclasses.fields to iterate over the attributes of a Resource instance in a custom __repr__.\n\nThen, we warned against possible abuse of data classes defeating a basic principle of object-oriented programming: data and the functions that touch it should be together in the same class. Classes with no logic may be a sign of misplaced logic.\n\nIn the last section, we saw how pattern matching works with subjects that are instan‐ ces of any class—not just classes built with the class builders presented in this chapter.\n\nFurther Reading Python’s standard documentation for the data class builders we covered is very good, and has quite a few small examples.\n\nFor @dataclass in particular, most of PEP 557—Data Classes was copied into the dataclasses module documentation. But PEP 557 has a few very informative sec‐ tions that were not copied, including “Why not just use namedtuple?”, “Why not just use typing.NamedTuple?”, and the “Rationale” section, which concludes with this Q&A:\n\nWhere is it not appropriate to use Data Classes?\n\nAPI compatibility with tuples or dicts is required. Type validation beyond that pro‐ vided by PEPs 484 and 526 is required, or value validation or conversion is required.\n\n—Eric V. Smith, PEP 557 “Rationale”\n\nOver at RealPython.com, Geir Arne Hjelle wrote a very complete “Ultimate guide to data classes in Python 3.7”.\n\nAt PyCon US 2018, Raymond Hettinger presented “Dataclasses: The code generator to end all code generators” (video).\n\nFor more features and advanced functionality, including validation, the attrs project led by Hynek Schlawack appeared years before dataclasses, and offers more fea‐ tures, promising to “bring back the joy of writing classes by relieving you from the drudgery of implementing object protocols (aka dunder methods).” The influence of attrs on @dataclass is acknowledged by Eric V. Smith in PEP 557. This probably includes Smith’s most important API decision: the use of a class decorator instead of a base class and/or a metaclass to do the job.\n\n196\n\n|\n\nChapter 5: Data Class Builders\n\nGlyph—founder of the Twisted project—wrote an excellent introduction to attrs in “The One Python Library Everyone Needs”. The attrs documentation includes a dis‐ cussion of alternatives.\n\nBook author, instructor, and mad computer scientist Dave Beazley wrote cluegen, yet another data class generator. If you’ve seen any of Dave’s talks, you know he is a mas‐ ter of metaprogramming Python from first principles. So I found it inspiring to learn from the cluegen README.md file the concrete use case that motivated him to write an alternative to Python’s @dataclass, and his philosophy of presenting an approach to solve the problem, in contrast to providing a tool: the tool may be quicker to use at first, but the approach is more flexible and can take you as far as you want to go.\n\nRegarding data class as a code smell, the best source I found was Martin Fowler’s book Refactoring, 2nd ed. This newest version is missing the quote from the epigraph of this chapter, “Data classes are like children…,” but otherwise it’s the best edition of Fowler’s most famous book, particularly for Pythonistas because the examples are in modern JavaScript, which is closer to Python than Java—the language of the first edition.\n\nThe website Refactoring Guru also has a description of the data class code smell.\n\nSoapbox The entry for “Guido” in “The Jargon File” is about Guido van Rossum. It says, among other things:\n\nMythically, Guido’s most important attribute besides Python itself is Guido’s time machine, a device he is reputed to possess because of the unnerving frequency with which user requests for new features have been met with the response “I just imple‐ mented that last night…”\n\nFor the longest time, one of the missing pieces in Python’s syntax has been a quick, standard way to declare instance attributes in a class. Many object-oriented languages have that. Here is part of a Point class definition in Smalltalk:\n\nObject subclass: #Point instanceVariableNames: 'x y' classVariableNames: '' package: 'Kernel-BasicObjects'\n\nThe second line lists the names of the instance attributes x and y. If there were class attributes, they would be in the third line.\n\nPython has always offered an easy way to declare class attributes, if they have an ini‐ tial value. But instance attributes are much more common, and Python coders have been forced to look into the __init__ method to find them, always afraid that there may be instance attributes created elsewhere in the class—or even created by external functions or methods of other classes.\n\nFurther Reading\n\n|\n\n197\n\nNow we have @dataclass, yay!\n\nBut they bring their own problems.\n\nFirst, when you use @dataclass, type hints are not optional. We’ve been promised for the last seven years, since PEP 484—Type Hints that they would always be optional. Now we have a major new language feature that requires them. If you don’t like the whole static typing trend, you may want to use attrs instead.\n\nSecond, the PEP 526 syntax for annotating instance and class attributes reverses the established convention of class statements: everything declared at the top-level of a class block was a class attribute (methods are class attributes, too). With PEP 526 and @dataclass, any attribute declared at the top level with a type hint becomes an instance attribute:\n\n@dataclass class Spam: repeat: int # instance attribute\n\nHere, repeat is also an instance attribute:\n\n@dataclass class Spam: repeat: int = 99 # instance attribute\n\nBut if there are no type hints, suddenly you are back in the good old times when dec‐ larations at the top level of the class belong to the class only:\n\n@dataclass class Spam: repeat = 99 # class attribute!\n\nFinally, if you want to annotate that class attribute with a type, you can’t use regular types because then it will become an instance attribute. You must resort to that pseu‐ dotype ClassVar annotation:\n\n@dataclass class Spam: repeat: ClassVar[int] = 99 # aargh!\n\nHere we are talking about the exception to the exception to the rule. This seems rather unPythonic to me.\n\nI did not take part in the discussions leading to PEP 526 or PEP 557—Data Classes, but here is an alternative syntax that I’d like to see:\n\n@dataclass class HackerClubMember: .name: str .guests: list = field(default_factory=list) .handle: str = ''\n\nall_handles = set()\n\n198\n\n|\n\nChapter 5: Data Class Builders\n\nInstance attributes must be declared with a . prefix.\n\nAny attribute name that doesn’t have a . prefix is a class attribute (as they always have been).\n\nThe language grammar would have to change to accept that. I find this quite readable, and it avoids the exception-to-the-exception issue.\n\nI wish I could borrow Guido’s time machine to go back to 2017 and sell this idea to the core team.\n\nFurther Reading\n\n|\n\n199\n\nCHAPTER 6 Object References, Mutability, and Recycling\n\n“You are sad,” the Knight said in an anxious tone: “let me sing you a song to comfort you. […] The name of the song is called ‘HADDOCKS’ EYES’.”\n\n“Oh, that’s the name of the song, is it?” Alice said, trying to feel interested.\n\n“No, you don’t understand,” the Knight said, looking a little vexed. “That’s what the name is CALLED. The name really IS ‘THE AGED AGED MAN.’”\n\n—Adapted from Lewis Carroll, Through the Looking-Glass, and What Alice Found There\n\nAlice and the Knight set the tone of what we will see in this chapter. The theme is the distinction between objects and their names. A name is not the object; a name is a separate thing.\n\nWe start the chapter by presenting a metaphor for variables in Python: variables are labels, not boxes. If reference variables are old news to you, the analogy may still be handy if you need to explain aliasing issues to others.\n\nWe then discuss the concepts of object identity, value, and aliasing. A surprising trait of tuples is revealed: they are immutable but their values may change. This leads to a discussion of shallow and deep copies. References and function parameters are our next theme: the problem with mutable parameter defaults and the safe handling of mutable arguments passed by clients of our functions.\n\nThe last sections of the chapter cover garbage collection, the del command, and a selection of tricks that Python plays with immutable objects.\n\nThis is a rather dry chapter, but its topics lie at the heart of many subtle bugs in real Python programs.\n\n201\n\nWhat’s New in This Chapter The topics covered here are very fundamental and stable. There were no changes worth mentioning in this second edition.\n\nI added an example of using is to test for a sentinel object, and a warning about misuses of the is operator at the end of “Choosing Between == and is” on page 206.\n\nThis chapter used to be in Part IV, but I decided to bring it up earlier because it works better as an ending to Part II, “Data Structures,” than an opening to “Object- Oriented Idioms.”\n\nThe section on “Weak References” from the first edition of this book is now a post at fluentpython.com.\n\nLet’s start by unlearning that a variable is like a box where you store data.\n\nVariables Are Not Boxes In 1997, I took a summer course on Java at MIT. The professor, Lynn Stein,1 made the point that the usual “variables as boxes” metaphor actually hinders the under‐ standing of reference variables in object-oriented languages. Python variables are like reference variables in Java; a better metaphor is to think of variables as labels with names attached to objects. The next example and figure will help you understand why.\n\nExample 6-1 is a simple interaction that the “variables as boxes” idea cannot explain. Figure 6-1 illustrates why the box metaphor is wrong for Python, while sticky notes provide a helpful picture of how variables actually work.\n\nExample 6-1. Variables a and b hold references to the same list, not copies of the list\n\n>>> a = [1, 2, 3] >>> b = a >>> a.append(4) >>> b [1, 2, 3, 4]\n\n1 Lynn Andrea Stein is an award-winning computer science educator who currently teaches at Olin College of\n\nEngineering.\n\n202\n\n|\n\nChapter 6: Object References, Mutability, and Recycling\n\nCreate a list [1, 2, 3] and bind the variable a to it.\n\nBind the variable b to the same value that a is referencing.\n\nModify the list referenced by a, by appending another item.\n\nYou can see the effect via the b variable. If we think of b as a box that stored a copy of the [1, 2, 3] from the a box, this behavior makes no sense.\n\nFigure 6-1. If you imagine variables are like boxes, you can’t make sense of assignment in Python; instead, think of variables as sticky notes, and Example 6-1 becomes easy to explain.\n\nTherefore, the b = a statement does not copy the contents of box a into box b. It attaches the label b to the object that already has the label a.\n\nProf. Stein also spoke about assignment in a very deliberate way. For example, when talking about a seesaw object in a simulation, she would say: “Variable s is assigned to the seesaw,” but never “The seesaw is assigned to variable s.” With reference vari‐ ables, it makes much more sense to say that the variable is assigned to an object, and not the other way around. After all, the object is created before the assignment. Example 6-2 proves that the righthand side of an assignment happens first.\n\nSince the verb “to assign” is used in contradictory ways, a useful alternative is “to bind”: Python’s assignment statement x = … binds the x name to the object created or referenced on the righthand side. And the object must exist before a name can be bound to it, as Example 6-2 proves.\n\nExample 6-2. Variables are bound to objects only after the objects are created\n\n>>> class Gizmo: ... def __init__(self): ... print(f'Gizmo id: {id(self)}') ... >>> x = Gizmo()\n\nVariables Are Not Boxes\n\n|\n\n203\n\nGizmo id: 4301489152 >>> y = Gizmo() * 10 Gizmo id: 4301489432 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: unsupported operand type(s) for *: 'Gizmo' and 'int' >>> >>> dir() ['Gizmo', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'x']\n\nThe output Gizmo id: … is a side effect of creating a Gizmo instance.\n\nMultiplying a Gizmo instance will raise an exception.\n\nHere is proof that a second Gizmo was actually instantiated before the multiplica‐ tion was attempted.\n\nBut variable y was never created, because the exception happened while the righthand side of the assignment was being evaluated.\n\nTo understand an assignment in Python, read the righthand side first: that’s where the object is created or retrieved. After that, the variable on the left is bound to the object, like a label stuck to it. Just forget about the boxes.\n\nBecause variables are mere labels, nothing prevents an object from having several labels assigned to it. When that happens, you have aliasing, our next topic.\n\nIdentity, Equality, and Aliases Lewis Carroll is the pen name of Prof. Charles Lutwidge Dodgson. Mr. Carroll is not only equal to Prof. Dodgson, they are one and the same. Example 6-3 expresses this idea in Python.\n\nExample 6-3. charles and lewis refer to the same object\n\n>>> charles = {'name': 'Charles L. Dodgson', 'born': 1832} >>> lewis = charles >>> lewis is charles True >>> id(charles), id(lewis) (4300473992, 4300473992) >>> lewis['balance'] = 950\n\n204\n\n|\n\nChapter 6: Object References, Mutability, and Recycling\n\n>>> charles {'name': 'Charles L. Dodgson', 'born': 1832, 'balance': 950}\n\nlewis is an alias for charles.\n\nThe is operator and the id function confirm it.\n\nAdding an item to lewis is the same as adding an item to charles.\n\nHowever, suppose an impostor—let’s call him Dr. Alexander Pedachenko—claims he is Charles L. Dodgson, born in 1832. His credentials may be the same, but Dr. Peda‐ chenko is not Prof. Dodgson. Figure 6-2 illustrates this scenario.\n\nFigure 6-2. charles and lewis are bound to the same object; alex is bound to a sepa‐ rate object of equal value.\n\nExample 6-4 implements and tests the alex object depicted in Figure 6-2.\n\nExample 6-4. alex and charles compare equal, but alex is not charles\n\n>>> alex = {'name': 'Charles L. Dodgson', 'born': 1832, 'balance': 950} >>> alex == charles True >>> alex is not charles True\n\nalex refers to an object that is a replica of the object assigned to charles.\n\nThe objects compare equal because of the __eq__ implementation in the dict class.\n\nBut they are distinct objects. This is the Pythonic way of writing the negative identity comparison: a is not b.\n\nExample 6-3 is an example of aliasing. In that code, lewis and charles are aliases: two variables bound to the same object. On the other hand, alex is not an alias for\n\nIdentity, Equality, and Aliases\n\n|\n\n205\n\ncharles: these variables are bound to distinct objects. The objects bound to alex and charles have the same value—that’s what == compares—but they have different identities.\n\nIn The Python Language Reference, “3.1. Objects, values and types” states:\n\nAn object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The is operator compares the identity of two objects; the id() function returns an integer representing its identity.\n\nThe real meaning of an object’s ID is implementation dependent. In CPython, id() returns the memory address of the object, but it may be something else in another Python interpreter. The key point is that the ID is guaranteed to be a unique integer label, and it will never change during the life of the object.\n\nIn practice, we rarely use the id() function while programming. Identity checks are most often done with the is operator, which compares the object IDs, so our code doesn’t need to call id() explicitly. Next, we’ll talk about is versus ==.\n\nFor tech reviewer Leonardo Rochael, the most frequent use for id() is while debugging, when the repr() of two objects look alike, but you need to understand whether two references are aliases or point to separate objects. If the references are in different contexts —such as different stack frames—using the is operator may not be viable.\n\nChoosing Between == and is The == operator compares the values of objects (the data they hold), while is com‐ pares their identities.\n\nWhile programming, we often care more about values than object identities, so == appears more frequently than is in Python code.\n\nHowever, if you are comparing a variable to a singleton, then it makes sense to use is. By far, the most common case is checking whether a variable is bound to None. This is the recommended way to do it:\n\nx is None\n\nAnd the proper way to write its negation is:\n\nx is not None\n\nNone is the most common singleton we test with is. Sentinel objects are another example of singletons we test with is. Here is one way to create and test a sentinel object:\n\n206\n\n|\n\nChapter 6: Object References, Mutability, and Recycling\n\nEND_OF_DATA = object() # ... many lines def traverse(...): # ... more lines if node is END_OF_DATA: return # etc.\n\nThe is operator is faster than ==, because it cannot be overloaded, so Python does not have to find and invoke special methods to evaluate it, and computing is as sim‐ ple as comparing two integer IDs. In contrast, a == b is syntactic sugar for a.__eq__(b). The __eq__ method inherited from object compares object IDs, so it produces the same result as is. But most built-in types override __eq__ with more meaningful implementations that actually take into account the values of the object attributes. Equality may involve a lot of processing—for example, when comparing large collections or deeply nested structures.\n\nUsually we are more interested in object equality than identity. Checking for None is the only common use case for the is operator. Most other uses I see while reviewing code are wrong. If you are not sure, use ==. It’s usually what you want, and also works with None—albeit not as fast.\n\nTo wrap up this discussion of identity versus equality, we’ll see that the famously immutable tuple is not as unchanging as you may expect.\n\nThe Relative Immutability of Tuples Tuples, like most Python collections—lists, dicts, sets, etc.—are containers: they hold references to objects.2 If the referenced items are mutable, they may change even if the tuple itself does not. In other words, the immutability of tuples really refers to the physical contents of the tuple data structure (i.e., the references it holds), and does not extend to the referenced objects.\n\nExample 6-5 illustrates the situation in which the value of a tuple changes as a result of changes to a mutable object referenced in it. What can never change in a tuple is the identity of the items it contains.\n\n2 In contrast, flat sequences like str, bytes, and array.array don’t contain references but directly hold their\n\ncontents—characters, bytes, and numbers—in contiguous memory.\n\nIdentity, Equality, and Aliases\n\n|\n\n207\n\nExample 6-5. t1 and t2 initially compare equal, but changing a mutable item inside tuple t1 makes it different\n\n>>> t1 = (1, 2, [30, 40]) >>> t2 = (1, 2, [30, 40]) >>> t1 == t2 True >>> id(t1[-1]) 4302515784 >>> t1[-1].append(99) >>> t1 (1, 2, [30, 40, 99]) >>> id(t1[-1]) 4302515784 >>> t1 == t2 False\n\nt1 is immutable, but t1[-1] is mutable.\n\nBuild a tuple t2 whose items are equal to those of t1.\n\nAlthough distinct objects, t1 and t2 compare equal, as expected.\n\nInspect the identity of the list at t1[-1].\n\nModify the t1[-1] list in place.\n\nThe identity of t1[-1] has not changed, only its value.\n\nt1 and t2 are now different.\n\nThis relative immutability of tuples is behind the riddle “A += Assignment Puzzler” on page 54. It’s also the reason why some tuples are unhashable, as we’ve seen in “What Is Hashable” on page 84.\n\nThe distinction between equality and identity has further implications when you need to copy an object. A copy is an equal object with a different ID. But if an object contains other objects, should the copy also duplicate the inner objects, or is it OK to share them? There’s no single answer. Read on for a discussion.\n\nCopies Are Shallow by Default The easiest way to copy a list (or most built-in mutable collections) is to use the built- in constructor for the type itself. For example:\n\n>>> l1 = [3, [55, 44], (7, 8, 9)] >>> l2 = list(l1)\n\n208\n\n|\n\nChapter 6: Object References, Mutability, and Recycling\n\n>>> l2 [3, [55, 44], (7, 8, 9)] >>> l2 == l1 True >>> l2 is l1 False\n\nlist(l1) creates a copy of l1.\n\nThe copies are equal…\n\n…but refer to two different objects.\n\nFor lists and other mutable sequences, the shortcut l2 = l1[:] also makes a copy.\n\nHowever, using the constructor or [:] produces a shallow copy (i.e., the outermost container is duplicated, but the copy is filled with references to the same items held by the original container). This saves memory and causes no problems if all the items are immutable. But if there are mutable items, this may lead to unpleasant surprises.\n\nIn Example 6-6, we create a shallow copy of a list containing another list and a tuple, and then make changes to see how they affect the referenced objects.\n\nIf you have a connected computer on hand, I highly recommend watching the interactive animation for Example 6-6 at the Online Python Tutor. As I write this, direct linking to a prepared example at pythontutor.com is not working reliably, but the tool is awesome, so taking the time to copy and paste the code is worthwhile.\n\nExample 6-6. Making a shallow copy of a list containing another list; copy and paste this code to see it animated at the Online Python Tutor\n\nl1 = [3, [66, 55, 44], (7, 8, 9)] l2 = list(l1) l1.append(100) l1[1].remove(55) print('l1:', l1) print('l2:', l2) l2[1] += [33, 22] l2[2] += (10, 11) print('l1:', l1) print('l2:', l2)\n\nl2 is a shallow copy of l1. This state is depicted in Figure 6-3.\n\nAppending 100 to l1 has no effect on l2.\n\nCopies Are Shallow by Default\n\n|\n\n209\n\nHere we remove 55 from the inner list l1[1]. This affects l2 because l2[1] is bound to the same list as l1[1].\n\nFor a mutable object like the list referred by l2[1], the operator += changes the list in place. This change is visible at l1[1], which is an alias for l2[1].\n\n+= on a tuple creates a new tuple and rebinds the variable l2[2] here. This is the same as doing l2[2] = l2[2] + (10, 11). Now the tuples in the last position of l1 and l2 are no longer the same object. See Figure 6-4.\n\nFigure 6-3. Program state immediately after the assignment l2 = list(l1) in Example 6-6. l1 and l2 refer to distinct lists, but the lists share references to the same inner list object [66, 55, 44] and tuple (7, 8, 9). (Diagram generated by the Online Python Tutor.)\n\nThe output of Example 6-6 is Example 6-7, and the final state of the objects is depic‐ ted in Figure 6-4.\n\nExample 6-7. Output of Example 6-6\n\nl1: [3, [66, 44], (7, 8, 9), 100] l2: [3, [66, 44], (7, 8, 9)] l1: [3, [66, 44, 33, 22], (7, 8, 9), 100] l2: [3, [66, 44, 33, 22], (7, 8, 9, 10, 11)]\n\n210\n\n|\n\nChapter 6: Object References, Mutability, and Recycling\n\nFigure 6-4. Final state of l1 and l2: they still share references to the same list object, now containing [66, 44, 33, 22], but the operation l2[2] += (10, 11) created a new tuple with content (7, 8, 9, 10, 11), unrelated to the tuple (7, 8, 9) refer‐ enced by l1[2]. (Diagram generated by the Online Python Tutor.)\n\nIt should be clear now that shallow copies are easy to make, but they may or may not be what you want. How to make deep copies is our next topic.\n\nDeep and Shallow Copies of Arbitrary Objects Working with shallow copies is not always a problem, but sometimes you need to make deep copies (i.e., duplicates that do not share references of embedded objects). The copy module provides the deepcopy and copy functions that return deep and shallow copies of arbitrary objects.\n\nTo illustrate the use of copy() and deepcopy(), Example 6-8 defines a simple class, Bus, representing a school bus that is loaded with passengers and then picks up or drops off passengers on its route.\n\nExample 6-8. Bus picks up and drops off passengers\n\nclass Bus:\n\ndef __init__(self, passengers=None): if passengers is None: self.passengers = [] else: self.passengers = list(passengers)\n\ndef pick(self, name): self.passengers.append(name)\n\nCopies Are Shallow by Default\n\n|\n\n211\n\ndef drop(self, name): self.passengers.remove(name)\n\nNow, in the interactive Example 6-9, we will create a bus object (bus1) and two clones—a shallow copy (bus2) and a deep copy (bus3)—to observe what happens as bus1 drops off a student.\n\nExample 6-9. Effects of using copy versus deepcopy\n\n>>> import copy >>> bus1 = Bus(['Alice', 'Bill', 'Claire', 'David']) >>> bus2 = copy.copy(bus1) >>> bus3 = copy.deepcopy(bus1) >>> id(bus1), id(bus2), id(bus3) (4301498296, 4301499416, 4301499752) >>> bus1.drop('Bill') >>> bus2.passengers ['Alice', 'Claire', 'David'] >>> id(bus1.passengers), id(bus2.passengers), id(bus3.passengers) (4302658568, 4302658568, 4302657800) >>> bus3.passengers ['Alice', 'Bill', 'Claire', 'David']\n\nUsing copy and deepcopy, we create three distinct Bus instances.\n\nAfter bus1 drops 'Bill', he is also missing from bus2.\n\nInspection of the passengers attributes shows that bus1 and bus2 share the same list object, because bus2 is a shallow copy of bus1.\n\nbus3 is a deep copy of bus1, so its passengers attribute refers to another list.\n\nNote that making deep copies is not a simple matter in the general case. Objects may have cyclic references that would cause a naïve algorithm to enter an infinite loop. The deepcopy function remembers the objects already copied to handle cyclic refer‐ ences gracefully. This is demonstrated in Example 6-10.\n\nExample 6-10. Cyclic references: b refers to a, and then is appended to a; deepcopy still manages to copy a\n\n>>> a = [10, 20] >>> b = [a, 30] >>> a.append(b) >>> a [10, 20, [[...], 30]] >>> from copy import deepcopy\n\n212\n\n|\n\nChapter 6: Object References, Mutability, and Recycling\n\n>>> c = deepcopy(a) >>> c [10, 20, [[...], 30]]\n\nAlso, a deep copy may be too deep in some cases. For example, objects may refer to external resources or singletons that should not be copied. You can control the behavior of both copy and deepcopy by implementing the __copy__() and __deepcopy__() special methods, as described in the copy module documentation.\n\nThe sharing of objects through aliases also explains how parameter passing works in Python, and the problem of using mutable types as parameter defaults. These issues will be covered next.\n\nFunction Parameters as References The only mode of parameter passing in Python is call by sharing. That is the same mode used in most object-oriented languages, including JavaScript, Ruby, and Java (this applies to Java reference types; primitive types use call by value). Call by sharing means that each formal parameter of the function gets a copy of each reference in the arguments. In other words, the parameters inside the function become aliases of the actual arguments.\n\nThe result of this scheme is that a function may change any mutable object passed as a parameter, but it cannot change the identity of those objects (i.e., it cannot alto‐ gether replace an object with another). Example 6-11 shows a simple function using += on one of its parameters. As we pass numbers, lists, and tuples to the function, the actual arguments passed are affected in different ways.\n\nExample 6-11. A function may change any mutable object it receives\n\n>>> def f(a, b): ... a += b ... return a ... >>> x = 1 >>> y = 2 >>> f(x, y) 3 >>> x, y (1, 2) >>> a = [1, 2] >>> b = [3, 4] >>> f(a, b) [1, 2, 3, 4] >>> a, b ([1, 2, 3, 4], [3, 4]) >>> t = (10, 20)\n\nFunction Parameters as References\n\n|\n\n213\n\n>>> u = (30, 40) >>> f(t, u) (10, 20, 30, 40) >>> t, u ((10, 20), (30, 40))\n\nThe number x is unchanged.\n\nThe list a is changed.\n\nThe tuple t is unchanged.\n\nAnother issue related to function parameters is the use of mutable values for defaults, as discussed next.\n\nMutable Types as Parameter Defaults: Bad Idea Optional parameters with default values are a great feature of Python function defini‐ tions, allowing our APIs to evolve while remaining backward compatible. However, you should avoid mutable objects as default values for parameters.\n\nTo illustrate this point, in Example 6-12, we take the Bus class from Example 6-8 and change its __init__ method to create HauntedBus. Here we tried to be clever, and instead of having a default value of passengers=None, we have passengers=[], thus avoiding the if in the previous __init__. This “cleverness” gets us into trouble.\n\nExample 6-12. A simple class to illustrate the danger of a mutable default\n\nclass HauntedBus: \"\"\"A bus model haunted by ghost passengers\"\"\"\n\ndef __init__(self, passengers=[]): self.passengers = passengers\n\ndef pick(self, name): self.passengers.append(name)\n\ndef drop(self, name): self.passengers.remove(name)\n\nWhen the passengers argument is not passed, this parameter is bound to the default list object, which is initially empty.\n\nThis assignment makes self.passengers an alias for passengers, which is itself an alias for the default list, when no passengers argument is given.\n\n214\n\n|\n\nChapter 6: Object References, Mutability, and Recycling\n\nWhen the methods .remove() and .append() are used with self.passengers, we are actually mutating the default list, which is an attribute of the function object.\n\nExample 6-13 shows the eerie behavior of the HauntedBus.\n\nExample 6-13. Buses haunted by ghost passengers\n\n>>> bus1 = HauntedBus(['Alice', 'Bill']) >>> bus1.passengers ['Alice', 'Bill'] >>> bus1.pick('Charlie') >>> bus1.drop('Alice') >>> bus1.passengers ['Bill', 'Charlie'] >>> bus2 = HauntedBus() >>> bus2.pick('Carrie') >>> bus2.passengers ['Carrie'] >>> bus3 = HauntedBus() >>> bus3.passengers ['Carrie'] >>> bus3.pick('Dave') >>> bus2.passengers ['Carrie', 'Dave'] >>> bus2.passengers is bus3.passengers True >>> bus1.passengers ['Bill', 'Charlie']\n\nbus1 starts with a two-passenger list.\n\nSo far, so good: no surprises with bus1.\n\nbus2 starts empty, so the default empty list is assigned to self.passengers.\n\nbus3 also starts empty, again the default list is assigned.\n\nThe default is no longer empty!\n\nNow Dave, picked by bus3, appears in bus2.\n\nThe problem: bus2.passengers and bus3.passengers refer to the same list.\n\nBut bus1.passengers is a distinct list.\n\nFunction Parameters as References\n\n|\n\n215\n\nThe problem is that HauntedBus instances that don’t get an initial passenger list end up sharing the same passenger list among themselves.\n\nSuch bugs may be subtle. As Example 6-13 demonstrates, when a HauntedBus is instantiated with passengers, it works as expected. Strange things happen only when a HauntedBus starts empty, because then self.passengers becomes an alias for the default value of the passengers parameter. The problem is that each default value is evaluated when the function is defined—i.e., usually when the module is loaded—and the default values become attributes of the function object. So if a default value is a mutable object, and you change it, the change will affect every future call of the function.\n\nAfter running the lines in Example 6-13, you can inspect the HauntedBus.__init__ object and see the ghost students haunting its __defaults__ attribute:\n\n>>> dir(HauntedBus.__init__) # doctest: +ELLIPSIS ['__annotations__', '__call__', ..., '__defaults__', ...] >>> HauntedBus.__init__.__defaults__ (['Carrie', 'Dave'],)\n\nFinally, we can verify that bus2.passengers is an alias bound to the first element of the HauntedBus.__init__.__defaults__ attribute:\n\n>>> HauntedBus.__init__.__defaults__[0] is bus2.passengers True\n\nThe issue with mutable defaults explains why None is commonly used as the default value for parameters that may receive mutable values. In Example 6-8, __init__ checks whether the passengers argument is None. If it is, self.passengers is bound to a new empty list. If passengers is not None, the correct implementation binds a copy of that argument to self.passengers. The next section explains why copying the argument is a good practice.\n\nDefensive Programming with Mutable Parameters When you are coding a function that receives a mutable parameter, you should care‐ fully consider whether the caller expects the argument passed to be changed.\n\nFor example, if your function receives a dict and needs to modify it while processing it, should this side effect be visible outside of the function or not? Actually it depends on the context. It’s really a matter of aligning the expectation of the coder of the func‐ tion and that of the caller.\n\nThe last bus example in this chapter shows how a TwilightBus breaks expectations by sharing its passenger list with its clients. Before studying the implementation, see in Example 6-14 how the TwilightBus class works from the perspective of a client of the class.\n\n216\n\n|\n\nChapter 6: Object References, Mutability, and Recycling\n\nExample 6-14. Passengers disappear when dropped by a TwilightBus\n\n>>> basketball_team = ['Sue', 'Tina', 'Maya', 'Diana', 'Pat'] >>> bus = TwilightBus(basketball_team) >>> bus.drop('Tina') >>> bus.drop('Pat') >>> basketball_team ['Sue', 'Maya', 'Diana']\n\nbasketball_team holds five student names.\n\nA TwilightBus is loaded with the team.\n\nThe bus drops one student, then another.\n\nThe dropped passengers vanished from the basketball team!\n\nTwilightBus violates the “Principle of least astonishment,” a best practice of interface design.3 It surely is astonishing that when the bus drops a student, their name is removed from the basketball team roster.\n\nExample 6-15 is the implementation TwilightBus and an explanation of the problem.\n\nExample 6-15. A simple class to show the perils of mutating received arguments\n\nclass TwilightBus: \"\"\"A bus model that makes passengers vanish\"\"\"\n\ndef __init__(self, passengers=None): if passengers is None: self.passengers = [] else: self.passengers = passengers\n\ndef pick(self, name): self.passengers.append(name)\n\ndef drop(self, name): self.passengers.remove(name)\n\n3 See Principle of least astonishment in the English Wikipedia.\n\nFunction Parameters as References\n\n|\n\n217\n\nHere we are careful to create a new empty list when passengers is None.\n\nHowever, this assignment makes self.passengers an alias for passengers, which is itself an alias for the actual argument passed to __init__ (i.e., basket ball_team in Example 6-14).\n\nWhen the methods .remove() and .append() are used with self.passengers, we are actually mutating the original list received as an argument to the con‐ structor.\n\nThe problem here is that the bus is aliasing the list that is passed to the constructor. Instead, it should keep its own passenger list. The fix is simple: in __init__, when the passengers parameter is provided, self.passengers should be initialized with a copy of it, as we did correctly in Example 6-8:\n\ndef __init__(self, passengers=None): if passengers is None: self.passengers = [] else: self.passengers = list(passengers)\n\nMake a copy of the passengers list, or convert it to a list if it’s not one.\n\nNow our internal handling of the passenger list will not affect the argument used to initialize the bus. As a bonus, this solution is more flexible: now the argument passed to the passengers parameter may be a tuple or any other iterable, like a set or even database results, because the list constructor accepts any iterable. As we create our list to manage, we ensure that it supports the necessary .remove() own and .append() operations we use in the .pick() and .drop() methods.\n\nUnless a method is explicitly intended to mutate an object received as an argument, you should think twice before aliasing the argu‐ ment object by simply assigning it to an instance variable in your class. If in doubt, make a copy. Your clients will be happier. Of course, making a copy is not free: there is a cost in CPU and mem‐ ory. However, an API that causes subtle bugs is usually a bigger problem than one that is a little slower or uses more resources.\n\nNow let’s talk about one of the most misunderstood of Python’s statements: del.\n\n218\n\n|\n\nChapter 6: Object References, Mutability, and Recycling\n\ndel and Garbage Collection\n\nObjects are never explicitly destroyed; however, when they become unreachable they may be garbage-collected.\n\n—“Data Model” chapter of The Python Language Reference\n\nThe first strange fact about del is that it’s not a function, it’s a statement. We write del x and not del(x)—although the latter also works, but only because the expres‐ sions x and (x) usually mean the same thing in Python.\n\nThe second surprising fact is that del deletes references, not objects. Python’s garbage collector may discard an object from memory as an indirect result of del, if the deleted variable was the last reference to the object. Rebinding a variable may also cause the number of references to an object to reach zero, causing its destruction.\n\n>>> a = [1, 2] >>> b = a >>> del a >>> b [1, 2] >>> b = [3]\n\nCreate object [1, 2] and bind a to it.\n\nBind b to the same [1, 2] object.\n\nDelete reference a.\n\n[1, 2] was not affected, because b still points to it.\n\nRebinding b to a different object removes the last remaining reference to [1, 2]. Now the garbage collector can discard that object.\n\nThere is a __del__ special method, but it does not cause the dis‐ posal of the instance, and should not be called by your code. __del__ is invoked by the Python interpreter when the instance is about to be destroyed to give it a chance to release external resources. You will seldom need to implement __del__ in your own code, yet some Python programmers spend time coding it for no good reason. The proper use of __del__ is rather tricky. See the __del__ special method documentation in the “Data Model” chap‐ ter of The Python Language Reference.\n\nIn CPython, the primary algorithm for garbage collection is reference counting. Essentially, each object keeps count of how many references point to it. As soon as\n\ndel and Garbage Collection\n\n|\n\n219\n\nthat refcount reaches zero, the object is immediately destroyed: CPython calls the __del__ method on the object (if defined) and then frees the memory allocated to the object. In CPython 2.0, a generational garbage collection algorithm was added to detect groups of objects involved in reference cycles—which may be unreachable even with outstanding references to them, when all the mutual references are con‐ tained within the group. Other implementations of Python have more sophisticated garbage collectors that do not rely on reference counting, which means the __del__ method may not be called immediately when there are no more references to the object. See “PyPy, Garbage Collection, and a Deadlock” by A. Jesse Jiryu Davis for discussion of improper and proper use of __del__.\n\nTo demonstrate the end of an object’s life, Example 6-16 uses weakref.finalize to register a callback function to be called when an object is destroyed.\n\nExample 6-16. Watching the end of an object when no more references point to it\n\n>>> import weakref >>> s1 = {1, 2, 3} >>> s2 = s1 >>> def bye(): ... print('...like tears in the rain.') ... >>> ender = weakref.finalize(s1, bye) >>> ender.alive True >>> del s1 >>> ender.alive True >>> s2 = 'spam' ...like tears in the rain. >>> ender.alive False\n\ns1 and s2 are aliases referring to the same set, {1, 2, 3}.\n\nThis function must not be a bound method of the object about to be destroyed or otherwise hold a reference to it.\n\nRegister the bye callback on the object referred by s1.\n\nThe .alive attribute is True before the finalize object is called.\n\nAs discussed, del did not delete the object, just the s1 reference to it.\n\nRebinding the last reference, s2, makes {1, 2, 3} unreachable. It is destroyed, the bye callback is invoked, and ender.alive becomes False.\n\n220\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "page_number": 221
    },
    {
      "number": 13,
      "title": "Segment 13 (pages 245-264)",
      "start_page": 245,
      "end_page": 264,
      "detection_method": "synthetic",
      "content": "The point of Example 6-16 is to make explicit that del does not delete objects, but objects may be deleted as a consequence of being unreachable after del is used.\n\nYou may be wondering why the {1, 2, 3} object was destroyed in Example 6-16. After all, the s1 reference was passed to the finalize function, which must have held on to it in order to monitor the object and invoke the callback. This works because finalize holds a weak reference to {1, 2, 3}. Weak references to an object do not increase its reference count. Therefore, a weak reference does not prevent the target object from being garbage collected. Weak references are useful in caching applica‐ tions because you don’t want the cached objects to be kept alive just because they are referenced by the cache.\n\nWeak references is a very specialized topic. That’s why I chose to skip it in this second edition. Instead, I published “Weak Refer‐ ences” on fluentpython.com.\n\nTricks Python Plays with Immutables\n\nThis optional section discusses some Python details that are not really important for users of Python, and that may not apply to other Python implementations or even future versions of CPython. Nevertheless, I’ve seen people stumble upon these corner cases and then start using the is operator incorrectly, so I felt they were worth mentioning.\n\nI was surprised to learn that, for a tuple t, t[:] does not make a copy, but returns a reference to the same object. You also get a reference to the same tuple if you write tuple(t).4 Example 6-17 proves it.\n\nExample 6-17. A tuple built from another is actually the same exact tuple\n\n>>> t1 = (1, 2, 3) >>> t2 = tuple(t1) >>> t2 is t1 True >>> t3 = t1[:] >>> t3 is t1 True\n\n4 This is clearly documented. Type help(tuple) in the Python console to read: “If the argument is a tuple, the\n\nreturn value is the same object.” I thought I knew everything about tuples before writing this book.\n\nTricks Python Plays with Immutables\n\n|\n\n221\n\nt1 and t2 are bound to the same object.\n\nAnd so is t3.\n\nThe same behavior can be observed with instances of str, bytes, and frozenset. Note that a frozenset is not a sequence, so fs[:] does not work if fs is a frozenset. But fs.copy() has the same effect: it cheats and returns a reference to the same object, and not a copy at all, as Example 6-18 shows.5\n\nExample 6-18. String literals may create shared objects\n\n>>> t1 = (1, 2, 3) >>> t3 = (1, 2, 3) >>> t3 is t1 False >>> s1 = 'ABC' >>> s2 = 'ABC' >>> s2 is s1 True\n\nCreating a new tuple from scratch.\n\nt1 and t3 are equal, but not the same object.\n\nCreating a second str from scratch.\n\nSurprise: a and b refer to the same str!\n\nThe sharing of string literals is an optimization technique called interning. CPython uses a similar technique with small integers to avoid unnecessary duplication of num‐ bers that appear frequently in programs like 0, 1, –1, etc. Note that CPython does not intern all strings or integers, and the criteria it uses to do so is an undocumented implementation detail.\n\nNever depend on str or int interning! Always use == instead of is to compare strings or integers for equality. Interning is an optimi‐ zation for internal use of the Python interpreter.\n\n5 The harmless lie of having the copy method not copying anything is justified by interface compatibility: it makes frozenset more compatible with set. Anyway, it makes no difference to the end user whether two identical immutable objects are the same or are copies.\n\n222\n\n|\n\nChapter 6: Object References, Mutability, and Recycling\n\nThe tricks discussed in this section, including the behavior of frozenset.copy(), are harmless “lies” that save memory and make the interpreter faster. Do not worry about them, they should not give you any trouble because they only apply to immuta‐ ble types. Probably the best use of these bits of trivia is to win bets with fellow Pythonistas.6\n\nChapter Summary Every Python object has an identity, a type, and a value. Only the value of an object may change over time.7\n\nIf two variables refer to immutable objects that have equal values (a == b is True), in practice it rarely matters if they refer to copies or are aliases referring to the same object, because the value of an immutable object does not change, with one excep‐ tion. The exception being immutable collections such as tuples: if an immutable col‐ lection holds references to mutable items, then its value may actually change when the value of a mutable item changes. In practice, this scenario is not so common. What never changes in an immutable collection are the identities of the objects within. The frozenset class does not suffer from this problem because it can only hold hashable elements, and the value of hashable objects cannot ever change, by definition.\n\nThe fact that variables hold references has many practical consequences in Python programming:\n\nSimple assignment does not create copies. • Augmented assignment with += or *= creates new objects if the lefthand variable is bound to an immutable object, but may modify a mutable object in place.\n\nAssigning a new value to an existing variable does not change the object previ‐ ously bound to it. This is called a rebinding: the variable is now bound to a differ‐ ent object. If that variable was the last reference to the previous object, that object will be garbage collected.\n\n6 A terrible use for this information would be to ask about it when interviewing candidates or authoring ques‐ tions for “certification” exams. There are countless more important and useful facts to check for Python knowledge.\n\n7 Actually the type of an object may be changed by merely assigning a different class to its __class__ attribute,\n\nbut that is pure evil and I regret writing this footnote.\n\nChapter Summary\n\n|\n\n223\n\nFunction parameters are passed as aliases, which means the function may change any mutable object received as an argument. There is no way to prevent this, except making local copies or using immutable objects (e.g., passing a tuple instead of a list).\n\nUsing mutable objects as default values for function parameters is dangerous because if the parameters are changed in place, then the default is changed, affecting every future call that relies on the default.\n\nIn CPython, objects are discarded as soon as the number of references to them rea‐ ches zero. They may also be discarded if they form groups with cyclic references but not outside references.\n\nIn some situations, it may be useful to hold a reference to an object that will not—by itself—keep an object alive. One example is a class that wants to keep track of all its current instances. This can be done with weak references, a low-level mechanism underlying the more useful collections WeakValueDictionary, WeakKeyDictionary, WeakSet, and the finalize function from the weakref module. For more on this, please see “Weak References” at fluentpython.com.\n\nFurther Reading The “Data Model” chapter of The Python Language Reference starts with a clear explanation of object identities and values.\n\nWesley Chun, author of the Core Python series of books, presented Understanding Python’s Memory Model, Mutability, and Methods at EuroPython 2011, covering not only the theme of this chapter but also the use of special methods.\n\nDoug Hellmann wrote the posts “copy – Duplicate Objects” and “weakref—Garbage- Collectable References to Objects” covering some of the topics we just discussed.\n\nMore information on the CPython generational garbage collector can be found in the gc module documentation, which starts with the sentence “This module provides an interface to the optional garbage collector.” The “optional” qualifier here may be sur‐ prising, but the “Data Model” chapter also states:\n\nAn implementation is allowed to postpone garbage collection or omit it altogether—it is a matter of implementation quality how garbage collection is implemented, as long as no objects are collected that are still reachable.\n\n224\n\n|\n\nChapter 6: Object References, Mutability, and Recycling\n\nPablo Galindo wrote more in-depth treatment of Python’s GC in “Design of CPy‐ thon’s Garbage Collector” in the Python Developer’s Guide, aimed at new and experi‐ enced contributors to the CPython implementation.\n\nThe CPython 3.4 garbage collector improved handling of objects with a __del__ method, as described in PEP 442—Safe object finalization.\n\nWikipedia has an article about string interning, mentioning the use of this technique in several languages, including Python.\n\nWikipedia also as an article on “Haddocks’ Eyes”, the Lewis Carroll song I quoted at the top of this chapter. The Wikipedia editors wrote that the lyrics are used in works on logic and philosophy “to elaborate on the symbolic status of the concept of name: a name as identification marker may be assigned to anything, including another name, thus introducing different levels of symbolization.”\n\nSoapbox\n\nEqual Treatment to All Objects\n\nI learned Java before I discovered Python. The == operator in Java never felt right to me. It is much more common for programmers to care about equality than identity, but for objects (not primitive types), the Java == compares references, and not object values. Even for something as basic as comparing strings, Java forces you to use the .equals method. Even then, there is another catch: if you write a.equals(b) and a is null, you get a null pointer exception. The Java designers felt the need to over‐ load + for strings, so why not go ahead and overload == as well?\n\nPython gets this right. The == operator compares object values; is compares refer‐ ences. And because Python has operator overloading, == works sensibly with all objects in the standard library, including None, which is a proper object, unlike Java’s null.\n\nAnd of course, you can define __eq__ in your own classes to decide what == means for your instances. If you don’t override __eq__, the method inherited from object compares object IDs, so the fallback is that every instance of a user-defined class is considered different.\n\nThese are some of the things that made me switch from Java to Python as soon as I finished reading The Python Tutorial one afternoon in September 1998.\n\nMutability\n\nThis chapter would not be necessary if all Python objects were immutable. When you are dealing with unchanging objects, it makes no difference whether variables hold the actual objects or references to shared objects. If a == b is true, and neither object\n\nFurther Reading\n\n|\n\n225\n\ncan change, they might as well be the same. That’s why string interning is safe. Object identity becomes important only when objects are mutable.\n\nIn “pure” functional programming, all data is immutable: appending to a collection actually creates a new collection. Elixir is one easy to learn, practical functional lan‐ guage in which all built-in types are immutable, including lists.\n\nPython, however, is not a functional language, much less a pure one. Instances of user-defined classes are mutable by default in Python—as in most object-oriented languages. When creating your own objects, you have to be extra careful to make them immutable, if that is a requirement. Every attribute of the object must also be immutable, otherwise you end up with something like the tuple: immutable as far as object IDs go, but the value of a tuple may change if it holds a mutable object.\n\nMutable objects are also the main reason why programming with threads is so hard to get right: threads mutating objects without proper synchronization produce cor‐ rupted data. Excessive synchronization, on the other hand, causes deadlocks. The Erlang language and platform—which includes Elixir—was designed to maximize uptime in highly concurrent, distributed applications such as telecommunications switches. Naturally, they chose immutable data by default.\n\nObject Destruction and Garbage Collection\n\nThere is no mechanism in Python to directly destroy an object, and this omission is actually a great feature: if you could destroy an object at any time, what would hap‐ pen to existing references pointing to it?\n\nGarbage collection in CPython is done primarily by reference counting, which is easy to implement, but is prone to memory leaking when there are reference cycles, so with version 2.0 (October 2000) a generational garbage collector was implemented, and it is able to dispose of unreachable objects kept alive by reference cycles.\n\nBut the reference counting is still there as a baseline, and it causes the immediate dis‐ posal of objects with zero references. This means that, in CPython—at least for now —it’s safe to write this:\n\nopen('test.txt', 'wt', encoding='utf-8').write('1, 2, 3')\n\nThat code is safe because the reference count of the file object will be zero after the write method returns, and Python will immediately close the file before destroying the object representing it in memory. However, the same line is not safe in Jython or IronPython that use the garbage collector of their host runtimes (the Java VM and the .NET CLR), which are more sophisticated but do not rely on reference counting and may take longer to destroy the object and close the file. In all cases, including CPython, the best practice is to explicitly close the file, and the most reliable way of doing it is using the with statement, which guarantees that the file will be closed even if exceptions are raised while it is open. Using with, the previous snippet becomes:\n\n226\n\n|\n\nChapter 6: Object References, Mutability, and Recycling\n\nwith open('test.txt', 'wt', encoding='utf-8') as fp: fp.write('1, 2, 3')\n\nIf you are into the subject of garbage collectors, you may want to read Thomas Perl’s paper “Python Garbage Collector Implementations: CPython, PyPy and GaS”, from which I learned the bit about the safety of the open().write() in CPython.\n\nParameter Passing: Call by Sharing\n\nA popular way of explaining how parameter passing works in Python is the phrase: “Parameters are passed by value, but the values are references.” This is not wrong, but causes confusion because the most common parameter passing modes in older lan‐ guages are call by value (the function gets a copy of the argument) and call by refer‐ ence (the function gets a pointer to the argument). In Python, the function gets a copy of the arguments, but the arguments are always references. So the value of the refer‐ enced objects may be changed, if they are mutable, but their identity cannot. Also, because the function gets a copy of the reference in an argument, rebinding it in the function body has no effect outside of the function. I adopted the term call by sharing after reading up on the subject in Programming Language Pragmatics, 3rd ed., by Michael L. Scott (Morgan Kaufmann), section “8.3.1: Parameter Modes.”\n\nFurther Reading\n\n|\n\n227\n\nPART II Functions as Objects\n\nCHAPTER 7 Functions as First-Class Objects\n\nI have never considered Python to be heavily influenced by functional languages, no matter what people say or think. I was much more familiar with imperative languages such as C and Algol 68 and although I had made functions first-class objects, I didn’t view Python as a functional programming language.\n\n— Guido van Rossum, Python BDFL1\n\nFunctions in Python are first-class objects. Programming language researchers define a “first-class object” as a program entity that can be:\n\nCreated at runtime\n\nAssigned to a variable or element in a data structure\n\nPassed as an argument to a function\n\nReturned as the result of a function\n\nIntegers, strings, and dictionaries are other examples of first-class objects in Python —nothing fancy here. Having functions as first-class objects is an essential feature of functional languages, such as Clojure, Elixir, and Haskell. However, first-class func‐ tions are so useful that they’ve been adopted by popular languages like JavaScript, Go, and Java (since JDK 8), none of which claim to be “functional languages.”\n\nThis chapter and most of Part III explore the practical applications of treating func‐ tions as objects.\n\n1 “Origins of Python’s ‘Functional’ Features”, from Guido’s The History of Python blog.\n\n231\n\nThe term “first-class functions” is widely used as shorthand for “functions as first-class objects.” It’s not ideal because it implies an “elite” among functions. In Python, all functions are first-class.\n\nWhat’s New in This Chapter The section “The Nine Flavors of Callable Objects” on page 237 was titled “The Seven Flavors of Callable Objects” in the first edition of this book. The new callables are native coroutines and asynchronous generators, introduced in Python 3.5 and 3.6, respectively. Both are covered in Chapter 21, but they are mentioned here along with the other callables for completeness.\n\n“Positional-Only Parameters” on page 242 is a new section, covering a feature added in Python 3.8.\n\nI moved the discussion of runtime access to function annotations to “Reading Type Hints at Runtime” on page 537. When I wrote the first edition, PEP 484—Type Hints was still under consideration, and people used annotations in different ways. Since Python 3.5, annotations should conform to PEP 484. Therefore, the best place to cover them is when discussing type hints.\n\nThe first edition of this book had sections about the introspection of function objects that were too low-level and distracted from the main subject of this chapter. I merged those sections into a post titled “Introspection of Function Parameters” at fluentpython.com.\n\nNow let’s see why Python functions are full-fledged objects.\n\nTreating a Function Like an Object The console session in Example 7-1 shows that Python functions are objects. Here we create a function, call it, read its __doc__ attribute, and check that the function object itself is an instance of the function class.\n\nExample 7-1. Create and test a function, then read its __doc__ and check its type\n\n>>> def factorial(n): ... \"\"\"returns n!\"\"\" ... return 1 if n < 2 else n * factorial(n - 1) ... >>> factorial(42) 1405006117752879898543142606244511569936384000000000 >>> factorial.__doc__\n\n232\n\n|\n\nChapter 7: Functions as First-Class Objects\n\n'returns n!' >>> type(factorial) <class 'function'>\n\nThis is a console session, so we’re creating a function at “runtime.”\n\n__doc__ is one of several attributes of function objects.\n\nfactorial is an instance of the function class.\n\nThe __doc__ attribute is used to generate the help text of an object. In the Python console, the command help(factorial) will display a screen like Figure 7-1.\n\nFigure 7-1. Help screen for factorial; the text is built from the __doc__ attribute of the function.\n\nExample 7-2 shows the “first class” nature of a function object. We can assign it a variable fact and call it through that name. We can also pass factorial as an argu‐ ment to the map function. Calling map(function, iterable) returns an iterable where each item is the result of calling the first argument (a function) to successive elements of the second argument (an iterable), range(10) in this example.\n\nExample 7-2. Use factorial through a different name, and pass factorial as an argument\n\n>>> fact = factorial >>> fact <function factorial at 0x...> >>> fact(5) 120 >>> map(factorial, range(11)) <map object at 0x...> >>> list(map(factorial, range(11))) [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n\nTreating a Function Like an Object\n\n|\n\n233\n\nHaving first-class functions enables programming in a functional style. One of the hallmarks of functional programming is the use of higher-order functions, our next topic.\n\nHigher-Order Functions A function that takes a function as an argument or returns a function as the result is a higher-order function. One example is map, shown in Example 7-2. Another is the built-in function sorted: the optional key argument lets you provide a function to be applied to each item for sorting, as we saw in “list.sort Versus the sorted Built-In” on page 56. For example, to sort a list of words by length, pass the len function as the key, as in Example 7-3.\n\nExample 7-3. Sorting a list of words by length\n\n>>> fruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana'] >>> sorted(fruits, key=len) ['fig', 'apple', 'cherry', 'banana', 'raspberry', 'strawberry'] >>>\n\nAny one-argument function can be used as the key. For example, to create a rhyme dictionary it might be useful to sort each word spelled backward. In Example 7-4, note that the words in the list are not changed at all; only their reversed spelling is used as the sort criterion, so that the berries appear together.\n\nExample 7-4. Sorting a list of words by their reversed spelling\n\n>>> def reverse(word): ... return word[::-1] >>> reverse('testing') 'gnitset' >>> sorted(fruits, key=reverse) ['banana', 'apple', 'fig', 'raspberry', 'strawberry', 'cherry'] >>>\n\nIn the functional programming paradigm, some of the best known higher-order functions are map, filter, reduce, and apply. The apply function was deprecated in Python 2.3 and removed in Python 3 because it’s no longer necessary. If you need to call a function with a dynamic set of arguments, you can write fn(*args, **kwargs) instead of apply(fn, args, kwargs).\n\nThe map, filter, and reduce higher-order functions are still around, but better alter‐ natives are available for most of their use cases, as the next section shows.\n\n234\n\n|\n\nChapter 7: Functions as First-Class Objects\n\nModern Replacements for map, filter, and reduce Functional languages commonly offer the map, filter, and reduce higher-order functions (sometimes with different names). The map and filter functions are still built-ins in Python 3, but since the introduction of list comprehensions and genera‐ tor expressions, they are not as important. A listcomp or a genexp does the job of map and filter combined, but is more readable. Consider Example 7-5.\n\nExample 7-5. Lists of factorials produced with map and filter compared to alternatives coded as list comprehensions\n\n>>> list(map(factorial, range(6))) [1, 1, 2, 6, 24, 120] >>> [factorial(n) for n in range(6)] [1, 1, 2, 6, 24, 120] >>> list(map(factorial, filter(lambda n: n % 2, range(6)))) [1, 6, 120] >>> [factorial(n) for n in range(6) if n % 2] [1, 6, 120] >>>\n\nBuild a list of factorials from 0! to 5!.\n\nSame operation, with a list comprehension.\n\nList of factorials of odd numbers up to 5!, using both map and filter.\n\nList comprehension does the same job, replacing map and filter, and making lambda unnecessary.\n\nIn Python 3, map and filter return generators—a form of iterator—so their direct substitute is now a generator expression (in Python 2, these functions returned lists, therefore their closest alternative was a listcomp).\n\nThe reduce function was demoted from a built-in in Python 2 to the functools module in Python 3. Its most common use case, summation, is better served by the sum built-in available since Python 2.3 was released in 2003. This is a big win in terms of readability and performance (see Example 7-6).\n\nExample 7-6. Sum of integers up to 99 performed with reduce and sum\n\n>>> from functools import reduce >>> from operator import add >>> reduce(add, range(100)) 4950 >>> sum(range(100))\n\nHigher-Order Functions\n\n|\n\n235\n\n4950 >>>\n\nStarting with Python 3.0, reduce is no longer a built-in.\n\nImport add to avoid creating a function just to add two numbers.\n\nSum integers up to 99.\n\nSame task with sum—no need to import and call reduce and add.\n\nThe common idea of sum and reduce is to apply some operation to successive items in a series, accumulating previous results, thus reducing a series of values to a single value.\n\nOther reducing built-ins are all and any:\n\nall(iterable)\n\nReturns True if there are no falsy elements in the iterable; all([]) returns True.\n\nany(iterable)\n\nReturns True if any element of the iterable is truthy; any([]) returns False.\n\nI give a fuller explanation of reduce in “Vector Take #4: Hashing and a Faster ==” on page 411 where an ongoing example provides a meaningful context for the use of this function. The reducing functions are summarized later in the book when iterables are in focus, in “Iterable Reducing Functions” on page 630.\n\nTo use a higher-order function, sometimes it is convenient to create a small, . one-off function. That is why anonymous functions exist. We’ll cover them next.\n\nAnonymous Functions The lambda keyword creates an anonymous function within a Python expression.\n\nHowever, the simple syntax of Python limits the body of lambda functions to be pure expressions. In other words, the body cannot contain other Python statements such as while, try, etc. Assignment with = is also a statement, so it cannot occur in a lambda. The new assignment expression syntax using := can be used—but if you need it, your lambda is probably too complicated and hard to read, and it should be refac‐ tored into a regular function using def.\n\n236\n\n|\n\nChapter 7: Functions as First-Class Objects\n\nThe best use of anonymous functions is in the context of an argument list for a higher-order function. For example, Example 7-7 is the rhyme index example from Example 7-4 rewritten with lambda, without defining a reverse function.\n\nExample 7-7. Sorting a list of words by their reversed spelling using lambda\n\n>>> fruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana'] >>> sorted(fruits, key=lambda word: word[::-1]) ['banana', 'apple', 'fig', 'raspberry', 'strawberry', 'cherry'] >>>\n\nOutside the limited context of arguments to higher-order functions, anonymous functions are rarely useful in Python. The syntactic restrictions tend to make nontriv‐ ial lambdas either unreadable or unworkable. If a lambda is hard to read, I strongly advise you follow Fredrik Lundh’s refactoring advice.\n\nFredrik Lundh’s lambda Refactoring Recipe If you find a piece of code hard to understand because of a lambda, Fredrik Lundh suggests this refactoring procedure:\n\n1. Write a comment explaining what the heck that lambda does.\n\n2. Study the comment for a while, and think of a name that captures the essence of the comment.\n\n3. Convert the lambda to a def statement, using that name.\n\n4. Remove the comment.\n\nThese steps are quoted from the “Functional Programming HOWTO”, a must read.\n\nThe lambda syntax is just syntactic sugar: a lambda expression creates a function object just like the def statement. That is just one of several kinds of callable objects in Python. The following section reviews all of them.\n\nThe Nine Flavors of Callable Objects The call operator () may be applied to other objects besides functions. To determine whether an object is callable, use the callable() built-in function. As of Python 3.9, the data model documentation lists nine callable types:\n\nThe Nine Flavors of Callable Objects\n\n|\n\n237\n\nUser-defined functions\n\nCreated with def statements or lambda expressions.\n\nBuilt-in functions\n\nA function implemented in C (for CPython), like len or time.strftime.\n\nBuilt-in methods\n\nMethods implemented in C, like dict.get.\n\nMethods\n\nFunctions defined in the body of a class.\n\nClasses\n\nWhen invoked, a class runs its __new__ method to create an instance, then __init__ to initialize it, and finally the instance is returned to the caller. Because there is no new operator in Python, calling a class is like calling a function.2\n\nClass instances\n\nIf a class defines a __call__ method, then its instances may be invoked as func‐ tions—that’s the subject of the next section.\n\nGenerator functions\n\nFunctions or methods that use the yield keyword in their body. When called, they return a generator object.\n\nNative coroutine functions\n\nFunctions or methods defined with async def. When called, they return a coroutine object. Added in Python 3.5.\n\nAsynchronous generator functions\n\nFunctions or methods defined with async def that have yield in their body. When called, they return an asynchronous generator for use with async for. Added in Python 3.6.\n\nGenerators, native coroutines, and asynchronous generator functions are unlike other callables in that their return values are never application data, but objects that require further processing to yield application data or perform useful work. Genera‐ tor functions return iterators. Both are covered in Chapter 17. Native coroutine func‐ tions and asynchronous generator functions return objects that only work with the help of an asynchronous programming framework, such as asyncio. They are the sub‐ ject of Chapter 21.\n\n2 Calling a class usually creates an instance of that same class, but other behaviors are possible by overriding\n\n__new__. We’ll see an example of this in “Flexible Object Creation with __new__” on page 843.\n\n238\n\n|\n\nChapter 7: Functions as First-Class Objects\n\nGiven the variety of existing callable types in Python, the safest way to determine whether an object is callable is to use the callable() built-in:\n\n>>> abs, str, 'Ni!' (<built-in function abs>, <class 'str'>, 'Ni!') >>> [callable(obj) for obj in (abs, str, 'Ni!')] [True, True, False]\n\nWe now move on to building class instances that work as callable objects.\n\nUser-Defined Callable Types Not only are Python functions real objects, but arbitrary Python objects may also be made to behave like functions. Implementing a __call__ instance method is all it takes.\n\nExample 7-8 implements a BingoCage class. An instance is built from any iterable, and stores an internal list of items, in random order. Calling the instance pops an item.3\n\nExample 7-8. bingocall.py: A BingoCage does one thing: picks items from a shuffled list\n\nimport random\n\nclass BingoCage:\n\ndef __init__(self, items): self._items = list(items) random.shuffle(self._items)\n\ndef pick(self): try: return self._items.pop() except IndexError: raise LookupError('pick from empty BingoCage')\n\ndef __call__(self): return self.pick()\n\n3 Why build a BingoCage when we already have random.choice? The choice function may return the same item multiple times, because the picked item is not removed from the collection given. Calling BingoCage never returns duplicate results—as long as the instance is filled with unique values.\n\nUser-Defined Callable Types\n\n|\n\n239\n\n__init__ accepts any iterable; building a local copy prevents unexpected side effects on any list passed as an argument.\n\nshuffle is guaranteed to work because self._items is a list.\n\nThe main method.\n\nRaise exception with custom message if self._items is empty.\n\nShortcut to bingo.pick(): bingo().\n\nHere is a simple demo of Example 7-8. Note how a bingo instance can be invoked as a function, and the callable() built-in recognizes it as a callable object:\n\n>>> bingo = BingoCage(range(3)) >>> bingo.pick() 1 >>> bingo() 0 >>> callable(bingo) True\n\nA class implementing __call__ is an easy way to create function-like objects that have some internal state that must be kept across invocations, like the remaining items in the BingoCage. Another good use case for __call__ is implementing decora‐ tors. Decorators must be callable, and it is sometimes convenient to “remember” something between calls of the decorator (e.g., for memoization—caching the results of expensive computations for later use) or to split a complex implementation into separate methods.\n\nThe functional approach to creating functions with internal state is to use closures. Closures, as well as decorators, are the subject of Chapter 9.\n\nNow let’s explore the powerful syntax Python offers to declare function parameters and pass arguments into them.\n\nFrom Positional to Keyword-Only Parameters One of the best features of Python functions is the extremely flexible parameter han‐ dling mechanism. Closely related are the use of * and ** to unpack iterables and mappings into separate arguments when we call a function. To see these features in action, see the code for Example 7-9 and tests showing its use in Example 7-10.\n\n240\n\n|\n\nChapter 7: Functions as First-Class Objects\n\nExample 7-9. tag generates HTML elements; a keyword-only argument class_ is used to pass “class” attributes as a workaround because class is a keyword in Python\n\ndef tag(name, *content, class_=None, **attrs): \"\"\"Generate one or more HTML tags\"\"\" if class_ is not None: attrs['class'] = class_ attr_pairs = (f' {attr}=\"{value}\"' for attr, value in sorted(attrs.items())) attr_str = ''.join(attr_pairs) if content: elements = (f'<{name}{attr_str}>{c}</{name}>' for c in content) return '\\n'.join(elements) else: return f'<{name}{attr_str} />'\n\nThe tag function can be invoked in many ways, as Example 7-10 shows.\n\nExample 7-10. Some of the many ways of calling the tag function from Example 7-9\n\n>>> tag('br') '<br />' >>> tag('p', 'hello') '<p>hello</p>' >>> print(tag('p', 'hello', 'world')) <p>hello</p> <p>world</p> >>> tag('p', 'hello', id=33) '<p id=\"33\">hello</p>' >>> print(tag('p', 'hello', 'world', class_='sidebar')) <p class=\"sidebar\">hello</p> <p class=\"sidebar\">world</p> >>> tag(content='testing', name=\"img\") '<img content=\"testing\" />' >>> my_tag = {'name': 'img', 'title': 'Sunset Boulevard', ... 'src': 'sunset.jpg', 'class': 'framed'} >>> tag(**my_tag) '<img class=\"framed\" src=\"sunset.jpg\" title=\"Sunset Boulevard\" />'\n\nA single positional argument produces an empty tag with that name.\n\nAny number of arguments after the first are captured by *content as a tuple.\n\nKeyword arguments not explicitly named in the tag signature are captured by **attrs as a dict.\n\nThe class_ parameter can only be passed as a keyword argument.\n\nFrom Positional to Keyword-Only Parameters\n\n|\n\n241\n\nThe first positional argument can also be passed as a keyword.\n\nPrefixing the my_tag dict with ** passes all its items as separate arguments, which are then bound to the named parameters, with the remaining caught by **attrs. In this case we can have a 'class' key in the arguments dict, because it is a string, and does not clash with the class reserved word.\n\nKeyword-only arguments are a feature of Python 3. In Example 7-9, the class_ parameter can only be given as a keyword argument—it will never capture unnamed positional arguments. To specify keyword-only arguments when defining a function, name them after the argument prefixed with *. If you don’t want to support variable positional arguments but still want keyword-only arguments, put a * by itself in the signature, like this:\n\n>>> def f(a, *, b): ... return a, b ... >>> f(1, b=2) (1, 2) >>> f(1, 2) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: f() takes 1 positional argument but 2 were given\n\nNote that keyword-only arguments do not need to have a default value: they can be mandatory, like b in the preceding example.\n\nPositional-Only Parameters Since Python 3.8, user-defined function signatures may specify positional-only parameters. This feature always existed for built-in functions, such as divmod(a, b), which can only be called with positional parameters, and not as divmod(a=10, b=4).\n\nTo define a function requiring positional-only parameters, use / in the parameter list.\n\nThis example from “What’s New In Python 3.8” shows how to emulate the divmod built-in function:\n\ndef divmod(a, b, /): return (a // b, a % b)\n\nAll arguments to the left of the / are positional-only. After the /, you may specify other arguments, which work as usual.\n\n242\n\n|\n\nChapter 7: Functions as First-Class Objects",
      "page_number": 245
    },
    {
      "number": 14,
      "title": "Segment 14 (pages 265-283)",
      "start_page": 265,
      "end_page": 283,
      "detection_method": "synthetic",
      "content": "The / in the parameter list is a syntax error in Python 3.7 or earlier.\n\nFor example, consider the tag function from Example 7-9. If we want the name parameter to be positional only, we can add a / after it in the function signature, like this:\n\ndef tag(name, /, *content, class_=None, **attrs): ...\n\nYou can find other examples of positional-only parameters in “What’s New In Python 3.8” and in PEP 570.\n\nAfter diving into Python’s flexible argument declaration features, the remainder of this chapter covers the most useful packages in the standard library for programming in a functional style.\n\nPackages for Functional Programming Although Guido makes it clear that he did not design Python to be a functional pro‐ gramming language, a functional coding style can be used to good extent, thanks to first-class functions, pattern matching, and the support of packages like operator and functools, which we cover in the next two sections.\n\nThe operator Module Often in functional programming it is convenient to use an arithmetic operator as a function. For example, suppose you want to multiply a sequence of numbers to calcu‐ late factorials without using recursion. To perform summation, you can use sum, but there is no equivalent function for multiplication. You could use reduce—as we saw in “Modern Replacements for map, filter, and reduce” on page 235—but this requires a function to multiply two items of the sequence. Example 7-11 shows how to solve this using lambda.\n\nExample 7-11. Factorial implemented with reduce and an anonymous function\n\nfrom functools import reduce\n\ndef factorial(n): return reduce(lambda a, b: a*b, range(1, n+1))\n\nPackages for Functional Programming\n\n|\n\n243\n\nThe operator module provides function equivalents for dozens of operators so you don’t have to code trivial functions like lambda a, b: a*b. With it, we can rewrite Example 7-11 as Example 7-12.\n\nExample 7-12. Factorial implemented with reduce and operator.mul\n\nfrom functools import reduce from operator import mul\n\ndef factorial(n): return reduce(mul, range(1, n+1))\n\nAnother group of one-trick lambdas that operator replaces are functions to pick items from sequences or read attributes from objects: itemgetter and attrgetter are factories that build custom functions to do that.\n\nExample 7-13 shows a common use of itemgetter: sorting a list of tuples by the value of one field. In the example, the cities are printed sorted by country code (field 1). Essentially, itemgetter(1) creates a function that, given a collection, returns the item at index 1. That’s easier to write and read than lambda fields: fields[1], which does the same thing.\n\nExample 7-13. Demo of itemgetter to sort a list of tuples (data from Example 2-8)\n\n>>> metro_data = [ ... ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)), ... ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), ... ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)), ... ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), ... ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)), ... ] >>> >>> from operator import itemgetter >>> for city in sorted(metro_data, key=itemgetter(1)): ... print(city) ... ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)) ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)) ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)) ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)) ('New York-Newark', 'US', 20.104, (40.808611, -74.020386))\n\nIf you pass multiple index arguments to itemgetter, the function it builds will return tuples with the extracted values, which is useful for sorting on multiple keys:\n\n>>> cc_name = itemgetter(1, 0) >>> for city in metro_data: ... print(cc_name(city))\n\n244\n\n|\n\nChapter 7: Functions as First-Class Objects\n\n... ('JP', 'Tokyo') ('IN', 'Delhi NCR') ('MX', 'Mexico City') ('US', 'New York-Newark') ('BR', 'São Paulo') >>>\n\nBecause itemgetter uses the [] operator, it supports not only sequences but also mappings and any class that implements __getitem__.\n\nA sibling of itemgetter is attrgetter, which creates functions to extract object attributes by name. If you pass attrgetter several attribute names as arguments, it also returns a tuple of values. In addition, if any argument name contains a . (dot), attrgetter navigates through nested objects to retrieve the attribute. These behav‐ iors are shown in Example 7-14. This is not the shortest console session because we need to build a nested structure to showcase the handling of dotted attributes by attrgetter.\n\nExample 7-14. Demo of attrgetter to process a previously defined list of namedtuple called metro_data (the same list that appears in Example 7-13)\n\n>>> from collections import namedtuple >>> LatLon = namedtuple('LatLon', 'lat lon') >>> Metropolis = namedtuple('Metropolis', 'name cc pop coord') >>> metro_areas = [Metropolis(name, cc, pop, LatLon(lat, lon)) ... for name, cc, pop, (lat, lon) in metro_data] >>> metro_areas[0] Metropolis(name='Tokyo', cc='JP', pop=36.933, coord=LatLon(lat=35.689722, lon=139.691667)) >>> metro_areas[0].coord.lat 35.689722 >>> from operator import attrgetter >>> name_lat = attrgetter('name', 'coord.lat') >>> >>> for city in sorted(metro_areas, key=attrgetter('coord.lat')): ... print(name_lat(city)) ... ('São Paulo', -23.547778) ('Mexico City', 19.433333) ('Delhi NCR', 28.613889) ('Tokyo', 35.689722) ('New York-Newark', 40.808611)\n\nUse namedtuple to define LatLon.\n\nAlso define Metropolis.\n\nPackages for Functional Programming\n\n|\n\n245\n\nBuild metro_areas list with Metropolis instances; note the nested tuple unpack‐ ing to extract (lat, lon) and use them to build the LatLon for the coord attribute of Metropolis.\n\nReach into element metro_areas[0] to get its latitude.\n\nDefine an attrgetter to retrieve the name and the coord.lat nested attribute.\n\nUse attrgetter again to sort list of cities by latitude.\n\nUse the attrgetter defined in\n\nto show only the city name and latitude.\n\nHere is a partial list of functions defined in operator (names starting with _ are omit‐ ted, because they are mostly implementation details):\n\n>>> [name for name in dir(operator) if not name.startswith('_')] ['abs', 'add', 'and_', 'attrgetter', 'concat', 'contains', 'countOf', 'delitem', 'eq', 'floordiv', 'ge', 'getitem', 'gt', 'iadd', 'iand', 'iconcat', 'ifloordiv', 'ilshift', 'imatmul', 'imod', 'imul', 'index', 'indexOf', 'inv', 'invert', 'ior', 'ipow', 'irshift', 'is_', 'is_not', 'isub', 'itemgetter', 'itruediv', 'ixor', 'le', 'length_hint', 'lshift', 'lt', 'matmul', 'methodcaller', 'mod', 'mul', 'ne', 'neg', 'not_', 'or_', 'pos', 'pow', 'rshift', 'setitem', 'sub', 'truediv', 'truth', 'xor']\n\nMost of the 54 names listed are self-evident. The group of names prefixed with i and the name of another operator—e.g., iadd, iand, etc.—correspond to the augmented assignment operators—e.g., +=, &=, etc. These change their first argument in place, if it is mutable; if not, the function works like the one without the i prefix: it simply returns the result of the operation.\n\nOf the remaining operator functions, methodcaller is the last we will cover. It is somewhat similar to attrgetter and itemgetter in that it creates a function on the fly. The function it creates calls a method by name on the object given as argument, as shown in Example 7-15.\n\nExample 7-15. Demo of methodcaller: second test shows the binding of extra arguments\n\n>>> from operator import methodcaller >>> s = 'The time has come' >>> upcase = methodcaller('upper') >>> upcase(s) 'THE TIME HAS COME' >>> hyphenate = methodcaller('replace', ' ', '-') >>> hyphenate(s) 'The-time-has-come'\n\n246\n\n|\n\nChapter 7: Functions as First-Class Objects\n\nThe first test in Example 7-15 is there just to show methodcaller at work, but if you need to use the str.upper as a function, you can just call it on the str class and pass a string as an argument, like this:\n\n>>> str.upper(s) 'THE TIME HAS COME'\n\nThe second test in Example 7-15 shows that methodcaller can also do a partial appli‐ cation to freeze some arguments, like the functools.partial function does. That is our next subject.*Bold Text*opmod07\n\nFreezing Arguments with functools.partial The functools module provides several higher-order functions. We saw reduce in “Modern Replacements for map, filter, and reduce” on page 235. Another is partial: given a callable, it produces a new callable with some of the arguments of the original callable bound to predetermined values. This is useful to adapt a function that takes one or more arguments to an API that requires a callback with fewer arguments. Example 7-16 is a trivial demonstration.\n\nExample 7-16. Using partial to use a two-argument function where a one-argument callable is required\n\n>>> from operator import mul >>> from functools import partial >>> triple = partial(mul, 3) >>> triple(7) 21 >>> list(map(triple, range(1, 10))) [3, 6, 9, 12, 15, 18, 21, 24, 27]\n\nCreate new triple function from mul, binding the first positional argument to 3.\n\nTest it.\n\nUse triple with map; mul would not work with map in this example.\n\nA more useful example involves the unicode.normalize function that we saw in “Normalizing Unicode for Reliable Comparisons” on page 140. If you work with text from many languages, you may want to apply unicode.normalize('NFC', s) to any string s before comparing or storing it. If you do that often, it’s handy to have an nfc function to do so, as in Example 7-17.\n\nPackages for Functional Programming\n\n|\n\n247\n\nExample 7-17. Building a convenient Unicode normalizing function with partial\n\n>>> import unicodedata, functools >>> nfc = functools.partial(unicodedata.normalize, 'NFC') >>> s1 = 'café' >>> s2 = 'cafe\\u0301' >>> s1, s2 ('café', 'café') >>> s1 == s2 False >>> nfc(s1) == nfc(s2) True\n\npartial takes a callable as first argument, followed by an arbitrary number of posi‐ tional and keyword arguments to bind.\n\nExample 7-18 shows the use of partial with the tag function from Example 7-9, to freeze one positional argument and one keyword argument.\n\nExample 7-18. Demo of partial applied to the function tag from Example 7-9\n\n>>> from tagger import tag >>> tag <function tag at 0x10206d1e0> >>> from functools import partial >>> picture = partial(tag, 'img', class_='pic-frame') >>> picture(src='wumpus.jpeg') '<img class=\"pic-frame\" src=\"wumpus.jpeg\" />' >>> picture functools.partial(<function tag at 0x10206d1e0>, 'img', class_='pic-frame') >>> picture.func <function tag at 0x10206d1e0> >>> picture.args ('img',) >>> picture.keywords {'class_': 'pic-frame'}\n\nImport tag from Example 7-9 and show its ID.\n\nCreate the picture function from tag by fixing the first positional argument with 'img' and the class_ keyword argument with 'pic-frame'.\n\npicture works as expected.\n\n248\n\n|\n\nChapter 7: Functions as First-Class Objects\n\npartial() returns a functools.partial object.4\n\nA functools.partial object has attributes providing access to the original func‐ tion and the fixed arguments.\n\nThe functools.partialmethod function does the same job as partial, but is designed to work with methods.\n\nThe functools module also includes higher-order functions designed to be used as function decorators, such as cache and singledispatch, among others. Those functions are covered in Chapter 9, which also explains how to implement custom decorators.\n\nChapter Summary The goal of this chapter was to explore the first-class nature of functions in Python. The main ideas are that you can assign functions to variables, pass them to other functions, store them in data structures, and access function attributes, allowing frameworks and tools to act on that information.\n\nHigher-order functions, a staple of functional programming, are common in Python. The sorted, min, and max built-ins, and functools.partial are examples of com‐ monly used higher-order functions in the language. Using map, filter, and reduce is not as common as it used to be, thanks to list comprehensions (and similar con‐ structs like generator expressions) and the addition of reducing built-ins like sum, all, and any.\n\nCallables come in nine different flavors since Python 3.6, from the simple functions created with lambda to instances of classes implementing __call__. Generators and coroutines are also callable, although their behavior is very different from other calla‐ bles. All callables can be detected by the callable() built-in. Callables offer rich syn‐ tax for declaring formal parameters, including keyword-only parameters, positional- only parameters, and annotations.\n\nLastly, we covered some functions from the operator module and functools.par tial, which facilitate functional programming by minimizing the need for the func‐ tionally challenged lambda syntax.\n\n4 The source code for functools.py reveals that functools.partial is implemented in C and is used by default.\n\nIf that is not available, a pure-Python implementation of partial is available since Python 3.4.\n\nChapter Summary\n\n|\n\n249\n\nFurther Reading The next chapters continue our exploration of programming with function objects. Chapter 8 is devoted to type hints in function parameters and return values. Chap‐ ter 9 dives into function decorators—a special kind of higher-order function—and the closure mechanism that makes them work. Chapter 10 shows how first-class functions can simplify some classic object-oriented design patterns.\n\nIn The Python Language Reference, “3.2. The standard type hierarchy” presents the nine callable types, along with all the other built-in types.\n\nChapter 7 of the Python Cookbook, 3rd ed. (O’Reilly), by David Beazley and Brian K. Jones, is an excellent complement to the current chapter as well as Chapter 9 of this book, covering mostly the same concepts with a different approach.\n\nSee PEP 3102—Keyword-Only Arguments if you are interested in the rationale and use cases for that feature.\n\nA great introduction to functional programming in Python is A. M. Kuchling’s “Python Functional Programming HOWTO”. The main focus of that text, however, is the use of iterators and generators, which are the subject of Chapter 17.\n\nThe StackOverflow question “Python: Why is functools.partial necessary?” has a highly informative (and funny) reply by Alex Martelli, coauthor of the classic Python in a Nutshell (O’Reilly).\n\nReflecting on the question “Is Python a functional language?”, I created one of my favorite talks, “Beyond Paradigms,” which I presented at PyCaribbean, PyBay, and PyConDE. See the slides and video from the Berlin presentation—where I met Miro‐ slav Šedivý and Jürgen Gmach, two of the technical reviewers of this book.\n\nSoapbox\n\nIs Python a Functional Language?\n\nSometime in the year 2000 I attended a Zope workshop at Zope Corporation in the United States when Guido van Rossum dropped by the classroom (he was not the instructor). In the Q&A that followed, somebody asked him which features of Python were borrowed from other languages. Guido’s answer: “Everything that is good in Python was stolen from other languages.”\n\nShriram Krishnamurthi, professor of Computer Science at Brown University, starts his “Teaching Programming Languages in a Post-Linnaean Age” paper with this:\n\nProgramming language “paradigms” are a moribund and tedious legacy of a bygone age. Modern language designers pay them no respect, so why do our courses slavishly adhere to them?\n\n250\n\n|\n\nChapter 7: Functions as First-Class Objects\n\nIn that paper, Python is mentioned by name in this passage:\n\nWhat else to make of a language like Python, Ruby, or Perl? Their designers have no patience for the niceties of these Linnaean hierarchies; they borrow features as they wish, creating mélanges that utterly defy characterization.\n\nKrishnamurthi argues that instead of trying to classify languages in some taxonomy, it’s more useful to consider them as aggregations of features. His ideas inspired my talk “Beyond Paradigms,” mentioned at the end of “Further Reading” on page 250.\n\nEven if it was not Guido’s goal, endowing Python with first-class functions opened the door to functional programming. In his post, “Origins of Python’s Functional Features”, he says that map, filter, and reduce were the motivation for adding lambda to Python in the first place. All of these features were contributed together by Amrit Prem for Python 1.0 in 1994, according to Misc/HISTORY in the CPython source code.\n\nFunctions like map, filter, and reduce first appeared in Lisp, the original functional language. However, Lisp does not limit what can be done inside a lambda, because everything in Lisp is an expression. Python uses a statement-oriented syntax in which expressions cannot contain statements, and many language constructs are statements —including try/catch, which is what I miss most often when writing lambdas. This is the price to pay for Python’s highly readable syntax.5 Lisp has many strengths, but readability is not one of them.\n\nIronically, stealing the list comprehension syntax from another functional language— Haskell—significantly diminished the need for map and filter, and also for lambda.\n\nBesides the limited anonymous function syntax, the biggest obstacle to wider adop‐ tion of functional programming idioms in Python is the lack of tail-call elimination, an optimization that allows memory-efficient computation of a function that makes a recursive call at the “tail” of its body. In another blog post, “Tail Recursion Elimina‐ tion”, Guido gives several reasons why such optimization is not a good fit for Python. That post is a great read for the technical arguments, but even more so because the first three and most important reasons given are usability issues. It is no accident that Python is a pleasure to use, learn, and teach. Guido made it so.\n\nSo there you have it: Python is not, by design, a functional language—whatever that means. Python just borrows a few good ideas from functional languages.\n\nThe Problem with Anonymous Functions\n\nBeyond the Python-specific syntax constraints, anonymous functions have a serious drawback in any language: they have no name.\n\n5 There is also the problem of lost indentation when pasting code to web forums, but I digress.\n\nFurther Reading\n\n|\n\n251\n\nI am only half joking here. Stack traces are easier to read when functions have names. Anonymous functions are a handy shortcut, people have fun coding with them, but sometimes they get carried away—especially if the language and environment encourage deep nesting of anonymous functions, like JavaScript on Node.js do. Lots of nested anonymous functions make debugging and error handling hard. Asynchro‐ nous programming in Python is more structured, perhaps because the limited lambda syntax prevents its abuse and forces a more explicit approach. Promises, futures, and deferreds are concepts used in modern asynchronous APIs. Along with coroutines, they provide an escape from the so-called “callback hell.” I promise to write more about asynchronous programming in the future, but this subject must be deferred to Chapter 21.\n\n252\n\n|\n\nChapter 7: Functions as First-Class Objects\n\nCHAPTER 8 Type Hints in Functions\n\nIt should also be emphasized that Python will remain a dynamically typed language, and the authors have no desire to ever make type hints mandatory, even by convention.\n\n—Guido van Rossum, Jukka Lehtosalo, and Łukasz Langa, PEP 484—Type Hints1\n\nType hints are the biggest change in the history of Python since the unification of types and classes in Python 2.2, released in 2001. However, type hints do not benefit all Python users equally. That’s why they should always be optional.\n\nPEP 484—Type Hints introduced syntax and semantics for explicit type declarations in function arguments, return values, and variables. The goal is to help developer tools find bugs in Python codebases via static analysis, i.e., without actually running the code through tests.\n\nThe main beneficiaries are professional software engineers using IDEs (Integrated Development Environments) and CI (Continuous Integration). The cost-benefit analysis that makes type hints attractive to that group does not apply to all users of Python.\n\nPython’s user base is much wider than that. It includes scientists, traders, journalists, artists, makers, analysts, and students in many fields—among others. For most of them, the cost of learning type hints is likely higher—unless they already know a language with static types, subtyping, and generics. The benefits will be lower for many of those users, given how they interact with Python, and the smaller size of their codebases and teams—often “teams” of one. Python’s default dynamic typing is\n\n1 PEP 484—Type Hints, “Rationale and Goals”; bold emphasis retained from the original.\n\n253\n\nsimpler and more expressive when writing code for exploring data and ideas, as in data science, creative computing, and learning,\n\nThis chapter focuses on Python’s type hints in function signatures. Chapter 15 explores type hints in the context of classes, and other typing module features.\n\nThe major topics in this chapter are:\n\nA hands-on introduction to gradual typing with Mypy\n\nThe complementary perspectives of duck typing and nominal typing\n\nOverview of the main categories of types that can appear in annotations—this is about 60% of the chapter\n\nType hinting variadic parameters (*args, **kwargs)\n\nLimitations and downsides of type hints and static typing\n\nWhat’s New in This Chapter This chapter is completely new. Type hints appeared in Python 3.5 after I wrapped up the first edition of Fluent Python.\n\nGiven the limitations of a static type system, the best idea of PEP 484 was to intro‐ duce a gradual type system. Let’s begin by defining what that means.\n\nAbout Gradual Typing PEP 484 introduced a gradual type system to Python. Other languages with gradual type systems are Microsoft’s TypeScript, Dart (the language of the Flutter SDK, cre‐ ated by Google), and Hack (a dialect of PHP supported by Facebook’s HHVM virtual machine). The Mypy type checker itself started as a language: a gradually typed dia‐ lect of Python with its own interpreter. Guido van Rossum convinced the creator of Mypy, Jukka Lehtosalo, to make it a tool for checking annotated Python code.\n\nA gradual type system:\n\nIs optional\n\nBy default, the type checker should not emit warnings for code that has no type hints. Instead, the type checker assumes the Any type when it cannot determine the type of an object. The Any type is considered compatible with all other types.\n\nDoes not catch type errors at runtime\n\nType hints are used by static type checkers, linters, and IDEs to raise warnings. They do not prevent inconsistent values from being passed to functions or assigned to variables at runtime.\n\n254\n\n|\n\nChapter 8: Type Hints in Functions\n\nDoes not enhance performance\n\nType annotations provide data that could, in theory, allow optimizations in the generated bytecode, but such optimizations are not implemented in any Python runtime that I am aware in of July 2021.2\n\nThe best usability feature of gradual typing is that annotations are always optional.\n\nWith static type systems, most type constraints are easy to express, many are cumber‐ some, some are hard, and a few are impossible.3 You may very well write an excellent piece of Python code, with good test coverage and passing tests, but still be unable to add type hints that satisfy a type checker. That’s OK; just leave out the problematic type hints and ship it!\n\nType hints are optional at all levels: you can have entire packages with no type hints, you can silence the type checker when you import one of those packages into a mod‐ ule where you use type hints, and you can add special comments to make the type checker ignore specific lines in your code.\n\nSeeking 100% coverage of type hints is likely to stimulate type hint‐ ing without proper thought, only to satisfy the metric. It will also prevent teams from making the most of the power and flexibility of Python. Code without type hints should naturally be accepted when annotations would make an API less user-friendly, or unduly complicate its implementation.\n\nGradual Typing in Practice Let’s see how gradual typing works in practice, starting with a simple function and gradually adding type hints to it, guided by Mypy.\n\nThere are several Python type checkers compatible with PEP 484, including Google’s pytype, Microsoft’s Pyright, Facebook’s Pyre— in addition to type checkers embedded in IDEs such as PyCharm. I picked Mypy for the examples because it’s the best known. How‐ ever, one of the others may be a better fit for some projects or teams. Pytype, for example, is designed to handle codebases with no type hints and still provide useful advice. It is more lenient than Mypy, and can also generate annotations for your code.\n\n2 A just-in-time compiler like the one in PyPy has much better data than type hints: it monitors the Python program as it runs, detects the concrete types in use, and generates optimized machine code for those concrete types.\n\n3 For example, recursive types are not supported as of July 2021—see typing module issue #182, Define a JSON\n\ntype and Mypy issue #731, Support recursive types.\n\nGradual Typing in Practice\n\n|\n\n255\n\nWe will annotate a show_count function that returns a string with a count and a sin‐ gular or plural word, depending on the count:\n\n>>> show_count(99, 'bird') '99 birds' >>> show_count(1, 'bird') '1 bird' >>> show_count(0, 'bird') 'no birds'\n\nExample 8-1 shows the source code of show_count, without annotations.\n\nExample 8-1. show_count from messages.py without type hints\n\ndef show_count(count, word): if count == 1: return f'1 {word}' count_str = str(count) if count else 'no' return f'{count_str} {word}s'\n\nStarting with Mypy To begin type checking, I run the mypy command on the messages.py module:\n\n…/no_hints/ $ pip install mypy [lots of messages omitted...] …/no_hints/ $ mypy messages.py Success: no issues found in 1 source file\n\nMypy with default settings finds no problem with Example 8-1.\n\nI am using Mypy 0.910, the most recent release as I review this in July 2021. The Mypy “Introduction” warns that it “is officially beta software. There will be occasional changes that break backward compatibility.” Mypy is giving me at least one report that is not the same I got when I wrote this chapter in April 2020. By the time you read this, you may get different results than shown here.\n\nIf a function signature has no annotations, Mypy ignores it by default—unless config‐ ured otherwise.\n\nFor Example 8-2, I also have pytest unit tests. This is the code in messages_test.py.\n\nExample 8-2. messages_test.py without type hints\n\nfrom pytest import mark\n\nfrom messages import show_count\n\n256\n\n|\n\nChapter 8: Type Hints in Functions\n\n@mark.parametrize('qty, expected', [ (1, '1 part'), (2, '2 parts'), ]) def test_show_count(qty, expected): got = show_count(qty, 'part') assert got == expected\n\ndef test_show_count_zero(): got = show_count(0, 'part') assert got == 'no parts'\n\nNow let’s add type hints, guided by Mypy.\n\nMaking Mypy More Strict The command-line option --disallow-untyped-defs makes Mypy flag any function definition that does not have type hints for all its parameters and for its return value.\n\nUsing --disallow-untyped-defs on the test file produces three errors and a note:\n\n…/no_hints/ $ mypy --disallow-untyped-defs messages_test.py messages.py:14: error: Function is missing a type annotation messages_test.py:10: error: Function is missing a type annotation messages_test.py:15: error: Function is missing a return type annotation messages_test.py:15: note: Use \"-> None\" if function does not return a value Found 3 errors in 2 files (checked 1 source file)\n\nFor the first steps with gradual typing, I prefer to use another option: --disallow- incomplete-defs. Initially, it tells me nothing:\n\n…/no_hints/ $ mypy --disallow-incomplete-defs messages_test.py Success: no issues found in 1 source file\n\nNow I can add just the return type to show_count in messages.py:\n\ndef show_count(count, word) -> str:\n\nThis is enough to make Mypy look at it. Using the same command line as before to check messages_test.py will lead Mypy to look at messages.py again:\n\n…/no_hints/ $ mypy --disallow-incomplete-defs messages_test.py messages.py:14: error: Function is missing a type annotation for one or more arguments Found 1 error in 1 file (checked 1 source file)\n\nNow I can gradually add type hints function by function, without getting warnings about functions that I haven’t annotated. This is a fully annotated signature that satis‐ fies Mypy:\n\ndef show_count(count: int, word: str) -> str:\n\nGradual Typing in Practice\n\n|\n\n257\n\nlike --disallow- Instead of incomplete-defs, you can save your favorite as described in the Mypy configuration file documentation. You can have global set‐ tings and per-module settings. Here is a simple mypy.ini to get started:\n\ntyping command-line options\n\n[mypy] python_version = 3.9 warn_unused_configs = True disallow_incomplete_defs = True\n\nA Default Parameter Value The show_count function in Example 8-1 only works with regular nouns. If the plural can’t be spelled by appending an 's', we should let the user provide the plural form, like this:\n\n>>> show_count(3, 'mouse', 'mice') '3 mice'\n\nLet’s do a little “type-driven development.” First we add a test that uses that third argument. Don’t forget to add the return type hint to the test function, otherwise Mypy will not check it.\n\ndef test_irregular() -> None: got = show_count(2, 'child', 'children') assert got == '2 children'\n\nMypy detects the error:\n\n…/hints_2/ $ mypy messages_test.py messages_test.py:22: error: Too many arguments for \"show_count\" Found 1 error in 1 file (checked 1 source file)\n\nNow I edit show_count, adding the optional plural parameter in Example 8-3.\n\nExample 8-3. showcount from hints_2/messages.py with an optional parameter\n\ndef show_count(count: int, singular: str, plural: str = '') -> str: if count == 1: return f'1 {singular}' count_str = str(count) if count else 'no' if not plural: plural = singular + 's' return f'{count_str} {plural}'\n\nNow Mypy reports “Success.”\n\n258\n\n|\n\nChapter 8: Type Hints in Functions\n\nHere is one typing mistake that Python does not catch. Can you spot it?\n\ndef hex2rgb(color=str) -> tuple[int, int, int]:\n\nMypy’s error report is not very helpful:\n\ncolors.py:24: error: Function is missing a type annotation for one or more arguments\n\nThe type hint for the color argument should be color: str. I wrote color=str, which is not an annotation: it sets the default value of color to str.\n\nIn my experience, it’s a common mistake and easy to overlook, especially in complicated type hints.\n\nThe following details are considered good style for type hints:\n\nNo space between the parameter name and the :; one space after the : • Spaces on both sides of the = that precedes a default parameter value\n\nOn the other hand, PEP 8 says there should be no spaces around the = if there is no type hint for that particular parameter.\n\nCode Style: Use flake8 and blue Instead of memorizing such silly rules, use tools like flake8 and blue. flake8 reports on code styling, among many other issues, and blue rewrites source code according to (most) rules embedded in the black code formatting tool.\n\nGiven the goal of enforcing a “standard” coding style, blue is better than black because it follows Python’s own style of using single quotes by default, double quotes as an alternative:\n\n>>> \"I prefer single quotes\" 'I prefer single quotes'\n\nThe preference for single quotes is embedded in repr(), among other places in CPy‐ thon. The doctest module depends on repr() using single quotes by default.\n\nOne of the authors of blue is Barry Warsaw, coauthor of PEP 8, Python core devel‐ oper since 1994, and a member of Python’s Steering Council from 2019 to present (July 2021). We are in very good company when we choose single quotes by default.\n\nIf you must use black, use the black -S option. Then it will leave your quotes as they are.\n\nGradual Typing in Practice\n\n|\n\n259\n\nUsing None as a Default In Example 8-3, the parameter plural is annotated as str, and the default value is '', so there is no type conflict.\n\nI like that solution, but in other contexts None is a better default. If the optional parameter expects a mutable type, then None is the only sensible default—as we saw in “Mutable Types as Parameter Defaults: Bad Idea” on page 214.\n\nTo have None as the default for the plural parameter, here is what the signature would look like:\n\nfrom typing import Optional\n\ndef show_count(count: int, singular: str, plural: Optional[str] = None) -> str:\n\nLet’s unpack that:\n\nOptional[str] means plural may be a str or None. • You must explicitly provide the default value = None.\n\nIf you don’t assign a default value to plural, the Python runtime will treat it as a required parameter. Remember: at runtime, type hints are ignored.\n\nNote that we need to import Optional from the typing module. When importing types, it’s good practice to use the syntax from typing import X to reduce the length of the function signatures.\n\nOptional is not a great name, because that annotation does not make the parameter optional. What makes it optional is assigning a default value to the parameter. Optional[str] just means: the type of this parameter may be str or NoneType. In the Haskell and Elm languages, a similar type is named Maybe.\n\nNow that we’ve had a first practical view of gradual typing, let’s consider what the concept of type means in practice.\n\nTypes Are Defined by Supported Operations\n\nThere are many definitions of the concept of type in the literature. Here we assume that type is a set of values and a set of functions that one can apply to these values.\n\n—PEP 483—The Theory of Type Hints\n\n260\n\n|\n\nChapter 8: Type Hints in Functions\n\nIn practice, it’s more useful to consider the set of supported operations as the defin‐ ing characteristic of a type.4\n\nFor example, from the point of view of applicable operations, what are the valid types for x in the following function?\n\ndef double(x): return x * 2\n\nThe x parameter type may be numeric (int, complex, Fraction, numpy.uint32, etc.) but it may also be a sequence (str, tuple, list, array), an N-dimensional numpy.array, or any other type that implements or inherits a __mul__ method that accepts an int argument.\n\nHowever, consider this annotated double. Please ignore the missing return type for now, let’s focus on the parameter type:\n\nfrom collections import abc\n\ndef double(x: abc.Sequence): return x * 2\n\nA type checker will reject that code. If you tell Mypy that x is of type abc.Sequence, it will flag x * 2 as an error because the Sequence ABC does not implement or inherit the __mul__ method. At runtime, that code will work with concrete sequences such as str, tuple, list, array, etc., as well as numbers, because at runtime the type hints are ignored. But the type checker only cares about what is explicitly declared, and abc.Sequence has no __mul__.\n\nThat’s why the title of this section is “Types Are Defined by Supported Operations.” The Python runtime accepts any object as the x argument for both versions of the double function. The computation x * 2 may work, or it may raise TypeError if the operation is not supported by x. In contrast, Mypy will declare x * 2 as wrong while analyzing the annotated double source code, because it’s an unsupported operation for the declared type: x: abc.Sequence.\n\nIn a gradual type system, we have the interplay of two different views of types:\n\nDuck typing\n\nThe view adopted by Smalltalk—the pioneering object-oriented language—as well as Python, JavaScript, and Ruby. Objects have types, but variables (including\n\n4 Python doesn’t provide syntax to control the set of possible values for a type—except in Enum types. For exam‐ ple, using type hints you can’t define Quantity as an integer between 1 and 1000, or AirportCode as a 3-letter combination. NumPy offers uint8, int16, and other machine-oriented numeric types, but in the Python standard library we only have types with very small sets of values (NoneType, bool) or extremely large sets (float, int, str, all possible tuples, etc.).\n\nTypes Are Defined by Supported Operations\n\n|\n\n261",
      "page_number": 265
    },
    {
      "number": 15,
      "title": "Segment 15 (pages 284-304)",
      "start_page": 284,
      "end_page": 304,
      "detection_method": "synthetic",
      "content": "parameters) are untyped. In practice, it doesn’t matter what the declared type of the object is, only what operations it actually supports. If I can invoke birdie.quack(), then birdie is a duck in this context. By definition, duck typ‐ ing is only enforced at runtime, when operations on objects are attempted. This is more flexible than nominal typing, at the cost of allowing more errors at run‐ time.5\n\nNominal typing\n\nThe view adopted by C++, Java, and C#, supported by annotated Python. Objects and variables have types. But objects only exist at runtime, and the type checker only cares about the source code where variables (including parameters) are annotated with type hints. If Duck is a subclass of Bird, you can assign a Duck instance to a parameter annotated as birdie: Bird. But in the body of the func‐ tion, the type checker considers the call birdie.quack() illegal, because birdie is nominally a Bird, and that class does not provide the .quack() method. It doesn’t matter if the actual argument at runtime is a Duck, because nominal typ‐ ing is enforced statically. The type checker doesn’t run any part of the program, it only reads the source code. This is more rigid than duck typing, with the advan‐ tage of catching some bugs earlier in a build pipeline, or even as the code is typed in an IDE.\n\nExample 8-4 is a silly example that contrasts duck typing and nominal typing, as well as static type checking and runtime behavior.6\n\nExample 8-4. birds.py\n\nclass Bird: pass\n\nclass Duck(Bird): def quack(self): print('Quack!')\n\ndef alert(birdie): birdie.quack()\n\ndef alert_duck(birdie: Duck) -> None: birdie.quack()\n\n5 Duck typing is an implicit form of structural typing, which Python ≥ 3.8 also supports with the introduction of typing.Protocol. This is covered later in this chapter—in “Static Protocols” on page 286—with more details in Chapter 13.\n\n6 Inheritance is often overused and hard to justify in examples that are realistic yet simple, so please accept this\n\nanimal example as a quick illustration of subtyping.\n\n262\n\n|\n\nChapter 8: Type Hints in Functions\n\ndef alert_bird(birdie: Bird) -> None: birdie.quack()\n\nDuck is a subclass of Bird.\n\nalert has no type hints, so the type checker ignores it.\n\nalert_duck takes one argument of type Duck.\n\nalert_bird takes one argument of type Bird.\n\nType checking birds.py with Mypy, we see a problem:\n\n…/birds/ $ mypy birds.py birds.py:16: error: \"Bird\" has no attribute \"quack\" Found 1 error in 1 file (checked 1 source file)\n\nJust by analyzing the source code, Mypy sees that alert_bird is problematic: the type hint declares the birdie parameter with type Bird, but the body of the function calls birdie.quack()—and the Bird class has no such method.\n\nNow let’s try to use the birds module in daffy.py in Example 8-5.\n\nExample 8-5. daffy.py\n\nfrom birds import *\n\ndaffy = Duck() alert(daffy) alert_duck(daffy) alert_bird(daffy)\n\nValid call, because alert has no type hints.\n\nValid call, because alert_duck takes a Duck argument, and daffy is a Duck.\n\nValid call, because alert_bird takes a Bird argument, and daffy is also a Bird— the superclass of Duck.\n\nRunning Mypy on daffy.py raises the same error about the quack call in the alert_bird function defined in birds.py:\n\n…/birds/ $ mypy daffy.py birds.py:16: error: \"Bird\" has no attribute \"quack\" Found 1 error in 1 file (checked 1 source file)\n\nBut Mypy sees no problem with daffy.py itself: the three function calls are OK.\n\nNow, if you run daffy.py, this is what you get:\n\nTypes Are Defined by Supported Operations\n\n|\n\n263\n\n…/birds/ $ python3 daffy.py Quack! Quack! Quack!\n\nEverything works! Duck typing FTW!\n\nAt runtime, Python doesn’t care about declared types. It uses duck typing only. Mypy flagged an error in alert_bird, but calling it with daffy works fine at runtime. This may surprise many Pythonistas at first: a static type checker will sometimes find errors in programs that we know will execute.\n\nHowever, if months from now you are tasked with extending the silly bird example, you may be grateful for Mypy. Consider this woody.py module, which also uses birds, in Example 8-6.\n\nExample 8-6. woody.py\n\nfrom birds import *\n\nwoody = Bird() alert(woody) alert_duck(woody) alert_bird(woody)\n\nMypy finds two errors while checking woody.py:\n\n…/birds/ $ mypy woody.py birds.py:16: error: \"Bird\" has no attribute \"quack\" woody.py:5: error: Argument 1 to \"alert_duck\" has incompatible type \"Bird\"; expected \"Duck\" Found 2 errors in 2 files (checked 1 source file)\n\nThe first error is in birds.py: the birdie.quack() call in alert_bird, which we’ve seen before. The second error is in woody.py: woody is an instance of Bird, so the call alert_duck(woody) is invalid because that function requires a Duck. Every Duck is a Bird, but not every Bird is a Duck.\n\nAt runtime, none of the calls in woody.py succeed. The succession of failures is best illustrated in a console session with callouts in Example 8-7.\n\nExample 8-7. Runtime errors and how Mypy could have helped\n\n>>> from birds import * >>> woody = Bird() >>> alert(woody) Traceback (most recent call last): ... AttributeError: 'Bird' object has no attribute 'quack' >>>\n\n264\n\n|\n\nChapter 8: Type Hints in Functions\n\n>>> alert_duck(woody) Traceback (most recent call last): ... AttributeError: 'Bird' object has no attribute 'quack' >>> >>> alert_bird(woody) Traceback (most recent call last): ... AttributeError: 'Bird' object has no attribute 'quack'\n\nMypy could not detect this error because there are no type hints in alert.\n\nMypy reported the problem: Argument 1 to \"alert_duck\" has incompatible type \"Bird\"; expected \"Duck\".\n\nMypy has been telling us since Example 8-4 that the body of the alert_bird function is wrong: \"Bird\" has no attribute \"quack\".\n\nThis little experiment shows that duck typing is easier to get started and is more flexi‐ ble, but allows unsupported operations to cause errors at runtime. Nominal typing detects errors before runtime, but sometimes can reject code that actually runs—such as the call alert_bird(daffy) in Example 8-5. Even if it sometimes works, the alert_bird function is misnamed: its body does require an object that supports the .quack() method, which Bird doesn’t have.\n\nIn this silly example, the functions are one-liners. But in real code they could be longer; they could pass the birdie argument to more functions, and the origin of the birdie argument could be many function calls away, making it hard to pinpoint the cause of a runtime error. The type checker prevents many such errors from ever hap‐ pening at runtime.\n\nThe value of type hints is questionable in the tiny examples that fit in a book. The benefits grow with the size of the codebase. That’s why companies with millions of lines of Python code—like Drop‐ box, Google, and Facebook—invested in teams and tools to sup‐ port the company-wide adoption of type hints, and have significant and increasing portions of their Python codebases type checked in their CI pipelines.\n\nIn this section we explored the relationship of types and operations in duck typing and nominal typing, starting with the simple double() function—which we left without proper type hints. Now we will tour the most important types used for anno‐ tating functions. We’ll see a good way to add type hints to double() when we reach “Static Protocols” on page 286. But before we get to that, there are more fundamental types to know.\n\nTypes Are Defined by Supported Operations\n\n|\n\n265\n\nTypes Usable in Annotations Pretty much any Python type can be used in type hints, but there are restrictions and recommendations. In addition, the typing module introduced special constructs with semantics that are sometimes surprising.\n\nThis section covers all the major types you can use with annotations:\n\ntyping.Any\n\nSimple types and classes • typing.Optional and typing.Union\n\nGeneric collections, including tuples and mappings\n\nAbstract base classes\n\nGeneric iterables • Parameterized generics and TypeVar • typing.Protocols—the key to static duck typing • typing.Callable • typing.NoReturn—a good way to end this list\n\nWe’ll cover each of these in turn, starting with a type that is strange, apparently use‐ less, but crucially important.\n\nThe Any Type The keystone of any gradual type system is the Any type, also known as the dynamic type. When a type checker sees an untyped function like this:\n\ndef double(x): return x * 2\n\nit assumes this:\n\ndef double(x: Any) -> Any: return x * 2\n\nThat means the x argument and the return value can be of any type, including differ‐ ent types. Any is assumed to support every possible operation.\n\nContrast Any with object. Consider this signature:\n\ndef double(x: object) -> object:\n\nThis function also accepts arguments of every type, because every type is a subtype-of object.\n\n266\n\n|\n\nChapter 8: Type Hints in Functions\n\nHowever, a type checker will reject this function:\n\ndef double(x: object) -> object: return x * 2\n\nThe problem is that object does not support the __mul__ operation. This is what Mypy reports:\n\n…/birds/ $ mypy double_object.py double_object.py:2: error: Unsupported operand types for * (\"object\" and \"int\") Found 1 error in 1 file (checked 1 source file)\n\nMore general types have narrower interfaces, i.e., they support fewer operations. The object class implements fewer operations than abc.Sequence, which implements fewer operations than abc.MutableSequence, which implements fewer operations than list.\n\nBut Any is a magic type that sits at the top and the bottom of the type hierarchy. It’s simultaneously the most general type—so that an argument n: Any accepts values of every type—and the most specialized type, supporting every possible operation. At least, that’s how the type checker understands Any.\n\nOf course, no type can support every possible operation, so using Any prevents the type checker from fulfilling its core mission: detecting potentially illegal operations before your program crashes with a runtime exception.\n\nSubtype-of versus consistent-with\n\nTraditional object-oriented nominal type systems rely on the is subtype-of relation‐ ship. Given a class T1 and a subclass T2, then T2 is subtype-of T1.\n\nConsider this code:\n\nclass T1: ...\n\nclass T2(T1): ...\n\ndef f1(p: T1) -> None: ...\n\no2 = T2()\n\nf1(o2) # OK\n\nTypes Usable in Annotations\n\n|\n\n267\n\nThe call f1(o2) is an application of the Liskov Substitution Principle—LSP. Barbara Liskov7 actually defined is subtype-of in terms of supported operations: if an object of type T2 substitutes an object of type T1 and the program still behaves correctly, then T2 is subtype-of T1.\n\nContinuing from the previous code, this shows a violation of the LSP:\n\ndef f2(p: T2) -> None: ...\n\no1 = T1()\n\nf2(o1) # type error\n\nFrom the point of view of supported operations, this makes perfect sense: as a sub‐ class, T2 inherits and must support all operations that T1 does. So an instance of T2 can be used anywhere an instance of T1 is expected. But the reverse is not necessarily true: T2 may implement additional methods, so an instance of T1 may not be used everywhere an instance of T2 is expected. This focus on supported operations is reflected in the name behavioral subtyping, also used to refer to the LSP.\n\nIn a gradual type system, there is another relationship: consistent-with, which applies wherever subtype-of applies, with special provisions for type Any.\n\nThe rules for consistent-with are:\n\n1. Given T1 and a subtype T2, then T2 is consistent-with T1 (Liskov substitution). 2. Every type is consistent-with Any: you can pass objects of every type to an argu‐ ment declared of type Any.\n\n3. Any is consistent-with every type: you can always pass an object of type Any where an argument of another type is expected.\n\nConsidering the previous definitions of the objects o1 and o2, here are examples of valid code, illustrating rules #2 and #3:\n\ndef f3(p: Any) -> None: ...\n\no0 = object() o1 = T1() o2 = T2()\n\nf3(o0) # f3(o1) # all OK: rule #2 f3(o2) #\n\n7 MIT Professor, programming language designer, and Turing Award recipient. Wikipedia: Barbara Liskov.\n\n268\n\n|\n\nChapter 8: Type Hints in Functions\n\ndef f4(): # implicit return type: `Any` ...\n\no4 = f4() # inferred type: `Any`\n\nf1(o4) # f2(o4) # all OK: rule #3 f3(o4) #\n\nEvery gradual type system needs a wildcard type like Any.\n\nThe verb “to infer” is a fancy synomym for “to guess,” used in the context of type analysis. Modern type checkers in Python and other languages don’t require type annotations everywhere because they can infer the type of many expressions. For example, if I write x = len(s) * 10, the type checker doesn’t need an explicit local decla‐ ration to know that x is an int, as long as it can find type hints for the len built-in.\n\nNow we can explore the rest of the types used in annotations.\n\nSimple Types and Classes Simple types like int, float, str, and bytes may be used directly in type hints. Con‐ crete classes from the standard library, external packages, or user defined—French Deck, Vector2d, and Duck—may also be used in type hints.\n\nAbstract base classes are also useful in type hints. We’ll get back to them as we study collection types, and in “Abstract Base Classes” on page 278.\n\nAmong classes, consistent-with is defined like subtype-of: a subclass is consistent-with all its superclasses.\n\nHowever, “practicality beats purity,” so there is an important exception, which I dis‐ cuss in the following tip.\n\nint Is Consistent-With complex\n\nThere is no nominal subtype relationship between the built-in types int, float, and complex: they are direct subclasses of object. But PEP 484 declares that int is consistent-with float, and float is consistent-with complex. It makes sense in practice: int imple‐ ments all operations that float does, and int implements addi‐ tional ones as well—bitwise operations like &, |, <<, etc. The end result is: int is consistent-with complex. For i = 3, i.real is 3, and i.imag is 0.\n\nTypes Usable in Annotations\n\n|\n\n269\n\nOptional and Union Types We saw the Optional special type in “Using None as a Default” on page 260. It solves the problem of having None as a default, as in this example from that section:\n\nfrom typing import Optional\n\ndef show_count(count: int, singular: str, plural: Optional[str] = None) -> str:\n\nThe construct Optional[str] is actually a shortcut for Union[str, None], which means the type of plural may be str or None.\n\nBetter Syntax for Optional and Union in Python 3.10\n\nWe can write str | bytes instead of Union[str, bytes] since Python 3.10. It’s less typing, and there’s no need to import Optional or Union from typing. Contrast the old and new syntax for the type hint of the plural parameter of show_count:\n\nplural: Optional[str] = None # before plural: str | None = None # after\n\nThe | operator also works with isinstance and issubclass to build the second argument: isinstance(x, int | str). For more, see PEP 604—Complementary syntax for Union[].\n\nThe ord built-in function’s signature is a simple example of Union—it accepts str or bytes, and returns an int:8\n\ndef ord(c: Union[str, bytes]) -> int: ...\n\nHere is an example of a function that takes a str, but may return a str or a float:\n\nfrom typing import Union\n\ndef parse_token(token: str) -> Union[str, float]: try: return float(token) except ValueError: return token\n\nIf possible, avoid creating functions that return Union types, as they put an extra bur‐ den on the user—forcing them to check the type of the returned value at runtime to know what to do with it. But the parse_token in the preceding code is a reasonable use case in the context of a simple expression evaluator.\n\n8 To be more precise, ord only accepts str or bytes with len(s) == 1. But the type system currently can’t\n\nexpress this constraint.\n\n270\n\n|\n\nChapter 8: Type Hints in Functions\n\nIn “Dual-Mode str and bytes APIs” on page 155, we saw functions that accept either str or bytes arguments, but return str if the argument was str or bytes if the arguments was bytes. In those cases, the return type is determined by the input type, so Union is not an accurate solution. To properly annotate such functions, we need a type variable—presented in “Parameterized Generics and TypeVar” on page 282—or overloading, which we’ll see in “Overloa‐ ded Signatures” on page 520.\n\nUnion[] requires at least two types. Nested Union types have the same effect as a flat‐ tened Union. So this type hint:\n\nUnion[A, B, Union[C, D, E]]\n\nis the same as:\n\nUnion[A, B, C, D, E]\n\nUnion is more useful with types that are not consistent among themselves. For exam‐ ple: Union[int, float] is redundant because int is consistent-with float. If you just use float to annotate the parameter, it will accept int values as well.\n\nGeneric Collections Most Python collections are heterogeneous. For example, you can put any mixture of different types in a list. However, in practice that’s not very useful: if you put objects in a collection, you are likely to want to operate on them later, and usually this means they must share at least one common method.9\n\nGeneric types can be declared with type parameters to specify the type of the items they can handle.\n\nFor example, a list can be parameterized to constrain the type of the elements in it, as you can see in Example 8-8.\n\nExample 8-8. tokenize with type hints for Python ≥ 3.9\n\ndef tokenize(text: str) -> list[str]: return text.upper().split()\n\nIn Python ≥ 3.9, it means that tokenize returns a list where every item is of type str.\n\n9 In ABC—the language that most influenced the initial design of Python—each list was constrained to accept\n\nvalues of a single type: the type of the first item you put into it.\n\nTypes Usable in Annotations\n\n|\n\n271\n\nThe annotations stuff: list and stuff: list[Any] mean the same thing: stuff is a list of objects of any type.\n\nIf you are using Python 3.8 or earlier, the concept is the same, but you need more code to make it work—as explained in the optional box “Legacy Support and Deprecated Collection Types” on page 272.\n\nPEP 585—Type Hinting Generics In Standard Collections lists collections from the standard library accepting generic type hints. The following list shows only those col‐ lections that use the simplest form of generic type hint, container[item]:\n\nlist collections.deque abc.Sequence abc.MutableSequence set abc.Container abc.Set abc.MutableSet frozenset abc.Collection\n\nThe tuple and mapping types support more complex type hints, as we’ll see in their respective sections.\n\nAs of Python 3.10, there is no good way to annotate array.array, taking into account the typecode constructor argument, which determines whether integers or floats are stored in the array. An even harder problem is how to type check integer ranges to prevent OverflowError at runtime when adding elements to arrays. For example, an array with typecode='B' can only hold int values from 0 to 255. Cur‐ rently, Python’s static type system is not up to this challenge.\n\nLegacy Support and Deprecated Collection Types\n\n(You may skip this box if you only use Python 3.9 or later.)\n\nFor Python 3.7 and 3.8, you need a __future__ import to make the [] notation work with built-in collections such as list, as shown in Example 8-9.\n\nExample 8-9. tokenize with type hints for Python ≥ 3.7\n\nfrom __future__ import annotations\n\ndef tokenize(text: str) -> list[str]: return text.upper().split()\n\nThe __future__ import does not work with Python 3.6 or earlier. Example 8-10 shows how to annotate tokenize in a way that works with Python ≥ 3.5.\n\nExample 8-10. tokenize with type hints for Python ≥ 3.5\n\nfrom typing import List\n\n272\n\n|\n\nChapter 8: Type Hints in Functions\n\ndef tokenize(text: str) -> List[str]: return text.upper().split()\n\nTo provide the initial support for generic type hints, the authors of PEP 484 created dozens of generic types in the typing module. Table 8-1 shows some of them. For the full list, visit the typing documentation.\n\nTable 8-1. Some collection types and their type hint equivalents\n\nCollection list\n\nType hint equivalent typing.List\n\nset\n\ntyping.Set\n\nfrozenset\n\ntyping.FrozenSet\n\ncollections.deque\n\ntyping.Deque\n\ncollections.abc.MutableSequence typing.MutableSequence\n\ncollections.abc.Sequence\n\ntyping.Sequence\n\ncollections.abc.Set\n\ntyping.AbstractSet\n\ncollections.abc.MutableSet\n\ntyping.MutableSet\n\nPEP 585—Type Hinting Generics In Standard Collections started a multiyear process to improve the usability of generic type hints. We can summarize that process in four steps:\n\n1. Introduce from __future__ import annotations in Python 3.7 to enable the use of standard library classes as generics with list[str] notation.\n\n2. Make that behavior the default in Python 3.9: list[str] now works without the future import.\n\n3. Deprecate all the redundant generic types from the typing module.10 Depreca‐ tion warnings will not be issued by the Python interpreter because type checkers should flag the deprecated types when the checked program targets Python 3.9 or newer.\n\n4. Remove those redundant generic types in the first version of Python released five years after Python 3.9. At the current cadence, that could be Python 3.14, a.k.a Python Pi.\n\nNow let’s see how to annotate generic tuples.\n\n10 One of my contributions to the typing module documentation was to add dozens of deprecation warnings as I reorganized the entries below “Module Contents” into subsections, under the supervision of Guido van Rossum.\n\nTypes Usable in Annotations\n\n|\n\n273\n\nTuple Types There are three ways to annotate tuple types:\n\nTuples as records\n\nTuples as records with named fields\n\nTuples as immutable sequences\n\nTuples as records\n\nIf you’re using a tuple as a record, use the tuple built-in and declare the types of the fields within [].\n\nFor example, the type hint would be tuple[str, float, str] to accept a tuple with city name, population, and country: ('Shanghai', 24.28, 'China').\n\nConsider a function that takes a pair of geographic coordinates and returns a Geo‐ hash, used like this:\n\n>>> shanghai = 31.2304, 121.4737 >>> geohash(shanghai) 'wtw3sjq6q'\n\nExample 8-11 shows how geohash is defined, using the geolib package from PyPI.\n\nExample 8-11. coordinates.py with the geohash function\n\nfrom geolib import geohash as gh # type: ignore\n\nPRECISION = 9\n\ndef geohash(lat_lon: tuple[float, float]) -> str: return gh.encode(*lat_lon, PRECISION)\n\nThis comment stops Mypy from reporting that the geolib package doesn’t have type hints.\n\nlat_lon parameter annotated as a tuple with two float fields.\n\nFor Python < 3.9, import and use typing.Tuple in type hints. It is deprecated but will remain in the standard library at least until 2024.\n\n274\n\n|\n\nChapter 8: Type Hints in Functions\n\nTuples as records with named fields\n\nTo annotate a tuple with many fields, or specific types of tuple your code uses in many places, I highly recommend using typing.NamedTuple, as seen in Chapter 5. Example 8-12 shows a variation of Example 8-11 with NamedTuple.\n\nExample 8-12. coordinates_named.py with the NamedTuple Coordinates and the geo hash function\n\nfrom typing import NamedTuple\n\nfrom geolib import geohash as gh # type: ignore\n\nPRECISION = 9\n\nclass Coordinate(NamedTuple): lat: float lon: float\n\ndef geohash(lat_lon: Coordinate) -> str: return gh.encode(*lat_lon, PRECISION)\n\nAs explained in “Overview of Data Class Builders” on page 164, typing.NamedTuple is a factory for tuple subclasses, so Coordinate is consistent-with tuple[float, float] but the reverse is not true—after all, Coordinate has extra methods added by NamedTuple, like ._asdict(), and could also have user-defined methods.\n\nIn practice, this means that it is type safe to pass a Coordinate instance to the dis play function defined in the following:\n\ndef display(lat_lon: tuple[float, float]) -> str: lat, lon = lat_lon ns = 'N' if lat >= 0 else 'S' ew = 'E' if lon >= 0 else 'W' return f'{abs(lat):0.1f}°{ns}, {abs(lon):0.1f}°{ew}'\n\nTuples as immutable sequences\n\nTo annotate tuples of unspecified length that are used as immutable lists, you must specify a single type, followed by a comma and ... (that’s Python’s ellipsis token, made of three periods, not Unicode U+2026—HORIZONTAL ELLIPSIS).\n\nFor example, tuple[int, ...] is a tuple with int items.\n\nThe ellipsis indicates that any number of elements >= 1 is acceptable. There is no way to specify fields of different types for tuples of arbitrary length.\n\nThe annotations stuff: tuple[Any, ...] and stuff: tuple mean the same thing: stuff is a tuple of unspecified length with objects of any type.\n\nTypes Usable in Annotations\n\n|\n\n275\n\nHere is a columnize function that transforms a sequence into a table of rows and cells in the form of a list of tuples with unspecified lengths. This is useful to display items in columns, like this:\n\n>>> animals = 'drake fawn heron ibex koala lynx tahr xerus yak zapus'.split() >>> table = columnize(animals) >>> table [('drake', 'koala', 'yak'), ('fawn', 'lynx', 'zapus'), ('heron', 'tahr'), ('ibex', 'xerus')] >>> for row in table: ... print(''.join(f'{word:10}' for word in row)) ... drake koala yak fawn lynx zapus heron tahr ibex xerus\n\nExample 8-13 shows the implementation of columnize. Note the return type:\n\nlist[tuple[str, ...]]\n\nExample 8-13. columnize.py returns a list of tuples of strings\n\nfrom collections.abc import Sequence\n\ndef columnize( sequence: Sequence[str], num_columns: int = 0 ) -> list[tuple[str, ...]]: if num_columns == 0: num_columns = round(len(sequence) ** 0.5) num_rows, reminder = divmod(len(sequence), num_columns) num_rows += bool(reminder) return [tuple(sequence[i::num_rows]) for i in range(num_rows)]\n\nGeneric Mappings Generic mapping types are annotated as MappingType[KeyType, ValueType]. The built-in dict and the mapping types in collections and collections.abc accept that notation in Python ≥ 3.9. For earlier versions, you must use typing.Dict and other mapping types from the typing module, as described in “Legacy Support and Deprecated Collection Types” on page 272.\n\nExample 8-14 shows a practical use of a function returning an inverted index to search Unicode characters by name—a variation of Example 4-21 more suitable for server-side code that we’ll study in Chapter 21.\n\nGiven starting and ending Unicode character codes, name_index returns a dict[str, set[str]], which is an inverted index mapping each word to a set of characters that have that word in their names. For example, after indexing ASCII characters from 32\n\n276\n\n|\n\nChapter 8: Type Hints in Functions\n\nto 64, here are the sets of characters mapped to the words 'SIGN' and 'DIGIT', and how to find the character named 'DIGIT EIGHT':\n\n>>> index = name_index(32, 65) >>> index['SIGN'] {'$', '>', '=', '+', '<', '%', '#'} >>> index['DIGIT'] {'8', '5', '6', '2', '3', '0', '1', '4', '7', '9'} >>> index['DIGIT'] & index['EIGHT'] {'8'}\n\nExample 8-14 shows the source code for charindex.py with the name_index function. Besides a dict[] type hint, this example has three features appearing for the first time in the book.\n\nExample 8-14. charindex.py\n\nimport sys import re import unicodedata from collections.abc import Iterator\n\nRE_WORD = re.compile(r'\\w+') STOP_CODE = sys.maxunicode + 1\n\ndef tokenize(text: str) -> Iterator[str]: \"\"\"return iterable of uppercased words\"\"\" for match in RE_WORD.finditer(text): yield match.group().upper()\n\ndef name_index(start: int = 32, end: int = STOP_CODE) -> dict[str, set[str]]: index: dict[str, set[str]] = {} for char in (chr(i) for i in range(start, end)): if name := unicodedata.name(char, ''): for word in tokenize(name): index.setdefault(word, set()).add(char) return index\n\ntokenize is a generator function. Chapter 17 is about generators.\n\nThe local variable index is annotated. Without the hint, Mypy says: Need type annotation for 'index' (hint: \"index: dict[<type>, <type>] = ...\").\n\nTypes Usable in Annotations\n\n|\n\n277\n\nI used the walrus operator := in the if condition. It assigns the result of the uni codedata.name() call to name, and the whole expression evaluates to that result. When the result is '', that’s falsy, and the index is not updated.11\n\nWhen using a dict as a record, it is common to have all keys of the str type, with values of different types depending on the keys. That is covered in “TypedDict” on page 526.\n\nAbstract Base Classes\n\nBe conservative in what you send, be liberal in what you accept.\n\n—Postel’s law, a.k.a. the Robustness Principle\n\nTable 8-1 lists several abstract classes from collections.abc. Ideally, a function should accept arguments of those abstract types—or their typing equivalents before Python 3.9—and not concrete types. This gives more flexibility to the caller.\n\nConsider this function signature:\n\nfrom collections.abc import Mapping\n\ndef name2hex(name: str, color_map: Mapping[str, int]) -> str:\n\nUsing abc.Mapping allows the caller to provide an instance of dict, defaultdict, ChainMap, a UserDict subclass, or any other type that is a subtype-of Mapping.\n\nIn contrast, consider this signature:\n\ndef name2hex(name: str, color_map: dict[str, int]) -> str:\n\nNow color_map must be a dict or one of its subtypes, such as defaultDict or OrderedDict. In particular, a subclass of collections.UserDict would not pass the type check for color_map, despite being the recommended way to create user-defined mappings, as we saw in “Subclassing UserDict Instead of dict” on page 97. Mypy would reject a UserDict or an instance of a class derived from it, because UserDict is not a subclass of dict; they are siblings. Both are subclasses of abc.MutableMapping.12\n\n11 I use := when it makes sense in a few examples, but I don’t cover it in the book. Please see PEP 572—Assign‐\n\nment Expressions for all the gory details.\n\n12 Actually, dict is a virtual subclass of abc.MutableMapping. The concept of a virtual subclass is explained in\n\nChapter 13. For now, know that issubclass(dict, abc.MutableMapping) is True, despite the fact that dict is implemented in C and does not inherit anything from abc.MutableMapping, but only from object.\n\n278\n\n|\n\nChapter 8: Type Hints in Functions\n\nTherefore, in general it’s better to use abc.Mapping or abc.MutableMapping in parameter type hints, instead of dict (or typing.Dict in legacy code). If the name2hex function doesn’t need to mutate the given color_map, the most accurate type hint for color_map is abc.Mapping. That way, the caller doesn’t need to provide an object that implements methods like setdefault, pop, and update, which are part of the MutableMapping interface, but not of Mapping. This has to do with the second part of Postel’s law: “Be liberal in what you accept.”\n\nPostel’s law also tells us to be conservative in what we send. The return value of a function is always a concrete object, so the return type hint should be a concrete type, as in the example from “Generic Collections” on page 271—which uses list[str]:\n\ndef tokenize(text: str) -> list[str]: return text.upper().split()\n\nUnder the entry of typing.List, the Python documentation says:\n\nGeneric version of list. Useful for annotating return types. To annotate arguments it is preferred to use an abstract collection type such as Sequence or Iterable.\n\nA similar comment appears in the entries for typing.Dict and typing.Set.\n\nRemember that most ABCs from collections.abc and other concrete classes from collections, as well as built-in collections, support generic type hint notation like collections.deque[str] starting with Python 3.9. The corresponding typing col‐ lections are only needed to support code written in Python 3.8 or earlier. The full list of classes that became generic appears in the “Implementation” section of PEP 585— Type Hinting Generics In Standard Collections.\n\nTo wrap up our discussion of ABCs in type hints, we need to talk about the numbers ABCs.\n\nThe fall of the numeric tower\n\nThe numbers package defines the so-called numeric tower described in PEP 3141—A Type Hierarchy for Numbers. The tower is linear hierarchy of ABCs, with Number at the top:\n\nNumber • Complex • Real • Rational • Integral\n\nTypes Usable in Annotations\n\n|\n\n279\n\nThose ABCs work perfectly well for runtime type checking, but they are not sup‐ ported for static type checking. The “Numeric Tower” section of PEP 484 rejects the numbers ABCs and dictates that the built-in types complex, float, and int should be treated as special cases, as explained in “int Is Consistent-With complex” on page 269.\n\nWe’ll come back to this issue in “The numbers ABCs and Numeric Protocols” on page 478, in Chapter 13, which is devoted to contrasting protocols and ABCs.\n\nIn practice, if you want to annotate numeric arguments for static type checking, you have a few options:\n\n1. Use one of the concrete types int, float, or complex—as recommended by PEP 488.\n\n2. Declare a union type like Union[float, Decimal, Fraction]. 3. If you want to avoid hardcoding concrete types, use numeric protocols like Sup portsFloat, covered in “Runtime Checkable Static Protocols” on page 468.\n\nThe upcoming section “Static Protocols” on page 286 is a prerequisite for understand‐ ing the numeric protocols.\n\nMeanwhile, let’s get to one of the most useful ABCs for type hints: Iterable.\n\nIterable The typing.List documentation I just quoted recommends Sequence and Iterable for function parameter type hints.\n\nOne example of the Iterable argument appears in the math.fsum function from the standard library:\n\ndef fsum(__seq: Iterable[float]) -> float:\n\nStub Files and the Typeshed Project\n\nAs of Python 3.10, the standard library has no annotations, but Mypy, PyCharm, etc. can find the necessary type hints in the Typeshed project, in the form of stub files: special source files with a .pyi extension that have annotated function and method signa‐ tures, without the implementation—much like header files in C. The signature for math.fsum is in /stdlib/2and3/math.pyi. The lead‐ ing underscores in __seq are a PEP 484 convention for positional- only parameters, explained in “Annotating Positional Only and Variadic Parameters” on page 295.\n\n280\n\n|\n\nChapter 8: Type Hints in Functions\n\nExample 8-15 is another example using an Iterable parameter that produces items that are tuple[str, str]. Here is how the function is used:\n\n>>> l33t = [('a', '4'), ('e', '3'), ('i', '1'), ('o', '0')] >>> text = 'mad skilled noob powned leet' >>> from replacer import zip_replace >>> zip_replace(text, l33t) 'm4d sk1ll3d n00b p0wn3d l33t'\n\nExample 8-15 shows how it’s implemented.\n\nExample 8-15. replacer.py\n\nfrom collections.abc import Iterable\n\nFromTo = tuple[str, str]\n\ndef zip_replace(text: str, changes: Iterable[FromTo]) -> str: for from_, to in changes: text = text.replace(from_, to) return text\n\nFromTo is a type alias: I assigned tuple[str, str] to FromTo, to make the signa‐ ture of zip_replace more readable.\n\nchanges needs to be an Iterable[FromTo]; that’s the same as Itera ble[tuple[str, str]], but shorter and easier to read.\n\nExplicit TypeAlias in Python 3.10\n\nPEP 613—Explicit Type Aliases introduced a special type, TypeA lias, to make the assignments that create type aliases more visible and easier to type check. Starting with Python 3.10, this is the pre‐ ferred way to create type aliases:\n\nfrom typing import TypeAlias\n\nFromTo: TypeAlias = tuple[str, str]\n\nabc.Iterable versus abc.Sequence\n\nBoth math.fsum and replacer.zip_replace must iterate over the entire Iterable arguments to return a result. Given an endless iterable such as the itertools.cycle generator as input, these functions would consume all memory and crash the Python process. Despite this potential danger, it is fairly common in modern Python to offer functions that accept an Iterable input even if they must process it completely to return a result. That gives the caller the option of providing input data as a generator\n\nTypes Usable in Annotations\n\n|\n\n281\n\ninstead of a prebuilt sequence, potentially saving a lot of memory if the number of input items is large.\n\nOn the other hand, the columnize function from Example 8-13 needs a Sequence parameter, and not an Iterable, because it must get the len() of the input to com‐ pute the number of rows up front.\n\nLike Sequence, Iterable is best used as a parameter type. It’s too vague as a return type. A function should be more precise about the concrete type it returns.\n\nClosely related to Iterable is the Iterator type, used as a return type in Example 8-14. We’ll get back to it in Chapter 17, which is about generators and classic iterators.\n\nParameterized Generics and TypeVar A parameterized generic is a generic type, written as list[T], where T is a type vari‐ able that will be bound to a specific type with each usage. This allows a parameter type to be reflected on the result type.\n\nExample 8-16 defines sample, a function that takes two arguments: a Sequence of ele‐ ments of type T, and an int. It returns a list of elements of the same type T, picked at random from the first argument.\n\nExample 8-16 shows the implementation.\n\nExample 8-16. sample.py\n\nfrom collections.abc import Sequence from random import shuffle from typing import TypeVar\n\nT = TypeVar('T')\n\ndef sample(population: Sequence[T], size: int) -> list[T]: if size < 1: raise ValueError('size must be >= 1') result = list(population) shuffle(result) return result[:size]\n\nHere are two examples of why I used a type variable in sample:\n\nIf called with a tuple of type tuple[int, ...]—which is consistent-with Sequence[int]—then the type parameter is int, so the return type is list[int].\n\n282\n\n|\n\nChapter 8: Type Hints in Functions",
      "page_number": 284
    },
    {
      "number": 16,
      "title": "Segment 16 (pages 305-326)",
      "start_page": 305,
      "end_page": 326,
      "detection_method": "synthetic",
      "content": "If called with a str—which is consistent-with Sequence[str]—then the type parameter is str, so the return type is list[str].\n\nWhy Is TypeVar Needed?\n\nThe authors of PEP 484 wanted to introduce type hints by adding the typing module and not changing anything else in the language. With clever metaprogramming they could make the [] operator work on classes like Sequence[T]. But the name of the T variable inside the brackets must be defined somewhere—otherwise the Python interpreter would need deep changes to support generic type notation as special use of []. That’s why the typing.TypeVar constructor is needed: to introduce the variable name in the cur‐ rent namespace. Languages such as Java, C#, and TypeScript don’t require the name of type variable to be declared beforehand, so they have no equivalent of Python’s TypeVar class.\n\nAnother example is the statistics.mode function from the standard library, which returns the most common data point from a series.\n\nHere is one usage example from the documentation:\n\n>>> mode([1, 1, 2, 3, 3, 3, 3, 4]) 3\n\nWithout using a TypeVar, mode could have the signature shown in Example 8-17.\n\nExample 8-17. mode_float.py: mode that operates on float and subtypes13\n\nfrom collections import Counter from collections.abc import Iterable\n\ndef mode(data: Iterable[float]) -> float: pairs = Counter(data).most_common(1) if len(pairs) == 0: raise ValueError('no mode for empty data') return pairs[0][0]\n\nMany uses of mode involve int or float values, but Python has other numerical types, and it is desirable that the return type follows the element type of the given Iterable. We can improve that signature using TypeVar. Let’s start with a simple, but wrong, parameterized signature:\n\n13 The implementation here is simpler than the one in the Python standard library statistics module.\n\nTypes Usable in Annotations\n\n|\n\n283\n\nfrom collections.abc import Iterable from typing import TypeVar\n\nT = TypeVar('T')\n\ndef mode(data: Iterable[T]) -> T:\n\nWhen it first appears in the signature, the type parameter T can be any type. The sec‐ ond time it appears, it will mean the same type as the first.\n\nTherefore, every iterable is consistent-with Iterable[T], including iterables of unhashable types that collections.Counter cannot handle. We need to restrict the possible types assigned to T. We’ll see two ways of doing that in the next two sections.\n\nRestricted TypeVar\n\nTypeVar accepts extra positional arguments to restrict the type parameter. We can improve the signature of mode to accept specific number types, like this:\n\nfrom collections.abc import Iterable from decimal import Decimal from fractions import Fraction from typing import TypeVar\n\nNumberT = TypeVar('NumberT', float, Decimal, Fraction)\n\ndef mode(data: Iterable[NumberT]) -> NumberT:\n\nThat’s better than before, and it was the signature for mode in the statistics.pyi stub file on typeshed on May 25, 2020.\n\nHowever, the statistics.mode documentation includes this example:\n\n>>> mode([\"red\", \"blue\", \"blue\", \"red\", \"green\", \"red\", \"red\"]) 'red'\n\nIn a hurry, we could just add str to the NumberT definition:\n\nNumberT = TypeVar('NumberT', float, Decimal, Fraction, str)\n\nThat certainly works, but NumberT is badly misnamed if it accepts str. More impor‐ tantly, we can’t keep listing types forever, as we realize mode can deal with them. We can do better with another feature of TypeVar, introduced next.\n\nBounded TypeVar\n\nLooking at the body of mode in Example 8-17, we see that the Counter class is used for ranking. Counter is based on dict, therefore the element type of the data iterable must be hashable.\n\nAt first, this signature may seem to work:\n\n284\n\n|\n\nChapter 8: Type Hints in Functions\n\nfrom collections.abc import Iterable, Hashable\n\ndef mode(data: Iterable[Hashable]) -> Hashable:\n\nNow the problem is that the type of the returned item is Hashable: an ABC that implements only the __hash__ method. So the type checker will not let us do any‐ thing with the return value except call hash() on it. Not very useful.\n\nThe solution is another optional parameter of TypeVar: the bound keyword parame‐ ter. It sets an upper boundary for the acceptable types. In Example 8-18, we have bound=Hashable, which means the type parameter may be Hashable or any subtype- of it.14\n\nExample 8-18. mode_hashable.py: same as Example 8-17, with a more flexible signature\n\nfrom collections import Counter from collections.abc import Iterable, Hashable from typing import TypeVar\n\nHashableT = TypeVar('HashableT', bound=Hashable)\n\ndef mode(data: Iterable[HashableT]) -> HashableT: pairs = Counter(data).most_common(1) if len(pairs) == 0: raise ValueError('no mode for empty data') return pairs[0][0]\n\nTo summarize:\n\nA restricted type variable will be set to one of the types named in the TypeVar declaration.\n\nA bounded type variable will be set to the inferred type of the expression—as long as the inferred type is consistent-with the boundary declared in the bound= keyword argument of TypeVar.\n\nIt is unfortunate that the keyword argument to declare a bounded TypeVar is named bound=, because the verb “to bind” is commonly used to mean setting the value of a variable, which in the reference semantics of Python is best described as binding a name to the value. It would have been less confusing if the keyword argument was named boundary=.\n\n14 I contributed this solution to typeshed, and that’s how mode is annotated on statistics.pyi as of May 26, 2020.\n\nTypes Usable in Annotations\n\n|\n\n285\n\nThe typing.TypeVar constructor has other optional parameters—covariant and con travariant—that we’ll cover in Chapter 15, “Variance” on page 544.\n\nLet’s conclude this introduction to TypeVar with AnyStr.\n\nThe AnyStr predefined type variable\n\nThe typing module includes a predefined TypeVar named AnyStr. It’s defined like this:\n\nAnyStr = TypeVar('AnyStr', bytes, str)\n\nAnyStr is used in many functions that accept either bytes or str, and return values of the given type.\n\nNow, on to typing.Protocol, a new feature of Python 3.8 that can support more Pythonic use of type hints.\n\nStatic Protocols\n\nIn object-oriented programming, the concept of a “protocol” as an informal interface is as old as Smalltalk, and is an essential part of Python from the beginning. However, in the context of type hints, a protocol is a typing.Protocol subclass defining an interface that a type checker can verify. Both kinds of protocols are covered in Chapter 13. This is just a brief introduction in the context of func‐ tion annotations.\n\nThe Protocol type, as presented in PEP 544—Protocols: Structural subtyping (static duck typing), is similar to interfaces in Go: a protocol type is defined by specifying one or more methods, and the type checker verifies that those methods are imple‐ mented where that protocol type is required.\n\nIn Python, a protocol definition is written as a typing.Protocol subclass. However, classes that implement a protocol don’t need to inherit, register, or declare any rela‐ tionship with the class that defines the protocol. It’s up to the type checker to find the available protocol types and enforce their usage.\n\nHere is a problem that can be solved with the help of Protocol and TypeVar. Suppose you want to create a function top(it, n) that returns the largest n elements of the iterable it:\n\n>>> top([4, 1, 5, 2, 6, 7, 3], 3) [7, 6, 5] >>> l = 'mango pear apple kiwi banana'.split() >>> top(l, 3) ['pear', 'mango', 'kiwi']\n\n286\n\n|\n\nChapter 8: Type Hints in Functions\n\n>>> >>> l2 = [(len(s), s) for s in l] >>> l2 [(5, 'mango'), (4, 'pear'), (5, 'apple'), (4, 'kiwi'), (6, 'banana')] >>> top(l2, 3) [(6, 'banana'), (5, 'mango'), (5, 'apple')]\n\nA parameterized generic top would look like what’s shown in Example 8-19.\n\nExample 8-19. top function with an undefined T type parameter\n\ndef top(series: Iterable[T], length: int) -> list[T]: ordered = sorted(series, reverse=True) return ordered[:length]\n\nThe problem is how to constrain T? It cannot be Any or object, because the series must work with sorted. The sorted built-in actually accepts Iterable[Any], but that’s because the optional parameter key takes a function that computes an arbitrary sort key from each element. What happens if you give sorted a list of plain objects but don’t provide a key argument? Let’s try that:\n\n>>> l = [object() for _ in range(4)] >>> l [<object object at 0x10fc2fca0>, <object object at 0x10fc2fbb0>, <object object at 0x10fc2fbc0>, <object object at 0x10fc2fbd0>] >>> sorted(l) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: '<' not supported between instances of 'object' and 'object'\n\nThe error message shows that sorted uses the < operator on the elements of the itera‐ ble. Is this all it takes? Let’s do another quick experiment:15\n\n>>> class Spam: ... def __init__(self, n): self.n = n ... def __lt__(self, other): return self.n < other.n ... def __repr__(self): return f'Spam({self.n})' ... >>> l = [Spam(n) for n in range(5, 0, -1)] >>> l [Spam(5), Spam(4), Spam(3), Spam(2), Spam(1)] >>> sorted(l) [Spam(1), Spam(2), Spam(3), Spam(4), Spam(5)]\n\nThat confirms it: I can sort a list of Spam because Spam implements __lt__—the spe‐ cial method that supports the < operator.\n\n15 How wonderful it is to open an interactive console and rely on duck typing to explore language features like I\n\njust did. I badly miss this kind of exploration when I use languages that don’t support it.\n\nTypes Usable in Annotations\n\n|\n\n287\n\nSo the T type parameter in Example 8-19 should be limited to types that implement __lt__. In Example 8-18 we needed a type parameter that implemented __hash__, so we were able to use typing.Hashable as the upper bound for the type parameter. But now there is no suitable type in typing or abc to use, so we need to create it.\n\nExample 8-20 shows the new SupportsLessThan type, a Protocol.\n\nExample 8-20. comparable.py: definition of a SupportsLessThan Protocol type\n\nfrom typing import Protocol, Any\n\nclass SupportsLessThan(Protocol): def __lt__(self, other: Any) -> bool: ...\n\nA protocol is a subclass of typing.Protocol.\n\nThe body of the protocol has one or more method definitions, with ... in their bodies.\n\nA type T is consistent-with a protocol P if T implements all the methods defined in P, with matching type signatures.\n\nGiven SupportsLessThan, we can now define this working version of top in Example 8-21.\n\nExample 8-21. top.py: definition of the top function using a TypeVar with bound=Sup portsLessThan\n\nfrom collections.abc import Iterable from typing import TypeVar\n\nfrom comparable import SupportsLessThan\n\nLT = TypeVar('LT', bound=SupportsLessThan)\n\ndef top(series: Iterable[LT], length: int) -> list[LT]: ordered = sorted(series, reverse=True) return ordered[:length]\n\nLet’s test-drive top. Example 8-22 shows part of a test suite for use with pytest. It tries calling top first with a generator expression that yields tuple[int, str], and then with a list of object. With the list of object, we expect to get a TypeError exception.\n\n288\n\n|\n\nChapter 8: Type Hints in Functions\n\nExample 8-22. top_test.py: partial listing of the test suite for top\n\nfrom collections.abc import Iterator from typing import TYPE_CHECKING\n\nimport pytest\n\nfrom top import top\n\n# several lines omitted\n\ndef test_top_tuples() -> None: fruit = 'mango pear apple kiwi banana'.split() series: Iterator[tuple[int, str]] = ( (len(s), s) for s in fruit) length = 3 expected = [(6, 'banana'), (5, 'mango'), (5, 'apple')] result = top(series, length) if TYPE_CHECKING: reveal_type(series) reveal_type(expected) reveal_type(result) assert result == expected\n\n# intentional type error def test_top_objects_error() -> None: series = [object() for _ in range(4)] if TYPE_CHECKING: reveal_type(series) with pytest.raises(TypeError) as excinfo: top(series, 3) assert \"'<' not supported\" in str(excinfo.value)\n\nThe typing.TYPE_CHECKING constant is always False at runtime, but type check‐ ers pretend it is True when they are type checking.\n\nExplicit type declaration for the series variable, to make the Mypy output easier to read.16\n\nThis if prevents the next three lines from executing when the test runs.\n\nreveal_type() cannot be called at runtime, because it is not a regular function but a Mypy debugging facility—that’s why there is no import for it. Mypy will\n\n16 Without this type hint, Mypy would infer the type of series as Generator[Tuple[builtins.int, buil\n\ntins.str*], None, None], which is verbose but consistent-with Iterator[tuple[int, str]], as we’ll see in “Generic Iterable Types” on page 639.\n\nTypes Usable in Annotations\n\n|\n\n289\n\noutput one debugging message for each reveal_type() pseudofunction call, showing the inferred type of the argument.\n\nThis line will be flagged as an error by Mypy.\n\nThe preceding tests pass—but they would pass anyway, with or without type hints in top.py. More to the point, if I check that test file with Mypy, I see that the TypeVar is working as intended. See the mypy command output in Example 8-23.\n\nAs of Mypy 0.910 (July 2021), the output of reveal_type does not show precisely the types I declared in some cases, but compatible types instead. For example, I did not use typing.Iterator but used abc.Iterator. Please ignore this detail. The Mypy output is still useful. I will pretend this issue of Mypy is fixed when discus‐ sing the output.\n\nExample 8-23. Output of mypy top_test.py (lines split for readability)\n\n…/comparable/ $ mypy top_test.py top_test.py:32: note: Revealed type is \"typing.Iterator[Tuple[builtins.int, builtins.str]]\" top_test.py:33: note: Revealed type is \"builtins.list[Tuple[builtins.int, builtins.str]]\" top_test.py:34: note: Revealed type is \"builtins.list[Tuple[builtins.int, builtins.str]]\" top_test.py:41: note: Revealed type is \"builtins.list[builtins.object*]\" top_test.py:43: error: Value of type variable \"LT\" of \"top\" cannot be \"object\" Found 1 error in 1 file (checked 1 source file)\n\nIn test_top_tuples, reveal_type(series) shows it is an Iterator[tuple[int, str]]—which I explicitly declared.\n\nreveal_type(result) confirms that the type returned by the top call is what I wanted: given the type of series, the result is list[tuple[int, str]].\n\nIn test_top_objects_error, reveal_type(series) shows it is list[object*]. Mypy puts a * after any type that was inferred: I did not annotate the type of series in this test.\n\nMypy flags the error that this test intentionally triggers: the element type of the Iterable series cannot be object (it must be of type SupportsLessThan).\n\nA key advantage of a protocol type over ABCs is that a type doesn’t need any special declaration to be consistent-with a protocol type. This allows a protocol to be created\n\n290\n\n|\n\nChapter 8: Type Hints in Functions\n\nleveraging preexisting types, or types implemented in code that we do not control. I don’t need to derive or register str, tuple, float, set, etc. with SupportsLessThan to use them where a SupportsLessThan parameter is expected. They only need to implement __lt__. And the type checker will still be able do its job, because Support sLessThan is explicitly defined as a Protocol—in contrast with the implicit protocols that are common with duck typing, which are invisible to the type checker.\n\nThe special Protocol class was introduced in PEP 544—Protocols: Structural subtyp‐ ing (static duck typing). Example 8-21 demonstrates why this feature is known as static duck typing: the solution to annotate the series parameter of top was to say “The nominal type of series doesn’t matter, as long as it implements the __lt__ method.” Python’s duck typing always allowed us to say that implicitly, leaving static type checkers clueless. A type checker can’t read CPython’s source code in C, or per‐ form console experiments to find out that sorted only requires that the elements support <.\n\nNow we can make duck typing explicit for static type checkers. That’s why it makes sense to say that typing.Protocol gives us static duck typing.17\n\nThere’s more to see about typing.Protocol. We’ll come back to it in Part IV, where Chapter 13 contrasts structural typing, duck typing, and ABCs—another approach to formalizing protocols. In addition, “Overloaded Signatures” on page 520 (Chapter 15) explains how to declare overloaded function signatures with @typing.overload, and includes an extensive example using typing.Protocol and a bounded TypeVar.\n\ntyping.Protocol makes it possible to annotate the double func‐ tion presented in “Types Are Defined by Supported Operations” on page 260 without losing functionality. The key is to define a protocol class with the __mul__ method. I invite you to do that as an exercise. The solution appears in “The Typed double Function” on page 466 (Chapter 13).\n\nCallable To annotate callback parameters or callable objects returned by higher-order func‐ tions, the collections.abc module provides the Callable type, available in the typ ing module for those not yet using Python 3.9. A Callable type is parameterized like this:\n\nCallable[[ParamType1, ParamType2], ReturnType]\n\n17 I don’t know who invented the term static duck typing, but it became more popular with the Go language, which has interface semantics that are more like Python’s protocols than the nominal interfaces of Java.\n\nTypes Usable in Annotations\n\n|\n\n291\n\nThe parameter list—[ParamType1, ParamType2]—can have zero or more types.\n\nHere is an example in the context of a repl function, part of a simple interactive interpreter we’ll see in “Pattern Matching in lis.py: A Case Study” on page 669:18\n\ndef repl(input_fn: Callable[[Any], str] = input]) -> None:\n\nDuring normal usage, the repl function uses Python’s input built-in to read expres‐ sions from the user. However, for automated testing or for integration with other input sources, repl accepts an optional input_fn parameter: a Callable with the same parameter and return types as input.\n\nThe built-in input has this signature on typeshed:\n\ndef input(__prompt: Any = ...) -> str: ...\n\nThe input signature is consistent-with this Callable type hint:\n\nCallable[[Any], str]\n\nThere is no syntax to annotate optional or keyword argument types. The documenta‐ tion of typing.Callable says “such function types are rarely used as callback types.” If you need a type hint to match a function with a flexible signature, replace the whole parameter list with ...—like this:\n\nCallable[..., ReturnType]\n\nThe interaction of generic type parameters with a type hierarchy introduces a new typing concept: variance.\n\nVariance in Callable types\n\nImagine a temperature control system with a simple update function as shown in Example 8-24. The update function calls the probe function to get the current tem‐ perature, and calls display to show the temperature to the user. Both probe and dis play are passed as arguments to update for didactic reasons. The goal of the example is to contrast two Callable annotations: one with a return type, the other with a parameter type.\n\nExample 8-24. Illustrating variance.\n\nfrom collections.abc import Callable\n\ndef update( probe: Callable[[], float], display: Callable[[float], None]\n\n18 REPL stands for Read-Eval-Print-Loop, the basic behavior of interactive interpreters.\n\n292\n\n|\n\nChapter 8: Type Hints in Functions\n\n) -> None: temperature = probe() # imagine lots of control code here display(temperature)\n\ndef probe_ok() -> int: return 42\n\ndef display_wrong(temperature: int) -> None: print(hex(temperature))\n\nupdate(probe_ok, display_wrong) # type error\n\ndef display_ok(temperature: complex) -> None: print(temperature)\n\nupdate(probe_ok, display_ok) # OK\n\nupdate takes two callables as arguments.\n\nprobe must be a callable that takes no arguments and returns a float.\n\ndisplay takes a float argument and returns None.\n\nprobe_ok is consistent-with Callable[[], float] because returning an int does not break code that expects a float.\n\ndisplay_wrong is not consistent-with Callable[[float], None] because there’s no guarantee that a function that expects an int can handle a float; for example, Python’s hex function accepts an int but rejects a float.\n\nMypy flags this line because display_wrong is incompatible with the type hint in the display parameter of update.\n\ndisplay_ok is consistent-with Callable[[float], None] because a function that accepts a complex can also handle a float argument.\n\nMypy is happy with this line.\n\nTo summarize, it’s OK to provide a callback that returns an int when the code expects a callback that returns a float, because an int value can always be used where a float is expected.\n\nFormally, we say that Callable[[], int] is subtype-of Callable[[], float]—as int is subtype-of float. This means that Callable is covariant on the return type\n\nTypes Usable in Annotations\n\n|\n\n293\n\nbecause the subtype-of relationship of the types int and float is in the same direc‐ tion as the relationship of the Callable types that use them as return types.\n\nOn the other hand, it’s a type error to provide a callback that takes a int argument when a callback that handles a float is required.\n\nFormally, Callable[[int], None] is not a subtype-of Callable[[float], None]. Although int is subtype-of float, in the parameterized Callable type the relation‐ ship is reversed: Callable[[float], None] is subtype-of Callable[[int], None]. Therefore we say that Callable is contravariant on the declared parameter types.\n\n“Variance” on page 544 in Chapter 15 explains variance with more details and examples of invariant, covariant, and contravariant types.\n\nFor now, rest assured that most parameterized generic types are invariant, therefore simpler. For example, if I declare scores: list[float], that tells me exactly what I can assign to scores. I can’t assign objects declared as list[int] or list[complex]:\n\nA list[int] object is not acceptable because it cannot hold float values which my code may need to put into scores. • A list[complex] object is not acceptable because my code may need to sort scores to find the median, but complex does not provide __lt__, therefore list[complex] is not sortable.\n\nNow we get to the last special type we’ll cover in this chapter.\n\nNoReturn This is a special type used only to annotate the return type of functions that never return. Usually, they exist to raise exceptions. There are dozens of such functions in the standard library.\n\nFor example, sys.exit() raises SystemExit to terminate the Python process.\n\nIts signature in typeshed is:\n\ndef exit(__status: object = ...) -> NoReturn: ...\n\nThe __status parameter is positional only, and it has a default value. Stub files don’t spell out the default values, they use ... instead. The type of __status is object, which means it may also be None, therefore it would be redundant to mark it Optional[object].\n\n294\n\n|\n\nChapter 8: Type Hints in Functions\n\nIn Chapter 24, Example 24-6 uses NoReturn in the __flag_unknown_attrs, a method designed to produce a user-friendly and comprehensive error message, and then raise AttributeError.\n\nThe last section in this epic chapter is about positional and variadic parameters.\n\nAnnotating Positional Only and Variadic Parameters Recall the tag function from Example 7-9. The last time we saw its signature was in “Positional-Only Parameters” on page 242:\n\ndef tag(name, /, *content, class_=None, **attrs):\n\nHere is tag, fully annotated, written in several lines—a common convention for long signatures, with line breaks the way the blue formatter would do it:\n\nfrom typing import Optional\n\ndef tag( name: str, /, *content: str, class_: Optional[str] = None, **attrs: str, ) -> str:\n\nNote the type hint *content: str for the arbitrary positional parameters; this means all those arguments must be of type str. The type of the content local variable in the function body will be tuple[str, ...].\n\nThe type hint for the arbitrary keyword arguments is **attrs: str in this example, therefore the type of attrs inside the function will be dict[str, str]. For a type hint like **attrs: float, the type of attrs in the function would be dict[str, float].``\n\nIf the attrs parameter must accept values of different types, you’ll need to use a Union[] or Any: **attrs: Any.\n\nThe / notation for positional-only parameters is only available in Python ≥ 3.8. In Python 3.7 or earlier, that’s a syntax error. The PEP 484 convention is to prefix each positional-only parameter name with two underscores. Here is the tag signature again, now in two lines, using the PEP 484 convention:\n\nfrom typing import Optional\n\ndef tag(__name: str, *content: str, class_: Optional[str] = None, **attrs: str) -> str:\n\nMypy understands and enforces both ways of declaring positional-only parameters.\n\nAnnotating Positional Only and Variadic Parameters\n\n|\n\n295\n\nTo close this chapter, let’s briefly consider the limits of type hints and the static type system they support.\n\nImperfect Typing and Strong Testing Maintainers of large corporate codebases report that many bugs are found by static type checkers and fixed more cheaply than if the bugs were discovered only after the code is running in production. However, it’s essential to note that automated testing was standard practice and widely adopted long before static typing was introduced in the companies that I know about.\n\nEven in the contexts where they are most beneficial, static typing cannot be trusted as the ultimate arbiter of correctness. It’s not hard to find:\n\nFalse positives\n\nTools report type errors on code that is correct.\n\nFalse negatives\n\nTools don’t report type errors on code that is incorrect.\n\nAlso, if we are forced to type check everything, we lose some of the expressive power of Python:\n\nSome handy features can’t be statically checked; for example, argument unpack‐ ing like config(**settings).\n\nAdvanced features like properties, descriptors, metaclasses, and metaprogram‐ ming in general are poorly supported or beyond comprehension for type checkers.\n\nType checkers lag behind Python releases, rejecting or even crashing while ana‐ lyzing code with new language features—for more than a year in some cases.\n\nCommon data constraints cannot be expressed in the type system—even simple ones. For example, type hints are unable to ensure “quantity must be an integer > 0” or “label must be a string with 6 to 12 ASCII letters.” In general, type hints are not help‐ ful to catch errors in business logic.\n\nGiven those caveats, type hints cannot be the mainstay of software quality, and mak‐ ing them mandatory without exception would amplify the downsides.\n\nConsider a static type checker as one of the tools in a modern CI pipeline, along with test runners, linters, etc. The point of a CI pipeline is to reduce software failures, and automated tests catch many bugs that are beyond the reach of type hints. Any code you can write in Python, you can test in Python—with or without type hints.\n\n296\n\n|\n\nChapter 8: Type Hints in Functions\n\nThe title and conclusion of this section were inspired by Bruce Eckel’s article “Strong Typing vs. Strong Testing”, also published in the anthology The Best Software Writing I, edited by Joel Spolsky (Apress). Bruce is a fan of Python and author of books about C++, Java, Scala, and Kotlin. In that post, he tells how he was a static typ‐ ing advocate until he learned Python and concluded: “If a Python program has adequate unit tests, it can be as robust as a C++, Java, or C# program with adequate unit tests (although the tests in Python will be faster to write).”\n\nThis wraps up our coverage of Python’s type hints for now. They are also the main focus of Chapter 15, which covers generic classes, variance, overloaded signatures, type casting, and more. Meanwhile, type hints will make guest appearances in several examples throughout the book.\n\nChapter Summary We started with a brief introduction to the concept of gradual typing and then switched to a hands-on approach. It’s hard to see how gradual typing works without a tool that actually reads the type hints, so we developed an annotated function guided by Mypy error reports.\n\nBack to the idea of gradual typing, we explored how it is a hybrid of Python’s tradi‐ tional duck typing and the nominal typing more familiar to users of Java, C++, and other statically typed languages.\n\nMost of the chapter was devoted to presenting the major groups of types used in annotations. Many of the types we covered are related to familiar Python object types, such as collections, tuples, and callables—extended to support generic notation like Sequence[float]. Many of those types are temporary surrogates implemented in the typing module before the standard types were changed to support generics in Python 3.9.\n\nSome of the types are special entities. Any, Optional, Union, and NoReturn have noth‐ ing to do with actual objects in memory, but exist only in the abstract domain of the type system.\n\nWe studied parameterized generics and type variables, which bring more flexibility to type hints without sacrificing type safety.\n\nParameterized generics become even more expressive with the use of Protocol. Because it appeared only in Python 3.8, Protocol is not widely used yet—but it is hugely important. Protocol enables static duck typing: the essential bridge between Python’s duck-typed core and the nominal typing that allows static type checkers to catch bugs.\n\nChapter Summary\n\n|\n\n297\n\nWhile covering some of these types, we experimented with Mypy to see type checking errors and inferred types with the help of Mypy’s magic reveal_type() function.\n\nThe final section covered how to annotate positional-only and variadic parameters.\n\nType hints are a complex and evolving topic. Fortunately, they are an optional feature. Let us keep Python accessible to the widest user base and stop preaching that all Python code should have type hints—as I’ve seen in public sermons by typing evangelists.\n\nOur BDFL19 emeritus led this push toward type hints in Python, so it’s only fair that this chapter starts and ends with his words:\n\nI wouldn’t like a version of Python where I was morally obligated to add type hints all the time. I really do think that type hints have their place but there are also plenty of times that it’s not worth it, and it’s so wonderful that you can choose to use them.20\n\n—Guido van Rossum\n\nFurther Reading Bernát Gábor wrote in his excellent post, “The state of type hints in Python”:\n\nType hints should be used whenever unit tests are worth writing.\n\nI am a big fan of testing, but I also do a lot of exploratory coding. When I am explor‐ ing, tests and type hints are not helpful. They are a drag.\n\nGábor’s post is one of the best introductions to Python’s type hints that I found, along with Geir Arne Hjelle’s “Python Type Checking (Guide)”. “Hypermodern Python Chapter 4: Typing” by Claudio Jolowicz is a shorter introduction that also covers runtime type checking validation.\n\nFor deeper coverage, the Mypy documentation is the best source. It is valuable regardless of the type checker you are using, because it has tutorial and reference pages about Python typing in general—not just about the Mypy tool itself. There you will also find a handy cheat sheets and a very useful page about common issues and solutions.\n\nThe typing module documentation is a good quick reference, but it doesn’t go into much detail. PEP 483—The Theory of Type Hints includes a deep explanation about variance, using Callable to illustrate contravariance. The ultimate references are the PEP documents related to typing. There are more than 20 of them already. The\n\n19 “Benevolent Dictator For Life.” See Guido van van Rossum on the “Origin of BDFL”.\n\n20 From the YouTube video, “Type Hints by Guido van Rossum (March 2015)”. Quote starts at 13’40”. I did\n\nsome light editing for clarity.\n\n298\n\n|\n\nChapter 8: Type Hints in Functions\n\nintended audience of PEPs are Python core developers and Python’s Steering Coun‐ cil, so they assume a lot of prior knowledge and are certainly not light reading.\n\nAs mentioned, Chapter 15 covers more typing topics, and “Further Reading” on page 555 provides additional references, including Table 15-1, listing typing PEPs approved or under discussion as of late 2021.\n\n“Awesome Python Typing” is a valuable collection of links to tools and references.\n\nSoapbox\n\nJust Ride\n\nForget the ultralight, uncomfortable bikes, flashy jerseys, clunky shoes that clip onto tiny pedals, the grinding out of endless miles. Instead, ride like you did when you were a kid—just get on your bike and discover the pure joy of riding it.\n\n—Grant Petersen, Just Ride: A Radically Practical Guide to Riding Your Bike (Workman Publishing)\n\nIf coding is not your whole profession, but a useful tool in your profession, or some‐ thing you do to learn, tinker, and enjoy, you probably don’t need type hints any more than most bikers need shoes with stiff soles and metal cleats.\n\nJust code.\n\nThe Cognitive Effect of Typing\n\nI worry about the effect type hints will have on Python coding style.\n\nI agree that users of most APIs benefit from type hints. But Python attracted me— among other reasons—because it provides functions that are so powerful that they replace entire APIs, and we can write similarly powerful functions ourselves. Con‐ sider the max() built-in. It’s powerful, yet easy to understand. But I will show in “Max Overload” on page 521 that it takes 14 lines of type hints to properly annotate it—not counting a typing.Protocol and a few TypeVar definitions to support those type hints.\n\nI am concerned that strict enforcement of type hints in libraries will discourage pro‐ grammers from even considering writing such functions in the future.\n\nAccording to the English Wikipedia, “linguistic relativity”—a.k.a. the Sapir–Whorf hypothesis— is a “principle claiming that the structure of a language affects its speak‐ ers’ world view or cognition.” Wikipedia further explains:\n\nThe strong version says that language determines thought and that linguistic cate‐ gories limit and determine cognitive categories.\n\nFurther Reading\n\n|\n\n299\n\nThe weak version says that linguistic categories and usage only influence thought and decisions.\n\nLinguists generally agree the strong version is false, but there is empirical evidence supporting the weak version.\n\nI am not aware of specific studies with programming languages, but in my experience they’ve had a big impact on how I approach problems. The first programming lan‐ guage I used professionally was Applesoft BASIC in the age of 8-bit computers. Recursion was not directly supported by BASIC—you had to roll your own call stack to use it. So I never considered using recursive algorithms or data structures. I knew at some conceptual level such things existed, but they weren’t part of my problem- solving toolbox.\n\nDecades later when I started with Elixir, I enjoyed solving problems with recursion and overused it—until I discovered that many of my solutions would be simpler if I used existing functions from the Elixir Enum and Stream modules. I learned that idiomatic Elixir application-level code rarely has explicit recursive calls, but uses enums and streams that implement recursion under the hood.\n\nLinguistic relativity could explain the widespread idea (also unproven) that learning different programming languages makes you a better programmer, particularly when the languages support different programming paradigms. Practicing Elixir made me more likely to apply functional patterns when I write Python or Go code.\n\nNow, back to Earth.\n\nThe requests package would probably have a very different API if Kenneth Reitz was determined (or told by his boss) to annotate all its functions. His goal was to write an API that was easy to use, flexible, and powerful. He succeeded, given the amazing popularity of requests—in May 2020, it’s #4 on PyPI Stats, with 2.6 million down‐ loads a day. #1 is urllib3, a dependency of requests.\n\nIn 2017, the requests maintainers decided not to spend their time writing type hints. One of the maintainers, Cory Benfield, had written an e-mail stating:\n\nI think that libraries with Pythonic APIs are the least likely to take up this typing sys‐ tem because it will provide the least value to them.\n\nIn that message, Benfield gave this extreme example of a tentative type definition for the files keyword argument of requests.request():\n\nOptional[ Union[ Mapping[ basestring, Union[ Tuple[basestring, Optional[Union[basestring, file]]], Tuple[basestring, Optional[Union[basestring, file]], Optional[basestring]],\n\n300\n\n|\n\nChapter 8: Type Hints in Functions\n\nTuple[basestring, Optional[Union[basestring, file]], Optional[basestring], Optional[Headers]] ] ], Iterable[ Tuple[ basestring, Union[ Tuple[basestring, Optional[Union[basestring, file]]], Tuple[basestring, Optional[Union[basestring, file]], Optional[basestring]], Tuple[basestring, Optional[Union[basestring, file]], Optional[basestring], Optional[Headers]] ] ] ] ]\n\nAnd that assumes this definition:\n\nHeaders = Union[ Mapping[basestring, basestring], Iterable[Tuple[basestring, basestring]], ]\n\nDo you think requests would be the way it is if the maintainers insisted on 100% type hint coverage? SQLAlchemy is another important package that doesn’t play well with type hints.\n\nWhat makes these libraries great is embracing the dynamic nature of Python.\n\nWhile there are benefits to type hints, there is also a price to pay.\n\nFirst, there is the significant investment of understanding how the type system works. That’s a one-time cost.\n\nBut there is also a recurring cost, forever.\n\nWe lose some of the expressive power of Python if we insist on type checking every‐ thing. Beautiful features like argument unpacking—e.g., config(**settings)—are beyond comprehension for type checkers.\n\nIf you want to have a call like config(**settings) type checked, you must spell every argument out. That brings me memories of Turbo Pascal code I wrote 35 years ago.\n\nLibraries that use metaprogramming are hard or impossible to annotate. Surely meta‐ programming can be abused, but it’s also what makes many Python packages a joy to use.\n\nIf type hints are mandated top-down without exceptions in large companies, I bet soon we’ll see people using code generation to reduce boilerplate in Python source- code—a common practice with less dynamic languages.\n\nFurther Reading\n\n|\n\n301\n\nFor some projects and contexts, type hints just don’t make sense. Even in contexts where they mostly make sense, they don’t make sense all the time. Any reasonable policy about the use of type hints must have exceptions.\n\nAlan Kay, the Turing Award laureate who pioneered object-oriented programming, once said:\n\nSome people are completely religious about type systems and as a mathematician I love the idea of type systems, but nobody has ever come up with one that has enough scope.21\n\nThank Guido for optional typing. Let’s use it as intended, and not aim to annotate everything into strict conformity to a coding style that looks like Java 1.5.\n\nDuck Typing FTW\n\nDuck typing fits my brain, and static duck typing is a good compromise allowing static type checking without losing a lot of flexibility that some nominal type systems only provide with a lot of complexity—if ever.\n\nBefore PEP 544, this whole idea of type hints seemed utterly unPythonic to me. I was very glad to see typing.Protocol land in Python. It brings balance to the force.\n\nGenerics or Specifics?\n\nFrom a Python perspective, the typing usage of the term “generic” is backward. Com‐ mon meanings of “generic” are “applicable to an entire class or group” or “without a brand name.”\n\nConsider list versus list[str]. The first is generic: it accepts any object. The sec‐ ond is specific: it only accepts str.\n\nThe term makes sense in Java, though. Before Java 1.5, all Java collections (except the magic array) were “specific”: they could only hold Object references, so we had to cast the items that came out of a collection to use them. With Java 1.5, collections got type parameters, and became “generic.”\n\n21 Source: “A Conversation with Alan Kay”.\n\n302\n\n|\n\nChapter 8: Type Hints in Functions\n\nCHAPTER 9 Decorators and Closures\n\nThere’s been a number of complaints about the choice of the name “decorator” for this feature. The major one is that the name is not consistent with its use in the GoF book.1 The name decorator probably owes more to its use in the compiler area—a syntax tree is walked and annotated.\n\n—PEP 318—Decorators for Functions and Methods\n\nFunction decorators let us “mark” functions in the source code to enhance their behavior in some way. This is powerful stuff, but mastering it requires understanding closures—which is what we get when functions capture variables defined outside of their bodies.\n\nThe most obscure reserved keyword in Python is nonlocal, introduced in Python 3.0. You can have a profitable life as a Python programmer without ever using it if you adhere to a strict regimen of class-centered object orientation. However, if you want to implement your own function decorators, you must understand closures, and then the need for nonlocal becomes obvious.\n\nAside from their application in decorators, closures are also essential for any type of programming using callbacks, and for coding in a functional style when it makes sense.\n\nThe end goal of this chapter is to explain exactly how function decorators work, from the simplest registration decorators to the rather more complicated parameterized ones. However, before we reach that goal we need to cover:\n\n1 That’s the 1995 Design Patterns book by the so-called Gang of Four (Gamma et al., Addison-Wesley).\n\n303\n\nHow Python evaluates decorator syntax\n\nHow Python decides whether a variable is local\n\nWhy closures exist and how they work • What problem is solved by nonlocal\n\nWith this grounding, we can tackle further decorator topics:\n\nImplementing a well-behaved decorator • Powerful decorators in the standard library: @cache, @lru_cache, and @single dispatch\n\nImplementing a parameterized decorator\n\nWhat’s New in This Chapter The caching decorator functools.cache—new in Python 3.9—is simpler than the traditional functools.lru_cache, so I present it first. The latter is covered in “Using lru_cache” on page 323, including the simplified form added in Python 3.8.\n\n“Single Dispatch Generic Functions” on page 324 was expanded and now uses type hints, the preferred way to use functools.singledispatch since Python 3.7.\n\n“Parameterized Decorators” on page 329 now includes a class-based example, Example 9-27.\n\nI moved Chapter 10, “Design Patterns with First-Class Functions” to the end of Part II to improve the flow of the book. “Decorator-Enhanced Strategy Pattern” on page 353 is now in that chapter, along with other variations of the Strategy design pat‐ tern using callables.\n\nWe start with a very gentle introduction to decorators, and then proceed with the rest of the items listed in the chapter opening.\n\nDecorators 101 A decorator is a callable that takes another function as an argument (the decorated function).\n\nA decorator may perform some processing with the decorated function, and returns it or replaces it with another function or callable object.2\n\n2 If you replace “function” with “class” in the previous sentence, you have a brief description of what a class\n\ndecorator does. Class decorators are covered in Chapter 24.\n\n304\n\n|\n\nChapter 9: Decorators and Closures",
      "page_number": 305
    },
    {
      "number": 17,
      "title": "Segment 17 (pages 327-347)",
      "start_page": 327,
      "end_page": 347,
      "detection_method": "synthetic",
      "content": "In other words, assuming an existing decorator named decorate, this code:\n\n@decorate def target(): print('running target()')\n\nhas the same effect as writing this:\n\ndef target(): print('running target()')\n\ntarget = decorate(target)\n\nThe end result is the same: at the end of either of these snippets, the target name is bound to whatever function is returned by decorate(target)—which may be the function initially named target, or may be a different function.\n\nTo confirm that the decorated function is replaced, see the console session in Example 9-1.\n\nExample 9-1. A decorator usually replaces a function with a different one\n\n>>> def deco(func): ... def inner(): ... print('running inner()') ... return inner ... >>> @deco ... def target(): ... print('running target()') ... >>> target() running inner() >>> target <function deco.<locals>.inner at 0x10063b598>\n\ndeco returns its inner function object.\n\ntarget is decorated by deco.\n\nInvoking the decorated target actually runs inner.\n\nInspection reveals that target is a now a reference to inner.\n\nStrictly speaking, decorators are just syntactic sugar. As we just saw, you can always simply call a decorator like any regular callable, passing another function. Sometimes that is actually convenient, especially when doing metaprogramming—changing pro‐ gram behavior at runtime.\n\nDecorators 101\n\n|\n\n305\n\nThree essential facts make a good summary of decorators:\n\nA decorator is a function or another callable.\n\nA decorator may replace the decorated function with a different one.\n\nDecorators are executed immediately when a module is loaded.\n\nNow let’s focus on the third point.\n\nWhen Python Executes Decorators A key feature of decorators is that they run right after the decorated function is defined. That is usually at import time (i.e., when a module is loaded by Python). Consider registration.py in Example 9-2.\n\nExample 9-2. The registration.py module\n\nregistry = []\n\ndef register(func): print(f'running register({func})') registry.append(func) return func\n\n@register def f1(): print('running f1()')\n\n@register def f2(): print('running f2()')\n\ndef f3(): print('running f3()')\n\ndef main(): print('running main()') print('registry ->', registry) f1() f2() f3()\n\nif __name__ == '__main__': main()\n\nregistry will hold references to functions decorated by @register.\n\nregister takes a function as an argument.\n\n306\n\n|\n\nChapter 9: Decorators and Closures\n\nDisplay what function is being decorated, for demonstration.\n\nInclude func in registry.\n\nReturn func: we must return a function; here we return the same received as argument.\n\nf1 and f2 are decorated by @register.\n\nf3 is not decorated.\n\nmain displays the registry, then calls f1(), f2(), and f3().\n\nmain() is only invoked if registration.py runs as a script.\n\nThe output of running registration.py as a script looks like this:\n\n$ python3 registration.py running register(<function f1 at 0x100631bf8>) running register(<function f2 at 0x100631c80>) running main() registry -> [<function f1 at 0x100631bf8>, <function f2 at 0x100631c80>] running f1() running f2() running f3()\n\nNote that register runs (twice) before any other function in the module. When reg ister is called, it receives the decorated function object as an argument—for exam‐ ple, <function f1 at 0x100631bf8>.\n\nAfter the module is loaded, the registry list holds references to the two decorated functions: f1 and f2. These functions, as well as f3, are only executed when explicitly called by main.\n\nIf registration.py is imported (and not run as a script), the output is this:\n\n>>> import registration running register(<function f1 at 0x10063b1e0>) running register(<function f2 at 0x10063b268>)\n\nAt this time, if you inspect registry, this is what you see:\n\n>>> registration.registry [<function f1 at 0x10063b1e0>, <function f2 at 0x10063b268>]\n\nThe main point of Example 9-2 is to emphasize that function decorators are executed as soon as the module is imported, but the decorated functions only run when they are explicitly invoked. This highlights the difference between what Pythonistas call import time and runtime.\n\nWhen Python Executes Decorators\n\n|\n\n307\n\nRegistration Decorators Considering how decorators are commonly employed in real code, Example 9-2 is unusual in two ways:\n\nThe decorator function is defined in the same module as the decorated functions. A real decorator is usually defined in one module and applied to functions in other modules.\n\nThe register decorator returns the same function passed as an argument. In practice, most decorators define an inner function and return it.\n\nEven though the register decorator in Example 9-2 returns the decorated function unchanged, that technique is not useless. Similar decorators are used in many Python frameworks to add functions to some central registry—for example, a registry map‐ ping URL patterns to functions that generate HTTP responses. Such registration dec‐ orators may or may not change the decorated function.\n\nWe will see a registration decorator applied in “Decorator-Enhanced Strategy Pat‐ tern” on page 353 (Chapter 10).\n\nMost decorators do change the decorated function. They usually do it by defining an inner function and returning it to replace the decorated function. Code that uses inner functions almost always depends on closures to operate correctly. To under‐ stand closures, we need to take a step back and review how variable scopes work in Python.\n\nVariable Scope Rules In Example 9-3, we define and test a function that reads two variables: a local variable a—defined as function parameter—and variable b that is not defined anywhere in the function.\n\nExample 9-3. Function reading a local and a global variable\n\n>>> def f1(a): ... print(a) ... print(b) ... >>> f1(3) 3 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"<stdin>\", line 3, in f1 NameError: global name 'b' is not defined\n\n308\n\n|\n\nChapter 9: Decorators and Closures\n\nThe error we got is not surprising. Continuing from Example 9-3, if we assign a value to a global b and then call f1, it works:\n\n>>> b = 6 >>> f1(3) 3 6\n\nNow, let’s see an example that may surprise you.\n\nTake a look at the f2 function in Example 9-4. Its first two lines are the same as f1 in Example 9-3, then it makes an assignment to b. But it fails at the second print, before the assignment is made.\n\nExample 9-4. Variable b is local, because it is assigned a value in the body of the function\n\n>>> b = 6 >>> def f2(a): ... print(a) ... print(b) ... b = 9 ... >>> f2(3) 3 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"<stdin>\", line 3, in f2 UnboundLocalError: local variable 'b' referenced before assignment\n\nNote that the output starts with 3, which proves that the print(a) statement was exe‐ cuted. But the second one, print(b), never runs. When I first saw this I was sur‐ prised, thinking that 6 should be printed, because there is a global variable b and the assignment to the local b is made after print(b).\n\nBut the fact is, when Python compiles the body of the function, it decides that b is a local variable because it is assigned within the function. The generated bytecode reflects this decision and will try to fetch b from the local scope. Later, when the call f2(3) is made, the body of f2 fetches and prints the value of the local variable a, but when trying to fetch the value of local variable b, it discovers that b is unbound.\n\nThis is not a bug, but a design choice: Python does not require you to declare vari‐ ables, but assumes that a variable assigned in the body of a function is local. This is much better than the behavior of JavaScript, which does not require variable declara‐ tions either, but if you do forget to declare that a variable is local (with var), you may clobber a global variable without knowing.\n\nVariable Scope Rules\n\n|\n\n309\n\nIf we want the interpreter to treat b as a global variable and still assign a new value to it within the function, we use the global declaration:\n\n>>> b = 6 >>> def f3(a): ... global b ... print(a) ... print(b) ... b = 9 ... >>> f3(3) 3 6 >>> b 9\n\nIn the preceding examples, we can see two scopes in action:\n\nThe module global scope\n\nMade of names assigned to values outside of any class or function block.\n\nThe f3 function local scope\n\nMade of names assigned to values as parameters, or directly in the body of the function.\n\nThere is one other scope where variables can come from, which we call nonlocal and is fundamental for closures; we’ll see it in a bit.\n\nAfter this closer look at how variable scopes work in Python, we can tackle closures in the next section, “Closures” on page 311. If you are curious about the bytecode differ‐ ences between the functions in Examples 9-3 and 9-4, see the following sidebar.\n\nComparing Bytecodes The dis module provides an easy way to disassemble the bytecode of Python func‐ tions. Read Examples 9-5 and 9-6 to see the bytecodes for f1 and f2 from Examples 9-3 and 9-4.\n\nExample 9-5. Disassembly of the f1 function from Example 9-3\n\n>>> from dis import dis >>> dis(f1) 2 0 LOAD_GLOBAL 0 (print) 3 LOAD_FAST 0 (a) 6 CALL_FUNCTION 1 (1 positional, 0 keyword pair) 9 POP_TOP\n\n3 10 LOAD_GLOBAL 0 (print) 13 LOAD_GLOBAL 1 (b) 16 CALL_FUNCTION 1 (1 positional, 0 keyword pair)\n\n310\n\n|\n\nChapter 9: Decorators and Closures\n\n19 POP_TOP 20 LOAD_CONST 0 (None) 23 RETURN_VALUE\n\nLoad global name print.\n\nLoad local name a.\n\nLoad global name b.\n\nContrast the bytecode for f1 shown in Example 9-5 with the bytecode for f2 in Example 9-6.\n\nExample 9-6. Disassembly of the f2 function from Example 9-4\n\n>>> dis(f2) 2 0 LOAD_GLOBAL 0 (print) 3 LOAD_FAST 0 (a) 6 CALL_FUNCTION 1 (1 positional, 0 keyword pair) 9 POP_TOP\n\n3 10 LOAD_GLOBAL 0 (print) 13 LOAD_FAST 1 (b) 16 CALL_FUNCTION 1 (1 positional, 0 keyword pair) 19 POP_TOP\n\n4 20 LOAD_CONST 1 (9) 23 STORE_FAST 1 (b) 26 LOAD_CONST 0 (None) 29 RETURN_VALUE\n\nLoad local name b. This shows that the compiler considers b a local variable, even if the assignment to b occurs later, because the nature of the variable—whether it is local or not—cannot change in the body of the function.\n\nThe CPython virtual machine (VM) that runs the bytecode is a stack machine, so LOAD and POP operations refer to the stack. It is beyond the scope of this book to fur‐ ther describe the Python opcodes, but they are documented along with the dis mod‐ ule in “dis—Disassembler for Python bytecode”.\n\nClosures In the blogosphere, closures are sometimes confused with anonymous functions. Many confuse them because of the parallel history of those features: defining func‐ tions inside functions is not so common or convenient, until you have anonymous functions. And closures only matter when you have nested functions. So a lot of peo‐ ple learn both concepts at the same time.\n\nClosures\n\n|\n\n311\n\nActually, a closure is a function—let’s call it f—with an extended scope that encom‐ passes variables referenced in the body of f that are not global variables or local vari‐ ables of f. Such variables must come from the local scope of an outer function that encompasses f.\n\nIt does not matter whether the function is anonymous or not; what matters is that it can access nonglobal variables that are defined outside of its body.\n\nThis is a challenging concept to grasp, and is better approached through an example.\n\nConsider an avg function to compute the mean of an ever-growing series of values; for example, the average closing price of a commodity over its entire history. Every day a new price is added, and the average is computed taking into account all prices so far.\n\nStarting with a clean slate, this is how avg could be used:\n\n>>> avg(10) 10.0 >>> avg(11) 10.5 >>> avg(12) 11.0\n\nWhere does avg come from, and where does it keep the history of previous values?\n\nFor starters, Example 9-7 is a class-based implementation.\n\nExample 9-7. average_oo.py: a class to calculate a running average\n\nclass Averager():\n\ndef __init__(self): self.series = []\n\ndef __call__(self, new_value): self.series.append(new_value) total = sum(self.series) return total / len(self.series)\n\nThe Averager class creates instances that are callable:\n\n>>> avg = Averager() >>> avg(10) 10.0 >>> avg(11) 10.5 >>> avg(12) 11.0\n\n312\n\n|\n\nChapter 9: Decorators and Closures\n\nNow, Example 9-8 is a functional implementation, using the higher-order function make_averager.\n\nExample 9-8. average.py: a higher-order function to calculate a running average\n\ndef make_averager(): series = []\n\ndef averager(new_value): series.append(new_value) total = sum(series) return total / len(series)\n\nreturn averager\n\nWhen invoked, make_averager returns an averager function object. Each time an averager is called, it appends the passed argument to the series, and computes the current average, as shown in Example 9-9.\n\nExample 9-9. Testing Example 9-8\n\n>>> avg = make_averager() >>> avg(10) 10.0 >>> avg(11) 10.5 >>> avg(15) 12.0\n\nNote the similarities of the examples: we call Averager() or make_averager() to get a callable object avg that will update the historical series and calculate the current mean. In Example 9-7, avg is an instance of Averager, and in Example 9-8, it is the inner function, averager. Either way, we just call avg(n) to include n in the series and get the updated mean.\n\nIt’s obvious where the avg of the Averager class keeps the history: the self.series instance attribute. But where does the avg function in the second example find the series?\n\nNote that series is a local variable of make_averager because the assignment series = [] happens in the body of that function. But when avg(10) is called, make_averager has already returned, and its local scope is long gone.\n\nWithin averager, series is a free variable. This is a technical term meaning a vari‐ able that is not bound in the local scope. See Figure 9-1.\n\nClosures\n\n|\n\n313\n\nFigure 9-1. The closure for averager extends the scope of that function to include the binding for the free variable series.\n\nInspecting the returned averager object shows how Python keeps the names of local and free variables in the __code__ attribute that represents the compiled body of the function. Example 9-10 demonstrates.\n\nExample 9-10. Inspecting the function created by make_averager in Example 9-8\n\n>>> avg.__code__.co_varnames ('new_value', 'total') >>> avg.__code__.co_freevars ('series',)\n\nThe value for series is kept in the __closure__ attribute of the returned function avg. Each item in avg.__closure__ corresponds to a name in avg. __code__ .co_freevars. These items are cells, and they have an attribute called cell_con tents where the actual value can be found. Example 9-11 shows these attributes.\n\nExample 9-11. Continuing from Example 9-9\n\n>>> avg.__code__.co_freevars ('series',) >>> avg.__closure__ (<cell at 0x107a44f78: list object at 0x107a91a48>,) >>> avg.__closure__[0].cell_contents [10, 11, 12]\n\nTo summarize: a closure is a function that retains the bindings of the free variables that exist when the function is defined, so that they can be used later when the func‐ tion is invoked and the defining scope is no longer available.\n\nNote that the only situation in which a function may need to deal with external vari‐ ables that are nonglobal is when it is nested in another function and those variables are part of the local scope of the outer function.\n\n314\n\n|\n\nChapter 9: Decorators and Closures\n\nThe nonlocal Declaration Our previous implementation of make_averager was not efficient. In Example 9-8, we stored all the values in the historical series and computed their sum every time averager was called. A better implementation would only store the total and the number of items so far, and compute the mean from these two numbers.\n\nExample 9-12 is a broken implementation, just to make a point. Can you see where it breaks?\n\nExample 9-12. A broken higher-order function to calculate a running average without keeping all history\n\ndef make_averager(): count = 0 total = 0\n\ndef averager(new_value): count += 1 total += new_value return total / count\n\nreturn averager\n\nIf you try Example 9-12, here is what you get:\n\n>>> avg = make_averager() >>> avg(10) Traceback (most recent call last): ... UnboundLocalError: local variable 'count' referenced before assignment >>>\n\nThe problem is that the statement count += 1 actually means the same as count = count + 1, when count is a number or any immutable type. So we are actually assigning to count in the body of averager, and that makes it a local variable. The same problem affects the total variable.\n\nWe did not have this problem in Example 9-8 because we never assigned to the ser ies name; we only called series.append and invoked sum and len on it. So we took advantage of the fact that lists are mutable.\n\nBut with immutable types like numbers, strings, tuples, etc., all you can do is read, never update. If you try to rebind them, as in count = count + 1, then you are implicitly creating a local variable count. It is no longer a free variable, and therefore it is not saved in the closure.\n\nThe nonlocal Declaration\n\n|\n\n315\n\nTo work around this, the nonlocal keyword was introduced in Python 3. It lets you declare a variable as a free variable even when it is assigned within the function. If a new value is assigned to a nonlocal variable, the binding stored in the closure is changed. A correct implementation of our newest make_averager looks like Example 9-13.\n\nExample 9-13. Calculate a running average without keeping all history (fixed with the use of nonlocal)\n\ndef make_averager(): count = 0 total = 0\n\ndef averager(new_value): nonlocal count, total count += 1 total += new_value return total / count\n\nreturn averager\n\nAfter studying the use of nonlocal, let’s summarize how Python’s variable lookup works.\n\nVariable Lookup Logic When a function is defined, the Python bytecode compiler determines how to fetch a variable x that appears in it, based on these rules:3\n\nIf there is a global x declaration, x comes from and is assigned to the x global variable module.4\n\nIf there is a nonlocal x declaration, x comes from and is assigned to the x local variable of the nearest surrounding function where x is defined.\n\nIf x is a parameter or is assigned a value in the function body, then x is the local variable.\n\nIf x is referenced but is not assigned and is not a parameter:\n\n— x will be looked up in the local scopes of the surrounding function bodies\n\n(nonlocal scopes).\n\n3 Thanks to tech reviewer Leonardo Rochael for suggesting this summary.\n\n4 Python does not have a program global scope, only module global scopes.\n\n316\n\n|\n\nChapter 9: Decorators and Closures\n\n— If not found in surrounding scopes, it will be read from the module global\n\nscope.\n\n— If not found in the global scope, it will be read from __builtins__.__dict__.\n\nNow that we have Python closures covered, we can effectively implement decorators with nested functions.\n\nImplementing a Simple Decorator Example 9-14 is a decorator that clocks every invocation of the decorated function and displays the elapsed time, the arguments passed, and the result of the call.\n\nExample 9-14. clockdeco0.py: simple decorator to show the running time of functions\n\nimport time\n\ndef clock(func): def clocked(*args): t0 = time.perf_counter() result = func(*args) elapsed = time.perf_counter() - t0 name = func.__name__ arg_str = ', '.join(repr(arg) for arg in args) print(f'[{elapsed:0.8f}s] {name}({arg_str}) -> {result!r}') return result return clocked\n\nDefine inner function clocked to accept any number of positional arguments.\n\nThis line only works because the closure for clocked encompasses the func free variable.\n\nReturn the inner function to replace the decorated function.\n\nExample 9-15 demonstrates the use of the clock decorator.\n\nExample 9-15. Using the clock decorator\n\nimport time from clockdeco0 import clock\n\n@clock def snooze(seconds): time.sleep(seconds)\n\n@clock\n\nImplementing a Simple Decorator\n\n|\n\n317\n\ndef factorial(n): return 1 if n < 2 else n*factorial(n-1)\n\nif __name__ == '__main__': print('*' * 40, 'Calling snooze(.123)') snooze(.123) print('*' * 40, 'Calling factorial(6)') print('6! =', factorial(6))\n\nThe output of running Example 9-15 looks like this:\n\n$ python3 clockdeco_demo.py **************************************** Calling snooze(.123) [0.12363791s] snooze(0.123) -> None **************************************** Calling factorial(6) [0.00000095s] factorial(1) -> 1 [0.00002408s] factorial(2) -> 2 [0.00003934s] factorial(3) -> 6 [0.00005221s] factorial(4) -> 24 [0.00006390s] factorial(5) -> 120 [0.00008297s] factorial(6) -> 720 6! = 720\n\nHow It Works Remember that this code:\n\n@clock def factorial(n): return 1 if n < 2 else n*factorial(n-1)\n\nactually does this:\n\ndef factorial(n): return 1 if n < 2 else n*factorial(n-1)\n\nfactorial = clock(factorial)\n\nSo, in both examples, clock gets the factorial function as its func argument (see Example 9-14). It then creates and returns the clocked function, which the Python interpreter assigns to factorial (behind the scenes, in the first example). In fact, if you import the clockdeco_demo module and check the __name__ of factorial, this is what you get:\n\n>>> import clockdeco_demo >>> clockdeco_demo.factorial.__name__ 'clocked' >>>\n\nSo factorial now actually holds a reference to the clocked function. From now on, each time factorial(n) is called, clocked(n) gets executed. In essence, clocked does the following:\n\n318\n\n|\n\nChapter 9: Decorators and Closures\n\n1. Records the initial time t0. 2. Calls the original factorial function, saving the result.\n\n3. Computes the elapsed time.\n\n4. Formats and displays the collected data.\n\n5. Returns the result saved in step 2.\n\nThis is the typical behavior of a decorator: it replaces the decorated function with a new function that accepts the same arguments and (usually) returns whatever the decorated function was supposed to return, while also doing some extra processing.\n\nIn Design Patterns by Gamma et al., the short description of the decorator pattern starts with: “Attach additional responsibilities to an object dynamically.” Function decorators fit that description. But at the implementation level, Python decorators bear little resemblance to the classic decorator described in the original Design Patterns work. “Soapbox” on page 338 has more on this subject.\n\nThe clock decorator implemented in Example 9-14 has a few shortcomings: it does not support keyword arguments, and it masks the __name__ and __doc__ of the deco‐ rated function. Example 9-16 uses the functools.wraps decorator to copy the rele‐ vant attributes from func to clocked. Also, in this new version, keyword arguments are correctly handled.\n\nExample 9-16. clockdeco.py: an improved clock decorator\n\nimport time import functools\n\ndef clock(func): @functools.wraps(func) def clocked(*args, **kwargs): t0 = time.perf_counter() result = func(*args, **kwargs) elapsed = time.perf_counter() - t0 name = func.__name__ arg_lst = [repr(arg) for arg in args] arg_lst.extend(f'{k}={v!r}' for k, v in kwargs.items()) arg_str = ', '.join(arg_lst) print(f'[{elapsed:0.8f}s] {name}({arg_str}) -> {result!r}') return result return clocked\n\nImplementing a Simple Decorator\n\n|\n\n319\n\nfunctools.wraps is just one of the ready-to-use decorators in the standard library. In the next section, we’ll meet the most impressive decorator that functools provides: cache.\n\nDecorators in the Standard Library Python has three built-in functions that are designed to decorate methods: property, classmethod, and staticmethod. We’ll discuss property in “Using a Property for Attribute Validation” on page 857 and the others in “classmethod Versus staticmethod” on page 369.\n\nIn Example 9-16 we saw another important decorator: functools.wraps, a helper for building well-behaved decorators. Some of the most interesting decorators in the standard library are cache, lru_cache, and singledispatch—all from the functools module. We’ll cover them next.\n\nMemoization with functools.cache The functools.cache decorator implements memoization:5 an optimization techni‐ que that works by saving the results of previous invocations of an expensive function, avoiding repeat computations on previously used arguments.\n\nfunctools.cache was added in Python 3.9. If you need to run these examples in Python 3.8, replace @cache with @lru_cache. For prior versions of Python, you must invoke the decorator, writing @lru_cache(), as explained in “Using lru_cache” on page 323.\n\nA good demonstration is to apply @cache to the painfully slow recursive function to generate the nth number in the Fibonacci sequence, as shown in Example 9-17.\n\nExample 9-17. The very costly recursive way to compute the nth number in the Fibonacci series\n\nfrom clockdeco import clock\n\n@clock def fibonacci(n): if n < 2: return n\n\n5 To clarify, this is not a typo: memoization is a computer science term vaguely related to “memorization,” but\n\nnot the same.\n\n320\n\n|\n\nChapter 9: Decorators and Closures\n\nreturn fibonacci(n - 2) + fibonacci(n - 1)\n\nif __name__ == '__main__': print(fibonacci(6))\n\nHere is the result of running fibo_demo.py. Except for the last line, all output is gen‐ erated by the clock decorator:\n\n$ python3 fibo_demo.py [0.00000042s] fibonacci(0) -> 0 [0.00000049s] fibonacci(1) -> 1 [0.00006115s] fibonacci(2) -> 1 [0.00000031s] fibonacci(1) -> 1 [0.00000035s] fibonacci(0) -> 0 [0.00000030s] fibonacci(1) -> 1 [0.00001084s] fibonacci(2) -> 1 [0.00002074s] fibonacci(3) -> 2 [0.00009189s] fibonacci(4) -> 3 [0.00000029s] fibonacci(1) -> 1 [0.00000027s] fibonacci(0) -> 0 [0.00000029s] fibonacci(1) -> 1 [0.00000959s] fibonacci(2) -> 1 [0.00001905s] fibonacci(3) -> 2 [0.00000026s] fibonacci(0) -> 0 [0.00000029s] fibonacci(1) -> 1 [0.00000997s] fibonacci(2) -> 1 [0.00000028s] fibonacci(1) -> 1 [0.00000030s] fibonacci(0) -> 0 [0.00000031s] fibonacci(1) -> 1 [0.00001019s] fibonacci(2) -> 1 [0.00001967s] fibonacci(3) -> 2 [0.00003876s] fibonacci(4) -> 3 [0.00006670s] fibonacci(5) -> 5 [0.00016852s] fibonacci(6) -> 8 8\n\nThe waste is obvious: fibonacci(1) is called eight times, fibonacci(2) five times, etc. But adding just two lines to use cache, performance is much improved. See Example 9-18.\n\nExample 9-18. Faster implementation using caching\n\nimport functools\n\nfrom clockdeco import clock\n\n@functools.cache @clock def fibonacci(n):\n\nDecorators in the Standard Library\n\n|\n\n321\n\nif n < 2: return n return fibonacci(n - 2) + fibonacci(n - 1)\n\nif __name__ == '__main__': print(fibonacci(6))\n\nThis line works with Python 3.9 or later. See “Using lru_cache” on page 323 for alternatives supporting earlier versions of Python.\n\nThis is an example of stacked decorators: @cache is applied on the function returned by @clock.\n\nStacked Decorators\n\nTo make sense of stacked decorators, recall that the @ is syntax sugar for applying the decorator function to the function below it. If there’s more than one decorator, they behave like nested func‐ tion calls. This:\n\n@alpha @beta def my_fn(): ...\n\nis the same as this:\n\nmy_fn = alpha(beta(my_fn))\n\nIn other words, the beta decorator is applied first, and the function it returns is then passed to alpha.\n\nUsing cache in Example 9-18, the fibonacci function is called only once for each value of n:\n\n$ python3 fibo_demo_lru.py [0.00000043s] fibonacci(0) -> 0 [0.00000054s] fibonacci(1) -> 1 [0.00006179s] fibonacci(2) -> 1 [0.00000070s] fibonacci(3) -> 2 [0.00007366s] fibonacci(4) -> 3 [0.00000057s] fibonacci(5) -> 5 [0.00008479s] fibonacci(6) -> 8 8\n\nIn another test, to compute fibonacci(30), Example 9-18 made the 31 calls needed in 0.00017s (total time), while the uncached Example 9-17 took 12.09s on an Intel Core i7 notebook, because it called fibonacci(1) 832,040 times, in a total of 2,692,537 calls.\n\n322\n\n|\n\nChapter 9: Decorators and Closures\n\nAll the arguments taken by the decorated function must be hashable, because the underlying lru_cache uses a dict to store the results, and the keys are made from the positional and keyword arguments used in the calls.\n\nBesides making silly recursive algorithms viable, @cache really shines in applications that need to fetch information from remote APIs.\n\nfunctools.cache can consume all available memory if there is a very large number of cache entries. I consider it more suitable for use in short-lived command-line scripts. In long-running pro‐ cesses, I recommend using functools.lru_cache with a suitable maxsize parameter, as explained in the next section.\n\nUsing lru_cache The functools.cache decorator is actually a simple wrapper around the older func tools.lru_cache function, which is more flexible and compatible with Python 3.8 and earlier versions.\n\nThe main advantage of @lru_cache is that its memory usage is bounded by the maxsize parameter, which has a rather conservative default value of 128—which means the cache will hold at most 128 entries at any time.\n\nThe acronym LRU stands for Least Recently Used, meaning that older entries that have not been read for a while are discarded to make room for new ones.\n\nSince Python 3.8, lru_cache can be applied in two ways. This is how to use it in the simplest way:\n\n@lru_cache def costly_function(a, b): ...\n\nThe other way—available since Python 3.2—is to invoke it as a function, with ():\n\n@lru_cache() def costly_function(a, b): ...\n\nIn both cases, the default parameters would be used. These are:\n\nmaxsize=128\n\nSets the maximum number of entries to be stored. After the cache is full, the least recently used entry is discarded to make room for each new entry. For optimal performance, maxsize should be a power of 2. If you pass maxsize=None, the LRU logic is disabled, so the cache works faster but entries are never discarded, which may consume too much memory. That’s what @functools.cache does.\n\nDecorators in the Standard Library\n\n|\n\n323\n\ntyped=False\n\nDetermines whether the results of different argument types are stored separately. For example, in the default setting, float and integer arguments that are consid‐ ered equal are stored only once, so there would be a single entry for the calls f(1) and f(1.0). If typed=True, those arguments would produce different entries, possibly storing distinct results.\n\nHere is an example invoking @lru_cache with nondefault parameters:\n\n@lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ...\n\nNow let’s study another powerful decorator: functools.singledispatch.\n\nSingle Dispatch Generic Functions Imagine we are creating a tool to debug web applications. We want to generate HTML displays for different types of Python objects.\n\nWe could start with a function like this:\n\nimport html\n\ndef htmlize(obj): content = html.escape(repr(obj)) return f'<pre>{content}</pre>'\n\nThat will work for any Python type, but now we want to extend it to generate custom displays for some types. Some examples:\n\nstr\n\nReplace embedded newline characters with '<br/>\\n' and use <p> tags instead of <pre>.\n\nint\n\nShow the number in decimal and hexadecimal (with a special case for bool).\n\nlist\n\nOutput an HTML list, formatting each item according to its type.\n\nfloat and Decimal\n\nOutput the value as usual, but also in the form of a fraction (why not?).\n\nThe behavior we want is shown in Example 9-19.\n\n324\n\n|\n\nChapter 9: Decorators and Closures\n\nExample 9-19. htmlize() generates HTML tailored to different object types\n\n>>> htmlize({1, 2, 3}) '<pre>{1, 2, 3}</pre>' >>> htmlize(abs) '<pre>&lt;built-in function abs&gt;</pre>' >>> htmlize('Heimlich & Co.\\n- a game') '<p>Heimlich &amp; Co.<br/>\\n- a game</p>' >>> htmlize(42) '<pre>42 (0x2a)</pre>' >>> print(htmlize(['alpha', 66, {3, 2, 1}])) <ul> <li><p>alpha</p></li> <li><pre>66 (0x42)</pre></li> <li><pre>{1, 2, 3}</pre></li> </ul> >>> htmlize(True) '<pre>True</pre>' >>> htmlize(fractions.Fraction(2, 3)) '<pre>2/3</pre>' >>> htmlize(2/3) '<pre>0.6666666666666666 (2/3)</pre>' >>> htmlize(decimal.Decimal('0.02380952')) '<pre>0.02380952 (1/42)</pre>'\n\nThe original function is registered for object, so it serves as a catch-all to handle argument types that don’t match the other implementations.\n\nstr objects are also HTML-escaped but wrapped in <p></p>, with <br/> line breaks inserted before each '\\n'.\n\nAn int is shown in decimal and hexadecimal, inside <pre></pre>.\n\nEach list item is formatted according to its type, and the whole sequence is ren‐ dered as an HTML list.\n\nAlthough bool is an int subtype, it gets special treatment.\n\nShow Fraction as a fraction.\n\nShow float and Decimal with an approximate fractional equivalent.\n\nFunction singledispatch\n\nBecause we don’t have Java-style method overloading in Python, we can’t simply cre‐ ate variations of htmlize with different signatures for each data type we want to han‐ dle differently. A possible solution in Python would be to turn htmlize into a\n\nDecorators in the Standard Library\n\n|\n\n325",
      "page_number": 327
    },
    {
      "number": 18,
      "title": "Segment 18 (pages 348-366)",
      "start_page": 348,
      "end_page": 366,
      "detection_method": "synthetic",
      "content": "dispatch function, with a chain of if/elif/… or match/case/… calling specialized functions like htmlize_str, htmlize_int, etc. This is not extensible by users of our module, and is unwieldy: over time, the htmlize dispatcher would become too big, and the coupling between it and the specialized functions would be very tight.\n\nThe functools.singledispatch decorator allows different modules to contribute to the overall solution, and lets you easily provide specialized functions even for types that belong to third-party packages that you can’t edit. If you decorate a plain func‐ tion with @singledispatch, it becomes the entry point for a generic function: a group of functions to perform the same operation in different ways, depending on the type of the first argument. This is what is meant by the term single dispatch. If more argu‐ ments were used to select the specific functions, we’d have multiple dispatch. Example 9-20 shows how.\n\nfunctools.singledispatch exists since Python 3.4, but it only supports type hints since Python 3.7. The last two functions in Example 9-20 illustrate the syntax that works in all versions of Python since 3.4.\n\nExample 9-20. @singledispatch creates a custom @htmlize.register to bundle several functions into a generic function\n\nfrom functools import singledispatch from collections import abc import fractions import decimal import html import numbers\n\n@singledispatch def htmlize(obj: object) -> str: content = html.escape(repr(obj)) return f'<pre>{content}</pre>'\n\n@htmlize.register def _(text: str) -> str: content = html.escape(text).replace('\\n', '<br/>\\n') return f'<p>{content}</p>'\n\n@htmlize.register def _(seq: abc.Sequence) -> str: inner = '</li>\\n<li>'.join(htmlize(item) for item in seq) return '<ul>\\n<li>' + inner + '</li>\\n</ul>'\n\n@htmlize.register def _(n: numbers.Integral) -> str: return f'<pre>{n} (0x{n:x})</pre>'\n\n326\n\n|\n\nChapter 9: Decorators and Closures\n\n@htmlize.register def _(n: bool) -> str: return f'<pre>{n}</pre>'\n\n@htmlize.register(fractions.Fraction) def _(x) -> str: frac = fractions.Fraction(x) return f'<pre>{frac.numerator}/{frac.denominator}</pre>'\n\n@htmlize.register(decimal.Decimal) @htmlize.register(float) def _(x) -> str: frac = fractions.Fraction(x).limit_denominator() return f'<pre>{x} ({frac.numerator}/{frac.denominator})</pre>'\n\n@singledispatch marks the base function that handles the object type.\n\nEach specialized function is decorated with @«base».register.\n\nThe type of the first argument given at runtime determines when this particular function definition will be used. The name of the specialized functions is irrele‐ vant; _ is a good choice to make this clear.6\n\nFor each additional type to get special treatment, register a new function with a matching type hint in the first parameter.\n\nThe numbers ABCs are useful for use with singledispatch.7\n\nbool is a subtype-of numbers.Integral, but the singledispatch logic seeks the implementation with the most specific matching type, regardless of the order they appear in the code.\n\n6 Unfortunately, Mypy 0.770 complains when it sees multiple functions with the same name. 7 Despite the warning in “The fall of the numeric tower” on page 279, the number ABCs are not deprecated and\n\nyou find them in Python 3 code.\n\nDecorators in the Standard Library\n\n|\n\n327\n\nIf you don’t want to, or cannot, add type hints to the decorated function, you can pass a type to the @«base».register decorator. This syntax works in Python 3.4 or later.\n\nThe @«base».register decorator returns the undecorated function, so it’s possi‐ ble to stack them to register two or more types on the same implementation.8\n\nWhen possible, register the specialized functions to handle ABCs (abstract classes) such as numbers.Integral and abc.MutableSequence, instead of concrete imple‐ mentations like int and list. This allows your code to support a greater variety of compatible types. For example, a Python extension can provide alternatives to the int type with fixed bit lengths as subclasses of numbers.Integral.9\n\nUsing ABCs or typing.Protocol with @singledispatch allows your code to support existing or future classes that are actual or virtual subclasses of those ABCs, or that implement those proto‐ cols. The use of ABCs and the concept of a virtual subclass are sub‐ jects of Chapter 13.\n\nA notable quality of the singledispatch mechanism is that you can register special‐ ized functions anywhere in the system, in any module. If you later add a module with a new user-defined type, you can easily provide a new custom function to handle that type. And you can write custom functions for classes that you did not write and can’t change.\n\nsingledispatch is a well-thought-out addition to the standard library, and it offers more features than I can describe here. PEP 443—Single-dispatch generic functions is a good reference, but it doesn’t mention the use of type hints, which were added later. The functools module documentation has improved and has more up-to-date cov‐ erage with several examples in its singledispatch entry.\n\n8 Maybe one day you’ll also be able to express this with single unparameterized @htmlize.register and type\n\nhint using Union, but when I tried, Python raised a TypeError with a message saying that Union is not a class. So, although PEP 484 syntax is supported by @singledispatch, the semantics are not there yet.\n\n9 NumPy, for example, implements several machine-oriented integer and floating-point types.\n\n328\n\n|\n\nChapter 9: Decorators and Closures\n\n@singledispatch is not designed to bring Java-style method over‐ loading to Python. A single class with many overloaded variations of a method is better than a single function with a lengthy stretch of if/elif/elif/elif blocks. But both solutions are flawed because they concentrate too much responsibility in a single code unit—the class or the function. The advantage of @singledispatch is supporting modular extension: each module can register a speci‐ alized function for each type it supports. In a realistic use case, you would not have all the implementations of generic functions in the same module as in Example 9-20.\n\nWe’ve seen some decorators that take arguments, for example, @lru_cache() and htmlize.register(float), created by @singledispatch in Example 9-20. The next section shows how to build decorators that accept parameters.\n\nParameterized Decorators When parsing a decorator in source code, Python takes the decorated function and passes it as the first argument to the decorator function. So how do you make a deco‐ rator accept other arguments? The answer is: make a decorator factory that takes those arguments and returns a decorator, which is then applied to the function to be decorated. Confusing? Sure. Let’s start with an example based on the simplest decora‐ tor we’ve seen: register in Example 9-21.\n\nExample 9-21. Abridged registration.py module from Example 9-2, repeated here for convenience\n\nregistry = []\n\ndef register(func): print(f'running register({func})') registry.append(func) return func\n\n@register def f1(): print('running f1()')\n\nprint('running main()') print('registry ->', registry) f1()\n\nA Parameterized Registration Decorator To make it easy to enable or disable the function registration performed by register, we’ll make it accept an optional active parameter which, if False, skips registering\n\nParameterized Decorators\n\n|\n\n329\n\nthe decorated function. Example 9-22 shows how. Conceptually, the new register function is not a decorator but a decorator factory. When called, it returns the actual decorator that will be applied to the target function.\n\nExample 9-22. To accept parameters, the new register decorator must be called as a function\n\nregistry = set()\n\ndef register(active=True): def decorate(func): print('running register' f'(active={active})->decorate({func})') if active: registry.add(func) else: registry.discard(func)\n\nreturn func return decorate\n\n@register(active=False) def f1(): print('running f1()')\n\n@register() def f2(): print('running f2()')\n\ndef f3(): print('running f3()')\n\nregistry is now a set, so adding and removing functions is faster.\n\nregister takes an optional keyword argument.\n\nThe decorate inner function is the actual decorator; note how it takes a function as an argument.\n\nRegister func only if the active argument (retrieved from the closure) is True.\n\nIf not active and func in registry, remove it.\n\nBecause decorate is a decorator, it must return a function.\n\nregister is our decorator factory, so it returns decorate.\n\n330\n\n|\n\nChapter 9: Decorators and Closures\n\nThe @register factory must be invoked as a function, with the desired parameters.\n\nIf no parameters are passed, register must still be called as a function—@regis ter()—i.e., to return the actual decorator, decorate.\n\nThe main point is that register() returns decorate, which is then applied to the decorated function.\n\nThe code in Example 9-22 is in a registration_param.py module. If we import it, this is what we get:\n\n>>> import registration_param running register(active=False)->decorate(<function f1 at 0x10063c1e0>) running register(active=True)->decorate(<function f2 at 0x10063c268>) >>> registration_param.registry [<function f2 at 0x10063c268>]\n\nNote how only the f2 function appears in the registry; f1 does not appear because active=False was passed to the register decorator factory, so the decorate that was applied to f1 did not add it to the registry.\n\nIf, instead of using the @ syntax, we used register as a regular function, the syntax needed to decorate a function f would be register()(f) to add f to the registry, or register(active=False)(f) to not add it (or remove it). See Example 9-23 for a demo of adding and removing functions to the registry.\n\nExample 9-23. Using the registration_param module listed in Example 9-22\n\n>>> from registration_param import * running register(active=False)->decorate(<function f1 at 0x10073c1e0>) running register(active=True)->decorate(<function f2 at 0x10073c268>) >>> registry {<function f2 at 0x10073c268>} >>> register()(f3) running register(active=True)->decorate(<function f3 at 0x10073c158>) <function f3 at 0x10073c158> >>> registry {<function f3 at 0x10073c158>, <function f2 at 0x10073c268>} >>> register(active=False)(f2) running register(active=False)->decorate(<function f2 at 0x10073c268>) <function f2 at 0x10073c268> >>> registry {<function f3 at 0x10073c158>}\n\nWhen the module is imported, f2 is in the registry.\n\nThe register() expression returns decorate, which is then applied to f3.\n\nParameterized Decorators\n\n|\n\n331\n\nThe previous line added f3 to the registry.\n\nThis call removes f2 from the registry.\n\nConfirm that only f3 remains in the registry.\n\nThe workings of parameterized decorators are fairly involved, and the one we’ve just discussed is simpler than most. Parameterized decorators usually replace the decora‐ ted function, and their construction requires yet another level of nesting. Now we will explore the architecture of one such function pyramid.\n\nThe Parameterized Clock Decorator In this section, we’ll revisit the clock decorator, adding a feature: users may pass a format string to control the output of the clocked function report. See Example 9-24.\n\nFor simplicity, Example 9-24 is based on the initial clock imple‐ mentation from Example 9-14, and not the improved one from Example 9-16 that uses @functools.wraps, adding yet another function layer.\n\nExample 9-24. Module clockdeco_param.py: the parameterized clock decorator\n\nimport time\n\nDEFAULT_FMT = '[{elapsed:0.8f}s] {name}({args}) -> {result}'\n\ndef clock(fmt=DEFAULT_FMT): def decorate(func): def clocked(*_args): t0 = time.perf_counter() _result = func(*_args) elapsed = time.perf_counter() - t0 name = func.__name__ args = ', '.join(repr(arg) for arg in _args) result = repr(_result) print(fmt.format(**locals())) return _result return clocked return decorate\n\nif __name__ == '__main__':\n\n@clock() def snooze(seconds): time.sleep(seconds)\n\n332\n\n|\n\nChapter 9: Decorators and Closures\n\nfor i in range(3): snooze(.123)\n\nclock is our parameterized decorator factory.\n\ndecorate is the actual decorator.\n\nclocked wraps the decorated function.\n\n_result is the actual result of the decorated function.\n\n_args holds the actual arguments of clocked, while args is str used for display.\n\nresult is the str representation of _result, for display.\n\nUsing **locals() here allows any local variable of clocked to be referenced in the fmt.10\n\nclocked will replace the decorated function, so it should return whatever that function returns.\n\ndecorate returns clocked.\n\nclock returns decorate.\n\nIn this self test, clock() is called without arguments, so the decorator applied will use the default format str.\n\nIf you run Example 9-24 from the shell, this is what you get:\n\n$ python3 clockdeco_param.py [0.12412500s] snooze(0.123) -> None [0.12411904s] snooze(0.123) -> None [0.12410498s] snooze(0.123) -> None\n\nTo exercise the new functionality, let’s have a look at Examples 9-25 and 9-26, which are two other modules using clockdeco_param, and the outputs they generate.\n\n10 Tech reviewer Miroslav Šedivý noted: “It also means that code linters will complain about unused variables since they tend to ignore uses of locals().” Yes, that’s yet another example of how static checking tools dis‐ courage the use of the dynamic features that attracted me and countless programmers to Python in the first place. To make the linter happy, I could spell out each local variable twice in the call: fmt.format(elapsed= elapsed, name=name, args=args, result=result). I’d rather not. If you use static checking tools, it’s very important to know when to ignore them.\n\nParameterized Decorators\n\n|\n\n333\n\nExample 9-25. clockdeco_param_demo1.py\n\nimport time from clockdeco_param import clock\n\n@clock('{name}: {elapsed}s') def snooze(seconds): time.sleep(seconds)\n\nfor i in range(3): snooze(.123)\n\nOutput of Example 9-25:\n\n$ python3 clockdeco_param_demo1.py snooze: 0.12414693832397461s snooze: 0.1241159439086914s snooze: 0.12412118911743164s\n\nExample 9-26. clockdeco_param_demo2.py\n\nimport time from clockdeco_param import clock\n\n@clock('{name}({args}) dt={elapsed:0.3f}s') def snooze(seconds): time.sleep(seconds)\n\nfor i in range(3): snooze(.123)\n\nOutput of Example 9-26:\n\n$ python3 clockdeco_param_demo2.py snooze(0.123) dt=0.124s snooze(0.123) dt=0.124s snooze(0.123) dt=0.124s\n\nLennart Regebro—a technical reviewer for the first edition—argues that decorators are best coded as classes implementing __call__, and not as functions like the examples in this chapter. I agree that approach is better for nontrivial decorators, but to explain the basic idea of this language feature, functions are easier to understand. See “Further Reading” on page 336, in particular, Graham Dumple‐ ton’s blog and wrapt module for industrial-strength techniques when building decorators.\n\nThe next section shows an example in the style recommended by Regebro and Dumpleton.\n\n334\n\n|\n\nChapter 9: Decorators and Closures\n\nA Class-Based Clock Decorator As a final example, Example 9-27 lists the implementation of a parameterized clock decorator implemented as a class with __call__. Contrast Example 9-24 with Example 9-27. Which one do you prefer?\n\nExample 9-27. Module clockdeco_cls.py: parameterized clock decorator implemented as class\n\nimport time\n\nDEFAULT_FMT = '[{elapsed:0.8f}s] {name}({args}) -> {result}'\n\nclass clock:\n\ndef __init__(self, fmt=DEFAULT_FMT): self.fmt = fmt\n\ndef __call__(self, func): def clocked(*_args): t0 = time.perf_counter() _result = func(*_args) elapsed = time.perf_counter() - t0 name = func.__name__ args = ', '.join(repr(arg) for arg in _args) result = repr(_result) print(self.fmt.format(**locals())) return _result return clocked\n\nInstead of a clock outer function, the clock class is our parameterized decorator factory. I named it with a lowercase c to make clear that this implementation is a drop-in replacement for the one in Example 9-24.\n\nThe argument passed in the clock(my_format) is assigned to the fmt parameter here. The class constructor returns an instance of clock, with my_format stored in self.fmt.\n\n__call__ makes the clock instance callable. When invoked, the instance replaces the decorated function with clocked.\n\nclocked wraps the decorated function.\n\nThis ends our exploration of function decorators. We’ll see class decorators in Chapter 24.\n\nParameterized Decorators\n\n|\n\n335\n\nChapter Summary We covered some difficult terrain in this chapter. I tried to make the journey as smooth as possible, but we definitely entered the realm of metaprogramming.\n\nWe started with a simple @register decorator without an inner function, and fin‐ ished with a parameterized @clock() involving two levels of nested functions.\n\nRegistration decorators, though simple in essence, have real applications in Python frameworks. We will apply the registration idea in one implementation of the Strat‐ egy design pattern in Chapter 10.\n\nUnderstanding how decorators actually work required covering the difference between import time and runtime, then diving into variable scoping, closures, and the new nonlocal declaration. Mastering closures and nonlocal is valuable not only to build decorators, but also to code event-oriented programs for GUIs or asynchronous I/O with callbacks, and to adopt a functional style when it makes sense.\n\nParameterized decorators almost always involve at least two nested functions, maybe more if you want to use @functools.wraps to produce a decorator that provides bet‐ ter support for more advanced techniques. One such technique is stacked decorators, which we saw in Example 9-18. For more sophisticated decorators, a class-based implementation may be easier to read and maintain.\n\nAs examples of parameterized decorators in the standard library, we visited the pow‐ erful @cache and @singledispatch from the functools module.\n\nFurther Reading Item #26 of Brett Slatkin’s Effective Python, 2nd ed. (Addison-Wesley), covers best practices for function decorators and recommends always using functools.wraps— which we saw in Example 9-16.11\n\nGraham Dumpleton has a series of in-depth blog posts about techniques for imple‐ menting well-behaved decorators, starting with “How you implemented your Python decorator is wrong”. His deep expertise in this matter is also nicely packaged in the wrapt module he wrote to simplify the implementation of decorators and dynamic function wrappers, which support introspection and behave correctly when further decorated, when applied to methods, and when used as attribute descriptors. Chap‐ ter 23 in Part III is about descriptors.\n\nChapter 9, “Metaprogramming”, of the Python Cookbook, 3rd ed. by David Beazley and Brian K. Jones (O’Reilly), has several recipes, from elementary decorators to very\n\n11 I wanted to make the code as simple as possible, so I did not follow Slatkin’s excellent advice in all examples.\n\n336\n\n|\n\nChapter 9: Decorators and Closures\n\nsophisticated ones, including one that can be called as a regular decorator or as a dec‐ orator factory, e.g., @clock or @clock(). That’s “Recipe 9.6. Defining a Decorator That Takes an Optional Argument” in that cookbook.\n\nMichele Simionato authored a package aiming to “simplify the usage of decorators for the average programmer, and to popularize decorators by showing various nontrivial examples,” according to the docs. It’s available on PyPI as the decorator package.\n\nCreated when decorators were still a new feature in Python, the Python Decorator Library wiki page has dozens of examples. Because that page started years ago, some of the techniques shown have been superseded, but the page is still an excellent source of inspiration.\n\n“Closures in Python” is a short blog post by Fredrik Lundh that explains the termi‐ nology of closures.\n\nPEP 3104—Access to Names in Outer Scopes describes the introduction of the nonlocal declaration to allow rebinding of names that are neither local nor global. It also includes an excellent overview of how this issue is resolved in other dynamic lan‐ guages (Perl, Ruby, JavaScript, etc.) and the pros and cons of the design options avail‐ able to Python.\n\nOn a more theoretical level, PEP 227—Statically Nested Scopes documents the intro‐ duction of lexical scoping as an option in Python 2.1 and as a standard in Python 2.2, explaining the rationale and design choices for the implementation of closures in Python.\n\nPEP 443 provides the rationale and a detailed description of the single-dispatch generic functions’ facility. An old (March 2005) blog post by Guido van Rossum, “Five-Minute Multimethods in Python”, walks through an implementation of generic functions (a.k.a. multimethods) using decorators. His code supports multiple- dispatch (i.e., dispatch based on more than one positional argument). Guido’s multi‐ methods code is interesting, but it’s a didactic example. For a modern, production- ready implementation of multiple dispatch generic functions, check out Reg by Martijn Faassen—author of the model-driven and REST-savvy Morepath web framework.\n\nFurther Reading\n\n|\n\n337\n\nSoapbox\n\nDynamic Scope Versus Lexical Scope\n\nThe designer of any language with first-class functions faces this issue: being a first- class object, a function is defined in a certain scope but may be invoked in other scopes. The question is: how to evaluate the free variables? The first and simplest answer is “dynamic scope.” This means that free variables are evaluated by looking into the environment where the function is invoked.\n\nIf Python had dynamic scope and no closures, we could improvise avg—similar to Example 9-8—like this:\n\n>>> ### this is not a real Python console session! ### >>> avg = make_averager() >>> series = [] >>> avg(10) 10.0 >>> avg(11) 10.5 >>> avg(12) 11.0 >>> series = [1] >>> avg(5) 3.0\n\nBefore using avg, we have to define series = [] ourselves, so we must know that averager (inside make_averager) refers to a list named series.\n\nBehind the scenes, series accumulates the values to be averaged.\n\nWhen series = [1] is executed, the previous list is lost. This could happen by accident, when handling two independent running averages at the same time.\n\nFunctions should be opaque, with their implementation hidden from users. But with dynamic scope, if a function uses free variables, the programmer has to know its internals to set up an environment where it works correctly. After years of struggling with the LaTeX document preparation language, the excellent Practical LaTeX book by George Grätzer (Springer) taught me that LaTeX variables use dynamic scope. That’s why they were so confusing to me!\n\nEmacs Lisp also uses dynamic scope, at least by default. See “Dynamic Binding” in the Emacs Lisp manual for a short explanation.\n\nDynamic scope is easier to implement, which is probably why it was the path taken by John McCarthy when he created Lisp, the first language to have first-class functions. Paul Graham’s article “The Roots of Lisp” is an accessible explanation of John\n\n338\n\n|\n\nChapter 9: Decorators and Closures\n\nMcCarthy’s original paper about the Lisp language, \"Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I”. McCarthy’s paper is a mas‐ terpiece as great as Beethoven’s 9th Symphony. Paul Graham translated it for the rest of us, from mathematics to English and running code.\n\nPaul Graham’s commentary explains how tricky dynamic scoping is. Quoting from “The Roots of Lisp”:\n\nIt’s an eloquent testimony to the dangers of dynamic scope that even the very first example of higher-order Lisp functions was broken because of it. It may be that McCarthy was not fully aware of the implications of dynamic scope in 1960. Dynamic scope remained in Lisp implementations for a surprisingly long time— until Sussman and Steele developed Scheme in 1975. Lexical scope does not compli‐ cate the definition of eval very much, but it may make compilers harder to write.\n\nToday, lexical scope is the norm: free variables are evaluated considering the environ‐ ment where the function is defined. Lexical scope complicates the implementation of languages with first-class functions, because it requires the support of closures. On the other hand, lexical scope makes source code easier to read. Most languages inven‐ ted since Algol have lexical scope. One notable exception is JavaScript, where the spe‐ cial variable this is confusing because it can be lexically or dynamically scoped, depending on how the code is written.\n\nFor many years, Python lambdas did not provide closures, contributing to the bad name of this feature among functional-programming geeks in the blogosphere. This was fixed in Python 2.2 (December 2001), but the blogosphere has a long memory. Since then, lambda is embarrassing only because of its limited syntax.\n\nPython Decorators and the Decorator Design Pattern\n\nPython function decorators fit the general description of decorator given by Gamma et al. in Design Patterns: “Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.”\n\nAt the implementation level, Python decorators do not resemble the classic decorator design pattern, but an analogy can be made.\n\nIn the design pattern, Decorator and Component are abstract classes. An instance of a concrete decorator wraps an instance of a concrete component in order to add behav‐ iors to it. Quoting from Design Patterns:\n\nThe decorator conforms to the interface of the component it decorates so that its presence is transparent to the component’s clients. The decorator forwards requests to the component and may perform additional actions (such as drawing a border) before or after forwarding. Transparency lets you nest decorators recursively, thereby allowing an unlimited number of added responsibilities.” (p. 175)\n\nIn Python, the decorator function plays the role of a concrete Decorator subclass, and the inner function it returns is a decorator instance. The returned function wraps\n\nFurther Reading\n\n|\n\n339\n\nthe function to be decorated, which is analogous to the component in the design pat‐ tern. The returned function is transparent because it conforms to the interface of the component by accepting the same arguments. It forwards calls to the component and may perform additional actions either before or after it. Borrowing from the previous citation, we can adapt the last sentence to say that “Transparency lets you stack deco‐ rators, thereby allowing an unlimited number of added behaviors.”\n\nNote that I am not suggesting that function decorators should be used to implement the decorator pattern in Python programs. Although this can be done in specific sit‐ uations, in general the decorator pattern is best implemented with classes to represent the decorator and the components it will wrap.\n\n340\n\n|\n\nChapter 9: Decorators and Closures\n\nCHAPTER 10 Design Patterns with First-Class Functions\n\nConformity to patterns is not a measure of goodness.\n\n—Ralph Johnson, coauthor of the Design Patterns classic1\n\nIn software engineering, a design pattern is a general recipe for solving a common design problem. You don’t need to know design patterns to follow this chapter. I will explain the patterns used in the examples.\n\nThe use of design patterns in programming was popularized by the landmark book Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley) by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides—a.k.a. “the Gang of Four.” The book is a catalog of 23 patterns consisting of arrangements of classes exemplified with code in C++, but assumed to be useful in other object-oriented lan‐ guages as well.\n\nAlthough design patterns are language independent, that does not mean every pat‐ tern applies to every language. For example, Chapter 17 will show that it doesn’t make sense to emulate the recipe of the Iterator pattern in Python, because the pat‐ tern is embedded in the language and ready to use in the form of generators—which don’t need classes to work, and require less code than the classic recipe.\n\nThe authors of Design Patterns acknowledge in their introduction that the implemen‐ tation language determines which patterns are relevant:\n\nThe choice of programming language is important because it influences one’s point of view. Our patterns assume Smalltalk/C++-level language features, and that choice determines what can and cannot be implemented easily. If we assumed procedural\n\n1 From a slide in the talk “Root Cause Analysis of Some Faults in Design Patterns,” presented by Ralph Johnson\n\nat IME/CCSL, Universidade de São Paulo, Nov. 15, 2014.\n\n341\n\nlanguages, we might have included design patterns called “Inheritance,” “Encapsula‐ tion,” and “Polymorphism.” Similarly, some of our patterns are supported directly by the less common object-oriented languages. CLOS has multi-methods, for example, which lessen the need for a pattern such as Visitor.2\n\nIn his 1996 presentation, “Design Patterns in Dynamic Languages”, Peter Norvig states that 16 out of the 23 patterns in the original Design Patterns book become either “invisible or simpler” in a dynamic language (slide 9). He’s talking about the Lisp and Dylan languages, but many of the relevant dynamic features are also present in Python. In particular, in the context of languages with first-class functions, Norvig suggests rethinking the classic patterns known as Strategy, Command, Template Method, and Visitor.\n\nThe goal of this chapter is to show how—in some cases—functions can do the same work as classes, with code that is more readable and concise. We will refactor an implementation of Strategy using functions as objects, removing a lot of boilerplate code. We’ll also discuss a similar approach to simplifying the Command pattern.\n\nWhat’s New in This Chapter I moved this chapter to the end of Part III so I could apply a registration decorator in “Decorator-Enhanced Strategy Pattern” on page 353 and also use type hints in the examples. Most type hints used in this chapter are not complicated, and they do help with readability.\n\nCase Study: Refactoring Strategy Strategy is a good example of a design pattern that can be simpler in Python if you leverage functions as first-class objects. In the following section, we describe and implement Strategy using the “classic” structure described in Design Patterns. If you are familiar with the classic pattern, you can skip to “Function-Oriented Strategy” on page 347 where we refactor the code using functions, significantly reducing the line count.\n\nClassic Strategy The UML class diagram in Figure 10-1 depicts an arrangement of classes that exem‐ plifies the Strategy pattern.\n\n2 Quoted from page 4 of Design Patterns.\n\n342\n\n|\n\nChapter 10: Design Patterns with First-Class Functions\n\nFigure 10-1. UML class diagram for order discount processing implemented with the Strategy design pattern.\n\nThe Strategy pattern is summarized like this in Design Patterns:\n\nDefine a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.\n\nA clear example of Strategy applied in the ecommerce domain is computing dis‐ counts to orders according to the attributes of the customer or inspection of the ordered items.\n\nConsider an online store with these discount rules:\n\nCustomers with 1,000 or more fidelity points get a global 5% discount per order.\n\nA 10% discount is applied to each line item with 20 or more units in the same order.\n\nOrders with at least 10 distinct items get a 7% global discount.\n\nFor brevity, let’s assume that only one discount may be applied to an order.\n\nThe UML class diagram for the Strategy pattern is depicted in Figure 10-1. Its partici‐ pants are:\n\nCase Study: Refactoring Strategy\n\n|\n\n343\n\nContext\n\nProvides a service by delegating some computation to interchangeable compo‐ nents that implement alternative algorithms. In the ecommerce example, the context is an Order, which is configured to apply a promotional discount accord‐ ing to one of several algorithms.\n\nStrategy\n\nThe interface common to the components that implement the different algo‐ rithms. In our example, this role is played by an abstract class called Promotion.\n\nConcrete strategy\n\nOne of the concrete subclasses of Strategy. FidelityPromo, BulkPromo, and LargeOrderPromo are the three concrete strategies implemented.\n\nThe code in Example 10-1 follows the blueprint in Figure 10-1. As described in Design Patterns, the concrete strategy is chosen by the client of the context class. In our example, before instantiating an order, the system would somehow select a pro‐ motional discount strategy and pass it to the Order constructor. The selection of the strategy is outside the scope of the pattern.\n\nExample 10-1. Implementation of the Order class with pluggable discount strategies\n\nfrom abc import ABC, abstractmethod from collections.abc import Sequence from decimal import Decimal from typing import NamedTuple, Optional\n\nclass Customer(NamedTuple): name: str fidelity: int\n\nclass LineItem(NamedTuple): product: str quantity: int price: Decimal\n\ndef total(self) -> Decimal: return self.price * self.quantity\n\nclass Order(NamedTuple): # the Context customer: Customer cart: Sequence[LineItem] promotion: Optional['Promotion'] = None\n\ndef total(self) -> Decimal: totals = (item.total() for item in self.cart)\n\n344\n\n|\n\nChapter 10: Design Patterns with First-Class Functions",
      "page_number": 348
    },
    {
      "number": 19,
      "title": "Segment 19 (pages 367-387)",
      "start_page": 367,
      "end_page": 387,
      "detection_method": "synthetic",
      "content": "return sum(totals, start=Decimal(0))\n\ndef due(self) -> Decimal: if self.promotion is None: discount = Decimal(0) else: discount = self.promotion.discount(self) return self.total() - discount\n\ndef __repr__(self): return f'<Order total: {self.total():.2f} due: {self.due():.2f}>'\n\nclass Promotion(ABC): # the Strategy: an abstract base class @abstractmethod def discount(self, order: Order) -> Decimal: \"\"\"Return discount as a positive dollar amount\"\"\"\n\nclass FidelityPromo(Promotion): # first Concrete Strategy \"\"\"5% discount for customers with 1000 or more fidelity points\"\"\"\n\ndef discount(self, order: Order) -> Decimal: rate = Decimal('0.05') if order.customer.fidelity >= 1000: return order.total() * rate return Decimal(0)\n\nclass BulkItemPromo(Promotion): # second Concrete Strategy \"\"\"10% discount for each LineItem with 20 or more units\"\"\"\n\ndef discount(self, order: Order) -> Decimal: discount = Decimal(0) for item in order.cart: if item.quantity >= 20: discount += item.total() * Decimal('0.1') return discount\n\nclass LargeOrderPromo(Promotion): # third Concrete Strategy \"\"\"7% discount for orders with 10 or more distinct items\"\"\"\n\ndef discount(self, order: Order) -> Decimal: distinct_items = {item.product for item in order.cart} if len(distinct_items) >= 10: return order.total() * Decimal('0.07') return Decimal(0)\n\nNote that in Example 10-1, I coded Promotion as an abstract base class (ABC) to use the @abstractmethod decorator and make the pattern more explicit.\n\nCase Study: Refactoring Strategy\n\n|\n\n345\n\nExample 10-2 shows doctests used to demonstrate and verify the operation of a mod‐ ule implementing the rules described earlier.\n\nExample 10-2. Sample usage of Order class with different promotions applied\n\n>>> joe = Customer('John Doe', 0) >>> ann = Customer('Ann Smith', 1100) >>> cart = (LineItem('banana', 4, Decimal('.5')), ... LineItem('apple', 10, Decimal('1.5')), ... LineItem('watermelon', 5, Decimal(5))) >>> Order(joe, cart, FidelityPromo()) <Order total: 42.00 due: 42.00> >>> Order(ann, cart, FidelityPromo()) <Order total: 42.00 due: 39.90> >>> banana_cart = (LineItem('banana', 30, Decimal('.5')), ... LineItem('apple', 10, Decimal('1.5'))) >>> Order(joe, banana_cart, BulkItemPromo()) <Order total: 30.00 due: 28.50> >>> long_cart = tuple(LineItem(str(sku), 1, Decimal(1)) ... for sku in range(10)) >>> Order(joe, long_cart, LargeOrderPromo()) <Order total: 10.00 due: 9.30> >>> Order(joe, cart, LargeOrderPromo()) <Order total: 42.00 due: 42.00>\n\nTwo customers: joe has 0 fidelity points, ann has 1,100.\n\nOne shopping cart with three line items.\n\nThe FidelityPromo promotion gives no discount to joe.\n\nann gets a 5% discount because she has at least 1,000 points.\n\nThe banana_cart has 30 units of the \"banana\" product and 10 apples.\n\nThanks to the BulkItemPromo, joe gets a $1.50 discount on the bananas.\n\nlong_cart has 10 different items at $1.00 each.\n\njoe gets a 7% discount on the whole order because of LargerOrderPromo.\n\nExample 10-1 works perfectly well, but the same functionality can be implemented with less code in Python by using functions as objects. The next section shows how.\n\n346\n\n|\n\nChapter 10: Design Patterns with First-Class Functions\n\nFunction-Oriented Strategy Each concrete strategy in Example 10-1 is a class with a single method, discount. Furthermore, the strategy instances have no state (no instance attributes). You could say they look a lot like plain functions, and you would be right. Example 10-3 is a refactoring of Example 10-1, replacing the concrete strategies with simple functions and removing the Promo abstract class. Only small adjustments are needed in the Order class.3\n\nExample 10-3. Order class with discount strategies implemented as functions\n\nfrom collections.abc import Sequence from dataclasses import dataclass from decimal import Decimal from typing import Optional, Callable, NamedTuple\n\nclass Customer(NamedTuple): name: str fidelity: int\n\nclass LineItem(NamedTuple): product: str quantity: int price: Decimal\n\ndef total(self): return self.price * self.quantity\n\n@dataclass(frozen=True) class Order: # the Context customer: Customer cart: Sequence[LineItem] promotion: Optional[Callable[['Order'], Decimal]] = None\n\ndef total(self) -> Decimal: totals = (item.total() for item in self.cart) return sum(totals, start=Decimal(0))\n\ndef due(self) -> Decimal: if self.promotion is None:\n\n3 I had to reimplement Order with @dataclass due to a bug in Mypy. You may ignore this detail, because this class works with NamedTuple as well, just like in Example 10-1. If Order is a NamedTuple, Mypy 0.910 crashes when checking the type hint for promotion. I tried adding # type ignore to that specific line, but Mypy crashed anyway. Mypy handles the same type hint correctly if Order is built with @dataclass. Issue #9397 is unresolved as of July 19, 2021. Hopefully it will be fixed by the time you read this.\n\nCase Study: Refactoring Strategy\n\n|\n\n347\n\ndiscount = Decimal(0) else: discount = self.promotion(self) return self.total() - discount\n\ndef __repr__(self): return f'<Order total: {self.total():.2f} due: {self.due():.2f}>'\n\ndef fidelity_promo(order: Order) -> Decimal: \"\"\"5% discount for customers with 1000 or more fidelity points\"\"\" if order.customer.fidelity >= 1000: return order.total() * Decimal('0.05') return Decimal(0)\n\ndef bulk_item_promo(order: Order) -> Decimal: \"\"\"10% discount for each LineItem with 20 or more units\"\"\" discount = Decimal(0) for item in order.cart: if item.quantity >= 20: discount += item.total() * Decimal('0.1') return discount\n\ndef large_order_promo(order: Order) -> Decimal: \"\"\"7% discount for orders with 10 or more distinct items\"\"\" distinct_items = {item.product for item in order.cart} if len(distinct_items) >= 10: return order.total() * Decimal('0.07') return Decimal(0)\n\nThis type hint says: promotion may be None, or it may be a callable that takes an Order argument and returns a Decimal.\n\nTo compute a discount, call the self.promotion callable, passing self as an argument. See the following tip for the reason.\n\nNo abstract class.\n\nEach strategy is a function.\n\n348\n\n|\n\nChapter 10: Design Patterns with First-Class Functions\n\nWhy self.promotion(self)?\n\nIn the Order class, promotion is not a method. It’s an instance attribute that happens to be callable. So the first part of the expres‐ sion, self.promotion, retrieves that callable. To invoke it, we must provide an instance of Order, which in this case is self. That’s why self appears twice in that expression.\n\n“Methods Are Descriptors” on page 898 will explain the mechanism that binds methods to instances automatically. It does not apply to promotion because it is not a method.\n\nThe code in Example 10-3 is shorter than Example 10-1. Using the new Order is also a bit simpler, as shown in the Example 10-4 doctests.\n\nExample 10-4. Sample usage of Order class with promotions as functions\n\n>>> joe = Customer('John Doe', 0) >>> ann = Customer('Ann Smith', 1100) >>> cart = [LineItem('banana', 4, Decimal('.5')), ... LineItem('apple', 10, Decimal('1.5')), ... LineItem('watermelon', 5, Decimal(5))] >>> Order(joe, cart, fidelity_promo) <Order total: 42.00 due: 42.00> >>> Order(ann, cart, fidelity_promo) <Order total: 42.00 due: 39.90> >>> banana_cart = [LineItem('banana', 30, Decimal('.5')), ... LineItem('apple', 10, Decimal('1.5'))] >>> Order(joe, banana_cart, bulk_item_promo) <Order total: 30.00 due: 28.50> >>> long_cart = [LineItem(str(item_code), 1, Decimal(1)) ... for item_code in range(10)] >>> Order(joe, long_cart, large_order_promo) <Order total: 10.00 due: 9.30> >>> Order(joe, cart, large_order_promo) <Order total: 42.00 due: 42.00>\n\nSame test fixtures as Example 10-1.\n\nTo apply a discount strategy to an Order, just pass the promotion function as an argument.\n\nA different promotion function is used here and in the next test.\n\nNote the callouts in Example 10-4—there is no need to instantiate a new promotion object with each new order: the functions are ready to use.\n\nCase Study: Refactoring Strategy\n\n|\n\n349\n\nIt is interesting to note that in Design Patterns, the authors suggest: “Strategy objects often make good flyweights.”4 A definition of the Flyweight pattern in another part of that work states: “A flyweight is a shared object that can be used in multiple contexts simultaneously.”5 The sharing is recommended to reduce the cost of creating a new concrete strategy object when the same strategy is applied over and over again with every new context—with every new Order instance, in our example. So, to overcome a drawback of the Strategy pattern—its runtime cost—the authors recommend apply‐ ing yet another pattern. Meanwhile, the line count and maintenance cost of your code are piling up.\n\nA thornier use case, with complex concrete strategies holding internal state, may require all the pieces of the Strategy and Flyweight design patterns combined. But often concrete strategies have no internal state; they only deal with data from the context. If that is the case, then by all means use plain old functions instead of coding single-method classes implementing a single-method interface declared in yet another class. A function is more lightweight than an instance of a user-defined class, and there is no need for Flyweight because each strategy function is created just once per Python process when it loads the module. A plain function is also “a shared object that can be used in multiple contexts simultaneously.”\n\nNow that we have implemented the Strategy pattern with functions, other possibili‐ ties emerge. Suppose you want to create a “metastrategy” that selects the best avail‐ able discount for a given Order. In the following sections we study additional refactorings that implement this requirement using a variety of approaches that lev‐ erage functions and modules as objects.\n\nChoosing the Best Strategy: Simple Approach Given the same customers and shopping carts from the tests in Example 10-4, we now add three additional tests in Example 10-5.\n\nExample 10-5. The best_promo function applies all discounts and returns the largest\n\n>>> Order(joe, long_cart, best_promo) <Order total: 10.00 due: 9.30> >>> Order(joe, banana_cart, best_promo) <Order total: 30.00 due: 28.50> >>> Order(ann, cart, best_promo) <Order total: 42.00 due: 39.90>\n\n4 See page 323 of Design Patterns.\n\n5 Ibid., p. 196.\n\n350\n\n|\n\nChapter 10: Design Patterns with First-Class Functions\n\nbest_promo selected the larger_order_promo for customer joe.\n\nHere joe got the discount from bulk_item_promo for ordering lots of bananas.\n\nChecking out with a simple cart, best_promo gave loyal customer ann the dis‐ count for the fidelity_promo.\n\nThe implementation of best_promo is very simple. See Example 10-6.\n\nExample 10-6. best_promo finds the maximum discount iterating over a list of functions\n\npromos = [fidelity_promo, bulk_item_promo, large_order_promo]\n\ndef best_promo(order: Order) -> Decimal: \"\"\"Compute the best discount available\"\"\" return max(promo(order) for promo in promos)\n\npromos: list of the strategies implemented as functions.\n\nbest_promo takes an instance of Order as argument, as do the other *_promo functions.\n\nUsing a generator expression, we apply each of the functions from promos to the order, and return the maximum discount computed.\n\nExample 10-6 is straightforward: promos is a list of functions. Once you get used to the idea that functions are first-class objects, it naturally follows that building data structures holding functions often makes sense.\n\nAlthough Example 10-6 works and is easy to read, there is some duplication that could lead to a subtle bug: to add a new promotion strategy, we need to code the function and remember to add it to the promos list, or else the new promotion will work when explicitly passed as an argument to Order, but will not be considered by best_promotion.\n\nRead on for a couple of solutions to this issue.\n\nFinding Strategies in a Module Modules in Python are also first-class objects, and the standard library provides sev‐ eral functions to handle them. The built-in globals is described as follows in the Python docs:\n\nCase Study: Refactoring Strategy\n\n|\n\n351\n\nglobals()\n\nReturn a dictionary representing the current global symbol table. This is always the dictionary of the current module (inside a function or method, this is the module where it is defined, not the module from which it is called).\n\nExample 10-7 is a somewhat hackish way of using globals to help best_promo auto‐ matically find the other available *_promo functions.\n\nExample 10-7. The promos list is built by introspection of the module global namespace\n\nfrom decimal import Decimal from strategy import Order from strategy import ( fidelity_promo, bulk_item_promo, large_order_promo )\n\npromos = [promo for name, promo in globals().items() if name.endswith('_promo') and name != 'best_promo' ]\n\ndef best_promo(order: Order) -> Decimal: \"\"\"Compute the best discount available\"\"\" return max(promo(order) for promo in promos)\n\nImport the promotion functions so they are available in the global namespace.6\n\nIterate over each item in the dict returned by globals().\n\nSelect only values where the name ends with the _promo suffix and…\n\n…filter out best_promo itself, to avoid an infinite recursion when best_promo is called.\n\nNo changes in best_promo.\n\nAnother way of collecting the available promotions would be to create a module and put all the strategy functions there, except for best_promo.\n\nIn Example 10-8, the only significant change is that the list of strategy functions is built by introspection of a separate module called promotions. Note that\n\n6 flake8 and VS Code both complain that these names are imported but not used. By definition, static analysis\n\ntools cannot understand the dynamic nature of Python. If we heed every advice from such tools, we’ll soon be writing grim and verbose Java-like code with Python syntax.\n\n352\n\n|\n\nChapter 10: Design Patterns with First-Class Functions\n\nExample 10-8 depends on importing the promotions module as well as inspect, which provides high-level introspection functions.\n\nExample 10-8. The promos list is built by introspection of a new promotions module\n\nfrom decimal import Decimal import inspect\n\nfrom strategy import Order import promotions\n\npromos = [func for _, func in inspect.getmembers(promotions, inspect.isfunction)]\n\ndef best_promo(order: Order) -> Decimal: \"\"\"Compute the best discount available\"\"\" return max(promo(order) for promo in promos)\n\nThe function inspect.getmembers returns the attributes of an object—in this case, the promotions module—optionally filtered by a predicate (a boolean function). We use inspect.isfunction to get only the functions from the module.\n\nExample 10-8 works regardless of the names given to the functions; all that matters is that the promotions module contains only functions that calculate discounts given orders. Of course, this is an implicit assumption of the code. If someone were to cre‐ ate a function with a different signature in the promotions module, then best_promo would break while trying to apply it to an order.\n\nWe could add more stringent tests to filter the functions, by inspecting their argu‐ ments for instance. The point of Example 10-8 is not to offer a complete solution, but to highlight one possible use of module introspection.\n\nA more explicit alternative to dynamically collecting promotional discount functions would be to use a simple decorator. That’s next.\n\nDecorator-Enhanced Strategy Pattern Recall that our main issue with Example 10-6 is the repetition of the function names in their definitions and then in the promos list used by the best_promo function to determine the highest discount applicable. The repetition is problematic because someone may add a new promotional strategy function and forget to manually add it to the promos list—in which case, best_promo will silently ignore the new strategy, introducing a subtle bug in the system. Example 10-9 solves this problem with the technique covered in “Registration Decorators” on page 308.\n\nDecorator-Enhanced Strategy Pattern\n\n|\n\n353\n\nExample 10-9. The promos list is filled by the Promotion decorator\n\nPromotion = Callable[[Order], Decimal]\n\npromos: list[Promotion] = []\n\ndef promotion(promo: Promotion) -> Promotion: promos.append(promo) return promo\n\ndef best_promo(order: Order) -> Decimal: \"\"\"Compute the best discount available\"\"\" return max(promo(order) for promo in promos)\n\n@promotion def fidelity(order: Order) -> Decimal: \"\"\"5% discount for customers with 1000 or more fidelity points\"\"\" if order.customer.fidelity >= 1000: return order.total() * Decimal('0.05') return Decimal(0)\n\n@promotion def bulk_item(order: Order) -> Decimal: \"\"\"10% discount for each LineItem with 20 or more units\"\"\" discount = Decimal(0) for item in order.cart: if item.quantity >= 20: discount += item.total() * Decimal('0.1') return discount\n\n@promotion def large_order(order: Order) -> Decimal: \"\"\"7% discount for orders with 10 or more distinct items\"\"\" distinct_items = {item.product for item in order.cart} if len(distinct_items) >= 10: return order.total() * Decimal('0.07') return Decimal(0)\n\nThe promos list is a module global, and starts empty.\n\nPromotion is a registration decorator: it returns the promo function unchanged, after appending it to the promos list.\n\nNo changes needed to best_promo, because it relies on the promos list.\n\n354\n\n|\n\nChapter 10: Design Patterns with First-Class Functions\n\nAny function decorated by @promotion will be added to promos.\n\nThis solution has several advantages over the others presented before:\n\nThe promotion strategy functions don’t have to use special names—no need for the _promo suffix.\n\nThe @promotion decorator highlights the purpose of the decorated function, and also makes it easy to temporarily disable a promotion: just comment out the decorator.\n\nPromotional discount strategies may be defined in other modules, anywhere in the system, as long as the @promotion decorator is applied to them.\n\nIn the next section, we discuss Command—another design pattern that is sometimes implemented via single-method classes when plain functions would do.\n\nThe Command Pattern Command is another design pattern that can be simplified by the use of functions passed as arguments. Figure 10-2 shows the arrangement of classes in the Command pattern.\n\nFigure 10-2. UML class diagram for menu-driven text editor implemented with the Command design pattern. Each command may have a different receiver: the object that implements the action. For PasteCommand, the receiver is the Document. For OpenCom mand, the receiver is the application.\n\nThe Command Pattern\n\n|\n\n355\n\nThe goal of Command is to decouple an object that invokes an operation (the invoker) from the provider object that implements it (the receiver). In the example from Design Patterns, each invoker is a menu item in a graphical application, and the receivers are the document being edited or the application itself.\n\nThe idea is to put a Command object between the two, implementing an interface with a single method, execute, which calls some method in the receiver to perform the desired operation. That way the invoker does not need to know the interface of the receiver, and different receivers can be adapted through different Command subclasses. The invoker is configured with a concrete command and calls its execute method to operate it. Note in Figure 10-2 that MacroCommand may store a sequence of com‐ mands; its execute() method calls the same method in each command stored.\n\nQuoting from Design Patterns, “Commands are an object-oriented replacement for callbacks.” The question is: do we need an object-oriented replacement for callbacks? Sometimes yes, but not always.\n\nInstead of giving the invoker a Command instance, we can simply give it a function. Instead of calling command.execute(), the invoker can just call command(). The Macro Command can be implemented with a class implementing __call__. Instances of MacroCommand would be callables, each holding a list of functions for future invoca‐ tion, as implemented in Example 10-10.\n\nExample 10-10. Each instance of MacroCommand has an internal list of commands\n\nclass MacroCommand: \"\"\"A command that executes a list of commands\"\"\"\n\ndef __init__(self, commands): self.commands = list(commands)\n\ndef __call__(self): for command in self.commands: command()\n\nBuilding a list from the commands arguments ensures that it is iterable and keeps a local copy of the command references in each MacroCommand instance.\n\nWhen an instance of MacroCommand is invoked, each command in self.commands is called in sequence.\n\nMore advanced uses of the Command pattern—to support undo, for example—may require more than a simple callback function. Even then, Python provides a couple of alternatives that deserve consideration:\n\n356\n\n|\n\nChapter 10: Design Patterns with First-Class Functions\n\nA callable instance like MacroCommand in Example 10-10 can keep whatever state is necessary, and provide extra methods in addition to __call__.\n\nA closure can be used to hold the internal state of a function between calls.\n\nThis concludes our rethinking of the Command pattern with first-class functions. At a high level, the approach here was similar to the one we applied to Strategy: replac‐ ing with callables the instances of a participant class that implemented a single- method interface. After all, every Python callable implements a single-method interface, and that method is named __call__.\n\nChapter Summary As Peter Norvig pointed out a couple of years after the classic Design Patterns book appeared, “16 of 23 patterns have qualitatively simpler implementation in Lisp or Dylan than in C++ for at least some uses of each pattern” (slide 9 of Norvig’s “Design Patterns in Dynamic Languages” presentation). Python shares some of the dynamic features of the Lisp and Dylan languages, in particular, first-class functions, our focus in this part of the book.\n\nFrom the same talk quoted at the start of this chapter, in reflecting on the 20th anni‐ versary of Design Patterns: Elements of Reusable Object-Oriented Software, Ralph Johnson has stated that one of the failings of the book is: “Too much emphasis on patterns as end-points instead of steps in the design process.”7 In this chapter, we used the Strategy pattern as a starting point: a working solution that we could sim‐ plify using first-class functions.\n\nIn many cases, functions or callable objects provide a more natural way of imple‐ menting callbacks in Python than mimicking the Strategy or the Command patterns as described by Gamma, Helm, Johnson, and Vlissides in Design Patterns. The refac‐ toring of Strategy and the discussion of Command in this chapter are examples of a more general insight: sometimes you may encounter a design pattern or an API that requires that components implement an interface with a single method, and that method has a generic-sounding name such as “execute,” “run,” or “do_it.” Such pat‐ terns or APIs often can be implemented with less boilerplate code in Python using functions as first-class objects.\n\n7 “Root Cause Analysis of Some Faults in Design Patterns,” presented by Johnson at IME-USP, November 15,\n\n2014.\n\nChapter Summary\n\n|\n\n357\n\nFurther Reading “Recipe 8.21. Implementing the Visitor Pattern,” in the Python Cookbook, 3rd ed., presents an elegant implementation of the Visitor pattern in which a NodeVisitor class handles methods as first-class objects.\n\nOn the general topic of design patterns, the choice of readings for the Python pro‐ grammer is not as broad as what is available to other language communities.\n\nLearning Python Design Patterns, by Gennadiy Zlobin (Packt), is the only book that I have seen entirely devoted to patterns in Python. But Zlobin’s work is quite short (100 pages) and covers 8 of the original 23 design patterns.\n\nExpert Python Programming, by Tarek Ziadé (Packt), is one of the best intermediate- level Python books in the market, and its final chapter, “Useful Design Patterns,” presents several of the classic patterns from a Pythonic perspective.\n\nAlex Martelli has given several talks about Python design patterns. There is a video of his EuroPython 2011 presentation and a set of slides on his personal website. I’ve found different slide decks and videos over the years, of varying lengths, so it is worthwhile to do a thorough search for his name with the words “Python Design Pat‐ terns.” A publisher told me Martelli is working on a book about this subject. I will certainly get it when it comes out.\n\nThere are many books about design patterns in the context of Java, but among them the one I like most is Head First Design Patterns, 2nd ed., by Eric Freeman and Elisa‐ beth Robson (O’Reilly). It explains 16 of the 23 classic patterns. If you like the wacky style of the Head First series and need an introduction to this topic, you will love that work. It is Java-centric, but the second edition was updated to reflect the addition of first-class functions in Java, making some of the examples closer to code we’d write in Python.\n\nFor a fresh look at patterns from the point of view of a dynamic language with duck typing and first-class functions, Design Patterns in Ruby by Russ Olsen (Addison- Wesley) has many insights that are also applicable to Python. In spite of their many syntactic differences, at the semantic level Python and Ruby are closer to each other than to Java or C++.\n\nIn “Design Patterns in Dynamic Languages” (slides), Peter Norvig shows how first- class functions (and other dynamic features) make several of the original design pat‐ terns either simpler or unnecessary.\n\nThe introduction of the original Design Patterns book by Gamma et al. is worth the price of the book—more than the catalog of 23 patterns, which includes recipes rang‐ ing from very important to rarely useful. The widely quoted design principles,\n\n358\n\n|\n\nChapter 10: Design Patterns with First-Class Functions\n\n“Program to an interface, not an implementation” and “Favor object composition over class inheritance,” both come from that introduction.\n\nThe application of patterns to design originated with the architect Christopher Alexander et al., presented in the book A Pattern Language (Oxford University Press). Alexander’s idea is to create a standard vocabulary allowing teams to share common design decisions while designing buildings. M. J. Dominus wrote “‘Design Patterns’ Aren’t”, an intriguing slide deck and postscript text arguing that Alexander’s original vision of patterns is more profound, more human, and also applicable to software engineering.\n\nSoapbox Python has first-class functions and first-class types, features that Norvig claims affect 10 of the 23 patterns (slide 10 of “Design Patterns in Dynamic Languages”). In Chap‐ ter 9, we saw that Python also has generic functions (“Single Dispatch Generic Func‐ tions” on page 324), a limited form of the CLOS multimethods that Gamma et al. suggest as a simpler way to implement the classic Visitor pattern. Norvig, on the other hand, says that multimethods simplify the Builder pattern (slide 10). Matching design patterns to language features is not an exact science.\n\nIn classrooms around the world, design patterns are frequently taught using Java examples. I’ve heard more than one student claim that they were led to believe that the original design patterns are useful in any implementation language. It turns out that the “classic” 23 patterns from Design Patterns apply to “classic” Java very well in spite of being originally presented mostly in the context of C++—a few have Small‐ talk examples in the book. But that does not mean every one of those patterns applies equally well in any language. The authors are explicit right at the beginning of their book that “some of our patterns are supported directly by the less common object- oriented languages” (recall full quote on the first page of this chapter).\n\nThe Python bibliography about design patterns is very thin, compared to that of Java, C++, or Ruby. In “Further Reading” on page 358 I mentioned Learning Python Design Patterns by Gennadiy Zlobin, which was published as recently as November 2013. In contrast, Russ Olsen’s Design Patterns in Ruby was published in 2007 and has 384 pages—284 more than Zlobin’s work.\n\nNow that Python is becoming increasingly popular in academia, let’s hope more will be written about design patterns in the context of this language. Also, Java 8 intro‐ duced method references and anonymous functions, and those highly anticipated features are likely to prompt fresh approaches to patterns in Java—recognizing that as languages evolve, so must our understanding of how to apply the classic design patterns.\n\nFurther Reading\n\n|\n\n359\n\nThe call of the Wild\n\nAs we collaborated to put the final touches to this book, tech reviewer Leonardo Rochael wondered:\n\nIf functions have a __call__ method, and methods are also callable, do __call__ methods also have a __call__ method?\n\nI don’t know if his discovery is useful, but it is a fun fact:\n\n>>> def turtle(): ... return 'eggs' ... >>> turtle() 'eggs' >>> turtle.__call__() 'eggs' >>> turtle.__call__.__call__() 'eggs' >>> turtle.__call__.__call__.__call__() 'eggs' >>> turtle.__call__.__call__.__call__.__call__() 'eggs' >>> turtle.__call__.__call__.__call__.__call__.__call__() 'eggs' >>> turtle.__call__.__call__.__call__.__call__.__call__.__call__() 'eggs' >>> turtle.__call__.__call__.__call__.__call__.__call__.__call__.__call__() 'eggs'\n\nTurtles all the way down!\n\n360\n\n|\n\nChapter 10: Design Patterns with First-Class Functions\n\nPART III Classes and Protocols\n\nCHAPTER 11 A Pythonic Object\n\nFor a library or framework to be Pythonic is to make it as easy and natural as possible for a Python programmer to pick up how to perform a task.\n\n—Martijn Faassen, creator of Python and JavaScript frameworks.1\n\nThanks to the Python Data Model, your user-defined types can behave as naturally as the built-in types. And this can be accomplished without inheritance, in the spirit of duck typing: you just implement the methods needed for your objects to behave as expected.\n\nIn previous chapters, we studied the behavior of many built-in objects. We will now build user-defined classes that behave as real Python objects. Your application classes probably don’t need and should not implement as many special methods as the examples in this chapter. But if you are writing a library or a framework, the pro‐ grammers who will use your classes may expect them to behave like the classes that Python provides. Fulfilling that expectation is one way of being “Pythonic.”\n\nThis chapter starts where Chapter 1 ended, by showing how to implement several special methods that are commonly seen in Python objects of many different types.\n\nIn this chapter, we will see how to:\n\nSupport the built-in functions that convert objects to other types (e.g., repr(), bytes(), complex(), etc.)\n\nImplement an alternative constructor as a class method • Extend the format mini-language used by f-strings, the format() built-in, and the str.format() method\n\n1 From Faassen’s blog post, “What is Pythonic?”\n\n363\n\nProvide read-only access to attributes • Make an object hashable for use in sets and as dict keys • Save memory with the use of __slots__\n\nWe’ll do all that as we develop Vector2d, a simple two-dimensional Euclidean vector type. This code will be the foundation of an N-dimensional vector class in Chapter 12.\n\nThe evolution of the example will be paused to discuss two conceptual topics:\n\nHow and when to use the @classmethod and @staticmethod decorators\n\nPrivate and protected attributes in Python: usage, conventions, and limitations\n\nWhat’s New in This Chapter I added a new epigraph and a few words in the second paragraph of the chapter to address the concept of “Pythonic”—which was only discussed at the very end in the first edition.\n\n“Formatted Displays” on page 370 was updated to mention f-strings, introduced in Python 3.6. It’s a small change because f-strings support the same formatting mini- language as the format() built-in and the str.format() method, so any previously implemented __format__ methods simply work with f-strings.\n\nThe rest of the chapter barely changed—the special methods are mostly the same since Python 3.0, and the core ideas appeared in Python 2.2.\n\nLet’s get started with the object representation methods.\n\nObject Representations Every object-oriented language has at least one standard way of getting a string repre‐ sentation from any object. Python has two:\n\nrepr()\n\nReturn a string representing the object as the developer wants to see it. It’s what you get when the Python console or a debugger shows an object.\n\nstr()\n\nReturn a string representing the object as the user wants to see it. It’s what you get when you print() an object.\n\nThe special methods __repr__ and __str__ support repr() and str(), as we saw in Chapter 1.\n\n364\n\n|\n\nChapter 11: A Pythonic Object\n\nThere are two additional special methods to support alternative representations of objects: __bytes__ and __format__. The __bytes__ method is analogous to __str__: it’s called by bytes() to get the object represented as a byte sequence. Regarding __format__, it is used by f-strings, by the built-in function format(), and by the str.format() method. They call obj.__format__(format_spec) to get string dis‐ plays of objects using special formatting codes. We’ll cover __bytes__ in the next example, and __format__ after that.\n\nIf you’re coming from Python 2, remember that in Python 3 __repr__, __str__, and __format__ must always return Unicode strings (type str). Only __bytes__ is supposed to return a byte sequence (type bytes).\n\nVector Class Redux In order to demonstrate the many methods used to generate object representations, we’ll use a Vector2d class similar to the one we saw in Chapter 1. We will build on it in this and future sections. Example 11-1 illustrates the basic behavior we expect from a Vector2d instance.\n\nExample 11-1. Vector2d instances have several representations\n\n>>> v1 = Vector2d(3, 4) >>> print(v1.x, v1.y) 3.0 4.0 >>> x, y = v1 >>> x, y (3.0, 4.0) >>> v1 Vector2d(3.0, 4.0) >>> v1_clone = eval(repr(v1)) >>> v1 == v1_clone True >>> print(v1) (3.0, 4.0) >>> octets = bytes(v1) >>> octets b'd\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x08@\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x10@' >>> abs(v1) 5.0 >>> bool(v1), bool(Vector2d(0, 0)) (True, False)\n\nVector Class Redux\n\n|\n\n365\n\nThe components of a Vector2d can be accessed directly as attributes (no getter method calls).\n\nA Vector2d can be unpacked to a tuple of variables.\n\nThe repr of a Vector2d emulates the source code for constructing the instance.\n\nUsing eval here shows that the repr of a Vector2d is a faithful representation of its constructor call.2\n\nVector2d supports comparison with ==; this is useful for testing.\n\nprint calls str, which for Vector2d produces an ordered pair display.\n\nbytes uses the __bytes__ method to produce a binary representation.\n\nabs uses the __abs__ method to return the magnitude of the Vector2d.\n\nbool uses the __bool__ method to return False for a Vector2d of zero magni‐ tude or True otherwise.\n\nVector2d from Example 11-1 is implemented in vector2d_v0.py (Example 11-2). The code is based on Example 1-2, except for the methods for the + and * operations, which we’ll see later in Chapter 16. We’ll add the method for == since it’s useful for testing. At this point, Vector2d uses several special methods to provide operations that a Pythonista expects in a well-designed object.\n\nExample 11-2. vector2d_v0.py: methods so far are all special methods\n\nfrom array import array import math\n\nclass Vector2d: typecode = 'd'\n\ndef __init__(self, x, y): self.x = float(x) self.y = float(y)\n\ndef __iter__(self): return (i for i in (self.x, self.y))\n\n2 I used eval to clone the object here just to make a point about repr; to clone an instance, the copy.copy\n\nfunction is safer and faster.\n\n366\n\n|\n\nChapter 11: A Pythonic Object",
      "page_number": 367
    },
    {
      "number": 20,
      "title": "Segment 20 (pages 388-410)",
      "start_page": 388,
      "end_page": 410,
      "detection_method": "synthetic",
      "content": "def __repr__(self): class_name = type(self).__name__ return '{}({!r}, {!r})'.format(class_name, *self)\n\ndef __str__(self): return str(tuple(self))\n\ndef __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self)))\n\ndef __eq__(self, other): return tuple(self) == tuple(other)\n\ndef __abs__(self): return math.hypot(self.x, self.y)\n\ndef __bool__(self): return bool(abs(self))\n\ntypecode is a class attribute we’ll use when converting Vector2d instances to/ from bytes.\n\nConverting x and y to float in __init__ catches errors early, which is helpful in case Vector2d is called with unsuitable arguments.\n\n__iter__ makes a Vector2d iterable; this is what makes unpacking work (e.g, x, y = my_vector). We implement it simply by using a generator expression to yield the components one after the other.3\n\n__repr__ builds a string by interpolating the components with {!r} to get their repr; because Vector2d is iterable, *self feeds the x and y components to format.\n\nFrom an iterable Vector2d, it’s easy to build a tuple for display as an ordered pair.\n\nTo generate bytes, we convert the typecode to bytes and concatenate…\n\n…bytes converted from an array built by iterating over the instance.\n\n3 This line could also be written as yield self.x; yield.self.y. I have a lot more to say about the __iter__\n\nspecial method, generator expressions, and the yield keyword in Chapter 17.\n\nVector Class Redux\n\n|\n\n367\n\nTo quickly compare all components, build tuples out of the operands. This works for operands that are instances of Vector2d, but has issues. See the following warning.\n\nThe magnitude is the length of the hypotenuse of the right triangle formed by the x and y components.\n\n__bool__ uses abs(self) to compute the magnitude, then converts it to bool, so 0.0 becomes False, nonzero is True.\n\nMethod __eq__ in Example 11-2 works for Vector2d operands but also returns True when comparing Vector2d instances to other iterables holding the same numeric values (e.g., Vector(3, 4) == [3, 4]). This may be considered a feature or a bug. Further discus‐ sion needs to wait until Chapter 16, when we cover operator over‐ loading.\n\nWe have a fairly complete set of basic methods, but we still need a way to rebuild a Vector2d from the binary representation produced by bytes().\n\nAn Alternative Constructor Since we can export a Vector2d as bytes, naturally we need a method that imports a Vector2d from a binary sequence. Looking at the standard library for inspiration, we find that array.array has a class method named .frombytes that suits our purpose —we saw it in “Arrays” on page 59. We adopt its name and use its functionality in a class method for Vector2d in vector2d_v1.py (Example 11-3).\n\nExample 11-3. Part of vector2d_v1.py: this snippet shows only the frombytes class method, added to the Vector2d definition in vector2d_v0.py (Example 11-2)\n\n@classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(*memv)\n\nThe classmethod decorator modifies a method so it can be called directly on a class.\n\nNo self argument; instead, the class itself is passed as the first argument—con‐ ventionally named cls.\n\n368\n\n|\n\nChapter 11: A Pythonic Object\n\nRead the typecode from the first byte.\n\nCreate a memoryview from the octets binary sequence and use the typecode to cast it.4\n\nUnpack the memoryview resulting from the cast into the pair of arguments needed for the constructor.\n\nI just used a classmethod decorator and it is very Python specific, so let’s have a word about it.\n\nclassmethod Versus staticmethod The classmethod decorator is not mentioned in the Python tutorial, and neither is staticmethod. Anyone who has learned OO in Java may wonder why Python has both of these decorators and not just one of them.\n\nLet’s start with classmethod. Example 11-3 shows its use: to define a method that operates on the class and not on instances. classmethod changes the way the method is called, so it receives the class itself as the first argument, instead of an instance. Its most common use is for alternative constructors, like frombytes in Example 11-3. Note how the last line of frombytes actually uses the cls argument by invoking it to build a new instance: cls(*memv).\n\nIn contrast, the staticmethod decorator changes a method so that it receives no spe‐ cial first argument. In essence, a static method is just like a plain function that hap‐ pens to live in a class body, instead of being defined at the module level. Example 11-4 contrasts the operation of classmethod and staticmethod.\n\nExample 11-4. Comparing behaviors of classmethod and staticmethod\n\n>>> class Demo: ... @classmethod ... def klassmeth(*args): ... return args ... @staticmethod ... def statmeth(*args): ... return args ... >>> Demo.klassmeth() (<class '__main__.Demo'>,) >>> Demo.klassmeth('spam')\n\n4 We had a brief introduction to memoryview, explaining its .cast method, in “Memory Views” on page 62.\n\nclassmethod Versus staticmethod\n\n|\n\n369\n\n(<class '__main__.Demo'>, 'spam') >>> Demo.statmeth() () >>> Demo.statmeth('spam') ('spam',)\n\nklassmeth just returns all positional arguments.\n\nstatmeth does the same.\n\nNo matter how you invoke it, Demo.klassmeth receives the Demo class as the first argument.\n\nDemo.statmeth behaves just like a plain old function.\n\nThe classmethod decorator is clearly useful, but good use cases for staticmethod are very rare in my experience. Maybe the function is closely related even if it never touches the class, so you may want to place it nearby in the code. Even then, defining the function right before or after the class in the same module is close enough most of the time.5\n\nNow that we’ve seen what classmethod is good for (and that staticmethod is not very useful), let’s go back to the issue of object representation and see how to support formatted output.\n\nFormatted Displays The f-strings, the format() built-in function, and the str.format() method delegate the actual formatting to each type by calling their .__format__(format_spec) method. The format_spec is a formatting specifier, which is either:\n\nThe second argument in format(my_obj, format_spec), or • Whatever appears after the colon in a replacement field delimited with {} inside an f-string or the fmt in fmt.str.format()\n\n5 Leonardo Rochael, one of the technical reviewers of this book, disagrees with my low opinion of staticme\n\nthod, and recommends the blog post “The Definitive Guide on How to Use Static, Class or Abstract Methods in Python” by Julien Danjou as a counterargument. Danjou’s post is very good; I do recommend it. But it wasn’t enough to change my mind about staticmethod. You’ll have to decide for yourself.\n\n370\n\n|\n\nChapter 11: A Pythonic Object\n\nFor example:\n\n>>> brl = 1 / 4.82 # BRL to USD currency conversion rate >>> brl 0.20746887966804978 >>> format(brl, '0.4f') '0.2075' >>> '1 BRL = {rate:0.2f} USD'.format(rate=brl) '1 BRL = 0.21 USD' >>> f'1 USD = {1 / brl:0.2f} BRL' '1 USD = 4.82 BRL'\n\nFormatting specifier is '0.4f'.\n\nFormatting specifier is '0.2f'. The rate part in the replacement field is not part of the formatting specifier. It determines which keyword argument of .format() goes into that replacement field.\n\nAgain, the specifier is '0.2f'. The 1 / brl expression is not part of it.\n\nThe second and third callouts make an important point: a format string such as '{0.mass:5.3e}' actually uses two separate notations. The '0.mass' to the left of the colon is the field_name part of the replacement field syntax, and it can be an arbi‐ trary expression in an f-string. The '5.3e' after the colon is the formatting specifier. The notation used in the formatting specifier is called the Format Specification Mini- Language.\n\nIf f-strings, format(), and str.format() are new to you, classroom experience tells me it’s best to study the format() built-in function first, which uses just the Format Specification Mini-Language. After you get the gist of that, read “Formatted string literals” and “Format String Syntax” to learn about the {:} replacement field notation, used in f-strings and the str.format() method (includ‐ ing the !s, !r, and !a conversion flags). F-strings don’t make str.format() obsolete: most of the time f-strings solve the prob‐ lem, but sometimes it’s better to specify the formatting string else‐ where, and not where it will be rendered.\n\nA few built-in types have their own presentation codes in the Format Specification Mini-Language. For example—among several other codes—the int type supports b and x for base 2 and base 16 output, respectively, while float implements f for a fixed-point display and % for a percentage display:\n\n>>> format(42, 'b') '101010'\n\nFormatted Displays\n\n|\n\n371\n\n>>> format(2 / 3, '.1%') '66.7%'\n\nThe Format Specification Mini-Language is extensible because each class gets to interpret the format_spec argument as it likes. For instance, the classes in the date time module use the same format codes in the strftime() functions and in their __format__ methods. Here are a couple of examples using the format() built-in and the str.format() method:\n\n>>> from datetime import datetime >>> now = datetime.now() >>> format(now, '%H:%M:%S') '18:49:05' >>> \"It's now {:%I:%M %p}\".format(now) \"It's now 06:49 PM\"\n\nIf a class has no __format__, the method inherited from object returns str(my_object). Because Vector2d has a __str__, this works:\n\n>>> v1 = Vector2d(3, 4) >>> format(v1) '(3.0, 4.0)'\n\nHowever, if you pass a format specifier, object.__format__ raises TypeError:\n\n>>> format(v1, '.3f') Traceback (most recent call last): ... TypeError: non-empty format string passed to object.__format__\n\nWe will fix that by implementing our own format mini-language. The first step will be to assume the format specifier provided by the user is intended to format each float component of the vector. This is the result we want:\n\n>>> v1 = Vector2d(3, 4) >>> format(v1) '(3.0, 4.0)' >>> format(v1, '.2f') '(3.00, 4.00)' >>> format(v1, '.3e') '(3.000e+00, 4.000e+00)'\n\nExample 11-5 implements __format__ to produce the displays just shown.\n\nExample 11-5. Vector2d.__format__ method, take #1\n\n# inside the Vector2d class\n\ndef __format__(self, fmt_spec=''): components = (format(c, fmt_spec) for c in self) return '({}, {})'.format(*components)\n\n372\n\n|\n\nChapter 11: A Pythonic Object\n\nUse the format built-in to apply the fmt_spec to each vector component, build‐ ing an iterable of formatted strings.\n\nPlug the formatted strings in the formula '(x, y)'.\n\nNow let’s add a custom formatting code to our mini-language: if the format specifier ends with a 'p', we’ll display the vector in polar coordinates: <r, θ>, where r is the magnitude and θ (theta) is the angle in radians. The rest of the format specifier (whatever comes before the 'p') will be used as before.\n\nWhen choosing the letter for the custom format code, I avoided overlapping with codes used by other types. In Format Specifica‐ tion Mini-Language, we see that integers use the codes 'bcdoxXn', floats use 'eEfFgGn%', and strings use 's'. So I picked 'p' for polar coordinates. Because each class interprets these codes inde‐ pendently, reusing a code letter in a custom format for a new type is not an error, but may be confusing to users.\n\nTo generate polar coordinates, we already have the __abs__ method for the magni‐ tude, and we’ll code a simple angle method using the math.atan2() function to get the angle. This is the code:\n\n# inside the Vector2d class\n\ndef angle(self): return math.atan2(self.y, self.x)\n\nWith that, we can enhance our __format__ to produce polar coordinates. See Example 11-6.\n\nExample 11-6. Vector2d.__format__ method, take #2, now with polar coordinates\n\ndef __format__(self, fmt_spec=''): if fmt_spec.endswith('p'): fmt_spec = fmt_spec[:-1] coords = (abs(self), self.angle()) outer_fmt = '<{}, {}>' else: coords = self outer_fmt = '({}, {})' components = (format(c, fmt_spec) for c in coords) return outer_fmt.format(*components)\n\nFormat ends with 'p': use polar coordinates.\n\nRemove 'p' suffix from fmt_spec.\n\nFormatted Displays\n\n|\n\n373\n\nBuild tuple of polar coordinates: (magnitude, angle).\n\nConfigure outer format with angle brackets.\n\nOtherwise, use x, y components of self for rectangular coordinates.\n\nConfigure outer format with parentheses.\n\nGenerate iterable with components as formatted strings.\n\nPlug formatted strings into outer format.\n\nWith Example 11-6, we get results similar to these:\n\n>>> format(Vector2d(1, 1), 'p') '<1.4142135623730951, 0.7853981633974483>' >>> format(Vector2d(1, 1), '.3ep') '<1.414e+00, 7.854e-01>' >>> format(Vector2d(1, 1), '0.5fp') '<1.41421, 0.78540>'\n\nAs this section shows, it’s not hard to extend the Format Specification Mini- Language to support user-defined types.\n\nNow let’s move to a subject that’s not just about appearances: we will make our Vector2d hashable, so we can build sets of vectors, or use them as dict keys.\n\nA Hashable Vector2d As defined, so far our Vector2d instances are unhashable, so we can’t put them in a set:\n\n>>> v1 = Vector2d(3, 4) >>> hash(v1) Traceback (most recent call last): ... TypeError: unhashable type: 'Vector2d' >>> set([v1]) Traceback (most recent call last): ... TypeError: unhashable type: 'Vector2d'\n\nTo make a Vector2d hashable, we must implement __hash__ (__eq__ is also required, and we already have it). We also need to make vector instances immutable, as we’ve seen in “What Is Hashable” on page 84.\n\n374\n\n|\n\nChapter 11: A Pythonic Object\n\nRight now, anyone can do v1.x = 7, and there is nothing in the code to suggest that changing a Vector2d is forbidden. This is the behavior we want:\n\n>>> v1.x, v1.y (3.0, 4.0) >>> v1.x = 7 Traceback (most recent call last): ... AttributeError: can't set attribute\n\nWe’ll do that by making the x and y components read-only properties in Example 11-7.\n\nExample 11-7. vector2d_v3.py: only the changes needed to make Vector2d immutable are shown here; see full listing in Example 11-11\n\nclass Vector2d: typecode = 'd'\n\ndef __init__(self, x, y): self.__x = float(x) self.__y = float(y)\n\n@property def x(self): return self.__x\n\n@property def y(self): return self.__y\n\ndef __iter__(self): return (i for i in (self.x, self.y))\n\n# remaining methods: same as previous Vector2d\n\nUse exactly two leading underscores (with zero or one trailing underscore) to make an attribute private.6\n\nThe @property decorator marks the getter method of a property.\n\nThe getter method is named after the public property it exposes: x.\n\nJust return self.__x.\n\n6 The pros and cons of private attributes are the subject of the upcoming “Private and ‘Protected’ Attributes in\n\nPython” on page 382.\n\nA Hashable Vector2d\n\n|\n\n375\n\nRepeat the same formula for y property.\n\nEvery method that just reads the x, y components can stay as it was, reading the public properties via self.x and self.y instead of the private attribute, so this listing omits the rest of the code for the class.\n\nVector.x and Vector.y are examples of read-only properties. Read/write properties will be covered in Chapter 22, where we dive deeper into @property.\n\nNow that our vectors are reasonably safe from accidental mutation, we can imple‐ ment the __hash__ method. It should return an int and ideally take into account the hashes of the object attributes that are also used in the __eq__ method, because objects that compare equal should have the same hash. The __hash__ special method documentation suggests computing the hash of a tuple with the components, so that’s what we do in Example 11-8.\n\nExample 11-8. vector2d_v3.py: implementation of hash\n\n# inside class Vector2d:\n\ndef __hash__(self): return hash((self.x, self.y))\n\nWith the addition of the __hash__ method, we now have hashable vectors:\n\n>>> v1 = Vector2d(3, 4) >>> v2 = Vector2d(3.1, 4.2) >>> hash(v1), hash(v2) (1079245023883434373, 1994163070182233067) >>> {v1, v2} {Vector2d(3.1, 4.2), Vector2d(3.0, 4.0)}\n\nIt’s not strictly necessary to implement properties or otherwise protect the instance attributes to create a hashable type. Imple‐ menting __hash__ and __eq__ correctly is all it takes. But the value of a hashable object is never supposed to change, so this provided a good excuse to talk about read-only properties.\n\nIf you are creating a type that has a sensible scalar numeric value, you may also implement the __int__ and __float__ methods, invoked by the int() and float() constructors, which are used for type coercion in some contexts. There is also a\n\n376\n\n|\n\nChapter 11: A Pythonic Object\n\n__complex__ method to support the complex() built-in constructor. Perhaps Vec tor2d should provide __complex__, but I’ll leave that as an exercise for you.\n\nSupporting Positional Pattern Matching So far, Vector2d instances are compatible with keyword class patterns—covered in “Keyword Class Patterns” on page 193.\n\nIn Example 11-9, all of these keyword patterns work as expected.\n\nExample 11-9. Keyword patterns for Vector2d subjects—requires Python 3.10\n\ndef keyword_pattern_demo(v: Vector2d) -> None: match v: case Vector2d(x=0, y=0): print(f'{v!r} is null') case Vector2d(x=0): print(f'{v!r} is vertical') case Vector2d(y=0): print(f'{v!r} is horizontal') case Vector2d(x=x, y=y) if x==y: print(f'{v!r} is diagonal') case _: print(f'{v!r} is awesome')\n\nHowever, if you try to use a positional pattern like this:\n\ncase Vector2d(_, 0): print(f'{v!r} is horizontal')\n\nyou get:\n\nTypeError: Vector2d() accepts 0 positional sub-patterns (1 given)\n\nTo make Vector2d work with positional patterns, we need to add a class attribute named __match_args__ , listing the instance attributes in the order they will be used for positional pattern matching:\n\nclass Vector2d: __match_args__ = ('x', 'y')\n\n# etc...\n\nNow we can save a few keystrokes when writing patterns to match Vector2d subjects, as you can see in Example 11-10.\n\nExample 11-10. Positional patterns for Vector2d subjects—requires Python 3.10\n\ndef positional_pattern_demo(v: Vector2d) -> None: match v:\n\nSupporting Positional Pattern Matching\n\n|\n\n377\n\ncase Vector2d(0, 0): print(f'{v!r} is null') case Vector2d(0): print(f'{v!r} is vertical') case Vector2d(_, 0): print(f'{v!r} is horizontal') case Vector2d(x, y) if x==y: print(f'{v!r} is diagonal') case _: print(f'{v!r} is awesome')\n\nThe __match_args__ class attribute does not need to include all public instance attributes. In particular, if the class __init__ has required and optional arguments that are assigned to instance attributes, it may be reasonable to name the required arguments in __match_args__, but not the optional ones.\n\nLet’s step back and review what we’ve coded so far in Vector2d.\n\nComplete Listing of Vector2d, Version 3 We have been working on Vector2d for a while, showing just snippets, so Example 11-11 is a consolidated, full listing of vector2d_v3.py, including the doctests I used when developing it.\n\nExample 11-11. vector2d_v3.py: the full monty\n\n\"\"\" A two-dimensional vector class\n\n>>> v1 = Vector2d(3, 4) >>> print(v1.x, v1.y) 3.0 4.0 >>> x, y = v1 >>> x, y (3.0, 4.0) >>> v1 Vector2d(3.0, 4.0) >>> v1_clone = eval(repr(v1)) >>> v1 == v1_clone True >>> print(v1) (3.0, 4.0) >>> octets = bytes(v1) >>> octets b'd\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x08@\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x10@' >>> abs(v1) 5.0 >>> bool(v1), bool(Vector2d(0, 0)) (True, False)\n\n378\n\n|\n\nChapter 11: A Pythonic Object\n\nTest of ``.frombytes()`` class method:\n\n>>> v1_clone = Vector2d.frombytes(bytes(v1)) >>> v1_clone Vector2d(3.0, 4.0) >>> v1 == v1_clone True\n\nTests of ``format()`` with Cartesian coordinates:\n\n>>> format(v1) '(3.0, 4.0)' >>> format(v1, '.2f') '(3.00, 4.00)' >>> format(v1, '.3e') '(3.000e+00, 4.000e+00)'\n\nTests of the ``angle`` method::\n\n>>> Vector2d(0, 0).angle() 0.0 >>> Vector2d(1, 0).angle() 0.0 >>> epsilon = 10**-8 >>> abs(Vector2d(0, 1).angle() - math.pi/2) < epsilon True >>> abs(Vector2d(1, 1).angle() - math.pi/4) < epsilon True\n\nTests of ``format()`` with polar coordinates:\n\n>>> format(Vector2d(1, 1), 'p') # doctest:+ELLIPSIS '<1.414213..., 0.785398...>' >>> format(Vector2d(1, 1), '.3ep') '<1.414e+00, 7.854e-01>' >>> format(Vector2d(1, 1), '0.5fp') '<1.41421, 0.78540>'\n\nTests of `x` and `y` read-only properties:\n\n>>> v1.x, v1.y (3.0, 4.0) >>> v1.x = 123 Traceback (most recent call last): ... AttributeError: can't set attribute 'x'\n\nComplete Listing of Vector2d, Version 3\n\n|\n\n379\n\nTests of hashing:\n\n>>> v1 = Vector2d(3, 4) >>> v2 = Vector2d(3.1, 4.2) >>> len({v1, v2}) 2\n\n\"\"\"\n\nfrom array import array import math\n\nclass Vector2d: __match_args__ = ('x', 'y')\n\ntypecode = 'd'\n\ndef __init__(self, x, y): self.__x = float(x) self.__y = float(y)\n\n@property def x(self): return self.__x\n\n@property def y(self): return self.__y\n\ndef __iter__(self): return (i for i in (self.x, self.y))\n\ndef __repr__(self): class_name = type(self).__name__ return '{}({!r}, {!r})'.format(class_name, *self)\n\ndef __str__(self): return str(tuple(self))\n\ndef __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self)))\n\ndef __eq__(self, other): return tuple(self) == tuple(other)\n\ndef __hash__(self): return hash((self.x, self.y))\n\ndef __abs__(self):\n\n380\n\n|\n\nChapter 11: A Pythonic Object\n\nreturn math.hypot(self.x, self.y)\n\ndef __bool__(self): return bool(abs(self))\n\ndef angle(self): return math.atan2(self.y, self.x)\n\ndef __format__(self, fmt_spec=''): if fmt_spec.endswith('p'): fmt_spec = fmt_spec[:-1] coords = (abs(self), self.angle()) outer_fmt = '<{}, {}>' else: coords = self outer_fmt = '({}, {})' components = (format(c, fmt_spec) for c in coords) return outer_fmt.format(*components)\n\n@classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(*memv)\n\nTo recap, in this and the previous sections, we saw some essential special methods that you may want to implement to have a full-fledged object.\n\nYou should only implement these special methods if your applica‐ tion needs them. End users don’t care if the objects that make up the application are “Pythonic” or not.\n\nOn the other hand, if your classes are part of a library for other Python programmers to use, you can’t really guess what they will do with your objects, and they may expect more of the “Pythonic” behaviors we are describing.\n\nAs coded in Example 11-11, Vector2d is a didactic example with a laundry list of spe‐ cial methods related to object representation, not a template for every user-defined class.\n\nIn the next section, we’ll take a break from Vector2d to discuss the design and draw‐ backs of the private attribute mechanism in Python—the double-underscore prefix in self.__x.\n\nComplete Listing of Vector2d, Version 3\n\n|\n\n381\n\nPrivate and “Protected” Attributes in Python In Python, there is no way to create private variables like there is with the private modifier in Java. What we have in Python is a simple mechanism to prevent acciden‐ tal overwriting of a “private” attribute in a subclass.\n\nConsider this scenario: someone wrote a class named Dog that uses a mood instance attribute internally, without exposing it. You need to subclass Dog as Beagle. If you create your own mood instance attribute without being aware of the name clash, you will clobber the mood attribute used by the methods inherited from Dog. This would be a pain to debug.\n\nTo prevent this, if you name an instance attribute in the form __mood (two leading underscores and zero or at most one trailing underscore), Python stores the name in the instance __dict__ prefixed with a leading underscore and the class name, so in the Dog class, __mood becomes _Dog__mood, and in Beagle it’s _Beagle__mood. This language feature goes by the lovely name of name mangling.\n\nExample 11-12 shows the result in the Vector2d class from Example 11-7.\n\nExample 11-12. Private attribute names are “mangled” by prefixing the _ and the class name\n\n>>> v1 = Vector2d(3, 4) >>> v1.__dict__ {'_Vector2d__y': 4.0, '_Vector2d__x': 3.0} >>> v1._Vector2d__x 3.0\n\nName mangling is about safety, not security: it’s designed to prevent accidental access and not malicious prying. Figure 11-1 illustrates another safety device.\n\nAnyone who knows how private names are mangled can read the private attribute directly, as the last line of Example 11-12 shows—that’s actually useful for debugging and serialization. They can also directly assign a value to a private component of a Vector2d by writing v1._Vector2d__x = 7. But if you are doing that in production code, you can’t complain if something blows up.\n\nThe name mangling functionality is not loved by all Pythonistas, and neither is the skewed look of names written as self.__x. Some prefer to avoid this syntax and use just one underscore prefix to “protect” attributes by convention (e.g., self._x). Crit‐ ics of the automatic double-underscore mangling suggest that concerns about acci‐ dental attribute clobbering should be addressed by naming conventions. Ian Bicking —creator of pip, virtualenv, and other projects—wrote:\n\n382\n\n|\n\nChapter 11: A Pythonic Object\n\nNever, ever use two leading underscores. This is annoyingly private. If name clashes are a concern, use explicit name mangling instead (e.g., _MyThing_blahblah). This is essentially the same thing as double-underscore, only it’s transparent where double underscore obscures.7\n\nFigure 11-1. A cover on a switch is a safety device, not a security one: it prevents acci‐ dents, not sabotage.\n\nThe single underscore prefix has no special meaning to the Python interpreter when used in attribute names, but it’s a very strong convention among Python program‐ mers that you should not access such attributes from outside the class.8 It’s easy to respect the privacy of an object that marks its attributes with a single _, just as it’s easy respect the convention that variables in ALL_CAPS should be treated as constants.\n\nAttributes with a single _ prefix are called “protected” in some corners of the Python documentation.9 The practice of “protecting” attributes by convention with the form self._x is widespread, but calling that a “protected” attribute is not so common. Some even call that a “private” attribute.\n\n7 From the “Paste Style Guide”.\n\n8 In modules, a single _ in front of a top-level name does have an effect: if you write from mymod import *, the names with a _ prefix are not imported from mymod. However, you can still write from mymod import _priva tefunc. This is explained in the Python Tutorial, section 6.1., “More on Modules”.\n\n9 One example is in the gettext module docs.\n\nPrivate and “Protected” Attributes in Python\n\n|\n\n383\n\nTo conclude: the Vector2d components are “private” and our Vector2d instances are “immutable”—with scare quotes—because there is no way to make them really pri‐ vate and immutable.10\n\nWe’ll now come back to our Vector2d class. In the next section, we cover a special attribute (not a method) that affects the internal storage of an object, with potentially huge impact on the use of memory but little effect on its public interface: __slots__.\n\nSaving Memory with __slots__ By default, Python stores the attributes of each instance in a dict named __dict__. As we saw in “Practical Consequences of How dict Works” on page 102, a dict has a significant memory overhead—even with the optimizations mentioned in that sec‐ tion. But if you define a class attribute named __slots__ holding a sequence of attribute names, Python uses an alternative storage model for the instance attributes: the attributes named in __slots__ are stored in a hidden array or references that use less memory than a dict. Let’s see how that works through simple examples, starting with Example 11-13.\n\nExample 11-13. The Pixel class uses __slots__\n\n>>> class Pixel: ... __slots__ = ('x', 'y') ... >>> p = Pixel() >>> p.__dict__ Traceback (most recent call last): ... AttributeError: 'Pixel' object has no attribute '__dict__' >>> p.x = 10 >>> p.y = 20 >>> p.color = 'red' Traceback (most recent call last): ... AttributeError: 'Pixel' object has no attribute 'color'\n\n__slots__ must be present when the class is created; adding or changing it later has no effect. The attribute names may be in a tuple or list, but I prefer a tuple to make it clear there’s no point in changing it.\n\n10 If this state of affairs depresses you, and makes you wish Python was more like Java in this regard, don’t read\n\nmy discussion of the relative strength of the Java private modifier in “Soapbox” on page 394.\n\n384\n\n|\n\nChapter 11: A Pythonic Object\n\nCreate an instance of Pixel, because we see the effects of __slots__ on the instances.\n\nFirst effect: instances of Pixel have no __dict__.\n\nSet the p.x and p.y attributes normally.\n\nSecond effect: trying to set an attribute not listed in __slots__ raises AttributeError.\n\nSo far, so good. Now let’s create a subclass of Pixel in Example 11-14 to see the counterintuitive side of __slots__.\n\nExample 11-14. The OpenPixel is a subclass of Pixel\n\n>>> class OpenPixel(Pixel): ... pass ... >>> op = OpenPixel() >>> op.__dict__ {} >>> op.x = 8 >>> op.__dict__ {} >>> op.x 8 >>> op.color = 'green' >>> op.__dict__ {'color': 'green'}\n\nOpenPixel declares no attributes of its own.\n\nSurprise: instances of OpenPixel have a __dict__.\n\nIf you set attribute x (named in the __slots__ of the base class Pixel)…\n\n…it is not stored in the instance __dict__…\n\n…but it is stored in the hidden array of references in the instance.\n\nIf you set an attribute not named in the __slots__…\n\n…it is stored in the instance __dict__.\n\nSaving Memory with __slots__\n\n|\n\n385\n\nExample 11-14 shows that the effect of __slots__ is only partially inherited by a sub‐ class. To make sure that instances of a subclass have no __dict__, you must declare __slots__ again in the subclass.\n\nIf you declare __slots__ = () (an empty tuple), then the instances of the subclass will have no __dict__ and will only accept the attributes named in the __slots__ of the base class.\n\nIf you want a subclass to have additional attributes, name them in __slots__, as shown in Example 11-15.\n\nExample 11-15. The ColorPixel, another subclass of Pixel\n\n>>> class ColorPixel(Pixel): ... __slots__ = ('color',) >>> cp = ColorPixel() >>> cp.__dict__ Traceback (most recent call last): ... AttributeError: 'ColorPixel' object has no attribute '__dict__' >>> cp.x = 2 >>> cp.color = 'blue' >>> cp.flavor = 'banana' Traceback (most recent call last): ... AttributeError: 'ColorPixel' object has no attribute 'flavor'\n\nEssentially, __slots__ of the superclasses are added to the __slots__ of the cur‐ rent class. Don’t forget that single-item tuples must have a trailing comma.\n\nColorPixel instances have no __dict__.\n\nYou can set the attributes declared in the __slots__ of this class and super‐ classes, but no other.\n\nIt’s possible to “save memory and eat it too”: if you add the '__dict__' name to the __slots__ list, your instances will keep attributes named in __slots__ in the per- instance array of references, but will also support dynamically created attributes, which will be stored in the usual __dict__. This is necessary if you want to use the @cached_property decorator (covered in “Step 5: Caching Properties with functools” on page 855).\n\nOf course, having '__dict__' in __slots__ may entirely defeat its purpose, depend‐ ing on the number of static and dynamic attributes in each instance and how they are used. Careless optimization is worse than premature optimization: you add complex‐ ity but may not get any benefit.\n\n386\n\n|\n\nChapter 11: A Pythonic Object\n\nAnother special per-instance attribute that you may want to keep is __weakref__, necessary for an object to support weak references (mentioned briefly in “del and Garbage Collection” on page 219). That attribute exists by default in instances of user-defined classes. However, if the class defines __slots__, and you need the instances to be targets of weak references, then you need to include '__weakref__' among the attributes named in __slots__.\n\nNow let’s see the effect of adding __slots__ to Vector2d.\n\nSimple Measure of __slot__ Savings Example 11-16 shows the implementation of __slots__ in Vector2d.\n\nExample 11-16. vector2d_v3_slots.py: the __slots__ attribute is the only addition to Vector2d\n\nclass Vector2d: __match_args__ = ('x', 'y') __slots__ = ('__x', '__y')\n\ntypecode = 'd' # methods are the same as previous version\n\n__match_args__ lists the public attribute names for positional pattern matching.\n\nIn contrast, __slots__ lists the names of the instance attributes, which in this case are private attributes.\n\nTo measure the memory savings, I wrote the mem_test.py script. It takes the name of a module with a Vector2d class variant as command-line argument, and uses a list comprehension to build a list with 10,000,000 instances of Vector2d. In the first run shown in Example 11-17, I use vector2d_v3.Vector2d (from Example 11-7); in the second run, I use the version with __slots__ from Example 11-16.\n\nExample 11-17. mem_test.py creates 10 million Vector2d instances using the class defined in the named module\n\n$ time python3 mem_test.py vector2d_v3 Selected Vector2d type: vector2d_v3.Vector2d Creating 10,000,000 Vector2d instances Initial RAM usage: 6,983,680 Final RAM usage: 1,666,535,424\n\nreal 0m11.990s user 0m10.861s sys 0m0.978s\n\nSaving Memory with __slots__\n\n|\n\n387\n\n$ time python3 mem_test.py vector2d_v3_slots Selected Vector2d type: vector2d_v3_slots.Vector2d Creating 10,000,000 Vector2d instances Initial RAM usage: 6,995,968 Final RAM usage: 577,839,104\n\nreal 0m8.381s user 0m8.006s sys 0m0.352s\n\nAs Example 11-17 reveals, the RAM footprint of the script grows to 1.55 GiB when instance __dict__ is used in each of the 10 million Vector2d instances, but that is reduced to 551 MiB when Vector2d has a __slots__ attribute. The __slots__ ver‐ sion is also faster. The mem_test.py script in this test basically deals with loading a module, checking memory usage, and formatting results. You can find its source code in the fluentpython/example-code-2e repository.\n\nIf you are handling millions of objects with numeric data, you should really be using NumPy arrays (see “NumPy” on page 64), which are not only memory efficient but have highly optimized functions for numeric processing, many of which operate on the entire array at once. I designed the Vector2d class just to provide context when discussing special methods, because I try to avoid vague foo and bar examples when I can.\n\nSummarizing the Issues with __slots__ The __slots__ class attribute may provide significant memory savings if properly used, but there are a few caveats:\n\nYou must remember to redeclare __slots__ in each subclass to prevent their instances from having __dict__.\n\nInstances will only be able to have the attributes listed in __slots__, unless you include '__dict__' in __slots__ (but doing so may negate the memory savings).\n\nClasses using __slots__ cannot use the @cached_property decorator, unless they explicitly name '__dict__' in __slots__.\n\nInstances cannot be targets of weak references, unless you add '__weakref__' in __slots__.\n\nThe last topic in this chapter has to do with overriding a class attribute in instances and subclasses.\n\n388\n\n|\n\nChapter 11: A Pythonic Object\n\nOverriding Class Attributes A distinctive feature of Python is how class attributes can be used as default values for instance attributes. In Vector2d there is the typecode class attribute. It’s used twice in the __bytes__ method, but we read it as self.typecode by design. Because Vec tor2d instances are created without a typecode attribute of their own, self.type code will get the Vector2d.typecode class attribute by default.\n\nBut if you write to an instance attribute that does not exist, you create a new instance attribute—e.g., a typecode instance attribute—and the class attribute by the same name is untouched. However, from then on, whenever the code handling that instance reads self.typecode, the instance typecode will be retrieved, effectively shadowing the class attribute by the same name. This opens the possibility of custom‐ izing an individual instance with a different typecode.\n\nThe default Vector2d.typecode is 'd', meaning each vector component will be rep‐ resented as an 8-byte double precision float when exporting to bytes. If we set the typecode of a Vector2d instance to 'f' prior to exporting, each component will be exported as a 4-byte single precision float. Example 11-18 demonstrates.\n\nWe are discussing adding a custom instance attribute, therefore Example 11-18 uses the Vector2d implementation without __slots__, as listed in Example 11-11.\n\nExample 11-18. Customizing an instance by setting the typecode attribute that was formerly inherited from the class\n\n>>> from vector2d_v3 import Vector2d >>> v1 = Vector2d(1.1, 2.2) >>> dumpd = bytes(v1) >>> dumpd b'd\\x9a\\x99\\x99\\x99\\x99\\x99\\xf1?\\x9a\\x99\\x99\\x99\\x99\\x99\\x01@' >>> len(dumpd) 17 >>> v1.typecode = 'f' >>> dumpf = bytes(v1) >>> dumpf b'f\\xcd\\xcc\\x8c?\\xcd\\xcc\\x0c@' >>> len(dumpf) 9 >>> Vector2d.typecode 'd'\n\nOverriding Class Attributes\n\n|\n\n389",
      "page_number": 388
    },
    {
      "number": 21,
      "title": "Segment 21 (pages 411-432)",
      "start_page": 411,
      "end_page": 432,
      "detection_method": "synthetic",
      "content": "Default bytes representation is 17 bytes long.\n\nSet typecode to 'f' in the v1 instance.\n\nNow the bytes dump is 9 bytes long.\n\nVector2d.typecode is unchanged; only the v1 instance uses typecode 'f'.\n\nNow it should be clear why the bytes export of a Vector2d is prefixed by the type code: we wanted to support different export formats.\n\nIf you want to change a class attribute, you must set it on the class directly, not through an instance. You could change the default typecode for all instances (that don’t have their own typecode) by doing this:\n\n>>> Vector2d.typecode = 'f'\n\nHowever, there is an idiomatic Python way of achieving a more permanent effect, and being more explicit about the change. Because class attributes are public, they are inherited by subclasses, so it’s common practice to subclass just to customize a class data attribute. The Django class-based views use this technique extensively. Example 11-19 shows how.\n\nExample 11-19. The ShortVector2d is a subclass of Vector2d, which only overwrites the default typecode\n\n>>> from vector2d_v3 import Vector2d >>> class ShortVector2d(Vector2d): ... typecode = 'f' ... >>> sv = ShortVector2d(1/11, 1/27) >>> sv ShortVector2d(0.09090909090909091, 0.037037037037037035) >>> len(bytes(sv)) 9\n\nCreate ShortVector2d as a Vector2d subclass just to overwrite the typecode class attribute.\n\nBuild ShortVector2d instance sv for demonstration.\n\nInspect the repr of sv.\n\nCheck that the length of the exported bytes is 9, not 17 as before.\n\nThis example also explains why I did not hardcode the class_name in Vector2d. __repr__, but instead got it from type(self).__name__, like this:\n\n390\n\n|\n\nChapter 11: A Pythonic Object\n\n# inside class Vector2d:\n\ndef __repr__(self): class_name = type(self).__name__ return '{}({!r}, {!r})'.format(class_name, *self)\n\nIf I had hardcoded the class_name, subclasses of Vector2d like ShortVector2d would have to overwrite __repr__ just to change the class_name. By reading the name from the type of the instance, I made __repr__ safer to inherit.\n\nThis ends our coverage of building a simple class that leverages the data model to play well with the rest of Python: offering different object representations, providing a custom formatting code, exposing read-only attributes, and supporting hash() to integrate with sets and mappings.\n\nChapter Summary The aim of this chapter was to demonstrate the use of special methods and conven‐ tions in the construction of a well-behaved Pythonic class.\n\nIs vector2d_v3.py (shown in Example 11-11) more Pythonic than vector2d_v0.py (shown in Example 11-2)? The Vector2d class in vector2d_v3.py certainly exhibits more Python features. But whether the first or the last Vector2d implementation is suitable depends on the context where it would be used. Tim Peter’s “Zen of Python” says:\n\nSimple is better than complex.\n\nAn object should be as simple as the requirements dictate—and not a parade of lan‐ guage features. If the code is for an application, then it should focus on what is needed to support the end users, not more. If the code is for a library for other pro‐ grammers to use, then it’s reasonable to implement special methods supporting behaviors that Pythonistas expect. For example, __eq__ may not be necessary to sup‐ port a business requirement, but it makes the class easier to test.\n\nMy goal in expanding the Vector2d code was to provide context for discussing Python special methods and coding conventions. The examples in this chapter have demonstrated several of the special methods we first saw in Table 1-1 (Chapter 1):\n\nString/bytes representation methods: __repr__, __str__, __format__, and __bytes__\n\nMethods for reducing an object to a number: __abs__, __bool__, and __hash__ • The __eq__ operator, to support testing and hashing (along with __hash__)\n\nChapter Summary\n\n|\n\n391\n\nWhile supporting conversion to bytes, we also implemented an alternative construc‐ tor, Vector2d.frombytes(), which provided the context for discussing the decora‐ tors @classmethod (very handy) and @staticmethod (not so useful, module-level functions are simpler). The frombytes method was inspired by its namesake in the array.array class.\n\nWe saw that the Format Specification Mini-Language is extensible by implementing a __format__ method that parses a format_spec provided to the format(obj, for mat_spec) built-in or within replacement fields '{:«format_spec»}' in f-strings or strings used with the str.format() method.\n\nIn preparation to make Vector2d instances hashable, we made an effort to make them immutable, at least preventing accidental changes by coding the x and y attributes as private, and exposing them as read-only properties. We then implemented __hash__ using the recommended technique of xor-ing the hashes of the instance attributes.\n\nWe then discussed the memory savings and the caveats of declaring a __slots__ attribute in Vector2d. Because using __slots__ has side effects, it really makes sense only when handling a very large number of instances—think millions of instances, not just thousands. In many such cases, using pandas may be the best option.\n\nThe last topic we covered was the overriding of a class attribute accessed via the instances (e.g., self.typecode). We did that first by creating an instance attribute, and then by subclassing and overwriting at the class level.\n\nThroughout the chapter, I mentioned how design choices in the examples were informed by studying the API of standard Python objects. If this chapter can be sum‐ marized in one sentence, this is it:\n\nTo build Pythonic objects, observe how real Python objects behave.\n\n—Ancient Chinese proverb\n\nFurther Reading This chapter covered several special methods of the data model, so naturally the pri‐ mary references are the same as the ones provided in Chapter 1, which gave a high- level view of the same topic. For convenience, I’ll repeat those four earlier recommendations here, and add a few other ones:\n\nThe “Data Model” chapter of The Python Language Reference\n\nMost of the methods we used in this chapter are documented in “3.3.1. Basic cus‐ tomization”.\n\n392\n\n|\n\nChapter 11: A Pythonic Object\n\nPython in a Nutshell, 3rd ed., by Alex Martelli, Anna Ravenscroft, and Steve Holden\n\nCovers the special methods in depth.\n\nPython Cookbook, 3rd ed., by David Beazley and Brian K. Jones\n\nModern Python practices demonstrated through recipes. Chapter 8, “Classes and Objects,” in particular has several solutions related to discussions in this chapter.\n\nPython Essential Reference, 4th ed., by David Beazley\n\nCovers the data model in detail, even if only Python 2.6 and 3.0 are covered (in the fourth edition). The fundamental concepts are all the same and most of the Data Model APIs haven’t changed at all since Python 2.2, when built-in types and user-defined classes were unified.\n\nIn 2015—the year I finished the first edition of Fluent Python—Hynek Schlawack started the attrs package. From the attrs documentation:\n\nattrs is the Python package that will bring back the joy of writing classes by relieving you from the drudgery of implementing object protocols (aka dunder methods).\n\nI mentioned attrs as a more powerful alternative to @dataclass in “Further Read‐ ing” on page 196. The data class builders from Chapter 5 as well as attrs automati‐ cally equip your classes with several special methods. But knowing how to code those special methods yourself is still essential to understand what those packages do, to decide whether you really need them, and to override the methods they generate— when necessary.\n\nIn this chapter, we saw every special method related to object representation, except __index__ and __fspath__. We’ll discuss __index__ in Chapter 12, “A Slice-Aware __getitem__” on page 406. I will not cover __fspath__. To learn about it, see PEP 519 —Adding a file system path protocol.\n\nAn early realization of the need for distinct string representations for objects appeared in Smalltalk. The 1996 article “How to Display an Object as a String: print‐ String and displayString” by Bobby Woolf discusses the implementation of the print String and displayString methods in that language. From that article, I borrowed the pithy descriptions “the way the developer wants to see it” and “the way the user wants to see it” when defining repr() and str() in “Object Representations” on page 364.\n\nFurther Reading\n\n|\n\n393\n\nSoapbox\n\nProperties Help Reduce Up-Front Costs\n\nIn the initial versions of Vector2d, the x and y attributes were public, as are all Python instance and class attributes by default. Naturally, users of vectors need to access its components. Although our vectors are iterable and can be unpacked into a pair of variables, it’s also desirable to write my_vector.x and my_vector.y to get each component.\n\nWhen we felt the need to avoid accidental updates to the x and y attributes, we imple‐ mented properties, but nothing changed elsewhere in the code and in the public interface of Vector2d, as verified by the doctests. We are still able to access my_vec tor.x and my_vector.y.\n\nThis shows that we can always start our classes in the simplest possible way, with public attributes, because when (or if) we later need to impose more control with get‐ ters and setters, these can be implemented through properties without changing any of the code that already interacts with our objects through the names (e.g., x and y) that were initially simple public attributes.\n\nThis approach is the opposite of that encouraged by the Java language: a Java pro‐ grammer cannot start with simple public attributes and only later, if needed, implement properties, because they don’t exist in the language. Therefore, writing getters and setters is the norm in Java—even when those methods do nothing useful —because the API cannot evolve from simple public attributes to getters and setters without breaking all code that uses those attributes.\n\nIn addition, as Martelli, Ravenscroft, and Holden point out in Python in a Nutshell, 3rd ed., typing getter/setter calls everywhere is goofy. You have to write stuff like:\n\n>>> my_object.set_foo(my_object.get_foo() + 1)\n\nJust to do this:\n\n>>> my_object.foo += 1\n\nWard Cunningham, inventor of the wiki and an Extreme Programming pioneer, rec‐ ommends asking: “What’s the simplest thing that could possibly work?” The idea is to focus on the goal.11 Implementing setters and getters up-front is a distraction from the goal. In Python, we can simply use public attributes, knowing we can change them to properties later, if the need arises.\n\n11 See the “Simplest Thing that Could Possibly Work: A Conversation with Ward Cunningham, Part V”.\n\n394\n\n|\n\nChapter 11: A Pythonic Object\n\nSafety Versus Security in Private Attributes\n\nPerl doesn’t have an infatuation with enforced privacy. It would prefer that you stayed out of its living room because you weren’t invited, not because it has a shotgun.\n\n—Larry Wall, creator of Perl\n\nPython and Perl are polar opposites in many regards, but Guido and Larry seem to agree on object privacy.\n\nHaving taught Python to many Java programmers over the years, I’ve found a lot of them put too much faith in the privacy guarantees that Java offers. As it turns out, the Java private and protected modifiers normally provide protection against accidents only (i.e., safety). They only offer security against malicious intent if the application is specially configured and deployed on top of a Java SecurityManager, and that seldom happens in practice, even in security conscious corporate settings.\n\nTo prove my point, I like to show this Java class (Example 11-20).\n\nExample 11-20. Confidential.java: a Java class with a private field named secret\n\npublic class Confidential {\n\nprivate String secret = \"\";\n\npublic Confidential(String text) { this.secret = text.toUpperCase(); } }\n\nIn Example 11-20, I store the text in the secret field after converting it to uppercase, just to make it obvious that whatever is in that field will be in all caps.\n\nThe actual demonstration consists of running expose.py with Jython. That script uses introspection (“reflection” in Java parlance) to get the value of a private field. The code is in Example 11-21.\n\nExample 11-21. expose.py: Jython code to read the content of a private field in another class\n\n#!/usr/bin/env jython # NOTE: Jython is still Python 2.7 in late2020\n\nimport Confidential\n\nmessage = Confidential('top secret text') secret_field = Confidential.getDeclaredField('secret') secret_field.setAccessible(True) # break the lock! print 'message.secret =', secret_field.get(message)\n\nIf you run Example 11-21, this is what you get:\n\nFurther Reading\n\n|\n\n395\n\n$ jython expose.py message.secret = TOP SECRET TEXT\n\nThe string 'TOP SECRET TEXT' was read from the secret private field of the Confi dential class.\n\nThere is no black magic here: expose.py uses the Java reflection API to get a reference to the private field named 'secret', and then calls 'secret_field.setAccessi ble(True)' to make it readable. The same thing can be done with Java code, of course (but it takes more than three times as many lines to do it; see the file Expose.java in the _Fluent Python_ code repository).\n\nThe crucial call .setAccessible(True) will fail only if the Jython script or the Java main program (e.g., Expose.class) is running under the supervision of a Security‐ Manager. But in the real world, Java applications are rarely deployed with a Security‐ Manager—except for Java applets when they were still supported by browsers.\n\nMy point is: in Java too, access control modifiers are mostly about safety and not security, at least in practice. So relax and enjoy the power Python gives you. Use it responsibly.\n\n396\n\n|\n\nChapter 11: A Pythonic Object\n\nCHAPTER 12 Special Methods for Sequences\n\nDon’t check whether it is-a duck: check whether it quacks-like-a duck, walks-like-a duck, etc., etc., depending on exactly what subset of duck-like behavior you need to play your language-games with. (comp.lang.python, Jul. 26, 2000)\n\n—Alex Martelli\n\nIn this chapter, we will create a class to represent a multidimensional Vector class—a significant step up from the two-dimensional Vector2d of Chapter 11. Vector will behave like a standard Python immutable flat sequence. Its elements will be floats, and it will support the following by the end of this chapter:\n\nBasic sequence protocol: __len__ and __getitem__\n\nSafe representation of instances with many items • Proper slicing support, producing new Vector instances\n\nAggregate hashing, taking into account every contained element value\n\nCustom formatting language extension\n\nWe’ll also implement dynamic attribute access with __getattr__ as a way of replac‐ ing the read-only properties we used in Vector2d—although this is not typical of sequence types.\n\nThe code-intensive presentation will be interrupted by a conceptual discussion about the idea of protocols as an informal interface. We’ll talk about how protocols and duck typing are related, and its practical implications when you create your own types.\n\n397\n\nWhat’s New in This Chapter There are no major changes in this chapter. There is a new, brief discussion of the typing.Protocol in a tip box near the end of “Protocols and Duck Typing” on page 402.\n\nIn “A Slice-Aware __getitem__” on page 406, the implementation of __getitem__ in Example 12-6 is more concise and robust than the example in the first edition, thanks to duck typing and operator.index. This change carried over to later implementa‐ tions of Vector in this chapter and in Chapter 16.\n\nLet’s get started.\n\nVector: A User-Defined Sequence Type Our strategy to implement Vector will be to use composition, not inheritance. We’ll store the components in an array of floats, and will implement the methods needed for our Vector to behave like an immutable flat sequence.\n\nBut before we implement the sequence methods, let’s make sure we have a baseline implementation of Vector that is compatible with our earlier Vector2d class—except where such compatibility would not make sense.\n\nVector Applications Beyond Three Dimensions Who needs a vector with 1,000 dimensions? N-dimensional vectors (with large values of N) are widely used in information retrieval, where documents and text queries are represented as vectors, with one dimension per word. This is called the Vector space model. In this model, a key relevance metric is the cosine similarity (i.e., the cosine of the angle between the vector representing the query and the vector representing the document). As the angle decreases, the cosine approaches the maximum value of 1, and so does the relevance of the document to the query.\n\nHaving said that, the Vector class in this chapter is a didactic example and we’ll not do much math here. Our goal is just to demonstrate some Python special methods in the context of a sequence type.\n\nNumPy and SciPy are the tools you need for real-world vector math. The PyPI pack‐ age gensim, by Radim Řehůřek, implements vector space modeling for natural lan‐ guage processing and information retrieval, using NumPy and SciPy.\n\n398\n\n|\n\nChapter 12: Special Methods for Sequences\n\nVector Take #1: Vector2d Compatible The first version of Vector should be as compatible as possible with our earlier Vec tor2d class.\n\nHowever, by design, the Vector constructor is not compatible with the Vector2d constructor. We could make Vector(3, 4) and Vector(3, 4, 5) work, by taking arbitrary arguments with *args in __init__, but the best practice for a sequence con‐ structor is to take the data as an iterable argument in the constructor, like all built-in sequence types do. Example 12-1 shows some ways of instantiating our new Vector objects.\n\nExample 12-1. Tests of Vector.__init__ and Vector.__repr__\n\n>>> Vector([3.1, 4.2]) Vector([3.1, 4.2]) >>> Vector((3, 4, 5)) Vector([3.0, 4.0, 5.0]) >>> Vector(range(10)) Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])\n\nApart from a new constructor signature, I made sure every test I did with Vector2d (e.g., Vector2d(3, 4)) passed and produced the same result with a two-component Vector([3, 4]).\n\nWhen a Vector has more than six components, the string pro‐ duced by repr() is abbreviated with ... as seen in the last line of Example 12-1. This is crucial in any collection type that may con‐ tain a large number of items, because repr is used for debugging— and you don’t want a single large object to span thousands of lines in your console or log. Use the reprlib module to produce limited-length representations, as in Example 12-2. The reprlib module was named repr in Python 2.7.\n\nExample 12-2 lists the implementation of our first version of Vector (this example builds on the code shown in Examples 11-2 and 11-3).\n\nExample 12-2. vector_v1.py: derived from vector2d_v1.py\n\nfrom array import array import reprlib import math\n\nclass Vector:\n\nVector Take #1: Vector2d Compatible\n\n|\n\n399\n\ntypecode = 'd'\n\ndef __init__(self, components): self._components = array(self.typecode, components)\n\ndef __iter__(self): return iter(self._components)\n\ndef __repr__(self): components = reprlib.repr(self._components) components = components[components.find('['):-1] return f'Vector({components})'\n\ndef __str__(self): return str(tuple(self))\n\ndef __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(self._components))\n\ndef __eq__(self, other): return tuple(self) == tuple(other)\n\ndef __abs__(self): return math.hypot(*self)\n\ndef __bool__(self): return bool(abs(self))\n\n@classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(memv)\n\nThe self._components instance “protected” attribute will hold an array with the Vector components.\n\nTo allow iteration, we return an iterator over self._components.1\n\nUse reprlib.repr() to get a limited-length representation of self._components (e.g., array('d', [0.0, 1.0, 2.0, 3.0, 4.0, ...])).\n\nRemove the array('d', prefix, and the trailing ) before plugging the string into a Vector constructor call.\n\n1 The iter() function is covered in Chapter 17, along with the __iter__ method.\n\n400\n\n|\n\nChapter 12: Special Methods for Sequences\n\nBuild a bytes object directly from self._components.\n\nSince Python 3.8, math.hypot accepts N-dimensional points. I used this expres‐ sion before: math.sqrt(sum(x * x for x in self)).\n\nThe only change needed from the earlier frombytes is in the last line: we pass the memoryview directly to the constructor, without unpacking with * as we did before.\n\nThe way I used reprlib.repr deserves some elaboration. That function produces safe representations of large or recursive structures by limiting the length of the out‐ put string and marking the cut with '...'. I wanted the repr of a Vector to look like Vector([3.0, 4.0, 5.0]) and not Vector(array('d', [3.0, 4.0, 5.0])), because the fact that there is an array inside a Vector is an implementation detail. Because these constructor calls build identical Vector objects, I prefer the simpler syntax using a list argument.\n\nWhen coding __repr__, I could have produced the simplified components display with this expression: reprlib.repr(list(self._components)). However, this would be wasteful, as I’d be copying every item from self._components to a list just to use the list repr. Instead, I decided to apply reprlib.repr to the self._com ponents array directly, and then chop off the characters outside of the []. That’s what the second line of __repr__ does in Example 12-2.\n\nBecause of its role in debugging, calling repr() on an object should never raise an exception. If something goes wrong inside your implementation of __repr__, you must deal with the issue and do your best to produce some serviceable output that gives the user a chance of identifying the receiver (self).\n\nNote that the __str__, __eq__, and __bool__ methods are unchanged from Vec tor2d, and only one character was changed in frombytes (a * was removed in the last line). This is one of the benefits of making the original Vector2d iterable.\n\nBy the way, we could have subclassed Vector from Vector2d, but I chose not to do it for two reasons. First, the incompatible constructors really make subclassing not advisable. I could work around that with some clever parameter handling in __init__, but the second reason is more important: I want Vector to be a standalone example of a class implementing the sequence protocol. That’s what we’ll do next, after a discussion of the term protocol.\n\nVector Take #1: Vector2d Compatible\n\n|\n\n401\n\nProtocols and Duck Typing As early as Chapter 1, we saw that you don’t need to inherit from any special class to create a fully functional sequence type in Python; you just need to implement the methods that fulfill the sequence protocol. But what kind of protocol are we talking about?\n\nIn the context of object-oriented programming, a protocol is an informal interface, defined only in documentation and not in code. For example, the sequence protocol in Python entails just the __len__ and __getitem__ methods. Any class Spam that implements those methods with the standard signature and semantics can be used anywhere a sequence is expected. Whether Spam is a subclass of this or that is irrele‐ vant; all that matters is that it provides the necessary methods. We saw that in Example 1-1, reproduced here in Example 12-3.\n\nExample 12-3. Code from Example 1-1, reproduced here for convenience\n\nimport collections\n\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n\nclass FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split()\n\ndef __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\ndef __len__(self): return len(self._cards)\n\ndef __getitem__(self, position): return self._cards[position]\n\nThe FrenchDeck class in Example 12-3 takes advantage of many Python facilities because it implements the sequence protocol, even if that is not declared anywhere in the code. An experienced Python coder will look at it and understand that it is a sequence, even if it subclasses object. We say it is a sequence because it behaves like one, and that is what matters.\n\nThis became known as duck typing, after Alex Martelli’s post quoted at the beginning of this chapter.\n\nBecause protocols are informal and unenforced, you can often get away with imple‐ menting just part of a protocol, if you know the specific context where a class will be\n\n402\n\n|\n\nChapter 12: Special Methods for Sequences\n\nused. For example, to support iteration, only __getitem__ is required; there is no need to provide __len__.\n\nWith PEP 544—Protocols: Structural subtyping (static duck typ‐ ing), Python 3.8 supports protocol classes: typing constructs, which we studied in “Static Protocols” on page 286. This new use of the word protocol in Python has a related but different meaning. When I need to differentiate them, I write static protocol to refer to the protocols formalized in protocol classes, and dynamic protocol for the traditional sense. One key difference is that static protocol implementations must provide all methods defined in the protocol class. “Two Kinds of Protocols” on page 434 in Chapter 13 has more details.\n\nWe’ll now implement the sequence protocol in Vector, initially without proper sup‐ port for slicing, but later adding that.\n\nVector Take #2: A Sliceable Sequence As we saw with the FrenchDeck example, supporting the sequence protocol is really easy if you can delegate to a sequence attribute in your object, like our self._compo nents array. These __len__ and __getitem__ one-liners are a good start:\n\nclass Vector: # many lines omitted # ...\n\ndef __len__(self): return len(self._components)\n\ndef __getitem__(self, index): return self._components[index]\n\nWith these additions, all of these operations now work:\n\n>>> v1 = Vector([3, 4, 5]) >>> len(v1) 3 >>> v1[0], v1[-1] (3.0, 5.0) >>> v7 = Vector(range(7)) >>> v7[1:4] array('d', [1.0, 2.0, 3.0])\n\nAs you can see, even slicing is supported—but not very well. It would be better if a slice of a Vector was also a Vector instance and not an array. The old FrenchDeck class has a similar problem: when you slice it, you get a list. In the case of Vector, a lot of functionality is lost when slicing produces plain arrays.\n\nVector Take #2: A Sliceable Sequence\n\n|\n\n403\n\nConsider the built-in sequence types: every one of them, when sliced, produces a new instance of its own type, and not of some other type.\n\nTo make Vector produce slices as Vector instances, we can’t just delegate the slicing to array. We need to analyze the arguments we get in __getitem__ and do the right thing.\n\nNow, let’s see how Python turns the syntax my_seq[1:3] into arguments for my_seq.__getitem__(...).\n\nHow Slicing Works A demo is worth a thousand words, so take a look at Example 12-4.\n\nExample 12-4. Checking out the behavior of __getitem__ and slices\n\n>>> class MySeq: ... def __getitem__(self, index): ... return index ... >>> s = MySeq() >>> s[1] 1 >>> s[1:4] slice(1, 4, None) >>> s[1:4:2] slice(1, 4, 2) >>> s[1:4:2, 9] (slice(1, 4, 2), 9) >>> s[1:4:2, 7:9] (slice(1, 4, 2), slice(7, 9, None))\n\nFor this demonstration, __getitem__ merely returns whatever is passed to it.\n\nA single index, nothing new.\n\nThe notation 1:4 becomes slice(1, 4, None).\n\nslice(1, 4, 2) means start at 1, stop at 4, step by 2.\n\nSurprise: the presence of commas inside the [] means __getitem__ receives a tuple.\n\nThe tuple may even hold several slice objects.\n\nNow let’s take a closer look at slice itself in Example 12-5.\n\n404\n\n|\n\nChapter 12: Special Methods for Sequences\n\nExample 12-5. Inspecting the attributes of the slice class\n\n>>> slice <class 'slice'> >>> dir(slice) ['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'indices', 'start', 'step', 'stop']\n\nslice is a built-in type (we saw it first in “Slice Objects” on page 48).\n\nInspecting a slice, we find the data attributes start, stop, and step, and an indices method.\n\nIn Example 12-5, calling dir(slice) reveals an indices attribute, which turns out to be a very interesting but little-known method. Here is what help(slice.indices) reveals:\n\nS.indices(len) -> (start, stop, stride)\n\nAssuming a sequence of length len, calculate the start and stop indices, and the stride length of the extended slice described by S. Out-of-bounds indices are clipped just like they are in a normal slice.\n\nIn other words, indices exposes the tricky logic that’s implemented in the built-in sequences to gracefully handle missing or negative indices and slices that are longer than the original sequence. This method produces “normalized” tuples of nonnega‐ tive start, stop, and stride integers tailored to a sequence of the given length.\n\nHere are a couple of examples, considering a sequence of len == 5, e.g., 'ABCDE':\n\n>>> slice(None, 10, 2).indices(5) (0, 5, 2) >>> slice(-3, None, None).indices(5) (2, 5, 1)\n\n'ABCDE'[:10:2] is the same as 'ABCDE'[0:5:2].\n\n'ABCDE'[-3:] is the same as 'ABCDE'[2:5:1].\n\nIn our Vector code, we’ll not need the slice.indices() method because when we get a slice argument we’ll delegate its handling to the _components array. But if you can’t count on the services of an underlying sequence, this method can be a huge time saver.\n\nVector Take #2: A Sliceable Sequence\n\n|\n\n405\n\nNow that we know how to handle slices, let’s take a look at the improved Vec tor.__getitem__ implementation.\n\nA Slice-Aware __getitem__ Example 12-6 lists the two methods needed to make Vector behave as a sequence: __len__ and __getitem__ (the latter now implemented to handle slicing correctly).\n\nExample 12-6. Part of vector_v2.py: __len__ and __getitem__ methods added to Vector class from vector_v1.py (see Example 12-2)\n\ndef __len__(self): return len(self._components)\n\ndef __getitem__(self, key): if isinstance(key, slice): cls = type(self) return cls(self._components[key]) index = operator.index(key) return self._components[index]\n\nIf the key argument is a slice…\n\n…get the class of the instance (i.e., Vector) and…\n\n…invoke the class to build another Vector instance from a slice of the _components array.\n\nIf we can get an index from key…\n\n…return the specific item from _components.\n\nThe operator.index() function calls the __index__ special method. The function and the special method were defined in PEP 357—Allowing Any Object to be Used for Slicing, proposed by Travis Oliphant to allow any of the numerous types of inte‐ gers in NumPy to be used as indexes and slice arguments. The key difference between operator.index() and int() is that the former is intended for this specific purpose. For example, int(3.14) returns 3, but operator.index(3.14) raises TypeError because a float should not be used as an index.\n\n406\n\n|\n\nChapter 12: Special Methods for Sequences\n\nExcessive use of isinstance may be a sign of bad OO design, but handling slices in __getitem__ is a justified use case. In the first edition, I also used an isinstance test on key to test if it was an integer. Using operator.index avoids this test, and raises Type Error with a very informative message if we can’t get the index from key. See the last error message from Example 12-7.\n\nOnce the code in Example 12-6 is added to the Vector class, we have proper slicing behavior, as Example 12-7 demonstrates.\n\nExample 12-7. Tests of enhanced Vector.__getitem__ from Example 12-6\n\n>>> v7 = Vector(range(7)) >>> v7[-1] 6.0 >>> v7[1:4] Vector([1.0, 2.0, 3.0]) >>> v7[-1:] Vector([6.0]) >>> v7[1,2] Traceback (most recent call last): ... TypeError: 'tuple' object cannot be interpreted as an integer\n\nAn integer index retrieves just one component value as a float.\n\nA slice index creates a new Vector.\n\nA slice of len == 1 also creates a Vector.\n\nVector does not support multidimensional indexing, so a tuple of indices or sli‐ ces raises an error.\n\nVector Take #3: Dynamic Attribute Access In the evolution from Vector2d to Vector, we lost the ability to access vector compo‐ nents by name (e.g., v.x, v.y). We are now dealing with vectors that may have a large number of components. Still, it may be convenient to access the first few components with shortcut letters such as x, y, z instead of v[0], v[1], and v[2].\n\nHere is the alternative syntax we want to provide for reading the first four compo‐ nents of a vector:\n\n>>> v = Vector(range(10)) >>> v.x 0.0\n\nVector Take #3: Dynamic Attribute Access\n\n|\n\n407\n\n>>> v.y, v.z, v.t (1.0, 2.0, 3.0)\n\nIn Vector2d, we provided read-only access to x and y using the @property decorator (Example 11-7). We could write four properties in Vector, but it would be tedious. The __getattr__ special method provides a better way.\n\nThe __getattr__ method is invoked by the interpreter when attribute lookup fails. In simple terms, given the expression my_obj.x, Python checks if the my_obj instance has an attribute named x; if not, the search goes to the class (my_obj.__class__), and then up the inheritance graph.2 If the x attribute is not found, then the __getattr__ method defined in the class of my_obj is called with self and the name of the attribute as a string (e.g., 'x').\n\nExample 12-8 lists our __getattr__ method. Essentially it checks whether the attribute being sought is one of the letters xyzt and if so, returns the corresponding vector component.\n\nExample 12-8. Part of vector_v3.py: __getattr__ method added to the Vector class\n\n__match_args__ = ('x', 'y', 'z', 't')\n\ndef __getattr__(self, name): cls = type(self) try: pos = cls.__match_args__.index(name) except ValueError: pos = -1 if 0 <= pos < len(self._components): return self._components[pos] msg = f'{cls.__name__!r} object has no attribute {name!r}' raise AttributeError(msg)\n\nSet __match_args__ to allow positional pattern matching on the dynamic attributes supported by __getattr__.3\n\nGet the Vector class for later use.\n\n2 Attribute lookup is more complicated than this; we’ll see the gory details in Part V. For now, this simplified\n\nexplanation will do.\n\n3 Although __match_args__ exists to support pattern matching in Python 3.10, setting this attribute is harmless in previous versions of Python. In the first edition of this book, I named it shortcut_names. With the new name it does double duty: it supports positional patterns in case clauses, and it holds the names of the dynamic attributes supported by special logic in __getattr__ and __setattr__.\n\n408\n\n|\n\nChapter 12: Special Methods for Sequences\n\nTry to get the position of name in __match_args__.\n\n.index(name) raises ValueError when name is not found; set pos to -1. (I’d rather use a method like str.find here, but tuple doesn’t implement it.)\n\nIf the pos is within range of the available components, return the component.\n\nIf we get this far, raise AttributeError with a standard message text.\n\nIt’s not hard to implement __getattr__, but in this case it’s not enough. Consider the bizarre interaction in Example 12-9.\n\nExample 12-9. Inappropriate behavior: assigning to v.x raises no error, but introduces an inconsistency\n\n>>> v = Vector(range(5)) >>> v Vector([0.0, 1.0, 2.0, 3.0, 4.0]) >>> v.x 0.0 >>> v.x = 10 >>> v.x 10 >>> v Vector([0.0, 1.0, 2.0, 3.0, 4.0])\n\nAccess element v[0] as v.x.\n\nAssign new value to v.x. This should raise an exception.\n\nReading v.x shows the new value, 10.\n\nHowever, the vector components did not change.\n\nCan you explain what is happening? In particular, why does v.x return 10 the second time if that value is not in the vector components array? If you don’t know right off the bat, study the explanation of __getattr__ given right before Example 12-8. It’s a bit subtle, but a very important foundation to understand a lot of what comes later in the book.\n\nAfter you’ve given it some thought, proceed and we’ll explain exactly what happened.\n\nThe inconsistency in Example 12-9 was introduced because of the way __getattr__ works: Python only calls that method as a fallback, when the object does not have the named attribute. However, after we assign v.x = 10, the v object now has an x attribute, so __getattr__ will no longer be called to retrieve v.x: the interpreter will\n\nVector Take #3: Dynamic Attribute Access\n\n|\n\n409\n\njust return the value 10 that is bound to v.x. On the other hand, our implementation of __getattr__ pays no attention to instance attributes other than self._compo nents, from where it retrieves the values of the “virtual attributes” listed in __match_args__.\n\nWe need to customize the logic for setting attributes in our Vector class in order to avoid this inconsistency.\n\nRecall that in the latest Vector2d examples from Chapter 11, trying to assign to the .x or .y instance attributes raised AttributeError. In Vector, we want the same excep‐ tion with any attempt at assigning to all single-letter lowercase attribute names, just to avoid confusion. To do that, we’ll implement __setattr__, as listed in Example 12-10.\n\nExample 12-10. Part of vector_v3.py: __setattr__ method in the Vector class\n\ndef __setattr__(self, name, value): cls = type(self) if len(name) == 1: if name in cls.__match_args__: error = 'readonly attribute {attr_name!r}' elif name.islower(): error = \"can't set attributes 'a' to 'z' in {cls_name!r}\" else: error = '' if error: msg = error.format(cls_name=cls.__name__, attr_name=name) raise AttributeError(msg) super().__setattr__(name, value)\n\nSpecial handling for single-character attribute names.\n\nIf name is one of __match_args__, set specific error message.\n\nIf name is lowercase, set error message about all single-letter names.\n\nOtherwise, set blank error message.\n\nIf there is a nonblank error message, raise AttributeError.\n\nDefault case: call __setattr__ on superclass for standard behavior.\n\n410\n\n|\n\nChapter 12: Special Methods for Sequences\n\nThe super() function provides a way to access methods of super‐ classes dynamically, a necessity in a dynamic language supporting multiple inheritance like Python. It’s used to delegate some task from a method in a subclass to a suitable method in a superclass, as seen in Example 12-10. There is more about super in “Multiple Inheritance and Method Resolution Order” on page 494.\n\nWhile choosing the error message to display with AttributeError, my first check was the behavior of the built-in complex type, because they are immutable and have a pair of data attributes, real and imag. Trying to change either of those in a complex instance raises AttributeError with the message \"can't set attribute\". On the other hand, trying to set a read-only attribute protected by a property as we did in “A Hashable Vector2d” on page 374 produces the message \"read-only attribute\". I drew inspiration from both wordings to set the error string in __setitem__, but was more explicit about the forbidden attributes.\n\nNote that we are not disallowing setting all attributes, only single-letter, lowercase ones, to avoid confusion with the supported read-only attributes x, y, z, and t.\n\nKnowing that declaring __slots__ at the class level prevents set‐ ting new instance attributes, it’s tempting to use that feature instead of implementing __setattr__ as we did. However, because of all the caveats discussed in “Summarizing the Issues with __slots__” on page 388, using __slots__ just to prevent instance attribute creation is not recommended. __slots__ should be used only to save memory, and only if that is a real issue.\n\nEven without supporting writing to the Vector components, here is an important takeaway from this example: very often when you implement __getattr__, you need to code __setattr__ as well, to avoid inconsistent behavior in your objects.\n\nIf we wanted to allow changing components, we could implement __setitem__ to enable v[0] = 1.1 and/or __setattr__ to make v.x = 1.1 work. But Vector will remain immutable because we want to make it hashable in the coming section.\n\nVector Take #4: Hashing and a Faster == Once more we get to implement a __hash__ method. Together with the existing __eq__, this will make Vector instances hashable.\n\nThe __hash__ in Vector2d (Example 11-8) computed the hash of a tuple built with the two components, self.x and self.y. Now we may be dealing with thousands of components, so building a tuple may be too costly. Instead, I will apply the ^ (xor)\n\nVector Take #4: Hashing and a Faster ==\n\n|\n\n411",
      "page_number": 411
    },
    {
      "number": 22,
      "title": "Segment 22 (pages 433-453)",
      "start_page": 433,
      "end_page": 453,
      "detection_method": "synthetic",
      "content": "operator to the hashes of every component in succession, like this: v[0] ^ v[1] ^ v[2]. That is what the functools.reduce function is for. Previously I said that reduce is not as popular as before,4 but computing the hash of all vector components is a good use case for it. Figure 12-1 depicts the general idea of the reduce function.\n\nFigure 12-1. Reducing functions—reduce, sum, any, all—produce a single aggregate result from a sequence or from any finite iterable object.\n\nSo far we’ve seen that functools.reduce() can be replaced by sum(), but now let’s properly explain how it works. The key idea is to reduce a series of values to a single value. The first argument to reduce() is a two-argument function, and the second argument is an iterable. Let’s say we have a two-argument function fn and a list lst. When you call reduce(fn, lst), fn will be applied to the first pair of elements— fn(lst[0], lst[1])—producing a first result, r1. Then fn is applied to r1 and the next element—fn(r1, lst[2])—producing a second result, r2. Now fn(r2, lst[3]) is called to produce r3 … and so on until the last element, when a single result, rN, is returned.\n\nHere is how you could use reduce to compute 5! (the factorial of 5):\n\n>>> 2 * 3 * 4 * 5 # the result we want: 5! == 120 120 >>> import functools >>> functools.reduce(lambda a,b: a*b, range(1, 6)) 120\n\nBack to our hashing problem, Example 12-11 shows the idea of computing the aggre‐ gate xor by doing it in three ways: with a for loop and two reduce calls.\n\nExample 12-11. Three ways of calculating the accumulated xor of integers from 0 to 5\n\n>>> n = 0 >>> for i in range(1, 6): ... n ^= i ...\n\n4 The sum, any, and all cover the most common uses of reduce. See the discussion in “Modern Replacements\n\nfor map, filter, and reduce” on page 235.\n\n412\n\n|\n\nChapter 12: Special Methods for Sequences\n\n>>> n 1 >>> import functools >>> functools.reduce(lambda a, b: a^b, range(6)) 1 >>> import operator >>> functools.reduce(operator.xor, range(6)) 1\n\nAggregate xor with a for loop and an accumulator variable.\n\nfunctools.reduce using an anonymous function.\n\nfunctools.reduce replacing custom lambda with operator.xor.\n\nFrom the alternatives in Example 12-11, the last one is my favorite, and the for loop comes second. What is your preference?\n\nAs seen in “The operator Module” on page 243, operator provides the functionality of all Python infix operators in function form, lessening the need for lambda.\n\nTo code Vector.__hash__ in my preferred style, we need to import the functools and operator modules. Example 12-12 shows the relevant changes.\n\nExample 12-12. Part of vector_v4.py: two imports and __hash__ method added to the Vector class from vector_v3.py\n\nfrom array import array import reprlib import math import functools import operator\n\nclass Vector: typecode = 'd'\n\n# many lines omitted in book listing...\n\ndef __eq__(self, other): return tuple(self) == tuple(other)\n\ndef __hash__(self): hashes = (hash(x) for x in self._components) return functools.reduce(operator.xor, hashes, 0)\n\n# more lines omitted...\n\nVector Take #4: Hashing and a Faster ==\n\n|\n\n413\n\nImport functools to use reduce.\n\nImport operator to use xor.\n\nNo change to __eq__; I listed it here because it’s good practice to keep __eq__ and __hash__ close in source code, because they need to work together.\n\nCreate a generator expression to lazily compute the hash of each component.\n\nFeed hashes to reduce with the xor function to compute the aggregate hash code; the third argument, 0, is the initializer (see the next warning).\n\nWhen using reduce, it’s good practice to provide the third argu‐ ment, reduce(function, iterable, initializer), to prevent this exception: TypeError: reduce() of empty sequence with no initial value (excellent message: explains the problem and how to fix it). The initializer is the value returned if the sequence is empty and is used as the first argument in the reducing loop, so it should be the identity value of the operation. As exam‐ ples, for +, |, ^ the initializer should be 0, but for *, & it should be 1.\n\nAs implemented, the __hash__ method in Example 12-12 is a perfect example of a map-reduce computation (Figure 12-2).\n\nFigure 12-2. Map-reduce: apply function to each item to generate a new series (map), then compute the aggregate (reduce).\n\nThe mapping step produces one hash for each component, and the reduce step aggre‐ gates all hashes with the xor operator. Using map instead of a genexp makes the map‐ ping step even more visible:\n\n414\n\n|\n\nChapter 12: Special Methods for Sequences\n\ndef __hash__(self): hashes = map(hash, self._components) return functools.reduce(operator.xor, hashes)\n\nThe solution with map would be less efficient in Python 2, where the map function builds a new list with the results. But in Python 3, map is lazy: it creates a generator that yields the results on demand, thus saving memory—just like the generator expression we used in the __hash__ method of Example 12-8.\n\nWhile we are on the topic of reducing functions, we can replace our quick implemen‐ tation of __eq__ with another one that will be cheaper in terms of processing and memory, at least for large vectors. As introduced in Example 11-2, we have this very concise implementation of __eq__:\n\ndef __eq__(self, other): return tuple(self) == tuple(other)\n\nThis works for Vector2d and for Vector—it even considers Vector([1, 2]) equal to (1, 2), which may be a problem, but we’ll overlook that for now.5 But for Vector instances that may have thousands of components, it’s very inefficient. It builds two tuples copying the entire contents of the operands just to use the __eq__ of the tuple type. For Vector2d (with only two components), it’s a good shortcut, but not for the large multidimensional vectors. A better way of comparing one Vector to another Vector or iterable would be Example 12-13.\n\nExample 12-13. The Vector.__eq__ implementation using zip in a for loop for more efficient comparison\n\ndef __eq__(self, other): if len(self) != len(other): return False for a, b in zip(self, other): if a != b: return False return True\n\nIf the len of the objects are different, they are not equal.\n\nzip produces a generator of tuples made from the items in each iterable argu‐ , the len ment. See “The Awesome zip” on page 416 if zip is new to you. In\n\n5 We will seriously consider the matter of Vector([1, 2]) == (1, 2) in “Operator Overloading 101” on page\n\n562.\n\nVector Take #4: Hashing and a Faster ==\n\n|\n\n415\n\ncomparison is needed because zip stops producing values without warning as soon as one of the inputs is exhausted.\n\nAs soon as two components are different, exit returning False.\n\nOtherwise, the objects are equal.\n\nThe zip function is named after the zipper fastener because the physical device works by interlocking pairs of teeth taken from both zipper sides, a good visual analogy for what zip(left, right) does. No relation to compressed files.\n\nExample 12-13 is efficient, but the all function can produce the same aggregate com‐ putation of the for loop in one line: if all comparisons between corresponding com‐ ponents in the operands are True, the result is True. As soon as one comparison is False, all returns False. Example 12-14 shows how __eq__ looks using all.\n\nExample 12-14. The Vector.__eq__ implementation using zip and all: same logic as Example 12-13\n\ndef __eq__(self, other): return len(self) == len(other) and all(a == b for a, b in zip(self, other))\n\nNote that we first check that the operands have equal length, because zip will stop at the shortest operand.\n\nExample 12-14 is the implementation we choose for __eq__ in vector_v4.py.\n\nThe Awesome zip Having a for loop that iterates over items without fiddling with index variables is great and prevents lots of bugs, but demands some special utility functions. One of them is the zip built-in, which makes it easy to iterate in parallel over two or more iterables by returning tuples that you can unpack into variables, one for each item in the parallel inputs. See Example 12-15.\n\nExample 12-15. The zip built-in at work\n\n>>> zip(range(3), 'ABC') <zip object at 0x10063ae48> >>> list(zip(range(3), 'ABC')) [(0, 'A'), (1, 'B'), (2, 'C')] >>> list(zip(range(3), 'ABC', [0.0, 1.1, 2.2, 3.3])) [(0, 'A', 0.0), (1, 'B', 1.1), (2, 'C', 2.2)]\n\n416\n\n|\n\nChapter 12: Special Methods for Sequences\n\n>>> from itertools import zip_longest >>> list(zip_longest(range(3), 'ABC', [0.0, 1.1, 2.2, 3.3], fillvalue=-1)) [(0, 'A', 0.0), (1, 'B', 1.1), (2, 'C', 2.2), (-1, -1, 3.3)]\n\nzip returns a generator that produces tuples on demand.\n\nBuild a list just for display; usually we iterate over the generator.\n\nzip stops without warning when one of the iterables is exhausted.\n\nThe itertools.zip_longest function behaves differently: it uses an optional fillvalue (None by default) to complete missing values so it can generate tuples until the last iterable is exhausted.\n\nNew zip() Option in Python 3.10\n\nI wrote in the first edition of this book that zip silently stop‐ ping at the shortest iterable was surprising—not a good trait for an API. Silently ignoring part of the input can cause subtle bugs. Instead, zip should raise ValueError if the iterables are not all of the same length, which is what happens when unpacking an iterable to a tuple of variables of different length —in line with Python’s fail fast policy. PEP 618—Add Optional Length-Checking To zip added an optional strict argument to zip to make it behave in that way. It is imple‐ mented in Python 3.10.\n\nThe zip function can also be used to transpose a matrix represented as nested itera‐ bles. For example:\n\n>>> a = [(1, 2, 3), ... (4, 5, 6)] >>> list(zip(*a)) [(1, 4), (2, 5), (3, 6)] >>> b = [(1, 2), ... (3, 4), ... (5, 6)] >>> list(zip(*b)) [(1, 3, 5), (2, 4, 6)]\n\nIf you want to grok zip, spend some time figuring out how these examples work.\n\nThe enumerate built-in is another generator function often used in for loops to avoid direct handling of index variables. If you’re not familiar with enumerate, you should definitely check it out in the “Built-in functions” documentation. The zip and\n\nVector Take #4: Hashing and a Faster ==\n\n|\n\n417\n\nenumerate built-ins, along with several other generator functions in the standard library, are covered in “Generator Functions in the Standard Library” on page 619.\n\nWe wrap up this chapter by bringing back the __format__ method from Vector2d to Vector.\n\nVector Take #5: Formatting The __format__ method of Vector will resemble that of Vector2d, but instead of providing a custom display in polar coordinates, Vector will use spherical coordi‐ nates—also known as “hyperspherical” coordinates, because now we support n dimensions, and spheres are “hyperspheres” in 4D and beyond.6 Accordingly, we’ll change the custom format suffix from 'p' to 'h'.\n\nAs we saw in “Formatted Displays” on page 370, when extending the Format Specification Mini-Language, it’s best to avoid reusing format codes supported by built-in types. In particular, our exten‐ ded mini-language also uses the float formatting codes 'eEfFgGn%' in their original meaning, so we definitely must avoid these. Inte‐ gers use 'bcdoxXn' and strings use 's'. I picked 'p' for Vector2d polar coordinates. Code 'h' for hyperspherical coordinates is a good choice.\n\nFor example, given a Vector object in 4D space (len(v) == 4), the 'h' code will pro‐ duce a display like <r, Φ₁, Φ₂, Φ₃>, where r is the magnitude (abs(v)), and the remaining numbers are the angular components Φ₁, Φ₂, Φ₃.\n\nHere are some samples of the spherical coordinate format in 4D, taken from the doctests of vector_v5.py (see Example 12-16):\n\n>>> format(Vector([-1, -1, -1, -1]), 'h') '<2.0, 2.0943951023931957, 2.186276035465284, 3.9269908169872414>' >>> format(Vector([2, 2, 2, 2]), '.3eh') '<4.000e+00, 1.047e+00, 9.553e-01, 7.854e-01>' >>> format(Vector([0, 1, 0, 0]), '0.5fh') '<1.00000, 1.57080, 0.00000, 0.00000>'\n\nBefore we can implement the minor changes required in __format__, we need to code a pair of support methods: angle(n) to compute one of the angular coordinates (e.g., Φ₁), and angles() to return an iterable of all angular coordinates. I will not\n\n6 The Wolfram Mathworld website has an article on hypersphere; on Wikipedia, “hypersphere” redirects to the\n\n“n-sphere” entry.\n\n418\n\n|\n\nChapter 12: Special Methods for Sequences\n\ndescribe the math here; if you’re curious, Wikipedia’s “n-sphere” entry has the for‐ mulas I used to calculate the spherical coordinates from the Cartesian coordinates in the Vector components array.\n\nExample 12-16 is a full listing of vector_v5.py consolidating all we’ve implemented since “Vector Take #1: Vector2d Compatible” on page 399 and introducing custom formatting.\n\nExample 12-16. vector_v5.py: doctests and all code for the final Vector class; callouts highlight additions needed to support __format__\n\n\"\"\" A multidimensional ``Vector`` class, take 5\n\nA ``Vector`` is built from an iterable of numbers::\n\n>>> Vector([3.1, 4.2]) Vector([3.1, 4.2]) >>> Vector((3, 4, 5)) Vector([3.0, 4.0, 5.0]) >>> Vector(range(10)) Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])\n\nTests with two dimensions (same results as ``vector2d_v1.py``)::\n\n>>> v1 = Vector([3, 4]) >>> x, y = v1 >>> x, y (3.0, 4.0) >>> v1 Vector([3.0, 4.0]) >>> v1_clone = eval(repr(v1)) >>> v1 == v1_clone True >>> print(v1) (3.0, 4.0) >>> octets = bytes(v1) >>> octets b'd\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x08@\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x10@' >>> abs(v1) 5.0 >>> bool(v1), bool(Vector([0, 0])) (True, False)\n\nTest of ``.frombytes()`` class method:\n\n>>> v1_clone = Vector.frombytes(bytes(v1)) >>> v1_clone\n\nVector Take #5: Formatting\n\n|\n\n419\n\nVector([3.0, 4.0]) >>> v1 == v1_clone True\n\nTests with three dimensions::\n\n>>> v1 = Vector([3, 4, 5]) >>> x, y, z = v1 >>> x, y, z (3.0, 4.0, 5.0) >>> v1 Vector([3.0, 4.0, 5.0]) >>> v1_clone = eval(repr(v1)) >>> v1 == v1_clone True >>> print(v1) (3.0, 4.0, 5.0) >>> abs(v1) # doctest:+ELLIPSIS 7.071067811... >>> bool(v1), bool(Vector([0, 0, 0])) (True, False)\n\nTests with many dimensions::\n\n>>> v7 = Vector(range(7)) >>> v7 Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...]) >>> abs(v7) # doctest:+ELLIPSIS 9.53939201...\n\nTest of ``.__bytes__`` and ``.frombytes()`` methods::\n\n>>> v1 = Vector([3, 4, 5]) >>> v1_clone = Vector.frombytes(bytes(v1)) >>> v1_clone Vector([3.0, 4.0, 5.0]) >>> v1 == v1_clone True\n\nTests of sequence behavior::\n\n>>> v1 = Vector([3, 4, 5]) >>> len(v1) 3 >>> v1[0], v1[len(v1)-1], v1[-1] (3.0, 5.0, 5.0)\n\n420\n\n|\n\nChapter 12: Special Methods for Sequences\n\nTest of slicing::\n\n>>> v7 = Vector(range(7)) >>> v7[-1] 6.0 >>> v7[1:4] Vector([1.0, 2.0, 3.0]) >>> v7[-1:] Vector([6.0]) >>> v7[1,2] Traceback (most recent call last): ... TypeError: 'tuple' object cannot be interpreted as an integer\n\nTests of dynamic attribute access::\n\n>>> v7 = Vector(range(10)) >>> v7.x 0.0 >>> v7.y, v7.z, v7.t (1.0, 2.0, 3.0)\n\nDynamic attribute lookup failures::\n\n>>> v7.k Traceback (most recent call last): ... AttributeError: 'Vector' object has no attribute 'k' >>> v3 = Vector(range(3)) >>> v3.t Traceback (most recent call last): ... AttributeError: 'Vector' object has no attribute 't' >>> v3.spam Traceback (most recent call last): ... AttributeError: 'Vector' object has no attribute 'spam'\n\nTests of hashing::\n\n>>> v1 = Vector([3, 4]) >>> v2 = Vector([3.1, 4.2]) >>> v3 = Vector([3, 4, 5]) >>> v6 = Vector(range(6)) >>> hash(v1), hash(v3), hash(v6) (7, 2, 1)\n\nMost hash codes of non-integers vary from a 32-bit to 64-bit CPython build::\n\nVector Take #5: Formatting\n\n|\n\n421\n\n>>> import sys >>> hash(v2) == (384307168202284039 if sys.maxsize > 2**32 else 357915986) True\n\nTests of ``format()`` with Cartesian coordinates in 2D::\n\n>>> v1 = Vector([3, 4]) >>> format(v1) '(3.0, 4.0)' >>> format(v1, '.2f') '(3.00, 4.00)' >>> format(v1, '.3e') '(3.000e+00, 4.000e+00)'\n\nTests of ``format()`` with Cartesian coordinates in 3D and 7D::\n\n>>> v3 = Vector([3, 4, 5]) >>> format(v3) '(3.0, 4.0, 5.0)' >>> format(Vector(range(7))) '(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0)'\n\nTests of ``format()`` with spherical coordinates in 2D, 3D and 4D::\n\n>>> format(Vector([1, 1]), 'h') # doctest:+ELLIPSIS '<1.414213..., 0.785398...>' >>> format(Vector([1, 1]), '.3eh') '<1.414e+00, 7.854e-01>' >>> format(Vector([1, 1]), '0.5fh') '<1.41421, 0.78540>' >>> format(Vector([1, 1, 1]), 'h') # doctest:+ELLIPSIS '<1.73205..., 0.95531..., 0.78539...>' >>> format(Vector([2, 2, 2]), '.3eh') '<3.464e+00, 9.553e-01, 7.854e-01>' >>> format(Vector([0, 0, 0]), '0.5fh') '<0.00000, 0.00000, 0.00000>' >>> format(Vector([-1, -1, -1, -1]), 'h') # doctest:+ELLIPSIS '<2.0, 2.09439..., 2.18627..., 3.92699...>' >>> format(Vector([2, 2, 2, 2]), '.3eh') '<4.000e+00, 1.047e+00, 9.553e-01, 7.854e-01>' >>> format(Vector([0, 1, 0, 0]), '0.5fh') '<1.00000, 1.57080, 0.00000, 0.00000>' \"\"\"\n\nfrom array import array import reprlib import math import functools import operator\n\n422\n\n|\n\nChapter 12: Special Methods for Sequences\n\nimport itertools\n\nclass Vector: typecode = 'd'\n\ndef __init__(self, components): self._components = array(self.typecode, components)\n\ndef __iter__(self): return iter(self._components)\n\ndef __repr__(self): components = reprlib.repr(self._components) components = components[components.find('['):-1] return f'Vector({components})'\n\ndef __str__(self): return str(tuple(self))\n\ndef __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(self._components))\n\ndef __eq__(self, other): return (len(self) == len(other) and all(a == b for a, b in zip(self, other)))\n\ndef __hash__(self): hashes = (hash(x) for x in self) return functools.reduce(operator.xor, hashes, 0)\n\ndef __abs__(self): return math.hypot(*self)\n\ndef __bool__(self): return bool(abs(self))\n\ndef __len__(self): return len(self._components)\n\ndef __getitem__(self, key): if isinstance(key, slice): cls = type(self) return cls(self._components[key]) index = operator.index(key) return self._components[index]\n\n__match_args__ = ('x', 'y', 'z', 't')\n\ndef __getattr__(self, name): cls = type(self)\n\nVector Take #5: Formatting\n\n|\n\n423\n\ntry: pos = cls.__match_args__.index(name) except ValueError: pos = -1 if 0 <= pos < len(self._components): return self._components[pos] msg = f'{cls.__name__!r} object has no attribute {name!r}' raise AttributeError(msg)\n\ndef angle(self, n): r = math.hypot(*self[n:]) a = math.atan2(r, self[n-1]) if (n == len(self) - 1) and (self[-1] < 0): return math.pi * 2 - a else: return a\n\ndef angles(self): return (self.angle(n) for n in range(1, len(self)))\n\ndef __format__(self, fmt_spec=''): if fmt_spec.endswith('h'): # hyperspherical coordinates fmt_spec = fmt_spec[:-1] coords = itertools.chain([abs(self)], self.angles()) outer_fmt = '<{}>' else: coords = self outer_fmt = '({})' components = (format(c, fmt_spec) for c in coords) return outer_fmt.format(', '.join(components))\n\n@classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(memv)\n\nImport itertools to use chain function in __format__.\n\nCompute one of the angular coordinates, using formulas adapted from the n-sphere article.\n\nCreate a generator expression to compute all angular coordinates on demand.\n\nUse itertools.chain to produce genexp to iterate seamlessly over the magni‐ tude and the angular coordinates.\n\nConfigure a spherical coordinate display with angular brackets.\n\n424\n\n|\n\nChapter 12: Special Methods for Sequences\n\nConfigure a Cartesian coordinate display with parentheses.\n\nCreate a generator expression to format each coordinate item on demand.\n\nPlug parentheses.\n\nformatted components separated by commas\n\ninside brackets or\n\nWe are making heavy use of generator expressions in __format__, angle, and angles, but our focus here is in providing __format__ to bring Vector to the same implementation level as Vector2d. When we cover generators in Chapter 17, we’ll use some of the code in Vector as examples, and then the generator tricks will be explained in detail.\n\nThis concludes our mission for this chapter. The Vector class will be enhanced with infix operators in Chapter 16, but our goal here was to explore techniques for coding special methods that are useful in a wide variety of collection classes.\n\nChapter Summary The Vector example in this chapter was designed to be compatible with Vector2d, except for the use of a different constructor signature accepting a single iterable argu‐ ment, just like the built-in sequence types do. The fact that Vector behaves as a sequence just by implementing __getitem__ and __len__ prompted a discussion of protocols, the informal interfaces used in duck-typed languages.\n\nWe then looked at how the my_seq[a:b:c] syntax works behind the scenes, by creat‐ ing a slice(a, b, c) object and handing it to __getitem__. Armed with this knowl‐ edge, we made Vector respond correctly to slicing, by returning new Vector instances, just like a Pythonic sequence is expected to do.\n\nThe next step was to provide read-only access to the first few Vector components using notation such as my_vec.x. We did it by implementing __getattr__. Doing that opened the possibility of tempting the user to assign to those special components by writing my_vec.x = 7, revealing a potential bug. We fixed it by implementing __setattr__ as well, to forbid assigning values to single-letter attributes. Very often, when you code a __getattr__ you need to add __setattr__ too, in order to avoid inconsistent behavior.\n\nImplementing the __hash__ function provided the perfect context for using func tools.reduce, because we needed to apply the xor operator ^ in succession to the hashes of all Vector components to produce an aggregate hash code for the whole\n\nChapter Summary\n\n|\n\n425\n\nVector. After applying reduce in __hash__, we used the all reducing built-in to cre‐ ate a more efficient __eq__ method.\n\nThe last enhancement to Vector was to reimplement the __format__ method from Vector2d by supporting spherical coordinates as an alternative to the default Carte‐ sian coordinates. We used quite a bit of math and several generators to code __for mat__ and its auxiliary functions, but these are implementation details—and we’ll come back to the generators in Chapter 17. The goal of that last section was to sup‐ port a custom format, thus fulfilling the promise of a Vector that could do everything a Vector2d did, and more.\n\nAs we did in Chapter 11, here we often looked at how standard Python objects behave, to emulate them and provide a “Pythonic” look-and-feel to Vector.\n\nIn Chapter 16, we will implement several infix operators on Vector. The math will be much simpler than in the angle() method here, but exploring how infix operators work in Python is a great lesson in OO design. But before we get to operator over‐ loading, we’ll step back from working on one class and look at organizing multiple classes with interfaces and inheritance, the subjects of Chapters 13 and 14.\n\nFurther Reading Most special methods covered in the Vector example also appear in the Vector2d example from Chapter 11, so the references in “Further Reading” on page 392 are all relevant here.\n\nThe powerful reduce higher-order function is also known as fold, accumulate, aggre‐ gate, compress, and inject. For more information, see Wikipedia’s “Fold (higher- order function)” article, which presents applications of that higher-order function with emphasis on functional programming with recursive data structures. The article also includes a table listing fold-like functions in dozens of programming languages.\n\n“What’s New in Python 2.5” has a short explanation of __index__, designed to sup‐ port __getitem__ methods, as we saw in “A Slice-Aware __getitem__” on page 406. PEP 357—Allowing Any Object to be Used for Slicing details the need for it from the perspective of an implementor of a C-extension—Travis Oliphant, the primary crea‐ tor of NumPy. Oliphant’s many contributions to Python made it a leading scientific computing language, which then positioned it to lead the way in machine learning applications.\n\n426\n\n|\n\nChapter 12: Special Methods for Sequences\n\nSoapbox\n\nProtocols as Informal Interfaces\n\nProtocols are not an invention of Python. The Smalltalk team, which also coined the expression “object-oriented,” used “protocol” as a synonym for what we now call interfaces. Some Smalltalk programming environments allowed programmers to tag a group of methods as a protocol, but that was merely a documentation and navigation aid, and not enforced by the language. That’s why I believe “informal interface” is a reasonable short explanation for “protocol” when I speak to an audience that is more familiar with formal (and compiler enforced) interfaces.\n\nEstablished protocols naturally evolve in any language that uses dynamic typing, that is, when type checking is done at runtime because there is no static type information in method signatures and variables. Ruby is another important object-oriented lan‐ guage that has dynamic typing and uses protocols.\n\nIn the Python documentation, you can often tell when a protocol is being discussed when you see language like “a file-like object.” This is a quick way of saying “some‐ thing that behaves sufficiently like a file, by implementing the parts of the file inter‐ face that are relevant in the context.”\n\nYou may think that implementing only part of a protocol is sloppy, but it has the advantage of keeping things simple. Section 3.3 of the “Data Model” chapter suggests:\n\nWhen implementing a class that emulates any built-in type, it is important that the emulation only be implemented to the degree that it makes sense for the object being modeled. For example, some sequences may work well with retrieval of individual elements, but extracting a slice may not make sense.\n\nWhen we don’t need to code nonsense methods just to fulfill some overdesigned interface contract and keep the compiler happy, it becomes easier to follow the KISS principle.\n\nOn the other hand, if you want to use a type checker to verify your protocol imple‐ mentations, then a stricter definition of protocol is required. That’s what typing.Pro tocol provides.\n\nI’ll have more to say about protocols and interfaces in Chapter 13, where they are the main focus.\n\nOrigins of Duck Typing\n\nI believe the Ruby community, more than any other, helped popularize the term “duck typing,” as they preached to the Java masses. But the expression has been used in Python discussions before either Ruby or Python were “popular.” According to Wikipedia, an early example of the duck analogy in object-oriented programming is a message to the Python-list by Alex Martelli from July 26, 2000: “polymorphism (was\n\nFurther Reading\n\n|\n\n427\n\nRe: Type checking in python?)”. That’s where the quote at the beginning of this chap‐ ter comes from. If you are curious about the literary origins of the “duck typing” term, and the applications of this OO concept in many languages, check out Wikipe‐ dia’s “Duck typing” entry.\n\nA Safe__format__, with Enhanced Usability\n\nWhile implementing __format__, I did not take any precautions regarding Vector instances with a very large number of components, as we did in __repr__ using reprlib. The reasoning is that repr() is for debugging and logging, so it must always generate some serviceable output, while __format__ is used to display output to end users who presumably want to see the entire Vector. If you think this is dangerous, then it would be cool to implement a further extension to the Format Specifier Mini- Language.\n\nHere is how I’d do it: by default, any formatted Vector would display a reasonable but limited number of components, say 30. If there are more elements than that, the default behavior would be similar to what the reprlib does: chop the excess and put ... in its place. However, if the format specifier ended with the special * code, meaning “all,” then the size limitation would be disabled. So a user who’s unaware of the problem of very long displays will not be bitten by it by accident. But if the default limitation becomes a nuisance, then the presence of the ... could lead the user to search the documentation and discover the * formatting code.\n\nThe Search for a Pythonic Sum\n\nThere’s no single answer to “What is Pythonic?” just as there’s no single answer to “What is beautiful?” Saying, as I often do, that it means using “idiomatic Python” is not 100% satisfactory, because what may be “idiomatic” for you may not be for me. One thing I know: “idiomatic” does not mean using the most obscure language fea‐ tures.\n\nIn the Python-list, there’s a thread titled “Pythonic Way to Sum n-th List Element?” from April 2003. It’s relevant to our discussion of reduce in this chapter.\n\nThe original poster, Guy Middleton, asked for an improvement on this solution, stat‐ ing he did not like to use lambda:7\n\n>>> my_list = [[1, 2, 3], [40, 50, 60], [9, 8, 7]] >>> import functools >>> functools.reduce(lambda a, b: a+b, [sub[1] for sub in my_list]) 60\n\n7 I adapted the code for this presentation: in 2003, reduce was a built-in, but in Python 3 we need to import it;\n\nalso, I replaced the names x and y with my_list and sub, for sub-list.\n\n428\n\n|\n\nChapter 12: Special Methods for Sequences\n\nThat code uses lots of idioms: lambda, reduce, and a list comprehension. It would probably come last in a popularity contest, because it offends people who hate lambda and those who despise list comprehensions—pretty much both sides of a divide.\n\nIf you’re going to use lambda, there’s probably no reason to use a list comprehension —except for filtering, which is not the case here.\n\nHere is a solution of my own that will please the lambda lovers:\n\n>>> functools.reduce(lambda a, b: a + b[1], my_list, 0) 60\n\nI did not take part in the original thread, and I wouldn’t use that in real code, because I don’t like lambda too much myself, but I wanted to show an example without a list comprehension.\n\nThe first answer came from Fernando Perez, creator of IPython, highlighting that NumPy supports n-dimensional arrays and n-dimensional slicing:\n\n>>> import numpy as np >>> my_array = np.array(my_list) >>> np.sum(my_array[:, 1]) 60\n\nI think Perez’s solution is cool, but Guy Middleton praised this next solution, by Paul Rubin and Skip Montanaro:\n\n>>> import operator >>> functools.reduce(operator.add, [sub[1] for sub in my_list], 0) 60\n\nThen Evan Simpson asked, “What’s wrong with this?”:\n\n>>> total = 0 >>> for sub in my_list: ... total += sub[1] ... >>> total 60\n\nLots of people agreed that was quite Pythonic. Alex Martelli went as far as saying that’s probably how Guido would code it.\n\nI like Evan Simpson’s code, but I also like David Eppstein’s comment on it:\n\nIf you want the sum of a list of items, you should write it in a way that looks like “the sum of a list of items,” not in a way that looks like “loop over these items, maintain another variable t, perform a sequence of additions.” Why do we have high-level lan‐ guages if not to express our intentions at a higher level and let the language worry about what low-level operations are needed to implement it?\n\nFurther Reading\n\n|\n\n429\n\nThen Alex Martelli comes back to suggest:\n\n“The sum” is so frequently needed that I wouldn’t mind at all if Python singled it out as a built-in. But “reduce(operator.add, …” just isn’t a great way to express it, in my opinion (and yet as an old APL’er, and FP-liker, I should like it—but I don’t).\n\nAlex goes on to suggest a sum() function, which he contributed. It became a built-in in Python 2.3, released only three months after that conversation took place. So Alex’s preferred syntax became the norm:\n\n>>> sum([sub[1] for sub in my_list]) 60\n\nBy the end of the next year (November 2004), Python 2.4 was launched with genera‐ tor expressions, providing what is now in my opinion the most Pythonic answer to Guy Middleton’s original question:\n\n>>> sum(sub[1] for sub in my_list) 60\n\nThis is not only more readable than reduce but also avoids the trap of the empty sequence: sum([]) is 0, simple as that.\n\nIn the same conversation, Alex Martelli suggests the reduce built-in in Python 2 was more trouble than it was worth, because it encouraged coding idioms that were hard to explain. He was most convincing: the function was demoted to the functools module in Python 3.\n\nStill, functools.reduce has its place. It solved the problem of our Vector.__hash__ in a way that I would call Pythonic.\n\n430\n\n|\n\nChapter 12: Special Methods for Sequences\n\nCHAPTER 13 Interfaces, Protocols, and ABCs\n\nProgram to an interface, not an implementation.\n\n—Gamma, Helm, Johnson, Vlissides, First Principle of Object-Oriented Design1\n\nObject-oriented programming is all about interfaces. The best approach to under‐ standing a type in Python is knowing the methods it provides—its interface—as dis‐ cussed in “Types Are Defined by Supported Operations” on page 260 (Chapter 8).\n\nDepending on the programming language, we have one or more ways of defining and using interfaces. Since Python 3.8, we have four ways. They are depicted in the Typing Map (Figure 13-1). We can summarize them like this:\n\nDuck typing\n\nPython’s default approach to typing from the beginning. We’ve been studying duck typing since Chapter 1.\n\nGoose typing\n\nThe approach supported by abstract base classes (ABCs) since Python 2.6, which relies on runtime checks of objects against ABCs. Goose typing is a major subject in this chapter.\n\nStatic typing\n\nThe traditional approach of statically-typed languages like C and Java; supported since Python 3.5 by the typing module, and enforced by external type checkers compliant with PEP 484—Type Hints. This is not the theme of this chapter. Most of Chapter 8 and the upcoming Chapter 15 are about static typing.\n\n1 Design Patterns: Elements of Reusable Object-Oriented Software, “Introduction,” p. 18.\n\n431\n\nStatic duck typing\n\nAn approach made popular by the Go language; supported by subclasses of typ ing.Protocol—new in Python 3.8—also enforced by external type checkers. We first saw this in “Static Protocols” on page 286 (Chapter 8).\n\nThe Typing Map The four typing approaches depicted in Figure 13-1 are complementary: they have different pros and cons. It doesn’t make sense to dismiss any of them.\n\nFigure 13-1. The top half describes runtime type checking approaches using just the Python interpreter; the bottom requires an external static type checker such as MyPy or an IDE like PyCharm. The left quadrants cover typing based on the object’s structure— i.e., the methods provided by the object, regardless of the name of its class or super‐ classes; the right quadrants depend on objects having explicitly named types: the name of the object’s class, or the name of its superclasses.\n\nEach of these four approaches rely on interfaces to work, but static typing can be done—poorly—using only concrete types instead of interface abstractions like proto‐ cols and abstract base classes. This chapter is about duck typing, goose typing, and static duck typing—typing disciplines that revolve around interfaces.\n\n432\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "page_number": 433
    },
    {
      "number": 23,
      "title": "Segment 23 (pages 454-475)",
      "start_page": 454,
      "end_page": 475,
      "detection_method": "synthetic",
      "content": "This chapter is split in four main sections, addressing three of the four quadrants in the Typing Map (Figure 13-1):\n\n“Two Kinds of Protocols” on page 434 compares the two forms of structural typing with protocols—i.e., the lefthand side of the Typing Map.\n\n“Programming Ducks” on page 435 dives deeper into Python’s usual duck typing, including how to make it safer while preserving its major strength: flexibility.\n\n“Goose Typing” on page 442 explains the use of ABCs for stricter runtime type checking. This is the longest section, not because it’s more important, but because there are more sections about duck typing, static duck typing, and static typing elsewhere in the book.\n\n“Static Protocols” on page 466 covers usage, implementation, and design of typ ing.Protocol subclasses—useful for static and runtime type checking.\n\nWhat’s New in This Chapter This chapter was heavily edited and is about 24% longer than the corresponding Chapter 11 in the first edition of Fluent Python. Although some sections and many paragraphs are the same, there’s a lot of new content. These are the highlights:\n\nThe chapter introduction and the Typing Map (Figure 13-1) are new. That’s the key to most new content in this chapter—and all other chapters related to typing in Python ≥ 3.8.\n\n“Two Kinds of Protocols” on page 434 explains the similarities and differences between dynamic and static protocols.\n\n“Defensive Programming and ‘Fail Fast’” on page 440 mostly reproduces content from the first edition, but was updated and now has a section title to highlight its importance.\n\n“Static Protocols” on page 466 is all new. It builds on the initial presentation in “Static Protocols” on page 286 (Chapter 8).\n\nUpdated class diagrams of collections.abc in Figures 13-2, 13-3, and 13-4 to include the Collection ABC, from Python 3.6.\n\nThe first edition of Fluent Python had a section encouraging use of the numbers ABCs for goose typing. In “The numbers ABCs and Numeric Protocols” on page 478, I explain why you should use numeric static protocols from the typing module instead, if you plan to use static type checkers as well as runtime checks in the style of goose typing.\n\nWhat’s New in This Chapter\n\n|\n\n433\n\nTwo Kinds of Protocols The word protocol has different meanings in computer science depending on context. A network protocol such as HTTP specifies commands that a client can send to a server, such as GET, PUT, and HEAD. We saw in “Protocols and Duck Typing” on page 402 that an object protocol specifies methods which an object must provide to fulfill a role. The FrenchDeck example in Chapter 1 demonstrated one object protocol, the sequence protocol: the methods that allow a Python object to behave as a sequence.\n\nImplementing a full protocol may require several methods, but often it is OK to implement only part of it. Consider the Vowels class in Example 13-1.\n\nExample 13-1. Partial sequence protocol implementation with __getitem__\n\n>>> class Vowels: ... def __getitem__(self, i): ... return 'AEIOU'[i] ... >>> v = Vowels() >>> v[0] 'A' >>> v[-1] 'U' >>> for c in v: print(c) ... A E I O U >>> 'E' in v True >>> 'Z' in v False\n\nImplementing __getitem__ is enough to allow retrieving items by index, and also to support iteration and the in operator. The __getitem__ special method is really the key to the sequence protocol. Take a look at this entry from the Python/C API Refer‐ ence Manual, “Sequence Protocol” section:\n\nint PySequence_Check(PyObject *o)\n\nReturn 1 if the object provides sequence protocol, and 0 otherwise. Note that it returns 1 for Python classes with a __getitem__() method unless they are dict subclasses […].\n\nWe expect a sequence to also support len(), by implementing __len__. Vowels has no __len__ method, but it still behaves as a sequence in some contexts. And that may\n\n434\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nbe enough for our purposes. That is why I like to say that a protocol is an “informal interface.” That is also how protocols are understood in Smalltalk, the first object- oriented programming environment to use that term.\n\nExcept in pages about network programming, most uses of the word “protocol” in the Python documentation refer to these informal interfaces.\n\nNow, with the adoption of PEP 544—Protocols: Structural subtyping (static duck typing) in Python 3.8, the word “protocol” has another meaning in Python—closely related, but different. As we saw in “Static Protocols” on page 286 (Chapter 8), PEP 544 allows us to create subclasses of typing.Protocol to define one or more methods that a class must implement (or inherit) to satisfy a static type checker.\n\nWhen I need to be specific, I will adopt these terms:\n\nDynamic protocol\n\nThe informal protocols Python always had. Dynamic protocols are implicit, defined by convention, and described in the documentation. Python’s most important dynamic protocols are supported by the interpreter itself, and are doc‐ umented in the “Data Model” chapter of The Python Language Reference.\n\nStatic protocol\n\nA protocol as defined by PEP 544—Protocols: Structural subtyping (static duck typing), since Python 3.8. A static protocol has an explicit definition: a typ ing.Protocol subclass.\n\nThere are two key differences between them:\n\nAn object may implement only part of a dynamic protocol and still be useful; but to fulfill a static protocol, the object must provide every method declared in the protocol class, even if your program doesn’t need them all.\n\nStatic protocols can be verified by static type checkers, but dynamic protocols can’t.\n\nBoth kinds of protocols share the essential characteristic that a class never needs to declare that it supports a protocol by name, i.e., by inheritance.\n\nIn addition to static protocols, Python provides another way of defining an explicit interface in code: an abstract base class (ABC).\n\nThe rest of this chapter covers dynamic and static protocols, as well as ABCs.\n\nProgramming Ducks Let’s start our discussion of dynamic protocols with two of the most important in Python: the sequence and iterable protocols. The interpreter goes out of its way to\n\nProgramming Ducks\n\n|\n\n435\n\nhandle objects that provide even a minimal implementation of those protocols, as the next section explains.\n\nPython Digs Sequences The philosophy of the Python Data Model is to cooperate with essential dynamic protocols as much as possible. When it comes to sequences, Python tries hard to work with even the simplest implementations.\n\nFigure 13-2 shows how the Sequence interface is formalized as an ABC. The Python interpreter and built-in sequences like list, str, etc., do not rely on that ABC at all. I am using it only to describe what a full-fledged Sequence is expected to support.\n\nFigure 13-2. UML class diagram for the Sequence ABC and related abstract classes from collections.abc. Inheritance arrows point from a subclass to its superclasses. Names in italic are abstract methods. Before Python 3.6, there was no Collection ABC—Sequence was a direct subclass of Container, Iterable, and Sized.\n\nMost ABCs in the collections.abc module exist to formalize interfaces that are implemented by built-in objects and are implic‐ itly supported by the interpreter—both of which predate the ABCs themselves. The ABCs are useful as starting points for new classes, and to support explicit type checking at runtime (a.k.a. goose typ‐ ing) as well as type hints for static type checkers.\n\nStudying Figure 13-2, we see that a correct subclass of Sequence must implement __getitem__ and __len__ (from Sized). All the other methods in Sequence are con‐ crete, so subclasses can inherit their implementations—or provide better ones.\n\nNow, recall the Vowels class in Example 13-1. It does not inherit from abc.Sequence and it only implements __getitem__.\n\nThere is no __iter__ method, yet Vowels instances are iterable because—as a fallback —if Python finds a __getitem__ method, it tries to iterate over the object by calling that method with integer indexes starting with 0. Because Python is smart enough to\n\n436\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\niterate over Vowels instances, it can also make the in operator work even when the __contains__ method is missing: it does a sequential scan to check if an item is present.\n\nIn summary, given the importance of sequence-like data structures, Python manages to make iteration and the in operator work by invoking __getitem__ when __iter__ and __contains__ are unavailable.\n\nThe original FrenchDeck from Chapter 1 does not subclass abc.Sequence either, but it does implement both methods of the sequence protocol: __getitem__ and __len__. See Example 13-2.\n\nExample 13-2. A deck as a sequence of cards (same as Example 1-1)\n\nimport collections\n\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n\nclass FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split()\n\ndef __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\ndef __len__(self): return len(self._cards)\n\ndef __getitem__(self, position): return self._cards[position]\n\nSeveral of the examples in Chapter 1 work because of the special treatment Python gives to anything vaguely resembling a sequence. The iterable protocol in Python represents an extreme form of duck typing: the interpreter tries two different meth‐ ods to iterate over objects.\n\nTo be clear, the behaviors I described in this section are implemented in the inter‐ preter itself, mostly in C. They do not depend on methods from the Sequence ABC. For example, the concrete methods __iter__ and __contains__ in the Sequence class emulate the built-in behaviors of the Python interpreter. If you are curious, check the source code of these methods in Lib/_collections_abc.py.\n\nNow let’s study another example emphasizing the dynamic nature of protocols—and why static type checkers have no chance of dealing with them.\n\nProgramming Ducks\n\n|\n\n437\n\nMonkey Patching: Implementing a Protocol at Runtime Monkey patching is dynamically changing a module, class, or function at runtime, to add features or fix bugs. For example, the gevent networking library monkey patches parts of Python’s standard library to allow lightweight concurrency without threads or async/await.2\n\nThe FrenchDeck class from Example 13-2 is missing an essential feature: it cannot be shuffled. Years ago when I first wrote the FrenchDeck example, I did implement a shuffle method. Later I had a Pythonic insight: if a FrenchDeck acts like a sequence, then it doesn’t need its own shuffle method because there is already random.shuf fle, documented as “Shuffle the sequence x in place.”\n\nThe standard random.shuffle function is used like this:\n\n>>> from random import shuffle >>> l = list(range(10)) >>> shuffle(l) >>> l [5, 2, 9, 7, 8, 3, 1, 4, 0, 6]\n\nWhen you follow established protocols, you improve your chances of leveraging existing standard library and third-party code, thanks to duck typing.\n\nHowever, if we try to shuffle a FrenchDeck instance, we get an exception, as in Example 13-3.\n\nExample 13-3. random.shuffle cannot handle FrenchDeck\n\n>>> from random import shuffle >>> from frenchdeck import FrenchDeck >>> deck = FrenchDeck() >>> shuffle(deck) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \".../random.py\", line 265, in shuffle x[i], x[j] = x[j], x[i] TypeError: 'FrenchDeck' object does not support item assignment\n\nThe error message is clear: 'FrenchDeck' object does not support item assign ment. The problem is that shuffle operates in place, by swapping items inside the\n\n2 The “Monkey patch” article on Wikipedia has a funny example in Python.\n\n438\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\ncollection, and FrenchDeck only implements the immutable sequence protocol. Mutable sequences must also provide a __setitem__ method.\n\nBecause Python is dynamic, we can fix this at runtime, even at the interactive console. Example 13-4 shows how to do it.\n\nExample 13-4. Monkey patching FrenchDeck to make it mutable and compatible with random.shuffle (continuing from Example 13-3)\n\n>>> def set_card(deck, position, card): ... deck._cards[position] = card ... >>> FrenchDeck.__setitem__ = set_card >>> shuffle(deck) >>> deck[:5] [Card(rank='3', suit='hearts'), Card(rank='4', suit='diamonds'), Card(rank='4', suit='clubs'), Card(rank='7', suit='hearts'), Card(rank='9', suit='spades')]\n\nCreate a function that takes deck, position, and card as arguments.\n\nAssign that function to an attribute named __setitem__ in the FrenchDeck class.\n\ndeck can now be shuffled because I added the necessary method of the mutable sequence protocol.\n\nThe signature of the __setitem__ special method is defined in The Python Language Reference in “3.3.6. Emulating container types”. Here I named the arguments deck, position, card—and not self, key, value as in the language reference—to show that every Python method starts life as a plain function, and naming the first argu‐ ment self is merely a convention. This is OK in a console session, but in a Python source file it’s much better to use self, key, and value as documented.\n\nThe trick is that set_card knows that the deck object has an attribute named _cards, and _cards must be a mutable sequence. The set_card function is then attached to the FrenchDeck class as the __setitem__ special method. This is an example of mon‐ key patching: changing a class or module at runtime, without touching the source code. Monkey patching is powerful, but the code that does the actual patching is very tightly coupled with the program to be patched, often handling private and undocu‐ mented attributes.\n\nBesides being an example of monkey patching, Example 13-4 highlights the dynamic nature of protocols in dynamic duck typing: random.shuffle doesn’t care about the class of the argument, it only needs the object to implement methods from the muta‐ ble sequence protocol. It doesn’t even matter if the object was “born” with the neces‐ sary methods or if they were somehow acquired later.\n\nProgramming Ducks\n\n|\n\n439\n\nDuck typing doesn’t need to be wildly unsafe or hard to debug. The next section shows some useful code patterns to detect dynamic protocols without resorting to explicit checks.\n\nDefensive Programming and “Fail Fast” Defensive programming is like defensive driving: a set of practices to enhance safety even when faced with careless programmers—or drivers.\n\nMany bugs cannot be caught except at runtime—even in mainstream statically typed languages.3 In a dynamically typed language, “fail fast” is excellent advice for safer and easier-to-maintain programs. Failing fast means raising runtime errors as soon as possible, for example, rejecting invalid arguments right a the beginning of a func‐ tion body.\n\nHere is one example: when you write code that accepts a sequence of items to process internally as a list, don’t enforce a list argument by type checking. Instead, take the argument and immediately build a list from it. One example of this code pattern is the __init__ method in Example 13-10, later in this chapter:\n\ndef __init__(self, iterable): self._balls = list(iterable)\n\nThat way you make your code more flexible, because the list() constructor handles any iterable that fits in memory. If the argument is not iterable, the call will fail fast with a very clear TypeError exception, right when the object is initialized. If you want to be more explict, you can wrap the list() call with try/except to customize the error message—but I’d use that extra code only on an external API, because the prob‐ lem would be easy to see for maintainers of the codebase. Either way, the offending call will appear near the end of the traceback, making it straightforward to fix. If you don’t catch the invalid argument in the class constructor, the program will blow up later, when some other method of the class needs to operate on self._balls and it is not a list. Then the root cause will be harder to find.\n\nOf course, calling list() on the argument would be bad if the data shouldn’t be copied, either because it’s too large or because the function, by design, needs to change it in place for the benefit of the caller, like random.shuffle does. In that case, a runtime check like isinstance(x, abc.MutableSequence) would be the way to go.\n\nIf you are afraid to get an infinite generator—not a common issue—you can begin by calling len() on the argument. This would reject iterators, while safely dealing with tuples, arrays, and other existing or future classes that fully implement the Sequence\n\n3 That’s why automated testing is necessary.\n\n440\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\ninterface. Calling len() is usually very cheap, and an invalid argument will raise an error immediately.\n\nOn the other hand, if any iterable is acceptable, then call iter(x) as soon as possible to obtain an iterator, as we’ll see in “Why Sequences Are Iterable: The iter Function” on page 596. Again, if x is not iterable, this will fail fast with an easy-to-debug exception.\n\nIn the cases I just described, a type hint could catch some problems earlier, but not all problems. Recall that the type Any is consistent-with every other type. Type inference may cause a variable to be tagged with the Any type. When that happens, the type checker is in the dark. In addition, type hints are not enforced at runtime. Fail fast is the last line of defense.\n\nDefensive code leveraging duck types can also include logic to handle different types without using isinstance() or hasattr() tests.\n\nOne example is how we might emulate the handling of the field_names argument in collections.namedtuple: field_names accepts a single string with identifiers sepa‐ rated by spaces or commas, or a sequence of identifiers. Example 13-5 shows how I’d do it using duck typing.\n\nExample 13-5. Duck typing to handle a string or an iterable of strings\n\ntry: field_names = field_names.replace(',', ' ').split() except AttributeError: pass field_names = tuple(field_names) if not all(s.isidentifier() for s in field_names): raise ValueError('field_names must all be valid identifiers')\n\nAssume it’s a string (EAFP = it’s easier to ask forgiveness than permission).\n\nConvert commas to spaces and split the result into a list of names.\n\nSorry, field_names doesn’t quack like a str: it has no .replace, or it returns something we can’t .split.\n\nIf AttributeError was raised, then field_names is not a str and we assume it was already an iterable of names.\n\nTo make sure it’s an iterable and to keep our own copy, create a tuple out of what we have. A tuple is more compact than list, and it also prevents my code from changing the names by mistake.\n\nProgramming Ducks\n\n|\n\n441\n\nUse str.isidentifier to ensure every name is valid.\n\nExample 13-5 shows one situation where duck typing is more expressive than static type hints. There is no way to spell a type hint that says “field_names must be a string of identifiers separated by spaces or commas.” This is the relevant part of the namedtuple signature on typeshed (see the full source at stdlib/3/collections/ __init__.pyi):\n\ndef namedtuple( typename: str, field_names: Union[str, Iterable[str]], *, # rest of signature omitted\n\nAs you can see, field_names is annotated as Union[str, Iterable[str]], which is OK as far as it goes, but is not enough to catch all possible problems.\n\nAfter reviewing dynamic protocols, we move to a more explicit form of runtime type checking: goose typing.\n\nGoose Typing\n\nAn abstract class represents an interface. —Bjarne Stroustrup, creator of C++4\n\nPython doesn’t have an interface keyword. We use abstract base classes (ABCs) to define interfaces for explicit type checking at runtime—also supported by static type checkers.\n\nThe Python Glossary entry for abstract base class has a good explanation of the value they bring to duck-typed languages:\n\nAbstract base classes complement duck typing by providing a way to define interfaces when other techniques like hasattr() would be clumsy or subtly wrong (for example, with magic methods). ABCs introduce virtual subclasses, which are classes that don’t inherit from a class but are still recognized by isinstance() and issubclass(); see the abc module documentation.5\n\nGoose typing is a runtime type checking approach that leverages ABCs. I will let Alex Martelli explain in “Waterfowl and ABCs” on page 443.\n\n4 Bjarne Stroustrup, The Design and Evolution of C++, p. 278 (Addison-Wesley).\n\n5 Retrieved October 18, 2020.\n\n442\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nI am very grateful to my friends Alex Martelli and Anna Raven‐ scroft. I showed them the first outline of Fluent Python at OSCON 2013, and they encouraged me to submit it for publication with O’Reilly. Both later contributed with thorough tech reviews. Alex was already the most cited person in this book, and then he offered to write this essay. Take it away, Alex!\n\nWaterfowl and ABCs\n\nBy Alex Martelli\n\nI’ve been credited on Wikipedia for helping spread the helpful meme and sound-bite “duck typing” (i.e, ignoring an object’s actual type, focusing instead on ensuring that the object implements the method names, signatures, and semantics required for its intended use).\n\nIn Python, this mostly boils down to avoiding the use of isinstance to check the object’s type (not to mention the even worse approach of checking, for example, whether type(foo) is bar—which is rightly anathema as it inhibits even the sim‐ plest forms of inheritance!).\n\nThe overall duck typing approach remains quite useful in many contexts—and yet, in many others, an often preferable one has evolved over time. And herein lies a tale…\n\nIn recent generations, the taxonomy of genus and species (including, but not limited to, the family of waterfowl known as Anatidae) has mostly been driven by phenetics— an approach focused on similarities of morphology and behavior…chiefly, observable traits. The analogy to “duck typing” was strong.\n\nHowever, parallel evolution can often produce similar traits, both morphological and behavioral ones, among species that are actually unrelated, but just happened to evolve in similar, though separate, ecological niches. Similar “accidental similarities” happen in programming, too—for example, consider the classic object-oriented pro‐ gramming example:\n\nclass Artist: def draw(self): ...\n\nclass Gunslinger: def draw(self): ...\n\nclass Lottery: def draw(self): ...\n\nClearly, the mere existence of a method named draw, callable without arguments, is far from sufficient to assure us that two objects x and y, such that x.draw() and y.draw() can be called, are in any way exchangeable or abstractly equivalent—\n\nGoose Typing\n\n|\n\n443\n\nnothing about the similarity of the semantics resulting from such calls can be infer‐ red. Rather, we need a knowledgeable programmer to somehow positively assert that such an equivalence holds at some level!\n\nIn biology (and other disciplines), this issue has led to the emergence (and, on many facets, the dominance) of an approach that’s an alternative to phenetics, known as cladistics—focusing taxonomical choices on characteristics that are inherited from common ancestors, rather than ones that are independently evolved. (Cheap and rapid DNA sequencing can make cladistics highly practical in many more cases in recent years.)\n\nFor example, sheldgeese (once classified as being closer to other geese) and shelducks (once classified as being closer to other ducks) are now grouped together within the subfamily Tadornidae (implying they’re closer to each other than to any other Anatidae, as they share a closer common ancestor). Furthermore, DNA analysis has shown, in particular, that the white-winged wood duck is not as close to the Muscovy duck (the latter being a shelduck) as similarity in looks and behavior had long sug‐ gested—so the wood duck was reclassified into its own genus, and entirely out of the subfamily!\n\nDoes this matter? It depends on the context! For such purposes as deciding how best to cook a waterfowl once you’ve bagged it, for example, specific observable traits (not all of them—plumage, for example, is de minimis in such a context), mostly texture and flavor (old-fashioned phenetics!), may be far more relevant than cladistics. But for other issues, such as susceptibility to different pathogens (whether you’re trying to raise waterfowl in captivity, or preserve them in the wild), DNA closeness can matter much more.\n\nSo, by very loose analogy with these taxonomic revolutions in the world of water‐ fowls, I’m recommending supplementing (not entirely replacing—in certain contexts it shall still serve) good old duck typing with…goose typing!\n\nWhat goose typing means is: isinstance(obj, cls) is now just fine…as long as cls is an abstract base class—in other words, cls’s metaclass is abc.ABCMeta.\n\nYou can find many useful existing abstract classes in collections.abc (and addi‐ tional ones in the numbers module of The Python Standard Library).6\n\nAmong the many conceptual advantages of ABCs over concrete classes (e.g., Scott Meyer’s “all non-leaf classes should be abstract”; see Item 33 in his book, More\n\n6 You can also, of course, define your own ABCs—but I would discourage all but the most advanced Pythonis‐ tas from going that route, just as I would discourage them from defining their own custom metaclasses…and even for said “most advanced Pythonistas,” those of us sporting deep mastery of every fold and crease in the language, these are not tools for frequent use. Such “deep metaprogramming,” if ever appropriate, is intended for authors of broad frameworks meant to be independently extended by vast numbers of separate develop‐ ment teams…less than 1% of “most advanced Pythonistas” may ever need that! — A.M.\n\n444\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nEffective C++, Addison-Wesley), Python’s ABCs add one major practical advantage: the register class method, which lets end-user code “declare” that a certain class becomes a “virtual” subclass of an ABC (for this purpose, the registered class must meet the ABC’s method name and signature requirements, and more importantly, the underlying semantic contract—but it need not have been developed with any awareness of the ABC, and in particular need not inherit from it!). This goes a long way toward breaking the rigidity and strong coupling that make inheritance some‐ thing to use with much more caution than typically practiced by most object-oriented programmers.\n\nSometimes you don’t even need to register a class for an ABC to recognize it as a subclass!\n\nThat’s the case for the ABCs whose essence boils down to a few special methods. For example:\n\n>>> class Struggle: ... def __len__(self): return 23 ... >>> from collections import abc >>> isinstance(Struggle(), abc.Sized) True\n\nAs you see, abc.Sized recognizes Struggle as “a subclass,” with no need for registra‐ tion, as implementing the special method named __len__ is all it takes (it’s supposed to be implemented with the proper syntax—callable without arguments—and seman‐ tics—returning a nonnegative integer denoting an object’s “length”; any code that implements a specially named method, such as __len__, with arbitrary, non- compliant syntax and semantics has much worse problems anyway).\n\nSo, here’s my valediction: whenever you’re implementing a class embodying any of the concepts represented in the ABCs in numbers, collections.abc, or other frame‐ work you may be using, be sure (if needed) to subclass it from, or register it into, the corresponding ABC. At the start of your programs using some library or framework defining classes which have omitted to do that, perform the registrations yourself; then, when you must check for (most typically) an argument being, e.g, “a sequence,” check whether:\n\nisinstance(the_arg, collections.abc.Sequence)\n\nAnd, don’t define custom ABCs (or metaclasses) in production code. If you feel the urge to do so, I’d bet it’s likely to be a case of the “all problems look like a nail”–syn‐ drome for somebody who just got a shiny new hammer—you (and future maintain‐ ers of your code) will be much happier sticking with straightforward and simple code, eschewing such depths. Valē!\n\nGoose Typing\n\n|\n\n445\n\nTo summarize, goose typing entails:\n\nSubclassing from ABCs to make it explict that you are implementing a previously defined interface.\n\nRuntime type checking using ABCs instead of concrete classes as the second argument for isinstance and issubclass.\n\nAlex makes the point that inheriting from an ABC is more than implementing the required methods: it’s also a clear declaration of intent by the developer. That intent can also be made explicit through registering a virtual subclass.\n\nDetails of using register are covered in “A Virtual Subclass of an ABC” on page 460, later in this chapter. For now, here is a brief example: given the FrenchDeck class, if I want it to pass a check like issubclass(FrenchDeck, Sequence), I can make it a virtual sub‐ class of the Sequence ABC with these lines: from collections.abc import Sequence Sequence.register(FrenchDeck)\n\nThe use of isinstance and issubclass becomes more acceptable if you are checking against ABCs instead of concrete classes. If used with concrete classes, type checks limit polymorphism—an essential feature of object-oriented programming. But with ABCs these tests are more flexible. After all, if a component does not implement an ABC by subclassing—but does implement the required methods—it can always be registered after the fact so it passes those explicit type checks.\n\nHowever, even with ABCs, you should beware that excessive use of isinstance checks may be a code smell—a symptom of bad OO design.\n\nIt’s usually not OK to have a chain of if/elif/elif with isinstance checks per‐ forming different actions depending on the type of object: you should be using poly‐ morphism for that—i.e., design your classes so that the interpreter dispatches calls to the proper methods, instead of you hardcoding the dispatch logic in if/elif/elif blocks.\n\nOn the other hand, it’s OK to perform an isinstance check against an ABC if you must enforce an API contract: “Dude, you have to implement this if you want to call me,” as technical reviewer Lennart Regebro put it. That’s particularly useful in sys‐ tems that have a plug-in architecture. Outside of frameworks, duck typing is often simpler and more flexible than type checks.\n\nFinally, in his essay, Alex reinforces more than once the need for restraint in the cre‐ ation of ABCs. Excessive use of ABCs would impose ceremony in a language that\n\n446\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nbecame popular because it is practical and pragmatic. During the Fluent Python review process, Alex wrote in an e-mail:\n\nABCs are meant to encapsulate very general concepts, abstractions, introduced by a framework—things like “a sequence” and “an exact number.” [Readers] most likely don’t need to write any new ABCs, just use existing ones correctly, to get 99.9% of the benefits without serious risk of misdesign.\n\nNow let’s see goose typing in practice.\n\nSubclassing an ABC Following Martelli’s advice, we’ll leverage an existing ABC, collections.MutableSe quence, before daring to invent our own. In Example 13-6, FrenchDeck2 is explicitly declared a subclass of collections.MutableSequence.\n\nExample 13-6. frenchdeck2.py: FrenchDeck2, a subclass of collections.MutableSe quence\n\nfrom collections import namedtuple, abc\n\nCard = namedtuple('Card', ['rank', 'suit'])\n\nclass FrenchDeck2(abc.MutableSequence): ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split()\n\ndef __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\ndef __len__(self): return len(self._cards)\n\ndef __getitem__(self, position): return self._cards[position]\n\ndef __setitem__(self, position, value): self._cards[position] = value\n\ndef __delitem__(self, position): del self._cards[position]\n\ndef insert(self, position, value): self._cards.insert(position, value)\n\nGoose Typing\n\n|\n\n447\n\n__setitem__ is all we need to enable shuffling…\n\n…but subclassing MutableSequence forces us to implement __delitem__, an abstract method of that ABC.\n\nWe are also required to implement insert, the third abstract method of MutableSequence.\n\nPython does not check for the implementation of the abstract methods at import time (when the frenchdeck2.py module is loaded and compiled), but only at runtime when we actually try to instantiate FrenchDeck2. Then, if we fail to implement any of the abstract methods, we get a TypeError exception with a message such as \"Can't instantiate abstract class FrenchDeck2 with abstract methods __delitem__, insert\". That’s why we must implement __delitem__ and insert, even if our FrenchDeck2 examples do not need those behaviors: the MutableSequence ABC demands them.\n\nAs Figure 13-3 shows, not all methods of the Sequence and MutableSequence ABCs are abstract.\n\nFigure 13-3. UML class diagram for the MutableSequence ABC and its superclasses from collections.abc (inheritance arrows point from subclasses to ancestors; names in italic are abstract classes and abstract methods).\n\nTo write FrenchDeck2 as a subclass of MutableSequence, I had to pay the price of implementing __delitem__ and insert, which my examples did not require. In return, FrenchDeck2 inherits five concrete methods from Sequence: __contains__, __iter__, __reversed__, index, and count. From MutableSequence, it gets another six methods: append, reverse, extend, pop, remove, and __iadd__—which supports the += operator for in place concatenation.\n\nThe concrete methods in each collections.abc ABC are implemented in terms of the public interface of the class, so they work without any knowledge of the internal structure of instances.\n\n448\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nAs the coder of a concrete subclass, you may be able to override methods inherited from ABCs with more efficient implementa‐ tions. For example, __contains__ works by doing a sequential scan of the sequence, but if your concrete sequence keeps its items sor‐ ted, you can write a faster __contains__ that does a binary search using the bisect function from the standard library. See “Manag‐ ing Ordered Sequences with Bisect” at fluentpython.com to learn more about it.\n\nTo use ABCs well, you need to know what’s available. We’ll review the collections ABCs next.\n\nABCs in the Standard Library Since Python 2.6, the standard library provides several ABCs. Most are defined in the collections.abc module, but there are others. You can find ABCs in the io and numbers packages, for example. But the most widely used are in collections.abc.\n\nThere are two modules named abc in the standard library. Here we are talking about collections.abc. To reduce loading time, since Python 3.4 that module is implemented outside of the collections package—in Lib/_collections_abc.py—so it’s imported separately from collections. The other abc module is just abc (i.e., Lib/ abc.py) where the abc.ABC class is defined. Every ABC depends on the abc module, but we don’t need to import it ourselves except to create a brand-new ABC.\n\nFigure 13-4 is a summary UML class diagram (without attribute names) of 17 ABCs defined in collections.abc. The documentation of collections.abc has a nice table summarizing the ABCs, their relationships, and their abstract and concrete methods (called “mixin methods”). There is plenty of multiple inheritance going on in Figure 13-4. We’ll devote most of Chapter 14 to multiple inheritance, but for now it’s enough to say that it is usually not a problem when ABCs are concerned.7\n\n7 Multiple inheritance was considered harmful and excluded from Java, except for interfaces: Java interfaces can\n\nextend multiple interfaces, and Java classes can implement multiple interfaces.\n\nGoose Typing\n\n|\n\n449\n\nFigure 13-4. UML class diagram for ABCs in collections.abc.\n\nLet’s review the clusters in Figure 13-4:\n\nIterable, Container, Sized\n\nEvery collection should either inherit from these ABCs or implement compatible protocols. Iterable supports iteration with __iter__, Container supports the in operator with __contains__, and Sized supports len() with __len__.\n\nCollection\n\nThis ABC has no methods of its own, but was added in Python 3.6 to make it easier to subclass from Iterable, Container, and Sized.\n\nSequence, Mapping, Set\n\nThese are the main immutable collection types, and each has a mutable subclass. A detailed diagram for MutableSequence is in Figure 13-3; for MutableMapping and MutableSet, see Figures 3-1 and 3-2 in Chapter 3.\n\nMappingView\n\nIn Python 3, the objects returned from the mapping methods .items(), .keys(), and .values() implement the interfaces defined in ItemsView, KeysView, and ValuesView, respectively. The first two also implement the rich interface of Set, with all the operators we saw in “Set Operations” on page 107.\n\nIterator\n\nNote that iterator subclasses Iterable. We discuss this further in Chapter 17.\n\n450\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nCallable, Hashable\n\nThese are not collections, but collections.abc was the first package to define ABCs in the standard library, and these two were deemed important enough to be included. They support type checking objects that must be callable or hashable.\n\nFor callable detection, the callable(obj) built-in function is more convenient than insinstance(obj, Callable).\n\nIf insinstance(obj, Hashable) returns False, you can be certain that obj is not hashable. But if the return is True, it may be a false positive. The next box explains.\n\nisinstance with Hashable and Iterable Can Be Misleading It’s easy to misinterpret the results of the isinstance and issubclass tests against the Hashable and Iterable ABCs.\n\nIf isinstance(obj, Hashable) returns True, that only means that the class of obj implements or inherits __hash__. But if obj is a tuple containing unhashable items, then obj is not hashable, despite the positive result of the isinstance check. Tech reviewer Jürgen Gmach pointed out that duck typing provides the most accurate way to determine if an instance is hashable: call hash(obj). That call will raise TypeError if obj is not hashable.\n\nOn the other hand, even when isinstance(obj, Iterable) returns False, Python may still be able to iterate over obj using __getitem__ with 0-based indices, as we saw in Chapter 1 and “Python Digs Sequences” on page 436. The documentation for collections.abc.Iterable states:\n\nThe only reliable way to determine whether an object is iterable is to call iter(obj).\n\nAfter looking at some existing ABCs, let’s practice goose typing by implementing an ABC from scratch and putting it to use. The goal here is not to encourage everyone to start creating ABCs left and right, but to learn how to read the source code of the ABCs you’ll find in the standard library and other packages.\n\nDefining and Using an ABC This warning appeared in the “Interfaces” chapter of the first edition of Fluent Python:\n\nABCs, like descriptors and metaclasses, are tools for building frameworks. Therefore, only a small minority of Python developers can create ABCs without imposing unrea‐ sonable limitations and needless work on fellow programmers.\n\nGoose Typing\n\n|\n\n451\n\nNow ABCs have more potential use cases in type hints to support static typing. As discussed in “Abstract Base Classes” on page 278, using ABCs instead of concrete types in function argument type hints gives more flexibility to the caller.\n\nTo justify creating an ABC, we need to come up with a context for using it as an extension point in a framework. So here is our context: imagine you need to display advertisements on a website or a mobile app in random order, but without repeating an ad before the full inventory of ads is shown. Now let’s assume we are building an ad management framework called ADAM. One of its requirements is to support user- provided nonrepeating random-picking classes.8 To make it clear to ADAM users what is expected of a “nonrepeating random-picking” component, we’ll define an ABC.\n\nIn the literature about data structures, “stack” and “queue” describe abstract inter‐ faces in terms of physical arrangements of objects. I will follow suit and use a real- world metaphor to name our ABC: bingo cages and lottery blowers are machines designed to pick items at random from a finite set, without repeating, until the set is exhausted.\n\nThe ABC will be named Tombola, after the Italian name of bingo and the tumbling container that mixes the numbers.\n\nThe Tombola ABC has four methods. The two abstract methods are:\n\n.load(…)\n\nPut items into the container.\n\n.pick()\n\nRemove one item at random from the container, returning it.\n\nThe concrete methods are:\n\n.loaded()\n\nReturn True if there is at least one item in the container.\n\n.inspect()\n\nReturn a tuple built from the items currently in the container, without changing its contents (the internal ordering is not preserved).\n\nFigure 13-5 shows the Tombola ABC and three concrete implementations.\n\n8 Perhaps the client needs to audit the randomizer; or the agency wants to provide a rigged one. You never\n\nknow…\n\n452\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nFigure 13-5. UML diagram for an ABC and three subclasses. The name of the Tombola ABC and its abstract methods are written in italics, per UML conventions. The dashed arrow is used for interface implementation—here I am using it to show that TomboList not only implements the Tombola interface, but is also registered as virtual subclass of Tombola—as we will see later in this chapter.9\n\nExample 13-7 shows the definition of the Tombola ABC.\n\nExample 13-7. tombola.py: Tombola is an ABC with two abstract methods and two concrete methods\n\nimport abc\n\nclass Tombola(abc.ABC):\n\n@abc.abstractmethod def load(self, iterable): \"\"\"Add items from an iterable.\"\"\"\n\n@abc.abstractmethod def pick(self): \"\"\"Remove item at random, returning it.\n\nThis method should raise `LookupError` when the instance is empty. \"\"\"\n\ndef loaded(self): \"\"\"Return `True` if there's at least 1 item, `False` otherwise.\"\"\"\n\n9 «registered» and «virtual subclass» are not standard UML terms. I am using them to represent a class relation‐\n\nship that is specific to Python.\n\nGoose Typing\n\n|\n\n453\n\nreturn bool(self.inspect())\n\ndef inspect(self): \"\"\"Return a sorted tuple with the items currently inside.\"\"\" items = [] while True: try: items.append(self.pick()) except LookupError: break self.load(items) return tuple(items)\n\nTo define an ABC, subclass abc.ABC.\n\nAn abstract method is marked with the @abstractmethod decorator, and often its body is empty except for a docstring.10\n\nThe docstring instructs implementers to raise LookupError if there are no items to pick.\n\nAn ABC may include concrete methods.\n\nConcrete methods in an ABC must rely only on the interface defined by the ABC (i.e., other concrete or abstract methods or properties of the ABC).\n\nWe can’t know how concrete subclasses will store the items, but we can build the inspect result by emptying the Tombola with successive calls to .pick()…\n\n…then use .load(…) to put everything back.\n\n10 Before ABCs existed, abstract methods would raise NotImplementedError to signal that subclasses were\n\nresponsible for their implementation. In Smalltalk-80, abstract method bodies would invoke subclassRespon sibility, a method inherited from object that would produce an error with the message, “My subclass should have overridden one of my messages.”\n\n454\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "page_number": 454
    },
    {
      "number": 24,
      "title": "Segment 24 (pages 476-496)",
      "start_page": 476,
      "end_page": 496,
      "detection_method": "synthetic",
      "content": "An abstract method can actually have an implementation. Even if it does, subclasses will still be forced to override it, but they will be able to invoke the abstract method with super(), adding function‐ ality to it instead of implementing from scratch. See the abc mod‐ ule documentation for details on @abstractmethod usage.\n\nThe code for the .inspect() method in Example 13-7 is silly, but it shows that we can rely on .pick() and .load(…) to inspect what’s inside the Tombola by picking all items and loading them back—without knowing how the items are actually stored. The point of this example is to highlight that it’s OK to provide concrete methods in ABCs, as long as they only depend on other methods in the interface. Being aware of their internal data structures, concrete subclasses of Tombola may always over‐ ride .inspect() with a smarter implementation, but they don’t have to.\n\nThe .loaded() method in Example 13-7 has one line, but it’s expensive: it calls .inspect() to build the tuple just to apply bool() on it. This works, but a con‐ crete subclass can do much better, as we’ll see.\n\nNote that our roundabout implementation of .inspect() requires that we catch a LookupError thrown by self.pick(). The fact that self.pick() may raise LookupEr ror is also part of its interface, but there is no way to make this explicit in Python, except in the documentation (see the docstring for the abstract pick method in Example 13-7).\n\nI chose the LookupError exception because of its place in the Python hierarchy of exceptions in relation to IndexError and KeyError, the most likely exceptions to be raised by the data structures used to implement a concrete Tombola. Therefore, implementations can raise LookupError, IndexError, KeyError, or a custom subclass of LookupError to comply. See Figure 13-6.\n\nGoose Typing\n\n|\n\n455\n\nFigure 13-6. Part of the Exception class hierarchy.11\n\nLookupError is the exception we handle in Tombola.inspect.\n\nIndexError is the LookupError subclass raised when we try to get an item from a sequence with an index beyond the last position.\n\nKeyError is raised when we use a nonexistent key to get an item from a mapping.\n\nWe now have our very own Tombola ABC. To witness the interface checking per‐ formed by an ABC, let’s try to fool Tombola with a defective implementation in Example 13-8.\n\nExample 13-8. A fake Tombola doesn’t go undetected\n\n>>> from tombola import Tombola >>> class Fake(Tombola): ... def pick(self): ... return 13 ... >>> Fake <class '__main__.Fake'> >>> f = Fake() Traceback (most recent call last):\n\n11 The complete tree is in section “5.4. Exception hierarchy” of The Python Standard Library docs.\n\n456\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nFile \"<stdin>\", line 1, in <module> TypeError: Can't instantiate abstract class Fake with abstract method load\n\nDeclare Fake as a subclass of Tombola.\n\nThe class was created, no errors so far.\n\nTypeError is raised when we try to instantiate Fake. The message is very clear: Fake is considered abstract because it failed to implement load, one of the abstract methods declared in the Tombola ABC.\n\nSo we have our first ABC defined, and we put it to work validating a class. We’ll soon subclass the Tombola ABC, but first we must cover some ABC coding rules.\n\nABC Syntax Details The standard way to declare an ABC is to subclass abc.ABC or any other ABC.\n\nBesides the ABC base class, and the @abstractmethod decorator, the abc module defines the @abstractclassmethod, @abstractstaticmethod, and @abstractprop erty decorators. However, these last three were deprecated in Python 3.3, when it became possible to stack decorators on top of @abstractmethod, making the others redundant. For example, the preferred way to declare an abstract class method is:\n\nclass MyABC(abc.ABC): @classmethod @abc.abstractmethod def an_abstract_classmethod(cls, ...): pass\n\nThe order of stacked function decorators matters, and in the case of @abstractmethod, the documentation is explicit:\n\nWhen abstractmethod() is applied in combination with other method descriptors, it should be applied as the innermost decorator…12\n\nIn other words, no other decorator may appear between @abstract method and the def statement.\n\nNow that we’ve got these ABC syntax issues covered, let’s put Tombola to use by implementing two concrete descendants of it.\n\n12 The @abc.abstractmethod entry in the abc module documentation.\n\nGoose Typing\n\n|\n\n457\n\nSubclassing an ABC Given the Tombola ABC, we’ll now develop two concrete subclasses that satisfy its interface. These classes were pictured in Figure 13-5, along with the virtual subclass to be discussed in the next section.\n\nThe BingoCage class in Example 13-9 is a variation of Example 7-8 using a better ran‐ domizer. This BingoCage implements the required abstract methods load and pick.\n\nExample 13-9. bingo.py: BingoCage is a concrete subclass of Tombola\n\nimport random\n\nfrom tombola import Tombola\n\nclass BingoCage(Tombola):\n\ndef __init__(self, items): self._randomizer = random.SystemRandom() self._items = [] self.load(items)\n\ndef load(self, items): self._items.extend(items) self._randomizer.shuffle(self._items)\n\ndef pick(self): try: return self._items.pop() except IndexError: raise LookupError('pick from empty BingoCage')\n\ndef __call__(self): self.pick()\n\nThis BingoCage class explicitly extends Tombola.\n\nPretend we’ll use this for online gaming. random.SystemRandom implements the random API on top of the os.urandom(…) function, which provides random bytes “suitable for cryptographic use,” according to the os module docs.\n\nDelegate initial loading to the .load(…) method.\n\nInstead of the plain random.shuffle() function, we use the .shuffle() method of our SystemRandom instance.\n\n458\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\npick is implemented as in Example 7-8.\n\n__call__ is also from Example 7-8. It’s not needed to satisfy the Tombola inter‐ face, but there’s no harm in adding extra methods.\n\nBingoCage inherits the expensive loaded and the silly inspect methods from Tom bola. Both could be overridden with much faster one-liners, as in Example 13-10. The point is: we can be lazy and just inherit the suboptimal concrete methods from an ABC. The methods inherited from Tombola are not as fast as they could be for BingoCage, but they do provide correct results for any Tombola subclass that correctly implements pick and load.\n\nExample 13-10 shows a very different but equally valid implementation of the Tom bola interface. Instead of shuffling the “balls” and popping the last, LottoBlower pops from a random position.\n\nExample 13-10. lotto.py: LottoBlower is a concrete subclass that overrides the inspect and loaded methods from Tombola\n\nimport random\n\nfrom tombola import Tombola\n\nclass LottoBlower(Tombola):\n\ndef __init__(self, iterable): self._balls = list(iterable)\n\ndef load(self, iterable): self._balls.extend(iterable)\n\ndef pick(self): try: position = random.randrange(len(self._balls)) except ValueError: raise LookupError('pick from empty LottoBlower') return self._balls.pop(position)\n\ndef loaded(self): return bool(self._balls)\n\ndef inspect(self): return tuple(self._balls)\n\nGoose Typing\n\n|\n\n459\n\nThe initializer accepts any iterable: the argument is used to build a list.\n\nThe random.randrange(…) function raises ValueError if the range is empty, so we catch that and throw LookupError instead, to be compatible with Tombola.\n\nOtherwise the randomly selected item is popped from self._balls.\n\nOverride loaded to avoid calling inspect (as Tombola.loaded does in Example 13-7). We can make it faster by working with self._balls directly—no need to build a whole new tuple.\n\nOverride inspect with a one-liner.\n\nExample 13-10 illustrates an idiom worth mentioning: in __init__, self._balls stores list(iterable) and not just a reference to iterable (i.e., we did not merely assign self._balls = iterable, aliasing the argument). As mentioned in “Defen‐ sive Programming and ‘Fail Fast’” on page 440, this makes our LottoBlower flexible because the iterable argument may be any iterable type. At the same time, we make sure to store its items in a list so we can pop items. And even if we always get lists as the iterable argument, list(iterable) produces a copy of the argument, which is a good practice considering we will be removing items from it and the client might not expect that the provided list will be changed.13\n\nWe now come to the crucial dynamic feature of goose typing: declaring virtual sub‐ classes with the register method.\n\nA Virtual Subclass of an ABC An essential characteristic of goose typing—and one reason why it deserves a water‐ fowl name—is the ability to register a class as a virtual subclass of an ABC, even if it does not inherit from it. When doing so, we promise that the class faithfully imple‐ ments the interface defined in the ABC—and Python will believe us without check‐ ing. If we lie, we’ll be caught by the usual runtime exceptions.\n\nThis is done by calling a register class method on the ABC. The registered class then becomes a virtual subclass of the ABC, and will be recognized as such by issub class, but it does not inherit any methods or attributes from the ABC.\n\n13 “Defensive Programming with Mutable Parameters” on page 216 in Chapter 6 was devoted to the aliasing\n\nissue we just avoided here.\n\n460\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nVirtual subclasses do not inherit from their registered ABCs, and are not checked for conformance to the ABC interface at any time, not even when they are instantiated. Also, static type checkers can’t handle virtual subclasses at this time. For details, see Mypy issue 2922—ABCMeta.register support.\n\nThe register method is usually invoked as a plain function (see “Usage of register in Practice” on page 463), but it can also be used as a decorator. In Example 13-11, we use the decorator syntax and implement TomboList, a virtual subclass of Tombola, depic‐ ted in Figure 13-7.\n\nFigure 13-7. UML class diagram for the TomboList, a real subclass of list and a vir‐ tual subclass of Tombola.\n\nExample 13-11. tombolist.py: class TomboList is a virtual subclass of Tombola\n\nfrom random import randrange\n\nfrom tombola import Tombola\n\n@Tombola.register class TomboList(list):\n\ndef pick(self): if self: position = randrange(len(self)) return self.pop(position)\n\nGoose Typing\n\n|\n\n461\n\nelse: raise LookupError('pop from empty TomboList')\n\nload = list.extend\n\ndef loaded(self): return bool(self)\n\ndef inspect(self): return tuple(self)\n\n# Tombola.register(TomboList)\n\nTombolist is registered as a virtual subclass of Tombola.\n\nTombolist extends list.\n\nTombolist inherits its boolean behavior from list, and that returns True if the list is not empty.\n\nOur pick calls self.pop, inherited from list, passing a random item index.\n\nTombolist.load is the same as list.extend.\n\nloaded delegates to bool.14\n\nIt’s always possible to call register in this way, and it’s useful to do so when you need to register a class that you do not maintain, but which does fulfill the interface.\n\nNote that because of the registration, the functions issubclass and isinstance act as if TomboList is a subclass of Tombola:\n\n>>> from tombola import Tombola >>> from tombolist import TomboList >>> issubclass(TomboList, Tombola) True >>> t = TomboList(range(100)) >>> isinstance(t, Tombola) True\n\n14 The same trick I used with load() doesn’t work with loaded(), because the list type does not implement\n\n__bool__, the method I’d have to bind to loaded. The bool() built-in doesn’t need __bool__ to work because it can also use __len__. See “4.1. Truth Value Testing” in the “Built-in Types” chapter of the Python documentation.\n\n462\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nHowever, inheritance is guided by a special class attribute named __mro__—the Method Resolution Order. It basically lists the class and its superclasses in the order Python uses to search for methods.15 If you inspect the __mro__ of TomboList, you’ll see that it lists only the “real” superclasses—list and object:\n\n>>> TomboList.__mro__ (<class 'tombolist.TomboList'>, <class 'list'>, <class 'object'>)\n\nTombola is not in Tombolist.__mro__, so Tombolist does not inherit any methods from Tombola.\n\nThis concludes our Tombola ABC case study. In the next section, we’ll address how the register ABC function is used in the wild.\n\nUsage of register in Practice In Example 13-11, we used Tombola.register as a class decorator. Prior to Python 3.3, register could not be used like that—it had to be called as a plain function after the class definition, as suggested by the comment at the end of Example 13-11. How‐ ever, even now, it’s more widely deployed as a function to register classes defined elsewhere. For example, in the source code for the collections.abc module, the built-in types tuple, str, range, and memoryview are registered as virtual subclasses of Sequence, like this:\n\nSequence.register(tuple) Sequence.register(str) Sequence.register(range) Sequence.register(memoryview)\n\nSeveral other built-in types are registered to ABCs in _collections_abc.py. Those regis‐ trations happen only when that module is imported, which is OK because you’ll have to import it anyway to get the ABCs. For example, you need to import MutableMap ping from collections.abc to perform a check like isinstance(my_dict, Mutable Mapping).\n\nSubclassing an ABC or registering with an ABC are both explicit ways of making our classes pass issubclass checks—as well as isinstance checks, which also rely on issubclass. But some ABCs support structural typing as well. The next section explains.\n\n15 There is a whole section explaining the __mro__ class attribute in “Multiple Inheritance and Method Resolu‐\n\ntion Order” on page 494. Right now, this quick explanation will do.\n\nGoose Typing\n\n|\n\n463\n\nStructural Typing with ABCs ABCs are mostly used with nominal typing. When a class Sub explicitly inherits from AnABC, or is registered with AnABC, the name of AnABC is linked to the Sub class—and that’s how at runtime, issubclass(AnABC, Sub) returns True.\n\nIn contrast, structural typing is about looking at the structure of an object’s public interface to determine its type: an object is consistent-with a type if it implements the methods defined in the type.16 Dynamic and static duck typing are two approaches to structural typing.\n\nIt turns out that some ABCs also support structural typing. In his essay, “Waterfowl and ABCs” on page 443, Alex shows that a class can be recognized as a subclass of an ABC even without registration. Here is his example again, with an added test using issubclass:\n\n>>> class Struggle: ... def __len__(self): return 23 ... >>> from collections import abc >>> isinstance(Struggle(), abc.Sized) True >>> issubclass(Struggle, abc.Sized) True\n\nClass Struggle is considered a subclass of abc.Sized by the issubclass function (and, consequently, by isinstance as well) because abc.Sized implements a special class method named __subclasshook__.\n\nThe __subclasshook__ for Sized checks whether the class argument has an attribute named __len__. If it does, then it is considered a virtual subclass of Sized. See Example 13-12.\n\nExample 13-12. Definition of Sized from the source code of Lib/_collections_abc.py\n\nclass Sized(metaclass=ABCMeta):\n\n__slots__ = ()\n\n@abstractmethod def __len__(self): return 0\n\n@classmethod def __subclasshook__(cls, C):\n\n16 The concept of type consistency was explained in “Subtype-of versus consistent-with” on page 267.\n\n464\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nif cls is Sized: if any(\"__len__\" in B.__dict__ for B in C.__mro__): return True return NotImplemented\n\nIf there is an attribute named __len__ in the __dict__ of any class listed in C.__mro__ (i.e., C and its superclasses)…\n\n…return True, signaling that C is a virtual subclass of Sized.\n\nOtherwise return NotImplemented to let the subclass check proceed.\n\nIf you are interested in the details of the subclass check, see the source code for the ABCMeta.__subclasscheck__ method in Python 3.6: Lib/abc.py. Beware: it has lots of ifs and two recursive calls. In Python 3.7, Ivan Levkivskyi and Inada Naoki rewrote in C most of the logic for the abc module, for better performance. See Python issue #31333. The current implementation of ABC Meta.__subclasscheck__ simply calls _abc_subclasscheck. The relevant C source code is in cpython/Modules/_abc.c#L605.\n\nThat’s how __subclasshook__ allows ABCs to support structural typing. You can formalize an interface with an ABC, you can make isinstance checks against that ABC, and still have a completely unrelated class pass an issubclass check because it implements a certain method (or because it does whatever it takes to convince a __subclasshook__ to vouch for it).\n\nIs it a good idea to implement __subclasshook__ in our own ABCs? Probably not. All the implementations of __subclasshook__ I’ve seen in the Python source code are in ABCs like Sized that declare just one special method, and they simply check for that special method name. Given their “special” status, you can be pretty sure that any method named __len__ does what you expect. But even in the realm of special methods and fundamental ABCs, it can be risky to make such assumptions. For example, mappings implement __len__, __getitem__, and __iter__, but they are rightly not considered subtypes of Sequence, because you can’t retrieve items using integer offsets or slices. That’s why the abc.Sequence class does not implement __subclasshook__.\n\nFor ABCs that you and I may write, a __subclasshook__ would be even less depend‐ able. I am not ready to believe that any class named Spam that implements or inherits load, pick, inspect, and loaded is guaranteed to behave as a Tombola. It’s better to let the programmer affirm it by subclassing Spam from Tombola, or registering it with\n\nGoose Typing\n\n|\n\n465\n\nTombola.register(Spam). Of course, your __subclasshook__ could also check method signatures and other features, but I just don’t think it’s worthwhile.\n\nStatic Protocols\n\nStatic protocols were introduced in “Static Protocols” on page 286 (Chapter 8). I considered delaying all coverage of protocols until this chapter, but decided that the initial presentation of type hints in functions had to include protocols because duck typing is an essential part of Python, and static type checking without protocols doesn’t handle Pythonic APIs very well.\n\nWe will wrap up this chapter by illustrating static protocols with two simple exam‐ ples, and a discussion of numeric ABCs and protocols. Let’s start by showing how a static protocol makes it possible to annotate and type check the double() function we first saw in “Types Are Defined by Supported Operations” on page 260.\n\nThe Typed double Function When introducing Python to programmers more used to statically typed languages, one of my favorite examples is this simple double function:\n\n>>> def double(x): ... return x * 2 ... >>> double(1.5) 3.0 >>> double('A') 'AA' >>> double([10, 20, 30]) [10, 20, 30, 10, 20, 30] >>> from fractions import Fraction >>> double(Fraction(2, 5)) Fraction(4, 5)\n\nBefore static protocols were introduced, there was no practical way to add type hints to double without limiting its possible uses.17\n\n17 OK, double() is not very useful, except as an example. But the Python standard library has many functions\n\nthat could not be properly annotated before static protocols were added in Python 3.8. I helped fix a couple of bugs in typeshed by adding type hints using protocols. For example, the pull request that fixed “Should Mypy warn about potential invalid arguments to max?” leveraged a _SupportsLessThan protocol, which I used to enhance the annotations for max, min, sorted, and list.sort.\n\n466\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nThanks to duck typing, double works even with types from the future, such as the enhanced Vector class that we’ll see in “Overloading * for Scalar Multiplication” on page 572 (Chapter 16):\n\n>>> from vector_v7 import Vector >>> double(Vector([11.0, 12.0, 13.0])) Vector([22.0, 24.0, 26.0])\n\nThe initial implementation of type hints in Python was a nominal type system: the name of a type in an annotation had to match the name of the type of the actual argu‐ ments—or the name of one of its superclasses. Since it’s impossible to name all types that implement a protocol by supporting the required operations, duck typing could not be described by type hints before Python 3.8.\n\nNow, with typing.Protocol we can tell Mypy that double takes an argument x that supports x * 2. Example 13-13 shows how.\n\nExample 13-13. double_protocol.py: definition of double using a Protocol\n\nfrom typing import TypeVar, Protocol\n\nT = TypeVar('T')\n\nclass Repeatable(Protocol): def __mul__(self: T, repeat_count: int) -> T: ...\n\nRT = TypeVar('RT', bound=Repeatable)\n\ndef double(x: RT) -> RT: return x * 2\n\nWe’ll use this T in the __mul__ signature.\n\n__mul__ is the essence of the Repeatable protocol. The self parameter is usually not annotated—its type is assumed to be the class. Here we use T to make sure the result type is the same as the type of self. Also, note that repeat_count is limited to int in this protocol.\n\nThe RT type variable is bounded by the Repeatable protocol: the type checker will require that the actual type implements Repeatable.\n\nNow the type checker is able to verify that the x parameter is an object that can be multiplied by an integer, and the return value has the same type as x.\n\nStatic Protocols\n\n|\n\n467\n\nThis example shows why PEP 544 is titled “Protocols: Structural subtyping (static duck typing).” The nominal type of the actual argument x given to double is irrele‐ vant as long as it quacks—that is, as long as it implements __mul__.\n\nRuntime Checkable Static Protocols In the Typing Map (Figure 13-1), typing.Protocol appears in the static checking area—the bottom half of the diagram. However, when defining a typing.Protocol subclass, you can use the @runtime_checkable decorator to make that protocol sup‐ port isinstance/issubclass checks at runtime. This works because typing.Proto col is an ABC, therefore it supports the __subclasshook__ we saw in “Structural Typing with ABCs” on page 464.\n\nAs of Python 3.9, the typing module includes seven ready-to-use protocols that are runtime checkable. Here are two of them, quoted directly from the typing documen‐ tation:\n\nclass typing.SupportsComplex\n\nAn ABC with one abstract method, __complex__.\n\nclass typing.SupportsFloat\n\nAn ABC with one abstract method, __float__.\n\nThese protocols are designed to check numeric types for “convertibility”: if an object o implements __complex__, then you should be able to get a complex by invoking complex(o)—because the __complex__ special method exists to support the complex() built-in function.\n\nExample 13-14 shows the source code for the typing.SupportsComplex protocol.\n\nExample 13-14. typing.SupportsComplex protocol source code\n\n@runtime_checkable class SupportsComplex(Protocol): \"\"\"An ABC with one abstract method __complex__.\"\"\" __slots__ = ()\n\n@abstractmethod def __complex__(self) -> complex: pass\n\n468\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nThe key is the __complex__ abstract method.18 During static type checking, an object will be considered consistent-with the SupportsComplex protocol if it implements a __complex__ method that takes only self and returns a complex.\n\nThanks to the @runtime_checkable class decorator applied to SupportsComplex, that protocol can also be used with isinstance checks in Example 13-15.\n\nExample 13-15. Using SupportsComplex at runtime\n\n>>> from typing import SupportsComplex >>> import numpy as np >>> c64 = np.complex64(3+4j) >>> isinstance(c64, complex) False >>> isinstance(c64, SupportsComplex) True >>> c = complex(c64) >>> c (3+4j) >>> isinstance(c, SupportsComplex) False >>> complex(c) (3+4j)\n\ncomplex64 is one of five complex number types provided by NumPy.\n\nNone of the NumPy complex types subclass the built-in complex.\n\nBut NumPy’s complex types implement __complex__, so they comply with the SupportsComplex protocol.\n\nTherefore, you can create built-in complex objects from them.\n\nSadly, the complex built-in type does not implement __complex__, although complex(c) works fine if c is a complex.\n\nAs a result of that last point, if you want to test whether an object c is a complex or SupportsComplex, you can provide a tuple of types as the second argument to isinstance, like this:\n\nisinstance(c, (complex, SupportsComplex))\n\n18 The __slots__ attribute is irrelevant to the current discussion—it’s an optimization we covered in “Saving\n\nMemory with __slots__” on page 384.\n\nStatic Protocols\n\n|\n\n469\n\nAn alternative would be to use the Complex ABC, defined in the numbers module. The built-in complex type and the NumPy complex64 and complex128 types are all registered as virtual subclasses of numbers.Complex, therefore this works:\n\n>>> import numbers >>> isinstance(c, numbers.Complex) True >>> isinstance(c64, numbers.Complex) True\n\nI recommended using the numbers ABCs in the first edition of Fluent Python, but now that’s no longer good advice, because those ABCs are not recognized by the static type checkers, as we’ll see in “The numbers ABCs and Numeric Protocols” on page 478.\n\nIn this section I wanted to demonstrate that a runtime checkable protocol works with isinstance, but it turns out this is example not a particularly good use case of isin stance, as the sidebar “Duck Typing Is Your Friend” on page 470 explains.\n\nIf you’re using an external type checker, there is one advantage of explict isinstance checks: when you write an if statement where the condition is isinstance(o, MyType), then Mypy can infer that inside the if block, the type of the o object is consistent-with MyType.\n\nDuck Typing Is Your Friend Very often at runtime, duck typing is the best approach for type checking: instead of calling isinstance or hasattr, just try the operations you need to do on the object, and handle exceptions as needed. Here is a concrete example.\n\nContinuing the previous discussion—given an object o that I need to use as a com‐ plex number, this would be one approach:\n\nif isinstance(o, (complex, SupportsComplex)): # do something that requires `o` to be convertible to complex else: raise TypeError('o must be convertible to complex')\n\nThe goose typing approach would be to use the numbers.Complex ABC:\n\nif isinstance(o, numbers.Complex): # do something with `o`, an instance of `Complex` else: raise TypeError('o must be an instance of Complex')\n\nHowever, I prefer to leverage duck typing and do this using the EAFP principle—it’s easier to ask for forgiveness than permission:\n\n470\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\ntry: c = complex(o) except TypeError as exc: raise TypeError('o must be convertible to complex') from exc\n\nAnd, if all you’re going to do is raise a TypeError anyway, then I’d omit the try/ except/raise statements and just write this:\n\nc = complex(o)\n\nIn this last case, if o is not an acceptable type, Python will raise an exception with a very clear message. For example, this is what I get if o is a tuple:\n\nTypeError: complex() first argument must be a string or a number, not 'tuple'\n\nI find the duck typing approach much better in this case.\n\nNow that we’ve seen how to use static protocols at runtime with preexisting types like complex and numpy.complex64, we need to discuss the limitations of runtime checka‐ ble protocols.\n\nLimitations of Runtime Protocol Checks We’ve seen that type hints are generally ignored at runtime, and this also affects the use of isinstance or issubclass checks against static protocols.\n\nFor example, any class with a __float__ method is considered—at runtime—a vir‐ tual subclass of SupportsFloat, even if the __float__ method does not return a float.\n\nCheck out this console session:\n\n>>> import sys >>> sys.version '3.9.5 (v3.9.5:0a7dcbdb13, May 3 2021, 13:17:02) \\n[Clang 6.0 (clang-600.0.57)]' >>> c = 3+4j >>> c.__float__ <method-wrapper '__float__' of complex object at 0x10a16c590> >>> c.__float__() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't convert complex to float\n\nIn Python 3.9, the complex type does have a __float__ method, but it exists only to raise a TypeError with an explicit error message. If that __float__ method had annotations, the return type would be NoReturn—which we saw in “NoReturn” on page 294.\n\nStatic Protocols\n\n|\n\n471\n\nBut type hinting complex.__float__ on typeshed would not solve this problem because Python’s runtime generally ignores type hints—and can’t access the typeshed stub files anyway.\n\nContinuing from the previous Python 3.9 session:\n\n>>> from typing import SupportsFloat >>> c = 3+4j >>> isinstance(c, SupportsFloat) True >>> issubclass(complex, SupportsFloat) True\n\nSo we have misleading results: the runtime checks against SupportsFloat suggest that you can convert a complex to float, but in fact that raises a type error.\n\nThe specific isssue with the complex type is fixed in Python 3.10.0b4 with the removal of the complex.__float__ method. But the overall issue remains: isinstance/issubclass checks only look at the presence or absence of methods, without checking their signatures, much less their type annotations. And this is not about to change, because such type checks at runtime would have an unacceptable performance cost.19\n\nNow let’s see how to implement a static protocol in a user-defined class.\n\nSupporting a Static Protocol Recall the Vector2d class we built in Chapter 11. Given that a complex number and a Vector2d instance both consist of a pair of floats, it makes sense to support conver‐ sion from Vector2d to complex.\n\nExample 13-16 shows the implementation of the __complex__ method to enhance the last version of Vector2d we saw in Example 11-11. For completeness, we can sup‐ port the inverse operation with a fromcomplex class method to build a Vector2d from a complex.\n\n19 Thanks to Ivan Levkivskyi, coauthor of PEP 544 (on Protocols), for pointing out that type checking is not just a matter of checking whether the type of x is T: it’s about determining that the type of x is consistent-with T, which may be expensive. It’s no wonder that Mypy takes a few seconds to type check even short Python scripts.\n\n472\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nExample 13-16. vector2d_v4.py: methods for converting to and from complex\n\ndef __complex__(self): return complex(self.x, self.y)\n\n@classmethod def fromcomplex(cls, datum): return cls(datum.real, datum.imag)\n\nThis assumes that datum has .real and .imag attributes. We’ll see a better imple‐ mentation in Example 13-17.\n\nGiven the preceding code, and the __abs__ method the Vector2d already had in Example 11-11, we get these features:\n\n>>> from typing import SupportsComplex, SupportsAbs >>> from vector2d_v4 import Vector2d >>> v = Vector2d(3, 4) >>> isinstance(v, SupportsComplex) True >>> isinstance(v, SupportsAbs) True >>> complex(v) (3+4j) >>> abs(v) 5.0 >>> Vector2d.fromcomplex(3+4j) Vector2d(3.0, 4.0)\n\nFor runtime type checking, Example 13-16 is fine, but for better static coverage and error reporting with Mypy, the __abs__, __complex__, and fromcomplex methods should get type hints, as shown in Example 13-17.\n\nExample 13-17. vector2d_v5.py: adding annotations to the methods under study\n\ndef __abs__(self) -> float: return math.hypot(self.x, self.y)\n\ndef __complex__(self) -> complex: return complex(self.x, self.y)\n\n@classmethod def fromcomplex(cls, datum: SupportsComplex) -> Vector2d: c = complex(datum) return cls(c.real, c.imag)\n\nStatic Protocols\n\n|\n\n473\n\nThe float return annotation is needed, otherwise Mypy infers Any, and doesn’t check the body of the method.\n\nEven without the annotation, Mypy was able to infer that this returns a complex. The annotation prevents a warning, depending on your Mypy configuration.\n\nHere SupportsComplex ensures the datum is convertible.\n\nThis explicit conversion is necessary, because the SupportsComplex type does not declare .real and .imag attributes, used in the next line. For example, Vector2d doesn’t have those attributes, but implements __complex__.\n\nThe return type of fromcomplex can be Vector2d if from __future__ import anno tations appears at the top of the module. That import causes type hints to be stored as strings, without being evaluated at import time, when function definitions are evaluated. Without the __future__ import of annotations, Vector2d is an invalid reference at this point (the class is not fully defined yet) and should be written as a string: 'Vector2d', as if it were a forward reference. This __future__ import was introduced in PEP 563—Postponed Evaluation of Annotations, implemented in Python 3.7. That behavior was scheduled to become default in 3.10, but the change was delayed to a later version.20 When that happens, the import will be redundant, but harmless.\n\nNext, let’s see how to create—and later, extend—a new static protocol.\n\nDesigning a Static Protocol While studying goose typing, we saw the Tombola ABC in “Defining and Using an ABC” on page 451. Here we’ll see how to define a similar interface using a static protocol.\n\nThe Tombola ABC specifies two methods: pick and load. We could define a static protocol with these two methods as well, but I learned from the Go community that single-method protocols make static duck typing more useful and flexible. The Go standard library has several interfaces like Reader, an interface for I/O that requires just a read method. After a while, if you realize a more complete protocol is required, you can combine two or more protocols to define a new one.\n\nUsing a container that picks items at random may or may not require reloading the container, but it certainly needs a method to do the actual pick, so that’s the method I\n\n20 Read the Python Steering Council decision on python-dev.\n\n474\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nwill choose for the minimal RandomPicker protocol. The code for that protocol is in Example 13-18, and its use is demonstrated by tests in Example 13-19.\n\nExample 13-18. randompick.py: definition of RandomPicker\n\nfrom typing import Protocol, runtime_checkable, Any\n\n@runtime_checkable class RandomPicker(Protocol): def pick(self) -> Any: ...\n\nThe pick method returns Any. In “Implementing a Generic Static Protocol” on page 552, we will see how to make RandomPicker a generic type with a parameter to let users of the protocol specify the return type of the pick method.\n\nExample 13-19. randompick_test.py: RandomPicker in use\n\nimport random from typing import Any, Iterable, TYPE_CHECKING\n\nfrom randompick import RandomPicker\n\nclass SimplePicker: def __init__(self, items: Iterable) -> None: self._items = list(items) random.shuffle(self._items)\n\ndef pick(self) -> Any: return self._items.pop()\n\ndef test_isinstance() -> None: popper: RandomPicker = SimplePicker([1]) assert isinstance(popper, RandomPicker)\n\ndef test_item_type() -> None: items = [1, 2] popper = SimplePicker(items) item = popper.pick() assert item in items if TYPE_CHECKING: reveal_type(item) assert isinstance(item, int)\n\nStatic Protocols\n\n|\n\n475",
      "page_number": 476
    },
    {
      "number": 25,
      "title": "Segment 25 (pages 497-516)",
      "start_page": 497,
      "end_page": 516,
      "detection_method": "synthetic",
      "content": "It’s not necessary to import the static protocol to define a class that implements it. Here I imported RandomPicker only to use it on test_isinstance later.\n\nSimplePicker implements RandomPicker—but it does not subclass it. This is static duck typing in action.\n\nAny is the default return type, so this annotation is not strictly necessary, but it does make it more clear that we are implementing the RandomPicker protocol as defined in Example 13-18.\n\nDon’t forget to add -> None hints to your tests if you want Mypy to look at them.\n\nI added a type hint for the popper variable to show that Mypy understands that SimplePicker is consistent-with.\n\nThis test proves that an instance of SimplePicker is also an instance of Random Picker. This works because of the @runtime_checkable decorator applied to RandomPicker, and because SimplePicker has a pick method as required.\n\nThis test invokes the pick method from a SimplePicker, verifies that it returns one of the items given to SimplePicker, and then does static and runtime checks on the returned item.\n\nThis line generates a note in the Mypy output.\n\nAs we saw in Example 8-22, reveal_type is a “magic” function recognized by Mypy. That’s why it is not imported and we can only call it inside if blocks protected by typing.TYPE_CHECKING, which is only True in the eyes of a static type checker, but is False at runtime.\n\nBoth tests in Example 13-19 pass. Mypy does not see any errors in that code either, and shows the result of the reveal_type on the item returned by pick:\n\n$ mypy randompick_test.py randompick_test.py:24: note: Revealed type is 'Any'\n\nHaving created our first protocol, let’s study some advice on the matter.\n\nBest Practices for Protocol Design After 10 years of experience with static duck typing in Go, it is clear that narrow pro‐ tocols are more useful—often such protocols have a single method, rarely more than a couple of methods. Martin Fowler wrote a post defining role interface, a useful idea to keep in mind when designing protocols.\n\n476\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nAlso, sometimes you see a protocol defined near the function that uses it—that is, defined in “client code” instead of being defined in a library. This is makes it easy to create new types to call that function, which is good for extensibility and testing with mocks.\n\nThe practices of narrow protocols and client-code protocols both avoid unnecessary tight coupling, in line with the Interface Segregation Principle, which we can summa‐ rize as “Clients should not be forced to depend upon interfaces that they do not use.”\n\nThe page “Contributing to typeshed” recommends this naming convention for static protocols (the following three points are quoted verbatim):\n\nUse plain names for protocols that represent a clear concept (e.g., Iterator, Container).\n\nUse SupportsX for protocols that provide callable methods (e.g., SupportsInt, SupportsRead, SupportsReadSeek).21\n\nUse HasX for protocols that have readable and/or writable attributes or getter/ setter methods (e.g., HasItems, HasFileno).\n\nThe Go standard library has a naming convention that I like: for single method pro‐ tocols, if the method name is a verb, append “-er” or “-or” to make it a noun. For example, instead of SupportsRead, have Reader. More examples include Formatter, Animator, and Scanner. For inspiration, see “Go (Golang) Standard Library Inter‐ faces (Selected)” by Asuka Kenji.\n\nOne good reason to create minimalistic protocols is the ability to extend them later, if needed. We’ll now see that it’s not hard to create a derived protocol with an addi‐ tional method.\n\nExtending a Protocol As I mentioned at the start of the previous section, Go developers advocate to err on the side of minimalism when defining interfaces—their name for static protocols. Many of the most widely used Go interfaces have a single method.\n\nWhen practice reveals that a protocol with more methods is useful, instead of adding methods to the original protocol, it’s better to derive a new protocol from it. Extend‐ ing a static protocol in Python has a few caveats, as Example 13-20 shows.\n\n21 Every method is callable, so this guideline doesn’t say much. Perhaps “provide one or two methods”? Any‐\n\nway, it’s a guideline, not a strict rule.\n\nStatic Protocols\n\n|\n\n477\n\nExample 13-20. randompickload.py: extending RandomPicker\n\nfrom typing import Protocol, runtime_checkable from randompick import RandomPicker\n\n@runtime_checkable class LoadableRandomPicker(RandomPicker, Protocol): def load(self, Iterable) -> None: ...\n\nIf you want the derived protocol to be runtime checkable, you must apply the decorator again—its behavior is not inherited.22\n\nEvery protocol must explicitly name typing.Protocol as one of its base classes in addition to the protocol we are extending. This is different from the way inheritance works in Python.23\n\nBack to “regular” object-oriented programming: we only need to declare the method that is new in this derived protocol. The pick method declaration is inherited from RandomPicker.\n\nThis concludes the final example of defining and using a static protocol in this chapter.\n\nTo wrap the chapter, we’ll go over numeric ABCs and their possible replacement with numeric protocols.\n\nThe numbers ABCs and Numeric Protocols As we saw in “The fall of the numeric tower” on page 279, the ABCs in the numbers package of the standard library work fine for runtime type checking.\n\nIf you need to check for an integer, you can use isinstance(x, numbers.Integral) to accept int, bool (which subclasses int) or other integer types that are provided by external libraries that register their types as virtual subclasses of the numbers ABCs. For example, NumPy has 21 integer types—as well as several variations of floating- point types registered as numbers.Real, and complex numbers with various bit widths registered as numbers.Complex.\n\n22 For details and rationale, please see the section about @runtime_checkable in PEP 544—Protocols: Structural\n\nsubtyping (static duck typing).\n\n23 Again, please read “Merging and extending protocols” in PEP 544 for details and rationale.\n\n478\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nSomewhat surprisingly, decimal.Decimal is not registered as a vir‐ tual subclass of numbers.Real. The reason is that, if you need the precision of Decimal in your program, then you want to be pro‐ tected from accidental mixing of decimals with floating-point numbers that are less precise.\n\nSadly, the numeric tower was not designed for static type checking. The root ABC— numbers.Number—has no methods, so if you declare x: Number, Mypy will not let you do arithmetic or call any methods on x.\n\nIf the numbers ABCs are not supported, what are the options?\n\nA good place to look for typing solutions is the typeshed project. As part of the Python standard library, the statistics module has a corresponding statistics.pyi stub file with type hints for on typeshed. There you’ll find the following definitions, which are used to annotate several functions:\n\n_Number = Union[float, Decimal, Fraction] _NumberT = TypeVar('_NumberT', float, Decimal, Fraction)\n\nThat approach is correct, but limited. It does not support numeric types outside of the standard library, which the numbers ABCs do support at runtime—when the numeric types are registered as virtual subclasses.\n\nThe current trend is to recommend the numeric protocols provided by the typing module, which we discussed in “Runtime Checkable Static Protocols” on page 468.\n\nUnfortunately, at runtime, the numeric protocols may let you down. As mentioned in “Limitations of Runtime Protocol Checks” on page 471, the complex type in Python 3.9 implements __float__, but the method exists only to raise TypeError with an explicit message: “can’t convert complex to float.” It implements __int__ as well, for the same reason. The presence of those methods makes isinstance return mislead‐ ing results in Python 3.9. In Python 3.10, the methods of complex that uncondition‐ ally raised TypeError were removed.24\n\nOn the other hand, NumPy’s complex types implement __float__ and __int__ methods that work, only issuing a warning when each of them is used for the first time:\n\n>>> import numpy as np >>> cd = np.cdouble(3+4j) >>> cd (3+4j) >>> float(cd)\n\n24 See Issue #41974—Remove complex.__float__, complex.__floordiv__, etc.\n\nStatic Protocols\n\n|\n\n479\n\n<stdin>:1: ComplexWarning: Casting complex values to real discards the imaginary part 3.0\n\nThe opposite problem also happens: built-ins complex, float, and int, and also numpy.float16 and numpy.uint8, don’t have a __complex__ method, so isin stance(x, SupportsComplex) returns False for them.25 The NumPy complex types, such as np.complex64, do implement __complex__ to convert to a built-in complex.\n\nHowever, in practice, the complex() built-in constructor handles instances of all these types with no errors or warnings:\n\n>>> import numpy as np >>> from typing import SupportsComplex >>> sample = [1+0j, np.complex64(1+0j), 1.0, np.float16(1.0), 1, np.uint8(1)] >>> [isinstance(x, SupportsComplex) for x in sample] [False, True, False, False, False, False] >>> [complex(x) for x in sample] [(1+0j), (1+0j), (1+0j), (1+0j), (1+0j), (1+0j)]\n\nThis shows that isinstance checks against SupportsComplex suggest that those con‐ versions to complex would fail, but they all succeed. In the typing-sig mailing list, Guido van Rossum pointed out that the built-in complex accepts a single argument, and that’s why those conversions work.\n\nOn the other hand, Mypy accepts arguments of all those six types in a call to a to_complex() function defined like this:\n\ndef to_complex(n: SupportsComplex) -> complex: return complex(n)\n\nAs I write this, NumPy has no type hints, so its number types are all Any.26 On the other hand, Mypy is somehow “aware” that the built-in int and float can be con‐ verted to complex, even though on typeshed only the built-in complex class has a __complex__ method.27\n\nIn conclusion, although numeric types should not be hard to type check, the current situation is this: the type hints PEP 484 eschews the numeric tower and implicitly recommends that type checkers hardcode the subtype relationships among built-in complex, float, and int. Mypy does that, and it also pragmatically accepts that int and float are consistent-with SupportsComplex, even though they don’t implement __complex__.\n\n25 I did not test all the other float and integer variants NumPy offers.\n\n26 The NumPy number types are all registered against the appropriate numbers ABCs, which Mypy ignores.\n\n27 That’s a well-meaning lie on the part of typeshed: as of Python 3.9, the built-in complex type does not actually\n\nhave a __complex__ method.\n\n480\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nI only found unexpected results when using isinstance checks with numeric Supports* protocols while experimenting with con‐ versions to or from complex. If you don’t use complex numbers, you can rely on those protocols instead of the numbers ABCs.\n\nThe main takeaways for this section are:\n\nThe numbers ABCs are fine for runtime type checking, but unsuitable for static typing.\n\nThe numeric static protocols SupportsComplex, SupportsFloat, etc. work well for static typing, but are unreliable for runtime type checking when complex numbers are involved.\n\nWe are now ready for a quick review of what we saw in this chapter.\n\nChapter Summary The Typing Map (Figure 13-1) is the key to making sense of this chapter. After a brief introduction to the four approaches to typing, we contrasted dynamic and static pro‐ tocols, which respectively support duck typing and static duck typing. Both kinds of protocols share the essential characteristic that a class is never required to explicitly declare support for any specific protocol. A class supports a protocol simply by implementing the necessary methods.\n\nThe next major section was “Programming Ducks” on page 435, where we explored the lengths to which the Python interpreter goes to make the sequence and iterable dynamic protocols work, including partial implementations of both. We then saw how a class can be made to implement a protocol at runtime through the addition of extra methods via monkey patching. The duck typing section ended with hints for defensive programming, including detection of structural types without explicit isin stance or hasattr checks using try/except and failing fast.\n\nAfter Alex Martelli introduced goose typing in “Waterfowl and ABCs” on page 443, we saw how to subclass existing ABCs, surveyed important ABCs in the standard library, and created an ABC from scratch, which we then implemented by traditional subclassing and by registration. To close this section, we saw how the __subclass hook__ special method enables ABCs to support structural typing by recognizing unrelated classes that provide methods fulfilling the interface defined in the ABC.\n\nThe last major section was “Static Protocols” on page 466, where we resumed cover‐ age of static duck typing, which started in Chapter 8, in “Static Protocols” on page 286. We saw how the @runtime_checkable decorator also leverages __subclass hook__ to support structural typing at runtime—even though the best use of static\n\nChapter Summary\n\n|\n\n481\n\nprotocols is with static type checkers, which can take into account type hints to make structural typing more reliable. Next we talked about the design and coding of a static protocol and how to extend it. The chapter ended with “The numbers ABCs and Numeric Protocols” on page 478, which tells the sad story of the derelict state of the numeric tower and a few existing shortcomings of the proposed alternative: the numeric static protocols such as SupportsFloat and others added to the typing module in Python 3.8.\n\nThe main message of this chapter is that we have four complementary ways of pro‐ gramming with interfaces in modern Python, each with different advantages and drawbacks. You are likely to find suitable use cases for each typing scheme in any modern Python codebase of significant size. Rejecting any one of these approaches will make your work as a Python programmer harder than it needs to be.\n\nHaving said that, Python achieved widespread popularity while supporting only duck typing. Other popular languages such as JavaScript, PHP, and Ruby, as well as Lisp, Smalltalk, Erlang, and Clojure—not popular but very influential—are all languages that had and still have tremendous impact by leveraging the power and simplicity of duck typing.\n\nFurther Reading For a quick look at typing pros and cons, as well as the importance of typing.Proto col for the health of statically checked codebases, I highly recommend Glyph Lefko‐ witz’s post “I Want A New Duck: typing.Protocol and the future of duck typing”. I also learned a lot from his post “Interfaces and Protocols”, comparing typing.Proto col and zope.interface—an earlier mechanism for defining interfaces in loosely coupled plug-in systems, used by the Plone CMS, the Pyramid web framework, and the Twisted asynchronous programming framework, a project founded by Glyph.28\n\nGreat books about Python have—almost by definition—great coverage of duck typ‐ ing. Two of my favorite Python books had updates released after the first edition of Fluent Python: The Quick Python Book, 3rd ed., (Manning), by Naomi Ceder; and Python in a Nutshell, 3rd ed., by Alex Martelli, Anna Ravenscroft, and Steve Holden (O’Reilly).\n\nFor a discussion of the pros and cons of dynamic typing, see Guido van Rossum’s interview with Bill Venners in “Contracts in Python: A Conversation with Guido van Rossum, Part IV”. An insightful and balanced take on this debate is Martin Fowler’s post “Dynamic Typing”. He also wrote “Role Interface”, which I mentioned in “Best Practices for Protocol Design” on page 476. Although it is not about duck typing, that\n\n28 Thanks to tech reviewer Jürgen Gmach for recommending the “Interfaces and Protocols” post.\n\n482\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\npost is highly relevant for Python protocol design, as he contrasts narrow role inter‐ faces with the broader public interfaces of classes in general.\n\nThe Mypy documentation is often the best source of information for anything related to static typing in Python, including static duck typing, addressed in their “Protocols and structural subtyping” chapter.\n\nThe remaining references are all about goose typing. Beazley and Jones’s Python Cookbook, 3rd ed. (O’Reilly) has a section about defining an ABC (Recipe 8.12). The book was written before Python 3.4, so they don’t use the now preferred syntax of declaring ABCs by subclassing from abc.ABC (instead, they use the metaclass key‐ word, which we’ll only really need in Chapter 24). Apart from this small detail, the recipe covers the major ABC features very well.\n\nThe Python Standard Library by Example by Doug Hellmann (Addison-Wesley), has a chapter about the abc module. It’s also available on the web in Doug’s excellent PyMOTW—Python Module of the Week. Hellmann also uses the old style of ABC declaration: PluginBase(metaclass=abc.ABCMeta) instead of the simpler Plugin Base(abc.ABC) available since Python 3.4.\n\nWhen using ABCs, multiple inheritance is not only common but practically inevita‐ ble, because each of the fundamental collection ABCs—Sequence, Mapping, and Set —extends Collection, which in turn extends multiple ABCs (see Figure 13-4). Therefore, Chapter 14 is an important follow-up to this one.\n\nPEP 3119—Introducing Abstract Base Classes gives the rationale for ABCs. PEP 3141 —A Type Hierarchy for Numbers presents the ABCs of the numbers module, but the discussion in the Mypy issue #3186 “int is not a Number?” includes some arguments about why the numeric tower is unsuitable for static type checking. Alex Waygood wrote a comprehensive answer on StackOverflow, discussing ways to annotate numeric types. I’ll keep watching Mypy issue #3186 for the next chapters of this saga, hoping for a happy ending that will make static typing and goose typing compatible —as they should be.\n\nFurther Reading\n\n|\n\n483\n\nSoapbox\n\nThe MVP Journey of Python Static Typing\n\nI work for Thoughtworks, a worldwide leader in Agile software development. At Thoughtworks, we often recommend that our clients should aim to create and deploy MVPs: minimal viable products: “a simple version of a product that is given to users in order to validate the key business assumptions,” as defined by my colleague Paulo Caroli in “Lean Inception”, a post in Martin Fowler’s collective blog.\n\nGuido van Rossum and the other core developers who designed and implemented static typing have followed an MVP strategy since 2006. First, PEP 3107—Function Annotations was implemented in Python 3.0 with very limited semantics: just syntax to attach annotations to function parameters and returns. This was done explicitly to allow for experimentation and collect feedback—key benefits of an MVP.\n\nEight years later, PEP 484—Type Hints was proposed and approved. Its implementa‐ tion in Python 3.5 required no changes in the language or standard library—except for adding the typing module, on which no other part of the standard library depen‐ ded. PEP 484 supported only nominal types with generics—similar to Java—but with the actual static checking done by external tools. Important features were missing, like variable annotations, generic built-in types, and protocols. Despite those limita‐ tions, this typing MVP was valuable enough to attract investment and adoption by companies with very large Python codebases, like Dropbox, Google, and Facebook; as well as support from professional IDEs, like PyCharm, Wing, and VS Code.\n\nPEP 526—Syntax for Variable Annotations was the first evolutionary step that required changes to the interpreter in Python 3.6. More changes to the Python 3.7 interpreter were made to support PEP 563—Postponed Evaluation of Annotations and PEP 560—Core support for typing module and generic types, which allowed built-in and standard library collections to accept generic type hints out of the box in Python 3.9, thanks to PEP 585—Type Hinting Generics In Standard Collections.\n\nDuring those years, some Python users—including me—were underwhelmed by the typing support. After I learned Go, the lack of static duck typing in Python was incomprehensible, in a language where duck typing had always been a core strength.\n\nBut that is the nature of MVPs: they may not satisfy all potential users, but they can be implemented with less effort, and guide further development with feedback from actual usage in the field.\n\nIf there is one thing we all learned from Python 3, it’s that incremental progress is safer than big-bang releases. I am glad we did not have to wait for Python 4—if it ever comes—to make Python more attractive to large enterprises, where the benefits of static typing outweigh the added complexity.\n\n484\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nTyping Approaches in Popular Languages\n\nFigure 13-8 is a variation of the Typing Map (Figure 13-1) with the names of a few popular languages that support each of the typing approaches.\n\nFigure 13-8. Four approaches to type checking and some languages that support them.\n\nTypeScript and Python ≥ 3.8 are the only languages in my small and arbitrary sample that support all four approaches.\n\nGo is clearly a statically typed language in the Pascal tradition, but it pioneered static duck typing—at least among languages that are widely used today. I also put Go in the goose typing quadrant because of its type assertions, which allow checking and adapting to different types at runtime.\n\nIf I had to draw a similar diagram in the year 2000, only the duck typing and the static typing quadrants would have languages in them. I am not aware of languages that supported static duck typing or goose typing 20 years ago. The fact that each of the four quadrants has at least three popular languages suggests that a lot of people see value in each of the four approaches to typing.\n\nFurther Reading\n\n|\n\n485\n\nMonkey Patching\n\nMonkey patching has a bad reputation. If abused, it can lead to systems that are hard to understand and maintain. The patch is usually tightly coupled with its target, mak‐ ing it brittle. Another problem is that two libraries that apply monkey patches may step on each other’s toes, with the second library to run destroying patches of the first.\n\nBut monkey patching can also be useful, for example, to make a class implement a protocol at runtime. The Adapter design pattern solves the same problem by imple‐ menting a whole new class.\n\nIt’s easy to monkey patch Python code, but there are limitations. Unlike Ruby and JavaScript, Python does not let you monkey patch the built-in types. I actually con‐ sider this an advantage, because you can be certain that a str object will always have those same methods. This limitation reduces the chance that external libraries apply conflicting patches.\n\nMetaphors and Idioms in Interfaces\n\nA metaphor fosters understanding by making constraints and affordances clear. That’s the value of the words “stack” and “queue” in describing those fundamental data structures: they make clear which operations are allowed, i.e., how items can be added or removed. On the other hand, Alan Cooper et al. write in About Face, the Essentials of Interaction Design, 4th ed. (Wiley):\n\nStrict adherence to metaphors ties interfaces unnecessarily tightly to the workings of the physical world.\n\nHe’s referring to user interfaces, but the admonition applies to APIs as well. But Cooper does grant that when a “truly appropriate” metaphor “falls on our lap,” we can use it (he writes “falls on our lap” because it’s so hard to find fitting metaphors that you should not spend time actively looking for them). I believe the bingo machine imagery I used in this chapter is appropriate and I stand by it.\n\nAbout Face is by far the best book about UI design I’ve read—and I’ve read a few. Letting go of metaphors as a design paradigm, and replacing it with “idiomatic inter‐ faces” was the most valuable thing I learned from Cooper’s work.\n\nIn About Face, Cooper does not deal with APIs, but the more I think about his ideas, the more I see how they apply to Python. The fundamental protocols of the language are what Cooper calls “idioms.” Once we learn what a “sequence” is, we can apply that knowledge in different contexts. This is a main theme of Fluent Python: high‐ lighting the fundamental idioms of the language, so your code is concise, effective, and readable—for a fluent Pythonista.\n\n486\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs\n\nCHAPTER 14 Inheritance: For Better or for Worse\n\n[...] we needed a better theory about inheritance entirely (and still do). For example, inheritance and instancing (which is a kind of inheritance) muddles both pragmatics (such as factoring code to save space) and semantics (used for way too many tasks such as: specialization, generalization, speciation, etc.). —Alan Kay, “The Early History of Smalltalk”1\n\nThis chapter is about inheritance and subclassing. I will assume a basic understand‐ ing of these concepts, which you may know from reading The Python Tutorial or from experience with another mainstream object-oriented language, such as Java, C#, or C++. Here we’ll focus on four characteristics of Python:\n\nThe super() function\n\nThe pitfalls of subclassing from built-in types\n\nMultiple inheritance and method resolution order\n\nMixin classes\n\nMultiple inheritance is the ability of a class to have more than one base class. C++ supports it; Java and C# don’t. Many consider multiple inheritance more trouble than it’s worth. It was deliberately left out of Java after its perceived abuse in early C++ codebases.\n\nThis chapter introduces multiple inheritance for those who have never used it, and provides some guidance on how to cope with single or multiple inheritance if you must use it.\n\n1 Alan Kay, “The Early History of Smalltalk,” in SIGPLAN Not. 28, 3 (March 1993), 69–95. Also available\n\nonline. Thanks to my friend Christiano Anderson, who shared this reference as I was writing this chapter.\n\n487\n\nAs of 2021, there is a significant backlash against overuse of inheritance in general— not only multiple inheritance—because superclasses and subclasses are tightly cou‐ pled. Tight coupling means that changes to one part of the program may have unex‐ pected and far-reaching effects in other parts, making systems brittle and hard to understand.\n\nHowever, we have to maintain existing systems designed with complex class hierar‐ chies, or use frameworks that force us to use inheritance—even multiple inheritance sometimes.\n\nI will illustrate practical uses of multiple inheritance with the standard library, the Django web framework, and the Tkinter GUI toolkit.\n\nWhat’s New in This Chapter There are no new Python features related to the subject of this chapter, but I heavily edited it based on feedback from technical reviewers of the second edition, especially Leonardo Rochael and Caleb Hattingh.\n\nI wrote a new opening section focusing on the super() built-in function, and changed the examples in “Multiple Inheritance and Method Resolution Order” on page 494 for a deeper exploration of how super() works to support cooperative multiple inheritance.\n\n“Mixin Classes” on page 500 is also new. “Multiple Inheritance in the Real World” on page 502 was reorganized and covers simpler mixin examples from the standard library, before the complex Django and the complicated Tkinter hierarchies.\n\nAs the chapter title suggests, the caveats of inheritance have always been one of the main themes of this chapter. But more and more developers consider it so problem‐ atic that I’ve added a couple of paragraphs about avoiding inheritance to the end of “Chapter Summary” on page 514 and “Further Reading” on page 515.\n\nWe’ll start with an overview of the mysterious super() function.\n\nThe super() Function Consistent use the of the super() built-in function is essential for maintainable object-oriented Python programs.\n\nWhen a subclass overrides a method of a superclass, the overriding method usually needs to call the corresponding method of the superclass. Here’s the recommended\n\n488\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nway to do it, from an example in the collections module documentation, section “OrderedDict Examples and Recipes”:2\n\nclass LastUpdatedOrderedDict(OrderedDict): \"\"\"Store items in the order they were last updated\"\"\"\n\ndef __setitem__(self, key, value): super().__setitem__(key, value) self.move_to_end(key)\n\nTo do its job, LastUpdatedOrderedDict overrides __setitem__ to:\n\n1. Use super().__setitem__ to call that method on the superclass, to let it insert or update the key/value pair.\n\n2. Call self.move_to_end to ensure the updated key is in the last position.\n\nInvoking an overridden __init__ method is particularly important to allow super‐ classes to do their part in initializing the instance.\n\nIf you learned object-oriented programming in Java, you may recall that a Java constructor method automatically calls the no- argument constructor of the superclass. Python doesn’t do this. You must get used to writing this pattern:\n\ndef __init__(self, a, b) : super().__init__(a, b) ... # more initialization code\n\nYou may have seen code that doesn’t use super(), but instead calls the method directly on the superclass, like this:\n\nclass NotRecommended(OrderedDict): \"\"\"This is a counter example!\"\"\"\n\ndef __setitem__(self, key, value): OrderedDict.__setitem__(self, key, value) self.move_to_end(key)\n\nThis alternative works in this particular case, but is not recommended for two rea‐ sons. First, it hardcodes the base class. The name OrderedDict appears in the class statement and also inside __setitem__. If in the future someone changes the class statement to change the base class or add another one, they may forget to update the body of __setitem__, introducing a bug.\n\n2 I only changed the docstring in the example, because the original is misleading. It says: “Store items in the order the keys were last added,” but that is not what the clearly named LastUpdatedOrderedDict does.\n\nThe super() Function\n\n|\n\n489\n\nThe second reason is that super implements logic to handle class hierarchies with multiple inheritance. We’ll come back to that in “Multiple Inheritance and Method Resolution Order” on page 494. To conclude this refresher about super, it is useful to review how we had to call it in Python 2, because the old signature with two argu‐ ments is revealing:\n\nclass LastUpdatedOrderedDict(OrderedDict): \"\"\"This code works in Python 2 and Python 3\"\"\"\n\ndef __setitem__(self, key, value): super(LastUpdatedOrderedDict, self).__setitem__(key, value) self.move_to_end(key)\n\nBoth arguments of super are now optional. The Python 3 bytecode compiler auto‐ matically provides them by inspecting the surrounding context when super() is invoked in a method. The arguments are:\n\ntype\n\nThe start of the search path for the superclass implementing the desired method. By default, it is the class that owns the method where the super() call appears.\n\nobject_or_type\n\nThe object (for instance method calls) or class (for class method calls) to be the receiver of the method call. By default, it is self if the super() call happens in an instance method.\n\nWhether you or the compiler provides those arguments, the super() call returns a dynamic proxy object that finds a method (such as __setitem__ in the example) in a superclass of the type parameter, and binds it to the object_or_type, so that we don’t need to pass the receiver (self) explicitly when invoking the method.\n\nIn Python 3, you can still explicitly provide the first and second arguments to super().3 But they are needed only in special cases, such as skipping over part of the MRO for testing or debugging, or for working around undesired behavior in a superclass.\n\nNow let’s discuss the caveats when subclassing built-in types.\n\nSubclassing Built-In Types Is Tricky It was not possible to subclass built-in types such as list or dict in the earliest ver‐ sions of Python. Since Python 2.2, it’s possible, but there is a major caveat: the code of\n\n3 It is also possible to provide only the first argument, but this not useful and may soon be deprecated, with the blessing of Guido van Rossum who created super() in the first place. See the discussion at “Is it time to dep‐ recate unbound super methods?”.\n\n490\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nthe built-ins (written in C) usually does not call methods overridden by user-defined classes. A good short description of the problem is in the documentation for PyPy, in the “Differences between PyPy and CPython” section, “Subclasses of built-in types”:\n\nOfficially, CPython has no rule at all for when exactly overridden method of subclasses of built-in types get implicitly called or not. As an approximation, these methods are never called by other built-in methods of the same object. For example, an overridden __getitem__() in a subclass of dict will not be called by e.g. the built-in get() method.\n\nExample 14-1 illustrates the problem.\n\nExample 14-1. Our __setitem__ override is ignored by the __init__ and __update__ methods of the built-in dict\n\n>>> class DoppelDict(dict): ... def __setitem__(self, key, value): ... super().__setitem__(key, [value] * 2) ... >>> dd = DoppelDict(one=1) >>> dd {'one': 1} >>> dd['two'] = 2 >>> dd {'one': 1, 'two': [2, 2]} >>> dd.update(three=3) >>> dd {'three': 3, 'one': 1, 'two': [2, 2]}\n\nDoppelDict.__setitem__ duplicates values when storing (for no good reason, just to have a visible effect). It works by delegating to the superclass.\n\nThe __init__ method inherited from dict clearly ignored that __setitem__ was overridden: the value of 'one' is not duplicated.\n\nThe [] operator calls our __setitem__ and works as expected: 'two' maps to the duplicated value [2, 2].\n\nThe update method from dict does not use our version of __setitem__ either: the value of 'three' was not duplicated.\n\nThis built-in behavior is a violation of a basic rule of object-oriented programming: the search for methods should always start from the class of the receiver (self), even when the call happens inside a method implemented in a superclass. This is what is called “late binding,” which Alan Kay—of Smalltalk fame—considers a key feature of object-oriented programming: in any call of the form x.method(), the exact method\n\nSubclassing Built-In Types Is Tricky\n\n|\n\n491\n\nto be called must be determined at runtime, based on the class of the receiver x.4 This sad state of affairs contributes to the issues we saw in “Inconsistent Usage of __missing__ in the Standard Library” on page 94.\n\nThe problem is not limited to calls within an instance—whether self.get() calls self.__getitem__()—but also happens with overridden methods of other classes that should be called by the built-in methods. Example 14-2 is adapted from the PyPy documentation.\n\nExample 14-2. The __getitem__ of AnswerDict is bypassed by dict.update\n\n>>> class AnswerDict(dict): ... def __getitem__(self, key): ... return 42 ... >>> ad = AnswerDict(a='foo') >>> ad['a'] 42 >>> d = {} >>> d.update(ad) >>> d['a'] 'foo' >>> d {'a': 'foo'}\n\nAnswerDict.__getitem__ always returns 42, no matter what the key.\n\nad is an AnswerDict loaded with the key-value pair ('a', 'foo').\n\nad['a'] returns 42, as expected.\n\nd is an instance of plain dict, which we update with ad.\n\nThe dict.update method ignored our AnswerDict.__getitem__.\n\nSubclassing built-in types like dict or list or str directly is error- prone because the built-in methods mostly ignore user-defined overrides. Instead of subclassing the built-ins, derive your classes from the collections module using UserDict, UserList, and UserString, which are designed to be easily extended.\n\n4 It is interesting to note that C++ has the notion of virtual and nonvirtual methods. Virtual methods are late bound, but nonvirtual methods are bound at compile time. Although every method that we can write in Python is late bound like a virtual method, built-in objects written in C seem to have nonvirtual methods by default, at least in CPython.\n\n492\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nIf you subclass collections.UserDict instead of dict, the issues exposed in Exam‐ ples 14-1 and 14-2 are both fixed. See Example 14-3.\n\nExample 14-3. DoppelDict2 and AnswerDict2 work as expected because they extend UserDict and not dict\n\n>>> import collections >>> >>> class DoppelDict2(collections.UserDict): ... def __setitem__(self, key, value): ... super().__setitem__(key, [value] * 2) ... >>> dd = DoppelDict2(one=1) >>> dd {'one': [1, 1]} >>> dd['two'] = 2 >>> dd {'two': [2, 2], 'one': [1, 1]} >>> dd.update(three=3) >>> dd {'two': [2, 2], 'three': [3, 3], 'one': [1, 1]} >>> >>> class AnswerDict2(collections.UserDict): ... def __getitem__(self, key): ... return 42 ... >>> ad = AnswerDict2(a='foo') >>> ad['a'] 42 >>> d = {} >>> d.update(ad) >>> d['a'] 42 >>> d {'a': 42}\n\nAs an experiment to measure the extra work required to subclass a built-in, I rewrote the StrKeyDict class from Example 3-9 to subclass dict instead of UserDict. In order to make it pass the same suite of tests, I had to implement __init__, get, and update because the versions inherited from dict refused to cooperate with the over‐ ridden __missing__, __contains__, and __setitem__. The UserDict subclass from Example 3-9 has 16 lines, while the experimental dict subclass ended up with 33 lines.5\n\n5 If you are curious, the experiment is in the 14-inheritance/strkeydict_dictsub.py file in the fluentpython/\n\nexample-code-2e repository.\n\nSubclassing Built-In Types Is Tricky\n\n|\n\n493\n\nTo be clear: this section covered an issue that applies only to method delegation within the C language code of the built-in types, and only affects classes derived directly from those types. If you subclass a base class coded in Python, such as UserDict or MutableMapping, you will not be troubled by this.6\n\nNow let’s focus on an issue that arises with multiple inheritance: if a class has two superclasses, how does Python decide which attribute to use when we call super().attr, but both superclasses have an attribute with that name?\n\nMultiple Inheritance and Method Resolution Order Any language implementing multiple inheritance needs to deal with potential nam‐ ing conflicts when superclasses implement a method by the same name. This is called the “diamond problem,” illustrated in Figure 14-1 and Example 14-4.\n\nFigure 14-1. Left: Activation sequence for the leaf1.ping() call. Right: Activation sequence for the leaf1.pong() call.\n\nExample 14-4. diamond.py: classes Leaf, A, B, Root form the graph in Figure 14-1\n\nclass Root: def ping(self): print(f'{self}.ping() in Root')\n\ndef pong(self): print(f'{self}.pong() in Root')\n\ndef __repr__(self):\n\n6 By the way, in this regard, PyPy behaves more “correctly” than CPython, at the expense of introducing a\n\nminor incompatibility. See “Differences between PyPy and CPython” for details.\n\n494\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\ncls_name = type(self).__name__ return f'<instance of {cls_name}>'\n\nclass A(Root): def ping(self): print(f'{self}.ping() in A') super().ping()\n\ndef pong(self): print(f'{self}.pong() in A') super().pong()\n\nclass B(Root): def ping(self): print(f'{self}.ping() in B') super().ping()\n\ndef pong(self): print(f'{self}.pong() in B')\n\nclass Leaf(A, B): def ping(self): print(f'{self}.ping() in Leaf') super().ping()\n\nRoot provides ping, pong, and __repr__ to make the output easier to read.\n\nThe ping and pong methods in class A both call super().\n\nOnly the ping method in class B calls super().\n\nClass Leaf implements only ping, and it calls super().\n\nNow let’s see the effect of calling the ping and pong methods on an instance of Leaf (Example 14-5).\n\nExample 14-5. Doctests for calling ping and pong on a Leaf object\n\n>>> leaf1 = Leaf() >>> leaf1.ping() <instance of Leaf>.ping() in Leaf <instance of Leaf>.ping() in A <instance of Leaf>.ping() in B <instance of Leaf>.ping() in Root\n\n>>> leaf1.pong()\n\nMultiple Inheritance and Method Resolution Order\n\n|\n\n495",
      "page_number": 497
    },
    {
      "number": 26,
      "title": "Segment 26 (pages 517-534)",
      "start_page": 517,
      "end_page": 534,
      "detection_method": "synthetic",
      "content": "<instance of Leaf>.pong() in A <instance of Leaf>.pong() in B\n\nleaf1 is an instance of Leaf.\n\nCalling leaf1.ping() activates the ping methods in Leaf, A, B, and Root, because the ping methods in the first three classes call super().ping().\n\nCalling leaf1.pong() activates pong in A via inheritance, which then calls super.pong(), activating B.pong.\n\nThe activation sequences shown in Example 14-5 and Figure 14-1 are determined by two factors:\n\nThe method resolution order of the Leaf class. • The use of super() in each method.\n\nEvery class has an attribute called __mro__ holding a tuple of references to the super‐ classes in method resolution order, from the current class all the way to the object class.7 For the Leaf class, this is the __mro__:\n\n>>> Leaf.__mro__ # doctest:+NORMALIZE_WHITESPACE (<class 'diamond1.Leaf'>, <class 'diamond1.A'>, <class 'diamond1.B'>, <class 'diamond1.Root'>, <class 'object'>)\n\nLooking at Figure 14-1, you may think the MRO describes a breadth-first search, but that’s just a coincidence for that particular class hierarchy. The MRO is computed by a published algorithm called C3. Its use in Python is detailed in Michele Simionato’s “The Python 2.3 Method Resolution Order”. It’s a challenging read, but Simionato writes: “unless you make strong use of multiple inheri‐ tance and you have non-trivial hierarchies, you don’t need to understand the C3 algorithm, and you can easily skip this paper.”\n\nThe MRO only determines the activation order, but whether a particular method will be activated in each of the classes depends on whether each implementation calls super() or not.\n\nConsider the experiment with the pong method. The Leaf class does not override it, therefore calling leaf1.pong() activates the implementation in the next class of\n\n7 Classes also have a .mro() method, but that’s an advanced feature of metaclass programming, mentioned in “Classes as Objects” on page 908. The content of the __mro__ attribute is what matters during normal usage of a class.\n\n496\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nLeaf.__mro__: the A class. Method A.pong calls super().pong(). The B class is next in the MRO, therefore B.pong is activated. But that method doesn’t call super().pong(), so the activation sequence ends here.\n\nThe MRO takes into account not only the inheritance graph but also the order in which superclasses are listed in a subclass declaration. In other words, if in dia‐ mond.py (Example 14-4) the Leaf class was declared as Leaf(B, A), then class B would appear before A in Leaf.__mro__. This would affect the activation order of the ping methods, and would also cause leaf1.pong() to activate B.pong via inheritance, but A.pong and Root.pong would never run, because B.pong doesn’t call super().\n\nWhen a method calls super(), it is a cooperative method. Cooperative methods enable cooperative multiple inheritance. These terms are intentional: in order to work, multiple inheritance in Python requires the active cooperation of the methods involved. In the B class, ping cooperates, but pong does not.\n\nA noncooperative method can be the cause of subtle bugs. Many coders reading Example 14-4 may expect that when method A.pong calls super.pong(), that will ultimately activate Root.pong. But if B.pong is activated before, it drops the ball. That’s why it is recommended that every method m of a nonroot class should call super().m().\n\nCooperative methods must have compatible signatures, because you never know whether A.ping will be called before or after B.ping. The activation sequence depends on the order of A and B in the declaration of each subclass that inherits from both.\n\nPython is a dynamic language, so the interaction of super() with the MRO is also dynamic. Example 14-6 shows a surprising result of this dynamic behavior.\n\nExample 14-6. diamond2.py: classes to demonstrate the dynamic nature of super()\n\nfrom diamond import A\n\nclass U(): def ping(self): print(f'{self}.ping() in U') super().ping()\n\nclass LeafUA(U, A): def ping(self): print(f'{self}.ping() in LeafUA') super().ping()\n\nMultiple Inheritance and Method Resolution Order\n\n|\n\n497\n\nClass A comes from diamond.py (Example 14-4).\n\nClass U is unrelated to A or Root from the diamond module.\n\nWhat does super().ping() do? Answer: it depends. Read on.\n\nLeafUA subclasses U and A in this order.\n\nIf you create an instance of U and try to call ping, you get an error:\n\n>>> u = U() >>> u.ping() Traceback (most recent call last): ... AttributeError: 'super' object has no attribute 'ping'\n\nThe 'super' object returned by super() has no attribute 'ping' because the MRO of U has two classes: U and object, and the latter has no attribute named 'ping'.\n\nHowever, the U.ping method is not completely hopeless. Check this out:\n\n>>> leaf2 = LeafUA() >>> leaf2.ping() <instance of LeafUA>.ping() in LeafUA <instance of LeafUA>.ping() in U <instance of LeafUA>.ping() in A <instance of LeafUA>.ping() in Root >>> LeafUA.__mro__ # doctest:+NORMALIZE_WHITESPACE (<class 'diamond2.LeafUA'>, <class 'diamond2.U'>, <class 'diamond.A'>, <class 'diamond.Root'>, <class 'object'>)\n\nThe super().ping() call in LeafUA activates U.ping, which cooperates by calling super().ping() too, activating A.ping, and eventually Root.ping.\n\nNote the base classes of LeafUA are (U, A) in that order. If instead the bases were (A, U), then leaf2.ping() would never reach U.ping, because the super().ping() in A.ping would activate Root.ping, and that method does not call super().\n\nIn a real program, a class like U could be a mixin class: a class intended to be used together with other classes in multiple inheritance, to provide additional functional‐ ity. We’ll study that shortly, in “Mixin Classes” on page 500.\n\nTo wrap up this discussion of the MRO, Figure 14-2 illustrates part of the complex multiple inheritance graph of the Tkinter GUI toolkit from the Python standard library.\n\n498\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nFigure 14-2. Left: UML diagram of the Tkinter Text widget class and superclasses. Right: The long and winding path of Text.__mro__ is drawn with dashed arrows.\n\nTo study the picture, start at the Text class at the bottom. The Text class implements a full-featured, multiline editable text widget. It provides rich functionality in itself, but also inherits many methods from other classes. The lefthand side shows a plain UML class diagram. On the right, it’s decorated with arrows showing the MRO, as listed in Example 14-7 with the help of a print_mro convenience function.\n\nExample 14-7. MRO of tkinter.Text\n\n>>> def print_mro(cls): ... print(', '.join(c.__name__ for c in cls.__mro__)) >>> import tkinter >>> print_mro(tkinter.Text) Text, Widget, BaseWidget, Misc, Pack, Place, Grid, XView, YView, object\n\nNow let’s talk about mixins.\n\nMultiple Inheritance and Method Resolution Order\n\n|\n\n499\n\nMixin Classes A mixin class is designed to be subclassed together with at least one other class in a multiple inheritance arrangement. A mixin is not supposed to be the only base class of a concrete class, because it does not provide all the functionality for a concrete object, but only adds or customizes the behavior of child or sibling classes.\n\nMixin classes are a convention with no explicit language support in Python and C++. Ruby allows the explicit definition and use of modules that work as mixins—collections of methods that may be included to add functionality to a class. C#, PHP, and Rust imple‐ ment traits, which are also an explicit form of mixin.\n\nLet’s see a simple but handy example of a mixin class.\n\nCase-Insensitive Mappings Example 14-8 shows UpperCaseMixin, a class designed to provide case-insensitive access to mappings with string keys, by uppercasing those keys when they are added or looked up.\n\nExample 14-8. uppermixin.py: UpperCaseMixin supports case-insensitive mappings\n\nimport collections\n\ndef _upper(key): try: return key.upper() except AttributeError: return key\n\nclass UpperCaseMixin: def __setitem__(self, key, item): super().__setitem__(_upper(key), item)\n\ndef __getitem__(self, key): return super().__getitem__(_upper(key))\n\ndef get(self, key, default=None): return super().get(_upper(key), default)\n\ndef __contains__(self, key): return super().__contains__(_upper(key))\n\n500\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nThis helper function takes a key of any type, and tries to return key.upper(); if that fails, it returns the key unchanged.\n\nThe mixin implements four essential methods of mappings, always calling super(), with the key uppercased, if possible.\n\nSince every method ot UpperCaseMixin calls super(), this mixin depends on a sibling class that implements or inherits methods with the same signature. To make its con‐ tribution, a mixin usually needs to appear before other classes in the MRO of a sub‐ class that uses it. In practice, that means mixins must appear first in the tuple of base classes in a class declaration. Example 14-9 shows two examples.\n\nExample 14-9. uppermixin.py: two classes that use UpperCaseMixin\n\nclass UpperDict(UpperCaseMixin, collections.UserDict): pass\n\nclass UpperCounter(UpperCaseMixin, collections.Counter): \"\"\"Specialized 'Counter' that uppercases string keys\"\"\"\n\nUpperDict needs no implementation of its own, but UpperCaseMixin must be the first base class, otherwise the methods from UserDict would be called instead.\n\nUpperCaseMixin also works with Counter.\n\nInstead of pass, it’s better to provide a docstring to satisfy the need for a body in the class statement syntax.\n\nHere are some doctests from uppermixin.py, for UpperDict:\n\n>>> d = UpperDict([('a', 'letter A'), (2, 'digit two')]) >>> list(d.keys()) ['A', 2] >>> d['b'] = 'letter B' >>> 'b' in d True >>> d['a'], d.get('B') ('letter A', 'letter B') >>> list(d.keys()) ['A', 2, 'B']\n\nAnd a quick demonstration of UpperCounter:\n\n>>> c = UpperCounter('BaNanA') >>> c.most_common() [('A', 3), ('N', 2), ('B', 1)]\n\nMixin Classes\n\n|\n\n501\n\nUpperDict and UpperCounter seem almost magical, but I had to carefully study the code of UserDict and Counter to make UpperCaseMixin work with them.\n\nFor example, my first version of UpperCaseMixin did not provide the get method. That version worked with UserDict but not with Counter. The UserDict class inher‐ its get from collections.abc.Mapping, and that get calls __getitem__, which I implemented. But keys were not uppercased when an UpperCounter was loaded upon __init__. That happened because Counter.__init__ uses Counter.update, which in turn relies on the get method inherited from dict. However, the get method in the dict class does not call __getitem__. This is the heart of the issue discussed in “Inconsistent Usage of __missing__ in the Standard Library” on page 94. It is also a stark reminder of the brittle and puzzling nature of programs leveraging inheritance, even at a small scale.\n\nThe next section covers several examples of multiple inheritance, often featuring mixin classes.\n\nMultiple Inheritance in the Real World In the Design Patterns book,8 almost all the code is in C++, but the only example of multiple inheritance is the Adapter pattern. In Python, multiple inheritance is not the norm either, but there are important examples that I will comment on in this section.\n\nABCs Are Mixins Too In the Python standard library, the most visible use of multiple inheritance is the col lections.abc package. That is not controversial: after all, even Java supports multi‐ ple inheritance of interfaces, and ABCs are interface declarations that may optionally provide concrete method implementations.9\n\nPython’s official documentation of collections.abc uses the term mixin method for the concrete methods implemented in many of the collection ABCs. The ABCs that provide mixin methods play two roles: they are interface definitions and also mixin classes. For example, the implementation of collections.UserDict relies on several of the mixin methods provided by collections.abc.MutableMapping.\n\n8 Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, Design Patterns: Elements of Reusable\n\nObject-Oriented Software (Addison-Wesley).\n\n9 As previously mentioned, Java 8 allows interfaces to provide method implementations as well. The new fea‐\n\nture is called “Default Methods” in the official Java Tutorial.\n\n502\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nThreadingMixIn and ForkingMixIn The http.server package provides HTTPServer and ThreadingHTTPServer classes. The latter was added in Python 3.7. Its documentation says:\n\nclass http.server.ThreadingHTTPServer(server_address, RequestHandlerClass)\n\nThis class is identical to HTTPServer but uses threads to handle requests by using the ThreadingMixIn. This is useful to handle web browsers pre-opening sockets, on which HTTPServer would wait indefinitely.\n\nThis is the complete source code for the ThreadingHTTPServer class in Python 3.10:\n\nclass ThreadingHTTPServer(socketserver.ThreadingMixIn, HTTPServer): daemon_threads = True\n\nThe source code of socketserver.ThreadingMixIn has 38 lines, including comments and docstrings. Example 14-10 shows a summary of its implementation.\n\nExample 14-10. Part of Lib/socketserver.py in Python 3.10\n\nclass ThreadingMixIn: \"\"\"Mixin class to handle each request in a new thread.\"\"\"\n\n# 8 lines omitted in book listing\n\ndef process_request_thread(self, request, client_address): ... # 6 lines omitted in book listing\n\ndef process_request(self, request, client_address): ... # 8 lines omitted in book listing\n\ndef server_close(self): super().server_close() self._threads.join()\n\nprocess_request_thread does not call super() because it is a new method, not an override. Its implementation calls three instance methods that HTTPServer provides or inherits.\n\nThis overrides the process_request method that HTTPServer inherits from sock etserver.BaseServer, starting a thread and delegating the actual work to pro cess_request_thread running in that thread. It does not call super().\n\nserver_close calls super().server_close() to stop taking requests, then waits for the threads started by process_request to finish their jobs.\n\nThe ThreadingMixIn appears in the socketserver module documentation next to ForkingMixin. The latter is designed to support concurrent servers based on\n\nMultiple Inheritance in the Real World\n\n|\n\n503\n\nos.fork(), an API for launching a child process, available in POSIX-compliant Unix-like systems.\n\nDjango Generic Views Mixins\n\nYou don’t need to know Django to follow this section. I am using a small part of the framework as a practical example of multiple inheritance, and I will try to give all the necessary background, assuming you have some experience with server-side web develop‐ ment in any language or framework.\n\nIn Django, a view is a callable object that takes a request argument—an object repre‐ senting an HTTP request—and returns an object representing an HTTP response. The different responses are what interests us in this discussion. They can be as simple as a redirect response, with no content body, or as complex as a catalog page in an online store, rendered from an HTML template and listing multiple merchandise with buttons for buying, and links to detail pages.\n\nOriginally, Django provided a set of functions, called generic views, that imple‐ mented some common use cases. For example, many sites need to show search results that include information from numerous items, with the listing spanning mul‐ tiple pages, and for each item a link to a page with detailed information about it. In Django, a list view and a detail view are designed to work together to solve this problem: a list view renders search results, and a detail view produces a page for each individual item.\n\nHowever, the original generic views were functions, so they were not extensible. If you needed to do something similar but not exactly like a generic list view, you’d have to start from scratch.\n\nThe concept of class-based views was introduced in Django 1.3, along with a set of generic view classes organized as base classes, mixins, and ready-to-use concrete classes. In Django 3.2, the base classes and mixins are in the base module of the django.views.generic package, pictured in Figure 14-3. At the top of the diagram we see two classes that take care of very distinct responsibilities: View and TemplateResponseMixin.\n\n504\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nFigure 14-3. UML class diagram for the django.views.generic.base module.\n\nA great resource to study these classes is the Classy Class-Based Views website, where you can easily navigate through them, see all methods in each class (inherited, overridden, and added methods), view diagrams, browse their documentation, and jump to their source code on GitHub.\n\nView is the base class of all views (it could be an ABC), and it provides core function‐ ality like the dispatch method, which delegates to “handler” methods like get, head, post, etc., implemented by concrete subclasses to handle the different HTTP verbs.10 The RedirectView class inherits only from View, and you can see that it implements get, head, post, etc.\n\nConcrete subclasses of View are supposed to implement the handler methods, so why aren’t those methods part of the View interface? The reason: subclasses are free to\n\n10 Django programmers know that the as_view class method is the most visible part of the View interface, but\n\nit’s not relevant to us here.\n\nMultiple Inheritance in the Real World\n\n|\n\n505\n\nimplement just the handlers they want to support. A TemplateView is used only to display content, so it only implements get. If an HTTP POST request is sent to a Tem plateView, the inherited View.dispatch method checks that there is no post han‐ dler, and produces an HTTP 405 Method Not Allowed response.11\n\nThe TemplateResponseMixin provides functionality that is of interest only to views that need to use a template. A RedirectView, for example, has no content body, so it has no need of a template and it does not inherit from this mixin. TemplateResponse Mixin provides behaviors to TemplateView and other template-rendering views, such as ListView, DetailView, etc., defined in the django.views.generic subpackages. Figure 14-4 depicts the django.views.generic.list module and part of the base module.\n\nFor Django users, the most important class in Figure 14-4 is ListView, which is an aggregate class, with no code at all (its body is just a docstring). When instantiated, a ListView has an object_list instance attribute through which the template can iter‐ ate to show the page contents, usually the result of a database query returning multi‐ ple objects. All the functionality related to generating this iterable of objects comes from the MultipleObjectMixin. That mixin also provides the complex pagination logic—to display part of the results in one page and links to more pages.\n\nSuppose you want to create a view that will not render a template, but will produce a list of objects in JSON format. That’s why the BaseListView exists. It provides an easy-to-use extension point that brings together View and MultipleObjectMixin functionality, without the overhead of the template machinery.\n\nThe Django class-based views API is a better example of multiple inheritance than Tkinter. In particular, it is easy to make sense of its mixin classes: each has a well- defined purpose, and they are all named with the …Mixin suffix.\n\n11 If you are into design patterns, you’ll notice that the Django dispatch mechanism is a dynamic variation of the Template Method pattern. It’s dynamic because the View class does not force subclasses to implement all han‐ dlers, but dispatch checks at runtime if a concrete handler is available for the specific request.\n\n506\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nFigure 14-4. UML class diagram for the django.views.generic.list module. Here the three classes of the base module are collapsed (see Figure 14-3). The ListView class has no methods or attributes: it’s an aggregate class.\n\nClass-based views were not universally embraced by Django users. Many do use them in a limited way, as opaque boxes, but when it’s necessary to create something new, a lot of Django coders continue writing monolithic view functions that take care of all those responsibilities, instead of trying to reuse the base views and mixins.\n\nIt does take some time to learn how to leverage class-based views and how to extend them to fulfill specific application needs, but I found that it was worthwhile to study them. They eliminate a lot of boilerplate code, make it easier to reuse solutions, and even improve team communication—for example, by defining standard names to templates, and to the variables passed to template contexts. Class-based views are Django views “on rails.”\n\nMultiple Inheritance in Tkinter An extreme example of multiple inheritance in Python’s standard library is the Tkinter GUI toolkit. I used part of the Tkinter widget hierarchy to illustrate the MRO in Figure 14-2. Figure 14-5 shows all the widget classes in the tkinter base package (there are more widgets in the tkinter.ttk subpackage).\n\nMultiple Inheritance in the Real World\n\n|\n\n507\n\nFigure 14-5. Summary UML diagram for the Tkinter GUI class hierarchy; classes tag‐ ged «mixin» are designed to provide concrete methods to other classes via multiple inheritance.\n\nTkinter is 25 years old as I write this. It is not an example of current best practices. But it shows how multiple inheritance was used when coders did not appreciate its drawbacks. And it will serve as a counterexample when we cover some good practices in the next section.\n\nConsider these classes from Figure 14-5:\n\n➊ Toplevel: The class of a top-level window in a Tkinter application.\n\n➋ Widget: The superclass of every visible object that can be placed on a window.\n\n➌ Button: A plain button widget.\n\n➍ Entry: A single-line editable text field.\n\n➎ Text: A multiline editable text field.\n\nHere are the MROs of those classes, displayed by the print_mro function from Example 14-7:\n\n>>> import tkinter >>> print_mro(tkinter.Toplevel) Toplevel, BaseWidget, Misc, Wm, object\n\n508\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\n>>> print_mro(tkinter.Widget) Widget, BaseWidget, Misc, Pack, Place, Grid, object >>> print_mro(tkinter.Button) Button, Widget, BaseWidget, Misc, Pack, Place, Grid, object >>> print_mro(tkinter.Entry) Entry, Widget, BaseWidget, Misc, Pack, Place, Grid, XView, object >>> print_mro(tkinter.Text) Text, Widget, BaseWidget, Misc, Pack, Place, Grid, XView, YView, object\n\nBy current standards, the class hierarchy of Tkinter is very deep. Few parts of the Python standard library have more than three or four levels of concrete classes, and the same can be said of the Java class library. However, it is interesting to note that the some of the deepest hierarchies in the Java class library are precisely in the packages related to GUI programming: java.awt and javax.swing. Squeak, the modern, free version of Smalltalk, includes the powerful and innovative Morphic GUI toolkit, also with a deep class hierarchy. In my experience, GUI toolkits are where inheritance is most useful.\n\nNote how these classes relate to others:\n\nToplevel is the only graphical class that does not inherit from Widget, because it is the top-level window and does not behave like a widget; for example, it cannot be attached to a window or frame. Toplevel inherits from Wm, which provides direct access functions of the host window manager, like setting the window title and configuring its borders.\n\nWidget inherits directly from BaseWidget and from Pack, Place, and Grid. These last three classes are geometry managers: they are responsible for arranging widgets inside a window or frame. Each encapsulates a different layout strategy and widget placement API.\n\nButton, like most widgets, descends only from Widget, but indirectly from Misc, which provides dozens of methods to every widget.\n\nEntry subclasses Widget and XView, which support horizontal scrolling. • Text subclasses from Widget, XView, and YView for vertical scrolling.\n\nWe’ll now discuss some good practices of multiple inheritance and see whether Tkinter goes along with them.\n\nMultiple Inheritance in the Real World\n\n|\n\n509\n\nCoping with Inheritance What Alan Kay wrote in the epigraph remains true: there’s still no general theory about inheritance that can guide practicing programmers. What we have are rules of thumb, design patterns, “best practices,” clever acronyms, taboos, etc. Some of these provide useful guidelines, but none of them are universally accepted or always applicable.\n\nIt’s easy to create incomprehensible and brittle designs using inheritance, even without multiple inheritance. Because we don’t have a comprehensive theory, here are a few tips to avoid spaghetti class graphs.\n\nFavor Object Composition over Class Inheritance The title of this subsection is the second principle of object-oriented design from the Design Patterns book,12 and is the best advice I can offer here. Once you get comforta‐ ble with inheritance, it’s too easy to overuse it. Placing objects in a neat hierarchy appeals to our sense of order; programmers do it just for fun.\n\nFavoring composition leads to more flexible designs. For example, in the case of the tkinter.Widget class, instead of inheriting the methods from all geometry managers, widget instances could hold a reference to a geometry manager, and invoke its meth‐ ods. After all, a Widget should not “be” a geometry manager, but could use the serv‐ ices of one via delegation. Then you could add a new geometry manager without touching the widget class hierarchy and without worrying about name clashes. Even with single inheritance, this principle enhances flexibility, because subclassing is a form of tight coupling, and tall inheritance trees tend to be brittle.\n\nComposition and delegation can replace the use of mixins to make behaviors avail‐ able to different classes, but cannot replace the use of interface inheritance to define a hierarchy of types.\n\nUnderstand Why Inheritance Is Used in Each Case When dealing with multiple inheritance, it’s useful to keep straight the reasons why subclassing is done in each particular case. The main reasons are:\n\nInheritance of interface creates a subtype, implying an “is-a” relationship. This is best done with ABCs.\n\nInheritance of implementation avoids code duplication by reuse. Mixins can help with this.\n\n12 The principle appears on p. 20 of the introduction to the book.\n\n510\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nIn practice, both uses are often simultaneous, but whenever you can make the intent clear, do it. Inheritance for code reuse is an implementation detail, and it can often be replaced by composition and delegation. On the other hand, interface inheritance is the backbone of a framework. Interface inheritance should use only ABCs as base classes, if possible.\n\nMake Interfaces Explicit with ABCs In modern Python, if a class is intended to define an interface, it should be an explicit ABC or a typing.Protocol subclass. An ABC should subclass only abc.ABC or other ABCs. Multiple inheritance of ABCs is not problematic.\n\nUse Explicit Mixins for Code Reuse If a class is designed to provide method implementations for reuse by multiple unre‐ lated subclasses, without implying an “is-a” relationship, it should be an explicit mixin class. Conceptually, a mixin does not define a new type; it merely bundles methods for reuse. A mixin should never be instantiated, and concrete classes should not inherit only from a mixin. Each mixin should provide a single specific behavior, implementing few and very closely related methods. Mixins should avoid keeping any internal state; i.e., a mixin class should not have instance attributes.\n\nThere is no formal way in Python to state that a class is a mixin, so it is highly recom‐ mended that they are named with a Mixin suffix.\n\nProvide Aggregate Classes to Users\n\nA class that is constructed primarily by inheriting from mixins and does not add its own structure or behavior is called an aggregate class.\n\n—Booch et al.13\n\nIf some combination of ABCs or mixins is particularly useful to client code, provide a class that brings them together in a sensible way.\n\nFor example, here is the complete source code for the Django ListView class on the bottom right of Figure 14-4:\n\nclass ListView(MultipleObjectTemplateResponseMixin, BaseListView): \"\"\" Render some list of objects, set by `self.model` or `self.queryset`. `self.queryset` can actually be any iterable of items, not just a queryset. \"\"\"\n\n13 Grady Booch et al., Object-Oriented Analysis and Design with Applications, 3rd ed. (Addison-Wesley), p. 109.\n\nCoping with Inheritance\n\n|\n\n511\n\nThe body of ListView is empty, but the class provides a useful service: it brings together a mixin and a base class that should be used together.\n\nAnother example is tkinter.Widget, which has four base classes and no methods or attributes of its own—just a docstring. Thanks to the Widget aggregate class, we can create new a widget with the required mixins, without having to figure out in which order they should be declared to work as intended.\n\nNote that aggregate classes don’t have to be completely empty, but they often are.\n\nSubclass Only Classes Designed for Subclassing In one comment about this chapter, technical reviewer Leonardo Rochael suggested the following warning.\n\nSubclassing any complex class and overriding its methods is error- prone because the superclass methods may ignore the subclass overrides in unexpected ways. As much as possible, avoid overrid‐ ing methods, or at least restrain yourself to subclassing classes which are designed to be easily extended, and only in the ways in which they were designed to be extended.\n\nThat’s great advice, but how do we know whether or how a class was designed to be extended?\n\nThe first answer is documentation (sometimes in the form of docstrings or even comments in code). For example, Python’s socketserver package is described as “a framework for network servers.” Its BaseServer class is designed for subclassing, as the name suggests. More importantly, the documentation and the docstring in the source code of the class explicitly note which of its methods are intended to be over‐ ridden by subclasses.\n\nIn Python ≥ 3.8, a new way of making those design constraints explicit is provided by PEP 591—Adding a final qualifier to typing. The PEP introduces a @final decorator that can be applied to classes or individual methods, so that IDEs or type checkers can report misguided attempts to subclass those classes or override those methods.14\n\n14 PEP 591 also introduces a Final annotation for variables or attributes that should not be reassigned or over‐\n\nridden.\n\n512\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nAvoid Subclassing from Concrete Classes Subclassing concrete classes is more dangerous than subclassing ABCs and mixins, because instances of concrete classes usually have internal state that can easily be cor‐ rupted when you override methods that depend on that state. Even if your methods cooperate by calling super(), and the internal state is held in private attributes using the __x syntax, there are still countless ways a method override can introduce bugs.\n\nIn “Waterfowl and ABCs” on page 443, Alex Martelli quotes Scott Meyer’s More Effective C++, which says: “all non-leaf classes should be abstract.” In other words, Meyer recommends that only abstract classes should be subclassed.\n\nIf you must use subclassing for code reuse, then the code intended for reuse should be in mixin methods of ABCs or in explicitly named mixin classes.\n\nWe will now analyze Tkinter from the point of view of these recommendations.\n\nTkinter: The Good, the Bad, and the Ugly Most advice in the previous section is not followed by Tkinter, with the notable exception of “Provide Aggregate Classes to Users” on page 511. Even then, it’s not a great example, because composition would probably work better for integrating the geometry managers into Widget, as discussed in “Favor Object Composition over Class Inheritance” on page 510.\n\nKeep in mind that Tkinter has been part of the standard library since Python 1.1 was released in 1994. Tkinter is a layer on top of the excellent Tk GUI toolkit of the Tcl language. The Tcl/Tk combo is not originally object-oriented, so the Tk API is basi‐ cally a vast catalog of functions. However, the toolkit is object-oriented in its design, if not in its original Tcl implementation.\n\nThe docstring of tkinter.Widget starts with the words “Internal class.” This suggests that Widget should probably be an ABC. Although Widget has no methods of its own, it does define an interface. Its message is: “You can count on every Tkinter widget providing basic widget methods (__init__, destroy, and dozens of Tk API func‐ tions), in addition to the methods of all three geometry managers.” We can agree that this is not a great interface definition (it’s just too broad), but it is an interface, and Widget “defines” it as the union of the interfaces of its superclasses.\n\nThe Tk class, which encapsulates the GUI application logic, inherits from Wm and Misc, neither of which are abstract or mixin (Wm is not a proper mixin because TopLevel subclasses only from it). The name of the Misc class is—by itself—a very strong code smell. Misc has more than 100 methods, and all widgets inherit from it. Why is it necessary that every single widget has methods for clipboard handling, text selection, timer management, and the like? You can’t really paste into a button or\n\nCoping with Inheritance\n\n|\n\n513",
      "page_number": 517
    },
    {
      "number": 27,
      "title": "Segment 27 (pages 535-552)",
      "start_page": 535,
      "end_page": 552,
      "detection_method": "synthetic",
      "content": "select text from a scrollbar. Misc should be split into several specialized mixin classes, and not all widgets should inherit from every one of those mixins.\n\nTo be fair, as a Tkinter user, you don’t need to know or use multiple inheritance at all. It’s an implementation detail hidden behind the widget classes that you will instantiate or subclass in your own code. But you will suffer the consequences of excessive multiple inheritance when you type dir(tkinter.Button) and try to find the method you need among the 214 attributes listed. And you’ll need to face the complexity if you decide to implement a new Tk widget.\n\nDespite the problems, Tkinter is stable, flexible, and provides a modern look-and-feel if you use the tkinter.ttk package and its themed widgets. Also, some of the original widgets, like Canvas and Text, are incredibly powerful. You can turn a Canvas object into a simple drag-and-drop drawing application in a matter of hours. Tkinter and Tcl/Tk are definitely worth a look if you are interested in GUI programming.\n\nThis concludes our tour through the labyrinth of inheritance.\n\nChapter Summary This chapter started with a review of the super() function in the context of single inheritance. We then discussed the problem with subclassing built-in types: their native methods implemented in C do not call overridden methods in subclasses, except in very few special cases. That’s why, when we need a custom list, dict, or str type, it’s easier to subclass UserList, UserDict, or UserString—all defined in the collections module, which actually wrap the corresponding built-in types and dele‐ gate operations to them—three examples of favoring composition over inheritance in the standard library. If the desired behavior is very different from what the built-ins offer, it may be easier to subclass the appropriate ABC from collections.abc and write your own implementation.\n\nThe rest of the chapter was devoted to the double-edged sword of multiple inheri‐ tance. First we saw how the method resolution order, encoded in the __mro__ class attribute, addresses the problem of potential naming conflicts in inherited methods. We also saw how the super() built-in behaves, sometimes unexpectedly, in hierar‐ chies with multiple inheritance. The behavior of super() is designed to support mixin classes, which we then studied through the simple example of the UpperCase Mixin for case-insensitive mappings.\n\nWe saw how multiple inhertance and mixin methods are used in Python’s ABCs, as well as in the socketserver threading and forking mixins. More complex uses of\n\n514\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nmultiple inheritance were exemplified by Django’s class-based views and the Tkinter GUI toolkit. Although Tkinter is not an example of modern best practices, it is an example of overly complex class hierarchies we may find in legacy systems.\n\nTo close the chapter, I presented seven recommendations to cope with inheritance, and applied some of that advice in a commentary of the Tkinter class hierarchy.\n\nRejecting inheritance—even single inheritance—is a modern trend. One of the most successful languages created in the 21st century is Go. It doesn’t have a construct called “class,” but you can build types that are structs of encapsulated fields and you can attach methods to those structs. Go allows the definition of interfaces that are checked by the compiler using structural typing, a.k.a. static duck typing—very simi‐ lar to what we now have with protocol types since Python 3.8. Go has special syntax for building types and interfaces by composition, but it does not support inheritance —not even among interfaces.\n\nSo perhaps the best advice about inheritance is: avoid it if you can. But often, we don’t have a choice: the frameworks we use impose their own design choices.\n\nFurther Reading\n\nWhen it comes to reading clarity, properly-done composition is superior to inheri‐ tance. Since code is much more often read than written, avoid subclassing in general, but especially don’t mix the various types of inheritance, and don’t use subclassing for code sharing.\n\n—Hynek Schlawack, Subclassing in Python Redux\n\nDuring the final review of this book, technical reviewer Jürgen Gmach recommended Hynek Schlawack’s post “Subclassing in Python Redux”—the source of the preceding quote. Schlawack is the author of the popular attrs package, and was a core contribu‐ tor to the Twisted asynchronous programming framework, a project started by Glyph Lefkowitz in 2002. Over time, the core team realized they had overused subclassing in their design, according to Schlawack. His post is long, and cites other important posts and talks. Highly recommended.\n\nIn that same conclusion, Hynek Schlawack wrote: “Don’t forget that more often than not, a function is all you need.” I agree, and that is precisely why Fluent Python covers functions in depth before classes and inheritance. My goal was to show how much you can accomplish with functions leveraging existing classes from the standard library, before creating your own classes.\n\nSubclassing built-ins, the super function, and advanced features like descriptors and metaclasses are all introduced in Guido van Rossum’s paper “Unifying types and classes in Python 2.2”. Nothing really important has changed in these features since then. Python 2.2 was an amazing feat of language evolution, adding several powerful\n\nFurther Reading\n\n|\n\n515\n\nnew features in a coherent whole, without breaking backward compatibility. The new features were 100% opt-in. To use them, we just had to explicitly subclass object— directly or indirectly—to create a so-called “new style class.” In Python 3, every class subclasses object.\n\nThe Python Cookbook, 3rd ed. by David Beazley and Brian K. Jones (O’Reilly) has several recipes showing the use of super() and mixin classes. You can start from the illuminating section “8.7. Calling a Method on a Parent Class”, and follow the inter‐ nal references from there.\n\nRaymond Hettinger’s post “Python’s super() considered super!” explains the work‐ ings of super and multiple inheritance in Python from a positive perspective. It was written in response to “Python’s Super is nifty, but you can’t use it (Previously: Python’s Super Considered Harmful)” by James Knight. Martijn Pieters’ response to “How to use super() with one argument?” includes a concise and deep explanation of super, including its relationship with descriptors, a concept we’ll only study in Chap‐ ter 23. That’s the nature of super. It is simple to use in basic use cases, but is a power‐ ful and complex tool that touches some of Python’s most advanced dynamic features, rarely found in other languages.\n\nDespite the titles of those posts, the problem is not really the super built-in—which in Python 3 is not as ugly as it was in Python 2. The real issue is multiple inheritance, which is inherently complicated and tricky. Michele Simionato goes beyond criticiz‐ ing and actually offers a solution in his “Setting Multiple Inheritance Straight”: he implements traits, an explict form of mixins that originated in the Self language. Sim‐ ionato has a long series of blog posts about multiple inheritance in Python, including “The wonders of cooperative inheritance, or using super in Python 3”; “Mixins con‐ sidered harmful,” part 1 and part 2; and “Things to Know About Python Super,” part 1, part 2, and part 3. The oldest posts use the Python 2 super syntax, but are still rele‐ vant.\n\nI read the first edition of Grady Booch et al., Object-Oriented Analysis and Design, 3rd ed., and highly recommend it as a general primer on object-oriented thinking, inde‐ pendent of programming language. It is a rare book that covers multiple inheritance without prejudice.\n\nNow more than ever it’s fashionable to avoid inheritance, so here are two references about how to do that. Brandon Rhodes wrote “The Composition Over Inheritance Principle”, part of his excellent Python Design Patterns guide. Augie Fackler and Nathaniel Manista presented “The End Of Object Inheritance & The Beginning Of A New Modularity” at PyCon 2013. Fackler and Manista talk about organizing systems around interfaces and functions that handle objects implementing those interfaces, avoiding the tight coupling and failure modes of classes and inheritance. That reminds me a lot of the Go way, but they advocate it for Python.\n\n516\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nSoapbox\n\nThink about the Classes You Really Need\n\n[We] started to push on the inheritance idea as a way to let novices build on frame‐ works that could only be designed by experts.\n\n—Alan Kay, “The Early History of Smalltalk”15\n\nThe vast majority of programmers write applications, not frameworks. Even those who do write frameworks are likely to spend a lot (if not most) of their time writing applications. When we write applications, we normally don’t need to code class hier‐ archies. At most, we write classes that subclass from ABCs or other classes provided by the framework. As application developers, it’s very rare that we need to write a class that will act as the superclass of another. The classes we code are almost always leaf classes (i.e., leaves of the inheritance tree).\n\nIf, while working as an application developer, you find yourself building multilevel class hierarchies, it’s likely that one or more of the following applies:\n\nYou are reinventing the wheel. Go look for a framework or library that provides components you can reuse in your application.\n\nYou are using a badly designed framework. Go look for an alternative.\n\nYou are overengineering. Remember the KISS principle.\n\nYou became bored coding applications and decided to start a new framework. Congratulations and good luck!\n\nIt’s also possible that all of the above apply to your situation: you became bored and decided to reinvent the wheel by building your own overengineered and badly designed framework, which is forcing you to code class after class to solve trivial problems. Hopefully you are having fun, or at least getting paid for it.\n\nMisbehaving Built-Ins: Bug or Feature?\n\nThe built-in dict, list, and str types are essential building blocks of Python itself, so they must be fast—any performance issues in them would severely impact pretty much everything else. That’s why CPython adopted the shortcuts that cause its built- in methods to misbehave by not cooperating with methods overridden by subclasses. A possible way out of this dilemma would be to offer two implementations for each of those types: one “internal,” optimized for use by the interpreter, and an external, easily extensible one.\n\n15 Alan Kay, “The Early History of Smalltalk,” in SIGPLAN Not. 28, 3 (March 1993), 69–95. Also available\n\nonline. Thanks to my friend Christiano Anderson, who shared this reference as I was writing this chapter.\n\nFurther Reading\n\n|\n\n517\n\nBut wait, this is what we have already: UserDict, UserList, and UserString are not as fast as the built-ins but are easily extensible. The pragmatic approach taken by CPython means we also get to use, in our own applications, the highly optimized implementations that are hard to subclass. Which makes sense, considering that it’s not so often that we need a custom mapping, list, or string, but we use dict, list, and str every day. We just need to be aware of the trade-offs involved.\n\nInheritance Across Languages\n\nAlan Kay coined the term “object-oriented,” and Smalltalk had only single inheri‐ tance, although there are forks with various forms of multiple inheritance support, including the modern Squeak and Pharo Smalltalk dialects that support traits—a lan‐ guage construct that fulfills the role of a mixin class, while avoiding some of the issues with multiple inheritance.\n\nThe first popular language to implement multiple inheritance was C++, and the fea‐ ture was abused enough that Java—intended as a C++ replacement—was designed without support for multiple inheritance of implementation (i.e., no mixin classes). That is, until Java 8 introduced default methods that make interfaces very similar to the abstract classes used to define interfaces in C++ and in Python. After Java, proba‐ bly the most widely deployed JVM language is Scala, and it implements traits.\n\nOther languages supporting traits are the latest stable versions of PHP and Groovy, as well as Rust and Raku—the language formerly known as Perl 6.16 So it’s fair to say that traits are trendy in 2021.\n\nRuby offers an original take on multiple inheritance: it does not support it, but intro‐ duces mixins as a language feature. A Ruby class can include a module in its body, so the methods defined in the module become part of the class implementation. This is a “pure” form of mixin, with no inheritance involved, and it’s clear that a Ruby mixin has no influence on the type of the class where it’s used. This provides the benefits of mixins, while avoiding many of its usual problems.\n\nTwo new object-oriented languages that are getting a lot of attention severely limit inheritance: Go and Julia. Both are about programming “objects,” and support polymorphism, but they avoid the term “class.”\n\nGo has no inheritance at all. Julia has a type hierarchy but subtypes cannot inherit structure, only behaviors, and only abstract types can be subtyped. In addition, Julia methods are implemented using multiple dispatch—a more advanced form of the mechanism we saw in “Single Dispatch Generic Functions” on page 324.\n\n16 My friend and technical reviewer Leonardo Rochael explains better than I could: “The continued existence, but persistent lack of arrival, of Perl 6 was draining willpower out of the evolution of Perl itself. Now Perl continues to be developed as a separate language (it’s up to version 5.34 as of now) with no shadow of depre‐ cation because of the language formerly known as Perl 6.”\n\n518\n\n|\n\nChapter 14: Inheritance: For Better or for Worse\n\nCHAPTER 15 More About Type Hints\n\nI learned a painful lesson that for small programs, dynamic typing is great. For large programs you need a more disciplined approach. And it helps if the language gives you that discipline rather than telling you “Well, you can do whatever you want”.\n\n—Guido van Rossum, a fan of Monty Python1\n\nThis chapter is a sequel to Chapter 8, covering more of Python’s gradual type system. The main topics are:\n\nOverloaded function signatures • typing.TypedDict for type hinting dicts used as records\n\nType casting\n\nRuntime access to type hints\n\nGeneric types\n\n— Declaring a generic class\n\n— Variance: invariant, covariant, and contravariant types\n\n— Generic static protocols\n\nWhat’s New in This Chapter This chapter is new in the second edition of Fluent Python. Let’s start with overloads.\n\n1 From YouTube video of “A Language Creators’ Conversation: Guido van Rossum, James Gosling, Larry Wall, and Anders Hejlsberg,” streamed live on April 2, 2019. Quote starts at 1:32:05, edited for brevity. Full tran‐ script available at https://github.com/fluentpython/language-creators.\n\n519\n\nOverloaded Signatures Python functions may accept different combinations of arguments. The @typ ing.overload decorator allows annotating those different combinations. This is par‐ ticularly important when the return type of the function depends on the type of two or more parameters.\n\nConsider the sum built-in function. This is the text of help(sum):\n\n>>> help(sum) sum(iterable, /, start=0) Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n\nWhen the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types.\n\nThe sum built-in is written in C, but typeshed has overloaded type hints for it, in builtins.pyi:\n\n@overload def sum(__iterable: Iterable[_T]) -> Union[_T, int]: ... @overload def sum(__iterable: Iterable[_T], start: _S) -> Union[_T, _S]: ...\n\nFirst let’s look at the overall syntax of overloads. That’s all the code about the sum you’ll find in the stub file (.pyi). The implementation would be in a different file. The ellipsis (...) has no function other than to fulfill the syntactic requirement for a function body, similar to pass. So .pyi files are valid Python files.\n\nAs mentioned in “Annotating Positional Only and Variadic Parameters” on page 295, the two leading underscores in __iterable are a PEP 484 convention for positional- only arguments that is enforced by Mypy. It means you can call sum(my_list), but not sum(__iterable = my_list).\n\nThe type checker tries to match the given arguments with each overloaded signature, in order. The call sum(range(100), 1000) doesn’t match the first overload, because that signature has only one parameter. But it matches the second.\n\nYou can also use @overload in a regular Python module, by writing the overloaded signatures right before the function’s actual signature and implementation. Example 15-1 shows how sum would appear annotated and implemented in a Python module.\n\nExample 15-1. mysum.py: definition of the sum function with overloaded signatures\n\nimport functools import operator from collections.abc import Iterable\n\n520\n\n|\n\nChapter 15: More About Type Hints\n\nfrom typing import overload, Union, TypeVar\n\nT = TypeVar('T') S = TypeVar('S')\n\n@overload def sum(it: Iterable[T]) -> Union[T, int]: ... @overload def sum(it: Iterable[T], /, start: S) -> Union[T, S]: ... def sum(it, /, start=0): return functools.reduce(operator.add, it, start)\n\nWe need this second TypeVar in the second overload.\n\nThis signature is for the simple case: sum(my_iterable). The result type may be T —the type of the elements that my_iterable yields—or it may be int if the itera‐ ble is empty, because the default value of the start parameter is 0.\n\nWhen start is given, it can be of any type S, so the result type is Union[T, S]. This is why we need S. If we reused T, then the type of start would have to be the same type as the elements of Iterable[T].\n\nThe signature of the actual function implementation has no type hints.\n\nThat’s a lot of lines to annotate a one-line function. Probably overkill, I know. At least it wasn’t a foo function.\n\nIf you want to learn about @overload by reading code, typeshed has hundreds of examples. On typeshed, the stub file for Python’s built-ins has 186 overloads as I write this—more than any other in the standard library.\n\nTake Advantage of Gradual Typing\n\nAiming for 100% of annotated code may lead to type hints that add lots of noise but little value. Refactoring to simplify type hinting can lead to cumbersome APIs. Sometimes it’s better to be prag‐ matic and leave a piece of code without type hints.\n\nThe handy APIs we call Pythonic are often hard to annotate. In the next section we’ll see an example: six overloads are needed to properly annotate the flexible max built-in function.\n\nMax Overload It is difficult to add type hints to functions that leverage the powerful dynamic fea‐ tures of Python.\n\nOverloaded Signatures\n\n|\n\n521\n\nWhile studying typeshed, I found bug report #4051: Mypy failed to warn that it is ille‐ gal to pass None as one of the arguments to the built-in max() function, or to pass an iterable that at some point yields None. In either case, you get a runtime exception like this one:\n\nTypeError: '>' not supported between instances of 'int' and 'NoneType'\n\nThe documentation of max starts with this sentence:\n\nReturn the largest item in an iterable or the largest of two or more arguments.\n\nTo me, that’s a very intuitive description.\n\nBut if I must annotate a function described in those terms, I have to ask: which is it? An iterable or two or more arguments?\n\nThe reality is more complicated because max also takes two optional keyword argu‐ ments: key and default.\n\nI coded max in Python to make it easier to see the relationship between how it works and the overloaded annotations (the built-in max is in C); see Example 15-2.\n\nExample 15-2. mymax.py: Python rewrite of max function\n\n# imports and definitions omitted, see next listing\n\nMISSING = object() EMPTY_MSG = 'max() arg is an empty sequence'\n\n# overloaded type hints omitted, see next listing\n\ndef max(first, *args, key=None, default=MISSING): if args: series = args candidate = first else: series = iter(first) try: candidate = next(series) except StopIteration: if default is not MISSING: return default raise ValueError(EMPTY_MSG) from None if key is None: for current in series: if candidate < current: candidate = current else: candidate_key = key(candidate) for current in series: current_key = key(current)\n\n522\n\n|\n\nChapter 15: More About Type Hints\n\nif candidate_key < current_key: candidate = current candidate_key = current_key return candidate\n\nThe focus of this example is not the logic of max, so I will not spend time with its implementation, other than explaining MISSING. The MISSING constant is a unique object instance used as a sentinel. It is the default value for the default= keyword argument, so that max can accept default=None and still distinguish between these two situations:\n\n1. The user did not provide a value for default=, so it is MISSING, and max raises ValueError if first is an empty iterable.\n\n2. The user provided some value for default=, including None, so max returns that value if first is an empty iterable.\n\nTo fix issue #4051, I wrote the code in Example 15-3.2\n\nExample 15-3. mymax.py: top of the module, with imports, definitions, and overloads\n\nfrom collections.abc import Callable, Iterable from typing import Protocol, Any, TypeVar, overload, Union\n\nclass SupportsLessThan(Protocol): def __lt__(self, other: Any) -> bool: ...\n\nT = TypeVar('T') LT = TypeVar('LT', bound=SupportsLessThan) DT = TypeVar('DT')\n\nMISSING = object() EMPTY_MSG = 'max() arg is an empty sequence'\n\n@overload def max(__arg1: LT, __arg2: LT, *args: LT, key: None = ...) -> LT: ... @overload def max(__arg1: T, __arg2: T, *args: T, key: Callable[[T], LT]) -> T: ... @overload def max(__iterable: Iterable[LT], *, key: None = ...) -> LT: ... @overload def max(__iterable: Iterable[T], *, key: Callable[[T], LT]) -> T:\n\n2 I am grateful to Jelle Zijlstra—a typeshed maintainer—who taught me several things, including how to reduce\n\nmy original nine overloads to six.\n\nOverloaded Signatures\n\n|\n\n523\n\n... @overload def max(__iterable: Iterable[LT], *, key: None = ..., default: DT) -> Union[LT, DT]: ... @overload def max(__iterable: Iterable[T], *, key: Callable[[T], LT], default: DT) -> Union[T, DT]: ...\n\nMy Python implementation of max is about the same length as all those typing imports and declarations. Thanks to duck typing, my code has no isinstance checks, and provides the same error checking as those type hints—but only at run‐ time, of course.\n\nA key benefit of @overload is declaring the return type as precisely as possible, according to the types of the arguments given. We’ll see that benefit next by studying the overloads for max in groups of one or two at a time.\n\nArguments implementing SupportsLessThan, but key and default not provided\n\n@overload def max(__arg1: LT, __arg2: LT, *_args: LT, key: None = ...) -> LT: ... # ... lines omitted ... @overload def max(__iterable: Iterable[LT], *, key: None = ...) -> LT: ...\n\nIn these cases, the inputs are either separate arguments of type LT implementing SupportsLessThan, or an Iterable of such items. The return type of max is the same as the actual arguments or items, as we saw in “Bounded TypeVar” on page 284.\n\nSample calls that match these overloads:\n\nmax(1, 2, -3) # returns 2 max(['Go', 'Python', 'Rust']) # returns 'Rust'\n\nArgument key provided, but no default\n\n@overload def max(__arg1: T, __arg2: T, *_args: T, key: Callable[[T], LT]) -> T: ... # ... lines omitted ... @overload def max(__iterable: Iterable[T], *, key: Callable[[T], LT]) -> T: ...\n\nThe inputs can be separate items of any type T or a single Iterable[T], and key= must be a callable that takes an argument of the same type T, and returns a value that\n\n524\n\n|\n\nChapter 15: More About Type Hints\n\nimplements SupportsLessThan. The return type of max is the same as the actual argu‐ ments.\n\nSample calls that match these overloads:\n\nmax(1, 2, -3, key=abs) # returns -3 max(['Go', 'Python', 'Rust'], key=len) # returns 'Python'\n\nArgument default provided, but no key\n\n@overload def max(__iterable: Iterable[LT], *, key: None = ..., default: DT) -> Union[LT, DT]: ...\n\nThe input is an iterable of items of type LT implementing SupportsLessThan. The default= argument is the return value when the Iterable is empty. Therefore the return type of max must be a Union of type LT and the type of the default argument.\n\nSample calls that match these overloads:\n\nmax([1, 2, -3], default=0) # returns 2 max([], default=None) # returns None\n\nArguments key and default provided\n\n@overload def max(__iterable: Iterable[T], *, key: Callable[[T], LT], default: DT) -> Union[T, DT]: ...\n\nThe inputs are:\n\nAn Iterable of items of any type T • Callable that takes an argument of type T and returns a value of type LT that implements SupportsLessThan\n\nA default value of any type DT\n\nThe return type of max must be a Union of type T or the type of the default argument:\n\nmax([1, 2, -3], key=abs, default=None) # returns -3 max([], key=abs, default=None) # returns None\n\nTakeaways from Overloading max Type hints allow Mypy to flag a call like max([None, None]) with this error message:\n\nmymax_demo.py:109: error: Value of type variable \"_LT\" of \"max\" cannot be \"None\"\n\nOverloaded Signatures\n\n|\n\n525\n\nOn the other hand, having to write so many lines to support the type checker may discourage people from writing convenient and flexible functions like max. If I had to reinvent the min function as well, I could refactor and reuse most of the implementa‐ tion of max. But I’d have to copy and paste all overloaded declarations—even though they would be identical for min, except for the function name.\n\nMy friend João S. O. Bueno—one of the smartest Python devs I know—tweeted this:\n\nAlthough it is this hard to express the signature of max—it fits in one’s mind quite easily. My understanding is that the expressiveness of annotation markings is very limited, compared to that of Python.\n\nNow let’s study the TypedDict typing construct. It is not as useful as I imagined at first, but has its uses. Experimenting with TypedDict demonstrates the limitations of static typing for handling dynamic structures, such as JSON data.\n\nTypedDict\n\nIt’s tempting to use TypedDict to protect against errors while han‐ dling dynamic data structures like JSON API responses. But the examples here make clear that correct handling of JSON must be done at runtime, and not with static type checking. For runtime checking of JSON-like structures using type hints, check out the pydantic package on PyPI.\n\nPython dictionaries are sometimes used as records, with the keys used as field names and field values of different types.\n\nFor example, consider a record describing a book in JSON or Python:\n\n{\"isbn\": \"0134757599\", \"title\": \"Refactoring, 2e\", \"authors\": [\"Martin Fowler\", \"Kent Beck\"], \"pagecount\": 478}\n\nBefore Python 3.8, there was no good way to annotate a record like that, because the mapping types we saw in “Generic Mappings” on page 276 limit all values to have the same type.\n\nHere are two lame attempts to annotate a record like the preceding JSON object:\n\nDict[str, Any]\n\nThe values may be of any type.\n\n526\n\n|\n\nChapter 15: More About Type Hints\n\nDict[str, Union[str, int, List[str]]]\n\nHard to read, and doesn’t preserve the relationship between field names and their respective field types: title is supposed to be a str, it can’t be an int or a List[str].\n\nPEP 589—TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys addressed that problem. Example 15-4 shows a simple TypedDict.\n\nExample 15-4. books.py: the BookDict definition\n\nfrom typing import TypedDict\n\nclass BookDict(TypedDict): isbn: str title: str authors: list[str] pagecount: int\n\nAt first glance, typing.TypedDict may seem like a data class builder, similar to typing.NamedTuple—covered in Chapter 5.\n\nThe syntactic similarity is misleading. TypedDict is very different. It exists only for the benefit of type checkers, and has no runtime effect.\n\nTypedDict provides two things:\n\nClass-like syntax to annotate a dict with type hints for the value of each “field.” • A constructor that tells the type checker to expect a dict with the keys and values as specified.\n\nAt runtime, a TypedDict constructor such as BookDict is a placebo: it has the same effect as calling the dict constructor with the same arguments.\n\nThe fact that BookDict creates a plain dict also means that:\n\nThe “fields” in the pseudoclass definition don’t create instance attributes.\n\nYou can’t write initializers with default values for the “fields.”\n\nMethod definitions are not allowed.\n\nLet’s explore the behavior of a BookDict at runtime (Example 15-5).\n\nExample 15-5. Using a BookDict, but not quite as intended\n\n>>> from books import BookDict >>> pp = BookDict(title='Programming Pearls', ... authors='Jon Bentley',\n\nTypedDict\n\n|\n\n527\n\n... isbn='0201657880', ... pagecount=256) >>> pp {'title': 'Programming Pearls', 'authors': 'Jon Bentley', 'isbn': '0201657880', 'pagecount': 256} >>> type(pp) <class 'dict'> >>> pp.title Traceback (most recent call last): File \"<stdin>\", line 1, in <module> AttributeError: 'dict' object has no attribute 'title' >>> pp['title'] 'Programming Pearls' >>> BookDict.__annotations__ {'isbn': <class 'str'>, 'title': <class 'str'>, 'authors': typing.List[str], 'pagecount': <class 'int'>}\n\nYou can call BookDict like a dict constructor with keyword arguments, or pass‐ ing a dict argument—including a dict literal.\n\nOops…I forgot authors takes a list. But gradual typing means no type checking at runtime.\n\nThe result of calling BookDict is a plain dict…\n\n…therefore you can’t read the data using object.field notation.\n\nThe type hints are in BookDict.__annotations__, and not in pp.\n\nWithout a type checker, TypedDict is as useful as comments: it may help people read the code, but that’s it. In contrast, the class builders from Chapter 5 are useful even if you don’t use a type checker, because at runtime they generate or enhance a custom class that you can instantiate. They also provide several useful methods or functions listed in Table 5-1.\n\nExample 15-6 builds a valid BookDict and tries some operations on it. This shows how TypedDict enables Mypy to catch errors, shown in Example 15-7.\n\nExample 15-6. demo_books.py: legal and illegal operations on a BookDict\n\nfrom books import BookDict from typing import TYPE_CHECKING\n\ndef demo() -> None: book = BookDict( isbn='0134757599', title='Refactoring, 2e', authors=['Martin Fowler', 'Kent Beck'],\n\n528\n\n|\n\nChapter 15: More About Type Hints\n\npagecount=478 ) authors = book['authors'] if TYPE_CHECKING: reveal_type(authors) authors = 'Bob' book['weight'] = 4.2 del book['title']\n\nif __name__ == '__main__': demo()\n\nRemember to add a return type, so that Mypy doesn’t ignore the function.\n\nThis is a valid BookDict: all the keys are present, with values of the correct types.\n\nMypy will infer the type of authors from the annotation for the 'authors' key in BookDict.\n\ntyping.TYPE_CHECKING is only True when the program is being type checked. At runtime, it’s always false.\n\nThe previous if statement prevents reveal_type(authors) from being called at runtime. reveal_type is not a runtime Python function, but a debugging facility provided by Mypy. That’s why there is no import for it. See its output in Example 15-7.\n\nThe last three lines of the demo function are illegal. They will cause error mes‐ sages in Example 15-7.\n\nType checking demo_books.py from Example 15-6, we get Example 15-7.\n\nExample 15-7. Type checking demo_books.py\n\n…/typeddict/ $ mypy demo_books.py demo_books.py:13: note: Revealed type is 'built-ins.list[built-ins.str]' demo_books.py:14: error: Incompatible types in assignment (expression has type \"str\", variable has type \"List[str]\") demo_books.py:15: error: TypedDict \"BookDict\" has no key 'weight' demo_books.py:16: error: Key 'title' of TypedDict \"BookDict\" cannot be deleted Found 3 errors in 1 file (checked 1 source file)\n\nTypedDict\n\n|\n\n529\n\nThis note is the result of reveal_type(authors).\n\nThe type of the authors variable was inferred from the type of the book['au thors'] expression that initialized it. You can’t assign a str to a variable of type List[str]. Type checkers usually don’t allow the type of a variable to change.3\n\nCannot assign to a key that is not part of the BookDict definition.\n\nCannot delete a key that is part of the BookDict definition.\n\nNow let’s see BookDict used in function signatures, to type check function calls.\n\nImagine you need to generate XML from book records, similar to this:\n\n<BOOK> <ISBN>0134757599</ISBN> <TITLE>Refactoring, 2e</TITLE> <AUTHOR>Martin Fowler</AUTHOR> <AUTHOR>Kent Beck</AUTHOR> <PAGECOUNT>478</PAGECOUNT> </BOOK>\n\nIf you were writing MicroPython code to be embedded in a tiny microcontroller, you might write a function like what’s shown in Example 15-8.4\n\nExample 15-8. books.py: to_xml function\n\nAUTHOR_ELEMENT = '<AUTHOR>{}</AUTHOR>'\n\ndef to_xml(book: BookDict) -> str: elements: list[str] = [] for key, value in book.items(): if isinstance(value, list): elements.extend( AUTHOR_ELEMENT.format(n) for n in value) else: tag = key.upper() elements.append(f'<{tag}>{value}</{tag}>') xml = '\\n\\t'.join(elements) return f'<BOOK>\\n\\t{xml}\\n</BOOK>'\n\n3 As of May 2020, pytype allows it. But its FAQ says it will be disallowed in the future. See the question, “Why\n\ndidn’t pytype catch that I changed the type of an annotated variable?” in the pytype FAQ.\n\n4 I prefer to use the lxml package to generate and parse XML: it’s easy to get started, full-featured, and fast.\n\nUnfortunately, lxml and Python’s own ElementTree don’t fit the limited RAM of my hypothetical microcon‐ troller.\n\n530\n\n|\n\nChapter 15: More About Type Hints\n\nThe whole point of the example: using BookDict in the function signature.\n\nIt’s often necessary to annotate collections that start empty, otherwise Mypy can’t infer the type of the elements.5\n\nMypy understands isinstance checks, and treats value as a list in this block.\n\nWhen I used key == 'authors' as the condition for the if guarding this block, Mypy found an error in this line: \"object\" has no attribute \"__iter__\", because it inferred the type of value returned from book.items() as object, which doesn’t support the __iter__ method required by the generator expres‐ sion. With the isinstance check, this works because Mypy knows that value is a list in this block.\n\nExample 15-9 shows a function that parses a JSON str and returns a BookDict.\n\nExample 15-9. books_any.py: from_json function\n\ndef from_json(data: str) -> BookDict: whatever = json.loads(data) return whatever\n\nThe return type of json.loads() is Any.6\n\nI can return whatever—of type Any—because Any is consistent-with every type, including the declared return type, BookDict.\n\nThe second point of Example 15-9 is very important to keep in mind: Mypy will not flag any problem in this code, but at runtime the value in whatever may not conform to the BookDict structure—in fact, it may not be a dict at all!\n\nIf you run Mypy with --disallow-any-expr, it will complain about the two lines in the body of from_json:\n\n…/typeddict/ $ mypy books_any.py --disallow-any-expr books_any.py:30: error: Expression has type \"Any\" books_any.py:31: error: Expression has type \"Any\" Found 2 errors in 1 file (checked 1 source file)\n\n5 The Mypy documentation discusses this in its “Common issues and solutions” page, in the section, “Types of\n\nempty collections”.\n\n6 Brett Cannon, Guido van Rossum, and others have been discussing how to type hint json.loads() since\n\n2016 in Mypy issue #182: Define a JSON type.\n\nTypedDict\n\n|\n\n531",
      "page_number": 535
    },
    {
      "number": 28,
      "title": "Segment 28 (pages 553-575)",
      "start_page": 553,
      "end_page": 575,
      "detection_method": "synthetic",
      "content": "Lines 30 and 31 mentioned in the previous snippet are the body of the from_json function. We can silence the type error by adding a type hint to the initialization of the whatever variable, as in Example 15-10.\n\nExample 15-10. books.py: from_json function with variable annotation\n\ndef from_json(data: str) -> BookDict: whatever: BookDict = json.loads(data) return whatever\n\n--disallow-any-expr does not cause errors when an expression of type Any is immediately assigned to a variable with a type hint.\n\nNow whatever is of type BookDict, the declared return type.\n\nDon’t be lulled into a false sense of type safety by Example 15-10! Looking at the code at rest, the type checker cannot predict that json.loads() will return anything that resembles a BookDict. Only runtime validation can guarantee that.\n\nStatic type checking is unable to prevent errors with code that is inherently dynamic, such as json.loads(), which builds Python objects of different types at runtime, as Examples 15-11, 15-12, and 15-13 demonstrate.\n\nExample 15-11. demo_not_book.py: from_json returns an invalid BookDict, and to_xml accepts it\n\nfrom books import to_xml, from_json from typing import TYPE_CHECKING\n\ndef demo() -> None: NOT_BOOK_JSON = \"\"\" {\"title\": \"Andromeda Strain\", \"flavor\": \"pistachio\", \"authors\": true} \"\"\" not_book = from_json(NOT_BOOK_JSON) if TYPE_CHECKING: reveal_type(not_book) reveal_type(not_book['authors'])\n\nprint(not_book) print(not_book['flavor'])\n\nxml = to_xml(not_book) print(xml)\n\n532\n\n|\n\nChapter 15: More About Type Hints\n\nif __name__ == '__main__': demo()\n\nThis line does not produce a valid BookDict—see the content of NOT_BOOK_JSON.\n\nLet’s have Mypy reveal a couple of types.\n\nThis should not be a problem: print can handle object and every other type.\n\nBookDict has no 'flavor' key, but the JSON source does…what will happen?\n\nRemember the signature: def to_xml(book: BookDict) -> str:.\n\nWhat will the XML output look like?\n\nNow we check demo_not_book.py with Mypy (Example 15-12).\n\nExample 15-12. Mypy report for demo_not_book.py, reformatted for clarity\n\n…/typeddict/ $ mypy demo_not_book.py demo_not_book.py:12: note: Revealed type is 'TypedDict('books.BookDict', {'isbn': built-ins.str, 'title': built-ins.str, 'authors': built-ins.list[built-ins.str], 'pagecount': built-ins.int})' demo_not_book.py:13: note: Revealed type is 'built-ins.list[built-ins.str]' demo_not_book.py:16: error: TypedDict \"BookDict\" has no key 'flavor' Found 1 error in 1 file (checked 1 source file)\n\nThe revealed type is the nominal type, not the runtime content of not_book.\n\nAgain, this is the nominal type of not_book['authors'], as defined in BookDict. Not the runtime type.\n\nThis error is for line print(not_book['flavor']): that key does not exist in the nominal type.\n\nNow let’s run demo_not_book.py, showing the output in Example 15-13.\n\nExample 15-13. Output of running demo_not_book.py\n\n…/typeddict/ $ python3 demo_not_book.py {'title': 'Andromeda Strain', 'flavor': 'pistachio', 'authors': True} pistachio <BOOK>\n\nTypedDict\n\n|\n\n533\n\n<TITLE>Andromeda Strain</TITLE> <FLAVOR>pistachio</FLAVOR> <AUTHORS>True</AUTHORS> </BOOK>\n\nThis is not really a BookDict.\n\nThe value of not_book['flavor'].\n\nto_xml takes a BookDict argument, but there is no runtime checking: garbage in, garbage out.\n\nExample 15-13 shows that demo_not_book.py outputs nonsense, but has no runtime errors. Using a TypedDict while handling JSON data did not provide much type safety.\n\nIf you look at the code for to_xml in Example 15-8 through the lens of duck typing, the argument book must provide an .items() method that returns an iterable of tuples like (key, value) where:\n\nkey must have an .upper() method • value can be anything\n\nThe point of this demonstration: when handling data with a dynamic structure, such as JSON or XML, TypedDict is absolutely not a replacement for data validation at runtime. For that, use pydantic.\n\nTypedDict has more features, including support for optional keys, a limited form of inheritance, and an alternative declaration syntax. If you want to know more about it, please review PEP 589—TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys.\n\nNow let’s turn our attention to a function that is best avoided, but sometimes is unavoidable: typing.cast.\n\nType Casting No type system is perfect, and neither are the static type checkers, the type hints in the typeshed project, or the type hints in the third-party packages that have them.\n\nThe typing.cast() special function provides one way to handle type checking mal‐ functions or incorrect type hints in code we can’t fix. The Mypy 0.930 documentation explains:\n\nCasts are used to silence spurious type checker warnings and give the type checker a little help when it can’t quite understand what is going on.\n\n534\n\n|\n\nChapter 15: More About Type Hints\n\nAt runtime, typing.cast does absolutely nothing. This is its implementation:\n\ndef cast(typ, val): \"\"\"Cast a value to a type. This returns the value unchanged. To the type checker this signals that the return value has the designated type, but at runtime we intentionally don't check anything (we want this to be as fast as possible). \"\"\" return val\n\nPEP 484 requires type checkers to “blindly believe” the type stated in the cast. The “Casts” section of PEP 484 gives an example where the type checker needs the guid‐ ance of cast:\n\nfrom typing import cast\n\ndef find_first_str(a: list[object]) -> str: index = next(i for i, x in enumerate(a) if isinstance(x, str)) # We only get here if there's at least one string return cast(str, a[index])\n\nThe next() call on the generator expression will either return the index of a str item or raise StopIteration. Therefore, find_first_str will always return a str if no exception is raised, and str is the declared return type.\n\nBut if the last line were just return a[index], Mypy would infer the return type as object because the a argument is declared as list[object]. So the cast() is required to guide Mypy.7\n\nHere is another example with cast, this time to correct an outdated type hint for Python’s standard library. In Example 21-12, I create an asyncio Server object and I want to get the address the server is listening to. I coded this line:\n\naddr = server.sockets[0].getsockname()\n\nBut Mypy reported this error:\n\nValue of type \"Optional[List[socket]]\" is not indexable\n\nThe type hint for Server.sockets on typeshed in May 2021 is valid for Python 3.6, where the sockets attribute could be None. But in Python 3.7, sockets became a property with a getter that always returns a list—which may be empty if the server has no sockets. And since Python 3.8, the getter returns a tuple (used as an immuta‐ ble sequence).\n\n7 The use of enumerate in the example is intended to confuse the type checker. A simpler implementation\n\nyielding strings directly instead of going through the enumerate index is correctly analyzed by Mypy, and the cast() is not needed.\n\nType Casting\n\n|\n\n535\n\nSince I can’t fix typeshed right now,8 I added a cast, like this:\n\nfrom asyncio.trsock import TransportSocket from typing import cast\n\n# ... many lines omitted ...\n\nsocket_list = cast(tuple[TransportSocket, ...], server.sockets) addr = socket_list[0].getsockname()\n\nUsing cast in this case required a couple of hours to understand the problem and read asyncio source code to find the correct type of the sockets: the TransportSocket class from the undocumented asyncio.trsock module. I also had to add two import statements and another line of code for readability.9 But the code is safer.\n\nThe careful reader may note that sockets[0] could raise IndexError if sockets is empty. However, as far as I understand asyncio, that cannot happen in Example 21-12 because the server is ready to accept connections by the time I read its sockets attribute, therefore it will not be empty. Anyway, IndexError is a runtime error. Mypy can’t spot the problem even in a trivial case like print([][0]).\n\nDon’t get too comfortable using cast to silence Mypy, because Mypy is usually right when it reports an error. If you are using cast very often, that’s a code smell. Your team may be misusing type hints, or you may have low-quality dependencies in your codebase.\n\nDespite the downsides, there are valid uses for cast. Here is something Guido van Rossum wrote about it:\n\nWhat’s wrong with the occasional cast() call or # type: ignore comment?10\n\n8 I reported typeshed issue #5535, “Wrong type hint for asyncio.base_events.Server sockets attribute.” and it was quickly fixed by Sebastian Rittau. However, I decided to keep the example because it illustrates a com‐ mon use case for cast, and the cast I wrote is harmless.\n\n9 To be honest, I originally appended a # type: ignore comment to the line with server.sockets[0] because after a little research I found similar lines the asyncio documentation and in a test case, so I suspected the problem was not in my code.\n\n10 19 May 2020 message to the typing-sig mailing list.\n\n536\n\n|\n\nChapter 15: More About Type Hints\n\nIt is unwise to completely ban the use of cast, especially because the other work‐ arounds are worse:\n\n# type: ignore is less informative.11 • Using Any is contagious: since Any is consistent-with all types, abusing it may pro‐ duce cascading effects through type inference, undermining the type checker’s ability to detect errors in other parts of the code.\n\nOf course, not all typing mishaps can be fixed with cast. Sometimes we need # type: ignore, the occasional Any, or even leaving a function without type hints.\n\nNext, let’s talk about using annotations at runtime.\n\nReading Type Hints at Runtime At import time, Python reads the type hints in functions, classes, and modules, and stores them in attributes named __annotations__. For instance, consider the clip function in Example 15-14.12\n\nExample 15-14. clipannot.py: annotated signature of a clip function\n\ndef clip(text: str, max_len: int = 80) -> str:\n\nThe type hints are stored as a dict in the __annotations__ attribute of the function:\n\n>>> from clip_annot import clip >>> clip.__annotations__ {'text': <class 'str'>, 'max_len': <class 'int'>, 'return': <class 'str'>}\n\nThe 'return' key maps to the return type hint after the -> symbol in Example 15-14.\n\nNote that the annotations are evaluated by the interpreter at import time, just as parameter default values are also evaluated. That’s why the values in the annotations are the Python classes str and int, and not the strings 'str' and 'int'. The import time evaluation of annotations is the standard as of Python 3.10, but that may change if PEP 563 or PEP 649 become the standard behavior.\n\n11 The syntax # type: ignore[code] allows you to specify which Mypy error code is being silenced, but the\n\ncodes are not always easy to interpret. See “Error codes” in the Mypy documentation.\n\n12 I will not go into the implementation of clip, but you can read the whole module in clip_annot.py if you’re\n\ncurious.\n\nReading Type Hints at Runtime\n\n|\n\n537\n\nProblems with Annotations at Runtime The increased use of type hints raised two problems:\n\nImporting modules uses more CPU and memory when many type hints are used.\n\nReferring to types not yet defined requires using strings instead of actual types.\n\nBoth issues are relevant. The first is because of what we just saw: annotations are evaluated by the interpreter at import time and stored in the __annotations__ attribute. Let’s focus now on the second issue.\n\nStoring annotations as strings is sometimes required because of the “forward refer‐ ence” problem: when a type hint needs to refer to a class defined below in the same module. However, a common manifestation of the problem in source code doesn’t look like a forward reference at all: that’s when a method returns a new object of the same class. Since the class object is not defined until Python completely evaluates the class body, type hints must use the name of the class as a string. Here is an example:\n\nclass Rectangle: # ... lines omitted ... def stretch(self, factor: float) -> 'Rectangle': return Rectangle(width=self.width * factor)\n\nWriting forward referencing type hints as strings is the standard and required prac‐ tice as of Python 3.10. Static type checkers were designed to deal with that issue from the beginning.\n\nBut at runtime, if you write code to read the return annotation for stretch, you will get a string 'Rectangle' instead of a reference to the actual type, the Rectangle class. Now your code needs to figure out what that string means.\n\nThe typing module includes three functions and a class categorized as Introspection helpers, the most important being typing.get_type_hints. Part of its documenta‐ tion states:\n\nget_type_hints(obj, globals=None, locals=None, include_extras=False)\n\n[…] This is often the same as obj.__annotations__. In addition, forward refer‐ ences encoded as string literals are handled by evaluating them in globals and locals namespaces. […]\n\nSince Python 3.10, the new inspect.get_annotations(…) func‐ tion should be used instead of typing.get_type_hints. However, some readers may not be using Python 3.10 yet, so in the examples I’ll use typing.get_type_hints, which is available since the typ ing module was added in Python 3.5.\n\n538\n\n|\n\nChapter 15: More About Type Hints\n\nPEP 563—Postponed Evaluation of Annotations was approved to make it unneces‐ sary to write annotations as strings, and to reduce the runtime costs of type hints. Its main idea is described in these two sentences of the “Abstract”:\n\nThis PEP proposes changing function annotations and variable annotations so that they are no longer evaluated at function definition time. Instead, they are preserved in annotations in string form.\n\nBeginning with Python 3.7, that’s how annotations are handled in any module that starts with this import statement:\n\nfrom __future__ import annotations\n\nTo demonstrate its effect, I put a copy of the same clip function from Example 15-14 in a clip_annot_post.py module with that __future__ import line at the top.\n\nAt the console, here’s what I get when I import that module and read the annotations from clip:\n\n>>> from clip_annot_post import clip >>> clip.__annotations__ {'text': 'str', 'max_len': 'int', 'return': 'str'}\n\nAs you can see, all the type hints are now plain strings, despite the fact they are not written as quoted strings in the definition of clip (Example 15-14).\n\nThe typing.get_type_hints function is able to resolve many type hints, including those in clip:\n\n>>> from clip_annot_post import clip >>> from typing import get_type_hints >>> get_type_hints(clip) {'text': <class 'str'>, 'max_len': <class 'int'>, 'return': <class 'str'>}\n\nCalling get_type_hints gives us the real types—even in some cases where the origi‐ nal type hint is written as a quoted string. That’s the recommended way to read type hints at runtime.\n\nThe PEP 563 behavior was scheduled to become default in Python 3.10, with no __future__ import needed. However, the maintainers of FastAPI and pydantic raised the alarm that the change would break their code which relies on type hints at run‐ time, and cannot use get_type_hints reliably.\n\nIn the ensuing discussion on the python-dev mailing list, Łukasz Langa—the author of PEP 563—described some limitations of that function:\n\n[…] it turned out that typing.get_type_hints() has limits that make its use in gen‐ eral costly at runtime, and more importantly insufficient to resolve all types. The most common example deals with non-global context in which types are generated (e.g., inner classes, classes within functions, etc.). But one of the crown examples of forward references: classes with methods accepting or returning objects of their own type, also\n\nReading Type Hints at Runtime\n\n|\n\n539\n\nisn’t properly handled by typing.get_type_hints() if a class generator is used. There’s some trickery we can do to connect the dots but in general it’s not great.13\n\nPython’s Steering Council decided to postpone making PEP 563 the default behavior until Python 3.11 or later, giving more time to developers to come up with a solution that addresses the issues PEP 563 tried to solve, without breaking widespread uses of type hints at runtime. PEP 649—Deferred Evaluation Of Annotations Using Descrip‐ tors is under consideration as a possible solution, but a different compromise may be reached.\n\nTo summarize: reading type hints at runtime is not 100% reliable as of Python 3.10 and is likely to change in 2022.\n\nCompanies using Python at a very large scale want the benefits of static typing, but they don’t want to pay the price for the evaluation of the type hints at import time. Static checking happens at devel‐ oper workstations and dedicated CI servers, but loading modules happens at a much higher frequency and volume in the production containers, and this cost is not negligible at scale.\n\nThis creates tension in the Python community between those who want type hints to be stored as strings only—to reduce the loading costs—versus those who also want to use type hints at runtime, like the creators and users of pydantic and FastAPI, who would rather have type objects stored instead of having to evaluate those annota‐ tions, a challenging task.\n\nDealing with the Problem Given the unstable situation at present, if you need to read annotations at runtime, I recommend:\n\nAvoid reading __annotations__ directly; instead, use inspect.get_annota tions (from Python 3.10) or typing.get_type_hints (since Python 3.5).\n\nWrite a custom function of your own as a thin wrapper around in spect .get_annotations or typing.get_type_hints, and have the rest of your code‐ base call that custom function, so that future changes are localized to a single function.\n\nTo demonstrate the second point, here are the first lines of the Checked class defined in Example 24-5, which we’ll study in Chapter 24:\n\n13 Message “PEP 563 in light of PEP 649”, posted April 16, 2021.\n\n540\n\n|\n\nChapter 15: More About Type Hints\n\nclass Checked: @classmethod def _fields(cls) -> dict[str, type]: return get_type_hints(cls) # ... more lines ...\n\nThe Checked._fields class method protects other parts of the module from depend‐ ing directly on typing.get_type_hints. If get_type_hints changes in the future, requiring additional logic, or you want to replace it with inspect.get_annotations, the change is limited to Checked._fields and does not affect the rest of your program.\n\nGiven the ongoing discussions and proposed changes for runtime inspection of type hints, the official “Annotations Best Practices” document is required reading, and is likely to be updated on the road to Python 3.11. That how-to was written by Larry Hastings, the author of PEP 649—Deferred Evaluation Of Annotations Using Descriptors, an alternative proposal to address the runtime issues raised by PEP 563—Postponed Evaluation of Annotations.\n\nThe remaining sections of this chapter cover generics, starting with how to define a generic class that can be parameterized by its users.\n\nImplementing a Generic Class In Example 13-7 we defined the Tombola ABC: an interface for classes that work like a bingo cage. The LottoBlower class from Example 13-10 is a concrete implementa‐ tion. Now we’ll study a generic version of LottoBlower used like in Example 15-15.\n\nExample 15-15. generic_lotto_demo.py: using a generic lottery blower class\n\nfrom generic_lotto import LottoBlower\n\nmachine = LottoBlower[int](range(1, 11))\n\nfirst = machine.pick() remain = machine.inspect()\n\nTo instantiate a generic class, we give it an actual type parameter, like int here.\n\nMypy will correctly infer that first is an int…\n\n… and that remain is a tuple of integers.\n\nImplementing a Generic Class\n\n|\n\n541\n\nIn addition, Mypy reports violations of the parameterized type with helpful messages, such as what’s shown in Example 15-16.\n\nExample 15-16. generic_lotto_errors.py: errors reported by Mypy\n\nfrom generic_lotto import LottoBlower\n\nmachine = LottoBlower[int]([1, .2]) ## error: List item 1 has incompatible type \"float\"; ## expected \"int\"\n\nmachine = LottoBlower[int](range(1, 11))\n\nmachine.load('ABC') ## error: Argument 1 to \"load\" of \"LottoBlower\" ## has incompatible type \"str\"; ## expected \"Iterable[int]\" ## note: Following member(s) of \"str\" have conflicts: ## note: Expected: ## note: def __iter__(self) -> Iterator[int] ## note: Got: ## note: def __iter__(self) -> Iterator[str]\n\nUpon instantiation of LottoBlower[int], Mypy flags the float.\n\nWhen calling .load('ABC'), Mypy explains why a str won’t do: str.__iter__ returns an Iterator[str], but LottoBlower[int] requires an Iterator[int].\n\nExample 15-17 is the implementation.\n\nExample 15-17. generic_lotto.py: a generic lottery blower class\n\nimport random\n\nfrom collections.abc import Iterable from typing import TypeVar, Generic\n\nfrom tombola import Tombola\n\nT = TypeVar('T')\n\nclass LottoBlower(Tombola, Generic[T]):\n\ndef __init__(self, items: Iterable[T]) -> None: self._balls = list[T](items)\n\ndef load(self, items: Iterable[T]) -> None: self._balls.extend(items)\n\n542\n\n|\n\nChapter 15: More About Type Hints\n\ndef pick(self) -> T: try: position = random.randrange(len(self._balls)) except ValueError: raise LookupError('pick from empty LottoBlower') return self._balls.pop(position)\n\ndef loaded(self) -> bool: return bool(self._balls)\n\ndef inspect(self) -> tuple[T, ...]: return tuple(self._balls)\n\nGeneric class declarations often use multiple inheritance, because we need to subclass Generic to declare the formal type parameters—in this case, T.\n\nThe items argument in __init__ is of type Iterable[T], which becomes Itera ble[int] when an instance is declared as LottoBlower[int].\n\nThe load method is likewise constrained.\n\nThe return type of T now becomes int in a LottoBlower[int].\n\nNo type variable here.\n\nFinally, T sets the type of the items in the returned tuple.\n\nThe “User-defined generic types” section of the typing module documentation is short, presents good examples, and provides a few more details that I do not cover here.\n\nNow that we’ve seen how to implement a generic class, let’s define the terminology to talk about generics.\n\nImplementing a Generic Class\n\n|\n\n543\n\nBasic Jargon for Generic Types Here are a few definitions that I found useful when studying generics:14\n\nGeneric type\n\nA type declared with one or more type variables. Examples: LottoBlower[T], abc.Mapping[KT, VT]\n\nFormal type parameter\n\nThe type variables that appear in a generic type declaration. Example: KT and VT in the previous example abc.Mapping[KT, VT]\n\nParameterized type\n\nA type declared with actual type parameters. Examples: LottoBlower[int], abc.Mapping[str, float]\n\nActual type parameter\n\nThe actual types given as parameters when a parameterized type is declared. Example: the int in LottoBlower[int]\n\nThe next topic is about how to make generic types more flexible, introducing the concepts of covariance, contravariance, and invariance.\n\nVariance\n\nDepending on your experience with generics in other languages, this may be the most challenging section in the book. The concept of variance is abstract, and a rigorous presentation would make this section look like pages from a math book.\n\nIn practice, variance is mostly relevant to library authors who want to support new generic container types or provide callback-based APIs. Even then, you can avoid much complexity by supporting only invariant containers—which is mostly what we have now in the Python standard library. So, on a first reading, you can skip the whole section or just read the sections about invariant types.\n\nWe first saw the concept of variance in “Variance in Callable types” on page 292, applied to parameterized generic Callable types. Here we’ll expand the concept to cover generic collection types, using a “real world” analogy to make this abstract con‐ cept more concrete.\n\n14 The terms are from Joshua Bloch’s classic book, Effective Java, 3rd ed. (Addison-Wesley). The definitions and\n\nexamples are mine.\n\n544\n\n|\n\nChapter 15: More About Type Hints\n\nImagine that a school cafeteria has a rule that only juice dispensers can be installed.15 General beverage dispensers are not allowed because they may serve sodas, which are banned by the school board.16\n\nAn Invariant Dispenser Let’s try to model the cafeteria scenario with a generic BeverageDispenser class that can be parameterized on the type of beverage. See Example 15-18.\n\nExample 15-18. invariant.py: type definitions and install function\n\nfrom typing import TypeVar, Generic\n\nclass Beverage: \"\"\"Any beverage.\"\"\"\n\nclass Juice(Beverage): \"\"\"Any fruit juice.\"\"\"\n\nclass OrangeJuice(Juice): \"\"\"Delicious juice from Brazilian oranges.\"\"\"\n\nT = TypeVar('T')\n\nclass BeverageDispenser(Generic[T]): \"\"\"A dispenser parameterized on the beverage type.\"\"\" def __init__(self, beverage: T) -> None: self.beverage = beverage\n\ndef dispense(self) -> T: return self.beverage\n\ndef install(dispenser: BeverageDispenser[Juice]) -> None: \"\"\"Install a fruit juice dispenser.\"\"\"\n\nBeverage, Juice, and OrangeJuice form a type hierarchy.\n\nSimple TypeVar declaration.\n\nBeverageDispenser is parameterized on the type of beverage.\n\n15 I first saw the cafeteria analogy for variance in Erik Meijer’s Foreword in The Dart Programming Language\n\nbook by Gilad Bracha (Addison-Wesley).\n\n16 Much better than banning books!\n\nVariance\n\n|\n\n545\n\ninstall is a module-global function. Its type hint enforces the rule that only a juice dispenser is acceptable.\n\nGiven the definitions in Example 15-18, the following code is legal:\n\njuice_dispenser = BeverageDispenser(Juice()) install(juice_dispenser)\n\nHowever, this is not legal:\n\nbeverage_dispenser = BeverageDispenser(Beverage()) install(beverage_dispenser) ## mypy: Argument 1 to \"install\" has ## incompatible type \"BeverageDispenser[Beverage]\" ## expected \"BeverageDispenser[Juice]\"\n\nA dispenser that serves any Beverage is not acceptable because the cafeteria requires a dispenser that is specialized for Juice.\n\nSomewhat surprisingly, this code is also illegal:\n\norange_juice_dispenser = BeverageDispenser(OrangeJuice()) install(orange_juice_dispenser) ## mypy: Argument 1 to \"install\" has ## incompatible type \"BeverageDispenser[OrangeJuice]\" ## expected \"BeverageDispenser[Juice]\"\n\nA dispenser specialized for OrangeJuice is not allowed either. Only BeverageDis penser[Juice] will do. In the typing jargon, we say that BeverageDis penser(Generic[T]) is invariant when BeverageDispenser[OrangeJuice] is not compatible with BeverageDispenser[Juice]—despite the fact that OrangeJuice is a subtype-of Juice.\n\nPython mutable collection types—such as list and set—are invariant. The Lotto Blower class from Example 15-17 is also invariant.\n\nA Covariant Dispenser If we want to be more flexible and model dispensers as a generic class that can accept some beverage type and also its subtypes, we must make it covariant. Example 15-19 shows how we’d declare BeverageDispenser.\n\nExample 15-19. covariant.py: type definitions and install function\n\nT_co = TypeVar('T_co', covariant=True)\n\nclass BeverageDispenser(Generic[T_co]): def __init__(self, beverage: T_co) -> None: self.beverage = beverage\n\n546\n\n|\n\nChapter 15: More About Type Hints\n\ndef dispense(self) -> T_co: return self.beverage\n\ndef install(dispenser: BeverageDispenser[Juice]) -> None: \"\"\"Install a fruit juice dispenser.\"\"\"\n\nSet covariant=True when declaring the type variable; _co is a conventional suf‐ fix for covariant type parameters on typeshed.\n\nUse T_co to parameterize the Generic special class.\n\nType hints for install are the same as in Example 15-18.\n\nThe following code works because now both the Juice dispenser and the Orange Juice dispenser are valid in a covariant BeverageDispenser:\n\njuice_dispenser = BeverageDispenser(Juice()) install(juice_dispenser)\n\norange_juice_dispenser = BeverageDispenser(OrangeJuice()) install(orange_juice_dispenser)\n\nBut a dispenser for an arbitrary Beverage is not acceptable:\n\nbeverage_dispenser = BeverageDispenser(Beverage()) install(beverage_dispenser) ## mypy: Argument 1 to \"install\" has ## incompatible type \"BeverageDispenser[Beverage]\" ## expected \"BeverageDispenser[Juice]\"\n\nThat’s covariance: the subtype relationship of the parameterized dispensers varies in the same direction as the subtype relationship of the type parameters.\n\nA Contravariant Trash Can Now we’ll model the cafeteria rule for deploying a trash can. Let’s assume food and drinks are served in biodegradable packages, and leftovers as well as single-use uten‐ sils are also biodegradable. The trash cans must be suitable for biodegradable refuse.\n\nVariance\n\n|\n\n547\n\nFor the sake of this didactic example, let’s make simplifying assumptions to classify trash in a neat hierarchy:\n\nRefuse is the most general type of trash. All trash is refuse. • Biodegradable is a specific type of trash that can be decom‐ posed by organisms over time. Some Refuse is not Biodegrad able.\n\nCompostable is a specific type of Biodegradable trash that can be efficiently turned into organic fertilizer in a compost bin or in a composting facility. Not all Biodegradable trash is Compo stable in our definition.\n\nIn order to model the rule for an acceptable trash can in the cafeteria, we need to introduce the concept of “contravariance” through an example using it, as shown in Example 15-20.\n\nExample 15-20. contravariant.py: type definitions and install function\n\nfrom typing import TypeVar, Generic\n\nclass Refuse: \"\"\"Any refuse.\"\"\"\n\nclass Biodegradable(Refuse): \"\"\"Biodegradable refuse.\"\"\"\n\nclass Compostable(Biodegradable): \"\"\"Compostable refuse.\"\"\"\n\nT_contra = TypeVar('T_contra', contravariant=True)\n\nclass TrashCan(Generic[T_contra]): def put(self, refuse: T_contra) -> None: \"\"\"Store trash until dumped.\"\"\"\n\ndef deploy(trash_can: TrashCan[Biodegradable]): \"\"\"Deploy a trash can for biodegradable refuse.\"\"\"\n\nA type hierarchy for refuse: Refuse is the most general type, Compostable is the most specific.\n\nT_contra is a conventional name for a contravariant type variable.\n\nTrashCan is contravariant on the type of refuse.\n\nGiven those definitions, these types of trash cans are acceptable:\n\n548\n\n|\n\nChapter 15: More About Type Hints\n\nbio_can: TrashCan[Biodegradable] = TrashCan() deploy(bio_can)\n\ntrash_can: TrashCan[Refuse] = TrashCan() deploy(trash_can)\n\nThe more general TrashCan[Refuse] is acceptable because it can take any kind of refuse, including Biodegradable. However, a TrashCan[Compostable] will not do, because it cannot take Biodegradable:\n\ncompost_can: TrashCan[Compostable] = TrashCan() deploy(compost_can) ## mypy: Argument 1 to \"deploy\" has ## incompatible type \"TrashCan[Compostable]\" ## expected \"TrashCan[Biodegradable]\"\n\nLet’s summarize the concepts we just saw.\n\nVariance Review Variance is a subtle property. The following sections recap the concept of invariant, covariant, and contravariant types, and provide some rules of thumb to reason about them.\n\nInvariant types\n\nA generic type L is invariant when there is no supertype or subtype relationship between two parameterized types, regardless of the relationship that may exist between the actual parameters. In other words, if L is invariant, then L[A] is not a supertype or a subtype of L[B]. They are inconsistent in both ways.\n\nAs mentioned, Python’s mutable collections are invariant by default. The list type is a good example: list[int] is not consistent-with list[float] and vice versa.\n\nIn general, if a formal type parameter appears in type hints of method arguments, and the same parameter appears in method return types, that parameter must be invariant to ensure type safety when updating and reading from the collection.\n\nFor example, here is part of the type hints for the list built-in on typeshed:\n\nclass list(MutableSequence[_T], Generic[_T]): @overload def __init__(self) -> None: ... @overload def __init__(self, iterable: Iterable[_T]) -> None: ... # ... lines omitted ... def append(self, __object: _T) -> None: ... def extend(self, __iterable: Iterable[_T]) -> None: ... def pop(self, __index: int = ...) -> _T: ... # etc...\n\nVariance\n\n|\n\n549\n\nNote that _T appears in the arguments of __init__, append, and extend, and as the return type of pop. There is no way to make such a class type safe if it is covariant or contravariant in _T.\n\nCovariant types\n\nConsider two types A and B, where B is consistent-with A, and neither of them is Any. Some authors use the <: and :> symbols to denote type relationships like this:\n\nA :> B\n\nA is a supertype-of or the same as B.\n\nB <: A\n\nB is a subtype-of or the same as A.\n\nGiven A :> B, a generic type C is covariant when C[A] :> C[B].\n\nNote the direction of the :> symbol is the same in both cases where A is to the left of B. Covariant generic types follow the subtype relationship of the actual type parameters.\n\nImmutable containers can be covariant. For example, this is how the typing.Frozen Set class is documented as a covariant with a type variable using the conventional name T_co:\n\nclass FrozenSet(frozenset, AbstractSet[T_co]):\n\nApplying the :> notation to parameterized types, we have:\n\nfloat :> int frozenset[float] :> frozenset[int]\n\nIterators are another example of covariant generics: they are not read-only collections like a frozenset, but they only produce output. Any code expecting an abc.Itera tor[float] yielding floats can safely use an abc.Iterator[int] yielding integers. Callable types are covariant on the return type for a similar reason.\n\nContravariant types\n\nGiven A :> B, a generic type K is contravariant if K[A] <: K[B].\n\nContravariant generic types reverse the subtype relationship of the actual type parameters.\n\nThe TrashCan class exemplifies this:\n\nRefuse :> Biodegradable TrashCan[Refuse] <: TrashCan[Biodegradable]\n\n550\n\n|\n\nChapter 15: More About Type Hints\n\nA contravariant container is usually a write-only data structure, also known as a “sink.” There are no examples of such collections in the standard library, but there are a few types with contravariant type parameters.\n\nCallable[[ParamType, …], ReturnType] is contravariant on the parameter types, but covariant on the ReturnType, as we saw in “Variance in Callable types” on page 292. In addition, Generator, Coroutine, and AsyncGenerator have one contravariant type parameter. The Generator type is described in “Generic Type Hints for Classic Coroutines” on page 650; Coroutine and AsyncGenerator are described in Chapter 21.\n\nFor the present discussion about variance, the main point is that the contravariant formal parameter defines the type of the arguments used to invoke or send data to the object, while different covariant formal parameters define the types of outputs produced by the object—the yield type or the return type, depending on the object. The meanings of “send” and “yield” are explained in “Classic Coroutines” on page 641.\n\nWe can derive useful guidelines from these observations of covariant outputs and contravariant inputs.\n\nVariance rules of thumb\n\nFinally, here are a few rules of thumb to reason about when thinking through variance:\n\nIf a formal type parameter defines a type for data that comes out of the object, it can be covariant.\n\nIf a formal type parameter defines a type for data that goes into the object after its initial construction, it can be contravariant.\n\nIf a formal type parameter defines a type for data that comes out of the object and the same parameter defines a type for data that goes into the object, it must be invariant.\n\nTo err on the safe side, make formal type parameters invariant.\n\nCallable[[ParamType, …], ReturnType] demonstrates rules #1 and #2: The Return Type is covariant, and each ParamType is contravariant.\n\nBy default, TypeVar creates formal parameters that are invariant, and that’s how the mutable collections in the standard library are annotated.\n\n“Generic Type Hints for Classic Coroutines” on page 650 continues the present discus‐ sion about variance.\n\nNext, let’s see how to define generic static protocols, applying the idea of covariance to a couple of new examples.\n\nVariance\n\n|\n\n551\n\nImplementing a Generic Static Protocol The Python 3.10 standard library provides a few generic static protocols. One of them is SupportsAbs, implemented like this in the typing module:\n\n@runtime_checkable class SupportsAbs(Protocol[T_co]): \"\"\"An ABC with one abstract method __abs__ that is covariant in its return type.\"\"\" __slots__ = ()\n\n@abstractmethod def __abs__(self) -> T_co: pass\n\nT_co is declared according to the naming convention:\n\nT_co = TypeVar('T_co', covariant=True)\n\nThanks to SupportsAbs, Mypy recognizes this code as valid, as you can see in Example 15-21.\n\nExample 15-21. abs_demo.py: use of the generic SupportsAbs protocol\n\nimport math from typing import NamedTuple, SupportsAbs\n\nclass Vector2d(NamedTuple): x: float y: float\n\ndef __abs__(self) -> float: return math.hypot(self.x, self.y)\n\ndef is_unit(v: SupportsAbs[float]) -> bool: \"\"\"'True' if the magnitude of 'v' is close to 1.\"\"\" return math.isclose(abs(v), 1.0)\n\nassert issubclass(Vector2d, SupportsAbs)\n\nv0 = Vector2d(0, 1) sqrt2 = math.sqrt(2) v1 = Vector2d(sqrt2 / 2, sqrt2 / 2) v2 = Vector2d(1, 1) v3 = complex(.5, math.sqrt(3) / 2) v4 = 1\n\nassert is_unit(v0) assert is_unit(v1) assert not is_unit(v2) assert is_unit(v3)\n\n552\n\n|\n\nChapter 15: More About Type Hints\n\nassert is_unit(v4)\n\nprint('OK')\n\nDefining __abs__ makes Vector2d consistent-with SupportsAbs.\n\nParameterizing SupportsAbs with float ensures…\n\n…that Mypy accepts abs(v) as the first argument for math.isclose.\n\nThanks to @runtime_checkable in the definition of SupportsAbs, this is a valid runtime assertion.\n\nThe remaining code all passes Mypy checks and runtime assertions.\n\nThe int type is also consistent-with SupportsAbs. According to typeshed, int.__abs__ returns an int, which is consistent-with the float type parameter declared in the is_unit type hint for the v argument.\n\nSimilarly, we can write a generic version of the RandomPicker protocol presented in Example 13-18, which was defined with a single method pick returning Any.\n\nExample 15-22 shows how to make a generic RandomPicker covariant on the return type of pick.\n\nExample 15-22. generic_randompick.py: definition of generic RandomPicker\n\nfrom typing import Protocol, runtime_checkable, TypeVar\n\nT_co = TypeVar('T_co', covariant=True)\n\n@runtime_checkable class RandomPicker(Protocol[T_co]): def pick(self) -> T_co: ...\n\nDeclare T_co as covariant.\n\nThis makes RandomPicker generic with a covariant formal type parameter.\n\nUse T_co as the return type.\n\nImplementing a Generic Static Protocol\n\n|\n\n553\n\nThe generic RandomPicker protocol can be covariant because its only formal parame‐ ter is used in a return type.\n\nWith this, we can call it a chapter.\n\nChapter Summary The chapter started with a simple example of using @overload, followed by a much more complex example that we studied in detail: the overloaded signatures required to correctly annotate the max built-in function.\n\nThe typing.TypedDict special construct came next. I chose to cover it here, and not in Chapter 5 where we saw typing.NamedTuple, because TypedDict is not a class builder; it’s merely a way to add type hints to a variable or argument that requires a dict with a specific set of string keys, and specific types for each key—which happens when we use a dict as a record, often in the context of handling with JSON data. That section was a bit long because using TypedDict can give a false sense of security, and I wanted to show how runtime checks and error handling are really inevitable when trying to make statically structured records out of mappings that are dynamic in nature.\n\nNext we talked about typing.cast, a function designed to let us guide the work of the type checker. It’s important to carefully consider when to use cast, because over‐ using it hinders the type checker.\n\nRuntime access to type hints came next. The key point was to use typing. get_type_hints instead of reading the __annotations__ attribute directly. However, that function may be unreliable with some annotations, and we saw that Python core developers are still working on a way to make type hints usable at runtime, while reducing their impact on CPU and memory usage.\n\nThe final sections were about generics, starting with the LottoBlower generic class— which we later learned is an invariant generic class. That example was followed by definitions of four basic terms: generic type, formal type parameter, parameterized type, and actual type parameter.\n\nThe major topic of variance was presented next, using cafeteria beverage dispensers and trash cans as “real life” examples of invariant, covariant, and contravariant generic types. Next we reviewed, formalized, and further applied those concepts to examples in Python’s standard library.\n\nLastly, we saw how a generic static protocol is defined, first considering the typ ing.SupportsAbs protocol, and then applying the same idea to the RandomPicker example, making it more strict than the original protocol from Chapter 13.\n\n554\n\n|\n\nChapter 15: More About Type Hints",
      "page_number": 553
    },
    {
      "number": 29,
      "title": "Segment 29 (pages 576-595)",
      "start_page": 576,
      "end_page": 595,
      "detection_method": "synthetic",
      "content": "Python’s type system is a huge and rapidly evolving subject. This chapter is not comprehensive. I chose to focus on topics that are either widely applicable, particularly challenging, or conceptually important and therefore likely to be relevant for a long time.\n\nFurther Reading Python’s static type system was complex as initially designed, and is getting more complex with each passing year. Table 15-1 lists all the PEPs that I am aware of as of May 2021. It would take a whole book to cover everything.\n\nTable 15-1. PEPs about type hints, with links in the titles. PEP with numbers marked with * are important enough to be mentioned in the opening paragraph of the typing documentation. Question marks in the Python column indicate PEPs under discussion or not yet implemented; “n/a” appears in informational PEPs with no specific Python version.\n\nPEP 3107\n\nTitle Function Annotations\n\nPython Year 2006 3.0\n\n483*\n\nThe Theory of Type Hints\n\nn/a\n\n2014\n\n484*\n\nType Hints\n\n3.5\n\n2014\n\n482\n\nLiterature Overview for Type Hints\n\nn/a\n\n2015\n\n526*\n\nSyntax for Variable Annotations\n\n3.6\n\n2016\n\n544*\n\nProtocols: Structural subtyping (static duck typing)\n\n3.8\n\n2017\n\n557\n\nData Classes\n\n3.7\n\n2017\n\n560\n\nCore support for typing module and generic types\n\n3.7\n\n2017\n\n561\n\nDistributing and Packaging Type Information\n\n3.7\n\n2017\n\n563\n\nPostponed Evaluation of Annotations\n\n3.7\n\n2017\n\n586*\n\nLiteral Types\n\n3.8\n\n2018\n\n585\n\nType Hinting Generics In Standard Collections\n\n3.9\n\n2019\n\n589*\n\nTypedDict: Type Hints for Dictionaries with a Fixed Set of Keys\n\n3.8\n\n2019\n\n591* Adding a final qualifier to typing\n\n3.8\n\n2019\n\n593\n\nFlexible function and variable annotations\n\n?\n\n2019\n\n604\n\nAllow writing union types as X | Y\n\n3.10\n\n2019\n\n612\n\nParameter Specification Variables\n\n3.10\n\n2019\n\n613\n\nExplicit Type Aliases\n\n3.10\n\n2020\n\n645\n\nAllow writing optional types as x?\n\n?\n\n2020\n\n646\n\nVariadic Generics\n\n?\n\n2020\n\n647\n\nUser-Defined Type Guards\n\n3.10\n\n2021\n\n649\n\nDeferred Evaluation Of Annotations Using Descriptors\n\n?\n\n2021\n\n655 Marking individual TypedDict items as required or potentially-missing\n\n?\n\n2021\n\nFurther Reading\n\n|\n\n555\n\nPython’s official documentation hardly keeps up with all that, so Mypy’s documenta‐ tion is an essential reference. Robust Python by Patrick Viafore (O’Reilly) is the first book with extensive coverage of Python’s static type system that I know about, pub‐ lished August 2021. You may be reading the second such book right now.\n\nThe subtle topic of variance has its own section in PEP 484, and is also covered in the “Generics” page of Mypy, as well as in its invaluable “Common Issues” page.\n\nPEP 362—Function Signature Object is worth reading if you intend to use the inspect module that complements the typing.get_type_hints function.\n\nIf you are interested in the history of Python, you may like to know that Guido van Rossum posted “Adding Optional Static Typing to Python” on December 23, 2004.\n\n“Python 3 Types in the Wild: A Tale of Two Type Systems” is a research paper by Ingkarat Rak-amnouykit and others from the Rensselaer Polytechnic Institute and IBM TJ Watson Research Center. The paper surveys the use of type hints in open source projects on GitHub, showing that most projects don’t use them, and also that most projects that have type hints apparently don’t use a type checker. I found most interesting the discussion of the different semantics of Mypy and Google’s pytype, which they conclude are “essentially two different type systems.”\n\nTwo seminal papers about gradual typing are Gilad Bracha’s “Pluggable Type Sys‐ tems”, and “Static Typing Where Possible, Dynamic Typing When Needed: The End of the Cold War Between Programming Languages” by Eric Meijer and Peter Dray‐ ton.17\n\nI learned a lot reading the relevant parts of some books about other languages that implement some of the same ideas:\n\nAtomic Kotlin by Bruce Eckel and Svetlana Isakova (Mindview)\n\nEffective Java, 3rd ed., by Joshua Bloch (Addison-Wesley)\n\nProgramming with Types: TypeScript Examples by Vlad Riscutia (Manning)\n\nProgramming TypeScript by Boris Cherny (O’Reilly) • The Dart Programming Language by Gilad Bracha (Addison-Wesley)18\n\nFor some critical views on type systems, I recommend Victor Youdaiken’s posts “Bad ideas in type theory” and “Types considered harmful II”.\n\n17 As a reader of footnotes, you may recall that I credited Erik Meijer for the cafeteria analogy to explain\n\nvariance.\n\n18 That book was written for Dart 1. There are significant changes in Dart 2, including in the type system. Nev‐ ertheless, Bracha is an important researcher in the field of programming language design, and I found the book valuable for his perspective on the design of Dart.\n\n556\n\n|\n\nChapter 15: More About Type Hints\n\nFinally, I was surprised to find “Generics Considered Harmful” by Ken Arnold, a core contributor to Java from the beginning, as well as coauthor of the first four edi‐ tions of the official The Java Programming Language book (Addison-Wesley)—in collaboration with James Gosling, the lead designer of Java.\n\nSadly, Arnold’s criticism applies to Python’s static type system as well. While reading the many rules and special cases of the typing PEPs, I was constantly reminded of this passage from Gosling’s post:\n\nWhich brings up the problem that I always cite for C++: I call it the “Nth order excep‐ tion to the exception rule.” It sounds like this: “You can do x, except in case y, unless y does z, in which case you can if …”\n\nFortunately, Python has a key advantage over Java and C++: an optional type system. We can squelch type checkers and omit type hints when they become too cumbersome.\n\nSoapbox\n\nTyping Rabbit Holes\n\nWhen using a type checker, we are sometimes forced to discover and import classes we did not need to know about, and our code has no need to reference—except to write type hints. Such classes are undocumented, probably because they are consid‐ ered implementation details by the authors of the packages. Here are two examples from the standard library.\n\nTo use cast() in the server.sockets example in “Type Casting” on page 534, I had to scour the vast asyncio documentation and then browse the source code of several modules in that package to discover the undocumented TransportSocket class in the equally undocumented asyncio.trsock module. Using socket.socket instead of TransportSocket would be incorrect, because the latter is explicitly not a subtype of the former, according to a docstring in the source code.\n\nI fell into a similar rabbit hole when I added type hints to Example 19-13, a simple demonstration of multiprocessing. That example uses SimpleQueue objects, which you get by calling multiprocessing.SimpleQueue(). However, I could not use that name in a type hint, because it turns out that multiprocessing.SimpleQueue is not a class! It’s a bound method of the undocumented multiprocessing.BaseContext class, which builds and returns an instance of the SimpleQueue class defined in the undocumented multiprocessing.queues module.\n\nIn each of those cases I had to spend a couple of hours to find the right undocumen‐ ted class to import, just to write a single type hint. This kind of research is part of the job when writing a book. But when writing application code, I’d probably avoid such\n\nFurther Reading\n\n|\n\n557\n\nscavenger hunts for a single offending line and just write # type: ignore. Sometimes that’s the only cost-effective solution.\n\nVariance Notation in Other Languages\n\nVariance is a difficult topic, and Python’s type hints syntax is not as good as it could be. This is evidenced by this direct quote from PEP 484:\n\nCovariance or contravariance is not a property of a type variable, but a property of a generic class defined using this variable.19\n\nIf that is the case, why are covariance and contravariance declared with TypeVar and not on the generic class?\n\nThe authors of PEP 484 worked under the severe self-imposed constraint that type hints should be supported without making any change to the interpreter. This required the introduction of TypeVar to define type variables, and also the abuse of [] to provide Klass[T] syntax for generics—instead of the Klass<T> notation used in other popular languages, including C#, Java, Kotlin, and TypeScript. None of these languages require type variables to be declared before use.\n\nIn addition, the syntax of Kotlin and C# makes it clear whether the type parameter is covariant, contravariant, or invariant exactly where it makes sense: in the class or interface declaration.\n\nIn Kotlin, we could declare the BeverageDispenser like this:\n\nclass BeverageDispenser<out T> { // etc... }\n\nThe out modifier in the formal type parameter means T is an “output” type, therefore BeverageDispenser is covariant.\n\n19 See the last paragraph of the section “Covariance and Contravariance” in PEP 484.\n\n558\n\n|\n\nChapter 15: More About Type Hints\n\nYou can probably guess how TrashCan would be declared:\n\nclass TrashCan<in T> { // etc... }\n\nGiven T as an “input” formal type parameter, then TrashCan is contravariant.\n\nIf neither in nor out appear, then the class is invariant on the parameter.\n\nIt’s easy to recall the “Variance rules of thumb” on page 551 when out and in are used in the formal type parameters.\n\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be:\n\nT_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True)\n\nThen we could define the classes like this:\n\nclass BeverageDispenser(Generic[T_out]): ...\n\nclass TrashCan(Generic[T_in]): ...\n\nIs it too late to change the naming convention established in PEP 484?\n\nFurther Reading\n\n|\n\n559\n\nCHAPTER 16 Operator Overloading\n\nThere are some things that I kind of feel torn about, like operator overloading. I left out operator overloading as a fairly personal choice because I had seen too many people abuse it in C++.\n\n—James Gosling, creator of Java1\n\nIn Python, you can compute compound interest using a formula written like this:\n\ninterest = principal * ((1 + rate) ** periods - 1)\n\nOperators that appear between operands, like 1 + rate, are infix operators. In Python, the infix operators can handle any arbitrary type. Thus, if you are dealing with real money, you can make sure that principal, rate, and periods are exact numbers—instances of the Python decimal.Decimal class—and that formula will work as written, producing an exact result.\n\nBut in Java, if you switch from float to BigDecimal to get exact results, you can’t use infix operators anymore, because they only work with the primitive types. This is the same formula coded to work with BigDecimal numbers in Java:\n\nBigDecimal interest = principal.multiply(BigDecimal.ONE.add(rate) .pow(periods).subtract(BigDecimal.ONE));\n\nIt’s clear that infix operators make formulas more readable. Operator overloading is necessary to support infix operator notation with user-defined or extension types, such as NumPy arrays. Having operator overloading in a high-level, easy-to-use lan‐ guage was probably a key reason for the huge success of Python in data science, including financial and scientific applications.\n\n1 Source: “The C Family of Languages: Interview with Dennis Ritchie, Bjarne Stroustrup, and James Gosling”.\n\n561\n\nIn “Emulating Numeric Types” on page 9 (Chapter 1) we saw some trivial implemen‐ tations of operators in a bare-bones Vector class. The __add__ and __mul__ methods in Example 1-2 were written to show how special methods support operator over‐ loading, but there are subtle problems in their implementations that we overlooked. Also, in Example 11-2, we noted that the Vector2d.__eq__ method considers this to be True: Vector(3, 4) == [3, 4]—which may or not make sense. We will address these matters in this chapter, as well as:\n\nHow an infix operator method should signal it cannot handle an operand\n\nUsing duck typing or goose typing to deal with operands of various types • The special behavior of the rich comparison operators (e.g., ==, >, <=, etc.) • The default handling of augmented assignment operators such as +=, and how to overload them\n\nWhat’s New in This Chapter Goose typing is a key part of Python, but the numbers ABCs are not supported in static typing, so I changed Example 16-11 to use duck typing instead of an explicit isinstance check against numbers.Real.2\n\nI covered the @ matrix multiplication operator in the first edition of Fluent Python as an upcoming change when 3.5 was still in alpha. Accordingly, that operator is no longer in a side note, but is integrated in the flow of the chapter in “Using @ as an Infix Operator” on page 574. I leveraged goose typing to make the implementation of __matmul__ safer than the one in the first edition, without compromising on flexibility.\n\n“Further Reading” on page 587 now has a couple of new references—including a blog post by Guido van Rossum. I also added mentions of two libraries that showcase effective use of operator overloading outside the domain of mathematics: pathlib and Scapy.\n\nOperator Overloading 101 Operator overloading allows user-defined objects to interoperate with infix operators such as + and |, or unary operators like - and ~. More generally, function invocation\n\n2 The remaining ABCs in Python’s standard library are still valuable for goose typing and static typing. The issue with the numbers ABCs is explained in “The numbers ABCs and Numeric Protocols” on page 478.\n\n562\n\n|\n\nChapter 16: Operator Overloading\n\n(()), attribute access (.), and item access/slicing ([]) are also operators in Python, but this chapter covers unary and infix operators.\n\nOperator overloading has a bad name in some circles. It is a language feature that can be (and has been) abused, resulting in programmer confusion, bugs, and unexpected performance bottlenecks. But if used well, it leads to pleasurable APIs and readable code. Python strikes a good balance among flexibility, usability, and safety by impos‐ ing some limitations:\n\nWe cannot change the meaning of the operators for the built-in types.\n\nWe cannot create new operators, only overload existing ones. • A few operators can’t be overloaded: is, and, or, not (but the bitwise &, |, ~, can).\n\nIn Chapter 12, we already had one infix operator in Vector: ==, supported by the __eq__ method. In this chapter, we’ll improve the implementation of __eq__ to better handle operands of types other than Vector. However, the rich comparison operators (==, !=, >, <, >=, <=) are special cases in operator overloading, so we’ll start by over‐ loading four arithmetic operators in Vector: the unary - and +, followed by the infix + and *.\n\nLet’s start with the easiest topic: unary operators.\n\nUnary Operators The Python Language Reference, “6.5. Unary arithmetic and bitwise operations” lists three unary operators, shown here with their associated special methods:\n\n, implemented by __neg__\n\nArithmetic unary negation. If x is -2 then -x == 2.\n\n+, implemented by __pos__\n\nArithmetic unary plus. Usually x == +x, but there are a few cases when that’s not true. See “When x and +x Are Not Equal” on page 565 if you’re curious.\n\n~, implemented by __invert__\n\nBitwise not, or bitwise inverse of an integer, defined as ~x == -(x+1). If x is 2 then ~x == -3.3\n\nThe “Data Model” chapter of The Python Language Reference also lists the abs() built-in function as a unary operator. The associated special method is __abs__, as we’ve seen before.\n\n3 See https://en.wikipedia.org/wiki/Bitwise_operation#NOT for an explanation of the bitwise not.\n\nUnary Operators\n\n|\n\n563\n\nIt’s easy to support the unary operators. Simply implement the appropriate special method, which will take just one argument: self. Use whatever logic makes sense in your class, but stick to the general rule of operators: always return a new object. In other words, do not modify the receiver (self), but create and return a new instance of a suitable type.\n\nIn the case of - and +, the result will probably be an instance of the same class as self. For unary +, if the receiver is immutable you should return self; otherwise, return a copy of self. For abs(), the result should be a scalar number.\n\nAs for ~, it’s difficult to say what would be a sensible result if you’re not dealing with bits in an integer. In the pandas data analysis package, the tilde negates boolean filter‐ ing conditions; see “Boolean indexing” in the pandas documentation for examples.\n\nAs promised before, we’ll implement several new operators on the Vector class from Chapter 12. Example 16-1 shows the __abs__ method we already had in Example 12-16, and the newly added __neg__ and __pos__ unary operator method.\n\nExample 16-1. vector_v6.py: unary operators - and + added to Example 12-16\n\ndef __abs__(self): return math.hypot(*self)\n\ndef __neg__(self): return Vector(-x for x in self)\n\ndef __pos__(self): return Vector(self)\n\nTo compute -v, build a new Vector with every component of self negated.\n\nTo compute +v, build a new Vector with every component of self.\n\nRecall that Vector instances are iterable, and the Vector.__init__ takes an iterable argument, so the implementations of __neg__ and __pos__ are short and sweet.\n\nWe’ll not implement __invert__, so if the user tries ~v on a Vector instance, Python will raise TypeError with a clear message: “bad operand type for unary ~: 'Vector'.”\n\nThe following sidebar covers a curiosity that may help you win a bet about unary + someday.\n\n564\n\n|\n\nChapter 16: Operator Overloading\n\nWhen x and +x Are Not Equal Everybody expects that x == +x, and that is true almost all the time in Python, but I found two cases in the standard library where x != +x.\n\nThe first case involves the decimal.Decimal class. You can have x != +x if x is a Decimal instance created in an arithmetic context and +x is then evaluated in a con‐ text with different settings. For example, x is calculated in a context with a certain precision, but the precision of the context is changed and then +x is evaluated. See Example 16-2 for a demonstration.\n\nExample 16-2. A change in the arithmetic context precision may cause x to differ from +x\n\n>>> import decimal >>> ctx = decimal.getcontext() >>> ctx.prec = 40 >>> one_third = decimal.Decimal('1') / decimal.Decimal('3') >>> one_third Decimal('0.3333333333333333333333333333333333333333') >>> one_third == +one_third True >>> ctx.prec = 28 >>> one_third == +one_third False >>> +one_third Decimal('0.3333333333333333333333333333')\n\nGet a reference to the current global arithmetic context.\n\nSet the precision of the arithmetic context to 40.\n\nCompute 1/3 using the current precision.\n\nInspect the result; there are 40 digits after the decimal point.\n\none_third == +one_third is True.\n\nLower precision to 28—the default for Decimal arithmetic.\n\nNow one_third == +one_third is False.\n\nInspect +one_third; there are 28 digits after the '.' here.\n\nUnary Operators\n\n|\n\n565\n\nThe fact is that each occurrence of the expression +one_third produces a new Deci mal instance from the value of one_third, but using the precision of the current arithmetic context.\n\nYou can find the second case where x != +x in the collections.Counter documen‐ tation. The Counter class implements several arithmetic operators, including infix + to add the tallies from two Counter instances. However, for practical reasons, Counter addition discards from the result any item with a negative or zero count. And the prefix + is a shortcut for adding an empty Counter, therefore it produces a new Counter, preserving only the tallies that are greater than zero. See Example 16-3.\n\nExample 16-3. Unary + produces a new Counter without zeroed or negative tallies\n\n>>> ct = Counter('abracadabra') >>> ct Counter({'a': 5, 'r': 2, 'b': 2, 'd': 1, 'c': 1}) >>> ct['r'] = -3 >>> ct['d'] = 0 >>> ct Counter({'a': 5, 'b': 2, 'c': 1, 'd': 0, 'r': -3}) >>> +ct Counter({'a': 5, 'b': 2, 'c': 1})\n\nAs you can see, +ct returns a counter where all tallies are greater than zero.\n\nNow, back to our regularly scheduled programming.\n\nOverloading + for Vector Addition The Vector class is a sequence type, and the section “3.3.6. Emulating container types” in the “Data Model” chapter of the official Python documentation says that sequences should support the + operator for concatenation and * for repetition. However, here we will implement + and * as mathematical vector operations, which are a bit harder but more meaningful for a Vector type.\n\nIf users want to concatenate or repeat Vector instances, they can convert them to tuples or lists, apply the operator, and convert back—thanks to the fact that Vector is iterable and can be con‐ structed from an iterable:\n\n>>> v_concatenated = Vector(list(v1) + list(v2)) >>> v_repeated = Vector(tuple(v1) * 5)\n\nAdding two Euclidean vectors results in a new vector in which the components are the pairwise additions of the components of the operands. To illustrate:\n\n566\n\n|\n\nChapter 16: Operator Overloading\n\n>>> v1 = Vector([3, 4, 5]) >>> v2 = Vector([6, 7, 8]) >>> v1 + v2 Vector([9.0, 11.0, 13.0]) >>> v1 + v2 == Vector([3 + 6, 4 + 7, 5 + 8]) True\n\nWhat happens if we try to add two Vector instances of different lengths? We could raise an error, but considering practical applications (such as information retrieval), it’s better to fill out the shortest Vector with zeros. This is the result we want:\n\n>>> v1 = Vector([3, 4, 5, 6]) >>> v3 = Vector([1, 2]) >>> v1 + v3 Vector([4.0, 6.0, 5.0, 6.0])\n\nGiven these basic requirements, we can implement __add__ like in Example 16-4.\n\nExample 16-4. Vector.__add__ method, take #1\n\n# inside the Vector class\n\ndef __add__(self, other): pairs = itertools.zip_longest(self, other, fillvalue=0.0) return Vector(a + b for a, b in pairs)\n\npairs is a generator that produces tuples (a, b), where a is from self, and b is from other. If self and other have different lengths, fillvalue supplies the missing values for the shortest iterable.\n\nA new Vector is built from a generator expression, producing one addition for each (a, b) from pairs.\n\nNote how __add__ returns a new Vector instance, and does not change self or other.\n\nSpecial methods implementing unary or infix operators should never change the value of the operands. Expressions with such operators are expected to produce results by creating new objects. Only augmented assignment operators may change the first operand (self), as discussed in “Augmented Assignment Opera‐ tors” on page 580.\n\nExample 16-4 allows adding Vector to a Vector2d, and Vector to a tuple or to any iterable that produces numbers, as Example 16-5 proves.\n\nOverloading + for Vector Addition\n\n|\n\n567\n\nExample 16-5. Vector.__add__ take #1 supports non-Vector objects, too\n\n>>> v1 = Vector([3, 4, 5]) >>> v1 + (10, 20, 30) Vector([13.0, 24.0, 35.0]) >>> from vector2d_v3 import Vector2d >>> v2d = Vector2d(1, 2) >>> v1 + v2d Vector([4.0, 6.0, 5.0])\n\nBoth uses of + in Example 16-5 work because __add__ uses zip_longest(…), which can consume any iterable, and the generator expression to build the new Vector merely performs a + b with the pairs produced by zip_longest(…), so an iterable producing any number items will do.\n\nHowever, if we swap the operands (Example 16-6), the mixed-type additions fail.\n\nExample 16-6. Vector.__add__ take #1 fails with non-Vector left operands\n\n>>> v1 = Vector([3, 4, 5]) >>> (10, 20, 30) + v1 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can only concatenate tuple (not \"Vector\") to tuple >>> from vector2d_v3 import Vector2d >>> v2d = Vector2d(1, 2) >>> v2d + v1 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: unsupported operand type(s) for +: 'Vector2d' and 'Vector'\n\nTo support operations involving objects of different types, Python implements a spe‐ cial dispatching mechanism for the infix operator special methods. Given an expres‐ sion a + b, the interpreter will perform these steps (also see Figure 16-1):\n\n1. If a has __add__, call a.__add__(b) and return result unless it’s NotImplemented. 2. If a doesn’t have __add__, or calling it returns NotImplemented, check if b has __radd__, then call b.__radd__(a) and return result unless it’s NotImplemented. 3. If b doesn’t have __radd__, or calling it returns NotImplemented, raise TypeError with an unsupported operand types message.\n\n568\n\n|\n\nChapter 16: Operator Overloading\n\nThe __radd__ method is called the “reflected” or “reversed” ver‐ sion of __add__. I prefer to call them “reversed” special methods.4\n\nFigure 16-1. Flowchart for computing a + b with __add__ and __radd__.\n\nTherefore, to make the mixed-type additions in Example 16-6 work, we need to implement the Vector.__radd__ method, which Python will invoke as a fallback if the left operand does not implement __add__, or if it does but returns NotImplemen ted to signal that it doesn’t know how to handle the right operand.\n\n4 The Python documentation uses both terms. The “Data Model” chapter uses “reflected,” but “9.1.2.2. Imple‐ menting the arithmetic operations” in the numbers module docs mention “forward” and “reverse” methods, and I find this terminology better, because “forward” and “reversed” clearly name each of the directions, while “reflected” doesn’t have an obvious opposite.\n\nOverloading + for Vector Addition\n\n|\n\n569\n\nDo not confuse NotImplemented with NotImplementedError. The first, NotImplemented, is a special singleton value that an infix operator special method should return to tell the interpreter it cannot handle a given operand. In contrast, NotImplementedError is an exception that stub methods in abstract classes may raise to warn that subclasses must implement them.\n\nThe simplest implementation of __radd__ that works is shown in Example 16-7.\n\nExample 16-7. The Vector methods __add__ and __radd__\n\n# inside the Vector class\n\ndef __add__(self, other): pairs = itertools.zip_longest(self, other, fillvalue=0.0) return Vector(a + b for a, b in pairs)\n\ndef __radd__(self, other): return self + other\n\nNo changes to __add__ from Example 16-4; listed here because __radd__ uses it.\n\n__radd__ just delegates to __add__.\n\nOften, __radd__ can be as simple as that: just invoke the proper operator, therefore delegating to __add__ in this case. This applies to any commutative operator; + is commutative when dealing with numbers or our vectors, but it’s not commutative when concatenating sequences in Python.\n\nIf __radd__ simply calls __add__, here is another way to achieve the same effect:\n\ndef __add__(self, other): pairs = itertools.zip_longest(self, other, fillvalue=0.0) return Vector(a + b for a, b in pairs)\n\n__radd__ = __add__\n\nThe methods in Example 16-7 work with Vector objects, or any iterable with numeric items, such as a Vector2d, a tuple of integers, or an array of floats. But if provided with a noniterable object, __add__ raises an exception with a message that is not very helpful, as in Example 16-8.\n\nExample 16-8. Vector.__add__ method needs an iterable operand\n\n>>> v1 + 1 Traceback (most recent call last): File \"<stdin>\", line 1, in <module>\n\n570\n\n|\n\nChapter 16: Operator Overloading\n\nFile \"vector_v6.py\", line 328, in __add__ pairs = itertools.zip_longest(self, other, fillvalue=0.0) TypeError: zip_longest argument #2 must support iteration\n\nEven worse, we get a misleading message if an operand is iterable but its items cannot be added to the float items in the Vector. See Example 16-9.\n\nExample 16-9. Vector.__add__ method needs an iterable with numeric items\n\n>>> v1 + 'ABC' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"vector_v6.py\", line 329, in __add__ return Vector(a + b for a, b in pairs) File \"vector_v6.py\", line 243, in __init__ self._components = array(self.typecode, components) File \"vector_v6.py\", line 329, in <genexpr> return Vector(a + b for a, b in pairs) TypeError: unsupported operand type(s) for +: 'float' and 'str'\n\nI tried to add Vector and a str, but the message complains about float and str.\n\nThe problems in Examples 16-8 and 16-9 actually go deeper than obscure error mes‐ sages: if an operator special method cannot return a valid result because of type incompatibility, it should return NotImplemented and not raise TypeError. By returning NotImplemented, you leave the door open for the implementer of the other operand type to perform the operation when Python tries the reversed method call.\n\nIn the spirit of duck typing, we will refrain from testing the type of the other operand, or the type of its elements. We’ll catch the exceptions and return NotImple mented. If the interpreter has not yet reversed the operands, it will try that. If the reverse method call returns NotImplemented, then Python will raise TypeError with a standard error message like “unsupported operand type(s) for +: Vector and str.”\n\nThe final implementation of the special methods for Vector addition is in Example 16-10.\n\nExample 16-10. vector_v6.py: operator + methods added to vector_v5.py (Example 12-16)\n\ndef __add__(self, other): try: pairs = itertools.zip_longest(self, other, fillvalue=0.0) return Vector(a + b for a, b in pairs) except TypeError: return NotImplemented\n\nOverloading + for Vector Addition\n\n|\n\n571\n\ndef __radd__(self, other): return self + other\n\nNote that __add__ now catches a TypeError and returns NotImplemented.\n\nIf an infix operator method raises an exception, it aborts the opera‐ tor dispatch algorithm. In the particular case of TypeError, it is often better to catch it and return NotImplemented. This allows the interpreter to try calling the reversed operator method, which may correctly handle the computation with the swapped operands, if they are of different types.\n\nAt this point, we have safely overloaded the + operator by writing __add__ and __radd__. We will now tackle another infix operator: *.\n\nOverloading * for Scalar Multiplication What does Vector([1, 2, 3]) * x mean? If x is a number, that would be a scalar product, and the result would be a new Vector with each component multiplied by x —also known as an elementwise multiplication:\n\n>>> v1 = Vector([1, 2, 3]) >>> v1 * 10 Vector([10.0, 20.0, 30.0]) >>> 11 * v1 Vector([11.0, 22.0, 33.0])\n\nAnother kind of product involving Vector operands would be the dot product of two vectors—or matrix multiplication, if you take one vector as a 1 × N matrix and the other as an N × 1 matrix. We will implement that operator in our Vector class in “Using @ as an Infix Operator” on page 574.\n\nBack to our scalar product, again we start with the simplest __mul__ and __rmul__ methods that could possibly work:\n\n# inside the Vector class\n\ndef __mul__(self, scalar): return Vector(n * scalar for n in self)\n\ndef __rmul__(self, scalar): return self * scalar\n\nThose methods do work, except when provided with incompatible operands. The scalar argument has to be a number that when multiplied by a float produces\n\n572\n\n|\n\nChapter 16: Operator Overloading\n\nanother float (because our Vector class uses an array of floats internally). So a com plex number will not do, but the scalar can be an int, a bool (because bool is a sub‐ class of int), or even a fractions.Fraction instance. In Example 16-11, the __mul__ method does not make an explicit type check on scalar, but instead converts it into a float, and returns NotImplemented if that fails. That’s a clear example of duck typing.\n\nExample 16-11. vector_v7.py: operator * methods added\n\nclass Vector: typecode = 'd'\n\ndef __init__(self, components): self._components = array(self.typecode, components)\n\n# many methods omitted in book listing, see vector_v7.py # in https://github.com/fluentpython/example-code-2e\n\ndef __mul__(self, scalar): try: factor = float(scalar) except TypeError: return NotImplemented return Vector(n * factor for n in self)\n\ndef __rmul__(self, scalar): return self * scalar\n\nIf scalar cannot be converted to float…\n\n…we don’t know how to handle it, so we return NotImplemented to let Python try __rmul__ on the scalar operand.\n\nIn this example, __rmul__ works fine by just performing self * scalar, dele‐ gating to the __mul__ method.\n\nWith Example 16-11, we can multiply Vectors by scalar values of the usual, and not so usual, numeric types:\n\n>>> v1 = Vector([1.0, 2.0, 3.0]) >>> 14 * v1 Vector([14.0, 28.0, 42.0]) >>> v1 * True Vector([1.0, 2.0, 3.0]) >>> from fractions import Fraction >>> v1 * Fraction(1, 3) Vector([0.3333333333333333, 0.6666666666666666, 1.0])\n\nOverloading * for Scalar Multiplication\n\n|\n\n573\n\nNow that we can multiply Vector by scalars, let’s see how to implement Vector by Vector products.\n\nIn the first edition of Fluent Python, I used goose typing in Example 16-11: I checked the scalar argument of __mul__ with isinstance(scalar, numbers.Real). Now I avoid using the num bers ABCs because they are not supported by PEP 484, and using types at runtime that cannot also be statically checked seems a bad idea to me. Alternatively, I could have checked against the typing.Supports Float protocol that we saw in “Runtime Checkable Static Proto‐ cols” on page 468. I chose duck typing in that example because I think fluent Pythonistas should be comfortable with that coding pattern. On the other hand, __matmul__ in Example 16-12 is a good exam‐ ple of goose typing, new in this second edition.\n\nUsing @ as an Infix Operator The @ sign is well-known as the prefix of function decorators, but since 2015, it can also be used as an infix operator. For years, the dot product was written as numpy.dot(a, b) in NumPy. The function call notation makes longer formulas harder to translate from mathematical notation to Python,5 so the numerical comput‐ ing community lobbied for PEP 465—A dedicated infix operator for matrix multipli‐ cation, which was implemented in Python 3.5. Today, you can write a @ b to compute the dot product of two NumPy arrays.\n\nThe @ operator is supported by the special methods __matmul__, __rmatmul__, and __imatmul__, named for “matrix multiplication.” These methods are not used any‐ where in the standard library at this time, but are recognized by the interpreter since Python 3.5, so the NumPy team—and the rest of us—can support the @ operator in user-defined types. The parser was also changed to handle the new operator (a @ b was a syntax error in Python 3.4).\n\nThese simple tests show how @ should work with Vector instances:\n\n>>> va = Vector([1, 2, 3]) >>> vz = Vector([5, 6, 7]) >>> va @ vz == 38.0 # 1*5 + 2*6 + 3*7 True >>> [10, 20, 30] @ vz\n\n5 See “Soapbox” on page 588 for a discussion of the problem.\n\n574\n\n|\n\nChapter 16: Operator Overloading\n\n380.0 >>> va @ 3 Traceback (most recent call last): ... TypeError: unsupported operand type(s) for @: 'Vector' and 'int'\n\nExample 16-12 shows the code of the relevant special methods.\n\nExample 16-12. vector_v7.py: operator @ methods\n\nclass Vector: # many methods omitted in book listing\n\ndef __matmul__(self, other): if (isinstance(other, abc.Sized) and isinstance(other, abc.Iterable)): if len(self) == len(other): return sum(a * b for a, b in zip(self, other)) else: raise ValueError('@ requires vectors of equal length.') else: return NotImplemented\n\ndef __rmatmul__(self, other): return self @ other\n\nBoth operands must implement __len__ and __iter__…\n\n…and have the same length to allow…\n\n…a beautiful application of sum, zip, and generator expression.\n\nNew zip() Feature in Python 3.10\n\nThe zip built-in accepts a strict keyword-only optional argument since Python 3.10. When strict=True, the function raises ValueEr ror when the iterables have different lengths. The default is False. This new strict behavior is in line with Python’s fail fast philoso‐ phy. In Example 16-12, I’d replace the inner if with a try/except ValueError and add strict=True to the zip call.\n\nExample 16-12 is a good example of goose typing in practice. If we tested the other operand against Vector, we’d deny users the flexibility of using lists or arrays as operands to @. As long as one operand is a Vector, our @ implementation supports other operands that are instances of abc.Sized and abc.Iterable. Both of these ABCs implement the __subclasshook__, therefore any object providing __len__ and __iter__ satisfies our test—no need to actually subclass those ABCs or even register\n\nUsing @ as an Infix Operator\n\n|\n\n575",
      "page_number": 576
    },
    {
      "number": 30,
      "title": "Segment 30 (pages 596-614)",
      "start_page": 596,
      "end_page": 614,
      "detection_method": "synthetic",
      "content": "with them, as explained in “Structural Typing with ABCs” on page 464. In particular, our Vector class does not subclass either abc.Sized or abc.Iterable, but it does pass the isinstance checks against those ABCs because it has the necessary methods.\n\nLet’s review the arithmetic operators supported by Python, before diving into the special category of “Rich Comparison Operators” on page 577.\n\nWrapping-Up Arithmetic Operators Implementing +, *, and @, we saw the most common patterns for coding infix opera‐ tors. The techniques we described are applicable to all operators listed in Table 16-1 (the in-place operators will be covered in “Augmented Assignment Operators” on page 580).\n\nTable 16-1. Infix operator method names (the in-place operators are used for augmented assignment; comparison operators are in Table 16-2)\n\nOperator\n\n+\n\nForward\n\n__add__\n\nReverse\n\n__radd__\n\nIn-place\n\n__iadd__\n\nDescription Addition or concatenation\n\n\n\n__sub__\n\n__rsub__\n\n__isub__\n\nSubtraction\n\n\n\n__mul__\n\n__rmul__\n\n__imul__\n\nMultiplication or repetition\n\n/\n\n__truediv__\n\n__rtruediv__\n\n__itruediv__\n\nTrue division\n\n//\n\n__floordiv__\n\n__rfloordiv__\n\n__ifloordiv__\n\nFloor division\n\n%\n\n__mod__\n\n__rmod__\n\n__imod__\n\nModulo\n\ndivmod()\n\n**, pow()\n\n__divmod__\n\n__pow__\n\n__rdivmod__\n\n__rpow__\n\n__idivmod__\n\n__ipow__\n\nReturns tuple of floor division quotient and modulo Exponentiationa\n\n@\n\n__matmul__\n\n__rmatmul__\n\n__imatmul__\n\nMatrix multiplication\n\n&\n\n__and__\n\n__rand__\n\n__iand__\n\nBitwise and\n\n|\n\n__or__\n\n__ror__\n\n__ior__\n\nBitwise or\n\n^\n\n__xor__\n\n__rxor__\n\n__ixor__\n\nBitwise xor\n\n<<\n\n__lshift__\n\n__rlshift__\n\n__ilshift__\n\nBitwise shift left\n\n>>\n\n__rshift__\n\n__rrshift__\n\n__irshift__\n\nBitwise shift right\n\na pow takes an optional third argument, modulo: pow(a, b, modulo), also supported by the special methods when invoked directly (e.g., a.__pow__(b, modulo)).\n\nThe rich comparison operators use a different set of rules.\n\n576\n\n|\n\nChapter 16: Operator Overloading\n\nRich Comparison Operators The handling of the rich comparison operators ==, !=, >, <, >=, and <= by the Python interpreter is similar to what we just saw, but differs in two important aspects:\n\nThe same set of methods is used in forward and reverse operator calls. The rules are summarized in Table 16-2. For example, in the case of ==, both the forward and reverse calls invoke __eq__, only swapping arguments; and a forward call to __gt__ is followed by a reverse call to __lt__ with the arguments swapped.\n\nIn the case of == and !=, if the reverse method is missing, or returns NotImplemen ted, Python compares the object IDs instead of raising TypeError.\n\nTable 16-2. Rich comparison operators: reverse methods invoked when the initial method call returns NotImplemented\n\nGroup Equality\n\nInfix operator\n\na == b\n\nForward method call Reverse method call\n\na.__eq__(b)\n\nb.__eq__(a)\n\nFallback Return id(a) == id(b)\n\na != b\n\na.__ne__(b)\n\nb.__ne__(a)\n\nReturn not (a == b)\n\nOrdering a > b\n\na.__gt__(b)\n\nb.__lt__(a)\n\nRaise TypeError\n\na < b\n\na.__lt__(b)\n\nb.__gt__(a)\n\nRaise TypeError\n\na >= b\n\na.__ge__(b)\n\nb.__le__(a)\n\nRaise TypeError\n\na <= b\n\na.__le__(b)\n\nb.__ge__(a)\n\nRaise TypeError\n\nGiven these rules, let’s review and improve the behavior of the Vector.__eq__ method, which was coded as follows in vector_v5.py (Example 12-16):\n\nclass Vector: # many lines omitted\n\ndef __eq__(self, other): return (len(self) == len(other) and all(a == b for a, b in zip(self, other)))\n\nThat method produces the results in Example 16-13.\n\nExample 16-13. Comparing a Vector to a Vector, a Vector2d, and a tuple\n\n>>> va = Vector([1.0, 2.0, 3.0]) >>> vb = Vector(range(1, 4)) >>> va == vb True >>> vc = Vector([1, 2]) >>> from vector2d_v3 import Vector2d >>> v2d = Vector2d(1, 2) >>> vc == v2d\n\nRich Comparison Operators\n\n|\n\n577\n\nTrue >>> t3 = (1, 2, 3) >>> va == t3 True\n\nTwo Vector instances with equal numeric components compare equal.\n\nA Vector and a Vector2d are also equal if their components are equal.\n\nA Vector is also considered equal to a tuple or any iterable with numeric items of equal value.\n\nThe result in Example 16-13 is probably not desirable. Do we really want a Vector to be considered equal to a tuple containing the same numbers? I have no hard rule about this; it depends on the application context. The “Zen of Python” says:\n\nIn the face of ambiguity, refuse the temptation to guess.\n\nExcessive liberality in the evaluation of operands may lead to surprising results, and programmers hate surprises.\n\nTaking a clue from Python itself, we can see that [1,2] == (1, 2) is False. There‐ fore, let’s be conservative and do some type checking. If the second operand is a Vector instance (or an instance of a Vector subclass), then use the same logic as the current __eq__. Otherwise, return NotImplemented and let Python handle that. See Example 16-14.\n\nExample 16-14. vector_v8.py: improved __eq__ in the Vector class\n\ndef __eq__(self, other): if isinstance(other, Vector): return (len(self) == len(other) and all(a == b for a, b in zip(self, other))) else: return NotImplemented\n\nIf the other operand is an instance of Vector (or of a Vector subclass), perform the comparison as before.\n\nOtherwise, return NotImplemented.\n\nIf you run the tests in Example 16-13 with the new Vector.__eq__ from Example 16-14, what you get now is shown in Example 16-15.\n\n578\n\n|\n\nChapter 16: Operator Overloading\n\nExample 16-15. Same comparisons as Example 16-13: last result changed\n\n>>> va = Vector([1.0, 2.0, 3.0]) >>> vb = Vector(range(1, 4)) >>> va == vb True >>> vc = Vector([1, 2]) >>> from vector2d_v3 import Vector2d >>> v2d = Vector2d(1, 2) >>> vc == v2d True >>> t3 = (1, 2, 3) >>> va == t3 False\n\nSame result as before, as expected.\n\nSame result as before, but why? Explanation coming up.\n\nDifferent result; this is what we wanted. But why does it work? Read on…\n\nAmong the three results in Example 16-15, the first one is no news, but the last two were caused by __eq__ returning NotImplemented in Example 16-14. Here is what happens in the example with a Vector and a Vector2d, vc == v2d, step-by-step:\n\n1. To evaluate vc == v2d, Python calls Vector.__eq__(vc, v2d). 2. Vector.__eq__(vc, v2d) verifies that v2d is not a Vector and returns NotImplemented.\n\n3. Python gets the NotImplemented result, so it tries Vector2d.__eq__(v2d, vc). 4. Vector2d.__eq__(v2d, vc) turns both operands into tuples and compares them: the result is True (the code for Vector2d.__eq__ is in Example 11-11).\n\nAs for the comparison va == t3, between Vector and tuple in Example 16-15, the actual steps are:\n\n1. To evaluate va == t3, Python calls Vector.__eq__(va, t3). 2. Vector.__eq__(va, t3) verifies that t3 NotImplemented.\n\n1. To evaluate va == t3, Python calls Vector.__eq__(va, t3). 2. Vector.__eq__(va, t3) verifies that t3 NotImplemented.\n\n3. Python gets the NotImplemented result, so it tries tuple.__eq__(t3, va).\n\nRich Comparison Operators\n\n|\n\n579\n\n4. tuple.__eq__(t3, va) has no NotImplemented.\n\n4. tuple.__eq__(t3, va) has no NotImplemented.\n\nidea what a Vector\n\nis, so\n\n5. In the special case of ==, if the reversed call returns NotImplemented, Python compares object IDs as a last resort.\n\nWe don’t need to implement __ne__ for != because the fallback behavior of __ne__ inherited from object suits us: when __eq__ is defined and does not return NotImple mented, __ne__ returns that result negated.\n\nIn other words, given the same objects we used in Example 16-15, the results for != are consistent:\n\n>>> va != vb False >>> vc != v2d False >>> va != (1, 2, 3) True\n\nThe __ne__ inherited from object works like the following code—except that the original is written in C:6\n\ndef __ne__(self, other): eq_result = self == other if eq_result is NotImplemented: return NotImplemented else: return not eq_result\n\nAfter covering the essentials of infix operator overloading, let’s turn to a different class of operators: the augmented assignment operators.\n\nAugmented Assignment Operators Our Vector class already supports the augmented assignment operators += and *=. That’s because augmented assignment works with immutable receivers by creating new instances and rebinding the lefthand variable.\n\nExample 16-16 shows them in action.\n\nExample 16-16. Using += and *= with Vector instances\n\n>>> v1 = Vector([1, 2, 3]) >>> v1_alias = v1\n\n6 The logic for object.__eq__ and object.__ne__ is in function object_richcompare in Objects/typeobject.c\n\nin the CPython source code.\n\n580\n\n|\n\nChapter 16: Operator Overloading\n\n>>> id(v1) 4302860128 >>> v1 += Vector([4, 5, 6]) >>> v1 Vector([5.0, 7.0, 9.0]) >>> id(v1) 4302859904 >>> v1_alias Vector([1.0, 2.0, 3.0]) >>> v1 *= 11 >>> v1 Vector([55.0, 77.0, 99.0]) >>> id(v1) 4302858336\n\nCreate an alias so we can inspect the Vector([1, 2, 3]) object later.\n\nRemember the ID of the initial Vector bound to v1.\n\nPerform augmented addition.\n\nThe expected result…\n\n…but a new Vector was created.\n\nInspect v1_alias to confirm the original Vector was not altered.\n\nPerform augmented multiplication.\n\nAgain, the expected result, but a new Vector was created.\n\nIf a class does not implement the in-place operators listed in Table 16-1, the augmen‐ ted assignment operators work as syntactic sugar: a += b is evaluated exactly as a = a + b. That’s the expected behavior for immutable types, and if you have __add__, then += will work with no additional code.\n\nHowever, if you do implement an in-place operator method such as __iadd__, that method is called to compute the result of a += b. As the name says, those operators are expected to change the lefthand operand in place, and not create a new object as the result.\n\nThe in-place special methods should never be implemented for immutable types like our Vector class. This is fairly obvious, but worth stating anyway.\n\nAugmented Assignment Operators\n\n|\n\n581\n\nTo show the code of an in-place operator, we will extend the BingoCage class from Example 13-9 to implement __add__ and __iadd__.\n\nWe’ll call the subclass AddableBingoCage. Example 16-17 is the behavior we want for the + operator.\n\nExample 16-17. The + operator creates a new AddableBingoCage instance\n\n>>> vowels = 'AEIOU' >>> globe = AddableBingoCage(vowels) >>> globe.inspect() ('A', 'E', 'I', 'O', 'U') >>> globe.pick() in vowels True >>> len(globe.inspect()) 4 >>> globe2 = AddableBingoCage('XYZ') >>> globe3 = globe + globe2 >>> len(globe3.inspect()) 7 >>> void = globe + [10, 20] Traceback (most recent call last): ... TypeError: unsupported operand type(s) for +: 'AddableBingoCage' and 'list'\n\nCreate a globe instance with five items (each of the vowels).\n\nPop one of the items, and verify it is one of the vowels.\n\nConfirm that the globe is down to four items.\n\nCreate a second instance, with three items.\n\nCreate a third instance by adding the previous two. This instance has seven items.\n\nAttempting to add an AddableBingoCage to a list fails with TypeError. That error message is produced by the Python interpreter when our __add__ method returns NotImplemented.\n\nBecause an AddableBingoCage is mutable, Example 16-18 shows how it will work when we implement __iadd__.\n\n582\n\n|\n\nChapter 16: Operator Overloading\n\nExample 16-18. An existing AddableBingoCage can be loaded with += (continuing from Example 16-17)\n\n>>> globe_orig = globe >>> len(globe.inspect()) 4 >>> globe += globe2 >>> len(globe.inspect()) 7 >>> globe += ['M', 'N'] >>> len(globe.inspect()) 9 >>> globe is globe_orig True >>> globe += 1 Traceback (most recent call last): ... TypeError: right operand in += must be 'Tombola' or an iterable\n\nCreate an alias so we can check the identity of the object later.\n\nglobe has four items here.\n\nAn AddableBingoCage instance can receive items from another instance of the same class.\n\nThe righthand operand of += can also be any iterable.\n\nThroughout this example, globe has always referred to the same object as globe_orig.\n\nTrying to add a noniterable to an AddableBingoCage fails with a proper error message.\n\nNote that the += operator is more liberal than + with regard to the second operand. With +, we want both operands to be of the same type (AddableBingoCage, in this case), because if we accepted different types, this might cause confusion as to the type of the result. With the +=, the situation is clearer: the lefthand object is updated in place, so there’s no doubt about the type of the result.\n\nI validated the contrasting behavior of + and += by observing how the list built-in type works. Writing my_list + x, you can only concatenate one list to another list, but if you write my_list += x, you can extend the lefthand list with items from any iterable x on the righthand side. This is how the list.extend() method works: it accepts any iterable argument.\n\nAugmented Assignment Operators\n\n|\n\n583\n\nNow that we are clear on the desired behavior for AddableBingoCage, we can look at its implementation in Example 16-19. Recall that BingoCage, from Example 13-9, is a concrete subclass of the Tombola ABC from Example 13-7.\n\nExample 16-19. bingoaddable.py: AddableBingoCage extends BingoCage to support + and +=\n\nfrom tombola import Tombola from bingo import BingoCage\n\nclass AddableBingoCage(BingoCage):\n\ndef __add__(self, other): if isinstance(other, Tombola): return AddableBingoCage(self.inspect() + other.inspect()) else: return NotImplemented\n\ndef __iadd__(self, other): if isinstance(other, Tombola): other_iterable = other.inspect() else: try: other_iterable = iter(other) except TypeError: msg = ('right operand in += must be ' \"'Tombola' or an iterable\") raise TypeError(msg) self.load(other_iterable) return self\n\nAddableBingoCage extends BingoCage.\n\nOur __add__ will only work with an instance of Tombola as the second operand.\n\nIn __iadd__, retrieve items from other, if it is an instance of Tombola.\n\nOtherwise, try to obtain an iterator over other.7\n\nIf that fails, raise an exception explaining what the user should do. When possi‐ ble, error messages should explicitly guide the user to the solution.\n\n7 The iter built-in function will be covered in the next chapter. Here I could have used tuple(other), and it would work, but at the cost of building a new tuple when all the .load(…) method needs is to iterate over its argument.\n\n584\n\n|\n\nChapter 16: Operator Overloading\n\nIf we got this far, we can load the other_iterable into self.\n\nVery important: augmented assignment special methods of mutable objects must return self. That’s what users expect.\n\nWe can summarize the whole idea of in-place operators by contrasting the return statements that produce results in __add__ and __iadd__ in Example 16-19:\n\n__add__\n\nThe result is produced by calling the constructor AddableBingoCage to build a new instance.\n\n__iadd__\n\nThe result is produced by returning self, after it has been modified.\n\nTo wrap up this example, a final observation on Example 16-19: by design, no __radd__ was coded in AddableBingoCage, because there is no need for it. The for‐ ward method __add__ will only deal with righthand operands of the same type, so if Python is trying to compute a + b, where a is an AddableBingoCage and b is not, we return NotImplemented—maybe the class of b can make it work. But if the expression is b + a and b is not an AddableBingoCage, and it returns NotImplemented, then it’s better to let Python give up and raise TypeError because we cannot handle b.\n\nIn general, if a forward infix operator method (e.g., __mul__) is designed to work only with operands of the same type as self, it’s useless to implement the corresponding reverse method (e.g., __rmul__) because that, by definition, will only be invoked when dealing with an operand of a different type.\n\nThis concludes our exploration of operator overloading in Python.\n\nChapter Summary We started this chapter by reviewing some restrictions Python imposes on operator overloading: no redefining of operators in the built-in types themselves, overloading limited to existing operators, with a few operators left out (is, and, or, not).\n\nWe got down to business with the unary operators, implementing __neg__ and __pos__. Next came the infix operators, starting with +, supported by the __add__ method. We saw that unary and infix operators are supposed to produce results by creating new objects, and should never change their operands. To support operations with other types, we return the NotImplemented special value—not an exception— allowing the interpreter to try again by swapping the operands and calling the reverse\n\nChapter Summary\n\n|\n\n585\n\nspecial method for that operator (e.g., __radd__). The algorithm Python uses to han‐ dle infix operators is summarized in the flowchart in Figure 16-1.\n\nMixing operand types requires detecting operands we can’t handle. In this chapter, we did this in two ways: in the duck typing way, we just went ahead and tried the operation, catching a TypeError exception if it happened; later, in __mul__ and __matmul__, we did it with an explicit isinstance test. There are pros and cons to these approaches: duck typing is more flexible, but explicit type checking is more predictable.\n\nIn general, libraries should leverage duck typing—opening the door for objects regardless of their types, as long as they support the necessary operations. However, Python’s operator dispatch algorithm may produce misleading error messages or unexpected results when combined with duck typing. For this reason, the discipline of type checking using isinstance calls against ABCs is often useful when writing special methods for operator overloading. That’s the technique dubbed goose typing by Alex Martelli—which we saw in “Goose Typing” on page 442. Goose typing is a good compromise between flexibility and safety, because existing or future user- defined types can be declared as actual or virtual subclasses of an ABC. In addition, if an ABC implements the __subclasshook__, then objects pass isinstance checks against that ABC by providing the required methods—no subclassing or registration required.\n\nThe next topic we covered was the rich comparison operators. We implemented == with __eq__ and discovered that Python provides a handy implementation of != in the __ne__ inherited from the object base class. The way Python evaluates these operators along with >, <, >=, and <= is slightly different, with special logic for choos‐ ing the reverse method, and fallback handling for == and !=, which never generate errors because Python compares the object IDs as a last resort.\n\nIn the last section, we focused on augmented assignment operators. We saw that Python handles them by default as a combination of plain operator followed by assignment, that is: a += b is evaluated exactly as a = a + b. That always creates a new object, so it works for mutable or immutable types. For mutable objects, we can implement in-place special methods such as __iadd__ for +=, and alter the value of the lefthand operand. To show this at work, we left behind the immutable Vector class and worked on implementing a BingoCage subclass to support += for adding items to the random pool, similar to the way the list built-in supports += as a short‐ cut for the list.extend() method. While doing this, we discussed how + tends to be stricter than += regarding the types it accepts. For sequence types, + usually requires that both operands are of the same type, while += often accepts any iterable as the righthand operand.\n\n586\n\n|\n\nChapter 16: Operator Overloading\n\nFurther Reading Guido van Rossum wrote a good defense of operator overloading in “Why operators are useful”. Trey Hunner blogged “Tuple ordering and deep comparisons in Python”, arguing that the rich comparison operators in Python are more flexible and powerful than programmers may realize when coming from other languages.\n\nOperator overloading is one area of Python programming where isinstance tests are common. The best practice around such tests is goose typing, covered in “Goose Typ‐ ing” on page 442. If you skipped that, make sure to read it.\n\nThe main reference for the operator special methods is the “Data Model” chapter of the Python documentation. Another relevant reading is “9.1.2.2. Implementing the arithmetic operations” in the numbers module of The Python Standard Library.\n\nA clever example of operator overloading appeared in the pathlib package, added in Python 3.4. Its Path class overloads the / operator to build filesystem paths from strings, as shown in this example from the documentation:\n\n>>> p = Path('/etc') >>> q = p / 'init.d' / 'reboot' >>> q PosixPath('/etc/init.d/reboot')\n\nAnother nonarithmetic example of operator overloading is in the Scapy library, used to “send, sniff, dissect, and forge network packets.” In Scapy, the / operator builds packets by stacking fields from different network layers. See “Stacking layers” for details.\n\nIf you are about to implement comparison operators, study functools.total_order ing. That is a class decorator that automatically generates methods for all rich com‐ parison operators in any class that defines at least a couple of them. See the functools module docs.\n\nIf you are curious about operator method dispatching in languages with dynamic typing, two seminal readings are “A Simple Technique for Handling Multiple Poly‐ morphism” by Dan Ingalls (member of the original Smalltalk team), and “Arithmetic and Double Dispatching in Smalltalk-80” by Kurt J. Hebel and Ralph Johnson (John‐ son became famous as one of the authors of the original Design Patterns book). Both papers provide deep insight into the power of polymorphism in languages with dynamic typing, like Smalltalk, Python, and Ruby. Python does not use double dis‐ patching for handling operators as described in those articles. The Python algorithm using forward and reverse operators is easier for user-defined classes to support than double dispatching, but requires special handling by the interpreter. In contrast, classic double dispatching is a general technique you can use in Python or any\n\nFurther Reading\n\n|\n\n587\n\nobject-oriented language beyond the specific context of infix operators, and in fact Ingalls, Hebel, and Johnson use very different examples to describe it.\n\nThe article, “The C Family of Languages: Interview with Dennis Ritchie, Bjarne Stroustrup, and James Gosling”, from which I quoted the epigraph for this chapter, appeared in Java Report, 5(7), July 2000, and C++ Report, 12(7), July/August 2000, along with two other snippets I used in this chapter’s “Soapbox” (next). If you are into programming language design, do yourself a favor and read that interview.\n\nSoapbox\n\nOperator Overloading: Pros and Cons\n\nJames Gosling, quoted at the start of this chapter, made the conscious decision to leave operator overloading out when he designed Java. In that same interview (“The C Family of Languages: Interview with Dennis Ritchie, Bjarne Stroustrup, and James Gosling”) he says:\n\nProbably about 20 to 30 percent of the population think of operator overloading as the spawn of the devil; somebody has done something with operator overloading that has just really ticked them off, because they’ve used like + for list insertion and it makes life really, really confusing. A lot of that problem stems from the fact that there are only about half a dozen operators you can sensibly overload, and yet there are thousands or millions of operators that people would like to define—so you have to pick, and often the choices conflict with your sense of intuition.\n\nGuido van Rossum picked the middle way in supporting operator overloading: he did not leave the door open for users creating new arbitrary operators like <=> or :-), which prevents a Tower of Babel of custom operators, and allows the Python parser to be simple. Python also does not let you overload the operators of the built-in types, another limitation that promotes readability and predictable performance.\n\nGosling goes on to say:\n\nThen there’s a community of about 10 percent that have actually used operator over‐ loading appropriately and who really care about it, and for whom it’s actually really important; this is almost exclusively people who do numerical work, where the nota‐ tion is very important to appealing to people’s intuition, because they come into it with an intuition about what the + means, and the ability to say “a + b” where a and b are complex numbers or matrices or something really does make sense.\n\nOf course, there are benefits to disallowing operator overloading in a language. I’ve seen the argument that C is better than C++ for systems programming because oper‐ ator overloading in C++ can make costly operations seem trivial. Two successful modern languages that compile to binary executables made opposite choices: Go doesn’t have operator overloading, but Rust does.\n\n588\n\n|\n\nChapter 16: Operator Overloading\n\nBut overloaded operators, when used sensibly, do make code easier to read and write. It’s a great feature to have in a modern high-level language.\n\nA Glimpse at Lazy Evaluation\n\nIf you look closely at the traceback in Example 16-9, you’ll see evidence of the lazy evaluation of generator expressions. Example 16-20 is that same traceback, now with callouts.\n\nExample 16-20. Same as Example 16-9\n\n>>> v1 + 'ABC' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"vector_v6.py\", line 329, in __add__ return Vector(a + b for a, b in pairs) File \"vector_v6.py\", line 243, in __init__ self._components = array(self.typecode, components) File \"vector_v6.py\", line 329, in <genexpr> return Vector(a + b for a, b in pairs) TypeError: unsupported operand type(s) for +: 'float' and 'str'\n\nThe Vector call gets a generator expression as its components argument. No problem at this stage.\n\nThe components genexp is passed to the array constructor. Within the array constructor, Python tries to iterate over the genexp, causing the evaluation of the first item a + b. That’s when the TypeError occurs.\n\nThe exception propagates to the Vector constructor call, where it is reported.\n\nThis shows how the generator expression is evaluated at the latest possible moment, and not where it is defined in the source code.\n\nIn contrast, if the Vector constructor was invoked as Vector([a + b for a, b in pairs]), then the exception would happen right there, because the list comprehen‐ sion tried to build a list to be passed as the argument to the Vector() call. The body of Vector.__init__ would not be reached at all.\n\nChapter 17 will cover generator expressions in detail, but I did not want to let this accidental demonstration of their lazy nature go unnoticed.\n\nFurther Reading\n\n|\n\n589\n\nPART IV Control Flow\n\nCHAPTER 17 Iterators, Generators, and Classic Coroutines\n\nWhen I see patterns in my programs, I consider it a sign of trouble. The shape of a program should reflect only the problem it needs to solve. Any other regularity in the code is a sign, to me at least, that I’m using abstractions that aren’t powerful enough— often that I’m generating by hand the expansions of some macro that I need to write.\n\n—Paul Graham, Lisp hacker and venture capitalist1\n\nIteration is fundamental to data processing: programs apply computations to data series, from pixels to nucleotides. If the data doesn’t fit in memory, we need to fetch the items lazily—one at a time and on demand. That’s what an iterator does. This chapter shows how the Iterator design pattern is built into the Python language so you never need to code it by hand.\n\nEvery standard collection in Python is iterable. An iterable is an object that provides an iterator, which Python uses to support operations like:\n\nfor loops\n\nList, dict, and set comprehensions\n\nUnpacking assignments\n\nConstruction of collection instances\n\n1 From “Revenge of the Nerds”, a blog post.\n\n593\n\nThis chapter covers the following topics:\n\nHow Python uses the iter() built-in function to handle iterable objects\n\nHow to implement the classic Iterator pattern in Python\n\nHow the classic Iterator pattern can be replaced by a generator function or gen‐ erator expression\n\nHow a generator function works in detail, with line-by-line descriptions\n\nLeveraging the general-purpose generator functions in the standard library • Using yield from expressions to combine generators\n\nWhy generators and classic coroutines look alike but are used in very different ways and should not be mixed\n\nWhat’s New in This Chapter “Subgenerators with yield from” on page 632 grew from one to six pages. It now includes simpler experiments demonstrating the behavior of generators with yield from, and an example of traversing a tree data structure, developed step-by-step.\n\nNew sections explain the type hints for Iterable, Iterator, and Generator types.\n\nThe last major section of this chapter, “Classic Coroutines” on page 641, is a 9-page introduction to a topic that filled a 40-page chapter in the first edition. I updated and moved the “Classic Coroutines” chapter to a post in the companion website because it was the most challenging chapter for readers, but its subject matter is less relevant after Python 3.5 introduced native coroutines—which we’ll study in Chapter 21.\n\nWe’ll get started studying how the iter() built-in function makes sequences iterable.\n\nA Sequence of Words We’ll start our exploration of iterables by implementing a Sentence class: you give its constructor a string with some text, and then you can iterate word by word. The first version will implement the sequence protocol, and it’s iterable because all sequences are iterable—as we’ve seen since Chapter 1. Now we’ll see exactly why.\n\nExample 17-1 shows a Sentence class that extracts words from a text by index.\n\nExample 17-1. sentence.py: a Sentence as a sequence of words\n\nimport re import reprlib\n\n594\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nRE_WORD = re.compile(r'\\w+')\n\nclass Sentence:\n\ndef __init__(self, text): self.text = text self.words = RE_WORD.findall(text)\n\ndef __getitem__(self, index): return self.words[index]\n\ndef __len__(self): return len(self.words)\n\ndef __repr__(self): return 'Sentence(%s)' % reprlib.repr(self.text)\n\n.findall returns a list with all nonoverlapping matches of the regular expres‐ sion, as a list of strings.\n\nself.words holds the result of .findall, so we simply return the word at the given index.\n\nTo complete the sequence protocol, we implement __len__ although it is not needed to make an iterable.\n\nreprlib.repr is a utility function to generate abbreviated string representations of data structures that can be very large.2\n\nBy default, reprlib.repr limits the generated string to 30 characters. See the console session in Example 17-2 to see how Sentence is used.\n\nExample 17-2. Testing iteration on a Sentence instance\n\n>>> s = Sentence('\"The time has come,\" the Walrus said,') >>> s Sentence('\"The time ha... Walrus said,') >>> for word in s: ... print(word) The time has come the\n\n2 We first used reprlib in “Vector Take #1: Vector2d Compatible” on page 399.\n\nA Sequence of Words\n\n|\n\n595\n\nWalrus said >>> list(s) ['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n\nA sentence is created from a string.\n\nNote the output of __repr__ using ... generated by reprlib.repr.\n\nSentence instances are iterable; we’ll see why in a moment.\n\nBeing iterable, Sentence objects can be used as input to build lists and other iterable types.\n\nIn the following pages, we’ll develop other Sentence classes that pass the tests in Example 17-2. However, the implementation in Example 17-1 is different from the others because it’s also a sequence, so you can get words by index:\n\n>>> s[0] 'The' >>> s[5] 'Walrus' >>> s[-1] 'said'\n\nPython programmers know that sequences are iterable. Now we’ll see precisely why.\n\nWhy Sequences Are Iterable: The iter Function Whenever Python needs to iterate over an object x, it automatically calls iter(x).\n\nThe iter built-in function:\n\n1. Checks whether the object implements __iter__, and calls that to obtain an iterator.\n\n2. If __iter__ is not implemented, but __getitem__ is, then iter() creates an iter‐ ator that tries to fetch items by index, starting from 0 (zero).\n\n3. If that fails, Python raises TypeError, usually saying 'C' object is not itera ble, where C is the class of the target object.\n\nThat is why all Python sequences are iterable: by definition, they all implement __getitem__. In fact, the standard sequences also implement __iter__, and yours should too, because iteration via __getitem__ exists for backward compatibility and may be gone in the future—although it is not deprecated as of Python 3.10, and I doubt it will ever be removed.\n\n596\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "page_number": 596
    },
    {
      "number": 31,
      "title": "Segment 31 (pages 615-636)",
      "start_page": 615,
      "end_page": 636,
      "detection_method": "synthetic",
      "content": "As mentioned in “Python Digs Sequences” on page 436, this is an extreme form of duck typing: an object is considered iterable not only when it implements the special method __iter__, but also when it implements __getitem__. Take a look:\n\n>>> class Spam: ... def __getitem__(self, i): ... print('->', i) ... raise IndexError() ... >>> spam_can = Spam() >>> iter(spam_can) <iterator object at 0x10a878f70> >>> list(spam_can) -> 0 [] >>> from collections import abc >>> isinstance(spam_can, abc.Iterable) False\n\nIf a class provides __getitem__, the iter() built-in accepts an instance of that class as iterable and builds an iterator from the instance. Python’s iteration machinery will call __getitem__ with indexes starting from 0, and will take an IndexError as a signal that there are no more items.\n\nNote that although spam_can is iterable (its __getitem__ could provide items), it is not recognized as such by an isinstance against abc.Iterable.\n\nIn the goose-typing approach, the definition for an iterable is simpler but not as flexi‐ ble: an object is considered iterable if it implements the __iter__ method. No sub‐ classing or registration implements the __subclasshook__, as seen in “Structural Typing with ABCs” on page 464. Here is a demonstration:\n\nis required, because abc.Iterable\n\n>>> class GooseSpam: ... def __iter__(self): ... pass ... >>> from collections import abc >>> issubclass(GooseSpam, abc.Iterable) True >>> goose_spam_can = GooseSpam() >>> isinstance(goose_spam_can, abc.Iterable) True\n\nAs of Python 3.10, the most accurate way to check whether an object x is iterable is to call iter(x) and handle a TypeError excep‐ tion if it isn’t. This is more accurate than using isinstance(x, abc.Iterable), because iter(x) also considers legacy __getitem__ method, while the Iterable ABC does not.\n\nthe\n\nWhy Sequences Are Iterable: The iter Function\n\n|\n\n597\n\nExplicitly checking whether an object is iterable may not be worthwhile if right after the check you are going to iterate over the object. After all, when the iteration is attempted on a noniterable, the exception Python raises is clear enough: TypeError: 'C' object is not iterable. If you can do better than just raising TypeError, then do so in a try/except block instead of doing an explicit check. The explicit check may make sense if you are holding on to the object to iterate over it later; in this case, catching the error early makes debugging easier.\n\nThe iter() built-in is more often used by Python itself than by our own code. There’s a second way we can use it, but it’s not widely known.\n\nUsing iter with a Callable We can call iter() with two arguments to create an iterator from a function or any callable object. In this usage, the first argument must be a callable to be invoked repeatedly (with no arguments) to produce values, and the second argument is a sen‐ tinel: a marker value which, when returned by the callable, causes the iterator to raise StopIteration instead of yielding the sentinel.\n\nThe following example shows how to use iter to roll a six-sided die until a 1 is rolled:\n\n>>> def d6(): ... return randint(1, 6) ... >>> d6_iter = iter(d6, 1) >>> d6_iter <callable_iterator object at 0x10a245270> >>> for roll in d6_iter: ... print(roll) ... 4 3 6 3\n\nNote that the iter function here returns a callable_iterator. The for loop in the example may run for a very long time, but it will never display 1, because that is the sentinel value. As usual with iterators, the d6_iter object in the example becomes useless once exhausted. To start over, we must rebuild the iterator by invoking iter() again.\n\nThe documentation for iter includes the following explanation and example code:\n\nOne useful application of the second form of iter() is to build a block-reader. For example, reading fixed-width blocks from a binary database file until the end of file is reached:\n\nfrom functools import partial\n\n598\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nwith open('mydata.db', 'rb') as f: read64 = partial(f.read, 64) for block in iter(read64, b''): process_block(block)\n\nFor clarity, I’ve added the read64 assignment, which is not in the original example. The partial() function is necessary because the callable given to iter() must not require arguments. In the example, an empty bytes object is the sentinel, because that’s what f.read returns when there are no more bytes to read.\n\nThe next section details the relationship between iterables and iterators.\n\nIterables Versus Iterators From the explanation in “Why Sequences Are Iterable: The iter Function” on page 596 we can extrapolate a definition:\n\niterable\n\nAny object from which the iter built-in function can obtain an iterator. Objects implementing an __iter__ method returning an iterator are iterable. Sequences are always iterable, as are objects implementing a __getitem__ method that accepts 0-based indexes.\n\nIt’s important to be clear about the relationship between iterables and iterators: Python obtains iterators from iterables.\n\nHere is a simple for loop iterating over a str. The str 'ABC' is the iterable here. You don’t see it, but there is an iterator behind the curtain:\n\n>>> s = 'ABC' >>> for char in s: ... print(char) ... A B C\n\nIf there was no for statement and we had to emulate the for machinery by hand with a while loop, this is what we’d have to write:\n\n>>> s = 'ABC' >>> it = iter(s) >>> while True: ... try: ... print(next(it)) ... except StopIteration: ... del it ... break ... A\n\nIterables Versus Iterators\n\n|\n\n599\n\nB C\n\nBuild an iterator it from the iterable.\n\nRepeatedly call next on the iterator to obtain the next item.\n\nThe iterator raises StopIteration when there are no further items.\n\nRelease reference to it—the iterator object is discarded.\n\nExit the loop.\n\nStopIteration signals that the iterator is exhausted. This exception is handled inter‐ nally by the iter() built-in that is part of the logic of for loops and other iteration contexts like list comprehensions, iterable unpacking, etc.\n\nPython’s standard interface for an iterator has two methods:\n\n__next__\n\nReturns the next item in the series, raising StopIteration if there are no more.\n\n__iter__\n\nReturns self; this allows iterators to be used where an iterable is expected, for example, in a for loop.\n\nThat interface is formalized in the collections.abc.Iterator ABC, which declares the __next__ abstract method, and subclasses Iterable—where the abstract __iter__ method is declared. See Figure 17-1.\n\nFigure 17-1. The Iterable and Iterator ABCs. Methods in italic are abstract. A con‐ crete Iterable.__iter__ should return a new Iterator instance. A concrete Itera tor must implement __next__. The Iterator.__iter__ method just returns the instance itself.\n\nThe source code for collections.abc.Iterator is in Example 17-3.\n\n600\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nExample 17-3. abc.Iterator class; extracted from Lib/_collections_abc.py\n\nclass Iterator(Iterable):\n\n__slots__ = ()\n\n@abstractmethod def __next__(self): 'Return the next item from the iterator. When exhausted, raise StopIteration' raise StopIteration\n\ndef __iter__(self): return self\n\n@classmethod def __subclasshook__(cls, C): if cls is Iterator: return _check_methods(C, '__iter__', '__next__') return NotImplemented\n\n__subclasshook__ supports structural type checks with isinstance and issub class. We saw it in “Structural Typing with ABCs” on page 464.\n\n_check_methods traverses the __mro__ of the class to check whether the methods are implemented in its base classes. It’s defined in that same Lib/_collec‐ tions_abc.py module. If the methods are implemented, the C class will be recog‐ nized as a virtual subclass of Iterator. In other words, issubclass(C, Iterable) will return True.\n\nThe Iterator ABC abstract method is it.__next__() in Python 3 and it.next() in Python 2. As usual, you should avoid calling spe‐ cial methods directly. Just use the next(it): this built-in function does the right thing in Python 2 and 3—which is useful for those migrating codebases from 2 to 3.\n\nThe Lib/types.py module source code in Python 3.9 has a comment that says:\n\n# Iterators in Python aren't a matter of type but of protocol. A large # and changing number of builtin types implement *some* flavor of # iterator. Don't check the type! Use hasattr to check for both # \"__iter__\" and \"__next__\" attributes instead.\n\nIn fact, that’s exactly what the __subclasshook__ method of the abc.Iterator ABC does.\n\nIterables Versus Iterators\n\n|\n\n601\n\nGiven the advice from Lib/types.py and the logic implemented in Lib/_collections_abc.py, the best way to check if an object x is an iterator is to call isinstance(x, abc.Iterator). Thanks to Itera tor.__subclasshook__, this test works even if the class of x is not a real or virtual subclass of Iterator.\n\nBack to our Sentence class from Example 17-1, you can clearly see how the iterator is built by iter() and consumed by next() using the Python console:\n\n>>> s3 = Sentence('Life of Brian') >>> it = iter(s3) >>> it # doctest: +ELLIPSIS <iterator object at 0x...> >>> next(it) 'Life' >>> next(it) 'of' >>> next(it) 'Brian' >>> next(it) Traceback (most recent call last): ... StopIteration >>> list(it) [] >>> list(iter(s3)) ['Life', 'of', 'Brian']\n\nCreate a sentence s3 with three words.\n\nObtain an iterator from s3.\n\nnext(it) fetches the next word.\n\nThere are no more words, so the iterator raises a StopIteration exception.\n\nOnce exhausted, an iterator will always raise StopIteration, which makes it look like it’s empty.\n\nTo go over the sentence again, a new iterator must be built.\n\nBecause the only methods required of an iterator are __next__ and __iter__, there is no way to check whether there are remaining items, other than to call next() and catch StopIteration. Also, it’s not possible to “reset” an iterator. If you need to start over, you need to call iter() on the iterable that built the iterator in the first place. Calling iter() on the iterator itself won’t help either, because—as mentioned—\n\n602\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nIterator.__iter__ is implemented by returning self, so this will not reset a deple‐ ted iterator.\n\nThat minimal interface is sensible, because in reality not all iterators are resettable. For example, if an iterator is reading packets from the network, there’s no way to rewind it.3\n\nThe first version of Sentence from Example 17-1 was iterable thanks to the special treatment the iter() built-in gives to sequences. Next, we will implement Sentence variations that implement __iter__ to return iterators.\n\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nSentence Take #2: A Classic Iterator The next Sentence implementation follows the blueprint of the classic Iterator design pattern from the Design Patterns book. Note that it is not idiomatic Python, as the next refactorings will make very clear. But it is useful to show the distinction between an iterable collection and an iterator that works with it.\n\nThe Sentence class in Example 17-4 is iterable because it implements the __iter__ special method, which builds and returns a SentenceIterator. That’s how an itera‐ ble and an iterator are related.\n\nExample 17-4. sentence_iter.py: Sentence implemented using the Iterator pattern\n\nimport re import reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\nclass Sentence:\n\ndef __init__(self, text): self.text = text self.words = RE_WORD.findall(text)\n\ndef __repr__(self): return f'Sentence({reprlib.repr(self.text)})'\n\n3 Thanks to tech reviewer Leonardo Rochael for this fine example.\n\nSentence Classes with __iter__\n\n|\n\n603\n\ndef __iter__(self): return SentenceIterator(self.words)\n\nclass SentenceIterator:\n\ndef __init__(self, words): self.words = words self.index = 0\n\ndef __next__(self): try: word = self.words[self.index] except IndexError: raise StopIteration() self.index += 1 return word\n\ndef __iter__(self): return self\n\nThe __iter__ method is the only addition to the previous Sentence implemen‐ tation. This version has no __getitem__, to make it clear that the class is iterable because it implements __iter__.\n\n__iter__ fulfills the iterable protocol by instantiating and returning an iterator.\n\nSentenceIterator holds a reference to the list of words.\n\nself.index determines the next word to fetch.\n\nGet the word at self.index.\n\nIf there is no word at self.index, raise StopIteration.\n\nIncrement self.index.\n\nReturn the word.\n\nImplement self.__iter__.\n\nThe code in Example 17-4 passes the tests in Example 17-2.\n\nNote that implementing __iter__ in SentenceIterator is not actually needed for this example to work, but it is the right thing to do: iterators are supposed to implement both __next__ and __iter__, and doing so makes our iterator pass the issubclass(SentenceIterator, abc.Iterator) test. If we had subclassed\n\n604\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nSentenceIterator from abc.Iterator, we’d inherit the concrete abc.Itera tor.__iter__ method.\n\nThat is a lot of work (for us spoiled Python programmers, anyway). Note how most code in SentenceIterator deals with managing the internal state of the iterator. Soon we’ll see how to avoid that bookkeeping. But first, a brief detour to address an implementation shortcut that may be tempting, but is just wrong.\n\nDon’t Make the Iterable an Iterator for Itself A common cause of errors in building iterables and iterators is to confuse the two. To be clear: iterables have an __iter__ method that instantiates a new iterator every time. Iterators implement a __next__ method that returns individual items, and an __iter__ method that returns self.\n\nTherefore, iterators are also iterable, but iterables are not iterators.\n\nIt may be tempting to implement __next__ in addition to __iter__ in the Sentence class, making each Sentence instance at the same time an iterable and iterator over itself. But this is rarely a good idea. It’s also a common antipattern, according to Alex Martelli who has a lot of experience reviewing Python code at Google.\n\nThe “Applicability” section about the Iterator design pattern in the Design Patterns book says:\n\nUse the Iterator pattern\n\nto access an aggregate object’s contents without exposing representation.\n\nto support multiple traversals of aggregate objects.\n\nto provide a uniform interface for traversing different aggregate structures (that is, to support polymorphic iteration).\n\nTo “support multiple traversals,” it must be possible to obtain multiple independent iterators from the same iterable instance, and each iterator must keep its own internal state, so a proper implementation of the pattern requires each call to iter(my_itera ble) to create a new, independent, iterator. That is why we need the SentenceItera tor class in this example.\n\nNow that the classic Iterator pattern is properly demonstrated, we can let it go. Python incorporated the yield keyword from Barbara Liskov’s CLU language, so we don’t need to “generate by hand” the code to implement iterators.\n\nThe next sections present more idiomatic versions of Sentence.\n\nSentence Classes with __iter__\n\n|\n\n605\n\nSentence Take #3: A Generator Function A Pythonic implementation of the same functionality uses a generator, avoiding all the work to implement the SentenceIterator class. A proper explanation of the gen‐ erator comes right after Example 17-5.\n\nExample 17-5. sentence_gen.py: Sentence implemented using a generator\n\nimport re import reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\nclass Sentence:\n\ndef __init__(self, text): self.text = text self.words = RE_WORD.findall(text)\n\ndef __repr__(self): return 'Sentence(%s)' % reprlib.repr(self.text)\n\ndef __iter__(self): for word in self.words: yield word\n\n# done!\n\nIterate over self.words.\n\nYield the current word.\n\nExplicit return is not necessary; the function can just “fall through” and return automatically. Either way, a generator function doesn’t raise StopIteration: it simply exits when it’s done producing values.4\n\nNo need for a separate iterator class!\n\n4 When reviewing this code, Alex Martelli suggested the body of this method could simply be return\n\niter(self.words). He is right: the result of calling self.words.__iter__() would also be an iterator, as it should be. However, I used a for loop with yield here to introduce the syntax of a generator function, which requires the yield keyword, as we’ll see in the next section. During review of the second edition of this book, Leonardo Rochael suggested yet another shortcut for the body of __iter__: yield from self.words. We’ll also cover yield from later in this chapter.\n\n606\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nHere again we have a different implementation of Sentence that passes the tests in Example 17-2.\n\nBack in the Sentence code in Example 17-4, __iter__ called the SentenceIterator constructor to build an iterator and return it. Now the iterator in Example 17-5 is in fact a generator object, built automatically when the __iter__ method is called, because __iter__ here is a generator function.\n\nA full explanation of generators follows.\n\nHow a Generator Works Any Python function that has the yield keyword in its body is a generator function: a function which, when called, returns a generator object. In other words, a generator function is a generator factory.\n\nThe only syntax distinguishing a plain function from a generator function is the fact that the latter has a yield keyword somewhere in its body. Some argued that a new keyword like gen should be used instead of def to declare generator functions, but Guido did not agree. His arguments are in PEP 255 — Simple Generators.5\n\nExample 17-6 shows the behavior of a simple generator function.6\n\nExample 17-6. A generator function that yields three numbers\n\n>>> def gen_123(): ... yield 1 ... yield 2 ... yield 3 ... >>> gen_123 # doctest: +ELLIPSIS <function gen_123 at 0x...> >>> gen_123() # doctest: +ELLIPSIS <generator object gen_123 at 0x...> >>> for i in gen_123(): ... print(i) 1 2\n\n5 Sometimes I add a gen prefix or suffix when naming generator functions, but this is not a common practice. And you can’t do that if you’re implementing an iterable, of course: the necessary special method must be named __iter__.\n\n6 Thanks to David Kwast for suggesting this example.\n\nSentence Classes with __iter__\n\n|\n\n607\n\n3 >>> g = gen_123() >>> next(g) 1 >>> next(g) 2 >>> next(g) 3 >>> next(g) Traceback (most recent call last): ... StopIteration\n\nThe body of a generator function often has yield inside a loop, but not necessar‐ ily; here I just repeat yield three times.\n\nLooking closely, we see gen_123 is a function object.\n\nBut when invoked, gen_123() returns a generator object.\n\nGenerator objects implement the Iterator interface, so they are also iterable.\n\nWe assign this new generator object to g, so we can experiment with it.\n\nBecause g is an iterator, calling next(g) fetches the next item produced by yield.\n\nWhen the generator function returns, the generator object raises StopIteration.\n\nA generator function builds a generator object that wraps the body of the function. When we invoke next() on the generator object, execution advances to the next yield in the function body, and the next() call evaluates to the value yielded when the function body is suspended. Finally, the enclosing generator object created by Python raises StopIteration when the function body returns, in accordance with the Iterator protocol.\n\nI find it helpful to be rigorous when talking about values obtained from a generator. It’s confusing to say a generator “returns” values. Functions return values. Calling a generator function returns a generator. A generator yields values. A generator doesn’t “return” values in the usual way: the return statement in the body of a gen‐ erator function causes StopIteration to be raised by the generator object. If you return x in the generator, the caller can retrieve the value of x from the StopIteration exception, but usually that is done automatically using the yield from syntax, as we’ll see in “Returning a Value from a Coroutine” on page 646.\n\n608\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nExample 17-7 makes the interaction between a for loop and the body of the function more explicit.\n\nExample 17-7. A generator function that prints messages when it runs\n\n>>> def gen_AB(): ... print('start') ... yield 'A' ... print('continue') ... yield 'B' ... print('end.') ... >>> for c in gen_AB(): ... print('-->', c) ... start --> A continue --> B end. >>>\n\nThe first implicit call to next() in the for loop at at the first yield, producing the value 'A'.\n\nwill print 'start' and stop\n\nThe second implicit call to next() in the for loop will print 'continue' and stop at the second yield, producing the value 'B'.\n\nThe third call to next() will print 'end.' and fall through the end of the func‐ tion body, causing the generator object to raise StopIteration.\n\nTo iterate, the for machinery does the equivalent of g = iter(gen_AB()) to get a generator object, and then next(g) at each iteration.\n\nThe loop prints --> and the value returned by next(g). This output will appear only after the output of the print calls inside the generator function.\n\nThe text start comes from print('start') in the generator body.\n\nyield 'A' in the generator body yields the value A consumed by the for loop, which gets assigned to the c variable and results in the output --> A.\n\nIteration continues with a second call to next(g), advancing the generator body from yield 'A' to yield 'B'. The text continue is output by the second print in the generator body.\n\nSentence Classes with __iter__\n\n|\n\n609\n\nyield 'B' yields the value B consumed by the for loop, which gets assigned to the c loop variable, so the loop prints --> B.\n\nIteration continues with a third call to next(it), advancing to the end of the body of the function. The text end. appears in the output because of the third print in the generator body.\n\nWhen the generator function runs to the end, the generator object raises StopIt eration. The for loop machinery catches that exception, and the loop termi‐ nates cleanly.\n\nNow hopefully it’s clear how Sentence.__iter__ in Example 17-5 works: __iter__ is a generator function which, when called, builds a generator object that implements the Iterator interface, so the SentenceIterator class is no longer needed.\n\nThat second version of Sentence is more concise than the first, but it’s not as lazy as it could be. Nowadays, laziness is considered a good trait, at least in programming languages and APIs. A lazy implementation postpones producing values to the last possible moment. This saves memory and may avoid wasting CPU cycles, too.\n\nWe’ll build lazy Sentence classes next.\n\nLazy Sentences The final variations of Sentence are lazy, taking advantage of a lazy function from the re module.\n\nSentence Take #4: Lazy Generator The Iterator interface is designed to be lazy: next(my_iterator) yields one item at a time. The opposite of lazy is eager: lazy evaluation and eager evaluation are techni‐ cal terms in programming language theory.\n\nOur Sentence implementations so far have not been lazy because the __init__ eagerly builds a list of all words in the text, binding it to the self.words attribute. This requires processing the entire text, and the list may use as much memory as the text itself (probably more; it depends on how many nonword characters are in the text). Most of this work will be in vain if the user only iterates over the first couple of words. If you wonder, “Is there a lazy way of doing this in Python?” the answer is often “Yes.”\n\nThe re.finditer function is a lazy version of re.findall. Instead of a list, re.fin diter returns a generator yielding re.MatchObject instances on demand. If there are many matches, re.finditer saves a lot of memory. Using it, our third version of\n\n610\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nSentence is now lazy: it only reads the next word from the text when it is needed. The code is in Example 17-8.\n\nExample 17-8. sentence_gen2.py: Sentence implemented using a generator function calling the re.finditer generator function\n\nimport re import reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\nclass Sentence:\n\ndef __init__(self, text): self.text = text\n\ndef __repr__(self): return f'Sentence({reprlib.repr(self.text)})'\n\ndef __iter__(self): for match in RE_WORD.finditer(self.text): yield match.group()\n\nNo need to have a words list.\n\nfinditer builds an iterator over the matches of RE_WORD on self.text, yielding MatchObject instances.\n\nmatch.group() extracts the matched text from the MatchObject instance.\n\nGenerators are a great shortcut, but the code can be made even more concise with a generator expression.\n\nSentence Take #5: Lazy Generator Expression We can replace simple generator functions like the one in the previous Sentence class (Example 17-8) with a generator expression. As a list comprehension builds lists, a generator expression builds generator objects. Example 17-9 contrasts their behavior.\n\nExample 17-9. The gen_AB generator function is used by a list comprehension, then by a generator expression\n\n>>> def gen_AB(): ... print('start') ... yield 'A'\n\nLazy Sentences\n\n|\n\n611\n\n... print('continue') ... yield 'B' ... print('end.') ... >>> res1 = [x*3 for x in gen_AB()] start continue end. >>> for i in res1: ... print('-->', i) ... --> AAA --> BBB >>> res2 = (x*3 for x in gen_AB()) >>> res2 <generator object <genexpr> at 0x10063c240> >>> for i in res2: ... print('-->', i) ... start --> AAA continue --> BBB end.\n\nThis is the same gen_AB function from Example 17-7.\n\nThe list comprehension eagerly iterates over the items yielded by the generator object returned by gen_AB(): 'A' and 'B'. Note the output in the next lines: start, continue, end.\n\nThis for loop iterates over the res1 list built by the list comprehension.\n\nThe generator expression returns res2, a generator object. The generator is not consumed here.\n\nOnly when the for loop iterates over res2, this generator gets items from gen_AB. Each iteration of the for loop implicitly calls next(res2), which in turn calls next() on the generator object returned by gen_AB(), advancing it to the next yield.\n\nNote how the output of gen_AB() interleaves with the output of the print in the for loop.\n\nWe can use a generator expression to further reduce the code in the Sentence class. See Example 17-10.\n\n612\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nExample 17-10. sentence_genexp.py: Sentence implemented using a generator expression\n\nimport re import reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\nclass Sentence:\n\ndef __init__(self, text): self.text = text\n\ndef __repr__(self): return f'Sentence({reprlib.repr(self.text)})'\n\ndef __iter__(self): return (match.group() for match in RE_WORD.finditer(self.text))\n\nThe only difference from Example 17-8 is the __iter__ method, which here is not a generator function (it has no yield) but uses a generator expression to build a gener‐ ator and then returns it. The end result is the same: the caller of __iter__ gets a gen‐ erator object.\n\nGenerator expressions are syntactic sugar: they can always be replaced by generator functions, but sometimes are more convenient. The next section is about generator expression usage.\n\nWhen to Use Generator Expressions I used several generator expressions when implementing the Vector class in Example 12-16. Each of these methods has a generator expression: __eq__, __hash__, __abs__, angle, angles, format, __add__, and __mul__. In all those methods, a list comprehension would also work, at the cost of using more memory to store the inter‐ mediate list values.\n\nIn Example 17-10, we saw that a generator expression is a syntactic shortcut to create a generator without defining and calling a function. On the other hand, generator functions are more flexible: we can code complex logic with multiple statements, and we can even use them as coroutines, as we’ll see in “Classic Coroutines” on page 641.\n\nFor the simpler cases, a generator expression is easier to read at a glance, as the Vector example shows.\n\nMy rule of thumb in choosing the syntax to use is simple: if the generator expression spans more than a couple of lines, I prefer to code a generator function for the sake of readability.\n\nWhen to Use Generator Expressions\n\n|\n\n613\n\nSyntax Tip\n\nWhen a generator expression is passed as the single argument to a function or constructor, you don’t need to write a set of parenthe‐ ses for the function call and another to enclose the generator expression. A single pair will do, like in the Vector call from the __mul__ method in Example 12-16, reproduced here:\n\ndef __mul__(self, scalar): if isinstance(scalar, numbers.Real): return Vector(n * scalar for n in self) else: return NotImplemented\n\nHowever, if there are more function arguments after the generator expression, you need to enclose it in parentheses to avoid a Syntax Error.\n\nThe Sentence examples we’ve seen demonstrate generators playing the role of the classic Iterator pattern: retrieving items from a collection. But we can also use genera‐ tors to yield values independent of a data source. The next section shows an example.\n\nBut first, a short discussion on the overlapping concepts of iterator and generator.\n\nContrasting Iterators and Generators In the official Python documentation and codebase, the terminology around iterators and generators is inconsistent and evolving. I’ve adopted the following definitions:\n\niterator\n\nGeneral term for any object that implements a __next__ method. Iterators are designed to produce data that is consumed by the client code, i.e., the code that drives the iterator via a for loop or other iterative feature, or by explicitly calling next(it) on the iterator—although this explicit usage is much less common. In practice, most iterators we use in Python are generators.\n\ngenerator\n\nAn iterator built by the Python compiler. To create a generator, we don’t imple‐ ment __next__. Instead, we use the yield keyword to make a generator function, which is a factory of generator objects. A generator expression is another way to build a generator object. Generator objects provide __next__, so they are itera‐ tors. Since Python 3.5, we also have asynchronous generators declared with async def. We’ll study them in Chapter 21, “Asynchronous Programming”.\n\nThe Python Glossary recently introduced the term generator iterator to refer to gener‐ ator objects built by generator functions, while the entry for generator expression says it returns an “iterator.”\n\n614\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nBut the objects returned in both cases are generator objects, according to Python:\n\n>>> def g(): ... yield 0 ... >>> g() <generator object g at 0x10e6fb290> >>> ge = (c for c in 'XYZ') >>> ge <generator object <genexpr> at 0x10e936ce0> >>> type(g()), type(ge) (<class 'generator'>, <class 'generator'>)\n\nAn Arithmetic Progression Generator The classic Iterator pattern is all about traversal: navigating some data structure. But a standard interface based on a method to fetch the next item in a series is also useful when the items are produced on the fly, instead of retrieved from a collection. For example, the range built-in generates a bounded arithmetic progression (AP) of inte‐ gers. What if you need to generate an AP of numbers of any type, not only integers?\n\nExample 17-11 shows a few console tests of an ArithmeticProgression class we will see in a moment. The signature of the constructor in Example 17-11 is Arithmetic Progression(begin, step[, end]). The complete signature of the range built-in is range(start, stop[, step]). I chose to implement a different signature because the step is mandatory but end is optional in an arithmetic progression. I also changed the argument names from start/stop to begin/end to make it clear that I opted for a different signature. In each test in Example 17-11, I call list() on the result to inspect the generated values.\n\nExample 17-11. Demonstration of an ArithmeticProgression class\n\n>>> ap = ArithmeticProgression(0, 1, 3) >>> list(ap) [0, 1, 2] >>> ap = ArithmeticProgression(1, .5, 3) >>> list(ap) [1.0, 1.5, 2.0, 2.5] >>> ap = ArithmeticProgression(0, 1/3, 1) >>> list(ap) [0.0, 0.3333333333333333, 0.6666666666666666] >>> from fractions import Fraction >>> ap = ArithmeticProgression(0, Fraction(1, 3), 1) >>> list(ap) [Fraction(0, 1), Fraction(1, 3), Fraction(2, 3)] >>> from decimal import Decimal >>> ap = ArithmeticProgression(0, Decimal('.1'), .3)\n\nAn Arithmetic Progression Generator\n\n|\n\n615\n\n>>> list(ap) [Decimal('0'), Decimal('0.1'), Decimal('0.2')]\n\nNote that the type of the numbers in the resulting arithmetic progression follows the type of begin + step, according to the numeric coercion rules of Python arithmetic. In Example 17-11, you see lists of int, float, Fraction, and Decimal numbers. Example 17-12 lists the implementation of the ArithmeticProgression class.\n\nExample 17-12. The ArithmeticProgression class\n\nclass ArithmeticProgression:\n\ndef __init__(self, begin, step, end=None): self.begin = begin self.step = step self.end = end # None -> \"infinite\" series\n\ndef __iter__(self): result_type = type(self.begin + self.step) result = result_type(self.begin) forever = self.end is None index = 0 while forever or result < self.end: yield result index += 1 result = self.begin + self.step * index\n\n__init__ requires two arguments: begin and step; end is optional, if it’s None, the series will be unbounded.\n\nGet the type of adding self.begin and self.step. For example, if one is int and the other is float, result_type will be float.\n\nThis line makes a result with the same numeric value of self.begin, but coerced to the type of the subsequent additions.7\n\nFor readability, the forever flag will be True if the self.end attribute is None, resulting in an unbounded series.\n\n7 In Python 2, there was a coerce() built-in function, but it’s gone in Python 3. It was deemed unnecessary\n\nbecause the numeric coercion rules are implicit in the arithmetic operator methods. So the best way I could think of to coerce the initial value to be of the same type as the rest of the series was to perform the addition and use its type to convert the result. I asked about this in the Python-list and got an excellent response from Steven D’Aprano.\n\n616\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nThis loop runs forever or until the result matches or exceeds self.end. When this loop exits, so does the function.\n\nThe current result is produced.\n\nThe next potential result is calculated. It may never be yielded, because the while loop may terminate.\n\nIn the last line of Example 17-12, instead of adding self.step to the previous result each time around the loop, I opted to ignore the previous result and each new result by adding self.begin to self.step multiplied by index. This avoids the cumulative effect of floating-point errors after successive additions. These simple experiments make the difference clear:\n\n>>> 100 * 1.1 110.00000000000001 >>> sum(1.1 for _ in range(100)) 109.99999999999982 >>> 1000 * 1.1 1100.0 >>> sum(1.1 for _ in range(1000)) 1100.0000000000086\n\nThe ArithmeticProgression class from Example 17-12 works as intended, and is a another example of using a generator function to implement the __iter__ special method. However, if the whole point of a class is to build a generator by implement‐ ing __iter__, we can replace the class with a generator function. A generator function is, after all, a generator factory.\n\nExample 17-13 shows a generator function called aritprog_gen that does the same job as ArithmeticProgression but with less code. The tests in Example 17-11 all pass if you just call aritprog_gen instead of ArithmeticProgression.8\n\nExample 17-13. The aritprog_gen generator function\n\ndef aritprog_gen(begin, step, end=None): result = type(begin + step)(begin) forever = end is None index = 0 while forever or result < end: yield result index += 1 result = begin + step * index\n\n8 The 17-it-generator/ directory in the Fluent Python code repository includes doctests and a script, arit‐\n\nprog_runner.py, which runs the tests against all variations of the aritprog*.py scripts.\n\nAn Arithmetic Progression Generator\n\n|\n\n617\n\nExample 17-13 is elegant, but always remember: there are plenty of ready-to-use gen‐ erators in the standard library, and the next section will show a shorter implementa‐ tion using the itertools module.\n\nArithmetic Progression with itertools The itertools module in Python 3.10 has 20 generator functions that can be com‐ bined in a variety of interesting ways.\n\nFor example, the itertools.count function returns a generator that yields numbers. Without arguments, it yields a series of integers starting with 0. But you can provide optional start and step values to achieve a result similar to our aritprog_gen functions:\n\n>>> import itertools >>> gen = itertools.count(1, .5) >>> next(gen) 1 >>> next(gen) 1.5 >>> next(gen) 2.0 >>> next(gen) 2.5\n\nitertools.count never stops, so if you call list(count()), Python will try to build a list that would fill all the memory chips ever made. In practice, your machine will become very grumpy long before the call fails.\n\nOn the other hand, there is the itertools.takewhile function: it returns a generator that consumes another generator and stops when a given predicate evaluates to False. So we can combine the two and write this:\n\n>>> gen = itertools.takewhile(lambda n: n < 3, itertools.count(1, .5)) >>> list(gen) [1, 1.5, 2.0, 2.5]\n\nLeveraging takewhile and count, Example 17-14 is even more concise.\n\nExample 17-14. aritprog_v3.py: this works like the previous aritprog_gen functions\n\nimport itertools\n\ndef aritprog_gen(begin, step, end=None): first = type(begin + step)(begin) ap_gen = itertools.count(first, step)\n\n618\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "page_number": 615
    },
    {
      "number": 32,
      "title": "Segment 32 (pages 637-655)",
      "start_page": 637,
      "end_page": 655,
      "detection_method": "synthetic",
      "content": "if end is None: return ap_gen return itertools.takewhile(lambda n: n < end, ap_gen)\n\nNote that aritprog_gen in Example 17-14 is not a generator function: it has no yield in its body. But it returns a generator, just as a generator function does.\n\nHowever, recall that itertools.count adds the step repeatedly, so the floating-point series it produces are not as precise as Example 17-13.\n\nThe point of Example 17-14 is: when implementing generators, know what is avail‐ able in the standard library, otherwise there’s a good chance you’ll reinvent the wheel. That’s why the next section covers several ready-to-use generator functions.\n\nGenerator Functions in the Standard Library The standard library provides many generators, from plain-text file objects providing line-by-line iteration, to the awesome os.walk function, which yields filenames while traversing a directory tree, making recursive filesystem searches as simple as a for loop.\n\nThe os.walk generator function is impressive, but in this section I want to focus on general-purpose functions that take arbitrary iterables as arguments and return gen‐ erators that yield selected, computed, or rearranged items. In the following tables, I summarize two dozen of them, from the built-in, itertools, and functools mod‐ ules. For convenience, I grouped them by high-level functionality, regardless of where they are defined.\n\nThe first group contains the filtering generator functions: they yield a subset of items produced by the input iterable, without changing the items themselves. Like take while, most functions listed in Table 17-1 take a predicate, which is a one-argument Boolean function that will be applied to each item in the input to determine whether the item is included in the output.\n\nTable 17-1. Filtering generator functions\n\nModule\n\nFunction\n\nitertools compress(it, selector_it)\n\nDescription Consumes two iterables in parallel; yields items from it whenever the corresponding item in selector_it is truthy\n\nitertools dropwhile(predicate, it)\n\nConsumes it, skipping items while predicate computes truthy, then yields every remaining item (no further checks are made)\n\n(built-in)\n\nfilter(predicate, it)\n\nApplies predicate to each item of iterable, yielding the item if predicate(item) is truthy; if predicate is None, only truthy items are yielded\n\nGenerator Functions in the Standard Library\n\n|\n\n619\n\nModule\n\nFunction\n\nitertools filterfalse(predicate, it)\n\nDescription Same as filter, with the predicate logic negated: yields items whenever predicate computes falsy\n\nitertools islice(it, stop) or\n\nislice(it, start, stop, step=1)\n\nYields items from a slice of it, similar to s[:stop] or s[start:stop:step] except it can be any iterable, and the operation is lazy\n\nitertools takewhile(predicate, it)\n\nYields items while predicate computes truthy, then stops and no further checks are made\n\nThe console listing in Example 17-15 shows the use of all the functions in Table 17-1.\n\nExample 17-15. Filtering generator functions examples\n\n>>> def vowel(c): ... return c.lower() in 'aeiou' ... >>> list(filter(vowel, 'Aardvark')) ['A', 'a', 'a'] >>> import itertools >>> list(itertools.filterfalse(vowel, 'Aardvark')) ['r', 'd', 'v', 'r', 'k'] >>> list(itertools.dropwhile(vowel, 'Aardvark')) ['r', 'd', 'v', 'a', 'r', 'k'] >>> list(itertools.takewhile(vowel, 'Aardvark')) ['A', 'a'] >>> list(itertools.compress('Aardvark', (1, 0, 1, 1, 0, 1))) ['A', 'r', 'd', 'a'] >>> list(itertools.islice('Aardvark', 4)) ['A', 'a', 'r', 'd'] >>> list(itertools.islice('Aardvark', 4, 7)) ['v', 'a', 'r'] >>> list(itertools.islice('Aardvark', 1, 7, 2)) ['a', 'd', 'a']\n\nThe next group contains the mapping generators: they yield items computed from each individual item in the input iterable—or iterables, in the case of map and star map.9 The generators in Table 17-2 yield one result per item in the input iterables. If the input comes from more than one iterable, the output stops as soon as the first input iterable is exhausted.\n\n9 Here, the term “mapping” is unrelated to dictionaries, but has to do with the map built-in.\n\n620\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nTable 17-2. Mapping generator functions\n\nModule\n\nFunction\n\nitertools accumulate(it,\n\n[func])\n\nDescription Yields accumulated sums; if func is provided, yields the result of applying it to the first pair of items, then to the first result and next item, etc.\n\n(built-in)\n\nenumerate(iterable, start=0)\n\nYields 2-tuples of the form (index, item), where index is counted from start, and item is taken from the iterable\n\n(built-in)\n\nmap(func, it1, [it2, …, itN])\n\nApplies func to each item of it, yielding the result; if N iterables are given, func must take N arguments and the iterables will be consumed in parallel\n\nitertools starmap(func, it)\n\nApplies func to each item of it, yielding the result; the input iterable should yield iterable items iit, and func is applied as func(*iit)\n\nExample 17-16 demonstrates some uses of itertools.accumulate.\n\nExample 17-16. itertools.accumulate generator function examples\n\n>>> sample = [5, 4, 2, 8, 7, 6, 3, 0, 9, 1] >>> import itertools >>> list(itertools.accumulate(sample)) [5, 9, 11, 19, 26, 32, 35, 35, 44, 45] >>> list(itertools.accumulate(sample, min)) [5, 4, 2, 2, 2, 2, 2, 0, 0, 0] >>> list(itertools.accumulate(sample, max)) [5, 5, 5, 8, 8, 8, 8, 8, 9, 9] >>> import operator >>> list(itertools.accumulate(sample, operator.mul)) [5, 20, 40, 320, 2240, 13440, 40320, 0, 0, 0] >>> list(itertools.accumulate(range(1, 11), operator.mul)) [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n\nRunning sum.\n\nRunning minimum.\n\nRunning maximum.\n\nRunning product.\n\nFactorials from 1! to 10!.\n\nThe remaining functions of Table 17-2 are shown in Example 17-17.\n\nExample 17-17. Mapping generator function examples\n\n>>> list(enumerate('albatroz', 1)) [(1, 'a'), (2, 'l'), (3, 'b'), (4, 'a'), (5, 't'), (6, 'r'), (7, 'o'), (8, 'z')]\n\nGenerator Functions in the Standard Library\n\n|\n\n621\n\n>>> import operator >>> list(map(operator.mul, range(11), range(11))) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100] >>> list(map(operator.mul, range(11), [2, 4, 8])) [0, 4, 16] >>> list(map(lambda a, b: (a, b), range(11), [2, 4, 8])) [(0, 2), (1, 4), (2, 8)] >>> import itertools >>> list(itertools.starmap(operator.mul, enumerate('albatroz', 1))) ['a', 'll', 'bbb', 'aaaa', 'ttttt', 'rrrrrr', 'ooooooo', 'zzzzzzzz'] >>> sample = [5, 4, 2, 8, 7, 6, 3, 0, 9, 1] >>> list(itertools.starmap(lambda a, b: b / a, ... enumerate(itertools.accumulate(sample), 1))) [5.0, 4.5, 3.6666666666666665, 4.75, 5.2, 5.333333333333333, 5.0, 4.375, 4.888888888888889, 4.5]\n\nNumber the letters in the word, starting from 1.\n\nSquares of integers from 0 to 10.\n\nMultiplying numbers from two iterables in parallel: results stop when the short‐ est iterable ends.\n\nThis is what the zip built-in function does.\n\nRepeat each letter in the word according to its place in it, starting from 1.\n\nRunning average.\n\nNext, we have the group of merging generators—all of these yield items from multi‐ ple input iterables. chain and chain.from_iterable consume the input iterables sequentially (one after the other), while product, zip, and zip_longest consume the input iterables in parallel. See Table 17-3.\n\nTable 17-3. Generator functions that merge multiple input iterables\n\nModule\n\nFunction\n\nitertools chain(it1, …, itN)\n\nDescription Yields all items from it1, then from it2, etc., seamlessly\n\nitertools chain.from_iterable(it)\n\nYields all items from each iterable produced by it, one after the other, seamlessly; it will be an iterable where the items are also iterables, for example, a list of tuples\n\nitertools product(it1, …, itN, repeat=1)\n\nCartesian product: yields N-tuples made by combining items from each input iterable, like nested for loops could produce; repeat allows the input iterables to be consumed more than once\n\n622\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nModule (built-in)\n\nFunction\n\nzip(it1, …, itN, strict=False)\n\nDescription Yields N-tuples built from items taken from the iterables in parallel, silently stopping when the first iterable is exhausted, unless strict=True is givena\n\nitertools zip_longest(it1, …, itN, fillvalue=None)\n\nYields N-tuples built from items taken from the iterables in parallel, stopping only when the last iterable is exhausted, filling the blanks with the fillvalue\n\na The strict keyword-only argument is new in Python 3.10. When strict=True, ValueError is raised if any iterable has a different length. The default is False, for backward compatibility.\n\nExample 17-18 shows the use of the itertools.chain and zip generator functions and their siblings. Recall that the zip function is named after the zip fastener or zip‐ per (no relation to compression). Both zip and itertools.zip_longest were intro‐ duced in “The Awesome zip” on page 416.\n\nExample 17-18. Merging generator function examples\n\n>>> list(itertools.chain('ABC', range(2))) ['A', 'B', 'C', 0, 1] >>> list(itertools.chain(enumerate('ABC'))) [(0, 'A'), (1, 'B'), (2, 'C')] >>> list(itertools.chain.from_iterable(enumerate('ABC'))) [0, 'A', 1, 'B', 2, 'C'] >>> list(zip('ABC', range(5), [10, 20, 30, 40])) [('A', 0, 10), ('B', 1, 20), ('C', 2, 30)] >>> list(itertools.zip_longest('ABC', range(5))) [('A', 0), ('B', 1), ('C', 2), (None, 3), (None, 4)] >>> list(itertools.zip_longest('ABC', range(5), fillvalue='?')) [('A', 0), ('B', 1), ('C', 2), ('?', 3), ('?', 4)]\n\nGenerator Functions in the Standard Library\n\n|\n\n623\n\nchain is usually called with two or more iterables.\n\nchain does nothing useful when called with a single iterable.\n\nBut chain.from_iterable takes each item from the iterable, and chains them in sequence, as long as each item is itself iterable.\n\nAny number of iterables can be consumed by zip in parallel, but the generator always stops as soon as the first iterable ends. In Python ≥ 3.10, if the strict=True argument is given and an iterable ends before the others, ValueEr ror is raised.\n\nitertools.zip_longest works like zip, except it consumes all input iterables to the end, padding output tuples with None, as needed.\n\nThe fillvalue keyword argument specifies a custom padding value.\n\nThe itertools.product generator is a lazy way of computing Cartesian products, which we built using list comprehensions with more than one for clause in “Cartesian Products” on page 27. Generator expressions with multiple for clauses can also be used to produce Cartesian products lazily. Example 17-19 demonstrates itertools.product.\n\nExample 17-19. itertools.product generator function examples\n\n>>> list(itertools.product('ABC', range(2))) [('A', 0), ('A', 1), ('B', 0), ('B', 1), ('C', 0), ('C', 1)] >>> suits = 'spades hearts diamonds clubs'.split() >>> list(itertools.product('AK', suits)) [('A', 'spades'), ('A', 'hearts'), ('A', 'diamonds'), ('A', 'clubs'), ('K', 'spades'), ('K', 'hearts'), ('K', 'diamonds'), ('K', 'clubs')] >>> list(itertools.product('ABC')) [('A',), ('B',), ('C',)] >>> list(itertools.product('ABC', repeat=2)) [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C', 'C')] >>> list(itertools.product(range(2), repeat=3)) [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)] >>> rows = itertools.product('AB', range(2), repeat=2) >>> for row in rows: print(row) ... ('A', 0, 'A', 0) ('A', 0, 'A', 1) ('A', 0, 'B', 0) ('A', 0, 'B', 1) ('A', 1, 'A', 0)\n\n624\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\n('A', 1, 'A', 1) ('A', 1, 'B', 0) ('A', 1, 'B', 1) ('B', 0, 'A', 0) ('B', 0, 'A', 1) ('B', 0, 'B', 0) ('B', 0, 'B', 1) ('B', 1, 'A', 0) ('B', 1, 'A', 1) ('B', 1, 'B', 0) ('B', 1, 'B', 1)\n\nThe Cartesian product of a str with three characters and a range with two inte‐ gers yields six tuples (because 3 * 2 is 6).\n\nThe product of two card ranks ('AK') and four suits is a series of eight tuples.\n\nGiven a single iterable, product yields a series of one-tuples—not very useful.\n\nThe repeat=N keyword argument tells the product to consume each input itera‐ ble N times.\n\nSome generator functions expand the input by yielding more than one value per input item. They are listed in Table 17-4.\n\nTable 17-4. Generator functions that expand each input item into multiple output items\n\nModule\n\nFunction\n\nitertools combinations(it, out_len)\n\nDescription Yields combinations of out_len items from the items yielded by it\n\nitertools combinations_with_replacement(it,\n\nout_len)\n\nYields combinations of out_len items from the items yielded by it, including combinations with repeated items\n\nitertools count(start=0, step=1)\n\nYields numbers starting at start, incremented by step, indefinitely\n\nitertools cycle(it)\n\nYields items from it, storing a copy of each, then yields the entire sequence repeatedly, indefinitely\n\nitertools pairwise(it)\n\nYields successive overlapping pairs taken from the input iterablea\n\nitertools permutations(it, out_len=None)\n\nYields permutations of out_len items from the items yielded by it; by default, out_len is len(list(it))\n\nitertools repeat(item, [times])\n\nYields the given item repeatedly, indefinitely unless a number of times is given\n\na itertools.pairwise was added in Python 3.10.\n\nGenerator Functions in the Standard Library\n\n|\n\n625\n\nThe count and repeat functions from itertools return generators that conjure items out of nothing: neither of them takes an iterable as input. We saw iter tools.count in “Arithmetic Progression with itertools” on page 618. The cycle generator makes a backup of the input iterable and yields its items repeatedly. Example 17-20 illustrates the use of count, cycle, pairwise, and repeat.\n\nExample 17-20. count, cycle, pairwise, and repeat\n\n>>> ct = itertools.count() >>> next(ct) 0 >>> next(ct), next(ct), next(ct) (1, 2, 3) >>> list(itertools.islice(itertools.count(1, .3), 3)) [1, 1.3, 1.6] >>> cy = itertools.cycle('ABC') >>> next(cy) 'A' >>> list(itertools.islice(cy, 7)) ['B', 'C', 'A', 'B', 'C', 'A', 'B'] >>> list(itertools.pairwise(range(7))) [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] >>> rp = itertools.repeat(7) >>> next(rp), next(rp) (7, 7) >>> list(itertools.repeat(8, 4)) [8, 8, 8, 8] >>> list(map(operator.mul, range(11), itertools.repeat(5))) [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]\n\nBuild a count generator ct.\n\nRetrieve the first item from ct.\n\nI can’t build a list from ct, because ct never stops, so I fetch the next three items.\n\nI can build a list from a count generator if it is limited by islice or takewhile.\n\nBuild a cycle generator from 'ABC' and fetch its first item, 'A'.\n\nA list can only be built if limited by islice; the next seven items are retrieved here.\n\nFor each item in the input, pairwise yields a 2-tuple with that item and the next —if there is a next item. Available in Python ≥ 3.10.\n\n626\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nBuild a repeat generator that will yield the number 7 forever.\n\nA repeat generator can be limited by passing the times argument: here the num‐ ber 8 will be produced 4 times.\n\nA common use of repeat: providing a fixed argument in map; here it provides the 5 multiplier.\n\nThe combinations, combinations_with_replacement, and permutations generator functions—together with product—are called the combinatorics generators in the itertools documentation page. There is a close relationship between iter tools.product and the remaining combinatoric functions as well, as Example 17-21 shows.\n\nExample 17-21. Combinatoric generator functions yield multiple values per input item\n\n>>> list(itertools.combinations('ABC', 2)) [('A', 'B'), ('A', 'C'), ('B', 'C')] >>> list(itertools.combinations_with_replacement('ABC', 2)) [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')] >>> list(itertools.permutations('ABC', 2)) [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')] >>> list(itertools.product('ABC', repeat=2)) [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C', 'C')]\n\nAll combinations of len()==2 from the items in 'ABC'; item ordering in the gen‐ erated tuples is irrelevant (they could be sets).\n\nAll combinations of len()==2 from the items in 'ABC', including combinations with repeated items.\n\nAll permutations of len()==2 from the items in 'ABC'; item ordering in the gen‐ erated tuples is relevant.\n\nCartesian product from 'ABC' and 'ABC' (that’s the effect of repeat=2).\n\nThe last group of generator functions we’ll cover in this section are designed to yield all items in the input iterables, but rearranged in some way. Here are two functions that return multiple generators: itertools.groupby and itertools.tee. The other generator function in this group, the reversed built-in, is the only one covered in this section that does not accept any iterable as input, but only sequences. This makes sense: because reversed will yield the items from last to first, it only works with a sequence with a known length. But it avoids the cost of making a reversed copy of the\n\nGenerator Functions in the Standard Library\n\n|\n\n627\n\nsequence by yielding each item as needed. I put the itertools.product function together with the merging generators in Table 17-3 because they all consume more than one iterable, while the generators in Table 17-5 all accept at most one input iterable.\n\nTable 17-5. Rearranging generator functions\n\nModule\n\nFunction\n\nitertools groupby(it,\n\nkey=None)\n\nDescription Yields 2-tuples of the form (key, group), where key is the grouping criterion and group is a generator yielding the items in the group\n\n(built-in)\n\nreversed(seq)\n\nYields items from seq in reverse order, from last to first; seq must be a sequence or implement the __reversed__ special method\n\nitertools tee(it, n=2)\n\nYields a tuple of n generators, each yielding the items of the input iterable independently\n\nExample 17-22 demonstrates the use of itertools.groupby and the reversed built- in. Note that itertools.groupby assumes that the input iterable is sorted by the grouping criterion, or at least that the items are clustered by that criterion—even if not completely sorted. Tech reviewer Miroslav Šedivý suggested this use case: you can sort the datetime objects chronologically, then groupby weekday to get a group of Monday data, followed by Tuesday data, etc., and then by Monday (of the next week) again, and so on.\n\nExample 17-22. itertools.groupby\n\n>>> list(itertools.groupby('LLLLAAGGG')) [('L', <itertools._grouper object at 0x102227cc0>), ('A', <itertools._grouper object at 0x102227b38>), ('G', <itertools._grouper object at 0x102227b70>)] >>> for char, group in itertools.groupby('LLLLAAAGG'): ... print(char, '->', list(group)) ... L -> ['L', 'L', 'L', 'L'] A -> ['A', 'A',] G -> ['G', 'G', 'G'] >>> animals = ['duck', 'eagle', 'rat', 'giraffe', 'bear', ... 'bat', 'dolphin', 'shark', 'lion'] >>> animals.sort(key=len) >>> animals ['rat', 'bat', 'duck', 'bear', 'lion', 'eagle', 'shark', 'giraffe', 'dolphin'] >>> for length, group in itertools.groupby(animals, len): ... print(length, '->', list(group)) ... 3 -> ['rat', 'bat'] 4 -> ['duck', 'bear', 'lion'] 5 -> ['eagle', 'shark']\n\n628\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\n7 -> ['giraffe', 'dolphin'] >>> for length, group in itertools.groupby(reversed(animals), len): ... print(length, '->', list(group)) ... 7 -> ['dolphin', 'giraffe'] 5 -> ['shark', 'eagle'] 4 -> ['lion', 'bear', 'duck'] 3 -> ['bat', 'rat'] >>>\n\ngroupby yields tuples of (key, group_generator).\n\nHandling groupby generators involves nested iteration: in this case, the outer for loop and the inner list constructor.\n\nSort animals by length.\n\nAgain, loop over the key and group pair, to display the key and expand the group into a list.\n\nHere the reverse generator iterates over animals from right to left.\n\nThe last of the generator functions in this group is iterator.tee, which has a unique behavior: it yields multiple generators from a single input iterable, each yielding every item from the input. Those generators can be consumed independently, as shown in Example 17-23.\n\nExample 17-23. itertools.tee yields multiple generators, each yielding every item of the input generator\n\n>>> list(itertools.tee('ABC')) [<itertools._tee object at 0x10222abc8>, <itertools._tee object at 0x10222ac08>] >>> g1, g2 = itertools.tee('ABC') >>> next(g1) 'A' >>> next(g2) 'A' >>> next(g2) 'B' >>> list(g1) ['B', 'C'] >>> list(g2) ['C'] >>> list(zip(*itertools.tee('ABC'))) [('A', 'A'), ('B', 'B'), ('C', 'C')]\n\nGenerator Functions in the Standard Library\n\n|\n\n629\n\nNote that several examples in this section used combinations of generator functions. This is a great feature of these functions: because they take generators as arguments and return generators, they can be combined in many different ways.\n\nNow we’ll review another group of iterable-savvy functions in the standard library.\n\nIterable Reducing Functions The functions in Table 17-6 all take an iterable and return a single result. They are known as “reducing,” “folding,” or “accumulating” functions. We can implement every one of the built-ins listed here with functools.reduce, but they exist as built- ins because they address some common use cases more easily. A longer explanation about functools.reduce appeared in “Vector Take #4: Hashing and a Faster ==” on page 411.\n\nIn the case of all and any, there is an important optimization functools.reduce does not support: all and any short-circuit—i.e., they stop consuming the iterator as soon as the result is determined. See the last test with any in Example 17-24.\n\nTable 17-6. Built-in functions that read iterables and return single values\n\nModule (built-in)\n\nFunction\n\nall(it)\n\nDescription Returns True if all items in it are truthy, otherwise False; all([]) returns True\n\n(built-in)\n\n(built-in)\n\n(built-in)\n\nany(it)\n\nmax(it, [key=,] [default=])\n\nmin(it, [key=,] [default=])\n\nReturns True if any item in it is truthy, otherwise False; any([]) returns False Returns the maximum value of the items in it;a key is an ordering function, as in sorted; default is returned if the iterable is empty Returns the minimum value of the items in it.b key is an ordering function, as in sorted; default is returned if the iterable is empty\n\nfunctools reduce(func, it, [ini\n\ntial])\n\nReturns the result of applying func to the first pair of items, then to that result and the third item, and so on; if given, initial forms the initial pair with the first item\n\n(built-in)\n\nsum(it, start=0)\n\nThe sum of all items in it, with the optional start value added (use math.fsum for better precision when adding floats)\n\na May also be called as max(arg1, arg2, …, [key=?]), in which case the maximum among the arguments is returned. b May also be called as min(arg1, arg2, …, [key=?]), in which case the minimum among the arguments is returned.\n\nThe operation of all and any is exemplified in Example 17-24.\n\n630\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nExample 17-24. Results of all and any for some sequences\n\n>>> all([1, 2, 3]) True >>> all([1, 0, 3]) False >>> all([]) True >>> any([1, 2, 3]) True >>> any([1, 0, 3]) True >>> any([0, 0.0]) False >>> any([]) False >>> g = (n for n in [0, 0.0, 7, 8]) >>> any(g) True >>> next(g) 8\n\nany iterated over g until g yielded 7; then any stopped and returned True.\n\nThat’s why 8 was still remaining.\n\nAnother built-in that takes an iterable and returns something else is sorted. Unlike reversed, which is a generator function, sorted builds and returns a new list. After all, every single item of the input iterable must be read so they can be sorted, and the sorting happens in a list, therefore sorted just returns that list after it’s done. I mention sorted here because it does consume an arbitrary iterable.\n\nOf course, sorted and the reducing functions only work with iterables that eventually stop. Otherwise, they will keep on collecting items and never return a result.\n\nIf you’ve gotten this far, you’ve seen the most important and useful content of this chapter. The remaining sections cover advanced generator features that most of us don’t see or need very often, such as the yield from construct and classic coroutines.\n\nThere are also sections about type hinting iterables, iterators, and classic coroutines.\n\nThe yield from syntax provides a new way of combining generators. That’s next.\n\nIterable Reducing Functions\n\n|\n\n631\n\nSubgenerators with yield from The yield from expression syntax was introduced in Python 3.3 to allow a generator to delegate work to a subgenerator.\n\nBefore yield from was introduced, we used a for loop when a generator needed to yield values produced from another generator:\n\n>>> def sub_gen(): ... yield 1.1 ... yield 1.2 ... >>> def gen(): ... yield 1 ... for i in sub_gen(): ... yield i ... yield 2 ... >>> for x in gen(): ... print(x) ... 1 1.1 1.2 2\n\nWe can get the same result using yield from, as you can see in Example 17-25.\n\nExample 17-25. Test-driving yield from\n\n>>> def sub_gen(): ... yield 1.1 ... yield 1.2 ... >>> def gen(): ... yield 1 ... yield from sub_gen() ... yield 2 ... >>> for x in gen(): ... print(x) ... 1 1.1 1.2 2\n\nIn Example 17-25, the for loop is the client code, gen is the delegating generator, and sub_gen is the subgenerator. Note that yield from pauses gen, and sub_gen takes over until it is exhausted. The values yielded by sub_gen pass through gen directly to\n\n632\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nthe client for loop. Meanwhile, gen is suspended and cannot see the values passing through it. Only when sub_gen is done, gen resumes.\n\nWhen the subgenerator contains a return statement with a value, that value can be captured in the delegating generator by using yield from as part of an expression. Example 17-26 demonstrates.\n\nExample 17-26. yield from gets the return value of the subgenerator\n\n>>> def sub_gen(): ... yield 1.1 ... yield 1.2 ... return 'Done!' ... >>> def gen(): ... yield 1 ... result = yield from sub_gen() ... print('<--', result) ... yield 2 ... >>> for x in gen(): ... print(x) ... 1 1.1 1.2 <-- Done! 2\n\nNow that we’ve seen the basics of yield from, let’s study a couple of simple but prac‐ tical examples of its use.\n\nReinventing chain We saw in Table 17-3 that itertools provides a chain generator that yields items from several iterables, iterating over the first, then the second, and so on up to the last. This is a homemade implementation of chain with nested for loops in Python:10\n\n>>> def chain(*iterables): ... for it in iterables: ... for i in it: ... yield i ... >>> s = 'ABC' >>> r = range(3)\n\n10 chain and most itertools functions are written in C.\n\nSubgenerators with yield from\n\n|\n\n633\n\n>>> list(chain(s, r)) ['A', 'B', 'C', 0, 1, 2]\n\nThe chain generator in the preceding code is delegating to each iterable it in turn, by driving each it in the inner for loop. That inner loop can be replaced with a yield from expression, as shown in the next console listing:\n\n>>> def chain(*iterables): ... for i in iterables: ... yield from i ... >>> list(chain(s, t)) ['A', 'B', 'C', 0, 1, 2]\n\nThe use of yield from in this example is correct, and the code reads better, but it seems like syntactic sugar with little real gain. Now let’s develop a more interesting example.\n\nTraversing a Tree In this section, we’ll see yield from in a script to traverse a tree structure. I will build it in baby steps.\n\nThe tree structure for this example is Python’s exception hierarchy. But the pattern can be adapted to show a directory tree or any other tree structure.\n\nStarting from BaseException at level zero, the exception hierarchy is five levels deep as of Python 3.10. Our first baby step is to show level zero.\n\nGiven a root class, the tree generator in Example 17-27 yields its name and stops.\n\nExample 17-27. tree/step0/tree.py: yield the name of the root class and stop\n\ndef tree(cls): yield cls.__name__\n\ndef display(cls): for cls_name in tree(cls): print(cls_name)\n\nif __name__ == '__main__': display(BaseException)\n\nThe output of Example 17-27 is just one line:\n\nBaseException\n\n634\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nThe next baby step takes us to level 1. The tree generator will yield the name of the root class and the names of each direct subclass. The names of the subclasses are indented to reveal the hierarchy. This is the output we want:\n\n$ python3 tree.py BaseException Exception GeneratorExit SystemExit KeyboardInterrupt\n\nExample 17-28 produces that output.\n\nExample 17-28. tree/step1/tree.py: yield the name of root class and direct subclasses\n\ndef tree(cls): yield cls.__name__, 0 for sub_cls in cls.__subclasses__(): yield sub_cls.__name__, 1\n\ndef display(cls): for cls_name, level in tree(cls): indent = ' ' * 4 * level print(f'{indent}{cls_name}')\n\nif __name__ == '__main__': display(BaseException)\n\nTo support the indented output, yield the name of the class and its level in the hierarchy.\n\nUse the __subclasses__ special method to get a list of subclasses.\n\nYield name of subclass and level 1.\n\nBuild indentation string of 4 spaces times level. At level zero, this will be an empty string.\n\nIn Example 17-29, I refactor tree to separate the special case of the root class from the subclasses, which are now handled in the sub_tree generator. At yield from, the tree generator is suspended, and sub_tree takes over yielding values.\n\nSubgenerators with yield from\n\n|\n\n635\n\nExample 17-29. tree/step2/tree.py: tree yields the root class name, then delegates to sub_tree\n\ndef tree(cls): yield cls.__name__, 0 yield from sub_tree(cls)\n\ndef sub_tree(cls): for sub_cls in cls.__subclasses__(): yield sub_cls.__name__, 1\n\ndef display(cls): for cls_name, level in tree(cls): indent = ' ' * 4 * level print(f'{indent}{cls_name}')\n\nif __name__ == '__main__': display(BaseException)\n\nDelegate to sub_tree to yield the names of the subclasses.\n\nYield the name of each subclass and level 1. Because of the yield from sub_tree(cls) inside tree, these values bypass the tree generator function completely…\n\n… and are received directly here.\n\nIn keeping with the baby steps method, I’ll write the simplest code I can imagine to reach level 2. For depth-first tree traversal, after yielding each node in level 1, I want to yield the children of that node in level 2, before resuming level 1. A nested for loop takes care of that, as in Example 17-30.\n\nExample 17-30. tree/step3/tree.py: sub_tree traverses levels 1 and 2 depth-first\n\ndef tree(cls): yield cls.__name__, 0 yield from sub_tree(cls)\n\ndef sub_tree(cls): for sub_cls in cls.__subclasses__(): yield sub_cls.__name__, 1 for sub_sub_cls in sub_cls.__subclasses__(): yield sub_sub_cls.__name__, 2\n\n636\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\ndef display(cls): for cls_name, level in tree(cls): indent = ' ' * 4 * level print(f'{indent}{cls_name}')\n\nif __name__ == '__main__': display(BaseException)\n\nThis is the result of running step3/tree.py from Example 17-30:\n\n$ python3 tree.py BaseException Exception TypeError StopAsyncIteration StopIteration ImportError OSError EOFError RuntimeError NameError AttributeError SyntaxError LookupError ValueError AssertionError ArithmeticError SystemError ReferenceError MemoryError BufferError Warning GeneratorExit SystemExit KeyboardInterrupt\n\nYou may already know where this is going, but I will stick to baby steps one more time: let’s reach level 3 by adding yet another nested for loop. The rest of the pro‐ gram is unchanged, so Example 17-31 shows only the sub_tree generator.\n\nExample 17-31. sub_tree generator from tree/step4/tree.py\n\ndef sub_tree(cls): for sub_cls in cls.__subclasses__(): yield sub_cls.__name__, 1 for sub_sub_cls in sub_cls.__subclasses__(): yield sub_sub_cls.__name__, 2 for sub_sub_sub_cls in sub_sub_cls.__subclasses__(): yield sub_sub_sub_cls.__name__, 3\n\nSubgenerators with yield from\n\n|\n\n637",
      "page_number": 637
    },
    {
      "number": 33,
      "title": "Segment 33 (pages 656-676)",
      "start_page": 656,
      "end_page": 676,
      "detection_method": "synthetic",
      "content": "There is a clear pattern in Example 17-31. We do a for loop to get the subclasses of level N. Each time around the loop, we yield a subclass of level N, then start another for loop to visit level N+1.\n\nIn “Reinventing chain” on page 633, we saw how we can replace a nested for loop driving a generator with yield from on the same generator. We can apply that idea here, if we make sub_tree accept a level parameter, and yield from it recursively, passing the current subclass as the new root class with the next level number. See Example 17-32.\n\nExample 17-32. tree/step5/tree.py: recursive sub_tree goes as far as memory allows\n\ndef tree(cls): yield cls.__name__, 0 yield from sub_tree(cls, 1)\n\ndef sub_tree(cls, level): for sub_cls in cls.__subclasses__(): yield sub_cls.__name__, level yield from sub_tree(sub_cls, level+1)\n\ndef display(cls): for cls_name, level in tree(cls): indent = ' ' * 4 * level print(f'{indent}{cls_name}')\n\nif __name__ == '__main__': display(BaseException)\n\nExample 17-32 can traverse trees of any depth, limited only by Python’s recursion limit. The default limit allows 1,000 pending functions.\n\nAny good tutorial about recursion will stress the importance of having a base case to avoid infinite recursion. A base case is a conditional branch that returns without making a recursive call. The base case is often implemented with an if statement. In Example 17-32, sub_tree has no if, but there is an implicit conditional in the for loop: if cls.__subclasses__() returns an empty list, the body of the loop is not exe‐ cuted, therefore no recursive call happens. The base case is when the cls class has no subclasses. In that case, sub_tree yields nothing. It just returns.\n\nExample 17-32 works as intended, but we can make it more concise by recalling the pattern we observed when we reached level 3 (Example 17-31): we yield a subclass with level N, then start a nested for loop to visit level N+1. In Example 17-32 we\n\n638\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nreplaced that nested loop with yield from. Now we can merge tree and sub_tree into a single generator. Example 17-33 is the last step for this example.\n\nExample 17-33. tree/step6/tree.py: recursive calls of tree pass an incremented level argument\n\ndef tree(cls, level=0): yield cls.__name__, level for sub_cls in cls.__subclasses__(): yield from tree(sub_cls, level+1)\n\ndef display(cls): for cls_name, level in tree(cls): indent = ' ' * 4 * level print(f'{indent}{cls_name}')\n\nif __name__ == '__main__': display(BaseException)\n\nAt the start of “Subgenerators with yield from” on page 632, we saw how yield from connects the subgenerator directly to the client code, bypassing the delegating gener‐ ator. That connection becomes really important when generators are used as corou‐ tines and not only produce but also consume values from the client code, as we’ll see in “Classic Coroutines” on page 641.\n\nAfter this first encounter with yield from, let’s turn to type hinting iterables and iterators.\n\nGeneric Iterable Types Python’s standard library has many functions that accept iterable arguments. In your code, such functions can be annotated like the zip_replace function we saw in Example 8-15, using collections.abc.Iterable (or typing.Iterable if you must support Python 3.8 or earlier, as explained in “Legacy Support and Deprecated Col‐ lection Types” on page 272). See Example 17-34.\n\nExample 17-34. replacer.py returns an iterator of tuples of strings\n\nfrom collections.abc import Iterable\n\nFromTo = tuple[str, str]\n\ndef zip_replace(text: str, changes: Iterable[FromTo]) -> str: for from_, to in changes:\n\nGeneric Iterable Types\n\n|\n\n639\n\ntext = text.replace(from_, to) return text\n\nDefine type alias; not required, but makes the next type hint more readable. Starting with Python 3.10, FromTo should have a type hint of typing.TypeAlias to clarify the reason for this line: FromTo: TypeAlias = tuple[str, str].\n\nAnnotate changes to accept an Iterable of FromTo tuples.\n\nIterator types don’t appear as often as Iterable types, but they are also simple to write. Example 17-35 shows the familiar Fibonacci generator, annotated.\n\nExample 17-35. fibo_gen.py: fibonacci returns a generator of integers\n\nfrom collections.abc import Iterator\n\ndef fibonacci() -> Iterator[int]: a, b = 0, 1 while True: yield a a, b = b, a + b\n\nNote that the type Iterator is used for generators coded as functions with yield, as well as iterators written “by hand” as classes with __next__. There is also a collec tions.abc.Generator type (and the corresponding deprecated typing.Generator) that we can use to annotate generator objects, but it is needlessly verbose for genera‐ tors used as iterators.\n\nExample 17-36, when checked with Mypy, reveals that the Iterator type is really a simplified special case of the Generator type.\n\nExample 17-36. itergentype.py: two ways to annotate iterators\n\nfrom collections.abc import Iterator from keyword import kwlist from typing import TYPE_CHECKING\n\nshort_kw = (k for k in kwlist if len(k) < 5)\n\nif TYPE_CHECKING: reveal_type(short_kw)\n\nlong_kw: Iterator[str] = (k for k in kwlist if len(k) >= 4)\n\nif TYPE_CHECKING: reveal_type(long_kw)\n\n640\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nGenerator expression that yields Python keywords with less than 5 characters.\n\nMypy infers: typing.Generator[builtins.str*, None, None].11\n\nThis also yields strings, but I added an explicit type hint.\n\nRevealed type: typing.Iterator[builtins.str].\n\nabc.Iterator[str] is consistent-with abc.Generator[str, None, None], therefore Mypy issues no errors for type checking in Example 17-36.\n\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nClassic Coroutines\n\nPEP 342—Coroutines via Enhanced Generators introduced the .send() and other features that made it possible to use genera‐ tors as coroutines. PEP 342 uses the word “coroutine” with the same meaning I am using here.\n\nIt is unfortunate that Python’s official documentation and standard library now use inconsistent terminology to refer to generators used as coroutines, forcing me to adopt the “classic coroutine” qualifier to contrast with the newer “native coroutine” objects.\n\nAfter Python 3.5 came out, the trend is to use “coroutine” as a syn‐ onym for “native coroutine.” But PEP 342 is not deprecated, and classic coroutines still work as originally designed, although they are no longer supported by asyncio.\n\nUnderstanding classic coroutines in Python is confusing because they are actually generators used in a different way. So let’s step back and consider another feature of Python that can be used in two ways.\n\nWe saw in “Tuples Are Not Just Immutable Lists” on page 30 that we can use tuple instances as records or as immutable sequences. When used as a record, a tuple is expected to have a specific number of items, and each item may have a different type. When used as immutable lists, a tuple can have any length, and all items are expected to have the same type. That’s why there are two different ways to annotate tuples with type hints:\n\n11 As of version 0.910, Mypy still uses the deprecated typing types.\n\nClassic Coroutines\n\n|\n\n641\n\n# A city record with name, country, and population: city: tuple[str, str, int]\n\n# An immutable sequence of domain names: domains: tuple[str, ...]\n\nSomething similar happens with generators. They are commonly used as iterators, but they can also be used as coroutines. A coroutine is really a generator function, created with the yield keyword in its body. And a coroutine object is physically a generator object. Despite sharing the same underlying implementation in C, the use cases of generators and coroutines in Python are so different that there are two ways to type hint them:\n\n# The `readings` variable can be bound to an iterator # or generator object that yields `float` items: readings: Iterator[float]\n\n# The `sim_taxi` variable can be bound to a coroutine # representing a taxi cab in a discrete event simulation. # It yields events, receives `float` timestamps, and returns # the number of trips made during the simulation: sim_taxi: Generator[Event, float, int]\n\nAdding to the confusion, the typing module authors decided to name that type Gen erator, when in fact it describes the API of a generator object intended to be used as a coroutine, while generators are more often used as simple iterators.\n\nThe typing documentation describes the formal type parameters of Generator like this:\n\nGenerator[YieldType, SendType, ReturnType]\n\nThe SendType is only relevant when the generator is used as a coroutine. That type parameter is the type of x in the call gen.send(x). It is an error to call .send() on a generator that was coded to behave as an iterator instead of a coroutine. Likewise, ReturnType is only meaningful to annotate a coroutine, because iterators don’t return values like regular functions. The only sensible operation on a generator used as an iterator is to call next(it) directly or indirectly via for loops and other forms of iter‐ ation. The YieldType is the type of the value returned by a call to next(it).\n\nThe Generator type has the same type parameters as typing.Coroutine:\n\nCoroutine[YieldType, SendType, ReturnType]\n\nThe typing.Coroutine documentation actually says: “The variance and order of type variables correspond to those of Generator.” But typing.Coroutine (deprecated) and collections.abc.Coroutine (generic since Python 3.9) are intended to anno‐ tate only native coroutines, not classic coroutines. If you want to use type hints with\n\n642\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nclassic coroutines, you’ll suffer through the confusion of annotating them as Genera tor[YieldType, SendType, ReturnType].\n\nDavid Beazley created some of the best talks and most comprehensive workshops about classic coroutines. In his PyCon 2009 course handout, he has a slide titled “Keeping It Straight,” which reads:\n\nGenerators produce data for iteration\n\nCoroutines are consumers of data\n\nTo keep your brain from exploding, don’t mix the two concepts together\n\nCoroutines are not related to iteration\n\nNote: There is a use of having `yield` produce a value in a coroutine, but it’s not tied to iteration.12\n\nNow let’s see how classic coroutines work.\n\nExample: Coroutine to Compute a Running Average While discussing closures in Chapter 9, we studied objects to compute a running average. Example 9-7 shows a class and Example 9-13 presents a higher-order func‐ tion returning a function that keeps the total and count variables across invocations in a closure. Example 17-37 shows how to do the same with a coroutine.13\n\nExample 17-37. coroaverager.py: coroutine to compute a running average\n\nfrom collections.abc import Generator\n\ndef averager() -> Generator[float, float, None]: total = 0.0 count = 0 average = 0.0 while True: term = yield average total += term count += 1 average = total/count\n\n12 Slide 33, “Keeping It Straight,” in “A Curious Course on Coroutines and Concurrency”.\n\n13 This example is inspired by a snippet from Jacob Holm in the Python-ideas list, message titled “Yield-From: Finalization guarantees”. Some variations appear later in the thread, and Holm further explains his thinking in message 003912.\n\nClassic Coroutines\n\n|\n\n643\n\nThis function returns a generator that yields float values, accepts float values via .send(), and does not return a useful value.14\n\nThis infinite loop means the coroutine will keep on yielding averages as long as the client code sends values.\n\nThe yield statement here suspends the coroutine, yields a result to the client, and—later—gets a value sent by the caller to the coroutine, starting another iter‐ ation of the infinite loop.\n\nIn a coroutine, total and count can be local variables: no instance attributes or clo‐ sures are needed to keep the context while the coroutine is suspended waiting for the next .send(). That’s why coroutines are attractive replacements for callbacks in asyn‐ chronous programming—they keep local state between activations.\n\nExample 17-38 runs doctests to show the averager coroutine in operation.\n\nExample 17-38. coroaverager.py: doctest for the running average coroutine in Example 17-37\n\n>>> coro_avg = averager() >>> next(coro_avg) 0.0 >>> coro_avg.send(10) 10.0 >>> coro_avg.send(30) 20.0 >>> coro_avg.send(5) 15.0\n\nCreate the coroutine object.\n\nStart the coroutine. This yields the initial value of average: 0.0.\n\nNow we are in business: each call to .send() yields the current average.\n\nIn Example 17-38, the call next(coro_avg) makes the coroutine advance to the yield, yielding the initial value for average. You can also start the coroutine by call‐ ing coro_avg.send(None)—this is actually what the next() built-in does. But you can’t send any value other than None, because the coroutine can only accept a sent\n\n14 In fact, it never returns unless some exception breaks the loop. Mypy 0.910 accepts both None and typing .NoReturn as the generator return type parameter—but it also accepts str in that position, so apparently it can’t fully analyze the coroutine code at this time.\n\n644\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nvalue when it is suspended at a yield line. Calling next() or .send(None) to advance to the first yield is known as “priming the coroutine.”\n\nAfter each activation, the coroutine is suspended precisely at the yield keyword, waiting for a value to be sent. The line coro_avg.send(10) provides that value, caus‐ ing the coroutine to activate. The yield expression resolves to the value 10, assigning it to the term variable. The rest of the loop updates the total, count, and average variables. The next iteration in the while loop yields the average, and the coroutine is again suspended at the yield keyword.\n\nThe attentive reader may be anxious to know how the execution of an averager instance (e.g., coro_avg) may be terminated, because its body is an infinite loop. We don’t usually need to terminate a generator, because it is garbage collected as soon as there are no more valid references to it. If you need to explicitly terminate it, use the .close() method, as shown in Example 17-39.\n\nExample 17-39. coroaverager.py: continuing from Example 17-38\n\n>>> coro_avg.send(20) 16.25 >>> coro_avg.close() >>> coro_avg.close() >>> coro_avg.send(5) Traceback (most recent call last): ... StopIteration\n\ncoro_avg is the instance created in Example 17-38.\n\nThe .close() method raises GeneratorExit at the suspended yield expression. If not handled in the coroutine function, the exception terminates it. Generator Exit is caught by the generator object that wraps the coroutine—that’s why we don’t see it.\n\nCalling .close() on a previously closed coroutine has no effect.\n\nTrying .send() on a closed coroutine raises StopIteration.\n\nBesides the .send() method, PEP 342—Coroutines via Enhanced Generators also introduced a way for a coroutine to return a value. The next section shows how.\n\nClassic Coroutines\n\n|\n\n645\n\nReturning a Value from a Coroutine We’ll now study another coroutine to compute an average. This version will not yield partial results. Instead, it returns a tuple with the number of terms and the average. I’ve split the listing in two parts: Example 17-40 and Example 17-41.\n\nExample 17-40. coroaverager2.py: top of the file\n\nfrom collections.abc import Generator from typing import Union, NamedTuple\n\nclass Result(NamedTuple): count: int # type: ignore average: float\n\nclass Sentinel: def __repr__(self): return f'<Sentinel>'\n\nSTOP = Sentinel()\n\nSendType = Union[float, Sentinel]\n\nThe averager2 coroutine in Example 17-41 will return an instance of Result.\n\nThe Result is actually a subclass of tuple, which has a .count() method that I don’t need. The # type: ignore comment prevents Mypy from complaining about having a count field.15\n\nA class to make a sentinel value with a readable __repr__.\n\nThe sentinel value that I’ll use to make the coroutine stop collecting data and return a result.\n\nI’ll use this type alias for the second type parameter of the coroutine Generator return type, the SendType parameter.\n\nThe SendType definition also works in Python 3.10, but if you don’t need to support earlier versions, it is better to write it like this, after importing TypeAlias from typing:\n\n15 I considered renaming the field, but count is the best name for the local variable in the coroutine, and is the name I used for this variable in similar examples in the book, so it makes sense to use the same name in the Result field. I don’t hesitate to use # type: ignore to avoid the limitations and annoyances of static type checkers when submission to the tool would make the code worse or needlessly complicated.\n\n646\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nSendType: TypeAlias = float | Sentinel\n\nUsing | instead of typing.Union is so concise and readable that I’d probably not cre‐ ate that type alias, but instead I’d write the signature of averager2 like this:\n\ndef averager2(verbose: bool=False) -> Generator[None, float | Sentinel, Result]:\n\nNow, let’s study the coroutine code itself (Example 17-41).\n\nExample 17-41. coroaverager2.py: a coroutine that returns a result value\n\ndef averager2(verbose: bool = False) -> Generator[None, SendType, Result]: total = 0.0 count = 0 average = 0.0 while True: term = yield if verbose: print('received:', term) if isinstance(term, Sentinel): break total += term count += 1 average = total / count return Result(count, average)\n\nFor this coroutine, the yield type is None because it does not yield data. It receives data of the SendType and returns a Result tuple when done.\n\nUsing yield like this only makes sense in coroutines, which are designed to con‐ sume data. This yields None, but receives a term from .send(term).\n\nIf the term is a Sentinel, break from the loop. Thanks to this isinstance check…\n\n…Mypy allows me to add term to the total without flagging an error that I can’t add a float to an object that may be a float or a Sentinel.\n\nThis line will be reached only if a Sentinel is sent to the coroutine.\n\nNow let’s see how we can use this coroutine, starting with a simple example that doesn’t actually produce a result (Example 17-42).\n\nExample 17-42. coroaverager2.py: doctest showing .cancel()\n\n>>> coro_avg = averager2() >>> next(coro_avg) >>> coro_avg.send(10)\n\nClassic Coroutines\n\n|\n\n647\n\n>>> coro_avg.send(30) >>> coro_avg.send(6.5) >>> coro_avg.close()\n\nRecall that averager2 does not yield partial results. It yields None, which Python’s console omits.\n\nCalling .close() in this coroutine makes it stop but does not return a result, because the GeneratorExit exception is raised at the yield line in the coroutine, so the return statement is never reached.\n\nNow let’s make it work in Example 17-43.\n\nExample 17-43. coroaverager2.py: doctest showing StopIteration with a Result\n\n>>> coro_avg = averager2() >>> next(coro_avg) >>> coro_avg.send(10) >>> coro_avg.send(30) >>> coro_avg.send(6.5) >>> try: ... coro_avg.send(STOP) ... except StopIteration as exc: ... result = exc.value ... >>> result Result(count=3, average=15.5)\n\nSending the STOP sentinel makes the coroutine break from the loop and return a Result. The generator object that wraps the coroutine then raises StopItera tion.\n\nThe StopIteration instance has a value attribute bound to the value of the return statement that terminated the coroutine.\n\nBelieve it or not!\n\nThis idea of “smuggling” the return value out of the coroutine wrapped in a StopIter ation exception is a bizarre hack. Nevertheless, this bizarre hack is part of PEP 342— Coroutines via Enhanced Generators, and is documented with the StopIteration exception, and in the “Yield expressions” section of Chapter 6 of The Python Lan‐ guage Reference.\n\nA delegating generator can get the return value of a coroutine directly using the yield from syntax, as shown in Example 17-44.\n\n648\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nExample 17-44. coroaverager2.py: doctest showing StopIteration with a Result\n\n>>> def compute(): ... res = yield from averager2(True) ... print('computed:', res) ... return res ... >>> comp = compute() >>> for v in [None, 10, 20, 30, STOP]: ... try: ... comp.send(v) ... except StopIteration as exc: ... result = exc.value received: 10 received: 20 received: 30 received: <Sentinel> computed: Result(count=3, average=20.0) >>> result Result(count=3, average=20.0)\n\nres will collect the return value of averager2; the yield from machinery retrieves the return value when it handles the StopIteration exception that marks the termination of the coroutine. When True, the verbose parameter makes the coroutine print the value received, to make its operation visible.\n\nKeep an eye out for the output of this line when this generator runs.\n\nReturn the result. This will also be wrapped in StopIteration.\n\nCreate the delegating coroutine object.\n\nThis loop will drive the delegating coroutine.\n\nFirst value sent is None, to prime the coroutine; last is the sentinel to stop it.\n\nCatch StopIteration to fetch the return value of compute.\n\nAfter the lines output by averager2 and compute, we get the Result instance.\n\nEven though the examples here don’t do much, the code is hard to follow. Driving the coroutine with .send() calls and retrieving results is complicated, except with yield from—but we can only use that syntax inside a delegating generator/corou‐ tine, which must ultimately be driven by some nontrivial code, as shown in Example 17-44.\n\nClassic Coroutines\n\n|\n\n649\n\nThe previous examples show that using coroutines directly is cumbersome and con‐ fusing. Add exception handling and the coroutine .throw() method, and examples become even more convoluted. I won’t cover .throw() in this book because— like .send()—it is only useful to drive coroutines “by hand,” but I don’t recommend doing that, unless you are creating a new coroutine-based framework from scratch.\n\nIf you are interested in deeper coverage of classic coroutines— including the .throw() method—please check out “Classic Corou‐ tines” at the fluentpython.com companion website. That post includes Python-like pseudocode detailing how yield from drives generators and coroutines, as well as a a small discrete event simu‐ lation demonstrating a form of concurrency using coroutines without an asynchronous programming framework.\n\nIn practice, productive work with coroutines requires the support of a specialized framework. That is what asyncio provided for classic coroutines way back in Python 3.3. With the advent of native coroutines in Python 3.5, the Python core developers are gradually phasing out support for classic coroutines in asyncio. But the underly‐ ing mechanisms are very similar. The async def syntax makes native coroutines eas‐ ier to spot in code, which is a great benefit. Inside, native coroutines use await instead of yield from to delegate to other coroutines. Chapter 21 is all about that.\n\nNow let’s wrap up the chapter with a mind-bending section about covariance and contravariance in type hints for coroutines.\n\nGeneric Type Hints for Classic Coroutines Back in “Contravariant types” on page 550, I mentioned typing.Generator as one of the few standard library types with a contravariant type parameter. Now that we’ve studied classic coroutines, we are ready to make sense of this generic type.\n\nHere is how typing.Generator was declared in the typing.py module of Python 3.6:16\n\nT_co = TypeVar('T_co', covariant=True) V_co = TypeVar('V_co', covariant=True) T_contra = TypeVar('T_contra', contravariant=True)\n\n# many lines omitted\n\nclass Generator(Iterator[T_co], Generic[T_co, T_contra, V_co], extra=_G_base):\n\n16 Since Python 3.7, typing.Generator and other types that correspond to ABCs in collections.abc were refactored with a wrapper around the corresponding ABC, so their generic parameters aren’t visible in the typing.py source file. That’s why I refer to Python 3.6 source code here.\n\n650\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nThat generic type declaration means that a Generator type hint requires those three type parameters we’ve seen before:\n\nmy_coro : Generator[YieldType, SendType, ReturnType]\n\nFrom the type variables in the formal parameters, we see that YieldType and Return Type are covariant, but SendType is contravariant. To understand why, consider that YieldType and ReturnType are “output” types. Both describe data that comes out of the coroutine object—i.e., the generator object when used as a coroutine object.\n\nIt makes sense that these are covariant, because any code expecting a coroutine that yields floats can use a coroutine that yields integers. That’s why Generator is cova‐ riant on its YieldType parameter. The same reasoning applies to the ReturnType parameter—also covariant.\n\nUsing the notation introduced in “Covariant types” on page 550, the covariance of the first and third parameters is expressed by the :> symbols pointing in the same direction:\n\nfloat :> int Generator[float, Any, float] :> Generator[int, Any, int]\n\nYieldType and ReturnType are examples of the first rule of “Variance rules of thumb” on page 551:\n\n1. If a formal type parameter defines a type for data that comes out of the object, it can be covariant.\n\nOn the other hand, SendType is an “input” parameter: it is the type of the value argu‐ ment for the .send(value) method of the coroutine object. Client code that needs to send floats to a coroutine cannot use a coroutine with int as the SendType because float is not a subtype of int. In other words, float is not consistent-with int. But the client can use a coroutine with complex as the SendType, because float is a sub‐ type of complex, therefore float is consistent-with complex.\n\nThe :> notation makes the contravariance of the second parameter visible:\n\nfloat :> int Generator[Any, float, Any] <: Generator[Any, int, Any]\n\nThis is an example of the second Variance Rule of Thumb:\n\n2. If a formal type parameter defines a type for data that goes into the object after its initial construction, it can be contravariant.\n\nThis merry discussion of variance completes the longest chapter in the book.\n\nClassic Coroutines\n\n|\n\n651\n\nChapter Summary Iteration is so deeply embedded in the language that I like to say that Python groks iterators.17 The integration of the Iterator pattern in the semantics of Python is a prime example of how design patterns are not equally applicable in all programming languages. In Python, a classic Iterator implemented “by hand” as in Example 17-4 has no practical use, except as a didactic example.\n\nIn this chapter, we built a few versions of a class to iterate over individual words in text files that may be very long. We saw how Python uses the iter() built-in to create iterators from sequence-like objects. We build a classic iterator as a class with __next__(), and then we used generators to make each successive refactoring of the Sentence class more concise and readable.\n\nWe then coded a generator of arithmetic progressions and showed how to leverage the itertools module to make it simpler. An overview of most general-purpose gen‐ erator functions in the standard library followed.\n\nWe then studied yield from expressions in the context of simple generators with the chain and tree examples.\n\nThe last major section was about classic coroutines, a topic of waning importance after native coroutines were added in Python 3.5. Although difficult to use in prac‐ tice, classic coroutines are the foundation of native coroutines, and the yield from expression is the direct precursor of await.\n\nAlso covered were type hints for Iterable, Iterator, and Generator types—with the latter providing a concrete and rare example of a contravariant type parameter.\n\nFurther Reading A detailed technical explanation of generators appears in The Python Language Refer‐ ence in “6.2.9. Yield expressions”. The PEP where generator functions were defined is PEP 255—Simple Generators.\n\nThe itertools module documentation is excellent because of all the examples included. Although the functions in that module are implemented in C, the docu‐ mentation shows how some of them would be written in Python, often by leveraging other functions in the module. The usage examples are also great; for instance, there is a snippet showing how to use the accumulate function to amortize a loan with interest, given a list of payments over time. There is also an “Itertools Recipes”\n\n17 According to the Jargon file, to grok is not merely to learn something, but to absorb it so “it becomes part of\n\nyou, part of your identity.”\n\n652\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nsection with additional high-performance functions that use the itertools functions as building blocks.\n\nBeyond Python’s standard library, I recommend the More Itertools package, which follows the fine itertools tradition in providing powerful generators with plenty of examples and some useful recipes.\n\nChapter 4, “Iterators and Generators,” of Python Cookbook, 3rd ed., by David Beazley and Brian K. Jones (O’Reilly), has 16 recipes covering this subject from many differ‐ ent angles, focusing on practical applications. It includes some illuminating recipes with yield from.\n\nSebastian Rittau—currently a top contributor of typeshed—explains why iterators should be iterable, as he noted in 2006 that, “Java: Iterators are not Iterable”.\n\nThe yield from syntax is explained with examples in the “What’s New in Python 3.3” section of PEP 380—Syntax for Delegating to a Subgenerator. My post “Classic Coroutines” at fluentpython.com explains yield from in depth, including Python pseudocode of its implementation in C.\n\nDavid Beazley is the ultimate authority on Python generators and coroutines. The Python Cookbook, 3rd ed., (O’Reilly) he coauthored with Brian Jones has numerous recipes with coroutines. Beazley’s PyCon tutorials on the subject are famous for their depth and breadth. The first was at PyCon US 2008: “Generator Tricks for Systems Programmers”. PyCon US 2009 saw the legendary “A Curious Course on Coroutines and Concurrency” (hard-to-find video links for all three parts: part 1, part 2, and part 3). His tutorial from PyCon 2014 in Montréal was “Generators: The Final Frontier”, in which he tackles more concurrency examples—so it’s really more about topics in Chapter 21. Dave can’t resist making brains explode in his classes, so in the last part of “The Final Frontier,” coroutines replace the classic Visitor pattern in an arithmetic expression evaluator.\n\nCoroutines allow new ways of organizing code, and just as recursion or polymor‐ phism (dynamic dispatch), it takes some time getting used to their possibilities. An interesting example of classic algorithm rewritten with coroutines is in the post “Greedy algorithm with coroutines”, by James Powell.\n\nBrett Slatkin’s Effective Python, 1st ed. (Addison-Wesley) has an excellent short chap‐ ter titled “Consider Coroutines to Run Many Functions Concurrently.” That chapter is not in the second edition of Effective Python, but it is still available online as a sam‐ ple chapter. Slatkin presents the best example of driving coroutines with yield from that I’ve seen: an implementation of John Conway’s Game of Life in which corou‐ tines manage the state of each cell as the game runs. I refactored the code for the Game of Life example—separating the functions and classes that implement the game from the testing snippets used in Slatkin’s original code. I also rewrote the tests as\n\nFurther Reading\n\n|\n\n653\n\ndoctests, so you can see the output of the various coroutines and classes without run‐ ning the script. The refactored example is posted as a GitHub gist.\n\nSoapbox\n\nThe Minimalistic Iterator Interface in Python\n\nIn the “Implementation” section of the Iterator pattern,18 the Gang of Four wrote:\n\nThe minimal interface to Iterator consists of the operations First, Next, IsDone, and CurrentItem.\n\nHowever, that very sentence has a footnote that reads:\n\nWe can make this interface even smaller by merging Next, IsDone, and CurrentItem into a single operation that advances to the next object and returns it. If the traversal is finished, then this operation returns a special value (0, for instance) that marks the end of the iteration.\n\nThis is close to what we have in Python: the single method __next__ does the job. But instead of using a sentinel, which could be overlooked by mistake, the StopIteration exception signals the end of the iteration. Simple and correct: that’s the Python way.\n\nPluggable Generators\n\nAnyone who manages large datasets finds many uses for generators. This is the story of the first time I built a practical solution around generators.\n\nYears ago I worked at BIREME, a digital library run by PAHO/WHO (Pan-American Health Organization/World Health Organization) in São Paulo, Brazil. Among the bibliographic datasets created by BIREME are LILACS (Latin American and Carib‐ bean Health Sciences index) and SciELO (Scientific Electronic Library Online), two comprehensive databases indexing the research literature about health sciences pro‐ duced in the region.\n\nSince the late 1980s, the database system used to manage LILACS is CDS/ISIS, a non- relational document database created by UNESCO. One of my jobs was to research alternatives for a possible migration of LILACS—and eventually the much larger SciELO—to a modern, open source, document database such as CouchDB or Mon‐ goDB. At the time, I wrote a paper explaining the semistructured data model and different ways to represent CDS/ISIS data with JSON-like records: “From ISIS to CouchDB: Databases and Data Models for Bibliographic Records”.\n\nAs part of that research, I wrote a Python script to read a CDS/ISIS file and write a JSON file suitable for importing to CouchDB or MongoDB. Initially, the script read\n\n18 Gamma et. al., Design Patterns: Elements of Reusable Object-Oriented Software, p. 261.\n\n654\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nfiles in the ISO-2709 format exported by CDS/ISIS. The reading and writing had to be done incrementally because the full datasets were much bigger than main memory. That was easy enough: each iteration of the main for loop read one record from the .iso file, massaged it, and wrote it to the .json output.\n\nHowever, for operational reasons, it was deemed necessary that isis2json.py supported another CDS/ISIS data format: the binary .mst files used in production at BIREME— to avoid the costly export to ISO-2709. Now I had a problem: the libraries used to read ISO-2709 and .mst files had very different APIs. And the JSON writing loop was already complicated because the script accepted a variety of command-line options to restructure each output record. Reading data using two different APIs in the same for loop where the JSON was produced would be unwieldy.\n\nThe solution was to isolate the reading logic into a pair of generator functions: one for each supported input format. In the end, I split the isis2json.py script into four functions. You can see the Python 2 source code with dependencies in the fluentpy‐ thon/isis2json repository on GitHub.19\n\nHere is a high-level overview of how the script is structured:\n\nmain\n\nThe main function uses argparse to read command-line options that configure the structure of the output records. Based on the input filename extension, a suit‐ able generator function is selected to read the data and yield the records, one by one.\n\niter_iso_records\n\nThis generator function reads .iso files (assumed to be in the ISO-2709 format). It takes two arguments: the filename and isis_json_type, one of the options related to the record structure. Each iteration of its for loop reads one record, creates an empty dict, populates it with field data, and yields the dict.\n\niter_mst_records\n\nThis other generator functions reads .mst files.20 If you look at the source code for isis2json.py, you’ll see that it’s not as simple as iter_iso_records, but its interface and overall structure is the same: it takes a filename and an isis_json_type argument and enters a for loop, which builds and yields one dict per iteration, representing a single record.\n\n19 The code is in Python 2 because one of its optional dependencies is a Java library named Bruma, which we\n\ncan import when we run the script with Jython—which does not yet support Python 3.\n\n20 The library used to read the complex .mst binary is actually written in Java, so this functionality is only avail‐ able when isis2json.py is executed with the Jython interpreter, version 2.5 or newer. For further details, see the README.rst file in the repository. The dependencies are imported inside the generator functions that need them, so the script can run even if only one of the external libraries is available.\n\nFurther Reading\n\n|\n\n655\n\nwrite_json\n\nThis function performs the actual writing of the JSON records, one at a time. It takes numerous arguments, but the first one—input_gen—is a reference to a generator function: either iter_iso_records or iter_mst_records. The main for loop in write_json iterates over the dictionaries yielded by the selected input_gen generator, restructures it in different ways as determined by the command-line options, and appends the JSON record to the output file.\n\nBy leveraging generator functions, I was able to decouple the reading from the writ‐ ing. Of course, the simplest way to decouple them would be to read all records to memory, then write them to disk. But that was not a viable option because of the size of the datasets. Using generators, the reading and writing is interleaved, so the script can process files of any size. Also, the special logic for reading a record in the differ‐ ent input formats is separated from the logic of restructuring each record for writing.\n\nNow, if we need isis2json.py to support an additional input format—say, MARCXML, a DTD used by the US Library of Congress to represent ISO-2709 data—it will be easy to add a third generator function to implement the reading logic, without chang‐ ing anything in the complicated write_json function.\n\nThis is not rocket science, but it’s a real example where generators enabled an effi‐ cient and flexible solution to process databases as a stream of records, keeping mem‐ ory usage low regardless of the size of the dataset.\n\n656\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines\n\nCHAPTER 18 with, match, and else Blocks\n\nContext managers may end up being almost as important as the subroutine itself. We’ve only scratched the surface with them. […] Basic has a with statement, there are with statements in lots of languages. But they don’t do the same thing, they all do something very shallow, they save you from repeated dotted [attribute] lookups, they don’t do setup and tear down. Just because it’s the same name don’t think it’s the same thing. The with statement is a very big deal.1\n\n—Raymond Hettinger, eloquent Python evangelist\n\nThis chapter is about control flow features that are not so common in other lan‐ guages, and for this reason tend to be overlooked or underused in Python. They are:\n\nThe with statement and context manager protocol • Pattern matching with match/case • The else clause in for, while, and try statements\n\nThe with statement sets up a temporary context and reliably tears it down, under the control of a context manager object. This prevents errors and reduces boilerplate code, making APIs at the same time safer and easier to use. Python programmers are finding lots of uses for with blocks beyond automatic file closing.\n\nWe’ve seen pattern matching in previous chapters, but here we’ll see how the gram‐ mar of a language can be expressed as sequence patterns. That observation explains why match/case is an effective tool to create language processors that are easy to understand and extend. We’ll study a complete interpreter for a small but functional\n\n1 PyCon US 2013 keynote: “What Makes Python Awesome”; the part about with starts at 23:00 and ends at\n\n26:15.\n\n657\n\nsubset of the Scheme language. The same ideas could be applied to develop a tem‐ plate language or a DSL (Domain-Specific Language) to encode business rules in a larger system.\n\nThe else clause is not a big deal, but it does help convey intention when properly used together with for, while, and try.\n\nWhat’s New in This Chapter “Pattern Matching in lis.py: A Case Study” on page 669 is a new section.\n\nI updated “The contextlib Utilities” on page 663 to cover a few features of the context lib module added since Python 3.6, and the new parenthesized context managers syntax introduced in Python 3.10.\n\nLet’s start with the powerful with statement.\n\nContext Managers and with Blocks Context manager objects exist to control a with statement, just like iterators exist to control a for statement.\n\nThe with statement was designed to simplify some common uses of try/finally, which guarantees that some operation is performed after a block of code, even if the block is terminated by return, an exception, or a sys.exit() call. The code in the finally clause usually releases a critical resource or restores some previous state that was temporarily changed.\n\nThe Python community is finding new, creative uses for context managers. Some examples from the standard library are:\n\nManaging transactions in the sqlite3 module—see “Using the connection as a context manager”.\n\nSafely handling locks, conditions, and semaphores—as described in the thread ing module documentation.\n\nSetting up custom environments for arithmetic operations with Decimal objects —see the decimal.localcontext documentation.\n\nPatching objects for testing—see the unittest.mock.patch function.\n\nThe context manager interface consists of the __enter__ and __exit__ methods. At the top of the with, Python calls the __enter__ method of the context manager object. When the with block completes or terminates for any reason, Python calls __exit__ on the context manager object.\n\n658\n\n|\n\nChapter 18: with, match, and else Blocks",
      "page_number": 656
    },
    {
      "number": 34,
      "title": "Segment 34 (pages 677-699)",
      "start_page": 677,
      "end_page": 699,
      "detection_method": "synthetic",
      "content": "The most common example is making sure a file object is closed. Example 18-1 is a detailed demonstration of using with to close a file.\n\nExample 18-1. Demonstration of a file object as a context manager\n\n>>> with open('mirror.py') as fp: ... src = fp.read(60) ... >>> len(src) 60 >>> fp <_io.TextIOWrapper name='mirror.py' mode='r' encoding='UTF-8'> >>> fp.closed, fp.encoding (True, 'UTF-8') >>> fp.read(60) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: I/O operation on closed file.\n\nfp is bound to the opened text file because the file’s __enter__ method returns self.\n\nRead 60 Unicode characters from fp.\n\nThe fp variable is still available—with blocks don’t define a new scope, as func‐ tions do.\n\nWe can read the attributes of the fp object.\n\nBut we can’t read more text from fp because at the end of the with block, the TextIOWrapper.__exit__ method was called, and it closed the file.\n\nThe first callout in Example 18-1 makes a subtle but crucial point: the context man‐ ager object is the result of evaluating the expression after with, but the value bound to the target variable (in the as clause) is the result returned by the __enter__ method of the context manager object.\n\nIt just happens that the open() function returns an instance of TextIOWrapper, and its __enter__ method returns self. But in a different class, the __enter__ method may also return some other object instead of the context manager instance.\n\nWhen control flow exits the with block in any way, the __exit__ method is invoked on the context manager object, not on whatever was returned by __enter__.\n\nContext Managers and with Blocks\n\n|\n\n659\n\nThe as clause of the with statement is optional. In the case of open, we always need it to get a reference to the file, so that we can call methods on it. But some context man‐ agers return None because they have no useful object to give back to the user.\n\nExample 18-2 shows the operation of a perfectly frivolous context manager designed to highlight the distinction between the context manager and the object returned by its __enter__ method.\n\nExample 18-2. Test-driving the LookingGlass context manager class\n\n>>> from mirror import LookingGlass >>> with LookingGlass() as what: ... print('Alice, Kitty and Snowdrop') ... print(what) ... pordwonS dna yttiK ,ecilA YKCOWREBBAJ >>> what 'JABBERWOCKY' >>> print('Back to normal.') Back to normal.\n\nThe context manager is an instance of LookingGlass; Python calls __enter__ on the context manager and the result is bound to what.\n\nPrint a str, then the value of the target variable what. The output of each print will come out reversed.\n\nNow the with block is over. We can see that the value returned by __enter__, held in what, is the string 'JABBERWOCKY'.\n\nProgram output is no longer reversed.\n\nExample 18-3 shows the implementation of LookingGlass.\n\nExample 18-3. mirror.py: code for the LookingGlass context manager class\n\nimport sys\n\nclass LookingGlass:\n\ndef __enter__(self): self.original_write = sys.stdout.write sys.stdout.write = self.reverse_write return 'JABBERWOCKY'\n\ndef reverse_write(self, text):\n\n660\n\n|\n\nChapter 18: with, match, and else Blocks\n\nself.original_write(text[::-1])\n\ndef __exit__(self, exc_type, exc_value, traceback): sys.stdout.write = self.original_write if exc_type is ZeroDivisionError: print('Please DO NOT divide by zero!') return True\n\nPython invokes __enter__ with no arguments besides self.\n\nHold the original sys.stdout.write method, so we can restore it later.\n\nMonkey-patch sys.stdout.write, replacing it with our own method.\n\nReturn the 'JABBERWOCKY' string just so we have something to put in the target variable what.\n\nOur replacement to sys.stdout.write reverses the text argument and calls the original implementation.\n\nPython calls __exit__ with None, None, None if all went well; if an exception is raised, the three arguments get the exception data, as described after this example.\n\nRestore the original method to sys.stdout.write.\n\nIf the exception is not None and its type is ZeroDivisionError, print a message…\n\n…and return True to tell the interpreter that the exception was handled.\n\nIf __exit__ returns None or any falsy value, any exception raised in the with block will be propagated.\n\nWhen real applications take over standard output, they often want to replace sys.stdout with another file-like object for a while, then switch back to the original. The contextlib.redirect_stdout context manager does exactly that: just pass it the file-like object that will stand in for sys.stdout.\n\nThe interpreter calls the __enter__ method with no arguments—beyond the implicit self. The three arguments passed to __exit__ are:\n\nContext Managers and with Blocks\n\n|\n\n661\n\nexc_type\n\nThe exception class (e.g., ZeroDivisionError).\n\nexc_value\n\nThe exception instance. Sometimes, parameters passed to the exception con‐ structor—such as the error message—can be found in exc_value.args.\n\ntraceback\n\nA traceback object.2\n\nFor a detailed look at how a context manager works, see Example 18-4, where LookingGlass is used outside of a with block, so we can manually call its __enter__ and __exit__ methods.\n\nExample 18-4. Exercising LookingGlass without a with block\n\n>>> from mirror import LookingGlass >>> manager = LookingGlass() >>> manager # doctest: +ELLIPSIS <mirror.LookingGlass object at 0x...> >>> monster = manager.__enter__() >>> monster == 'JABBERWOCKY' eurT >>> monster 'YKCOWREBBAJ' >>> manager # doctest: +ELLIPSIS >... ta tcejbo ssalGgnikooL.rorrim< >>> manager.__exit__(None, None, None) >>> monster 'JABBERWOCKY'\n\nInstantiate and inspect the manager instance.\n\nCall the manager’s __enter__ method and store result in monster.\n\nmonster is the string 'JABBERWOCKY'. The True identifier appears reversed because all output via stdout goes through the write method we patched in __enter__.\n\nCall manager.__exit__ to restore the previous stdout.write.\n\n2 The three arguments received by self are exactly what you get if you call sys.exc_info() in the finally\n\nblock of a try/finally statement. This makes sense, considering that the with statement is meant to replace most uses of try/finally, and calling sys.exc_info() was often necessary to determine what clean-up action would be required.\n\n662\n\n|\n\nChapter 18: with, match, and else Blocks\n\nParenthesized Context Managers in Python 3.10\n\nPython 3.10 adopted a new, more powerful parser, allowing new syntax beyond what was possible with the older LL(1) parser. One syntax enhancement was to allow parenthesized context managers, like this:\n\nwith ( CtxManager1() as example1, CtxManager2() as example2, CtxManager3() as example3, ): ...\n\nPrior to 3.10, we’d have to write that as nested with blocks.\n\nThe standard library includes the contextlib package with handy functions, classes, and decorators for building, combining, and using context managers.\n\nThe contextlib Utilities Before rolling your own context manager classes, take a look at contextlib—“Utilit‐ ies for with-statement contexts” in the Python documentation. Maybe what you are about to build already exists, or there is a class or some callable that will make your job easier.\n\nBesides the redirect_stdout context manager mentioned right after Example 18-3, redirect_stderr was added in Python 3.5—it does the same as the former, but for output directed to stderr.\n\nThe contextlib package also includes:\n\nclosing\n\nA function to build context managers out of objects that provide a close() method but don’t implement the __enter__/__exit__ interface.\n\nsuppress\n\nA context manager to temporarily ignore exceptions given as arguments.\n\nnullcontext\n\nA context manager that does nothing, to simplify conditional logic around objects that may not implement a suitable context manager. It serves as a stand- in when conditional code before the with block may or may not provide a con‐ text manager for the with statement—added in Python 3.7.\n\nThe contextlib module provides classes and a decorator that are more widely appli‐ cable than the decorators just mentioned:\n\nContext Managers and with Blocks\n\n|\n\n663\n\n@contextmanager\n\nA decorator that lets you build a context manager from a simple generator func‐ tion, instead of creating a class and implementing the interface. See “Using @contextmanager” on page 664.\n\nAbstractContextManager\n\nAn ABC that formalizes the context manager interface, and makes it a bit easier to create context manager classes by subclassing—added in Python 3.6.\n\nContextDecorator\n\nA base class for defining class-based context managers that can also be used as function decorators, running the entire function within a managed context.\n\nExitStack\n\nA context manager that lets you enter a variable number of context managers. When the with block ends, ExitStack calls the stacked context managers’ __exit__ methods in LIFO order (last entered, first exited). Use this class when you don’t know beforehand how many context managers you need to enter in your with block; for example, when opening all files from an arbitrary list of files at the same time.\n\nWith Python 3.7, contextlib added AbstractAsyncContextManager, @asynccontext manager, and AsyncExitStack. They are similar to the equivalent utilities without the async part of the name, but designed for use with the new async with statement, covered in Chapter 21.\n\nThe most widely used of these utilities is the @contextmanager decorator, so it deserves more attention. That decorator is also interesting because it shows a use for the yield statement unrelated to iteration.\n\nUsing @contextmanager The @contextmanager decorator is an elegant and practical tool that brings together three distinctive Python features: a function decorator, a generator, and the with statement.\n\nUsing @contextmanager reduces the boilerplate of creating a context manager: instead of writing a whole class with __enter__/__exit__ methods, you just imple‐ ment a generator with a single yield that should produce whatever you want the __enter__ method to return.\n\nIn a generator decorated with @contextmanager, yield splits the body of the function in two parts: everything before the yield will be executed at the beginning of the with block when the interpreter calls __enter__; the code after yield will run when __exit__ is called at the end of the block.\n\n664\n\n|\n\nChapter 18: with, match, and else Blocks\n\nExample 18-5 replaces the LookingGlass class from Example 18-3 with a generator function.\n\nExample 18-5. mirror_gen.py: a context manager implemented with a generator\n\nimport contextlib import sys\n\n@contextlib.contextmanager def looking_glass(): original_write = sys.stdout.write\n\ndef reverse_write(text): original_write(text[::-1])\n\nsys.stdout.write = reverse_write yield 'JABBERWOCKY' sys.stdout.write = original_write\n\nApply the contextmanager decorator.\n\nPreserve the original sys.stdout.write method.\n\nreverse_write can call original_write later because it is available in its closure.\n\nReplace sys.stdout.write with reverse_write.\n\nYield the value that will be bound to the target variable in the as clause of the with statement. The generator pauses at this point while the body of the with executes.\n\nWhen control exits the with block, execution continues after the yield; here the original sys.stdout.write is restored.\n\nExample 18-6 shows the looking_glass function in operation.\n\nExample 18-6. Test-driving the looking_glass context manager function\n\n>>> from mirror_gen import looking_glass >>> with looking_glass() as what: ... print('Alice, Kitty and Snowdrop') ... print(what) ... pordwonS dna yttiK ,ecilA YKCOWREBBAJ >>> what 'JABBERWOCKY'\n\nContext Managers and with Blocks\n\n|\n\n665\n\n>>> print('back to normal') back to normal\n\nThe only difference from Example 18-2 is the name of the context manager: look ing_glass instead of LookingGlass.\n\nThe contextlib.contextmanager decorator wraps the function in a class that imple‐ ments the __enter__ and __exit__ methods.3\n\nThe __enter__ method of that class:\n\n1. Calls the generator function to get a generator object—let’s call it gen. 2. Calls next(gen) to drive it to the yield keyword. 3. Returns the value yielded by next(gen), to allow the user to bind it to a variable in the with/as form.\n\nWhen the with block terminates, the __exit__ method:\n\n1. Checks whether an exception was passed as exc_type; if so, gen.throw(excep tion) is invoked, causing the exception to be raised in the yield line inside the generator function body.\n\n2. Otherwise, next(gen) is called, resuming the execution of the generator function body after the yield.\n\nExample 18-5 has a flaw: if an exception is raised in the body of the with block, the Python interpreter will catch it and raise it again in the yield expression inside look ing_glass. But there is no error handling there, so the looking_glass generator will terminate without ever restoring the original sys.stdout.write method, leaving the system in an invalid state.\n\nExample 18-7 adds special handling of the ZeroDivisionError exception, making it functionally equivalent to the class-based Example 18-3.\n\nExample 18-7. mirror_gen_exc.py: generator-based context manager implementing exception handling—same external behavior as Example 18-3\n\nimport contextlib import sys\n\n@contextlib.contextmanager\n\n3 The actual class is named _GeneratorContextManager. If you want to see exactly how it works, read its source\n\ncode in Lib/contextlib.py in Python 3.10.\n\n666\n\n|\n\nChapter 18: with, match, and else Blocks\n\ndef looking_glass(): original_write = sys.stdout.write\n\ndef reverse_write(text): original_write(text[::-1])\n\nsys.stdout.write = reverse_write msg = '' try: yield 'JABBERWOCKY' except ZeroDivisionError: msg = 'Please DO NOT divide by zero!' finally: sys.stdout.write = original_write if msg: print(msg)\n\nCreate a variable for a possible error message; this is the first change in relation to Example 18-5.\n\nHandle ZeroDivisionError by setting an error message.\n\nUndo monkey-patching of sys.stdout.write.\n\nDisplay error message, if it was set.\n\nRecall that the __exit__ method tells the interpreter that it has handled the exception by returning a truthy value; in that case, the interpreter suppresses the exception. On the other hand, if __exit__ does not explicitly return a value, the interpreter gets the usual None, and propagates the exception. With @contextmanager, the default behav‐ ior is inverted: the __exit__ method provided by the decorator assumes any excep‐ tion sent into the generator is handled and should be suppressed.\n\nHaving a try/finally (or a with block) around the yield is an unavoidable price of using @contextmanager, because you never know what the users of your context manager are going to do inside the with block.4\n\n4 This tip is quoted literally from a comment by Leonardo Rochael, one of the tech reviewers for this book.\n\nNicely said, Leo!\n\nContext Managers and with Blocks\n\n|\n\n667\n\nA little-known feature of @contextmanager is that the generators decorated with it can also be used as decorators themselves.5 That happens because @contextmanager is implemented with the contextlib.ContextDecorator class.\n\nExample 18-8 shows the looking_glass context manager from Example 18-5 used as decorator.\n\nExample 18-8. The looking_glass context manager also works as a decorator\n\n>>> @looking_glass() ... def verse(): ... print('The time has come') ... >>> verse() emoc sah emit ehT >>> print('back to normal') back to normal\n\nlooking_glass does its job before and after the body of verse runs.\n\nThis confirms that the original sys.write was restored.\n\nContrast Example 18-8 with Example 18-6, where looking_glass is used as a context manager.\n\nAn interesting real-life example of @contextmanager outside of the standard library is Martijn Pieters’ in-place file rewriting using a context manager. Example 18-9 shows how it’s used.\n\nExample 18-9. A context manager for rewriting files in place\n\nimport csv\n\nwith inplace(csvfilename, 'r', newline='') as (infh, outfh): reader = csv.reader(infh) writer = csv.writer(outfh)\n\nfor row in reader: row += ['new', 'columns'] writer.writerow(row)\n\nThe inplace function is a context manager that gives you two handles—infh and outfh in the example—to the same file, allowing your code to read and write to it at\n\n5 At least I and the other technical reviewers didn’t know it until Caleb Hattingh told us. Thanks, Caleb!\n\n668\n\n|\n\nChapter 18: with, match, and else Blocks\n\nthe same time. It’s easier to use than the standard library’s fileinput.input function (which also provides a context manager, by the way).\n\nIf you want to study Martijn’s inplace source code (listed in the post), find the yield keyword: everything before it deals with setting up the context, which entails creating a backup file, then opening and yielding references to the readable and writable file handles that will be returned by the __enter__ call. The __exit__ processing after the yield closes the file handles and restores the file from the backup if something went wrong.\n\nThis concludes our overview of the with statement and context managers. Let’s turn to match/case in the context of a complete example.\n\nPattern Matching in lis.py: A Case Study In “Pattern Matching Sequences in an Interpreter” on page 43 we saw examples of sequence patterns extracted from the evaluate function of Peter Norvig’s lis.py inter‐ preter, ported to Python 3.10. In this section I want to give a broader overview of how lis.py works, and also explore all the case clauses of evaluate, explaining not only the patterns but also what the interpreter does in each case.\n\nBesides showing more pattern matching, I wrote this section for three reasons:\n\n1. Norvig’s lis.py is a beautiful example of idiomatic Python code.\n\n2. The simplicity of Scheme is a master class of language design.\n\n3. Learning how an interpreter works gave me a deeper understanding of Python and programming languages in general—interpreted or compiled.\n\nBefore looking at the Python code, let’s get a little taste of Scheme so you can make sense of this case study—in case you haven’t seen Scheme or Lisp before.\n\nScheme Syntax In Scheme there is no distinction between expressions and statements, like we have in Python. Also, there are no infix operators. All expressions use prefix notation like (+ x 13) instead of x + 13. The same prefix notation is used for function calls—e.g., (gcd x 13)—and special forms—e.g., (define x 13), which we’d write as the assignment statement x = 13 in Python. The notation used by Scheme and most Lisp dialects is known as S-expression.6\n\n6 People complain about too many parentheses in Lisp, but thoughtful indentation and a good editor mostly take care of that issue. The main readability problem is using the same (f …) notation for function calls and special forms like (define …), (if …), and (quote …) that don’t behave at all like function calls.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n669\n\nExample 18-10 shows a simple example in Scheme.\n\nExample 18-10. Greatest common divisor in Scheme\n\n(define (mod m n) (- m (* n (quotient m n))))\n\n(define (gcd m n) (if (= n 0) m (gcd n (mod m n))))\n\n(display (gcd 18 45))\n\nExample 18-10 shows three Scheme expressions: two function definitions—mod and gcd—and a call to display, which will output 9, the result of (gcd 18 45). Example 18-11 is the same code in Python (shorter than an English explanation of the recursive Euclidean algorithm).\n\nExample 18-11. Same as Example 18-10, written in Python\n\ndef mod(m, n): return m - (m // n * n)\n\ndef gcd(m, n): if n == 0: return m else: return gcd(n, mod(m, n))\n\nprint(gcd(18, 45))\n\nIn idiomatic Python, I’d use the % operator instead of reinventing mod, and it would be more efficient to use a while loop instead of recursion. But I wanted to show two function definitions, and make the examples as similar as possible, to help you read the Scheme code.\n\nScheme has no iterative control flow commands like while or for. Iteration is done with recursion. Note how there are no assignments in the Scheme and Python exam‐ ples. Extensive use of recursion and minimal use of assignment are hallmarks of pro‐ gramming in a functional style.7\n\n7 To make iteration through recursion practical and efficient, Scheme and other functional languages imple‐\n\nment proper tail calls. For more about this, see “Soapbox” on page 691.\n\n670\n\n|\n\nChapter 18: with, match, and else Blocks\n\nNow let’s review the code of the Python 3.10 version of lis.py. The complete source code with tests is in the 18-with-match/lispy/py3.10/ directory of the GitHub reposi‐ tory fluentpython/example-code-2e.\n\nImports and Types Example 18-12 shows the first lines of lis.py. The use of TypeAlias and the | type union operator require Python 3.10.\n\nExample 18-12. lis.py: top of the file\n\nimport math import operator as op from collections import ChainMap from itertools import chain from typing import Any, TypeAlias, NoReturn\n\nSymbol: TypeAlias = str Atom: TypeAlias = float | int | Symbol Expression: TypeAlias = Atom | list\n\nThe types defined are:\n\nSymbol\n\nJust an alias for str. In lis.py, Symbol is used for identifiers; there is no string data type with operations such as slicing, splitting, etc.8\n\nAtom\n\nA simple syntactic element, such as a number or a Symbol—as opposed to a com‐ posite structure made of distinct parts, like a list.\n\nExpression\n\nThe building blocks of Scheme programs are expressions made of atoms and lists, possibly nested.\n\nThe Parser Norvig’s parser is 36 lines of code showcasing the power of Python applied to han‐ dling the simple recursive syntax of S-expression—without string data, comments, macros, and other features of standard Scheme that make parsing more complicated (Example 18-13).\n\n8 But Norvig’s second interpreter, lispy.py, supports strings as a data type, as well as advanced features like syn‐ tactic macros, continuations, and proper tail calls. However, lispy.py is almost three times longer than lis.py— and much harder to understand.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n671\n\nExample 18-13. lis.py: the main parsing functions\n\ndef parse(program: str) -> Expression: \"Read a Scheme expression from a string.\" return read_from_tokens(tokenize(program))\n\ndef tokenize(s: str) -> list[str]: \"Convert a string into a list of tokens.\" return s.replace('(', ' ( ').replace(')', ' ) ').split()\n\ndef read_from_tokens(tokens: list[str]) -> Expression: \"Read an expression from a sequence of tokens.\" # more parsing code omitted in book listing\n\nThe main function of that group is parse, which takes an S-expression as a str and returns an Expression object, as defined in Example 18-12: an Atom or a list that may contain more atoms and nested lists.\n\nNorvig uses a smart trick in tokenize: he adds spaces before and after each parenthe‐ sis in the input and then splits it, resulting in a list of syntactic tokens with '(' and ')' as separate tokens. This shortcut works because there is no string type in the little Scheme of lis.py, so every '(' or ')' is an expression delimiter. The recursive parsing code is in read_from_tokens, a 14-line function that you can read in the fluentpy‐ thon/example-code-2e repository. I will skip it because I want to focus on the other parts of the interpreter.\n\nHere are some doctests extracted from lispy/py3.10/examples_test.py:\n\n>>> from lis import parse >>> parse('1.5') 1.5 >>> parse('ni!') 'ni!' >>> parse('(gcd 18 45)') ['gcd', 18, 45] >>> parse(''' ... (define double ... (lambda (n) ... (* n 2))) ... ''') ['define', 'double', ['lambda', ['n'], ['*', 'n', 2]]]\n\nThe parsing rules for this subset of Scheme are simple:\n\n1. A token that looks like a number is parsed as a float or int. 2. Anything else that is not '(' or ')' is parsed as a Symbol—a str to be used as an identifier. This includes source text like +, set!, and make-counter that are valid identifiers in Scheme but not in Python.\n\n672\n\n|\n\nChapter 18: with, match, and else Blocks\n\n3. Expressions inside '(' and ')' are recursively parsed as lists containing atoms or as nested lists that may contain atoms and more nested lists.\n\nUsing the terminology of the Python interpreter, the output of parse is an AST (Abstract Syntax Tree): a convenient representation of the Scheme program as nested lists forming a tree-like structure, where the outermost list is the trunk, inner lists are the branches, and atoms are the leaves (Figure 18-1).\n\nFigure 18-1. A Scheme lambda expression represented as source code (concrete syntax), as a tree, and as a sequence of Python objects (abstract syntax).\n\nThe Environment The Environment class extends collections.ChainMap, adding a change method to update a value inside one of the chained dicts, which ChainMap instances hold in a list of mappings: the self.maps attribute. The change method is needed to support the Scheme (set! …) form, described later; see Example 18-14.\n\nExample 18-14. lis.py: the Environment class\n\nclass Environment(ChainMap[Symbol, Any]): \"A ChainMap that allows changing an item in-place.\"\n\ndef change(self, key: Symbol, value: Any) -> None: \"Find where key is defined and change the value there.\" for map in self.maps: if key in map:\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n673\n\nmap[key] = value # type: ignore[index] return raise KeyError(key)\n\nNote that the change method only updates existing keys.9 Trying to change a key that is not found raises KeyError.\n\nThis doctest shows how Environment works:\n\n>>> from lis import Environment >>> inner_env = {'a': 2} >>> outer_env = {'a': 0, 'b': 1} >>> env = Environment(inner_env, outer_env) >>> env['a'] 2 >>> env['a'] = 111 >>> env['c'] = 222 >>> env Environment({'a': 111, 'c': 222}, {'a': 0, 'b': 1}) >>> env.change('b', 333) >>> env Environment({'a': 111, 'c': 222}, {'a': 0, 'b': 333})\n\nWhen reading values, Environment works as ChainMap: keys are searched in the nested mappings from left to right. That’s why the value of a in the outer_env is shadowed by the value in inner_env.\n\nAssigning with [] overwrites or inserts new items, but always in the first map‐ ping, inner_env in this example.\n\nenv.change('b', 333) seeks the 'b' key and assigns a new value to it in-place, in the outer_env.\n\nNext is the standard_env() function, which builds and returns an Environment loaded with predefined functions, similar to Python’s __builtins__ module that is always available (Example 18-15).\n\nExample 18-15. lis.py: standard_env() builds and returns the global environment\n\ndef standard_env() -> Environment: \"An environment with some Scheme standard procedures.\" env = Environment() env.update(vars(math)) # sin, cos, sqrt, pi, ...\n\n9 The # type: ignore[index] comment is there because of typeshed issue #6042, which is unresolved as I\n\nreview this chapter. ChainMap is annotated as MutableMapping, but the type hint in the maps attribute says it’s a list of Mapping, indirectly making the whole ChainMap immutable as far as Mypy is concerned.\n\n674\n\n|\n\nChapter 18: with, match, and else Blocks\n\nenv.update({ '+': op.add, '-': op.sub, '*': op.mul, '/': op.truediv, # omitted here: more operator definitions 'abs': abs, 'append': lambda *args: list(chain(*args)), 'apply': lambda proc, args: proc(*args), 'begin': lambda *x: x[-1], 'car': lambda x: x[0], 'cdr': lambda x: x[1:], # omitted here: more function definitions 'number?': lambda x: isinstance(x, (int, float)), 'procedure?': callable, 'round': round, 'symbol?': lambda x: isinstance(x, Symbol), }) return env\n\nTo summarize, the env mapping is loaded with:\n\nAll functions from Python’s math module • Selected operators from Python’s op module • Simple but powerful functions built with Python’s lambda • Python built-ins renamed, like callable as procedure?, or directly mapped, like round\n\nThe REPL Norvig’s REPL (read-eval-print-loop) is easy to understand but not user-friendly (see Example 18-16). If no command-line arguments are given to lis.py, the repl() func‐ tion is invoked by main()—defined at the end of the module. At the lis.py> prompt, we must enter correct and complete expressions; if we forget to close one parenthesis, lis.py crashes.10\n\n10 As I studied Norvig’s lis.py and lispy.py, I started a fork named mylis that adds some features, including a REPL that accepts partial S-expressions and prompts for the continuation, similar to how Python’s REPL knows we are not finished and presents the secondary prompt (...) until we enter a complete expression or statement that can be evaluated. mylis also handles a few errors gracefully, but it’s still easy to crash. It’s not nearly as robust as Python’s REPL.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n675\n\nExample 18-16. The REPL functions\n\ndef repl(prompt: str = 'lis.py> ') -> NoReturn: \"A prompt-read-eval-print loop.\" global_env = Environment({}, standard_env()) while True: ast = parse(input(prompt)) val = evaluate(ast, global_env) if val is not None: print(lispstr(val))\n\ndef lispstr(exp: object) -> str: \"Convert a Python object back into a Lisp-readable string.\" if isinstance(exp, list): return '(' + ' '.join(map(lispstr, exp)) + ')' else: return str(exp)\n\nHere is a quick explanation about these two functions:\n\nrepl(prompt: str = 'lis.py> ') -> NoReturn\n\nCalls standard_env() to provide built-in functions for the global environment, then enters an infinite loop, reading and parsing each input line, evaluating it in the global environment, and displaying the result—unless it’s None. The global_env may be modified by evaluate. For example, when a user defines a new global variable or named function, it is stored in the first mapping of the environment—the empty dict in the Environment constructor call in the first line of repl.\n\nlispstr(exp: object) -> str\n\nThe inverse function of parse: given a Python object representing an expression, parse returns the Scheme source code for it. For example, given ['+', 2, 3], the result is '(+ 2 3)'.\n\nThe Evaluator Now we can appreciate the beauty of Norvig’s expression evaluator—made a little prettier with match/case. The evaluate function in Example 18-17 takes an Expres sion built by parse and an Environment.\n\nThe body of evaluate is a single match statement with an expression exp as the sub‐ ject. The case patterns express the syntax and semantics of Scheme with amazing clarity.\n\n676\n\n|\n\nChapter 18: with, match, and else Blocks\n\nExample 18-17. evaluate takes an expression and computes its value\n\nKEYWORDS = ['quote', 'if', 'lambda', 'define', 'set!']\n\ndef evaluate(exp: Expression, env: Environment) -> Any: \"Evaluate an expression in an environment.\" match exp: case int(x) | float(x): return x case Symbol(var): return env[var] case ['quote', x]: return x case ['if', test, consequence, alternative]: if evaluate(test, env): return evaluate(consequence, env) else: return evaluate(alternative, env) case ['lambda', [*parms], *body] if body: return Procedure(parms, body, env) case ['define', Symbol(name), value_exp]: env[name] = evaluate(value_exp, env) case ['define', [Symbol(name), *parms], *body] if body: env[name] = Procedure(parms, body, env) case ['set!', Symbol(name), value_exp]: env.change(name, evaluate(value_exp, env)) case [func_exp, *args] if func_exp not in KEYWORDS: proc = evaluate(func_exp, env) values = [evaluate(arg, env) for arg in args] return proc(*values) case _: raise SyntaxError(lispstr(exp))\n\nLet’s study each case clause and what it does. In some cases I added comments show‐ ing an S-expression that would match the pattern when parsed into a Python list. Doctests extracted from examples_test.py demonstrate each case.\n\nEvaluating numbers\n\ncase int(x) | float(x): return x\n\nSubject:\n\nInstance of int or float.\n\nAction:\n\nReturn value as is.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n677\n\nExample:\n\n>>> from lis import parse, evaluate, standard_env >>> evaluate(parse('1.5'), {}) 1.5\n\nEvaluating symbols\n\ncase Symbol(var): return env[var]\n\nSubject:\n\nInstance of Symbol, i.e., a str used as an identifier.\n\nAction:\n\nLook up var in env and return its value.\n\nExamples:\n\n>>> evaluate(parse('+'), standard_env()) <built-in function add> >>> evaluate(parse('ni!'), standard_env()) Traceback (most recent call last): ... KeyError: 'ni!'\n\n(quote …)\n\nThe quote special form treats atoms and lists as data instead of expressions to be evaluated.\n\n# (quote (99 bottles of beer)) case ['quote', x]: return x\n\nSubject:\n\nList starting with the symbol 'quote', followed by one expression x.\n\nAction:\n\nReturn x without evaluating it.\n\nExamples:\n\n>>> evaluate(parse('(quote no-such-name)'), standard_env()) 'no-such-name' >>> evaluate(parse('(quote (99 bottles of beer))'), standard_env()) [99, 'bottles', 'of', 'beer'] >>> evaluate(parse('(quote (/ 10 0))'), standard_env()) ['/', 10, 0]\n\nWithout quote, each expression in the test would raise an error:\n\n678\n\n|\n\nChapter 18: with, match, and else Blocks\n\nno-such-name would be looked up in the environment, raising KeyError • (99 bottles of beer) cannot be evaluated because the number 99 is not a Symbol naming a special form, operator, or function\n\n(/ 10 0) would raise ZeroDivisionError\n\nWhy Languages Have Reserved Keywords Although simple, quote cannot be implemented as a function in Scheme. Its special power is to prevent the interpreter from evaluating (f 10) in the expression (quote (f 10)): the result is simply a list with a Symbol and an int. In contrast, in a function call like (abs (f 10)), the interpreter evaluates (f 10) before invoking abs. That’s why quote is a reserved keyword: it must be handled as a special form.\n\nIn general, reserved keywords are needed:\n\nTo introduce specialized evaluation rules, as in quote and lambda—which don’t evaluate any of their subexpressions\n\nTo change the control flow, as in if and function calls—which also have special evaluation rules\n\nTo manage the environment, as in define and set\n\nThis is also why Python, and programming languages in general, need reserved key‐ words. Think about Python’s def, if, yield, import, del, and what they do.\n\n(if …)\n\n# (if (< x 0) 0 x) case ['if', test, consequence, alternative]: if evaluate(test, env): return evaluate(consequence, env) else: return evaluate(alternative, env)\n\nSubject:\n\nList starting with 'if' followed by three expressions: test, consequence, and alternative.\n\nAction:\n\nEvaluate test:\n\nIf true, evaluate consequence and return its value. • Otherwise, evaluate alternative and return its value.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n679\n\nExamples:\n\n>>> evaluate(parse('(if (= 3 3) 1 0))'), standard_env()) 1 >>> evaluate(parse('(if (= 3 4) 1 0))'), standard_env()) 0\n\nThe consequence and alternative branches must be single expressions. If more than one expression is needed in a branch, you can combine them with (begin exp1 exp2…), provided as a function in lis.py—see Example 18-15.\n\n(lambda …)\n\nScheme’s lambda form defines anonymous functions. It doesn’t suffer from the limi‐ tations of Python’s lambda: any function that can be written in Scheme can be written using the (lambda …) syntax.\n\n# (lambda (a b) (/ (+ a b) 2)) case ['lambda' [*parms], *body] if body: return Procedure(parms, body, env)\n\nSubject:\n\nList starting with 'lambda', followed by:\n\nList of zero or more parameter names. • One or more expressions collected in body (the guard ensures that body is not empty).\n\nAction:\n\nCreate and return a new Procedure instance with the parameter names, the list of expressions as the body, and the current environment.\n\nExample:\n\n>>> expr = '(lambda (a b) (* (/ a b) 100))' >>> f = evaluate(parse(expr), standard_env()) >>> f # doctest: +ELLIPSIS <lis.Procedure object at 0x...> >>> f(15, 20) 75.0\n\nThe Procedure class implements the concept of a closure: a callable object holding parameter names, a function body, and a reference to the environment in which the function is defined. We’ll study the code for Procedure in a moment.\n\n680\n\n|\n\nChapter 18: with, match, and else Blocks\n\n(define …)\n\nThe define keyword is used in two different syntactic forms. The simplest is:\n\n# (define half (/ 1 2)) case ['define', Symbol(name), value_exp]: env[name] = evaluate(value_exp, env)\n\nSubject:\n\nList starting with 'define', followed by a Symbol and an expression.\n\nAction:\n\nEvaluate the expression and put its value into env, using name as key.\n\nExample:\n\n>>> global_env = standard_env() >>> evaluate(parse('(define answer (* 7 6))'), global_env) >>> global_env['answer'] 42\n\nThe doctest for this case creates a global_env so that we can verify that evaluate puts answer into that Environment.\n\nWe can use that simple define form to create variables or to bind names to anony‐ mous functions, using (lambda …) as the value_exp.\n\nStandard Scheme provides a shortcut for defining named functions. That’s the sec‐ ond define form:\n\n# (define (average a b) (/ (+ a b) 2)) case ['define', [Symbol(name), *parms], *body] if body: env[name] = Procedure(parms, body, env)\n\nSubject:\n\nList starting with 'define', followed by:\n\nA list starting with a Symbol(name), followed by zero or more items collected into a list named parms.\n\nOne or more expressions collected in body (the guard ensures that body is not empty).\n\nAction:\n\nCreate a new Procedure instance with the parameter names, the list of expres‐ sions as the body, and the current environment.\n\nPut the Procedure into env, using name as key.\n\nThe doctest in Example 18-18 defines a function named % that computes a percentage and adds it to the global_env.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n681",
      "page_number": 677
    },
    {
      "number": 35,
      "title": "Segment 35 (pages 700-717)",
      "start_page": 700,
      "end_page": 717,
      "detection_method": "synthetic",
      "content": "Example 18-18. Defining a function named % that computes a percentage\n\n>>> global_env = standard_env() >>> percent = '(define (% a b) (* (/ a b) 100))' >>> evaluate(parse(percent), global_env) >>> global_env['%'] # doctest: +ELLIPSIS <lis.Procedure object at 0x...> >>> global_env['%'](170, 200) 85.0\n\nAfter calling evaluate, we check that % is bound to a Procedure that takes two numeric arguments and returns a percentage.\n\nThe pattern for the second define case does not enforce that the items in parms are all Symbol instances. I’d have to check that before building the Procedure, but I didn’t—to keep the code as easy to follow as Norvig’s.\n\n(set! …)\n\nThe set! form changes the value of a previously defined variable.11\n\n# (set! n (+ n 1)) case ['set!', Symbol(name), value_exp]: env.change(name, evaluate(value_exp, env))\n\nSubject:\n\nList starting with 'set!', followed by a Symbol and an expression.\n\nAction:\n\nUpdate the value of name in env with the result of evaluating the expression.\n\nThe Environment.change method traverses the chained environments from local to global, and updates the first occurrence of name with the new value. If we were not implementing the 'set!' keyword, we could use Python’s ChainMap as the Environ ment type everywhere in this interpreter.\n\n11 Assignment is one of the first features taught in many programming tutorials, but set! only appears on page 220 of the best known Scheme book, Structure and Interpretation of Computer Programs, 2nd ed., by Abelson et al. (MIT Press), a.k.a. SICP or the “Wizard Book.” Coding in a functional style can take us very far without the state changes that are typical of imperative and object-oriented programming.\n\n682\n\n|\n\nChapter 18: with, match, and else Blocks\n\nPython’s nonlocal and Scheme’s set! Address the Same Issue The use of the set! form is related to the use of the nonlocal keyword in Python: declaring nonlocal x allows x = 10 to update a previously defined x variable outside of the local scope. Without a nonlocal x declaration, x = 10 will always create a local variable in Python, as we saw in “The nonlocal Declaration” on page 315.\n\nSimilarly, (set! x 10) updates a previously defined x that may be outside of the local environment of the function. In contrast, the variable x in (define x 10) is always a local variable, created or updated in the local environment.\n\nBoth nonlocal and (set! …) are needed to update program state held in variables within a closure. Example 9-13 demonstrated the use of nonlocal to implement a function to compute a running average, holding an item count and total in a clo‐ sure. Here is that same idea, written in the Scheme subset of lis.py:\n\n(define (make-averager) (define count 0) (define total 0) (lambda (new-value) (set! count (+ count 1)) (set! total (+ total new-value)) (/ total count) ) ) (define avg (make-averager)) (avg 10) (avg 11) (avg 15)\n\nCreates a new closure with the inner function defined by lambda, and the vari‐ ables count and total initialized to 0; binds the closure to avg.\n\nReturns 10.0.\n\nReturns 10.5.\n\nReturns 12.0.\n\nThe preceding code is one of the tests in lispy/py3.10/examples_test.py.\n\nNow we get to a function call.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n683\n\nFunction call\n\n# (gcd (* 2 105) 84) case [func_exp, *args] if func_exp not in KEYWORDS: proc = evaluate(func_exp, env) values = [evaluate(arg, env) for arg in args] return proc(*values)\n\nSubject:\n\nList with one or more items.\n\nThe guard ensures that func_exp is not one of ['quote', 'if', 'define', 'lambda', 'set!']—listed right before evaluate in Example 18-17.\n\nThe pattern matches any list with one or more expressions, binding the first expression to func_exp and the rest to args as a list, which may be empty.\n\nAction:\n\nEvaluate func_exp to obtain a function proc. • Evaluate each item in args to build a list of argument values. • Call proc with the values as separate arguments, returning the result.\n\nExample:\n\n>>> evaluate(parse('(% (* 12 14) (- 500 100))'), global_env) 42.0\n\nThis doctest continues from Example 18-18: it assumes global_env has a function named %. The arguments given to % are arithmetic expressions, to emphasize that the arguments are evaluated before the function is called.\n\nThe guard in this case is needed because [func_exp, *args] matches any sequence subject with one or more items. However, if func_exp is a keyword, and the subject did not match any previous case, then it is really a syntax error.\n\nCatch syntax errors\n\nIf the subject exp does not match any of the previous cases, the catch-all case raises a SyntaxError:\n\ncase _: raise SyntaxError(lispstr(exp))\n\nHere is an example of a malformed (lambda …) reported as a SyntaxError:\n\n>>> evaluate(parse('(lambda is not like this)'), standard_env()) Traceback (most recent call last): ... SyntaxError: (lambda is not like this)\n\n684\n\n|\n\nChapter 18: with, match, and else Blocks\n\nIf the case for function call did not have that guard rejecting keywords, the (lambda is not like this) expression would be handled as a function call, which would raise KeyError because 'lambda' is not part of the environment—just like lambda is not a Python built-in function.\n\nProcedure: A Class Implementing a Closure The Procedure class could very well be named Closure, because that’s what it repre‐ sents: a function definition together with an environment. The function definition includes the name of the parameters and the expressions that make up the body of the function. The environment is used when the function is called to provide the val‐ ues of the free variables: variables that appear in the body of the function but are not parameters, local variables, or global variables. We saw the concepts of closure and free variable in “Closures” on page 311.\n\nWe learned how to use closures in Python, but now we can dive deeper and see how a closure is implemented in lis.py:\n\nclass Procedure: \"A user-defined Scheme procedure.\"\n\ndef __init__( self, parms: list[Symbol], body: list[Expression], env: Environment ): self.parms = parms self.body = body self.env = env\n\ndef __call__(self, *args: Expression) -> Any: local_env = dict(zip(self.parms, args)) env = Environment(local_env, self.env) for exp in self.body: result = evaluate(exp, env) return result\n\nCalled when a function is defined by the lambda or define forms.\n\nSave the parameter names, body expressions, and environment for later use.\n\nCalled by proc(*values) in the last line of the case [func_exp, *args] clause.\n\nBuild local_env mapping self.parms as local variable names, and the given args as values.\n\nBuild a new combined env, putting local_env first, and then self.env—the environment that was saved when the function was defined.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n685\n\nIterate over each expression in self.body, evaluating it in the combined env.\n\nReturn the result of the last expression evaluated.\n\nThere are a couple of simple functions after evaluate in lis.py: run reads a complete Scheme program and executes it, and main calls run or repl, depending on the com‐ mand line—similar to what Python does. I will not describe those functions because there’s nothing new in them. My goals were to share with you the beauty of Norvig’s little interpreter, to give more insight into how closures work, and to show how match/case is a great addition to Python.\n\nTo wrap up this extended section on pattern matching, let’s formalize the concept of an OR-pattern.\n\nUsing OR-patterns A series of patterns separated by | is an OR-pattern: it succeeds if any of the subpat‐ terns succeed. The pattern in “Evaluating numbers” on page 677 is an OR-pattern:\n\ncase int(x) | float(x): return x\n\nAll subpatterns in an OR-pattern must use the same variables. This restriction is nec‐ essary to ensure that the variables are available to the guard expression and the case body, regardless of the subpattern that matched.\n\nIn the context of a case clause, the | operator has a special mean‐ ing. It does not trigger the __or__ special method, which handles expressions like a | b in other contexts, where it is overloaded to perform operations such as set union or integer bitwise-or, depending on the operands.\n\nAn OR-pattern is not restricted to appear at the top level of a pattern. You can also use | in subpatterns. For example, if we wanted lis.py to accept the Greek letter λ (lambda)12 as well as the lambda keyword, we can rewrite the pattern like this:\n\n# (λ (a b) (/ (+ a b) 2) ) case ['lambda' | 'λ', [*parms], *body] if body: return Procedure(parms, body, env)\n\n12 The official Unicode name for λ (U+03BB) is GREEK SMALL LETTER LAMDA. This is not a typo: the char‐ acter is named “lamda” without the “b” in the Unicode database. According to the English Wikipedia article “Lambda”, the Unicode Consortium adopted that spelling because of “preferences expressed by the Greek National Body.”\n\n686\n\n|\n\nChapter 18: with, match, and else Blocks\n\nNow we can move to the third and last subject of this chapter: the unusual places where an else clause may appear in Python.\n\nDo This, Then That: else Blocks Beyond if This is no secret, but it is an underappreciated language feature: the else clause can be used not only in if statements but also in for, while, and try statements.\n\nThe semantics of for/else, while/else, and try/else are closely related, but very different from if/else. Initially, the word else actually hindered my understanding of these features, but eventually I got used to it.\n\nHere are the rules:\n\nfor\n\nThe else block will run only if and when the for loop runs to completion (i.e., not if the for is aborted with a break).\n\nwhile\n\nThe else block will run only if and when the while loop exits because the condi‐ tion became falsy (i.e., not if the while is aborted with a break).\n\ntry\n\nThe else block will run only if no exception is raised in the try block. The offi‐ cial docs also state: “Exceptions in the else clause are not handled by the preced‐ ing except clauses.”\n\nIn all cases, the else clause is also skipped if an exception or a return, break, or continue statement causes control to jump out of the main block of the compound statement.\n\nI think else is a very poor choice for the keyword in all cases except if. It implies an excluding alternative, like, “Run this loop, otherwise do that,” but the semantics for else in loops is the oppo‐ site: “Run this loop, then do that.” This suggests then as a better keyword—which would also make sense in the try context: “Try this, then do that.” However, adding a new keyword is a breaking change to the language—not an easy decision to make.\n\nUsing else with these statements often makes the code easier to read and saves the trouble of setting up control flags or coding extra if statements.\n\nThe use of else in loops generally follows the pattern of this snippet:\n\nfor item in my_list: if item.flavor == 'banana':\n\nDo This, Then That: else Blocks Beyond if\n\n|\n\n687\n\nbreak else: raise ValueError('No banana flavor found!')\n\nIn the case of try/except blocks, else may seem redundant at first. After all, the after_call() in the following snippet will run only if the dangerous_call() does not raise an exception, correct?\n\ntry: dangerous_call() after_call() except OSError: log('OSError...')\n\nHowever, doing so puts the after_call() inside the try block for no good reason. For clarity and correctness, the body of a try block should only have the statements that may generate the expected exceptions. This is better:\n\ntry: dangerous_call() except OSError: log('OSError...') else: after_call()\n\nit’s clear that the try block\n\nNow in dangerous_call() and not in after_call(). It’s also explicit that after_call() will only execute if no exceptions are raised in the try block.\n\nis guarding against possible errors\n\nIn Python, try/except is commonly used for control flow, and not just for error handling. There’s even an acronym/slogan for that documented in the official Python glossary:\n\nEAFP\n\nEasier to ask for forgiveness than permission. This common Python coding style assumes the existence of valid keys or attributes and catches exceptions if the assumption proves false. This clean and fast style is characterized by the presence of many try and except statements. The technique contrasts with the LBYL style common to many other languages such as C.\n\nThe glossary then defines LBYL:\n\nLBYL\n\nLook before you leap. This coding style explicitly tests for pre-conditions before making calls or lookups. This style contrasts with the EAFP approach and is char‐ acterized by the presence of many if statements. In a multi-threaded environment, the LBYL approach can risk introducing a race condition between “the looking” and “the leaping.” For example, the code, if key in mapping: return mapping[key] can fail if another thread removes key from mapping after the test, but before the lookup. This issue can be solved with locks or by using the EAFP approach.\n\n688\n\n|\n\nChapter 18: with, match, and else Blocks\n\nGiven the EAFP style, it makes even more sense to know and use else blocks well in try/except statements.\n\nWhen the match statement was discussed, some people (including me) thought it should also have an else clause. In the end it was decided that it wasn’t needed because case _: does the same job.13\n\nNow let’s summarize the chapter.\n\nChapter Summary This chapter started with context managers and the meaning of the with statement, quickly moving beyond its common use to automatically close opened files. We implemented a custom context manager: the LookingGlass class with the __enter__/__exit__ methods, and saw how to handle exceptions in the __exit__ method. A key point that Raymond Hettinger made in his PyCon US 2013 keynote is that with is not just for resource management; it’s a tool for factoring out common setup and teardown code, or any pair of operations that need to be done before and after another procedure.14\n\nWe reviewed functions in the contextlib standard library module. One of them, the @contextmanager decorator, makes it possible to implement a context manager using a simple generator with one yield—a leaner solution than coding a class with at least two methods. We reimplemented the LookingGlass as a looking_glass generator function, and discussed how to do exception handling when using @contextmanager.\n\nThen we studied Peter Norvig’s elegant lis.py, a Scheme interpreter written in idiomatic Python, refactored to use match/case in evaluate—the function at the core of any interpreter. Understanding how evaluate works required reviewing a lit‐ tle bit of Scheme, a parser for S-expressions, a simple REPL, and the construction of nested scopes through an Environment subclass of collection.ChainMap. In the end, lis.py became a vehicle to explore much more than pattern matching. It shows how the different parts of an interpreter work together, illuminating core features of Python itself: why reserved keywords are necessary, how scoping rules work, and how closures are built and used.\n\n13 Watching the discussion in the python-dev mailing list I thought one reason why else was rejected was the lack of consensus on how to indent it within match: should else be indented at the same level as match, or at the same level as case?\n\n14 See slide 21 in “Python is Awesome”.\n\nChapter Summary\n\n|\n\n689\n\nFurther Reading Chapter 8, “Compound Statements,” in The Python Language Reference says pretty much everything there is to say about else clauses in if, for, while, and try state‐ ments. Regarding Pythonic usage of try/except, with or without else, Raymond Hettinger has a brilliant answer to the question “Is it a good practice to use try- except-else in Python?” in StackOverflow. Python in a Nutshell, 3rd ed., by Martelli et al., has a chapter about exceptions with an excellent discussion of the EAFP style, crediting computing pioneer Grace Hopper for coining the phrase, “It’s easier to ask forgiveness than permission.”\n\nThe Python Standard Library, Chapter 4, “Built-in Types,” has a section devoted to “Context Manager Types”. The __enter__/__exit__ special methods are also docu‐ mented in The Python Language Reference in “With Statement Context Managers”. Context managers were introduced in PEP 343—The “with” Statement.\n\nRaymond Hettinger highlighted the with statement as a “winning language feature” in his PyCon US 2013 keynote. He also showed some interesting applications of con‐ text managers in his talk, “Transforming Code into Beautiful, Idiomatic Python”, at the same conference.\n\nJeff Preshing’s blog post “The Python with Statement by Example” is interesting for the examples using context managers with the pycairo graphics library.\n\nThe contextlib.ExitStack class is based on an original idea by Nikolaus Rath, who wrote a short post explaining why its useful: “On the Beauty of Python’s ExitStack”. In that text, Rath submits that ExitStack is similar but more flexible than the defer statement in Go—which I think is one of the best ideas in that language.\n\nBeazley and Jones devised context managers for very different purposes in their Python Cookbook, 3rd ed. “Recipe 8.3. Making Objects Support the Context- Management Protocol” implements a LazyConnection class whose instances are con‐ text managers that open and close network connections automatically in with blocks. “Recipe 9.22. Defining Context Managers the Easy Way” introduces a context man‐ ager for timing code, and another for making transactional changes to a list object: within the with block, a working copy of the list instance is made, and all changes are applied to that working copy. Only when the with block completes without an exception, the working copy replaces the original list. Simple and ingenious.\n\nPeter Norvig describes his small Scheme interpreters in the posts “(How to Write a (Lisp) Interpreter (in Python))” and “(An ((Even Better) Lisp) Interpreter (in Python))”. The code for lis.py and lispy.py is the norvig/pytudes repository. My repos‐ itory fluentpython/lispy includes the mylis forks of lis.py, updated to Python 3.10, with a nicer REPL, command-line integration, examples, more tests, and references for\n\n690\n\n|\n\nChapter 18: with, match, and else Blocks\n\nlearning more about Scheme. The best Scheme dialect and environment to learn and experiment is Racket.\n\nSoapbox\n\nFactoring Out the Bread\n\nIn his PyCon US 2013 keynote, “What Makes Python Awesome”, Raymond Het‐ tinger says when he first saw the with statement proposal he thought it was “a little bit arcane.” Initially, I had a similar reaction. PEPs are often hard to read, and PEP 343 is typical in that regard.\n\nThen—Hettinger told us—he had an insight: subroutines are the most important invention in the history of computer languages. If you have sequences of operations like A;B;C and P;B;Q, you can factor out B in a subroutine. It’s like factoring out the filling in a sandwich: using tuna with different breads. But what if you want to factor out the bread, to make sandwiches with wheat bread, using a different filling each time? That’s what the with statement offers. It’s the complement of the subroutine. Hettinger went on to say:\n\nThe with statement is a very big deal. I encourage you to go out and take this tip of the iceberg and drill deeper. You can probably do profound things with the with statement. The best uses of it have not been discovered yet. I expect that if you make good use of it, it will be copied into other languages and all future languages will have it. You can be part of discovering something almost as profound as the invention of the subroutine itself.\n\nHettinger admits he is overselling the with statement. Nevertheless, it is a very useful feature. When he used the sandwich analogy to explain how with is the complement to the subroutine, many possibilities opened up in my mind.\n\nIf you need to convince anyone that Python is awesome, you should watch Het‐ tinger’s keynote. The bit about context managers is from 23:00 to 26:15. But the entire keynote is excellent.\n\nEfficient Recursion with Proper Tail Calls\n\nStandard Scheme implementations are required to provide proper tail calls (PTC), to make iteration through recursion a practical alternative to while loops in imperative languages. Some writers refer to PTC as tail call optimization (TCO); for others, TCO is something different. For more details, see “Tail call” on Wikipedia and “Tail call optimization in ECMAScript 6”.\n\nA tail call is when a function returns the result of a function call, which may be the same function or not. The gcd examples in Example 18-10 and Example 18-11 make (recursive) tail calls in the falsy branch of the if.\n\nOn the other hand, this factorial does not make a tail call:\n\nFurther Reading\n\n|\n\n691\n\ndef factorial(n): if n < 2: return 1 return n * factorial(n - 1)\n\nThe call to factorial in the last line is not a tail call because the return value is not the result of the recursive call: the result is multiplied by n before it is returned.\n\nHere is an alternative that uses a tail call, and is therefore tail recursive:\n\ndef factorial_tc(n, product=1): if n < 1: return product return factorial_tc(n - 1, product * n)\n\nPython does not have PTC, so there’s no advantage in writing tail recursive functions. In this case, the first version is shorter and more readable in my opinion. For real-life uses, don’t forget that Python has math.factorial, written in C without recursion. The point is that, even in languages that implement PTC, it does not benefit every recursive function, only those that are carefully written to make tail calls.\n\nIf PTC is supported by the language, when the interpreter sees a tail call, it jumps into the body of the called function without creating a new stack frame, saving memory. There are also compiled languages that implement PTC, sometimes as an optimiza‐ tion that can be toggled.\n\nThere is no universal consensus about the definition of TCO or the value of PTC in languages that were not designed as functional languages from the ground up, like Python or JavaScript. In functional languages, PTC is an expected feature, not merely an optimization that is nice to have. If a language has no iteration mechanism other than recursion, then PTC is necessary for practical usage. Norvig’s lis.py does not implement PTC, but his more elaborate lispy.py interpreter does.\n\nThe Case Against Proper Tail Calls in Python and JavaScript\n\nCPython does not implement PTC, and probably never will. Guido van Rossum wrote “Final Words on Tail Calls” to explain why. To summarize, here is a key pas‐ sage from his post:\n\nPersonally, I think it is a fine feature for some languages, but I don’t think it fits Python: the elimination of stack traces for some calls but not others would certainly confuse many users, who have not been raised with tail call religion but might have learned about call semantics by tracing through a few calls in a debugger.\n\nIn 2015, PTC was included in the ECMAScript 6 standard for JavaScript. As of Octo‐ ber 2021, the interpreter in WebKit implements it. WebKit is used by Safari. The JS interpreters in every other major browser don’t have PTC, and neither does Node.js, as it relies on the V8 engine that Google maintains for Chrome. Transpilers and poly‐ fills targeting JS, like TypeScript, ClojureScript, and Babel, don’t support PTC either, according to this “ECMAScript 6 compatibility table”.\n\n692\n\n|\n\nChapter 18: with, match, and else Blocks\n\nI’ve seen several explanations for the rejection of PTC by the implementers, but the most common is the same that Guido van Rossum mentioned: PTC makes debugging harder for everyone, while benefiting only a minority of people who’d rather use recursion for iteration. For details, see “What happened to proper tail calls in Java‐ Script?” by Graham Marlow.\n\nThere are cases when recursion is the best solution, even in Python without PTC. In a previous post on the subject, Guido wrote:\n\n[…] a typical Python implementation allows 1000 recursions, which is plenty for non-recursively written code and for code that recourses to traverse, for example, a typical parse tree, but not enough for a recursively written loop over a large list.\n\nI agree with Guido and the majority of JS implementers: PTC is not a good fit for Python or JavaScript. The lack of PTC is the main restriction for writing Python pro‐ grams in a functional style—more than the limited lambda syntax.\n\nIf you are curious to see how PTC works in an interpreter with less features (and less code) than Norvig’s lispy.py, check out mylis_2. The trick starts with the infinite loop in evaluate and the code in the case for function calls: that combination makes the intepreter jump into the body of the next Procedure without calling evaluate recur‐ sively during a tail call. Those little interpreters demonstrate the power of abstraction: even though Python does not implement PTC, it’s possible and not very hard to write an interpreter, in Python, that does implement PTC. I learned how to do it reading Peter Norvig’s code. Thanks for sharing it, professor!\n\nNorvig’s Take on evaluate() with Pattern Matching\n\nI shared the code for the Python 3.10 version of lis.py with Peter Norvig. He liked the example using pattern matching, but suggested a different solution: instead of the guards I wrote, he would have exactly one case per keyword, and have tests within each case, to provide more specific SyntaxError messages—for example, when a body is empty. This would also make the guard in case [func_exp, *args] if func_exp not in KEYWORDS: unnecessary, as every keyword would be handled before the case for function calls.\n\nI’ll probably follow Norvig’s advice when I add more functionality to mylis. But the way I structured evaluate in Example 18-17 has some didactic advantages for this book: the example parallels the implementation with if/elif/… (Example 2-11), the case clauses demonstrate more features of pattern matching, and the code is more concise.\n\nFurther Reading\n\n|\n\n693\n\nCHAPTER 19 Concurrency Models in Python\n\nConcurrency is about dealing with lots of things at once.\n\nParallelism is about doing lots of things at once.\n\nNot the same, but related.\n\nOne is about structure, one is about execution.\n\nConcurrency provides a way to structure a solution to solve a problem that may (but not necessarily) be parallelizable.\n\n—Rob Pike, co-inventor of the Go language1\n\nThis chapter is about how to make Python deal with “lots of things at once.” This may involve concurrent or parallel programming—even academics who are keen on jargon disagree on how to use those terms. I will adopt Rob Pike’s informal defini‐ tions in this chapter’s epigraph, but note that I’ve found papers and books that claim to be about parallel computing but are mostly about concurrency.2\n\nParallelism is a special case of concurrency, in Pike’s view. All parallel systems are concurrent, but not all concurrent systems are parallel. In the early 2000s we used single-core machines that handled 100 processes concurrently on GNU Linux. A modern laptop with 4 CPU cores is routinely running more than 200 processes at any given time under normal, casual use. To execute 200 tasks in parallel, you’d need 200 cores. So, in practice, most computing is concurrent and not parallel. The OS\n\n1 Slide 8 of the talk “Concurrency Is Not Parallelism”.\n\n2 I studied and worked with Prof. Imre Simon, who liked to say there are two major sins in science: using dif‐ ferent words to mean the same thing and using one word to mean different things. Imre Simon (1943–2009) was a pioneer of computer science in Brazil who made seminal contributions to Automata Theory and started the field of Tropical Mathematics. He was also an advocate of free software and free culture.\n\n695\n\nmanages hundreds of processes, making sure each has an opportunity to make pro‐ gress, even if the CPU itself can’t do more than four things at once.\n\nThis chapter assumes no prior knowledge of concurrent or parallel programming. After a brief conceptual introduction, we will study simple examples to introduce and compare Python’s core packages for concurrent programming: threading, multi processing, and asyncio.\n\nThe last 30% of the chapter is a high-level overview of third-party tools, libraries, application servers, and distributed task queues—all of which can enhance the per‐ formance and scalability of Python applications. These are all important topics, but beyond the scope of a book focused on core Python language features. Nevertheless, I felt it was important to address these themes in this second edition of Fluent Python, because Python’s fitness for concurrent and parallel computing is not limited to what the standard library provides. That’s why YouTube, DropBox, Instagram, Reddit, and others were able to achieve web scale when they started, using Python as their pri‐ mary language—despite persistent claims that “Python doesn’t scale.”\n\nWhat’s New in This Chapter This chapter is new in the second edition of Fluent Python. The spinner examples in “A Concurrent Hello World” on page 701 previously were in the chapter about asyncio. Here they are improved, and provide the first illustration of Python’s three approaches to concurrency: threads, processes, and native coroutines.\n\nThe remaining content is new, except for a few paragraphs that originally appeared in the chapters on concurrent.futures and asyncio.\n\n“Python in the Multicore World” on page 725 is different from the rest of the book: there are no code examples. The goal is to mention important tools that you may want to study to achieve high-performance concurrency and parallelism beyond what’s possible with Python’s standard library.\n\nThe Big Picture There are many factors that make concurrent programming hard, but I want to touch on the most basic factor: starting threads or processes is easy enough, but how do you keep track of them?3\n\nWhen you call a function, the calling code is blocked until the function returns. So you know when the function is done, and you can easily get the value it returned. If\n\n3 This section was suggested by my friend Bruce Eckel—author of books about Kotlin, Scala, Java, and C++.\n\n696\n\n|\n\nChapter 19: Concurrency Models in Python\n\nthe function raises an exception, the calling code can surround the call site with try/ except to catch the error.\n\nThose familiar options are not available when you start a thread or process: you don’t automatically know when it’s done, and getting back results or errors requires setting up some communication channel, such as a message queue.\n\nAdditionally, starting a thread or a process is not cheap, so you don’t want to start one of them just to perform a single computation and quit. Often you want to amor‐ tize the startup cost by making each thread or process into a “worker” that enters a loop and stands by for inputs to work on. This further complicates communications and introduces more questions. How do you make a worker quit when you don’t need it anymore? And how do you make it quit without interrupting a job partway, leaving half-baked data and unreleased resources—like open files? Again the usual answers involve messages and queues.\n\nA coroutine is cheap to start. If you start a coroutine using the await keyword, it’s easy to get a value returned by it, it can be safely cancelled, and you have a clear site to catch exceptions. But coroutines are often started by the asynchronous framework, and that can make them as hard to monitor as threads or processes.\n\nFinally, Python coroutines and threads are not suitable for CPU-intensive tasks, as we’ll see.\n\nThat’s why concurrent programming requires learning new concepts and coding pat‐ terns. Let’s first make sure we are on the same page regarding some core concepts.\n\nA Bit of Jargon Here are some terms I will use for the rest of this chapter and the next two:\n\nConcurrency\n\nThe ability to handle multiple pending tasks, making progress one at a time or in parallel (if possible) so that each of them eventually succeeds or fails. A single- core CPU is capable of concurrency if it runs an OS scheduler that interleaves the execution of the pending tasks. Also known as multitasking.\n\nParallelism\n\nThe ability to execute multiple computations at the same time. This requires a multicore CPU, multiple CPUs, a GPU, or multiple computers in a cluster.\n\nExecution unit\n\nGeneral term for objects that execute code concurrently, each with independent state and call stack. Python natively supports three kinds of execution units: pro‐ cesses, threads, and coroutines.\n\nA Bit of Jargon\n\n|\n\n697\n\nProcess\n\nAn instance of a computer program while it is running, using memory and a slice of the CPU time. Modern desktop operating systems routinely manage hundreds of processes concurrently, with each process isolated in its own private memory space. Processes communicate via pipes, sockets, or memory mapped files—all of which can only carry raw bytes. Python objects must be serialized (converted) into raw bytes to pass from one process to another. This is costly, and not all Python objects are serializable. A process can spawn subprocesses, each called a child process. These are also isolated from each other and from the parent. Pro‐ cesses allow preemptive multitasking: the OS scheduler preempts—i.e., suspends —each running process periodically to allow other processes to run. This means that a frozen process can’t freeze the whole system—in theory.\n\nThread\n\nAn execution unit within a single process. When a process starts, it uses a single thread: the main thread. A process can create more threads to operate concur‐ rently by calling operating system APIs. Threads within a process share the same memory space, which holds live Python objects. This allows easy data sharing between threads, but can also lead to corrupted data when more than one thread updates the same object concurrently. Like processes, threads also enable pre‐ emptive multitasking under the supervision of the OS scheduler. A thread con‐ sumes less resources than a process doing the same job.\n\nCoroutine\n\nA function that can suspend itself and resume later. In Python, classic coroutines are built from generator functions, and native coroutines are defined with async def. “Classic Coroutines” on page 641 introduced the concept, and Chapter 21 covers the use of native coroutines. Python coroutines usually run within a single thread under the supervision of an event loop, also in the same thread. Asynchro‐ nous programming frameworks such as asyncio, Curio, or Trio provide an event loop and supporting libraries for nonblocking, coroutine-based I/O. Coroutines support cooperative multitasking: each coroutine must explicitly cede control with the yield or await keyword, so that another may proceed concurrently (but not in parallel). This means that any blocking code in a coroutine blocks the exe‐ cution of the event loop and all other coroutines—in contrast with the preemp‐ tive multitasking supported by processes and threads. On the other hand, each coroutine consumes less resources than a thread or process doing the same job.\n\nQueue\n\nA data structure that lets us put and get items, usually in FIFO order: first in, first out. Queues allow separate execution units to exchange application data and con‐ trol messages, such as error codes and signals to terminate. The implementation of a queue varies according to the underlying concurrency model: the queue\n\n698\n\n|\n\nChapter 19: Concurrency Models in Python\n\npackage in Python’s standard library provides queue classes to support threads, while the multiprocessing and asyncio packages implement their own queue classes. The queue and asyncio packages also include queues that are not FIFO: LifoQueue and PriorityQueue.\n\nLock\n\nAn object that execution units can use to synchronize their actions and avoid corrupting data. While updating a shared data structure, the running code should hold an associated lock. This signals other parts of the program to wait until the lock is released before accessing the same data structure. The simplest type of lock is also known as a mutex (for mutual exclusion). The implementa‐ tion of a lock depends on the underlying concurrency model.\n\nContention\n\nDispute over a limited asset. Resource contention happens when multiple execu‐ tion units try to access a shared resource—such as a lock or storage. There’s also CPU contention, when compute-intensive processes or threads must wait for the OS scheduler to give them a share of the CPU time.\n\nNow let’s use some of that jargon to understand concurrency support in Python.\n\nProcesses, Threads, and Python’s Infamous GIL Here is how the concepts we just saw apply to Python programming, in 10 points:\n\n1. Each instance of the Python interpreter is a process. You can start additional Python processes using the multiprocessing or concurrent.futures libraries. Python’s subprocess library is designed to launch processes to run external pro‐ grams, regardless of the languages used to write them.\n\n2. The Python interpreter uses a single thread to run the user’s program and the memory garbage collector. You can start additional Python threads using the threading or concurrent.futures libraries.\n\n3. Access to object reference counts and other internal interpreter state is con‐ trolled by a lock, the Global Interpreter Lock (GIL). Only one Python thread can hold the GIL at any time. This means that only one thread can execute Python code at any time, regardless of the number of CPU cores.\n\n4. To prevent a Python thread from holding the GIL indefinitely, Python’s bytecode interpreter pauses the current Python thread every 5ms by default,4 releasing the GIL. The thread can then try to reacquire the GIL, but if there are other threads waiting for it, the OS scheduler may pick one of them to proceed.\n\n4 Call sys.getswitchinterval() to get the interval; change it with sys.setswitchinterval(s).\n\nA Bit of Jargon\n\n|\n\n699\n\n5. When we write Python code, we have no control over the GIL. But a built-in function or an extension written in C—or any language that interfaces at the Python/C API level—can release the GIL while running time-consuming tasks. 6. Every Python standard library function that makes a syscall5 releases the GIL. This includes all functions that perform disk I/O, network I/O, and time.sleep(). Many CPU-intensive functions in the NumPy/SciPy libraries, as well as the compressing/decompressing functions from the zlib and bz2 mod‐ ules, also release the GIL.6\n\n7. Extensions that integrate at the Python/C API level can also launch other non- Python threads that are not affected by the GIL. Such GIL-free threads generally cannot change Python objects, but they can read from and write to the memory underlying objects that support the buffer protocol, such as bytearray, array.array, and NumPy arrays.\n\n8. The effect of the GIL on network programming with Python threads is relatively small, because the I/O functions release the GIL, and reading or writing to the network always implies high latency—compared to reading and writing to mem‐ ory. Consequently, each individual thread spends a lot of time waiting anyway, so their execution can be interleaved without major impact on the overall throughput. That’s why David Beazley says: “Python threads are great at doing nothing.”7\n\n9. Contention over the GIL slows down compute-intensive Python threads. Sequential, single-threaded code is simpler and faster for such tasks.\n\n10. To run CPU-intensive Python code on multiple cores, you must use multiple Python processes.\n\nHere is a good summary from the threading module documentation:8\n\nCPython implementation detail: In CPython, due to the Global Interpreter Lock, only one thread can execute Python code at once (even though certain performance- oriented libraries might overcome this limitation). If you want your application to make better use of the computational resources of multicore machines, you are advised to use multiprocessing or concurrent.futures.ProcessPoolExecutor. However,\n\n5 A syscall is a call from user code to a function of the operating system kernel. I/O, timers, and locks are some\n\nof the kernel services available through syscalls. To learn more, read the Wikipedia “System call” article.\n\n6 The zlib and bz2 modules are specifically mentioned in a python-dev message by Antoine Pitrou, who con‐\n\ntributed the time-slicing GIL logic to Python 3.2.\n\n7 Source: slide 106 of Beazley’s “Generators: The Final Frontier” tutorial.\n\n8 Source: last paragraph of the “Thread objects” section.\n\n700\n\n|\n\nChapter 19: Concurrency Models in Python",
      "page_number": 700
    },
    {
      "number": 36,
      "title": "Segment 36 (pages 718-737)",
      "start_page": 718,
      "end_page": 737,
      "detection_method": "synthetic",
      "content": "threading is still an appropriate model if you want to run multiple I/O-bound tasks simultaneously.\n\nThe previous paragraph starts with “CPython implementation detail” because the GIL is not part of the Python language definition. The Jython and IronPython imple‐ mentations don’t have a GIL. Unfortunately, both are lagging behind—still tracking Python 2.7. The highly performant PyPy interpreter also has a GIL in its 2.7 and 3.7 versions—the latest as of June 2021.\n\nThis section did not mention coroutines, because by default they share the same Python thread among themselves and with the supervising event loop provided by an asynchronous framework, therefore the GIL does not affect them. It is possible to use multiple threads in an asynchronous program, but the best practice is that one thread runs the event loop and all coroutines, while additional threads carry out specific tasks. This will be explained in “Delegat‐ ing Tasks to Executors” on page 797.\n\nEnough concepts for now. Let’s see some code.\n\nA Concurrent Hello World During a discussion about threads and how to avoid the GIL, Python contributor Michele Simionato posted an example that is like a concurrent “Hello World”: the simplest program to show how Python can “walk and chew gum.”\n\nSimionato’s program uses multiprocessing, but I adapted it to introduce threading and asyncio as well. Let’s start with the threading version, which may look familiar if you’ve studied threads in Java or C.\n\nSpinner with Threads The idea of the next few examples is simple: start a function that blocks for 3 seconds while animating characters in the terminal to let the user know that the program is “thinking” and not stalled.\n\nThe script makes an animated spinner displaying each character in the string \"\\|/-\" in the same screen position.9 When the slow computation finishes, the line with the spinner is cleared and the result is shown: Answer: 42.\n\n9 Unicode has lots of characters useful for simple animations, like the Braille patterns for example. I used the\n\nASCII characters \"\\|/-\" to keep the examples simple.\n\nA Concurrent Hello World\n\n|\n\n701\n\nFigure 19-1 shows the output of two versions of the spinning example: first with threads, then with coroutines. If you’re away from the computer, imagine the \\ in the last line is spinning.\n\nFigure 19-1. The scripts spinner_thread.py and spinner_async.py produce similar out‐ put: the repr of a spinner object and the text “Answer: 42”. In the screenshot, spin‐ ner_async.py is still running, and the animated message “/ thinking!” is shown; that line will be replaced by “Answer: 42” after 3 seconds.\n\nLet’s review the spinner_thread.py script first. Example 19-1 lists the first two func‐ tions in the script, and Example 19-2 shows the rest.\n\nExample 19-1. spinner_thread.py: the spin and slow functions\n\nimport itertools import time from threading import Thread, Event\n\ndef spin(msg: str, done: Event) -> None: for char in itertools.cycle(r'\\|/-'): status = f'\\r{char} {msg}' print(status, end='', flush=True) if done.wait(.1): break blanks = ' ' * len(status) print(f'\\r{blanks}\\r', end='')\n\ndef slow() -> int: time.sleep(3) return 42\n\nThis function will run in a separate thread. The done argument is an instance of threading.Event, a simple object to synchronize threads.\n\nThis is an infinite loop because itertools.cycle yields one character at a time, cycling through the string forever.\n\nThe trick for text-mode animation: move the cursor back to the start of the line with the carriage return ASCII control character ('\\r').\n\n702\n\n|\n\nChapter 19: Concurrency Models in Python\n\nThe Event.wait(timeout=None) method returns True when the event is set by another thread; if the timeout elapses, it returns False. The .1s timeout sets the “frame rate” of the animation to 10 FPS. If you want the spinner to go faster, use a smaller timeout.\n\nExit the infinite loop.\n\nClear the status line by overwriting with spaces and moving the cursor back to the beginning.\n\nslow() will be called by the main thread. Imagine this is a slow API call over the network. Calling sleep blocks the main thread, but the GIL is released so the spinner thread can proceed.\n\nThe first important insight of this example is that time.sleep() blocks the calling thread but releases the GIL, allowing other Python threads to run.\n\nThe spin and slow functions will execute concurrently. The main thread—the only thread when the program starts—will start a new thread to run spin and then call slow. By design, there is no API for terminating a thread in Python. You must send it a message to shut down.\n\nThe threading.Event class is Python’s simplest signalling mechanism to coordinate threads. An Event instance has an internal boolean flag that starts as False. Calling Event.set() sets the flag to True. While the flag is false, if a thread calls Event.wait(), it is blocked until another thread calls Event.set(), at which time Event.wait() returns True. If a timeout in seconds is given to Event.wait(s), this call returns False when the timeout elapses, or returns True as soon as Event.set() is called by another thread.\n\nThe supervisor function, listed in Example 19-2, uses an Event to signal the spin function to exit.\n\nExample 19-2. spinner_thread.py: the supervisor and main functions\n\ndef supervisor() -> int: done = Event() spinner = Thread(target=spin, args=('thinking!', done)) print(f'spinner object: {spinner}') spinner.start() result = slow() done.set()\n\nA Concurrent Hello World\n\n|\n\n703\n\nspinner.join() return result\n\ndef main() -> None: result = supervisor() print(f'Answer: {result}')\n\nif __name__ == '__main__': main()\n\nsupervisor will return the result of slow.\n\nThe threading.Event instance is the key to coordinate the activities of the main thread and the spinner thread, as explained further down.\n\nTo create a new Thread, provide a function as the target keyword argument, and positional arguments to the target as a tuple passed via args.\n\nDisplay the spinner object. The output is <Thread(Thread-1, initial)>, where initial is the state of the thread—meaning it has not started.\n\nStart the spinner thread.\n\nCall slow, which blocks the main thread. Meanwhile, the secondary thread is run‐ ning the spinner animation.\n\nSet the Event flag to True; this will terminate the for loop inside the spin function.\n\nWait until the spinner thread finishes.\n\nRun the supervisor function. I wrote separate main and supervisor functions to make this example look more like the asyncio version in Example 19-4.\n\nWhen the main thread sets the done event, the spinner thread will eventually notice and exit cleanly.\n\nNow let’s take a look at a similar example using the multiprocessing package.\n\nSpinner with Processes The multiprocessing package supports running concurrent tasks in separate Python processes instead of threads. When you create a multiprocessing.Process instance, a whole new Python interpreter is started as a child process in the background. Since each Python process has its own GIL, this allows your program to use all available\n\n704\n\n|\n\nChapter 19: Concurrency Models in Python\n\nCPU cores—but that ultimately depends on the operating system scheduler. We’ll see practical effects in “A Homegrown Process Pool” on page 716, but for this simple pro‐ gram it makes no real difference.\n\nThe point of this section is to introduce multiprocessing and show that its API emulates the threading API, making it easy to convert simple programs from threads to processes, as shown in spinner_proc.py (Example 19-3).\n\nExample 19-3. spinner_proc.py: only the changed parts are shown; everything else is the same as spinner_thread.py\n\nimport itertools import time from multiprocessing import Process, Event from multiprocessing import synchronize\n\ndef spin(msg: str, done: synchronize.Event) -> None:\n\n# [snip] the rest of spin and slow functions are unchanged from spinner_thread.py\n\ndef supervisor() -> int: done = Event() spinner = Process(target=spin, args=('thinking!', done)) print(f'spinner object: {spinner}') spinner.start() result = slow() done.set() spinner.join() return result\n\n# [snip] main function is unchanged as well\n\nThe basic multiprocessing API imitates the threading API, but type hints and Mypy expose this difference: multiprocessing.Event is a function (not a class like threading.Event) which returns a synchronize.Event instance…\n\n…forcing us to import multiprocessing.synchronize…\n\n…to write this type hint.\n\nBasic usage of the Process class is similar to Thread.\n\nThe spinner object is displayed as <Process name='Process-1' parent=14868 initial>, where 14868 is the process ID of the Python instance running spinner_proc.py.\n\nA Concurrent Hello World\n\n|\n\n705\n\nThe basic API of threading and multiprocessing are similar, but their implementa‐ tion is very different, and multiprocessing has a much larger API to handle the added complexity of multiprocess programming. For example, one challenge when converting from threads to processes is how to communicate between processes that are isolated by the operating system and can’t share Python objects. This means that objects crossing process boundaries have to be serialized and deserialized, which cre‐ ates overhead. In Example 19-3, the only data that crosses the process boundary is the Event state, which is implemented with a low-level OS semaphore in the C code underlying the multiprocessing module.10\n\nSince Python 3.8, there’s a multiprocessing.shared_memory pack‐ age in the standard library, but it does not support instances of user-defined classes. Besides raw bytes, the package allows pro‐ cesses to share a ShareableList, a mutable sequence type that can hold a fixed number of items of types int, float, bool, and None, as well as str and bytes up to 10 MB per item. See the ShareableL ist documentation for more.\n\nNow let’s see how the same behavior can be achieved with coroutines instead of threads or processes.\n\nSpinner with Coroutines\n\nChapter 21 is entirely devoted to asynchronous programming with coroutines. This is just a high-level introduction to contrast this approach with the threads and processes concurrency models. As such, we will overlook many details.\n\nIt is the job of OS schedulers to allocate CPU time to drive threads and processes. In contrast, coroutines are driven by an application-level event loop that manages a queue of pending coroutines, drives them one by one, monitors events triggered by I/O operations initiated by coroutines, and passes control back to the corresponding coroutine when each event happens. The event loop and the library coroutines and the user coroutines all execute in a single thread. Therefore, any time spent in a coroutine slows down the event loop—and all other coroutines.\n\n10 The semaphore is a fundamental building block that can be used to implement other synchronization mecha‐ nisms. Python provides different semaphore classes for use with threads, processes, and coroutines. We’ll see asyncio.Semaphore in “Using asyncio.as_completed and a Thread” on page 788 (Chapter 21).\n\n706\n\n|\n\nChapter 19: Concurrency Models in Python\n\nThe coroutine version of the spinner program is easier to understand if we start from the main function, then study the supervisor. That’s what Example 19-4 shows.\n\nExample 19-4. spinner_async.py: the main function and supervisor coroutine\n\ndef main() -> None: result = asyncio.run(supervisor()) print(f'Answer: {result}')\n\nasync def supervisor() -> int: spinner = asyncio.create_task(spin('thinking!')) print(f'spinner object: {spinner}') result = await slow() spinner.cancel() return result\n\nif __name__ == '__main__': main()\n\nmain is the only regular function defined in this program—the others are coroutines.\n\nThe asyncio.run function starts the event loop to drive the coroutine that will eventually set the other coroutines in motion. The main function will stay blocked until supervisor returns. The return value of supervisor will be the return value of asyncio.run.\n\nNative coroutines are defined with async def.\n\nasyncio.create_task schedules the eventual execution of spin, immediately returning an instance of asyncio.Task.\n\nThe repr of the spinner object looks like <Task pending name='Task-2' coro=<spin() running at /path/to/spinner_async.py:11>>.\n\nThe await keyword calls slow, blocking supervisor until slow returns. The return value of slow will be assigned to result.\n\nThe Task.cancel method raises a CancelledError exception inside the spin coroutine, as we’ll see in Example 19-5.\n\nExample 19-4 demonstrates the three main ways of running a coroutine:\n\nA Concurrent Hello World\n\n|\n\n707\n\nasyncio.run(coro())\n\nCalled from a regular function to drive a coroutine object that usually is the entry point for all the asynchronous code in the program, like the supervisor in this example. This call blocks until the body of coro returns. The return value of the run() call is whatever the body of coro returns.\n\nasyncio.create_task(coro())\n\nCalled from a coroutine to schedule another coroutine to execute eventually. This call does not suspend the current coroutine. It returns a Task instance, an object that wraps the coroutine object and provides methods to control and query its state.\n\nawait coro()\n\nCalled from a coroutine to transfer control to the coroutine object returned by coro(). This suspends the current coroutine until the body of coro returns. The value of the await expression is whatever the body of coro returns.\n\nRemember: invoking a coroutine as coro() immediately returns a coroutine object, but does not run the body of the coro function. Driving the body of coroutines is the job of the event loop.\n\nNow let’s study the spin and slow coroutines in Example 19-5.\n\nExample 19-5. spinner_async.py: the spin and slow coroutines\n\nimport asyncio import itertools\n\nasync def spin(msg: str) -> None: for char in itertools.cycle(r'\\|/-'): status = f'\\r{char} {msg}' print(status, flush=True, end='') try: await asyncio.sleep(.1) except asyncio.CancelledError: break blanks = ' ' * len(status) print(f'\\r{blanks}\\r', end='')\n\nasync def slow() -> int: await asyncio.sleep(3) return 42\n\n708\n\n|\n\nChapter 19: Concurrency Models in Python\n\nWe don’t need the Event argument that was used to signal that slow had comple‐ ted its job in spinner_thread.py (Example 19-1).\n\nUse await asyncio.sleep(.1) instead of time.sleep(.1), to pause without blocking other coroutines. See the experiment after this example.\n\nasyncio.CancelledError is raised when the cancel method is called on the Task controlling this coroutine. Time to exit the loop.\n\nThe slow coroutine also uses await asyncio.sleep instead of time.sleep.\n\nExperiment: Break the spinner for an insight\n\nHere is an experiment I recommend to understand how spinner_async.py works. Import the time module, then go to the slow coroutine and replace the line await asyncio.sleep(3) with a call to time.sleep(3), like in Example 19-6.\n\nExample 19-6. spinner_async.py: replacing await asyncio.sleep(3) with time.sleep(3)\n\nasync def slow() -> int: time.sleep(3) return 42\n\nWatching the behavior is more memorable than reading about it. Go ahead, I’ll wait.\n\nWhen you run the experiment, this is what you see:\n\n1. The spinner object is shown, similar to this: <Task pending name='Task-2' coro=<spin() running at /path/to/spinner_async.py:12>>.\n\n2. The spinner never appears. The program hangs for 3 seconds. 3. Answer: 42 is displayed and the program ends.\n\nTo understand what is happening, recall that Python code using asyncio has only one flow of execution, unless you’ve explicitly started additional threads or processes. That means only one coroutine executes at any point in time. Concurrency is achieved by control passing from one coroutine to another. In Example 19-7, let’s focus on what happens in the supervisor and slow coroutines during the proposed experiment.\n\nExample 19-7. spinner_async_experiment.py: the supervisor and slow coroutines\n\nasync def slow() -> int: time.sleep(3)\n\nA Concurrent Hello World\n\n|\n\n709\n\nreturn 42\n\nasync def supervisor() -> int: spinner = asyncio.create_task(spin('thinking!')) print(f'spinner object: {spinner}') result = await slow() spinner.cancel() return result\n\nThe spinner task is created, to eventually drive the execution of spin.\n\nThe display shows the Task is “pending.”\n\nThe await expression transfers control to the slow coroutine.\n\ntime.sleep(3) blocks for 3 seconds; nothing else can happen in the program, because the main thread is blocked—and it is the only thread. The operating sys‐ tem will continue with other activities. After 3 seconds, sleep unblocks, and slow returns.\n\nRight after slow returns, the spinner task is cancelled. The flow of control never reached the body of the spin coroutine.\n\nThe spinner_async_experiment.py teaches an important lesson, as explained in the following warning.\n\nNever use time.sleep(…) in asyncio coroutines unless you want to pause your whole program. If a coroutine needs to spend some time doing nothing, it should await asyncio.sleep(DELAY). This yields control back to the asyncio event loop, which can drive other pending coroutines.\n\nGreenlet and gevent As we discuss concurrency with coroutines, it’s important to mention the greenlet package, which has been around for many years and is used at scale.11 The package supports cooperative multitasking through lightweight coroutines—named greenlets —that don’t require any special syntax such as yield or await, therefore are easier to integrate into existing, sequential codebases. SQL Alchemy 1.4 ORM uses greenlets internally to implement its new asynchronous API compatible with asyncio.\n\n11 Thanks to tech reviewers Caleb Hattingh and Jürgen Gmach who did not let me overlook greenlet and gevent.\n\n710\n\n|\n\nChapter 19: Concurrency Models in Python\n\nThe gevent networking library monkey patches Python’s standard socket module making it nonblocking by replacing some of its code with greenlets. To a large extent, gevent is transparent to the surrounding code, making it easier to adapt sequential applications and libraries—such as database drivers—to perform concurrent network I/O. Numerous open source projects use gevent, including the widely deployed Guni‐ corn—mentioned in “WSGI Application Servers” on page 730.\n\nSupervisors Side-by-Side The line count of spinner_thread.py and spinner_async.py is nearly the same. The supervisor functions are the heart of these examples. Let’s compare them in detail. Example 19-8 lists only the supervisor from Example 19-2.\n\nExample 19-8. spinner_thread.py: the threaded supervisor function\n\ndef supervisor() -> int: done = Event() spinner = Thread(target=spin, args=('thinking!', done)) print('spinner object:', spinner) spinner.start() result = slow() done.set() spinner.join() return result\n\nFor comparison, Example 19-9 shows the supervisor coroutine from Example 19-4.\n\nExample 19-9. spinner_async.py: the asynchronous supervisor coroutine\n\nasync def supervisor() -> int: spinner = asyncio.create_task(spin('thinking!')) print('spinner object:', spinner) result = await slow() spinner.cancel() return result\n\nHere is a summary of the differences and similarities to note between the two super visor implementations:\n\nAn asyncio.Task is roughly the equivalent of a threading.Thread. • A Task drives a coroutine object, and a Thread invokes a callable. • A coroutine yields control explicitly with the await keyword.\n\nA Concurrent Hello World\n\n|\n\n711\n\nYou don’t instantiate Task objects yourself, you get them by passing a coroutine to asyncio.create_task(…).\n\nWhen asyncio.create_task(…) returns a Task object, it is already scheduled to run, but a Thread instance must be explicitly told to run by calling its start method.\n\nIn the threaded supervisor, slow is a plain function and is directly invoked by the main thread. In the asynchronous supervisor, slow is a coroutine driven by await.\n\nThere’s no API to terminate a thread from the outside; instead, you must send a signal—like setting the done Event object. For tasks, there is the Task.cancel() instance method, which raises CancelledError at the await expression where the coroutine body is currently suspended.\n\nThe supervisor coroutine must be started with asyncio.run in the main function.\n\nThis comparison should help you understand how concurrent jobs are orchestrated with asyncio, in contrast to how it’s done with the Threading module, which may be more familiar to you.\n\nOne final point related to threads versus coroutines: if you’ve done any nontrivial programming with threads, you know how challenging it is to reason about the pro‐ gram because the scheduler can interrupt a thread at any time. You must remember to hold locks to protect the critical sections of your program, to avoid getting inter‐ rupted in the middle of a multistep operation—which could leave data in an invalid state.\n\nWith coroutines, your code is protected against interruption by default. You must explicitly await to let the rest of the program run. Instead of holding locks to syn‐ chronize the operations of multiple threads, coroutines are “synchronized” by defini‐ tion: only one of them is running at any time. When you want to give up control, you use await to yield control back to the scheduler. That’s why it is possible to safely cancel a coroutine: by definition, a coroutine can only be cancelled when it’s sus‐ pended at an await expression, so you can perform cleanup by handling the Cancel ledError exception.\n\nThe time.sleep() call blocks but does nothing. Now we’ll experiment with a CPU- intensive call to get a better understanding of the GIL, as well as the effect of CPU- intensive functions in asynchronous code.\n\n712\n\n|\n\nChapter 19: Concurrency Models in Python\n\nThe Real Impact of the GIL In the threading code (Example 19-1), you can replace the time.sleep(3) call in the slow function with an HTTP client request from your favorite library, and the spin‐ ner will keep spinning. That’s because a well-designed network library will release the GIL while waiting for the network.\n\nYou can also replace the asyncio.sleep(3) expression in the slow coroutine to await for a response from a well-designed asynchronous network library, because such libraries provide coroutines that yield control back to the event loop while wait‐ ing for the network. Meanwhile, the spinner will keep spinning.\n\nWith CPU-intensive code, the story is different. Consider the function is_prime in Example 19-10, which returns True if the argument is a prime number, False if it’s not.\n\nExample 19-10. primes.py: an easy to read primality check, from Python’s ProcessPool Executor example\n\ndef is_prime(n: int) -> bool: if n < 2: return False if n == 2: return True if n % 2 == 0: return False\n\nroot = math.isqrt(n) for i in range(3, root + 1, 2): if n % i == 0: return False return True\n\nThe call is_prime(5_000_111_000_222_021) takes about 3.3s on the company laptop I am using now.12\n\nQuick Quiz Given what we’ve seen so far, please take the time to consider the following three- part question. One part of the answer is tricky (at least it was for me).\n\nWhat would happen to the spinner animation if you made the following changes, assuming that n = 5_000_111_000_222_021—that prime which my machine takes 3.3s to verify:\n\n12 It’s a 15” MacBook Pro 2018 with a 6-core, 2.2 GHz Intel Core i7 CPU.\n\nThe Real Impact of the GIL\n\n|\n\n713\n\n1. In spinner_proc.py, replace time.sleep(3) with a call to is_prime(n)?\n\n2. In spinner_thread.py, replace time.sleep(3) with a call to is_prime(n)?\n\n3. In\n\nspinner_async.py, replace await asyncio.sleep(3) with a call\n\nis_prime(n)?\n\nBefore you run the code or read on, I recommend figuring out the answers on your own. Then, you may want to copy and modify the spinner_*.py examples as suggested.\n\nNow the answers, from easier to hardest.\n\n1. Answer for multiprocessing\n\nThe spinner is controlled by a child process, so it continues spinning while the pri‐ mality test is computed by the parent process.13\n\n2. Answer for threading\n\nThe spinner is controlled by a secondary thread, so it continues spinning while the primality test is computed by the main thread.\n\nI did not get this answer right at first: I was expecting the spinner to freeze because I overestimated the impact of the GIL.\n\nIn this particular example, the spinner keeps spinning because Python suspends the running thread every 5ms (by default), making the GIL available to other pending threads. Therefore, the main thread running is_prime is interrupted every 5ms, allowing the secondary thread to wake up and iterate once through the for loop, until it calls the wait method of the done event, at which time it will release the GIL. The main thread will then grab the GIL, and the is_prime computation will proceed for another 5ms.\n\nThis does not have a visible impact on the running time of this specific example, because the spin function quickly iterates once and releases the GIL as it waits for the done event, so there is not much contention for the GIL. The main thread running is_prime will have the GIL most of the time.\n\nWe got away with a compute-intensive task using threading in this simple experi‐ ment because there are only two threads: one hogging the CPU, and the other waking up only 10 times per second to update the spinner.\n\n13 This is true today because you are probably using a modern OS with preemptive multitasking. Windows\n\nbefore the NT era and macOS before the OSX era were not “preemptive,” therefore any process could take over 100% of the CPU and freeze the whole system. We are not completely free of this kind of problem today but trust this graybeard: this troubled every user in the 1990s, and a hard reset was the only cure.\n\n714\n\n|\n\nChapter 19: Concurrency Models in Python\n\nto\n\nBut if you have two or more threads vying for a lot of CPU time, your program will be slower than sequential code.\n\n3. Answer for asyncio\n\nIf you call is_prime(5_000_111_000_222_021) in the slow coroutine of the spin‐ ner_async.py example, the spinner will never appear. The effect would be the same we had in Example 19-6, when we replaced await asyncio.sleep(3) with time.sleep(3): no spinning at all. The flow of control will pass from supervisor to slow, and then to is_prime. When is_prime returns, slow returns as well, and super visor resumes, cancelling the spinner task before it is executed even once. The pro‐ gram appears frozen for about 3s, then shows the answer.\n\nPower Napping with sleep(0) One way to keep the spinner alive is to rewrite is_prime as a coroutine, and periodi‐ cally call asyncio.sleep(0) in an await expression to yield control back to the event loop, like in Example 19-11.\n\nExample 19-11. spinner_async_nap.py: is_prime is now a coroutine\n\nasync def is_prime(n): if n < 2: return False if n == 2: return True if n % 2 == 0: return False\n\nroot = math.isqrt(n) for i in range(3, root + 1, 2): if n % i == 0: return False if i % 100_000 == 1: await asyncio.sleep(0) return True\n\nSleep once every 50,000 iterations (because the step in the range is 2).\n\nIssue #284 in the asyncio repository has an informative discussion about the use of asyncio.sleep(0).\n\nHowever, be aware this will slow down is_prime, and—more importantly—will still slow down the event loop and your whole program with it. When I used await asyn cio.sleep(0) every 100,000 iterations, the spinner was smooth but the program ran in 4.9s on my machine, almost 50% longer than the original primes.is_prime func‐ tion by itself with the same argument (5_000_111_000_222_021).\n\nThe Real Impact of the GIL\n\n|\n\n715\n\nUsing await asyncio.sleep(0) should be considered a stopgap measure before you refactor your asynchronous code to delegate CPU-intensive computations to another process. We’ll see one way of doing that with asyncio.loop.run_in_executor, cov‐ ered in Chapter 21. Another option would be a task queue, which we’ll briefly discuss in “Distributed Task Queues” on page 732.\n\nSo far, we’ve only experimented with a single call to a CPU-intensive function. The next section presents concurrent execution of multiple CPU-intensive calls.\n\nA Homegrown Process Pool\n\nI wrote this section to show the use of multiple processes for CPU- intensive tasks, and the common pattern of using queues to distrib‐ ute tasks and collect results. Chapter 20 will show a simpler way of distributing tasks to processes: a ProcessPoolExecutor from the concurrent.futures package, which uses queues internally.\n\nIn this section we’ll write programs to compute the primality of a sample of 20 inte‐ gers, from 2 to 9,999,999,999,999,999—i.e., 1016 – 1, or more than 253. The sample includes small and large primes, as well as composite numbers with small and large prime factors.\n\nThe sequential.py program provides the performance baseline. Here is a sample run:\n\n$ python3 sequential.py 2 P 0.000001s 142702110479723 P 0.568328s 299593572317531 P 0.796773s 3333333333333301 P 2.648625s 3333333333333333 0.000007s 3333335652092209 2.672323s 4444444444444423 P 3.052667s 4444444444444444 0.000001s 4444444488888889 3.061083s 5555553133149889 3.451833s 5555555555555503 P 3.556867s 5555555555555555 0.000007s 6666666666666666 0.000001s 6666666666666719 P 3.781064s 6666667141414921 3.778166s 7777777536340681 4.120069s 7777777777777753 P 4.141530s 7777777777777777 0.000007s 9999999999999917 P 4.678164s 9999999999999999 0.000007s Total time: 40.31\n\n716\n\n|\n\nChapter 19: Concurrency Models in Python\n\nThe results are shown in three columns:\n\nThe number to be checked. • P if it’s a prime number, blank if not.\n\nElapsed time for checking the primality for that specific number.\n\nIn this example, the total time is approximately the sum of the times for each check, but it is computed separately, as you can see in Example 19-12.\n\nExample 19-12. sequential.py: sequential primality check for a small dataset\n\n#!/usr/bin/env python3\n\n\"\"\" sequential.py: baseline for comparing sequential, multiprocessing, and threading code for CPU-intensive work. \"\"\"\n\nfrom time import perf_counter from typing import NamedTuple\n\nfrom primes import is_prime, NUMBERS\n\nclass Result(NamedTuple): prime: bool elapsed: float\n\ndef check(n: int) -> Result: t0 = perf_counter() prime = is_prime(n) return Result(prime, perf_counter() - t0)\n\ndef main() -> None: print(f'Checking {len(NUMBERS)} numbers sequentially:') t0 = perf_counter() for n in NUMBERS: prime, elapsed = check(n) label = 'P' if prime else ' ' print(f'{n:16} {label} {elapsed:9.6f}s')\n\nelapsed = perf_counter() - t0 print(f'Total time: {elapsed:.2f}s')\n\nif __name__ == '__main__': main()\n\nA Homegrown Process Pool\n\n|\n\n717\n\nThe check function (in the next callout) returns a Result tuple with the boolean value of the is_prime call and the elapsed time.\n\ncheck(n) calls is_prime(n) and computes the elapsed time to return a Result.\n\nFor each number in the sample, we call check and display the result.\n\nCompute and display the total elapsed time.\n\nProcess-Based Solution The next example, procs.py, shows the use of multiple processes to distribute the pri‐ mality checks across multiple CPU cores. These are the times I get with procs.py:\n\n$ python3 procs.py Checking 20 numbers with 12 processes: 2 P 0.000002s 3333333333333333 0.000021s 4444444444444444 0.000002s 5555555555555555 0.000018s 6666666666666666 0.000002s 142702110479723 P 1.350982s 7777777777777777 0.000009s 299593572317531 P 1.981411s 9999999999999999 0.000008s 3333333333333301 P 6.328173s 3333335652092209 6.419249s 4444444488888889 7.051267s 4444444444444423 P 7.122004s 5555553133149889 7.412735s 5555555555555503 P 7.603327s 6666666666666719 P 7.934670s 6666667141414921 8.017599s 7777777536340681 8.339623s 7777777777777753 P 8.388859s 9999999999999917 P 8.117313s 20 checks in 9.58s\n\nThe last line of the output shows that procs.py was 4.2 times faster than sequential.py.\n\nUnderstanding the Elapsed Times Note that the elapsed time in the first column is for checking that specific number. For example, is_prime(7777777777777753) took almost 8.4s to return True. Mean‐ while, other processes were checking other numbers in parallel.\n\nThere were 20 numbers to check. I wrote procs.py to start a number of worker pro‐ cesses equal to the number of CPU cores, as determined by multiprocess ing.cpu_count().\n\n718\n\n|\n\nChapter 19: Concurrency Models in Python\n\nThe total time in this case is much less than the sum of the elapsed time for the indi‐ vidual checks. There is some overhead in spinning up processes and in inter-process communication, so the end result is that the multiprocess version is only about 4.2 times faster than the sequential. That’s good, but a little disappointing considering the code launches 12 processes to use all cores on this laptop.\n\nThe multiprocessing.cpu_count() function returns 12 on the MacBook Pro I’m using to write this chapter. It’s actually a 6-CPU Core-i7, but the OS reports 12 CPUs because of hyperthreading, an Intel technology which executes 2 threads per core. However, hyperthreading works better when one of the threads is not work‐ ing as hard as the other thread in the same core—perhaps the first is stalled waiting for data after a cache miss, and the other is crunching numbers. Anyway, there’s no free lunch: this laptop per‐ forms like a 6-CPU machine for compute-intensive work that doesn’t use a lot of memory—like that simple primality test.\n\nCode for the Multicore Prime Checker When we delegate computing to threads or processes, our code does not call the worker function directly, so we can’t simply get a return value. Instead, the worker is driven by the thread or process library, and it eventually produces a result that needs to be stored somewhere. Coordinating workers and collecting results are common uses of queues in concurrent programming—and also in distributed systems.\n\nMuch of the new code in procs.py has to do with setting up and using queues. The top of the file is in Example 19-13.\n\nSimpleQueue was added to multiprocessing in Python 3.9. If you’re using an earlier version of Python, you can replace Simple Queue with Queue in Example 19-13.\n\nExample 19-13. procs.py: multiprocess primality check; imports, types, and functions\n\nimport sys from time import perf_counter from typing import NamedTuple from multiprocessing import Process, SimpleQueue, cpu_count from multiprocessing import queues\n\nfrom primes import is_prime, NUMBERS\n\nclass PrimeResult(NamedTuple): n: int\n\nA Homegrown Process Pool\n\n|\n\n719\n\nprime: bool elapsed: float\n\nJobQueue = queues.SimpleQueue[int] ResultQueue = queues.SimpleQueue[PrimeResult]\n\ndef check(n: int) -> PrimeResult: t0 = perf_counter() res = is_prime(n) return PrimeResult(n, res, perf_counter() - t0)\n\ndef worker(jobs: JobQueue, results: ResultQueue) -> None: while n := jobs.get(): results.put(check(n)) results.put(PrimeResult(0, False, 0.0))\n\ndef start_jobs( procs: int, jobs: JobQueue, results: ResultQueue ) -> None: for n in NUMBERS: jobs.put(n) for _ in range(procs): proc = Process(target=worker, args=(jobs, results)) proc.start() jobs.put(0)\n\nTrying to emulate threading, multiprocessing provides multiprocessing.Sim pleQueue, but this is a method bound to a predefined instance of a lower-level BaseContext class. We must call this SimpleQueue to build a queue, we can’t use it in type hints.\n\nmultiprocessing.queues has the SimpleQueue class we need for type hints.\n\nPrimeResult includes the number checked for primality. Keeping n together with the other result fields simplifies displaying results later.\n\nThis is a type alias for a SimpleQueue that the main function (Example 19-14) will use to send numbers to the processes that will do the work.\n\nType alias for a second SimpleQueue that will collect the results in main. The val‐ ues in the queue will be tuples made of the number to be tested for primality, and a Result tuple.\n\nThis is similar to sequential.py.\n\nworker gets a queue with the numbers to be checked, and another to put results.\n\n720\n\n|\n\nChapter 19: Concurrency Models in Python",
      "page_number": 718
    },
    {
      "number": 37,
      "title": "Segment 37 (pages 738-758)",
      "start_page": 738,
      "end_page": 758,
      "detection_method": "synthetic",
      "content": "In this code, I use the number 0 as a poison pill: a signal for the worker to finish. If n is not 0, proceed with the loop.14\n\nInvoke the primality check and enqueue PrimeResult.\n\nSend back a PrimeResult(0, False, 0.0) to let the main loop know that this worker is done.\n\nprocs is the number of processes that will compute the prime checks in parallel.\n\nEnqueue the numbers to be checked in jobs.\n\nFork a child process for each worker. Each child will run the loop inside its own instance of the worker function, until it fetches a 0 from the jobs queue.\n\nStart each child process.\n\nEnqueue one 0 for each process, to terminate them.\n\nLoops, Sentinels, and Poison Pills The worker function in Example 19-13 follows a common pattern in concurrent pro‐ gramming: looping indefinitely while taking items from a queue and processing each with a function that does the actual work. The loop ends when the queue produces a sentinel value. In this pattern, the sentinel that shuts down the worker is often called a “poison pill.”\n\nNone is often used as a sentinel value, but it may be unsuitable if it can occur in the data stream. Calling object() is a common way to get a unique value to use as senti‐ nel. However, that does not work across processes because Python objects must be serialized for inter-process communication, and when you pickle.dump and pickle.load an instance of object, the unpickled instance is distinct from the origi‐ nal: it doesn’t compare equal. A good alternative to None is the Ellipsis built-in object (a.k.a. ...), which survives serialization without losing its identity.15\n\nPython’s standard library uses lots of different values as sentinels. PEP 661—Sentinel Values proposes a standard sentinel type. As of September 2021, it’s only a draft.\n\n14 In this example, 0 is a convenient sentinel. None is also commonly used for that. Using 0 simplifies the type\n\nhint for PrimeResult and the code for worker.\n\n15 Surviving serialization without losing our identity is a pretty good life goal.\n\nA Homegrown Process Pool\n\n|\n\n721\n\nNow let’s study the main function of procs.py in Example 19-14.\n\nExample 19-14. procs.py: multiprocess primality check; main function\n\ndef main() -> None: if len(sys.argv) < 2: procs = cpu_count() else: procs = int(sys.argv[1])\n\nprint(f'Checking {len(NUMBERS)} numbers with {procs} processes:') t0 = perf_counter() jobs: JobQueue = SimpleQueue() results: ResultQueue = SimpleQueue() start_jobs(procs, jobs, results) checked = report(procs, results) elapsed = perf_counter() - t0 print(f'{checked} checks in {elapsed:.2f}s')\n\ndef report(procs: int, results: ResultQueue) -> int: checked = 0 procs_done = 0 while procs_done < procs: n, prime, elapsed = results.get() if n == 0: procs_done += 1 else: checked += 1 label = 'P' if prime else ' ' print(f'{n:16} {label} {elapsed:9.6f}s') return checked\n\nif __name__ == '__main__': main()\n\nIf no command-line argument is given, set the number of processes to the num‐ ber of CPU cores; otherwise, create as many processes as given in the first argument.\n\njobs and results are the queues described in Example 19-13.\n\nStart proc processes to consume jobs and post results.\n\nRetrieve the results and display them; report is defined in\n\n.\n\nDisplay how many numbers were checked and the total elapsed time.\n\nThe arguments are the number of procs and the queue to post the results.\n\n722\n\n|\n\nChapter 19: Concurrency Models in Python\n\nLoop until all processes are done.\n\nGet one PrimeResult. Calling .get() on a queue block until there is an item in the queue. It’s also possible to make this nonblocking, or set a timeout. See the SimpleQueue.get documentation for details.\n\nIf n is zero, then one process exited; increment the procs_done count.\n\nOtherwise, increment the checked count (to keep track of the numbers checked) and display the results.\n\nThe results will not come back in the same order the jobs were submitted. That’s why I had to put n in each PrimeResult tuple. Otherwise, I’d have no way to know which result belonged to each number.\n\nIf the main process exits before all subprocesses are done, you may see confusing tracebacks on FileNotFoundError exceptions caused by an internal lock in multi processing. Debugging concurrent code is always hard, and debugging multiproc essing is even harder because of all the complexity behind the thread-like façade. Fortunately, the ProcessPoolExecutor we’ll meet in Chapter 20 is easier to use and more robust.\n\nThanks to reader Michael Albert who noticed the code I published during the early release had a race condition in Example 19-14. A race condition is a bug that may or may not occur depending on the order of actions performed by concurrent execution units. If “A” happens before “B,” all is fine; but it “B” happens first, some‐ thing goes wrong. That’s the race.\n\nIf you are curious, this diff shows the bug and how I fixed it: example-code-2e/commit/2c123057—but note that I later refactored the example to delegate parts of main to the start_jobs and report functions. There’s a README.md file in the same directory explaining the problem and the solution.\n\nExperimenting with More or Fewer Processes You may want try running procs.py, passing arguments to set the number of worker processes. For example, this command…\n\n$ python3 procs.py 2\n\n…will launch two worker processes, producing results almost twice as fast as sequen‐ tial.py—if your machine has at least two cores and is not too busy running other programs.\n\nA Homegrown Process Pool\n\n|\n\n723\n\nI ran procs.py 12 times with 1 to 20 processes, totaling 240 runs. Then I computed the median time for all runs with the same number of processes, and plotted Figure 19-2.\n\nFigure 19-2. Median run times for each number of processes from 1 to 20. Highest median time was 40.81s, with 1 process. Lowest median time was 10.39s, with 6 pro‐ cesses, indicated by the dotted line.\n\nIn this 6-core laptop, the lowest median time was with 6 processes: 10.39s—marked by the dotted line in Figure 19-2. I expected the run time to increase after 6 processes due to CPU contention, and it reached a local maximum of 12.51s at 10 processes. I did not expect and I can’t explain why the performance improved at 11 processes and remained almost flat from 13 to 20 processes, with median times only slightly higher than the lowest median time at 6 processes.\n\nThread-Based Nonsolution I also wrote threads.py, a version of procs.py using threading instead of multiproc essing. The code is very similar—as is usually the case when converting simple examples between these two APIs.16 Due to the GIL and the compute-intensive nature of is_prime, the threaded version is slower than the sequential code in Example 19-12, and it gets slower as the number of threads increase, because of CPU contention and the cost of context switching. To switch to a new thread, the OS needs to save CPU registers and update the program counter and stack pointer,\n\n16 See 19-concurrency/primes/threads.py in the Fluent Python code repository.\n\n724\n\n|\n\nChapter 19: Concurrency Models in Python\n\ntriggering expensive side effects like invalidating CPU caches and possibly even swapping memory pages.17\n\nThe next two chapters will cover more about concurrent programming in Python, using the high-level concurrent.futures library to manage threads and processes (Chapter 20) and the asyncio library for asynchronous programming (Chapter 21).\n\nThe remaining sections in this chapter aim to answer the question:\n\nGiven the limitations discussed so far, how is Python thriving in a multicore world?\n\nPython in the Multicore World Consider this citation from the widely quoted article “The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software” by Herb Sutter:\n\nThe major processor manufacturers and architectures, from Intel and AMD to Sparc and PowerPC, have run out of room with most of their traditional approaches to boosting CPU performance. Instead of driving clock speeds and straight-line instruc‐ tion throughput ever higher, they are instead turning en masse to hyper-threading and multicore architectures. March 2005. [Available online].\n\nWhat Sutter calls the “free lunch” was the trend of software getting faster with no additional developer effort because CPUs were executing sequential code faster, year after year. Since 2004, that is no longer true: clock speeds and execution optimiza‐ tions reached a plateau, and now any significant increase in performance must come from leveraging multiple cores or hyperthreading, advances that only benefit code that is written for concurrent execution.\n\nPython’s story started in the early 1990s, when CPUs were still getting exponentially faster at sequential code execution. There was no talk about multicore CPUs except in supercomputers back then. At the time, the decision to have a GIL was a no- brainer. The GIL makes the interpreter faster when running on a single core, and its implementation simpler.18 The GIL also makes it easier to write simple extensions through the Python/C API.\n\n17 To learn more, see “Context switch” in the English Wikipedia.\n\n18 These are probably the same reasons that prompted the creator of the Ruby language, Yukihiro Matsumoto,\n\nto use a GIL in his interpreter as well.\n\nPython in the Multicore World\n\n|\n\n725\n\nI just wrote “simple extensions” because an extension does not need to deal with the GIL at all. A function written in C or Fortran may be hundreds of times faster than the equivalent in Python.19 Therefore the added complexity of releasing the GIL to leverage multicore CPUs may not be needed in many cases. So we can thank the GIL for many extensions available for Python—and that is certainly one of the key reasons why the language is so popular today.\n\nDespite the GIL, Python is thriving in applications that require concurrent or parallel execution, thanks to libraries and software architectures that work around the limita‐ tions of CPython.\n\nNow let’s discuss how Python is used in system administration, data science, and server-side application development in the multicore, distributed computing world of 2021.\n\nSystem Administration Python is widely used to manage large fleets of servers, routers, load balancers, and network-attached storage (NAS). It’s also a leading option in software-defined net‐ working (SDN) and ethical hacking. Major cloud service providers support Python through libraries and tutorials authored by the providers themselves or by their large communities of Python users.\n\nIn this domain, Python scripts automate configuration tasks by issuing commands to be carried out by the remote machines, so rarely there are CPU-bound operations to be done. Threads or coroutines are well suited for such jobs. In particular, the concur rent.futures package we’ll see in Chapter 20 can be used to perform the same oper‐ ations on many remote machines at the same time without a lot of complexity.\n\nBeyond the standard library, there are popular Python-based projects to manage server clusters: tools like Ansible and Salt, as well as libraries like Fabric.\n\nThere is also a growing number of libraries for system administration supporting coroutines and asyncio. In 2016, Facebook’s Production Engineering team reported: “We are increasingly relying on AsyncIO, which was introduced in Python 3.4, and seeing huge performance gains as we move codebases away from Python 2.”\n\n19 As an exercise in college, I had to implement the LZW compression algorithm in C. But first I wrote it in\n\nPython, to check my understanding of the spec. The C version was about 900× faster.\n\n726\n\n|\n\nChapter 19: Concurrency Models in Python\n\nData Science Data science—including artificial intelligence—and scientific computing are very well served by Python. Applications in these fields are compute-intensive, but Python users benefit from a vast ecosystem of numeric computing libraries written in C, C++, Fortran, Cython, etc.—many of which are able to leverage multicore machines, GPUs, and/or distributed parallel computing in heterogeneous clusters.\n\nAs of 2021, Python’s data science ecosystem includes impressive tools such as:\n\nProject Jupyter\n\nTwo browser-based interfaces—Jupyter Notebook and JupyterLab—that allow users to run and document analytics code potentially running across the network on remote machines. Both are hybrid Python/JavaScript applications, supporting computing kernels written in different languages, all integrated via ZeroMQ—an asynchronous messaging library for distributed applications. The name Jupyter actually comes from Julia, Python, and R, the first three languages supported by the Notebook. The rich ecosystem built on top of the Jupyter tools include Bokeh, a powerful interactive visualization library that lets users navigate and interact with large datasets or continuously updated streaming data, thanks to the performance of modern JavaScript engines and browsers.\n\nTensorFlow and PyTorch\n\nThese are the top two deep learning frameworks, according to O’Reilly’s January 2021 report on usage of their learning resources during 2020. Both projects are written in C++, and are able to leverage multiple cores, GPUs, and clusters. They support other languages as well, but Python is their main focus and is used by the majority of their users. TensorFlow was created and is used internally by Google; PyTorch by Facebook.\n\nDask\n\nA parallel computing library that can farm out work to local processes or clusters of machines, “tested on some of the largest supercomputers in the world”—as their home page states. Dask offers APIs that closely emulate NumPy, pandas, and scikit-learn—the most popular libraries in data science and machine learn‐ ing today. Dask can be used from JupyterLab or Jupyter Notebook, and leverages Bokeh not only for data visualization but also for an interactive dashboard show‐ ing the flow of data and computations across the processes/machines in near real time. Dask is so impressive that I recommend watching a video such as this 15- minute demo in which Matthew Rocklin—a maintainer of the project—shows Dask crunching data on 64 cores distributed in 8 EC2 machines on AWS.\n\nThese are only some examples to illustrate how the data science community is creat‐ ing solutions that leverage the best of Python and overcome the limitations of the CPython runtime.\n\nPython in the Multicore World\n\n|\n\n727\n\nServer-Side Web/Mobile Development Python is widely used in web applications and for the backend APIs supporting mobile applications. How is it that Google, YouTube, Dropbox, Instagram, Quora, and Reddit—among others—managed to build Python server-side applications serv‐ ing hundreds of millions of users 24x7? Again, the answer goes way beyond what Python provides “out of the box.”\n\nBefore we discuss tools to support Python at scale, I must quote an admonition from the Thoughtworks Technology Radar:\n\nHigh performance envy/web scale envy\n\nWe see many teams run into trouble because they have chosen complex tools, frame‐ works or architectures because they “might need to scale.” Companies such as Twitter and Netflix need to support extreme loads and so need these architectures, but they also have extremely skilled development teams able to handle the complexity. Most sit‐ uations do not require these kinds of engineering feats; teams should keep their web scale envy in check in favor of simpler solutions that still get the job done.20\n\nAt web scale, the key is an architecture that allows horizontal scaling. At that point, all systems are distributed systems, and no single programming language is likely to be the right choice for every part of the solution.\n\nDistributed systems is a field of academic research, but fortunately some practitioners have written accessible books anchored on solid research and practical experience. One of them is Martin Kleppmann, the author of Designing Data-Intensive Applica‐ tions (O’Reilly).\n\nConsider Figure 19-3, the first of many architecture diagrams in Kleppmann’s book. Here are some components I’ve seen in Python engagements that I worked on or have firsthand knowledge of:\n\nApplication caches:21 memcached, Redis, Varnish\n\nRelational databases: PostgreSQL, MySQL\n\nDocument databases: Apache CouchDB, MongoDB\n\nFull-text indexes: Elasticsearch, Apache Solr\n\nMessage queues: RabbitMQ, Redis\n\n20 Source: Thoughtworks Technology Advisory Board, Technology Radar—November 2015.\n\n21 Contrast application caches—used directly by your application code—with HTTP caches, which would be placed on the top edge of Figure 19-3 to serve static assets like images, CSS, and JS files. Content Delivery Networks (CDNs) offer another type of HTTP cache, deployed in data centers closer to the end users of your application.\n\n728\n\n|\n\nChapter 19: Concurrency Models in Python\n\nFigure 19-3. One possible architecture for a system combining several components.22\n\nThere are other industrial-strength open source products in each of those categories. Major cloud providers also offer their own proprietary alternatives.\n\nKleppmann’s diagram is general and language independent—as is his book. For Python server-side applications, two specific components are often deployed:\n\nAn application server to distribute the load among several instances of the Python application. The application server would appear near the top in Figure 19-3, handling client requests before they reached the application code.\n\nA task queue built around the message queue on the righthand side of Figure 19-3, providing a higher-level, easier-to-use API to distribute tasks to pro‐ cesses running on other machines.\n\n22 Diagram adapted from Figure 1-1, Designing Data-Intensive Applications by Martin Kleppmann (O’Reilly).\n\nPython in the Multicore World\n\n|\n\n729\n\nThe next two sections explore these components that are recommended best practi‐ ces in Python server-side deployments.\n\nWSGI Application Servers WSGI—the Web Server Gateway Interface—is a standard API for a Python frame‐ work or application to receive requests from an HTTP server and send responses to it.23 WSGI application servers manage one or more processes running your applica‐ tion, maximizing the use of the available CPUs.\n\nFigure 19-4 illustrates a typical WSGI deployment.\n\nIf we wanted to merge the previous pair of diagrams, the content of the dashed rectangle in Figure 19-4 would replace the solid “Appli‐ cation code” rectangle at the top of Figure 19-3.\n\nThe best-known application servers in Python web projects are:\n\nmod_wsgi • uWSGI24\n\nGunicorn\n\nNGINX Unit\n\nFor users of the Apache HTTP server, mod_wsgi is the best option. It’s as old as WSGI itself, but is actively maintained, and now provides a command-line launcher called mod_wsgi-express that makes it easier to configure and more suitable for use in Docker containers.\n\n23 Some speakers spell out the WSGI acronym, while others pronounce it as one word rhyming with “whisky.”\n\n24 uWSGI is spelled with a lowercase “u,” but that is pronounced as the Greek letter “µ,” so the whole name\n\nsounds like “micro-whisky” with a “g” instead of the “k.”\n\n730\n\n|\n\nChapter 19: Concurrency Models in Python\n\nFigure 19-4. Clients connect to an HTTP server that delivers static files and routes other requests to the application server, which forks child processes to run the applica‐ tion code, leveraging multiple CPU cores. The WSGI API is the glue between the appli‐ cation server and the Python application code.\n\nuWSGI and Gunicorn are the top choices in recent projects I know about. Both are often used with the NGINX HTTP server. uWSGI offers a lot of extra functionality, including an application cache, a task queue, cron-like periodic tasks, and many other features. On the flip side, uWSGI is much harder to configure properly than Gunicorn.25\n\nReleased in 2018, NGINX Unit is a new product from the makers of the well-known NGINX HTTP server and reverse proxy.\n\n25 Bloomberg engineers Peter Sperl and Ben Green wrote “Configuring uWSGI for Production Deployment”, explaining how many of the default settings in uWSGI are not suitable for many common deployment sce‐ narios. Sperl presented a summary of their recommendations at EuroPython 2019. Highly recommended for users of uWSGI.\n\nPython in the Multicore World\n\n|\n\n731\n\nmod_wsgi and Gunicorn support Python web apps only, while uWSGI and NGINX Unit work with other languages as well. Please browse their docs to learn more.\n\nThe main point: all of these application servers can potentially use all CPU cores on the server by forking multiple Python processes to run traditional web apps written in good old sequential code in Django, Flask, Pyramid, etc. This explains why it’s been possible to earn a living as a Python web developer without ever studying the threading, multiprocessing, or asyncio modules: the application server handles concurrency transparently.\n\nASGI—Asynchronous Server Gateway Interface\n\nWSGI is a synchronous API. It doesn’t support coroutines with async/await—the most efficient way to implement WebSockets or HTTP long polling in Python. The ASGI specification is a succes‐ sor to WSGI, designed for asynchronous Python web frameworks such as aiohttp, Sanic, FastAPI, etc., as well as Django and Flask, which are gradually adding asynchronous functionality.\n\nNow let’s turn to another way of bypassing the GIL to achieve higher performance with server-side Python applications.\n\nDistributed Task Queues When the application server delivers a request to one of the Python processes run‐ ning your code, your app needs to respond quickly: you want the process to be avail‐ able to handle the next request as soon as possible. However, some requests demand actions that may take longer—for example, sending email or generating a PDF. That’s the problem that distributed task queues are designed to solve.\n\nCelery and RQ are the best known open source task queues with Python APIs. Cloud providers also offer their own proprietary task queues.\n\nThese products wrap a message queue and offer a high-level API for delegating tasks to workers, possibly running on different machines.\n\nIn the context of task queues, the words producer and consumer are used instead of traditional client/server terminology. For example, a Django view handler produces job requests, which are put in the queue to be consumed by one or more PDF rendering processes.\n\nQuoting directly from Celery’s FAQ, here are some typical use cases:\n\nRunning something in the background. For example, to finish the web request as soon as possible, then update the users page incrementally. This gives the user the\n\n732\n\n|\n\nChapter 19: Concurrency Models in Python\n\nimpression of good performance and “snappiness,” even though the real work might actually take some time.\n\nRunning something after the web request has finished.\n\nMaking sure something is done, by executing it asynchronously and using retries.\n\nScheduling periodic work.\n\nBesides solving these immediate problems, task queues support horizontal scalability. Producers and consumers are decoupled: a producer doesn’t call a consumer, it puts a request in a queue. Consumers don’t need to know anything about the producers (but the request may include information about the producer, if an acknowledgment is required). Crucially, you can easily add more workers to consume tasks as demand grows. That’s why Celery and RQ are called distributed task queues.\n\nRecall that our simple procs.py (Example 19-13) used two queues: one for job requests, the other for collecting results. The distributed architecture of Celery and RQ uses a similar pattern. Both support using the Redis NoSQL database as a message queue and result storage. Celery also supports other message queues like RabbitMQ or Amazon SQS, as well other databases for result storage.\n\nThis wraps up our introduction to concurrency in Python. The next two chapters will continue this theme, focusing on the concurrent.futures and asyncio packages of the standard library.\n\nChapter Summary After a bit of theory, this chapter presented the spinner scripts implemented in each of Python’s three native concurrency programming models:\n\nThreads, with the threading package • Processes, with multiprocessing • Asynchronous coroutines with asyncio\n\nWe then explored the real impact of the GIL with an experiment: changing the spin‐ ner examples to compute the primality of a large integer and observe the resulting behavior. This demonstrated graphically that CPU-intensive functions must be avoi‐ ded in asyncio, as they block the event loop. The threaded version of the experiment worked—despite the GIL—because Python periodically interrupts threads, and the example used only two threads: one doing compute-intensive work, and the other driving the animation only 10 times per second. The multiprocessing variant worked around the GIL, starting a new process just for the animation, while the main process did the primality check.\n\nChapter Summary\n\n|\n\n733\n\nThe next example, computing several primes, highlighted the difference between mul tiprocessing and threading, proving that only processes allow Python to benefit from multicore CPUs. Python’s GIL makes threads worse than sequential code for heavy computations.\n\nThe GIL dominates discussions about concurrent and parallel computing in Python, but we should not overestimate its impact. That was the point of “Python in the Mul‐ ticore World” on page 725. For example, the GIL doesn’t affect many use cases of Python in system administration. On the other hand, the data science and server-side development communities have worked around the GIL with industrial-strength sol‐ utions tailored to their specific needs. The last two sections mentioned two common elements to support Python server-side applications at scale: WSGI application servers and distributed task queues.\n\nFurther Reading This chapter has an extensive reading list, so I split it into subsections.\n\nConcurrency with Threads and Processes The concurrent.futures library covered in Chapter 20 uses threads, processes, locks, and queues under the hood, but you won’t see individual instances of them; they’re bundled and managed by the higher-level abstractions of a ThreadPoolExecutor and a ProcessPoolExecutor. If you want to learn more about the practice of concurrent programming with those low-level objects, “An Intro to Threading in Python” by Jim Anderson is a good first read. Doug Hellmann has a chapter titled “Concurrency with Processes, Threads, and Coroutines” on his website and book, The Python 3 Standard Library by Example (Addison-Wesley).\n\nBrett Slatkin’s Effective Python, 2nd ed. (Addison-Wesley), David Beazley’s Python Essential Reference, 4th ed. (Addison-Wesley), and Martelli et al., Python in a Nut‐ shell, 3rd ed. (O’Reilly) are other general Python references with significant coverage of threading and multiprocessing. The vast multiprocessing official documenta‐ tion includes useful advice in its “Programming guidelines” section.\n\nJesse Noller and Richard Oudkerk contributed the multiprocessing package, intro‐ duced in PEP 371—Addition of the multiprocessing package to the standard library. The official documentation for the package is a 93 KB .rst file—that’s about 63 pages —making it one of the longest chapters in the Python standard library.\n\nIn High Performance Python, 2nd ed., (O’Reilly), authors Micha Gorelick and Ian Ozsvald include a chapter about multiprocessing with an example about checking for primes with a different strategy than our procs.py example. For each number, they split the range of possible factors—from 2 to sqrt(n)—into subranges, and make\n\n734\n\n|\n\nChapter 19: Concurrency Models in Python\n\neach worker iterate over one of the subranges. Their divide-and-conquer approach is typical of scientific computing applications where the datasets are huge, and worksta‐ tions (or clusters) have more CPU cores than users. On a server-side system handling requests from many users, it is simpler and more efficient to let each process work on one computation from start to finish—reducing the overhead of communication and coordination among processes. Besides multiprocessing, Gorelick and Ozsvald present many other ways of developing and deploying high-performance data science applications leveraging multiple cores, GPUs, clusters, profilers, and compilers like Cython and Numba. Their last chapter, “Lessons from the Field,” is a valuable collec‐ tion of short case studies contributed by other practitioners of high-performance computing in Python.\n\nAdvanced Python Development by Matthew Wilkes (Apress), is a rare book that includes short examples to explain concepts, while also showing how to build a realis‐ tic application ready for production: a data aggregator, similar to DevOps monitoring systems or IoT data collectors for distributed sensors. Two chapters in Advanced Python Development cover concurrent programming with threading and asyncio.\n\nJan Palach’s Parallel Programming with Python (Packt, 2014) explains the core con‐ cepts behind concurrency and parallelism, covering Python’s standard library as well as Celery.\n\n“The Truth About Threads” is the title of Chapter 2 in Using Asyncio in Python by Caleb Hattingh (O’Reilly).26 The chapter covers the benefits and drawbacks of thread‐ ing—with compelling quotes from several authoritative sources—making it clear that the fundamental challenges of threads have nothing to do with Python or the GIL. Quoting verbatim from page 14 of Using Asyncio in Python:\n\nThese themes repeat throughout:\n\nThreading makes code hard to reason about.\n\nThreading is an inefficient model for large-scale concurrency (thousands of con‐ current tasks).\n\nIf you want to learn the hard way how difficult it is to reason about threads and locks —without risking your job—try the exercises in Allen Downey’s workbook, The Little Book of Semaphores (Green Tea Press). The exercises in Downey’s book range from easy to very hard to unsolvable, but even the easy ones are eye-opening.\n\n26 Caleb is one of the tech reviewers for this edition of Fluent Python.\n\nFurther Reading\n\n|\n\n735\n\nThe GIL If you are intrigued about the GIL, remember we have no control over it from Python code, so the canonical reference is in the C-API documentation: Thread State and the Global Interpreter Lock. The Python Library and Extension FAQ answers: “Can’t we get rid of the Global Interpreter Lock?”. Also worth reading are posts by Guido van Rossum and Jesse Noller (contributor of the multiprocessing package), respectively: “It isn’t Easy to Remove the GIL” and “Python Threads and the Global Interpreter Lock”.\n\nCPython Internals by Anthony Shaw (Real Python) explains the implementation of the CPython 3 interpreter at the C programming level. Shaw’s longest chapter is “Parallelism and Concurrency”: a deep dive into Python’s native support for threads and processes, including managing the GIL from extensions using the C/Python API.\n\nFinally, David Beazley presented a detailed exploration in “Understanding the Python GIL”.27 In slide #54 of the presentation, Beazley reports an increase in pro‐ cessing time for a particular benchmark with the new GIL algorithm introduced in Python 3.2. The issue is not significant with real workloads, according to a comment by Antoine Pitrou—who implemented the new GIL algorithm—in the bug report submitted by Beazley: Python issue #7946.\n\nConcurrency Beyond the Standard Library Fluent Python focuses on core language features and core parts of the standard library. Full Stack Python is a great complement to this book: it’s about Python’s eco‐ system, with sections titled “Development Environments,” “Data,” “Web Develop‐ ment,” and “DevOps,” among others.\n\nI’ve already mentioned two books that cover concurrency using the Python standard library that also include significant content on third-party libraries and tools: High Performance Python, 2nd ed. and Parallel Programming with Python. Francesco Pierfederici’s Distributed Computing with Python (Packt) covers the standard library and also the use of cloud providers and HPC (High-Performance Computing) clus‐ ters.\n\n“Python, Performance, and GPUs” by Matthew Rocklin is “a status update for using GPU accelerators from Python,” posted in June 2019.\n\n“Instagram currently features the world’s largest deployment of the Django web framework, which is written entirely in Python.” That’s the opening sentence of the blog post, “Web Service Efficiency at Instagram with Python”, written by Min Ni—a software engineer at Instagram. The post describes metrics and tools Instagram uses\n\n27 Thanks to Lucas Brunialti for sending me a link to this talk.\n\n736\n\n|\n\nChapter 19: Concurrency Models in Python\n\nto optimize the efficiency of its Python codebase, as well as detect and diagnose per‐ formance regressions as it deploys its back end “30-50 times a day.”\n\nArchitecture Patterns with Python: Enabling Test-Driven Development, Domain- Driven Design, and Event-Driven Microservices by Harry Percival and Bob Gregory (O’Reilly) presents architectural patterns for Python server-side applications. The authors also made the book freely available online at cosmicpython.com.\n\nTwo elegant and easy-to-use libraries for parallelizing tasks over processes are lelo by João S. O. Bueno and python-parallelize by Nat Pryce. The lelo package defines a @par allel decorator that you can apply to any function to magically make it unblocking: when you call the decorated function, its execution is started in another process. Nat Pryce’s python-parallelize package provides a parallelize generator that distributes the execution of a for loop over multiple CPUs. Both packages are built on the multi‐ processing library.\n\nPython core developer Eric Snow maintains a Multicore Python wiki, with notes about his and other people’s efforts to improve Python’s support for parallel execu‐ tion. Snow is the author of PEP 554—Multiple Interpreters in the Stdlib. If approved and implemented, PEP 554 lays the groundwork for future enhancements that may eventually allow Python to use multiple cores without the overheads of multiprocess‐ ing. One of the biggest blockers is the complex interaction between multiple active subinterpreters and extensions that assume a single interpreter.\n\nMark Shannon—also a Python maintainer—created a useful table comparing concur‐ rent models in Python, referenced in a discussion about subinterpreters between him, Eric Snow, and other developers on the python-dev mailing list. In Shannon’s table, the “Ideal CSP” column refers to the theoretical Communicating sequential processes model proposed by Tony Hoare in 1978. Go also allows shared objects, violating an essential constraint of CSP: execution units should communicate through message passing through channels.\n\nStackless Python (a.k.a. Stackless) is a fork of CPython implementing microthreads, which are application-level lightweight threads—as opposed to OS threads. The mas‐ sively multiplayer online game EVE Online was built on Stackless, and engineers employed by the game company CCP were maintainers of Stackless for a while. Some features of Stackless were reimplemented in the Pypy interpreter and the greenlet package, the core technology of the gevent networking library, which in turn is the foundation of the Gunicorn application server.\n\nThe actor model of concurrent programming is at the core of the highly scalable Erlang and Elixir languages, and is also the model of the Akka framework for Scala and Java. If you want to try out the actor model in Python, check out the Thespian and Pykka libraries.\n\nFurther Reading\n\n|\n\n737\n\nMy remaining recommendations have few or zero mentions of Python, but are nev‐ ertheless relevant to readers interested in the theme of this chapter.\n\nConcurrency and Scalability Beyond Python RabbitMQ in Action by Alvaro Videla and Jason J. W. Williams (Manning) is a very well-written introduction to RabbitMQ and the Advanced Message Queuing Protocol (AMQP) standard, with examples in Python, PHP, and Ruby. Regardless of the rest of your tech stack, and even if you plan to use Celery with RabbitMQ under the hood, I recommend this book for its coverage of concepts, motivation, and patterns for dis‐ tributed message queues, as well as operating and tuning RabbitMQ at scale.\n\nI learned a lot reading Seven Concurrency Models in Seven Weeks, by Paul Butcher (Pragmatic Bookshelf), with the eloquent subtitle When Threads Unravel. Chapter 1 of the book presents the core concepts and challenges of programming with threads and locks in Java.28 The remaining six chapters of the book are devoted to what the author considers better alternatives for concurrent and parallel programming, as sup‐ ported by different languages, tools, and libraries. The examples use Java, Clojure, Elixir, and C (for the chapter about parallel programming with the OpenCL frame‐ work). The CSP model is exemplified with Clojure code, although the Go language deserves credit for popularizing that approach. Elixir is the language of the examples illustrating the actor model. A freely available, alternative bonus chapter about actors uses Scala and the Akka framework. Unless you already know Scala, Elixir is a more accessible language to learn and experiment with the actor model and the Erlang/OTP distributed systems platform.\n\nUnmesh Joshi of Thoughtworks has contributed several pages documenting “Pat‐ terns of Distributed Systems” to Martin Fowler’s blog. The opening page is a great introduction the topic, with links to individual patterns. Joshi is adding patterns incrementally, but what’s already there distills years of hard-earned experience in mission-critical systems.\n\nMartin Kleppmann’s Designing Data-Intensive Applications (O’Reilly) is a rare book written by a practitioner with deep industry experience and advanced academic back‐ ground. The author worked with large-scale data infrastructure at LinkedIn and two startups, before becoming a researcher of distributed systems at the University of Cambridge. Each chapter in Kleppmann’s book ends with an extensive list of refer‐ ences, including recent research results. The book also includes numerous illuminat‐ ing diagrams and beautiful concept maps.\n\nI was fortunate to be in the audience for Francesco Cesarini’s outstanding workshop on the architecture of reliable distributed systems at OSCON 2016: “Designing and\n\n28 Python’s threading and concurrent.futures APIs are heavily influenced by the Java standard library.\n\n738\n\n|\n\nChapter 19: Concurrency Models in Python\n\narchitecting for scalability with Erlang/OTP” (video at the O’Reilly Learning Plat‐ form). Despite the title, 9:35 into the video, Cesarini explains:\n\nVery little of what I am going to say will be Erlang-specific […]. The fact remains that Erlang will remove a lot of accidental difficulties to making systems which are resilient and which never fail, and are scalable. So it will be much easier if you do use Erlang, or a language running on the Erlang virtual machine.\n\nThat workshop was based on the last four chapters of Designing for Scalability with Erlang/OTP by Francesco Cesarini and Steve Vinoski (O’Reilly).\n\nProgramming distributed systems is challenging and exciting, but beware of web- scale envy. The KISS principle remains solid engineering advice.\n\nCheck out the paper “Scalability! But at what COST?” by Frank McSherry, Michael Isard, and Derek G. Murray. The authors identified parallel graph-processing systems presented in academic symposia that require hundreds of cores to outperform a “competent single-threaded implementation.” They also found systems that “under‐ perform one thread for all of their reported configurations.”\n\nThose findings remind me of a classic hacker quip:\n\nMy Perl script is faster than your Hadoop cluster.\n\nSoapbox\n\nTo Manage Complexity, We Need Constraints\n\nI learned to program on a TI-58 calculator. Its “language” was similar to assembly. At that level, all “variables” are globals, and you don’t have the luxury of structured con‐ trol flow statements. You have conditional jumps: instructions that take the execution directly to an arbitrary location—ahead or behind the current spot—depending on the value of a CPU register or flag.\n\nBasically you can do anything in assembly, and that’s the challenge: there are very few constraints to keep you from making mistakes, and to help maintainers understand the code when changes are needed.\n\nThe second language I learned was the unstructured BASIC that came with 8-bit computers—nothing like Visual Basic, which appeared much later. There were FOR, GOSUB, and RETURN statements, but still no concept of local variables. GOSUB did not support parameter passing: it was just a fancy GOTO that put a return line number in a stack so that RETURN had a target to jump to. Subroutines could help themselves to the global data, and put results there too. We had to improvise other forms of control flow with combinations of IF and GOTO—which, again, allowed you to jump to any line of the program.\n\nFurther Reading\n\n|\n\n739\n\nAfter a few years of programming with jumps and global variables, I remember the struggle to rewire my brain for “structured programming” when I learned Pascal. Now I had to use control flow statements around blocks of code that have a single entry point. I couldn’t jump to any instruction I liked. Global variables were unavoid‐ able in BASIC, but now they were taboo. I needed to rethink the flow of data and explicitly pass arguments to functions.\n\nThe next challenge for me was learning object-oriented programming. At its core, object-oriented programming is structured programming with more constraints and polymorphism. Information hiding forces yet another rethink of where data lives. I remember being frustrated more than once because I had to refactor my code so that a method I was writing could get information that was encapsulated in an object that my method could not reach.\n\nFunctional programming languages add other constraints, but immutability is the hardest to swallow after decades of imperative programming and object-oriented programming. After we get used to these constraints, we see them as blessings. They make reasoning about the code much easier.\n\nLack of constraints is the main problem with the threads-and-locks model of concur‐ rent programming. When summarizing Chapter 1 of Seven Concurrency Models in Seven Weeks, Paul Butcher wrote:\n\nThe greatest weakness of the approach, however, is that threads-and-locks program‐ ming is hard. It may be easy for a language designer to add them to a language, but they provide us, the poor programmers, with very little help.\n\nSome examples of unconstrained behavior in that model:\n\nThreads can share access to arbitrary, mutable data structures.\n\nThe scheduler can interrupt a thread at almost any point, including in the middle of a simple operation like a += 1. Very few operations are atomic at the level of source code expressions.\n\nLocks are usually advisory. That’s a technical term meaning that you must remember to explicitly hold a lock before updating a shared data structure. If you forget to get the lock, nothing prevents your code from messing up the data while another thread dutifully holds the lock and is updating the same data.\n\nIn contrast, consider some constraints enforced by the actor model, in which the exe‐ cution unit is called an actor:29\n\n29 The Erlang community uses the term “process” for actors. In Erlang, each process is a function in its own\n\nloop, so they are very lightweight and it’s feasible to have millions of them active at once in a single machine —no relation to the heavyweight OS processes we’ve been talking about elsewhere in this chapter. So here we have examples of the two sins described by Prof. Simon: using different words to mean the same thing, and using one word to mean different things.\n\n740\n\n|\n\nChapter 19: Concurrency Models in Python\n\nAn actor can have internal state, but cannot share state with other actors.\n\nActors can only communicate by sending and receiving messages.\n\nMessages only hold copies of data, not references to mutable data.\n\nAn actor only handles one message at a time. There is no concurrent execution inside a single actor.\n\nOf course, you can adopt an actor style of coding in any language by following these rules. You can also use object-oriented programming idioms in C, and even struc‐ tured programming patterns in assembly. But doing any of that requires a lot of agreement and discipline among everyone who touches the code.\n\nManaging locks is unnecessary in the actor model, as implemented by Erlang and Elixir, where all data types are immutable.\n\nThreads-and-locks are not going away. I just don’t think dealing with such low-level entities is a good use of my time as I write applications—as opposed to kernel mod‐ ules or databases.\n\nI reserve the right to change my mind, always. But right now, I am convinced that the actor model is the most sensible, general-purpose concurrent programming model available. CSP (Communicating Sequential Processes) is also sensible, but its implementation in Go leaves out some constraints. The idea in CSP is that coroutines (or goroutines in Go) exchange data and synchronize using queues (called channels in Go). But Go also supports memory sharing and locks. I’ve seen a book about Go advocate the use of shared memory and locks instead of channels—in the name of performance. Old habits die hard.\n\nFurther Reading\n\n|\n\n741",
      "page_number": 738
    },
    {
      "number": 38,
      "title": "Segment 38 (pages 759-777)",
      "start_page": 759,
      "end_page": 777,
      "detection_method": "synthetic",
      "content": "CHAPTER 20 Concurrent Executors\n\nThe people bashing threads are typically system programmers which have in mind use cases that the typical application programmer will never encounter in her life. [...] In 99% of the use cases an application programmer is likely to run into, the simple pat‐ tern of spawning a bunch of independent threads and collecting the results in a queue is everything one needs to know.\n\n—Michele Simionato, Python deep thinker1\n\nThis chapter focuses on the concurrent.futures.Executor classes that encapsulate the pattern of “spawning a bunch of independent threads and collecting the results in a queue,” described by Michele Simionato. The concurrent executors make this pat‐ tern almost trivial to use, not only with threads but also with processes—useful for compute-intensive tasks.\n\nHere I also introduce the concept of futures—objects representing the asynchronous execution of an operation, similar to JavaScript promises. This primitive idea is the foundation not only of concurrent.futures but also of the asyncio package, the subject of Chapter 21.\n\nWhat’s New in This Chapter I renamed the chapter from “Concurrency with Futures” to “Concurrent Executors” because the executors are the most important high-level feature covered here. Futures are low-level objects, focused on in “Where Are the Futures?” on page 751, but mostly invisible in the rest of the chapter.\n\n1 From Michele Simionato’s post, “Threads, processes and concurrency in Python: some thoughts”, summar‐ ized as “Removing the hype around the multicore (non) revolution and some (hopefully) sensible comment about threads and other forms of concurrency.”\n\n743\n\nAll the HTTP client examples now use the new HTTPX library, which provides syn‐ chronous and asynchronous APIs.\n\nThe setup for the experiments in “Downloads with Progress Display and Error Han‐ dling” on page 762 is now simpler, thanks to the multithreaded server added to the http.server package in Python 3.7. Previously, the standard library only had the single-threaded BaseHttpServer, which was no good for experimenting with concur‐ rent clients, so I had to resort to external tools in the first edition of this book.\n\n“Launching Processes with concurrent.futures” on page 754 now demonstrates how an executor simplifies the code we saw in “Code for the Multicore Prime Checker” on page 719.\n\nFinally, I moved most of the theory to the new Chapter 19, “Concurrency Models in Python”.\n\nConcurrent Web Downloads Concurrency is essential for efficient network I/O: instead of idly waiting for remote machines, the application should do something else until a response comes back.2\n\nTo demonstrate with code, I wrote three simple programs to download images of 20 country flags from the web. The first one, flags.py, runs sequentially: it only requests the next image when the previous one is downloaded and saved locally. The other two scripts make concurrent downloads: they request several images practically at the same time, and save them as they arrive. The flags_threadpool.py script uses the con current.futures package, while flags_asyncio.py uses asyncio.\n\nExample 20-1 shows the result of running the three scripts, three times each. I also posted a 73s video on YouTube so you can watch them running while a macOS Finder window displays the flags as they are saved. The scripts are downloading images from fluentpython.com, which is behind a CDN, so you may see slower results in the first runs. The results in Example 20-1 were obtained after several runs, so the CDN cache was warm.\n\nExample 20-1. Three typical runs of the scripts flags.py, flags_threadpool.py, and flags_asyncio.py\n\n$ python3 flags.py BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN 20 flags downloaded in 7.26s $ python3 flags.py BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN\n\n2 Particularly if your cloud provider rents machines by the second, regardless of how busy the CPUs are.\n\n744\n\n|\n\nChapter 20: Concurrent Executors\n\n20 flags downloaded in 7.20s $ python3 flags.py BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN 20 flags downloaded in 7.09s $ python3 flags_threadpool.py DE BD CN JP ID EG NG BR RU CD IR MX US PH FR PK VN IN ET TR 20 flags downloaded in 1.37s $ python3 flags_threadpool.py EG BR FR IN BD JP DE RU PK PH CD MX ID US NG TR CN VN ET IR 20 flags downloaded in 1.60s $ python3 flags_threadpool.py BD DE EG CN ID RU IN VN ET MX FR CD NG US JP TR PK BR IR PH 20 flags downloaded in 1.22s $ python3 flags_asyncio.py BD BR IN ID TR DE CN US IR PK PH FR RU NG VN ET MX EG JP CD 20 flags downloaded in 1.36s $ python3 flags_asyncio.py RU CN BR IN FR BD TR EG VN IR PH CD ET ID NG DE JP PK MX US 20 flags downloaded in 1.27s $ python3 flags_asyncio.py RU IN ID DE BR VN PK MX US IR ET EG NG BD FR CN JP PH CD TR 20 flags downloaded in 1.42s\n\nThe output for each run starts with the country codes of the flags as they are downloaded, and ends with a message stating the elapsed time.\n\nIt took flags.py an average 7.18s to download 20 images.\n\nThe average for flags_threadpool.py was 1.40s.\n\nFor flags_asyncio.py, 1.35s was the average time.\n\nNote the order of the country codes: the downloads happened in a different order every time with the concurrent scripts.\n\nThe difference in performance between the concurrent scripts is not significant, but they are both more than five times faster than the sequential script—and this is just for the small task of downloading 20 files of a few kilobytes each. If you scale the task to hundreds of downloads, the concurrent scripts can outpace the sequential code by a factor or 20 or more.\n\nWhile testing concurrent HTTP clients against public web servers, you may inadvertently launch a denial-of-service (DoS) attack, or be suspected of doing so. In the case of Example 20-1, it’s OK to do it because those scripts are hardcoded to make only 20 requests. We’ll use Python’s http.server package to run tests later in this chapter.\n\nConcurrent Web Downloads\n\n|\n\n745\n\nNow let’s study the implementations of two of the scripts tested in Example 20-1: flags.py and flags_threadpool.py. I will leave the third script, flags_asyncio.py, for Chapter 21, but I wanted to demonstrate all three together to make two points:\n\n1. Regardless of the concurrency constructs you use—threads or coroutines—you’ll see vastly improved throughput over sequential code in network I/O operations, if you code it properly.\n\n2. For HTTP clients that can control how many requests they make, there is no sig‐ nificant difference in performance between threads and coroutines.3\n\nOn to the code.\n\nA Sequential Download Script Example 20-2 contains the implementation of flags.py, the first script we ran in Example 20-1. It’s not very interesting, but we’ll reuse most of its code and settings to implement the concurrent scripts, so it deserves some attention.\n\nFor clarity, there is no error handling in Example 20-2. We will deal with exceptions later, but here I want to focus on the basic structure of the code, to make it easier to contrast this script with the concurrent ones.\n\nExample 20-2. flags.py: sequential download script; some functions will be reused by the other scripts\n\nimport time from pathlib import Path from typing import Callable\n\nimport httpx\n\nPOP20_CC = ('CN IN US ID BR PK NG BD RU JP ' 'MX PH VN ET EG DE IR TR CD FR').split()\n\nBASE_URL = 'https://www.fluentpython.com/data/flags' DEST_DIR = Path('downloaded')\n\ndef save_flag(img: bytes, filename: str) -> None: (DEST_DIR / filename).write_bytes(img)\n\n3 For servers that may be hit by many clients, there is a difference: coroutines scale better because they use much less memory than threads, and also reduce the cost of context switching, which I mentioned in “Thread-Based Nonsolution” on page 724.\n\n746\n\n|\n\nChapter 20: Concurrent Executors\n\ndef get_flag(cc: str) -> bytes: url = f'{BASE_URL}/{cc}/{cc}.gif'.lower() resp = httpx.get(url, timeout=6.1, follow_redirects=True) resp.raise_for_status() return resp.content\n\ndef download_many(cc_list: list[str]) -> int: for cc in sorted(cc_list): image = get_flag(cc) save_flag(image, f'{cc}.gif') print(cc, end=' ', flush=True) return len(cc_list)\n\ndef main(downloader: Callable[[list[str]], int]) -> None: DEST_DIR.mkdir(exist_ok=True) t0 = time.perf_counter() count = downloader(POP20_CC) elapsed = time.perf_counter() - t0 print(f'\\n{count} downloads in {elapsed:.2f}s')\n\nif __name__ == '__main__': main(download_many)\n\nImport the httpx library. It’s not part of the standard library, so by convention the import goes after the standard library modules and a blank line.\n\nList of the ISO 3166 country codes for the 20 most populous countries in order of decreasing population.\n\nThe directory with the flag images.4\n\nLocal directory where the images are saved.\n\nSave the img bytes to filename in the DEST_DIR.\n\nGiven a country code, build the URL and download the image, returning the binary contents of the response.\n\nIt’s good practice to add a sensible timeout to network operations, to avoid blocking for several minutes for no good reason.\n\n4 The images are originally from the CIA World Factbook, a public-domain, US government publication. I\n\ncopied them to my site to avoid the risk of launching a DOS attack on cia.gov.\n\nConcurrent Web Downloads\n\n|\n\n747\n\nBy default, HTTPX does not follow redirects.5\n\nThere’s no error handling in this script, but this method raises an exception if the HTTP status is not in the 2XX range—highly recommended to avoid silent failures.\n\ndownload_many implementations.\n\nis\n\nthe key\n\nfunction\n\nto compare with\n\nthe concurrent\n\nLoop over the list of country codes in alphabetical order, to make it easy to see that the ordering is preserved in the output; return the number of country codes downloaded.\n\nDisplay one country code at a time in the same line so we can see progress as each download happens. The end=' ' argument replaces the usual line break at the end of each line printed with a space character, so all country codes are dis‐ played progressively in the same line. The flush=True argument is needed because, by default, Python output is line buffered, meaning that Python only displays printed characters after a line break.\n\nmain must be called with the function that will make the downloads; that way, we can use main as a library function with other implementations of download_many in the threadpool and ascyncio examples.\n\nCreate DEST_DIR if needed; don’t raise an error if the directory exists.\n\nRecord and report the elapsed time after running the downloader function.\n\nCall main with the download_many function.\n\nThe HTTPX library is inspired by the Pythonic requests package, but is built on a more modern foundation. Crucially, HTTPX pro‐ vides synchronous and asynchronous APIs, so we can use it in all HTTP client examples in this chapter and the next. Python’s stan‐ dard library provides the urllib.request module, but its API is synchronous only, and is not user friendly.\n\n5 Setting follow_redirects=True is not needed for this example, but I wanted to highlight this important dif‐ ference between HTTPX and requests. Also, setting follow_redirects=True in this example gives me flexibil‐ ity to host the image files elsewhere in the future. I think the HTTPX default setting of follow_redirects =False is sensible because unexpected redirects can mask needless requests and complicate error diagnostics.\n\n748\n\n|\n\nChapter 20: Concurrent Executors\n\nThere’s really nothing new to flags.py. It serves as a baseline for comparing the other scripts, and I used it as a library to avoid redundant code when implementing them. Now let’s see a reimplementation using concurrent.futures.\n\nDownloading with concurrent.futures The main features of the concurrent.futures package are the ThreadPoolExecutor and ProcessPoolExecutor classes, which implement an API to submit callables for execution in different threads or processes, respectively. The classes transparently manage a pool of worker threads or processes, and queues to distribute jobs and col‐ lect results. But the interface is very high-level, and we don’t need to know about any of those details for a simple use case like our flag downloads.\n\nExample 20-3 shows the easiest way to implement the downloads concurrently, using the ThreadPoolExecutor.map method.\n\nExample 20-3. flags_threadpool.py: threaded download script using futures.Thread PoolExecutor\n\nfrom concurrent import futures\n\nfrom flags import save_flag, get_flag, main\n\ndef download_one(cc: str): image = get_flag(cc) save_flag(image, f'{cc}.gif') print(cc, end=' ', flush=True) return cc\n\ndef download_many(cc_list: list[str]) -> int: with futures.ThreadPoolExecutor() as executor: res = executor.map(download_one, sorted(cc_list))\n\nreturn len(list(res))\n\nif __name__ == '__main__': main(download_many)\n\nReuse some functions from the flags module (Example 20-2).\n\nFunction to download a single image; this is what each worker will execute.\n\nInstantiate the ThreadPoolExecutor as a context manager; the executor .__exit__ method will call executor.shutdown(wait=True), which will block until all threads are done.\n\nConcurrent Web Downloads\n\n|\n\n749\n\nThe map method is similar to the map built-in, except that the download_one func‐ tion will be called concurrently from multiple threads; it returns a generator that you can iterate to retrieve the value returned by each function call—in this case, each call to download_one will return a country code.\n\nReturn the number of results obtained. If any of the threaded calls raises an exception, that exception is raised here when the implicit next() call inside the list constructor tries to retrieve the corresponding return value from the itera‐ tor returned by executor.map.\n\nCall the main function from the flags module, passing the concurrent version of download_many.\n\nNote that the download_one function from Example 20-3 is essentially the body of the for loop in the download_many function from Example 20-2. This is a common refac‐ toring when writing concurrent code: turning the body of a sequential for loop into a function to be called concurrently.\n\nExample 20-3 is very short because I was able to reuse most func‐ tions from the sequential flags.py script. One of the best features of concurrent.futures is to make it simple to add concurrent execu‐ tion on top of legacy sequential code.\n\nThe ThreadPoolExecutor constructor takes several arguments not shown, but the first and most important one is max_workers, setting the maximum number of worker threads to be executed. When max_workers is None (the default), ThreadPool Executor decides its value using the following expression—since Python 3.8:\n\nmax_workers = min(32, os.cpu_count() + 4)\n\nThe rationale is explained in the ThreadPoolExecutor documentation:\n\nThis default value preserves at least 5 workers for I/O bound tasks. It utilizes at most 32 CPU cores for CPU bound tasks which release the GIL. And it avoids using very large resources implicitly on many-core machines. ThreadPoolExecutor now reuses idle worker threads before starting max_workers worker threads too.\n\nTo conclude: the computed default for max_workers is sensible, and ThreadPoolExe cutor avoids starting new workers unnecessarily. Understanding the logic behind max_workers may help you decide when and how to set it yourself.\n\nThe library is called concurrency.futures, yet there are no futures to be seen in Example 20-3, so you may be wondering where they are. The next section explains.\n\n750\n\n|\n\nChapter 20: Concurrent Executors\n\nWhere Are the Futures? Futures are core components of concurrent.futures and of asyncio, but as users of these libraries we sometimes don’t see them. Example 20-3 depends on futures behind the scenes, but the code I wrote does not touch them directly. This section is an overview of futures, with an example that shows them in action.\n\nSince Python 3.4, there are two classes named Future in the standard library: concur rent.futures.Future and asyncio.Future. They serve the same purpose: an instance of either Future class represents a deferred computation that may or may not have completed. This is somewhat similar to the Deferred class in Twisted, the Future class in Tornado, and Promise in modern JavaScript.\n\nFutures encapsulate pending operations so that we can put them in queues, check whether they are done, and retrieve results (or exceptions) when they become available.\n\nAn important thing to know about futures is that you and I should not create them: they are meant to be instantiated exclusively by the concurrency framework, be it concurrent.futures or asyncio. Here is why: a Future represents something that will eventually run, therefore it must be scheduled to run, and that’s the job of the framework. In particular, concurrent.futures.Future instances are created only as the result of submitting a callable for execution with a concurrent.futures.Execu tor subclass. For example, the Executor.submit() method takes a callable, schedules it to run, and returns a Future.\n\nApplication code is not supposed to change the state of a future: the concurrency framework changes the state of a future when the computation it represents is done, and we can’t control when that happens.\n\nBoth types of Future have a .done() method that is nonblocking and returns a Boolean that tells you whether the callable wrapped by that future has executed or not. However, instead of repeatedly asking whether a future is done, client code usu‐ ally asks to be notified. That’s why both Future classes have an .add_done_call back() method: you give it a callable, and the callable will be invoked with the future as the single argument when the future is done. Be aware that the callback callable will run in the same worker thread or process that ran the function wrapped in the future.\n\nThere is also a .result() method, which works the same in both classes when the future is done: it returns the result of the callable, or re-raises whatever exception might have been thrown when the callable was executed. However, when the future is not done, the behavior of the result method is very different between the two flavors of Future. In a concurrency.futures.Future instance, invoking f.result() will block the caller’s thread until the result is ready. An optional timeout argument can\n\nConcurrent Web Downloads\n\n|\n\n751\n\nbe passed, and if the future is not done in the specified time, the result method raises TimeoutError. The asyncio.Future.result method does not support time‐ out, and await is the preferred way to get the result of futures in asyncio—but await doesn’t work with concurrency.futures.Future instances.\n\nSeveral functions in both libraries return futures; others use them in their implemen‐ tation in a way that is transparent to the user. An example of the latter is the Execu tor.map we saw in Example 20-3: it returns an iterator in which __next__ calls the result method of each future, so we get the results of the futures, and not the futures themselves.\n\nTo get a practical look at futures, we can rewrite Example 20-3 to use the concur rent.futures.as_completed function, which takes an iterable of futures and returns an iterator that yields futures as they are done.\n\nUsing futures.as_completed requires changes to the download_many function only. The higher-level executor.map call is replaced by two for loops: one to create and schedule the futures, the other to retrieve their results. While we are at it, we’ll add a few print calls to display each future before and after it’s done. Example 20-4 shows the code for a new download_many function. The code for download_many grew from 5 to 17 lines, but now we get to inspect the mysterious futures. The remaining func‐ tions are the same as in Example 20-3.\n\nExample 20-4. flags_threadpool_futures.py: replacing executor.map with execu tor.submit and futures.as_completed in the download_many function\n\ndef download_many(cc_list: list[str]) -> int: cc_list = cc_list[:5] with futures.ThreadPoolExecutor(max_workers=3) as executor: to_do: list[futures.Future] = [] for cc in sorted(cc_list): future = executor.submit(download_one, cc) to_do.append(future) print(f'Scheduled for {cc}: {future}')\n\nfor count, future in enumerate(futures.as_completed(to_do), 1): res: str = future.result() print(f'{future} result: {res!r}')\n\nreturn count\n\n752\n\n|\n\nChapter 20: Concurrent Executors\n\nFor this demonstration, use only the top five most populous countries.\n\nSet max_workers to 3 so we can see pending futures in the output.\n\nIterate over country codes alphabetically, to make it clear that results will arrive out of order.\n\nexecutor.submit schedules the callable to be executed, and returns a future representing this pending operation.\n\nStore each future so we can later retrieve them with as_completed.\n\nDisplay a message with the country code and the respective future.\n\nas_completed yields futures as they are completed.\n\nGet the result of this future.\n\nDisplay the future and its result.\n\nNote that the future.result() call will never block in this example because the future is coming out of as_completed. Example 20-5 shows the output of one run of Example 20-4.\n\nExample 20-5. Output of flags_threadpool_futures.py\n\n$ python3 flags_threadpool_futures.py Scheduled for BR: <Future at 0x100791518 state=running> Scheduled for CN: <Future at 0x100791710 state=running> Scheduled for ID: <Future at 0x100791a90 state=running> Scheduled for IN: <Future at 0x101807080 state=pending> Scheduled for US: <Future at 0x101807128 state=pending> CN <Future at 0x100791710 state=finished returned str> result: 'CN' BR ID <Future at 0x100791518 state=finished returned str> result: 'BR' <Future at 0x100791a90 state=finished returned str> result: 'ID' IN <Future at 0x101807080 state=finished returned str> result: 'IN' US <Future at 0x101807128 state=finished returned str> result: 'US'\n\n5 downloads in 0.70s\n\nThe futures are scheduled in alphabetical order; the repr() of a future shows its state: the first three are running, because there are three worker threads.\n\nThe last two futures are pending, waiting for worker threads.\n\nConcurrent Web Downloads\n\n|\n\n753\n\nThe first CN here is the output of download_one in a worker thread; the rest of the line is the output of download_many.\n\nHere, two threads output codes before download_many in the main thread can display the result of the first thread.\n\nI recommend experimenting with flags_threadpool_futures.py. If you run it several times, you’ll see the order of the results varying. Increasing max_workers to 5 will increase the variation in the order of the results. Decreasing it to 1 will make this script run sequen‐ tially, and the order of the results will always be the order of the submit calls.\n\nWe saw two variants of the download script using concurrent.futures: one in Example 20-3 with ThreadPoolExecutor.map and one in Example 20-4 with futures.as_completed. If you are curious about the code for flags_asyncio.py, you may peek at Example 21-3 in Chapter 21, where it is explained.\n\nNow let’s take a brief look at a simple way to work around the GIL for CPU-bound jobs using concurrent.futures.\n\nLaunching Processes with concurrent.futures The concurrent.futures documentation page is subtitled “Launching parallel tasks.” The package enables parallel computation on multicore machines because it supports distributing work among multiple Python processes using the ProcessPool Executor class.\n\nBoth ProcessPoolExecutor and ThreadPoolExecutor implement the Executor interface, so it’s easy to switch from a thread-based to a process-based solution using concurrent.futures.\n\nThere is no advantage in using a ProcessPoolExecutor for the flags download exam‐ ple or any I/O-bound job. It’s easy to verify this; just change these lines in Example 20-3:\n\ndef download_many(cc_list: list[str]) -> int: with futures.ThreadPoolExecutor() as executor:\n\nTo this:\n\ndef download_many(cc_list: list[str]) -> int: with futures.ProcessPoolExecutor() as executor:\n\n754\n\n|\n\nChapter 20: Concurrent Executors\n\nThe constructor for ProcessPoolExecutor also has a max_workers parameter, which defaults to None. In that case, the executor limits the number of workers to the num‐ ber returned by os.cpu_count().\n\nProcesses use more memory and take longer to start than threads, so the real value of ProcessPoolExecutor is in CPU-intensive jobs. Let’s go back to the primality test example of “A Homegrown Process Pool” on page 716, rewriting it with concurrent.futures.\n\nMulticore Prime Checker Redux In “Code for the Multicore Prime Checker” on page 719 we studied procs.py, a script that checked the primality of some large numbers using multiprocessing. In Example 20-6 we solve the same problem in the proc_pool.py program using a Proc essPoolExecutor. From the first import to the main() call at the end, procs.py has 43 nonblank lines of code, and proc_pool.py has 31—28% shorter.\n\nExample 20-6. proc_pool.py: procs.py rewritten with ProcessPoolExecutor\n\nimport sys from concurrent import futures from time import perf_counter from typing import NamedTuple\n\nfrom primes import is_prime, NUMBERS\n\nclass PrimeResult(NamedTuple): n: int flag: bool elapsed: float\n\ndef check(n: int) -> PrimeResult: t0 = perf_counter() res = is_prime(n) return PrimeResult(n, res, perf_counter() - t0)\n\ndef main() -> None: if len(sys.argv) < 2: workers = None else: workers = int(sys.argv[1])\n\nexecutor = futures.ProcessPoolExecutor(workers) actual_workers = executor._max_workers # type: ignore\n\nprint(f'Checking {len(NUMBERS)} numbers with {actual_workers} processes:')\n\nt0 = perf_counter()\n\nLaunching Processes with concurrent.futures\n\n|\n\n755\n\nnumbers = sorted(NUMBERS, reverse=True) with executor: for n, prime, elapsed in executor.map(check, numbers): label = 'P' if prime else ' ' print(f'{n:16} {label} {elapsed:9.6f}s')\n\ntime = perf_counter() - t0 print(f'Total time: {time:.2f}s')\n\nif __name__ == '__main__': main()\n\nNo need to import multiprocessing, SimpleQueue etc.; concurrent.futures hides all that.\n\nThe PrimeResult tuple and the check function are the same as we saw in procs.py, but we don’t need the queues and the worker function anymore.\n\nInstead of deciding ourselves how many workers to use if no command-line argument was given, we set workers to None and let the ProcessPoolExecutor decide.\n\nHere I build the ProcessPoolExecutor before the with block in ➐ so that I can display the actual number of workers in the next line.\n\n_max_workers is an undocumented instance attribute of a ProcessPoolExecutor. I decided to use it to show the number of workers when the workers variable is None. Mypy correctly complains when I access it, so I put the type: ignore com‐ ment to silence it.\n\nSort the numbers to be checked in descending order. This will expose a differ‐ ence in the behavior of proc_pool.py when compared with procs.py. See the explanation after this example.\n\nUse the executor as a context manager.\n\nThe executor.map call returns the PrimeResult instances returned by check in the same order as the numbers arguments.\n\nIf you run Example 20-6, you’ll see the results appearing in strict descending order, as shown in Example 20-7. In contrast, the ordering of the output of procs.py (shown in “Process-Based Solution” on page 718) is heavily influenced by the difficulty in checking whether each number is a prime. For example, procs.py shows the result for\n\n756\n\n|\n\nChapter 20: Concurrent Executors\n\n7777777777777777 near the top, because it has a low divisor, 7, so is_prime quickly determines it’s not a prime.\n\nIn contrast, 7777777536340681 is 881917092, so is_prime will take much longer to determine that it’s a composite number, and even longer to find out that 7777777777777753 is prime—therefore both of these numbers appear near the end of the output of procs.py.\n\nRunning proc_pool.py, you’ll observe not only the descending order of the results, but also that the program will appear to be stuck after showing the result for 9999999999999999.\n\nExample 20-7. Output of proc_pool.py\n\n$ ./proc_pool.py Checking 20 numbers with 12 processes: 9999999999999999 0.000024s 9999999999999917 P 9.500677s 7777777777777777 0.000022s 7777777777777753 P 8.976933s 7777777536340681 8.896149s 6666667141414921 8.537621s 6666666666666719 P 8.548641s 6666666666666666 0.000002s 5555555555555555 0.000017s 5555555555555503 P 8.214086s 5555553133149889 8.067247s 4444444488888889 7.546234s 4444444444444444 0.000002s 4444444444444423 P 7.622370s 3333335652092209 6.724649s 3333333333333333 0.000018s 3333333333333301 P 6.655039s 299593572317531 P 2.072723s 142702110479723 P 1.461840s 2 P 0.000001s Total time: 9.65s\n\nThis line appears very quickly.\n\nThis line takes more than 9.5s to show up.\n\nAll the remaining lines appear almost immediately.\n\nLaunching Processes with concurrent.futures\n\n|\n\n757\n\nHere is why proc_pool.py behaves in that way:\n\nAs mentioned before, executor.map(check, numbers) returns the result in the same order as the numbers are given.\n\nBy default, proc_pool.py uses as many workers as there are CPUs—it’s what ProcessPoolExecutor does when max_workers is None. That’s 12 processes in this laptop.\n\nBecause we are submitting numbers\n\nin descending order, the first\n\n9999999999999999; with 9 as a divisor, it returns quickly.\n\nThe second number is 9999999999999917, the largest prime in the sample. This will take longer than all the others to check.\n\nMeanwhile, the remaining 11 processes will be checking other numbers, which are either primes or composites with large factors, or composites with very small factors.\n\nWhen the worker in charge of 9999999999999917 finally determines that’s a prime, all the other processes have completed their last jobs, so the results appear immediately after.\n\nAlthough the progress of proc_pool.py is not as visible as that of procs.py, the overall execution time is practically the same as depic‐ ted in Figure 19-2, for the same number of workers and CPU cores.\n\nUnderstanding how concurrent programs behave is not straightforward, so here’s is a second experiment that may help you visualize the operation of Executor.map.\n\nExperimenting with Executor.map Let’s investigate Executor.map, now using a ThreadPoolExecutor with three workers running five callables that output timestamped messages. The code in Example 20-8, the output in Example 20-9.\n\nExample 20-8. demo_executor_map.py: Simple demonstration of the map method of ThreadPoolExecutor\n\nfrom time import sleep, strftime from concurrent import futures\n\ndef display(*args): print(strftime('[%H:%M:%S]'), end=' ') print(*args)\n\n758\n\n|\n\nChapter 20: Concurrent Executors\n\nis\n\nis\n\ndef loiter(n): msg = '{}loiter({}): doing nothing for {}s...' display(msg.format('\\t'*n, n, n)) sleep(n) msg = '{}loiter({}): done.' display(msg.format('\\t'*n, n)) return n * 10\n\ndef main(): display('Script starting.') executor = futures.ThreadPoolExecutor(max_workers=3) results = executor.map(loiter, range(5)) display('results:', results) display('Waiting for individual results:') for i, result in enumerate(results): display(f'result {i}: {result}')\n\nif __name__ == '__main__': main()\n\nThis function simply prints whatever arguments it gets, preceded by a timestamp in the format [HH:MM:SS].\n\nloiter does nothing except display a message when it starts, sleep for n seconds, then display a message when it ends; tabs are used to indent the messages accord‐ ing to the value of n.\n\nloiter returns n * 10 so we can see how to collect results.\n\nCreate a ThreadPoolExecutor with three threads.\n\nSubmit five tasks to the executor. Since there are only three threads, only three of those tasks will start immediately: the calls loiter(0), loiter(1), and loi ter(2); this is a nonblocking call.\n\nImmediately display the results of invoking executor.map: it’s a generator, as the output in Example 20-9 shows.\n\nThe enumerate call in the for loop will implicitly invoke next(results), which in turn will invoke _f.result() on the (internal) _f future representing the first call, loiter(0). The result method will block until the future is done, therefore each iteration in this loop will have to wait for the next result to be ready.\n\nExperimenting with Executor.map\n\n|\n\n759\n\nI encourage you to run Example 20-8 and see the display being updated incremen‐ tally. While you’re at it, play with the max_workers argument for the ThreadPoolExec utor and with the range function that produces the arguments for the executor.map call—or replace it with lists of handpicked values to create different delays.\n\nExample 20-9 shows a sample run of Example 20-8.\n\nExample 20-9. Sample run of demo_executor_map.py from Example 20-8\n\n$ python3 demo_executor_map.py [15:56:50] Script starting. [15:56:50] loiter(0): doing nothing for 0s... [15:56:50] loiter(0): done. [15:56:50] loiter(1): doing nothing for 1s... [15:56:50] loiter(2): doing nothing for 2s... [15:56:50] results: <generator object result_iterator at 0x106517168> [15:56:50] loiter(3): doing nothing for 3s... [15:56:50] Waiting for individual results: [15:56:50] result 0: 0 [15:56:51] loiter(1): done. [15:56:51] loiter(4): doing nothing for 4s... [15:56:51] result 1: 10 [15:56:52] loiter(2): done. [15:56:52] result 2: 20 [15:56:53] loiter(3): done. [15:56:53] result 3: 30 [15:56:55] loiter(4): done. [15:56:55] result 4: 40\n\nThis run started at 15:56:50.\n\nThe first thread executes loiter(0), so it will sleep for 0s and return even before the second thread has a chance to start, but YMMV.6\n\nloiter(1) and loiter(2) start immediately (because the thread pool has three workers, it can run three functions concurrently).\n\nThis shows that the results returned by executor.map is a generator; nothing so far would block, regardless of the number of tasks and the max_workers setting.\n\n6 Your mileage may vary: with threads, you never know the exact sequencing of events that should happen\n\nnearly at the same time; it’s possible that, in another machine, you see loiter(1) starting before loiter(0) finishes, particularly because sleep always releases the GIL, so Python may switch to another thread even if you sleep for 0s.\n\n760\n\n|\n\nChapter 20: Concurrent Executors\n\nBecause loiter(0) is done, the first worker is now available to start the fourth thread for loiter(3).\n\nThis is where execution may block, depending on the parameters given to the loiter calls: the __next__ method of the results generator must wait until the first future is complete. In this case, it won’t block because the call to loiter(0) finished before this loop started. Note that everything up to this point happened within the same second: 15:56:50.\n\nloiter(1) is done one second later, at 15:56:51. The thread is freed to start loiter(4).\n\nThe result of loiter(1) is shown: 10. Now the for loop will block waiting for the result of loiter(2).\n\nThe pattern repeats: loiter(2) is done, its result is shown; same with loiter(3).\n\nThere is a 2s delay until loiter(4) is done, because it started at 15:56:51 and did nothing for 4s.\n\nThe Executor.map function is easy to use, but often it’s preferable to get the results as they are ready, regardless of the order they were submitted. To do that, we need a combination of the Executor.submit method and the futures.as_completed func‐ tion, as we saw in Example 20-4. We’ll come back to this technique in “Using futures.as_completed” on page 769.\n\nThe combination of executor.submit and futures.as_completed is more flexible than executor.map because you can submit different callables and arguments, while executor.map is designed to run the same callable on the different arguments. In addition, the set of futures you pass to futures.as_completed may come from more than one executor—perhaps some were created by a ThreadPoolExecutor from a ProcessPoolExecutor.\n\ninstance, while others are\n\nIn the next section, we will resume the flag download examples with new require‐ ments that will force us to iterate over the results of futures.as_completed instead of using executor.map.\n\nExperimenting with Executor.map\n\n|\n\n761",
      "page_number": 759
    },
    {
      "number": 39,
      "title": "Segment 39 (pages 778-797)",
      "start_page": 778,
      "end_page": 797,
      "detection_method": "synthetic",
      "content": "Downloads with Progress Display and Error Handling As mentioned, the scripts in “Concurrent Web Downloads” on page 744 have no error handling to make them easier to read and to contrast the structure of the three approaches: sequential, threaded, and asynchronous.\n\nIn order to test the handling of a variety of error conditions, I created the flags2 examples:\n\nflags2_common.py\n\nThis module contains common functions and settings used by all flags2 exam‐ ples, including a main function, which takes care of command-line parsing, tim‐ ing, and reporting results. That is really support code, not directly relevant to the subject of this chapter, so I will not list the source code here, but you can read it in the fluentpython/example-code-2e repository: 20-executors/getflags/ flags2_common.py.\n\nflags2_sequential.py\n\nA sequential HTTP client with proper error handling and progress bar display. Its download_one function is also used by flags2_threadpool.py.\n\nflags2_threadpool.py\n\nConcurrent HTTP client based on futures.ThreadPoolExecutor to demon‐ strate error handling and integration of the progress bar.\n\nflags2_asyncio.py\n\nSame functionality as the previous example, but implemented with asyncio and httpx. This will be covered in “Enhancing the asyncio Downloader” on page 787, in Chapter 21.\n\nBe Careful when Testing Concurrent Clients\n\nWhen testing concurrent HTTP clients on public web servers, you may generate many requests per second, and that’s how denial-of- service (DoS) attacks are made. Carefully throttle your clients when hitting public servers. For testing, set up a local HTTP server. See “Setting Up Test Servers” on page 765 for instructions.\n\nThe most visible feature of the flags2 examples is that they have an animated, text- mode progress bar implemented with the tqdm package. I posted a 108s video on YouTube to show the progress bar and contrast the speed of the three flags2 scripts. In the video, I start with the sequential download, but I interrupt it after 32s because it was going to take more than 5 minutes to hit on 676 URLs and get 194 flags. I then run the threaded and asyncio scripts three times each, and every time they complete\n\n762\n\n|\n\nChapter 20: Concurrent Executors\n\nthe job in 6s or less (i.e., more than 60 times faster). Figure 20-1 shows two screen‐ shots: during and after running flags2_threadpool.py.\n\nFigure 20-1. Top-left: flags2_threadpool.py running with live progress bar generated by tqdm; bottom-right: same terminal window after the script is finished.\n\nThe simplest tqdm example appears in an animated .gif in the project’s README.md. If you type the following code in the Python console after installing the tqdm pack‐ age, you’ll see an animated progress bar where the comment is:\n\n>>> import time >>> from tqdm import tqdm >>> for i in tqdm(range(1000)): ... time.sleep(.01) ... >>> # -> progress bar will appear here <-\n\nBesides the neat effect, the tqdm function is also interesting conceptually: it consumes any iterable and produces an iterator which, while it’s consumed, displays the pro‐ gress bar and estimates the remaining time to complete all iterations. To compute that estimate, tqdm needs to get an iterable that has a len, or additionally receive the total= argument with the expected number of items. Integrating tqdm with our flags2 examples provides an opportunity to look deeper into how the concurrent scripts actually work, by forcing us to use the futures.as_completed and the asyn cio.as_completed functions so that tqdm can display progress as each future is completed.\n\nThe other feature of the flags2 example is a command-line interface. All three scripts accept the same options, and you can see them by running any of the scripts with the -h option. Example 20-10 shows the help text.\n\nDownloads with Progress Display and Error Handling\n\n|\n\n763\n\nExample 20-10. Help screen for the scripts in the flags2 series\n\n$ python3 flags2_threadpool.py -h usage: flags2_threadpool.py [-h] [-a] [-e] [-l N] [-m CONCURRENT] [-s LABEL] [-v] [CC [CC ...]]\n\nDownload flags for country codes. Default: top 20 countries by population.\n\npositional arguments: CC country code or 1st letter (eg. B for BA...BZ)\n\noptional arguments: -h, --help show this help message and exit -a, --all get all available flags (AD to ZW) -e, --every get flags for every possible code (AA...ZZ) -l N, --limit N limit to N first codes -m CONCURRENT, --max_req CONCURRENT maximum concurrent requests (default=30) -s LABEL, --server LABEL Server to hit; one of DELAY, ERROR, LOCAL, REMOTE (default=LOCAL) -v, --verbose output detailed progress info\n\nAll arguments are optional. But the -s/--server is essential for testing: it lets you choose which HTTP server and port will be used in the test. Pass one of these case- insensitive labels to determine where the script will look for the flags:\n\nLOCAL\n\nUse http://localhost:8000/flags; this is the default. You should configure a local HTTP server to answer at port 8000. See the following note for instructions.\n\nREMOTE\n\nUse http://fluentpython.com/data/flags; that is a public website owned by me, hosted on a shared server. Please do not pound it with too many concurrent requests. The fluentpython.com domain is handled by the Cloudflare CDN (Con‐ tent Delivery Network) so you may notice that the first downloads are slower, but they get faster when the CDN cache warms up.\n\nDELAY\n\nUse http://localhost:8001/flags; a server delaying HTTP responses should be listening to port 8001. I wrote slow_server.py to make it easier to experiment. You’ll find it in the 20-futures/getflags/ directory of the Fluent Python code repos‐ itory. See the following note for instructions.\n\nERROR\n\nUse http://localhost:8002/flags; a server returning some HTTP errors should be listening on port 8002. Instructions are next.\n\n764\n\n|\n\nChapter 20: Concurrent Executors\n\nSetting Up Test Servers\n\nIf you don’t have a local HTTP server for testing, I wrote setup instructions using only Python ≥ 3.9 (no external libraries) in 20- fluentpython/example- executors/getflags/README.adoc code-2e repository. In short, README.adoc describes how to use:\n\nin\n\nthe\n\npython3 -m http.server\n\nThe LOCAL server on port 8000\n\npython3 slow_server.py\n\nThe DELAY server on port 8001, which adds a random delay of .5s to 5s before each response\n\npython3 slow_server.py 8002 --error-rate .25\n\nThe ERROR server on port 8002, which in addition to the ran‐ dom delay, has a 25% chance of returning a “418 I’m a teapot” error response\n\nBy default, each flags2*.py script will fetch the flags of the 20 most populous countries from the LOCAL server (http://localhost:8000/flags) using a default number of concurrent connections, which varies from script to script. Example 20-11 shows a sample run of the flags2_sequential.py script using all defaults. To run it, you need a local server, as explained in “Be Careful when Testing Concurrent Clients” on page 762.\n\nExample 20-11. Running flags2_sequential.py with all defaults: LOCAL site, top 20 flags, 1 concurrent connection\n\n$ python3 flags2_sequential.py LOCAL site: http://localhost:8000/flags Searching for 20 flags: from BD to VN 1 concurrent connection will be used. -------------------- 20 flags downloaded. Elapsed time: 0.10s\n\nYou can select which flags will be downloaded in several ways. Example 20-12 shows how to download all flags with country codes starting with the letters A, B, or C.\n\nExample 20-12. Run flags2_threadpool.py to fetch all flags with country codes prefixes A, B, or C from the DELAY server\n\n$ python3 flags2_threadpool.py -s DELAY a b c DELAY site: http://localhost:8001/flags Searching for 78 flags: from AA to CZ 30 concurrent connections will be used.\n\nDownloads with Progress Display and Error Handling\n\n|\n\n765\n\n-------------------- 43 flags downloaded. 35 not found. Elapsed time: 1.72s\n\nRegardless of how the country codes are selected, the number of flags to fetch can be limited with the -l/--limit option. Example 20-13 demonstrates how to run exactly 100 requests, combining the -a option to get all flags with -l 100.\n\nExample 20-13. Run flags2_asyncio.py to get 100 flags (-al 100) from the ERROR server, using 100 concurrent requests (-m 100)\n\n$ python3 flags2_asyncio.py -s ERROR -al 100 -m 100 ERROR site: http://localhost:8002/flags Searching for 100 flags: from AD to LK 100 concurrent connections will be used. -------------------- 73 flags downloaded. 27 errors. Elapsed time: 0.64s\n\nThat’s the user interface of the flags2 examples. Let’s see how they are implemented.\n\nError Handling in the flags2 Examples The common strategy in all three examples to deal with HTTP errors is that 404 errors (not found) are handled by the function in charge of downloading a single file (download_one). Any other exception propagates to be handled by the down load_many function or the supervisor coroutine—in the asyncio example.\n\nOnce more, we’ll start by studying the sequential code, which is easier to follow—and mostly reused by the thread pool script. Example 20-14 shows the functions that per‐ form the actual downloads in the flags2_sequential.py and flags2_threadpool.py scripts.\n\nExample 20-14. flags2_sequential.py: basic functions in charge of downloading; both are reused in flags2_threadpool.py\n\nfrom collections import Counter from http import HTTPStatus\n\nimport httpx import tqdm # type: ignore\n\nfrom flags2_common import main, save_flag, DownloadStatus\n\nDEFAULT_CONCUR_REQ = 1 MAX_CONCUR_REQ = 1\n\n766\n\n|\n\nChapter 20: Concurrent Executors\n\ndef get_flag(base_url: str, cc: str) -> bytes: url = f'{base_url}/{cc}/{cc}.gif'.lower() resp = httpx.get(url, timeout=3.1, follow_redirects=True) resp.raise_for_status() return resp.content\n\ndef download_one(cc: str, base_url: str, verbose: bool = False) -> DownloadStatus: try: image = get_flag(base_url, cc) except httpx.HTTPStatusError as exc: res = exc.response if res.status_code == HTTPStatus.NOT_FOUND: status = DownloadStatus.NOT_FOUND msg = f'not found: {res.url}' else: raise else: save_flag(image, f'{cc}.gif') status = DownloadStatus.OK msg = 'OK'\n\nif verbose: print(cc, msg)\n\nreturn status\n\nImport the tqdm progress-bar display library, and tell Mypy to skip checking it.7\n\nImport a couple of functions and an Enum from the flags2_common module.\n\nRaises HTTPStetusError if the HTTP status code is not in range(200, 300).\n\ndownload_one catches HTTPStatusError to handle HTTP code 404 specifically…\n\n…by setting its local status to DownloadStatus.NOT_FOUND; DownloadStatus is an Enum imported from flags2_common.py.\n\nAny other HTTPStatusError exception is re-raised to propagate to the caller.\n\nIf the -v/--verbose command-line option is set, the country code and status message are displayed; this is how you’ll see progress in verbose mode.\n\n7 As of September 2021, there are no type hints in the current release of tdqm. That’s OK. The world will not\n\nend because of that. Thank Guido for optional typing!\n\nDownloads with Progress Display and Error Handling\n\n|\n\n767\n\nExample 20-15 lists the sequential version of the download_many function. This code is straightforward, but it’s worth studying to contrast with the concurrent versions coming up. Focus on how it reports progress, handles errors, and tallies downloads.\n\nExample 20-15. flags2_sequential.py: the sequential implementation of download_many\n\ndef download_many(cc_list: list[str], base_url: str, verbose: bool, _unused_concur_req: int) -> Counter[DownloadStatus]: counter: Counter[DownloadStatus] = Counter() cc_iter = sorted(cc_list) if not verbose: cc_iter = tqdm.tqdm(cc_iter) for cc in cc_iter: try: status = download_one(cc, base_url, verbose) except httpx.HTTPStatusError as exc: error_msg = 'HTTP error {resp.status_code} - {resp.reason_phrase}' error_msg = error_msg.format(resp=exc.response) except httpx.RequestError as exc: error_msg = f'{exc} {type(exc)}'.strip() except KeyboardInterrupt: break else: error_msg = ''\n\nif error_msg: status = DownloadStatus.ERROR counter[status] += 1 if verbose and error_msg: print(f'{cc} error: {error_msg}')\n\nreturn counter\n\nThis Counter will tally the different download outcomes: DownloadStatus.OK, DownloadStatus.NOT_FOUND, or DownloadStatus.ERROR.\n\ncc_iter holds the list of the country codes received as arguments, ordered alphabetically.\n\nIf not running in verbose mode, cc_iter is passed to tqdm, which returns an iter‐ ator yielding the items in cc_iter while also animating the progress bar.\n\nMake successive calls to download_one.\n\n768\n\n|\n\nChapter 20: Concurrent Executors\n\nHTTP status code exceptions raised by get_flag and not handled by down load_one are handled here.\n\nOther network-related exceptions are handled here. Any other exception will abort the script, because the flags2_common.main function that calls down load_many has no try/except.\n\nExit the loop if the user hits Ctrl-C.\n\nIf no exception escaped download_one, clear the error message.\n\nIf there was an error, set the local status accordingly.\n\nIncrement the counter for that status.\n\nIn verbose mode, display the error message for the current country code, if any.\n\nReturn counter so that main can display the numbers in the final report.\n\nWe’ll now study the refactored thread pool example, flags2_threadpool.py.\n\nUsing futures.as_completed In order to integrate the tqdm progress bar and handle errors on each request, flags2_threadpool.py script uses futures.ThreadPoolExecutor with the the futures.as_completed function we’ve already seen. Example 20-16 is the full listing of flags2_threadpool.py. Only the download_many function is implemented; the other functions are reused from flags2_common.py and flags2_sequential.py.\n\nExample 20-16. flags2_threadpool.py: full listing\n\nfrom collections import Counter from concurrent.futures import ThreadPoolExecutor, as_completed\n\nimport httpx import tqdm # type: ignore\n\nfrom flags2_common import main, DownloadStatus from flags2_sequential import download_one\n\nDEFAULT_CONCUR_REQ = 30 MAX_CONCUR_REQ = 1000\n\ndef download_many(cc_list: list[str], base_url: str,\n\nDownloads with Progress Display and Error Handling\n\n|\n\n769\n\nverbose: bool, concur_req: int) -> Counter[DownloadStatus]: counter: Counter[DownloadStatus] = Counter() with ThreadPoolExecutor(max_workers=concur_req) as executor: to_do_map = {} for cc in sorted(cc_list): future = executor.submit(download_one, cc, base_url, verbose) to_do_map[future] = cc done_iter = as_completed(to_do_map) if not verbose: done_iter = tqdm.tqdm(done_iter, total=len(cc_list)) for future in done_iter: try: status = future.result() except httpx.HTTPStatusError as exc: error_msg = 'HTTP error {resp.status_code} - {resp.reason_phrase}' error_msg = error_msg.format(resp=exc.response) except httpx.RequestError as exc: error_msg = f'{exc} {type(exc)}'.strip() except KeyboardInterrupt: break else: error_msg = ''\n\nif error_msg: status = DownloadStatus.ERROR counter[status] += 1 if verbose and error_msg: cc = to_do_map[future] print(f'{cc} error: {error_msg}')\n\nreturn counter\n\nif __name__ == '__main__': main(download_many, DEFAULT_CONCUR_REQ, MAX_CONCUR_REQ)\n\nReuse download_one from flags2_sequential (Example 20-14).\n\nIf the -m/--max_req command-line option is not given, this will be the maxi‐ mum number of concurrent requests, implemented as the size of the thread pool; the actual number may be smaller if the number of flags to download is smaller.\n\nMAX_CONCUR_REQ caps the maximum number of concurrent requests regardless of the number of flags to download or the -m/--max_req command-line option. It’s a safety precaution to avoid launching too many threads with their significant memory overhead.\n\n770\n\n|\n\nChapter 20: Concurrent Executors\n\nCreate the executor with max_workers set to concur_req, computed by the main function as the smaller of: MAX_CONCUR_REQ, the length of cc_list, or the value of the -m/--max_req command-line option. This avoids creating more threads than necessary.\n\nThis dict will map each Future instance—representing one download—with the respective country code for error reporting.\n\nIterate over the list of country codes in alphabetical order. The order of the results will depend on the timing of the HTTP responses more than anything, but if the size of the thread pool (given by concur_req) is much smaller than len(cc_list), you may notice the downloads batched alphabetically.\n\nEach call to executor.submit schedules the execution of one callable and returns a Future instance. The first argument is the callable, the rest are the arguments it will receive.\n\nStore the future and the country code in the dict.\n\nfutures.as_completed returns an iterator that yields futures as each task is done.\n\nIf not in verbose mode, wrap the result of as_completed with the tqdm function to display the progress bar; because done_iter has no len, we must tell tqdm what is the expected number of items as the total= argument, so tqdm can esti‐ mate the work remaining.\n\nIterate over the futures as they are completed.\n\nCalling the result method on a future either returns the value returned by the callable, or raises whatever exception was caught when the callable was executed. This method may block waiting for a resolution, but not in this example because as_completed only returns futures that are done.\n\nHandle the potential exceptions; the rest of this function is identical to the sequential download_many in Example 20-15), except for the next callout.\n\nTo provide context for the error message, retrieve the country code from the to_do_map using the current future as key. This was not necessary in the sequential version because we were iterating over the list of country codes, so we knew the current cc; here we are iterating over the futures.\n\nDownloads with Progress Display and Error Handling\n\n|\n\n771\n\nExample 20-16 uses an is very useful with idiom futures.as_completed: building a dict to map each future to other data that may be useful when the future is completed. Here the to_do_map maps each future to the country code assigned to it. This makes it easy to do follow-up processing with the result of the futures, despite the fact that they are produced out of order.\n\nthat\n\nPython threads are well suited for I/O-intensive applications, and the concur rent.futures package makes it relatively simple to use for certain use cases. With ProcessPoolExecutor, you can also solve CPU-intensive problems on multiple cores —if the computations are “embarrassingly parallel”. This concludes our basic intro‐ duction to concurrent.futures.\n\nChapter Summary We started the chapter by comparing two concurrent HTTP clients with a sequential one, demonstrating that the concurrent solutions show significant performance gains over the sequential script.\n\nAfter studying the first example based on concurrent.futures, we took a closer look at future objects, either instances of concurrent.futures.Future or asyncio .Future, emphasizing what these classes have in common (their differences will be emphasized in Chapter 21). We saw how to create futures by calling Executor.sub mit, and iterate over completed futures with concurrent.futures.as_completed.\n\nWe then discussed the use of multiple processes with the concurrent.futures.Proc essPoolExecutor class, to go around the GIL and use multiple CPU cores to simplify the multicore prime checker we first saw in Chapter 19.\n\nIn the following section, we saw how the concurrent.futures.ThreadPoolExecutor works with a didactic example, launching tasks that did nothing for a few seconds, except for displaying their status with a timestamp.\n\nNext we went back to the flag downloading examples. Enhancing them with a pro‐ gress bar and proper error handling prompted further exploration of the future.as_completed generator function, showing a common pattern: storing futures in a dict to link further information to them when submitting, so that we can use that information when the future comes out of the as_completed iterator.\n\nFurther Reading The concurrent.futures package was contributed by Brian Quinlan, who presented it in a great talk titled “The Future Is Soon!” at PyCon Australia 2010. Quinlan’s talk has no slides; he shows what the library does by typing code directly in the Python\n\n772\n\n|\n\nChapter 20: Concurrent Executors\n\nconsole. As a motivating example, the presentation features a short video with XKCD cartoonist/programmer Randall Munroe making an unintended DoS attack on Goo‐ gle Maps to build a colored map of driving times around his city. The formal intro‐ duction to the library is PEP 3148 - futures - execute computations asynchronously. In the PEP, Quinlan wrote that the concurrent.futures library was “heavily influ‐ enced by the Java java.util.concurrent package.”\n\nFor additional resources covering concurrent.futures, please see Chapter 19. All the references that cover Python’s threading and multiprocessing in “Concurrency with Threads and Processes” on page 734 also cover concurrent.futures.\n\nSoapbox\n\nThread Avoidance\n\nConcurrency: one of the most difficult topics in computer science (usually best avoided).\n\n—David Beazley, Python instructor and mad scientist8\n\nI agree with the apparently contradictory quotes by David Beazley and Michele Sim‐ ionato at the start of this chapter.\n\nI attended an undergraduate course about concurrency. All we did was POSIX threads programming. What I learned: I don’t want to manage threads and locks myself, for the same reason that I don’t want to manage memory allocation and deal‐ location. Those jobs are best carried out by the systems programmers who have the know-how, the inclination, and the time to get them right—hopefully. I am paid to develop applications, not operating systems. I don’t need all the fine-grained control of threads, locks, malloc, and free—see “C dynamic memory allocation”.\n\nThat’s why I think the concurrent.futures package is interesting: it treats threads, processes, and queues as infrastructure at your service, not something you have to deal with directly. Of course, it’s designed with simple jobs in mind, the so-called embarrassingly parallel problems. But that’s a large slice of the concurrency problems we face when writing applications—as opposed to operating systems or database servers, as Simionato points out in that quote.\n\nFor “nonembarrassing” concurrency problems, threads and locks are not the answer either. Threads will never disappear at the OS level, but every programming language I’ve found exciting in the last several years provides higher-level, concurrency abstractions that are easier to use correctly, as the excellent Seven Concurrency Models in Seven Weeks book by Paul Butcher demonstrates. Go, Elixir, and Clojure are\n\n8 Slide #9 from “A Curious Course on Coroutines and Concurrency” tutorial presented at PyCon 2009.\n\nFurther Reading\n\n|\n\n773\n\namong them. Erlang—the implementation language of Elixir—is a prime example of a language designed from the ground up with concurrency in mind. Erlang doesn’t excite me for a simple reason: I find its syntax ugly. Python spoiled me that way.\n\nJosé Valim, previously a Ruby on Rails core contributor, designed Elixir with a pleas‐ ant, modern syntax. Like Lisp and Clojure, Elixir implements syntactic macros. That’s a double-edged sword. Syntactic macros enable powerful DSLs, but the proliferation of sublanguages can lead to incompatible codebases and community fragmentation. Lisp drowned in a flood of macros, with each Lisp shop using its own arcane dialect. Standardizing around Common Lisp resulted in a bloated language. I hope José Valim can inspire the Elixir community to avoid a similar outcome. So far, it’s look‐ ing good. The Ecto database wrapper and query generator is a joy to use: a great example of using macros to create a flexible yet user-friendly DSL—Domain-Specific Language—for interacting with relational and nonrelational databases.\n\nLike Elixir, Go is a modern language with fresh ideas. But, in some regards, it’s a con‐ servative language, compared to Elixir. Go doesn’t have macros, and its syntax is sim‐ pler than Python’s. Go doesn’t support inheritance or operator overloading, and it offers fewer opportunities for metaprogramming than Python. These limitations are considered features. They lead to more predictable behavior and performance. That’s a big plus in the highly concurrent, mission-critical settings where Go aims to replace C++, Java, and Python.\n\nWhile Elixir and Go are direct competitors in the high-concurrency space, their design philosophies appeal to different crowds. Both are likely to thrive. But in the history of programming languages, the conservative ones tend to attract more coders.\n\n774\n\n|\n\nChapter 20: Concurrent Executors\n\nCHAPTER 21 Asynchronous Programming\n\nThe problem with normal approaches to asynchronous programming is that they’re all-or-nothing propositions. You rewrite all your code so none of it blocks or you’re just wasting your time. Alvaro Videla and Jason J. W. Williams, RabbitMQ in Action1\n\nThis chapter addresses three major topics that are closely related:\n\nPython’s async def, await, async with, and async for constructs\n\nObjects supporting those constructs: native coroutines and asynchronous var‐ iants of context managers, iterables, generators, and comprehensions\n\nasyncio and other asynchronous libraries\n\nThis chapter builds on the ideas of iterables and generators (Chapter 17, in particular “Classic Coroutines” on page 641), context managers (Chapter 18), and general con‐ cepts of concurrent programming (Chapter 19).\n\nWe’ll study concurrent HTTP clients similar to the ones we saw in Chapter 20, rewritten with native coroutines and asynchronous context managers, using the same HTTPX library as before, but now through its asynchronous API. We’ll also see how to avoid blocking the event loop by delegating slow operations to a thread or process executor.\n\nAfter the HTTP client examples, we’ll see two simple asynchronous server-side appli‐ cations, one of them using the increasingly popular FastAPI framework. Then we’ll cover other language constructs enabled by the async/await keywords:\n\n1 Videla & Williams, RabbitMQ in Action (Manning), Chapter 4, “Solving Problems with Rabbit: coding and\n\npatterns,” p. 61.\n\n775\n\nasynchronous generator functions, asynchronous comprehensions, and asynchro‐ nous generator expressions. To emphasize the fact that those language features are not tied to asyncio, we’ll see one example rewritten to use Curio—the elegant and innovative asynchronous framework invented by David Beazley.\n\nTo wrap up the chapter, I wrote a brief section on the advantages and pitfalls of asyn‐ chronous programming.\n\nThat’s a lot of ground to cover. We only have space for basic examples, but they will illustrate the most important features of each idea.\n\nThe asyncio documentation is much better after Yury Selivanov2 reorganized it, separating the few functions useful to application developers from the low-level API for creators of packages like web frameworks and database drivers.\n\nFor book-length coverage of asyncio, I recommend Using Asyncio in Python by Caleb Hattingh (O’Reilly). Full disclosure: Caleb is one of the tech reviewers of this book.\n\nWhat’s New in This Chapter When I wrote the first edition of Fluent Python, the asyncio library was provisional and the async/await keywords did not exist. Therefore, I had to update all examples in this chapter. I also created new examples: domain probing scripts, a FastAPI web service, and experiments with Python’s new asynchronous console mode.\n\nNew sections cover language features that did not exist at the time, such as native coroutines, async with, async for, and the objects that support those constructs.\n\nThe ideas in “How Async Works and How It Doesn’t” on page 825 reflect hard- earned lessons that I consider essential reading for anyone using asynchronous pro‐ gramming. They may save you a lot of trouble—whether you’re using Python or Node.js.\n\nFinally, I removed several paragraphs about asyncio.Futures, which is now consid‐ ered part of the low-level asyncio APIs.\n\n2 Selivanov implemented async/await in Python, and wrote the related PEPs 492, 525, and 530.\n\n776\n\n|\n\nChapter 21: Asynchronous Programming\n\nA Few Definitions At the start of “Classic Coroutines” on page 641, we saw that Python 3.5 and later offer three kinds of coroutines:\n\nNative coroutine\n\nA coroutine function defined with async def. You can delegate from a native coroutine to another native coroutine using the await keyword, similar to how classic coroutines use yield from. The async def statement always defines a native coroutine, even if the await keyword is not used in its body. The await keyword cannot be used outside of a native coroutine.3\n\nClassic coroutine\n\nA generator function that consumes data sent to it via my_coro.send(data) calls, and reads that data by using yield in an expression. Classic coroutines can dele‐ gate to other classic coroutines using yield from. Classic coroutines cannot be driven by await, and are no longer supported by asyncio.\n\nGenerator-based coroutine\n\nA generator function decorated with @types.coroutine—introduced in Python 3.5. That decorator makes the generator compatible with the new await keyword.\n\nIn this chapter, we focus on native coroutines as well as asynchronous generators:\n\nAsynchronous generator\n\nA generator function defined with async def and using yield in its body. It returns an asynchronous generator object that provides __anext__, a coroutine method to retrieve the next item.\n\n@asyncio.coroutine has No Future4\n\nThe @asyncio.coroutine decorator for classic coroutines and generator-based coroutines was deprecated in Python 3.8 and is scheduled for removal in Python 3.11, according to Issue 43216. In contrast, @types.coroutine should remain, per Issue 36921. It is no longer supported by asyncio, but is used in low-level code in the Curio and Trio asynchronous frameworks.\n\n3 There is one exception to this rule: if you run Python with the -m asyncio option, you can use await directly at the >>> prompt to drive a native coroutine. This is explained in “Experimenting with Python’s async con‐ sole” on page 812.\n\n4 Sorry, I could not resist it.\n\nA Few Definitions\n\n|\n\n777\n\nAn asyncio Example: Probing Domains Imagine you are about to start a new blog on Python, and you plan to register a domain using a Python keyword and the .DEV suffix—for example: AWAIT.DEV. Example 21-1 is a script using asyncio to check several domains concurrently. This is the output it produces:\n\n$ python3 blogdom.py with.dev + elif.dev + def.dev from.dev else.dev or.dev if.dev del.dev + as.dev none.dev pass.dev true.dev + in.dev + for.dev + is.dev + and.dev + try.dev + not.dev\n\nNote that the domains appear unordered. If you run the script, you’ll see them dis‐ played one after the other, with varying delays. The + sign indicates your machine was able to resolve the domain via DNS. Otherwise, the domain did not resolve and may be available.5\n\nIn blogdom.py, the DNS probing is done via native coroutine objects. Because the asynchronous operations are interleaved, the time needed to check the 18 domains is much less than checking them sequentially. In fact, the total time is practically the same as the time for the single slowest DNS response, instead of the sum of the times of all responses.\n\nExample 21-1 shows the code for blogdom.py.\n\nExample 21-1. blogdom.py: search for domains for a Python blog\n\n#!/usr/bin/env python3 import asyncio import socket\n\n5 true.dev is available for USD 360/year as I write this. I see that for.dev is registered, but has no DNS config‐\n\nured.\n\n778\n\n|\n\nChapter 21: Asynchronous Programming\n\nfrom keyword import kwlist\n\nMAX_KEYWORD_LEN = 4\n\nasync def probe(domain: str) -> tuple[str, bool]: loop = asyncio.get_running_loop() try: await loop.getaddrinfo(domain, None) except socket.gaierror: return (domain, False) return (domain, True)\n\nasync def main() -> None: names = (kw for kw in kwlist if len(kw) <= MAX_KEYWORD_LEN) domains = (f'{name}.dev'.lower() for name in names) coros = [probe(domain) for domain in domains] for coro in asyncio.as_completed(coros): domain, found = await coro mark = '+' if found else ' ' print(f'{mark} {domain}')\n\nif __name__ == '__main__': asyncio.run(main())\n\nSet maximum length of keyword for domains, because shorter is better.\n\nprobe returns a tuple with the domain name and a boolean; True means the domain resolved. Returning the domain name will make it easier to display the results.\n\nGet a reference to the asyncio event loop, so we can use it next.\n\nThe loop.getaddrinfo(…) coroutine-method returns a five-part tuple of param‐ eters to connect to the given address using a socket. In this example, we don’t need the result. If we got it, the domain resolves; otherwise, it doesn’t.\n\nmain must be a coroutine, so that we can use await in it.\n\nGenerator to yield Python keywords with length up to MAX_KEYWORD_LEN.\n\nGenerator to yield domain names with the .dev suffix.\n\nBuild a list of coroutine objects by invoking the probe coroutine with each domain argument.\n\nAn asyncio Example: Probing Domains\n\n|\n\n779\n\nasyncio.as_completed is a generator that yields coroutines that return the results of the coroutines passed to it in the order they are completed—not the order they were submitted. It’s similar to futures.as_completed, which we saw in Chapter 20, Example 20-4.\n\nAt this point, we know the coroutine is done because that’s how as_completed works. Therefore, the await expression will not block but we need it to get the result from coro. If coro raised an unhandled exception, it would be re-raised here.\n\nasyncio.run starts the event loop and returns only when the event loop exits. This is a common pattern for scripts that use asyncio: implement main as a coroutine, and drive it with asyncio.run inside the if __name__ == '__main__': block.\n\nThe asyncio.get_running_loop function was added in Python 3.7 for use inside coroutines, as shown in probe. If there’s no running loop, asyncio.get_running_loop raises RuntimeError. Its imple‐ mentation is simpler and faster than asyncio.get_event_loop, which may start an event loop if necessary. Since Python 3.10, asyn cio.get_event_loop is deprecated and will eventually become an alias to asyncio.get_running_loop.\n\nGuido’s Trick to Read Asynchronous Code There are a lot of new concepts to grasp in asyncio, but the overall logic of Example 21-1 is easy to follow if you employ a trick suggested by Guido van Rossum himself: squint and pretend the async and await keywords are not there. If you do that, you’ll realize that coroutines read like plain old sequential functions.\n\nFor example, imagine that the body of this coroutine…\n\nasync def probe(domain: str) -> tuple[str, bool]: loop = asyncio.get_running_loop() try: await loop.getaddrinfo(domain, None) except socket.gaierror: return (domain, False) return (domain, True)\n\n…works like the following function, except that it magically never blocks:\n\ndef probe(domain: str) -> tuple[str, bool]: # no async loop = asyncio.get_running_loop() try: loop.getaddrinfo(domain, None) # no await\n\n780\n\n|\n\nChapter 21: Asynchronous Programming\n\nexcept socket.gaierror: return (domain, False) return (domain, True)\n\nUsing the syntax await loop.getaddrinfo(...) avoids blocking because await sus‐ pends the current coroutine object. For example, during the execution of the probe('if.dev') coroutine, a new coroutine object is created by getad drinfo('if.dev', None). Awaiting it starts the low-level addrinfo query and yields control back to the event loop, not to the probe(‘if.dev’) coroutine, which is sus‐ pended. The event loop can then drive other pending coroutine objects, such as probe('or.dev').\n\nWhen the event loop gets a response for the getaddrinfo('if.dev', None) query, that specific coroutine object resumes and returns control back the probe('if.dev')—which was suspended at await—and can now handle a possible exception and return the result tuple.\n\nSo far, we’ve only seen asyncio.as_completed and await applied to coroutines. But they handle any awaitable object. That concept is explained next.\n\nNew Concept: Awaitable The for keyword works with iterables. The await keyword works with awaitables.\n\nAs an end user of asyncio, these are the awaitables you will see on a daily basis:\n\nA native coroutine object, which you get by calling a native coroutine function • An asyncio.Task, which you usually get by passing a coroutine object to asyn cio.create_task()\n\nHowever, end-user code does not always need to await on a Task. We use asyn cio.create_task(one_coro()) to schedule one_coro for concurrent execution, without waiting for its return. That’s what we did with the spinner coroutine in spin‐ ner_async.py (Example 19-4). If you don’t expect to cancel the task or wait for it, there is no need to keep the Task object returned from create_task. Creating the task is enough to schedule the coroutine to run.\n\nIn contrast, we use await other_coro() to run other_coro right now and wait for its completion because we need its result before we can proceed. In spinner_async.py, the supervisor coroutine did res = await slow() to execute slow and get its result.\n\nWhen implementing asynchronous libraries or contributing to asyncio itself, you may also deal with these lower-level awaitables:\n\nNew Concept: Awaitable\n\nto\n\n|\n\n781",
      "page_number": 778
    },
    {
      "number": 40,
      "title": "Segment 40 (pages 798-818)",
      "start_page": 798,
      "end_page": 818,
      "detection_method": "synthetic",
      "content": "An object with an __await__ method that returns an iterator; for example, an asyncio.Future instance (asyncio.Task is a subclass of asyncio.Future)\n\nObjects written\n\nthe Python/C API with a languages using tp_as_async.am_await function, returning an iterator (similar to __await__ method)\n\nin other\n\nExisting codebases may also have one additional kind of awaitable: generator-based coroutine objects—which are in the process of being deprecated.\n\nPEP 492 states that the await expression “uses the yield from implementation with an extra step of validating its argument” and “await only accepts an awaitable.” The PEP does not explain that implementation in detail, but refers to PEP 380, which introduced yield from. I posted a detailed explanation in “Classic Corou‐ tines”, section “The Meaning of yield from”, at fluentpython.com.\n\nNow let’s study the asyncio version of a script that downloads a fixed set of flag images.\n\nDownloading with asyncio and HTTPX The flags_asyncio.py script downloads a fixed set of 20 flags from fluentpython.com. We first mentioned it in “Concurrent Web Downloads” on page 744, but now we’ll study it in detail, applying the concepts we just saw.\n\nAs of Python 3.10, asyncio only supports TCP and UDP directly, and there are no asynchronous HTTP client or server packages in the standard library. I am using HTTPX in all the HTTP client examples.\n\nWe’ll explore flags_asyncio.py from the bottom up—that is, looking first at the func‐ tions that set up the action in Example 21-2.\n\nTo make the code easier to read, flags_asyncio.py has no error han‐ dling. As we introduce async/await, it’s useful to focus on the “happy path” initially, to understand how regular functions and coroutines are arranged in a program. Starting with “Enhancing the asyncio Downloader” on page 787, the examples include error handling and more features.\n\nThe flags_.py examples from this chapter and Chapter 20 share code and data, so I put them together in the example-code-2e/20- executors/getflags directory.\n\n782\n\n|\n\nChapter 21: Asynchronous Programming\n\nExample 21-2. flags_asyncio.py: startup functions\n\ndef download_many(cc_list: list[str]) -> int: return asyncio.run(supervisor(cc_list))\n\nasync def supervisor(cc_list: list[str]) -> int: async with AsyncClient() as client: to_do = [download_one(client, cc) for cc in sorted(cc_list)] res = await asyncio.gather(*to_do)\n\nreturn len(res)\n\nif __name__ == '__main__': main(download_many)\n\nThis needs to be a plain function—not a coroutine—so it can be passed to and called by the main function from the flags.py module (Example 20-2).\n\nExecute the event loop driving the supervisor(cc_list) coroutine object until it returns. This will block while the event loop runs. The result of this line is whatever supervisor returns.\n\nAsynchronous HTTP client operations in httpx are methods of AsyncClient, which is also an asynchronous context manager: a context manager with asyn‐ chronous setup and teardown methods (more about this in “Asynchronous Con‐ text Managers” on page 786).\n\nBuild a list of coroutine objects by calling the download_one coroutine once for each flag to be retrieved.\n\nWait for the asyncio.gather coroutine, which accepts one or more awaitable arguments and waits for all of them to complete, returning a list of results for the given awaitables in the order they were submitted.\n\nsupervisor returns the length of the list returned by asyncio.gather.\n\nNow let’s review the top of flags_asyncio.py (Example 21-3). I reorganized the corou‐ tines so we can read them in the order they are started by the event loop.\n\nExample 21-3. flags_asyncio.py: imports and download functions\n\nimport asyncio\n\nfrom httpx import AsyncClient\n\nfrom flags import BASE_URL, save_flag, main\n\nDownloading with asyncio and HTTPX\n\n|\n\n783\n\nasync def download_one(client: AsyncClient, cc: str): image = await get_flag(client, cc) save_flag(image, f'{cc}.gif') print(cc, end=' ', flush=True) return cc\n\nasync def get_flag(client: AsyncClient, cc: str) -> bytes: url = f'{BASE_URL}/{cc}/{cc}.gif'.lower() resp = await client.get(url, timeout=6.1, follow_redirects=True) return resp.read()\n\nhttpx must be installed—it’s not in the standard library.\n\nReuse code from flags.py (Example 20-2).\n\ndownload_one must be a native coroutine, so it can await on get_flag—which does the HTTP request. Then it displays the code of the downloaded flag, and saves the image.\n\nget_flag needs to receive the AsyncClient to make the request.\n\nThe get method of an httpx.AsyncClient instance returns a ClientResponse object that is also an asynchronous context manager.\n\nNetwork I/O operations are implemented as coroutine methods, so they are driven asynchronously by the asyncio event loop.\n\nFor better performance, the save_flag call inside get_flag should be asynchronous, to avoid blocking the event loop. However, asyn‐ cio does not provide an asynchronous filesystem API at this time— as Node.js does.\n\n“Using asyncio.as_completed and a Thread” on page 788 will show how to delegate save_flag to a thread.\n\nYour code delegates to the httpx coroutines explicitly through await or implicitly through the special methods of the asynchronous context managers, such as Async Client and ClientResponse—as we’ll see in “Asynchronous Context Managers” on page 786.\n\nThe Secret of Native Coroutines: Humble Generators A key difference between the classic coroutine examples we saw in “Classic Corou‐ tines” on page 641 and flags_asyncio.py is that there are no visible .send() calls or\n\n784\n\n|\n\nChapter 21: Asynchronous Programming\n\nyield expressions in the latter. Your code sits between the asyncio library and the asynchronous libraries you are using, such as HTTPX. This is illustrated in Figure 21-1.\n\nFigure 21-1. In an asynchronous program, a user’s function starts the event loop, sched‐ uling an initial coroutine with asyncio.run. Each user’s coroutine drives the next with an await expression, forming a channel that enables communication between a library like HTTPX and the event loop.\n\nUnder the hood, the asyncio event loop makes the .send calls that drive your corou‐ tines, and your coroutines await on other coroutines, including library coroutines. As mentioned, await borrows most of its implementation from yield from, which also makes .send calls to drive coroutines.\n\nThe await chain eventually reaches a low-level awaitable, which returns a generator that the event loop can drive in response to events such as timers or network I/O. The low-level awaitables and generators at the end of these await chains are implemented deep into the libraries, are not part of their APIs, and may be Python/C extensions.\n\nUsing functions like asyncio.gather and asyncio.create_task, you can start mul‐ tiple concurrent await channels, enabling concurrent execution of multiple I/O oper‐ ations driven by a single event loop, in a single thread.\n\nThe All-or-Nothing Problem Note that in Example 21-3, I could not reuse the get_flag function from flags.py (Example 20-2). I had to rewrite it as a coroutine to use the asynchronous API of HTTPX. For peak performance with asyncio, we must replace every function that does I/O with an asynchronous version that is activated with await or asyncio.cre ate_task, so that control is given back to the event loop while the function waits for I/O. If you can’t rewrite a blocking function as a coroutine, you should run it in a separate thread or process, as we’ll see in “Delegating Tasks to Executors” on page 797.\n\nDownloading with asyncio and HTTPX\n\n|\n\n785\n\nThat’s why I chose the epigraph for this chapter, which includes this advice: “You rewrite all your code so none of it blocks or you’re just wasting your time.”\n\nFor the same reason, I could not reuse the download_one function from flags_thread‐ pool.py (Example 20-3) either. The code in Example 21-3 drives get_flag with await, so download_one must also be a coroutine. For each request, a download_one coroutine object is created in supervisor, and they are all driven by the asyncio.gather coroutine.\n\nlet’s study the async with statement that appeared\n\nNow (Example 21-2) and get_flag (Example 21-3).\n\nin supervisor\n\nAsynchronous Context Managers In “Context Managers and with Blocks” on page 658, we saw how an object can be used to run code before and after the body of a with block, if its class provides the __enter__ and __exit__ methods.\n\nNow, consider Example 21-4, from the asyncpg asyncio-compatible PostgreSQL driver documentation on transactions.\n\nExample 21-4. Sample code from the documentation of the asyncpg PostgreSQL driver\n\ntr = connection.transaction() await tr.start() try: await connection.execute(\"INSERT INTO mytable VALUES (1, 2, 3)\") except: await tr.rollback() raise else: await tr.commit()\n\nA database transaction is a natural fit for the context manager protocol: the transac‐ tion has to be started, data is changed with connection.execute, and then a rollback or commit must happen, depending on the outcome of the changes.\n\nIn an asynchronous driver like asyncpg, the setup and wrap-up need to be coroutines so that other operations can happen concurrently. However, the implementation of the classic with statement doesn’t support coroutines doing the work of __enter__ or __exit__.\n\nThat’s why PEP 492—Coroutines with async and await syntax introduced the async with statement, which works with asynchronous context managers: objects imple‐ menting the __aenter__ and __aexit__ methods as coroutines.\n\n786\n\n|\n\nChapter 21: Asynchronous Programming\n\nWith async with, Example 21-4 can be written like this other snippet from the asyncpg documentation:\n\nasync with connection.transaction(): await connection.execute(\"INSERT INTO mytable VALUES (1, 2, 3)\")\n\nIn the asyncpg.Transaction class, the __aenter__ coroutine method does await self.start(), and the __aexit__ coroutine awaits on private __rollback or __com mit coroutine methods, depending on whether an exception occurred or not. Using coroutines to implement Transaction as an asynchronous context manager allows asyncpg to handle many transactions concurrently.\n\nCaleb Hattingh on asyncpg\n\nAnother really great thing about asyncpg is that it also works around PostgreSQL’s lack of high-concurrency support (it uses one server-side process per connection) by implementing a connection pool for internal connections to Postgres itself.\n\nThis means you don’t need additional tools like pgbouncer as explained in the asyncpg documentation.6\n\nBack to flags_asyncio.py, the AsyncClient class of httpx is an asynchronous context manager, so it can use awaitables in its __aenter__ and __aexit__ special coroutine methods.\n\n“Asynchronous generators as context managers” on page 817 shows how to use Python’s contextlib to create an asynchronous context manager without having to write a class. That explanation comes later in this chapter because of a prerequisite topic: “Asynchronous Generator Functions” on page 812.\n\nWe’ll now enhance the asyncio flag download example with a progress bar, which will lead us to explore a bit more of the asyncio API.\n\nEnhancing the asyncio Downloader Recall from “Downloads with Progress Display and Error Handling” on page 762 that the flags2 set of examples share the same command-line interface, and they display a progress bar while the downloads are happening. They also include error handling.\n\n6 This tip is quoted verbatim from a comment by tech reviewer Caleb Hattingh. Thanks, Caleb!\n\nEnhancing the asyncio Downloader\n\n|\n\n787\n\nI encourage you to play with the flags2 examples to develop an intuition of how concurrent HTTP clients perform. Use the -h option to see the help screen in Example 20-10. Use the -a, -e, and -l command-line options to control the number of downloads, and the -m option to set the number of concurrent downloads. Run tests against the LOCAL, REMOTE, DELAY, and ERROR servers. Discover the optimum number of concurrent downloads to maximize throughput against each server. Tweak the options for the test servers, as described in “Setting Up Test Servers” on page 765.\n\nFor instance, Example 21-5 shows an attempt to get 100 flags (-al 100) from the ERROR server, using 100 concurrent requests (-m 100). The 48 errors in the result are either HTTP 418 or time-out errors—the expected (mis)behavior of the slow_server.py.\n\nExample 21-5. Running flags2_asyncio.py\n\n$ python3 flags2_asyncio.py -s ERROR -al 100 -m 100 ERROR site: http://localhost:8002/flags Searching for 100 flags: from AD to LK 100 concurrent connections will be used. 100%|█████████████████████████████████████████| 100/100 [00:03<00:00, 30.48it/s] -------------------- 52 flags downloaded. 48 errors. Elapsed time: 3.31s\n\nAct Responsibly When Testing Concurrent Clients\n\nEven if the overall download time is not much different between the threaded and asyncio HTTP clients, asyncio can send requests faster, so it’s more likely that the server will suspect a DoS attack. To really exercise these concurrent clients at full throttle, please use local HTTP servers for testing, as explained in “Setting Up Test Servers” on page 765.\n\nNow let’s see how flags2_asyncio.py is implemented.\n\nUsing asyncio.as_completed and a Thread In Example 21-3, we passed several coroutines to asyncio.gather, which returns a list with results of the coroutines in the order they were submitted. This means that asyncio.gather can only return when all the awaitables are done. However, to update a progress bar, we need to get results as they are done.\n\n788\n\n|\n\nChapter 21: Asynchronous Programming\n\nFortunately, there is an asyncio equivalent of the as_completed generator function we used in the thread pool example with the progress bar (Example 20-16).\n\nExample 21-6 shows the top of the flags2_asyncio.py script where the get_flag and download_one coroutines are defined. Example 21-7 lists the rest of the source, with supervisor and download_many. This script is longer than flags_asyncio.py because of error handling.\n\nExample 21-6. flags2_asyncio.py: top portion of the script; remaining code is in Example 21-7\n\nimport asyncio from collections import Counter from http import HTTPStatus from pathlib import Path\n\nimport httpx import tqdm # type: ignore\n\nfrom flags2_common import main, DownloadStatus, save_flag\n\n# low concurrency default to avoid errors from remote site, # such as 503 - Service Temporarily Unavailable DEFAULT_CONCUR_REQ = 5 MAX_CONCUR_REQ = 1000\n\nasync def get_flag(client: httpx.AsyncClient, base_url: str, cc: str) -> bytes: url = f'{base_url}/{cc}/{cc}.gif'.lower() resp = await client.get(url, timeout=3.1, follow_redirects=True) resp.raise_for_status() return resp.content\n\nasync def download_one(client: httpx.AsyncClient, cc: str, base_url: str, semaphore: asyncio.Semaphore, verbose: bool) -> DownloadStatus: try: async with semaphore: image = await get_flag(client, base_url, cc) except httpx.HTTPStatusError as exc: res = exc.response if res.status_code == HTTPStatus.NOT_FOUND: status = DownloadStatus.NOT_FOUND msg = f'not found: {res.url}' else: raise else:\n\nEnhancing the asyncio Downloader\n\n|\n\n789\n\nawait asyncio.to_thread(save_flag, image, f'{cc}.gif') status = DownloadStatus.OK msg = 'OK' if verbose and msg: print(cc, msg) return status\n\nget_flag is very similar to the sequential version in Example 20-14. First differ‐ ence: it requires the client parameter.\n\nSecond and third differences: .get is an AsyncClient method, and it’s a corou‐ tine, so we need to await it.\n\nUse the semaphore as an asynchronous context manager so that the program as a whole is not blocked; only this coroutine is suspended when the semaphore counter is zero. More about this in “Python’s Semaphores” on page 791.\n\nThe error handling logic is the same as in download_one, from Example 20-14.\n\nSaving the image is an I/O operation. To avoid blocking the event loop, run save_flag in a thread.\n\nAll network I/O is done with coroutines in asyncio, but not file I/O. However, file I/O is also “blocking”—in the sense that reading/writing files takes thousands of times longer than reading/writing to RAM. If you’re using Network-Attached Stor‐ age, it may even involve network I/O under the covers.\n\nSince Python 3.9, the asyncio.to_thread coroutine makes it easy to delegate file I/O to a thread pool provided by asyncio. If you need to support Python 3.7 or 3.8, “Dele‐ gating Tasks to Executors” on page 797 shows how to add a couple of lines to do it. But first, let’s finish our study of the HTTP client code.\n\nThrottling Requests with a Semaphore Network clients like the ones we are studying should be throttled (i.e., limited) to avoid pounding the server with too many concurrent requests.\n\nA semaphore is a synchronization primitive, more flexible than a lock. A semaphore can be held by multiple coroutines, with a configurable maximum number. This makes it ideal to throttle the number of active concurrent coroutines. “Python’s Sem‐ aphores” on page 791 has more information.\n\nIn flags2_threadpool.py (Example 20-16), the throttling was done by instantiating the ThreadPoolExecutor with the required max_workers argument set to concur_req in the download_many function. In flags2_asyncio.py, an asyncio.Semaphore is created\n\n790\n\n|\n\nChapter 21: Asynchronous Programming\n\nby the supervisor function (shown in Example 21-7) and passed as the semaphore argument to download_one in Example 21-6.\n\nPython’s Semaphores Computer scientist Edsger W. Dijkstra invented the semaphore in the early 1960s. It’s a simple idea, but it’s so flexible that most other synchronization objects—such as locks and barriers—can be built on top of semaphores. There are three Semaphore classes in Python’s standard library: one in threading, another in multiprocessing, and a third one in asyncio. Here we’ll describe the latter.\n\nAn asyncio.Semaphore has an internal counter that is decremented whenever we await on the .acquire() coroutine method, and incremented when we call the .release() method—which is not a coroutine because it never blocks. The initial value of the counter is set when the Semaphore is instantiated:\n\nsemaphore = asyncio.Semaphore(concur_req)\n\nAwaiting on .acquire() causes no delay when the counter is greater than zero, but if the counter is zero, .acquire() suspends the awaiting coroutine until some other coroutine calls .release() on the same Semaphore, thus incrementing the counter. Instead of using those methods directly, it’s safer to use the semaphore as an asyn‐ chronous context manager, as I did in Example 21-6, function download_one:\n\nasync with semaphore: image = await get_flag(client, base_url, cc)\n\nThe Semaphore.__aenter__ coroutine method awaits for .acquire(), and its __aexit__ coroutine method calls .release(). That snippet guarantees that no more than concur_req instances of get_flags coroutines will be active at any time.\n\nEach of the Semaphore classes in the standard library has a BoundedSemaphore subclass that enforces an additional constraint: the internal counter can never there are more .release() become the than .acquire() operations.7\n\nlarger\n\nthan\n\ninitial value when\n\nNow let’s take a look at the rest of the script in Example 21-7.\n\nExample 21-7. flags2_asyncio.py: script continued from Example 21-6\n\nasync def supervisor(cc_list: list[str], base_url: str,\n\n7 Thanks to Guto Maia who noted that the concept of a semaphore was not explained when he read the first\n\nedition draft for this chapter.\n\nEnhancing the asyncio Downloader\n\n|\n\n791\n\nverbose: bool, concur_req: int) -> Counter[DownloadStatus]: counter: Counter[DownloadStatus] = Counter() semaphore = asyncio.Semaphore(concur_req) async with httpx.AsyncClient() as client: to_do = [download_one(client, cc, base_url, semaphore, verbose) for cc in sorted(cc_list)] to_do_iter = asyncio.as_completed(to_do) if not verbose: to_do_iter = tqdm.tqdm(to_do_iter, total=len(cc_list)) error: httpx.HTTPError | None = None for coro in to_do_iter: try: status = await coro except httpx.HTTPStatusError as exc: error_msg = 'HTTP error {resp.status_code} - {resp.reason_phrase}' error_msg = error_msg.format(resp=exc.response) error = exc except httpx.RequestError as exc: error_msg = f'{exc} {type(exc)}'.strip() error = exc except KeyboardInterrupt: break\n\nif error: status = DownloadStatus.ERROR if verbose: url = str(error.request.url) cc = Path(url).stem.upper() print(f'{cc} error: {error_msg}') counter[status] += 1\n\nreturn counter\n\ndef download_many(cc_list: list[str], base_url: str, verbose: bool, concur_req: int) -> Counter[DownloadStatus]: coro = supervisor(cc_list, base_url, verbose, concur_req) counts = asyncio.run(coro)\n\nreturn counts\n\nif __name__ == '__main__': main(download_many, DEFAULT_CONCUR_REQ, MAX_CONCUR_REQ)\n\nsupervisor takes the same arguments as the download_many function, but it can‐ not be invoked directly from main because it’s a coroutine and not a plain func‐ tion like download_many.\n\n792\n\n|\n\nChapter 21: Asynchronous Programming\n\nCreate an asyncio.Semaphore that will not allow more than concur_req active coroutines among those using this semaphore. The value of concur_req is com‐ puted by the main function from flags2_common.py, based on command-line options and constants set in each example.\n\nCreate a list of coroutine objects, one per call to the download_one coroutine.\n\nGet an iterator that will return coroutine objects as they are done. I did not place this call to as_completed directly in the for loop below because I may need to wrap it with the tqdm iterator for the progress bar, depending on the user’s choice for verbosity.\n\nWrap the as_completed iterator with the tqdm generator function to display progress.\n\nDeclare and initialize error with None; this variable will be used to hold an exception beyond the try/except statement, if one is raised.\n\nIterate over the completed coroutine objects; this loop is similar to the one in download_many in Example 20-16.\n\nawait on the coroutine to get its result. This will not block because as_comple ted only produces coroutines that are done.\n\nThis assignment is necessary because the exc variable scope is limited to this except clause, but I need to preserve its value for later.\n\nSame as before.\n\nIf there was an error, set the status.\n\nIn verbose mode, extract the URL from the exception that was raised…\n\n…and extract the name of the file to display the country code next.\n\ndownload_many instantiates the supervisor coroutine object and passes it to the event loop with asyncio.run, collecting the counter supervisor returns when the event loop ends.\n\nIn Example 21-7, we could not use the mapping of futures to country codes we saw in Example 20-16, because the awaitables returned by asyncio.as_completed are the same awaitables we pass into the as_completed call. Internally, the asyncio\n\nEnhancing the asyncio Downloader\n\n|\n\n793\n\nmachinery may replace the awaitables we provide with others that will, in the end, produce the same results.8\n\nBecause I could not use the awaitables as keys to retrieve the coun‐ try code from a dict in case of failure, I had to extract the country code from the exception. To do that, I kept the exception in the error variable to retrieve outside of the try/except statement. Python is not a block-scoped language: statements such as loops and try/except don’t create a local scope in the blocks they man‐ age. But if an except clause binds an exception to a variable, like the exc variables we just saw—that binding only exists within the block inside that particular except clause.\n\nThis wraps up the discussion of an asyncio example functionally equivalent to the flags2_threadpool.py we saw earlier.\n\nThe next example demonstrates the simple pattern of executing one asynchronous task after another using coroutines. This deserves our attention because anyone with previous experience with JavaScript knows that running one asynchronous function after the other was the reason for the nested coding pattern known as pyramid of doom. The await keyword makes that curse go away. That’s why await is now part of Python and JavaScript.\n\nMaking Multiple Requests for Each Download Suppose you want to save each country flag with the name of the country and the country code, instead of just the country code. Now you need to make two HTTP requests per flag: one to get the flag image itself, the other to get the metadata.json file in the same directory as the image—that’s where the name of the country is recorded.\n\nCoordinating multiple requests in the same task is easy in the threaded script: just make one request then the other, blocking the thread twice, and keeping both pieces of data (country code and name) in local variables, ready to use when saving the files. If you needed to do the same in an asynchronous script with callbacks, you needed nested functions so that the country code and name were available in their closures until you could save the file, because each callback runs in a different local scope. The await keyword provides relief from that, allowing you to drive the asynchronous requests one after the other, sharing the local scope of the driving coroutine.\n\n8 A detailed discussion about this can be found in a thread I started in the python-tulip group, titled “Which\n\nother futures may come out of asyncio.as_completed?”. Guido responds, and gives insight on the implemen‐ tation of as_completed, as well as the close relationship between futures and coroutines in asyncio.\n\n794\n\n|\n\nChapter 21: Asynchronous Programming\n\nIf you are doing asynchronous application programming in modern Python with lots of callbacks, you are probably applying old patterns that don’t make sense in modern Python. That is justi‐ fied if you are writing a library that interfaces with legacy or low- support coroutines. Anyway, level code the StackOverflow Q&A, for the use future.add_done_callback()?” explains why callbacks are needed in low-level code, but are not very useful in Python application-level code these days.\n\nthat does not\n\n“What\n\nis\n\ncase\n\nThe third variation of the asyncio flag downloading script has a few changes:\n\nget_country\n\nThis new coroutine fetches the metadata.json file for the country code, and gets the name of the country from it.\n\ndownload_one\n\nThis coroutine now uses await to delegate to get_flag and the new get_country coroutine, using the result of the latter to build the name of the file to save.\n\nLet’s start with the code for get_country (Example 21-8). Note that it is very similar to get_flag from Example 21-6.\n\nExample 21-8. flags3_asyncio.py: get_country coroutine\n\nasync def get_country(client: httpx.AsyncClient, base_url: str, cc: str) -> str: url = f'{base_url}/{cc}/metadata.json'.lower() resp = await client.get(url, timeout=3.1, follow_redirects=True) resp.raise_for_status() metadata = resp.json() return metadata['country']\n\nThis coroutine returns a string with the country name—if all goes well.\n\nmetadata will get a Python dict built from the JSON contents of the response.\n\nReturn the country name.\n\nNow let’s see the modified download_one in Example 21-9, which has only a few lines changed from the same coroutine in Example 21-6.\n\nEnhancing the asyncio Downloader\n\n|\n\n795\n\nExample 21-9. flags3_asyncio.py: download_one coroutine\n\nasync def download_one(client: httpx.AsyncClient, cc: str, base_url: str, semaphore: asyncio.Semaphore, verbose: bool) -> DownloadStatus: try: async with semaphore: image = await get_flag(client, base_url, cc) async with semaphore: country = await get_country(client, base_url, cc) except httpx.HTTPStatusError as exc: res = exc.response if res.status_code == HTTPStatus.NOT_FOUND: status = DownloadStatus.NOT_FOUND msg = f'not found: {res.url}' else: raise else: filename = country.replace(' ', '_') await asyncio.to_thread(save_flag, image, f'{filename}.gif') status = DownloadStatus.OK msg = 'OK' if verbose and msg: print(cc, msg) return status\n\nHold the semaphore to await for get_flag…\n\n…and again for get_country.\n\nUse the country name to create a filename. As a command-line user, I don’t like to see spaces in filenames.\n\nMuch better than nested callbacks!\n\nI put the calls to get_flag and get_country in separate with blocks controlled by the semaphore because it’s good practice to hold semaphores and locks for the shortest possible time.\n\nI could schedule both get_flag and get_country in parallel using asyncio.gather, but if get_flag raises an exception, there is no image to save, so it’s pointless to run get_country. But there are cases where it makes sense to use asyncio.gather to hit several APIs at the same time instead of waiting for one response before making the next request.\n\nIn flags3_asyncio.py, the await syntax appears six times, and async with three times. Hopefully, you should be getting the hang of asynchronous programming in Python.\n\n796\n\n|\n\nChapter 21: Asynchronous Programming\n\nOne challenge is to know when you have to use await and when you can’t use it. The answer in principle is easy: you await coroutines and other awaitables, such as asyn cio.Task instances. But some APIs are tricky, mixing coroutines and plain functions in seemingly arbitrary ways, like the StreamWriter class we’ll use in Example 21-14.\n\nExample 21-9 wrapped up the flags set of examples. Now let’s discuss the use of thread or process executors in asynchronous programming.\n\nDelegating Tasks to Executors One important advantage of Node.js over Python for asynchronous programming is the Node.js standard library, which provides async APIs for all I/O—not just for net‐ work I/O. In Python, if you’re not careful, file I/O can seriously degrade the perfor‐ mance of asynchronous applications, because reading and writing to storage in the main thread blocks the event loop.\n\nIn the download_one coroutine of Example 21-6, I used this line to save the downloa‐ ded image to disk:\n\nawait asyncio.to_thread(save_flag, image, f'{cc}.gif')\n\nAs mentioned before, the asyncio.to_thread was added in Python 3.9. If you need to support 3.7 or 3.8, then replace that single line with the lines in Example 21-10.\n\nExample 21-10. Lines to use instead of await asyncio.to_thread\n\nloop = asyncio.get_running_loop() loop.run_in_executor(None, save_flag, image, f'{cc}.gif')\n\nGet a reference to the event loop.\n\nThe first argument is the executor to use; passing None selects the default Thread PoolExecutor that is always available in the asyncio event loop.\n\nYou can pass positional arguments to the function to run, but if you need to pass keyword arguments, then you need to resort to functool.partial, as described in the run_in_executor documentation.\n\nThe newer asyncio.to_thread function is easier to use and more flexible, as it also accepts keyword arguments.\n\nThe implementation of asyncio itself uses run_in_executor under the hood in a few places. For example, the loop.getaddrinfo(…) coroutine we saw in Example 21-1 is implemented by calling the getaddrinfo function from the socket module—\n\nDelegating Tasks to Executors\n\n|\n\n797\n\nwhich is a blocking function that may take seconds to return, as it depends on DNS resolution.\n\nA common pattern in asynchronous APIs is to wrap blocking calls that are imple‐ mentation details in coroutines using run_in_executor internally. That way, you provide a consistent interface of coroutines to be driven with await, and hide the threads you need to use for pragmatic reasons. The Motor asynchronous driver for MongoDB has an API compatible with async/await that is really a façade around a threaded core that talks to the database server. A. Jesse Jiryu Davis, the lead developer of Motor, explains his reasoning in “Response to ‘Asynchronous Python and Data‐ bases’”. Spoiler: Davis discovered that a thread pool was more performant in the par‐ ticular use case of a database driver—despite the myth that asynchronous approaches are always faster than threads for network I/O.\n\nThe main reason to pass an explict Executor to loop.run_in_executor is to employ a ProcessPoolExecutor if the function to execute is CPU intensive, so that it runs in a different Python process, avoiding contention for the GIL. Because of the high start-up cost, it would be better to start the ProcessPoolExecutor in the supervisor, and pass it to the coroutines that need to use it.\n\nCaleb Hattingh—the author of Using Asyncio in Python (O’ Reilly)—is one of the tech reviewers of this book and suggested I add the following warning about execu‐ tors and asyncio.\n\nCaleb’s Warning about run_in_executors\n\nUsing run_in_executor can produce hard-to-debug problems since cancellation doesn’t work the way one might expect. Corou‐ tines that use executors give merely the pretense of cancellation: the underlying thread (if it’s a ThreadPoolExecutor) has no cancel‐ lation mechanism. For example, a long-lived thread that is created inside a run_in_executor call may prevent your asyncio program from shutting down cleanly: asyncio.run will wait for the executor to fully shut down before returning, and it will wait forever if the executor jobs don’t stop somehow on their own. My greybeard inclination is to want that function to be named run_in_executor_uncancellable.\n\nWe’ll now go from client scripts to writing servers with asyncio.\n\n798\n\n|\n\nChapter 21: Asynchronous Programming\n\nWriting asyncio Servers The classic toy example of a TCP server is an echo server. We’ll build slightly more interesting toys: server-side Unicode character search utilities, first using HTTP with FastAPI, then using plain TCP with asyncio only.\n\nThese servers let users query for Unicode characters based on words in their standard names from the unicodedata module we discussed in “The Unicode Database” on page 150. Figure 21-2 shows a session with web_mojifinder.py, the first server we’ll build.\n\nFigure 21-2. Browser window displaying search results for “mountain” from the web_mojifinder.py service.\n\nThe Unicode search logic in these examples is in the InvertedIndex class in the char‐ index.py module in the Fluent Python code repository. There’s nothing concurrent in that small module, so I’ll only give a brief overview in the optional box that follows. You can skip to the HTTP server implementation in “A FastAPI Web Service” on page 800.\n\nMeet the Inverted Index An inverted index usually maps words to documents in which they occur. In the mojifinder examples, each “document” is one Unicode character. The charin dex.InvertedIndex class indexes each word that appears in each character name in the Unicode database, and creates an inverted index stored in a defaultdict. For example, to index character U+0037—DIGIT SEVEN—the InvertedIndex initializer appends the character '7' to the entries under the keys 'DIGIT' and 'SEVEN'. After indexing the Unicode 13.0.0 data bundled with Python 3.9.1, 'DIGIT' maps to 868 characters, and 'SEVEN' maps to 143, including U+1F556—CLOCK FACE SEVEN\n\nWriting asyncio Servers\n\n|\n\n799\n\nOCLOCK and U+2790—DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT SEVEN (which appears in many code listings in this book).\n\nSee Figure 21-3 for a demonstration using the entries for 'CAT' and 'FACE'.9\n\nFigure 21-3. Python console exploring InvertedIndex attribute entries and search method.\n\nThe InvertedIndex.search method breaks the query into words, and returns the intersection of the entries for each word. That’s why searching for “face” finds 171 results, “cat” finds 14, but “cat face” only 10.\n\nThat’s the beautiful idea behind an inverted index: a fundamental building block in information retrieval—the theory behind search engines. See the English Wikipedia article “Inverted Index” to learn more.\n\nA FastAPI Web Service I wrote the next example—web_mojifinder.py—using FastAPI: one of the Python ASGI Web frameworks mentioned in “ASGI—Asynchronous Server Gateway Inter‐ face” on page 732. Figure 21-2 is a screenshot of the frontend. It’s a super simple SPA (Single Page Application): after the initial HTML download, the UI is updated by client-side JavaScript communicating with the server.\n\nFastAPI is designed to implement backends for SPA and mobile apps, which mostly consist of web API end points returning JSON responses instead of server-rendered HTML. FastAPI leverages decorators, type hints, and code introspection to eliminate a lot of the boilerplate code for web APIs, and also automatically publishes interactive OpenAPI—a.k.a. Swagger—documentation for the APIs we create. Figure 21-4 shows the autogenerated /docs page for web_mojifinder.py.\n\n9 The boxed question mark in the screen shot is not a defect of the book or ebook you are reading. It’s the U\n\n+101EC—PHAISTOS DISC SIGN CAT character, which is missing from the font in the terminal I used. The Phaistos disc is an ancient artifact inscribed with pictograms, discovered in the island of Crete.\n\n800\n\n|\n\nChapter 21: Asynchronous Programming\n\nFigure 21-4. Autogenerated OpenAPI schema for the /search endpoint.\n\nExample 21-11 is the code for web_mojifinder.py, but that’s just the backend code. When you hit the root URL /, the server sends the form.html file, which has 81 lines of code, including 54 lines of JavaScript to communicate with the server and fill a table with the results. If you’re interested in reading plain framework-less JavaScript, please find 21-async/mojifinder/static/form.html in the Fluent Python code repository.\n\nTo run web_mojifinder.py, you need to install two packages and their dependencies: FastAPI and uvicorn.10 This is the command to run Example 21-11 with uvicorn in development mode:\n\n$ uvicorn web_mojifinder:app --reload\n\nThe parameters are:\n\nweb_mojifinder:app\n\nThe package name, a colon, and the name of the ASGI application defined in it— app is the conventional name.\n\n--reload\n\nMake uvicorn monitor changes to application source files and automatically reload them. Useful only during development.\n\nNow let’s study the source code for web_mojifinder.py.\n\n10 Instead of uvicorn, you may use another ASGI server, such as hypercorn or Daphne. See the official ASGI doc‐\n\numentation page about implementations for more information.\n\nWriting asyncio Servers\n\n|\n\n801\n\nExample 21-11. web_mojifinder.py: complete source\n\nfrom pathlib import Path from unicodedata import name\n\nfrom fastapi import FastAPI from fastapi.responses import HTMLResponse from pydantic import BaseModel\n\nfrom charindex import InvertedIndex\n\nSTATIC_PATH = Path(__file__).parent.absolute() / 'static'\n\napp = FastAPI( title='Mojifinder Web', description='Search for Unicode characters by name.', )\n\nclass CharName(BaseModel): char: str name: str\n\ndef init(app): app.state.index = InvertedIndex() app.state.form = (STATIC_PATH / 'form.html').read_text()\n\ninit(app)\n\n@app.get('/search', response_model=list[CharName]) async def search(q: str): chars = sorted(app.state.index.search(q)) return ({'char': c, 'name': name(c)} for c in chars)\n\n@app.get('/', response_class=HTMLResponse, include_in_schema=False) def form(): return app.state.form\n\n# no main funcion\n\nUnrelated to the theme of this chapter, but worth noting: the elegant use of the overloaded / operator by pathlib.11\n\nThis line defines the ASGI app. It could be as simple as app = FastAPI(). The parameters shown are metadata for the autogenerated documentation.\n\n11 Thanks to tech reviewer Miroslav Šedivý for highlighting good places to use pathlib in code examples.\n\n802\n\n|\n\nChapter 21: Asynchronous Programming",
      "page_number": 798
    },
    {
      "number": 41,
      "title": "Segment 41 (pages 819-841)",
      "start_page": 819,
      "end_page": 841,
      "detection_method": "synthetic",
      "content": "A pydantic schema for a JSON response with char and name fields.12\n\nBuild the index and load the static HTML form, attaching both to the app.state for later use.\n\nRun init when this module is loaded by the ASGI server.\n\nRoute for the /search endpoint; response_model uses that CharName pydantic model to describe the response format.\n\nFastAPI assumes that any parameters that appear in the function or coroutine signature that are not in the route path will be passed in the HTTP query string, e.g., /search?q=cat. Since q has no default, FastAPI will return a 422 (Unpro‐ cessable Entity) status if q is missing from the query string.\n\nReturning an iterable of dicts compatible with the response_model schema allows FastAPI to build the JSON response according to the response_model in the @app.get decorator.\n\nRegular functions (i.e., non-async) can also be used to produce responses.\n\nThis module has no main function. It is loaded and driven by the ASGI server— uvicorn in this example.\n\nExample 21-11 has no direct calls to asyncio. FastAPI is built on the Starlette ASGI toolkit, which in turn uses asyncio.\n\nAlso note that the body of search doesn’t use await, async with, or async for, therefore it could be a plain function. I defined search as a coroutine just to show that FastAPI knows how to handle it. In a real app, most endpoints will query data‐ bases or hit other remote servers, so it is a critical advantage of FastAPI—and ASGI frameworks in general—to support coroutines that can take advantage of asynchro‐ nous libraries for network I/O.\n\n12 As mentioned in Chapter 8, pydantic enforces type hints at runtime, for data validation.\n\nWriting asyncio Servers\n\n|\n\n803\n\nThe init and form functions I wrote to load and serve the static HTML form are a hack to make the example short and easy to run. The recommended best practice is to have a proxy/load-balancer in front of the ASGI server to handle all static assets, and also use a CDN (Content Delivery Network) when possible. One such proxy/ load-balancer is Traefik, a self-described “edge router” that “receives requests on behalf of your system and finds out which components are responsible for handling them.” FastAPI has project generation scripts that prepare your code to do that.\n\nThe typing enthusiast may have noticed that there are no return type hints in search and form. Instead, FastAPI relies on the response_model= keyword argument in the route decorators. The “Response Model” page in the FastAPI documentation explains:\n\nThe response model is declared in this parameter instead of as a function return type annotation, because the path function may not actually return that response model but rather return a dict, database object or some other model, and then use the response_model to perform the field limiting and serialization.\n\nFor example, in search, I returned a generator of dict items, not a list of CharName objects, but that’s good enough for FastAPI and pydantic to validate my data and build the appropriate JSON response compatible with response_model=list[Char Name].\n\nWe’ll now focus on the tcp_mojifinder.py script that is answering the queries in Figure 21-5.\n\nAn asyncio TCP Server The tcp_mojifinder.py program uses plain TCP to communicate with a client like Tel‐ net or Netcat, so I could write it using asyncio without external dependencies—and without reinventing HTTP. Figure 21-5 shows text-based UI.\n\n804\n\n|\n\nChapter 21: Asynchronous Programming\n\nFigure 21-5. Telnet session with the tcp_mojifinder.py server: querying for “fire.”\n\nThis program is twice as long as web_mojifinder.py, so I split the presentation into three parts: Example 21-12, Example 21-14, and Example 21-15. The top of tcp_moji‐ finder.py—including the import statements—is in Example 21-14, but I will start by describing the supervisor coroutine and the main function that drives the program.\n\nExample 21-12. tcp_mojifinder.py: a simple TCP server; continues in Example 21-14\n\nasync def supervisor(index: InvertedIndex, host: str, port: int) -> None: server = await asyncio.start_server( functools.partial(finder, index), host, port)\n\nsocket_list = cast(tuple[TransportSocket, ...], server.sockets) addr = socket_list[0].getsockname() print(f'Serving on {addr}. Hit CTRL-C to stop.') await server.serve_forever()\n\ndef main(host: str = '127.0.0.1', port_arg: str = '2323'): port = int(port_arg) print('Building index.') index = InvertedIndex() try: asyncio.run(supervisor(index, host, port)) except KeyboardInterrupt: print('\\nServer shut down.')\n\nif __name__ == '__main__': main(*sys.argv[1:])\n\nWriting asyncio Servers\n\n|\n\n805\n\nThis await quickly gets an instance of asyncio.Server, a TCP socket server. By default, start_server creates and starts the server, so it’s ready to receive connections.\n\nThe first argument to start_server is client_connected_cb, a callback to run when a new client connection starts. The callback can be a function or a corou‐ tine, but it must accept exactly two arguments: an asyncio.StreamReader and an asyncio.StreamWriter. However, my finder coroutine also needs to get an index, so I used functools.partial to bind that parameter and obtain a callable that takes the reader and writer. Adapting user functions to callback APIs is the most common use case for functools.partial.\n\nhost and port are the second and third arguments to start_server. See the full signature in the asyncio documentation.\n\nThis cast is needed because typeshed has an outdated type hint for the sockets property of the Server class—as of May 2021. See Issue #5535 on typeshed.13\n\nDisplay the address and port of the first socket of the server.\n\nAlthough start_server already started the server as a concurrent task, I need to await on the server_forever method so that my supervisor is suspended here. Without this line, supervisor would return immediately, ending the loop started with asyncio.run(supervisor(…)), and exiting the program. The documenta‐ tion for Server.serve_forever says: “This method can be called if the server is already accepting connections.”\n\nBuild the inverted index.14\n\nStart the event loop running supervisor.\n\nCatch the KeyboardInterrupt to avoid a distracting traceback when I stop the server with Ctrl-C on the terminal running it.\n\nYou may find it easier to understand how control flows in tcp_mojifinder.py if you study the output it generates on the server console, listed in Example 21-13.\n\n13 Issue #5535 is closed as of October 2021, but Mypy did not have a new release since then, so the error persists.\n\n14 Tech reviewer Leonardo Rochael pointed out that building the index could be delegated to another thread\n\nusing loop.run_with_executor() in the supervisor coroutine, so the server would be ready to take requests immediately while the index is built. That’s true, but querying the index is the only thing this server does, so it would not be a big win in this example.\n\n806\n\n|\n\nChapter 21: Asynchronous Programming\n\nExample 21-13. tcp_mojifinder.py: this is the server side of the session depicted in Figure 21-5\n\n$ python3 tcp_mojifinder.py Building index. Serving on ('127.0.0.1', 2323). Hit Ctrl-C to stop. From ('127.0.0.1', 58192): 'cat face' To ('127.0.0.1', 58192): 10 results. From ('127.0.0.1', 58192): 'fire' To ('127.0.0.1', 58192): 11 results. From ('127.0.0.1', 58192): '\\x00' Close ('127.0.0.1', 58192). ^C Server shut down. $\n\nOutput by main. Before the next line appears, I see a 0.6s delay on my machine while the index is built.\n\nOutput by supervisor.\n\nFirst iteration of a while loop in finder. The TCP/IP stack assigned port 58192 to my Telnet client. If you connect several clients to the server, you’ll see their various ports in the output.\n\nSecond iteration of the while loop in finder.\n\nI hit Ctrl-C on the client terminal; the while loop in finder exits.\n\nThe finder coroutine displays this message then exits. Meanwhile the server is still running, ready to service another client.\n\nI hit Ctrl-C on the server terminal; server.serve_forever is cancelled, ending supervisor and the event loop.\n\nOutput by main.\n\nAfter main builds the index and starts the event loop, supervisor quickly displays the Serving on… message and is suspended at the await server.serve_forever() line. At that point, control flows into the event loop and stays there, occasionally coming back to the finder coroutine, which yields control back to the event loop whenever it needs to wait for the network to send or receive data.\n\nWhile the event loop is alive, a new instance of the finder coroutine will be started for each client that connects to the server. In this way, many clients can be handled\n\nWriting asyncio Servers\n\n|\n\n807\n\nconcurrently by this simple server. This continues until a KeyboardInterrupt occurs on the server or its process is killed by the OS.\n\nNow let’s see the top of tcp_mojifinder.py, with the finder coroutine.\n\nExample 21-14. tcp_mojifinder.py: continued from Example 21-12\n\nimport asyncio import functools import sys from asyncio.trsock import TransportSocket from typing import cast\n\nfrom charindex import InvertedIndex, format_results\n\nCRLF = b'\\r\\n' PROMPT = b'?> '\n\nasync def finder(index: InvertedIndex, reader: asyncio.StreamReader, writer: asyncio.StreamWriter) -> None: client = writer.get_extra_info('peername') while True: writer.write(PROMPT) # can't await! await writer.drain() # must await! data = await reader.readline() if not data: break try: query = data.decode().strip() except UnicodeDecodeError: query = '\\x00' print(f' From {client}: {query!r}') if query: if ord(query[:1]) < 32: break results = await search(query, index, writer) print(f' To {client}: {results} results.')\n\nwriter.close() await writer.wait_closed() print(f'Close {client}.')\n\n808\n\n|\n\nChapter 21: Asynchronous Programming\n\nformat_results is useful to display the results of InvertedIndex.search in a text-based UI such as the command line or a Telnet session.\n\nTo pass finder to asyncio.start_server, I wrapped it with functools.par tial, because the server expects a coroutine or function that takes only the reader and writer arguments.\n\nGet the remote client address to which the socket is connected.\n\nThis loop handles a dialog that lasts until a control character is received from the client.\n\nThe StreamWriter.write method is not a coroutine, just a plain function; this line sends the ?> prompt.\n\nStreamWriter.drain flushes the writer buffer; it is a coroutine, so it must be driven with await.\n\nStreamWriter.readline is a coroutine that returns bytes.\n\nIf no bytes were received, the client closed the connection, so exit the loop.\n\nDecode the bytes to str, using the default UTF-8 encoding.\n\nA UnicodeDecodeError may happen when the user hits Ctrl-C and the Telnet cli‐ ent sends control bytes; if that happens, replace the query with a null character, for simplicity.\n\nLog the query to the server console.\n\nExit the loop if a control or null character was received.\n\nDo the actual search; code is presented next.\n\nLog the response to the server console.\n\nClose the StreamWriter.\n\nWait for the StreamWriter to close. This is recommended in the .close() method documentation.\n\nLog the end of this client’s session to the server console.\n\nThe last piece of this example is the search coroutine, shown in Example 21-15.\n\nWriting asyncio Servers\n\n|\n\n809\n\nExample 21-15. tcp_mojifinder.py: search coroutine\n\nasync def search(query: str, index: InvertedIndex, writer: asyncio.StreamWriter) -> int: chars = index.search(query) lines = (line.encode() + CRLF for line in format_results(chars)) writer.writelines(lines) await writer.drain() status_line = f'{\"─\" * 66} {len(chars)} found' writer.write(status_line.encode() + CRLF) await writer.drain() return len(chars)\n\nsearch must be a coroutine because it writes to a StreamWriter and must use its .drain() coroutine method.\n\nQuery the inverted index.\n\nThis generator expression will yield byte strings encoded in UTF-8 with the Uni‐ code codepoint, the actual character, its name, and a CRLF sequence—e.g., b'U+0039\\t9\\tDIGIT NINE\\r\\n').\n\nSend the lines. Surprisingly, writer.writelines is not a coroutine.\n\nBut writer.drain() is a coroutine. Don’t forget the await!\n\nBuild a status line, then send it.\n\nNote that all network I/O in tcp_mojifinder.py is in bytes; we need to decode the bytes received from the network, and encode strings before sending them out. In Python 3, the default encoding is UTF-8, and that’s what I used implicitly in all encode and decode calls in this example.\n\nNote that some of the I/O methods are coroutines and must be driven with await, while others are simple functions. For example, StreamWriter.write is a plain function, because it writes to a buffer. On the other hand, StreamWriter.drain—which flushes the buffer and performs the network I/O—is a coroutine, as is StreamReader.readline—but not StreamWriter.writelines! While I was writing the first edition of this book, the asyncio API docs were improved by clearly labeling coroutines as such.\n\n810\n\n|\n\nChapter 21: Asynchronous Programming\n\nThe tcp_mojifinder.py code leverages the high-level asyncio Streams API that pro‐ vides a ready-to-use server so you only need to implement a handler function, which can be a plain callback or a coroutine. There is also a lower-level Transports and Pro‐ tocols API, inspired by the transport and protocols abstractions in the Twisted frame‐ work. Refer to the asyncio documentation for more information, including TCP and UDP echo servers and clients implemented with that lower-level API.\n\nOur next topic is async for and the objects that make it work.\n\nAsynchronous Iteration and Asynchronous Iterables We saw in “Asynchronous Context Managers” on page 786 how async with works with objects implementing the __aenter__ and __aexit__ methods returning await‐ ables—usually in the form of coroutine objects.\n\nSimilarly, async for works with asynchronous iterables: objects that implement __aiter__. However, __aiter__ must be a regular method—not a coroutine method —and it must return an asynchronous iterator.\n\nAn asynchronous iterator provides an __anext__ coroutine method that returns an awaitable—often a coroutine object. They are also expected to implement __aiter__, which usually returns self. This mirrors the important distinction of iterables and iterators we discussed in “Don’t Make the Iterable an Iterator for Itself” on page 605.\n\nThe aiopg asynchronous PostgreSQL driver documentation has an example that illus‐ trates the use of async for to iterate over the rows of a database cursor:\n\nasync def go(): pool = await aiopg.create_pool(dsn) async with pool.acquire() as conn: async with conn.cursor() as cur: await cur.execute(\"SELECT 1\") ret = [] async for row in cur: ret.append(row) assert ret == [(1,)]\n\nIn this example the query will return a single row, but in a realistic scenario you may have thousands of rows in response to a SELECT query. For large responses, the cursor will not be loaded with all the rows in a single batch. Therefore it is important that async for row in cur: does not block the event loop while the cursor may be wait‐ ing for additional rows. By implementing the cursor as an asynchronous iterator, aiopg may yield to the event loop at each __anext__ call, and resume later when more rows arrive from PostgreSQL.\n\nAsynchronous Iteration and Asynchronous Iterables\n\n|\n\n811\n\nAsynchronous Generator Functions You can implement an asynchronous iterator by writing a class with __anext__ and __aiter__, but there is a simpler way: write a function declared with async def and use yield in its body. This parallels how generator functions simplify the classic Iter‐ ator pattern.\n\nLet’s study a simple example using async for and implementing an asynchronous generator. In Example 21-1 we saw blogdom.py, a script that probed domain names. Now suppose we find other uses for the probe coroutine we defined there, and decide to put it into a new module—domainlib.py—together with a new multi_probe asyn‐ chronous generator that takes a list of domain names and yields results as they are probed.\n\nWe’ll look at the implementation of domainlib.py soon, but first let’s see how it is used with Python’s new asynchronous console.\n\nExperimenting with Python’s async console\n\nSince Python 3.8, you can run the interpreter with the -m asyncio command-line option to get an “async REPL”: a Python console that imports asyncio, provides a running event loop, and accepts await, async for, and async with at the top-level prompt—which otherwise are syntax errors when used outside of native coroutines.15\n\nTo experiment with domainlib.py, go to the 21-async/domains/asyncio/ directory in your local copy of the Fluent Python code repository. Then run:\n\n$ python -m asyncio\n\nYou’ll see the console start, similar to this:\n\nasyncio REPL 3.9.1 (v3.9.1:1e5d33e9b9, Dec 7 2020, 12:10:52) [Clang 6.0 (clang-600.0.57)] on darwin Use \"await\" directly instead of \"asyncio.run()\". Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import asyncio >>>\n\nNote how the header says you can use await instead of asyncio.run()—to drive coroutines and other awaitables. Also: I did not type import asyncio. The asyncio module is automatically imported and that line makes that fact clear to the user.\n\n15 This is great for experimentation, like the Node.js console. Thanks to Yury Selivanov for yet another excellent\n\ncontribution to asynchronous Python.\n\n812\n\n|\n\nChapter 21: Asynchronous Programming\n\nNow let’s import domainlib.py and play with its two coroutines: probe and multi_probe (Example 21-16).\n\nExample 21-16. Experimenting with domainlib.py after running python3 -m asyncio\n\n>>> await asyncio.sleep(3, 'Rise and shine!') 'Rise and shine!' >>> from domainlib import * >>> await probe('python.org') Result(domain='python.org', found=True) >>> names = 'python.org rust-lang.org golang.org no-lang.invalid'.split() >>> async for result in multi_probe(names): ... print(*result, sep='\\t') ... golang.org True no-lang.invalid False python.org True rust-lang.org True >>>\n\nTry a simple await to see the asynchronous console in action. Tip: asyn cio.sleep() takes an optional second argument that is returned when you await it.\n\nDrive the probe coroutine.\n\nThe domainlib version of probe returns a Result named tuple.\n\nMake a list of domains. The .invalid top-level domain is reserved for testing. DNS queries for such domains always get an NXDOMAIN response from DNS servers, meaning “that domain does not exist.”16\n\nIterate with async for over the multi_probe asynchronous generator to display the results.\n\nNote that the results are not in the order the domains were given to multiprobe. They appear as each DNS response comes back.\n\nExample 21-16 shows that multi_probe is an asynchronous generator because it is compatible with async for. Now let’s do a few more experiments, continuing from that example with Example 21-17.\n\n16 See RFC 6761—Special-Use Domain Names.\n\nAsynchronous Iteration and Asynchronous Iterables\n\n|\n\n813\n\nExample 21-17. More experiments, continuing from Example 21-16\n\n>>> probe('python.org') <coroutine object probe at 0x10e313740> >>> multi_probe(names) <async_generator object multi_probe at 0x10e246b80> >>> for r in multi_probe(names): ... print(r) ... Traceback (most recent call last): ... TypeError: 'async_generator' object is not iterable\n\nCalling a native coroutine gives you a coroutine object.\n\nCalling an asynchronous generator gives you an async_generator object.\n\nWe can’t use a regular for loop with asynchronous generators because they implement __aiter__ instead of __iter__.\n\nAsynchronous generators are driven by async for, which can be a block statement (as seen in Example 21-16), and it also appears in asynchronous comprehensions, which we’ll cover soon.\n\nImplementing an asynchronous generator\n\nNow let’s study the code for domainlib.py, with the multi_probe asynchronous gen‐ erator (Example 21-18).\n\nExample 21-18. domainlib.py: functions for probing domains\n\nimport asyncio import socket from collections.abc import Iterable, AsyncIterator from typing import NamedTuple, Optional\n\nclass Result(NamedTuple): domain: str found: bool\n\nOptionalLoop = Optional[asyncio.AbstractEventLoop]\n\nasync def probe(domain: str, loop: OptionalLoop = None) -> Result: if loop is None: loop = asyncio.get_running_loop() try:\n\n814\n\n|\n\nChapter 21: Asynchronous Programming\n\nawait loop.getaddrinfo(domain, None) except socket.gaierror: return Result(domain, False) return Result(domain, True)\n\nasync def multi_probe(domains: Iterable[str]) -> AsyncIterator[Result]: loop = asyncio.get_running_loop() coros = [probe(domain, loop) for domain in domains] for coro in asyncio.as_completed(coros): result = await coro yield result\n\nNamedTuple makes the result from probe easier to read and debug.\n\nThis type alias is to avoid making the next line too long for a book listing.\n\nprobe now gets an optional loop argument, to avoid repeated calls to get_run ning_loop when this coroutine is driven by multi_probe.\n\nAn asynchronous generator function produces an asynchronous generator object, which can be annotated as AsyncIterator[SomeType].\n\nBuild list of probe coroutine objects, each with a different domain.\n\nThis is not async for because asyncio.as_completed is a classic generator.\n\nAwait on the coroutine object to retrieve the result.\n\nYield result. This line makes multi_probe an asynchronous generator.\n\nThe for loop in Example 21-18 could be more concise: for coro in asyncio.as_completed(coros): yield await coro\n\nPython parses that as yield (await coro), so it works.\n\nI thought it could be confusing to use that shortcut in the first asynchronous generator example in the book, so I split it into two lines.\n\nGiven domainlib.py, we can demonstrate the use of the multi_probe asynchronous generator in domaincheck.py: a script that takes a domain suffix and searches for domains made from short Python keywords.\n\nHere is a sample output of domaincheck.py:\n\nAsynchronous Iteration and Asynchronous Iterables\n\n|\n\n815\n\n$ ./domaincheck.py net FOUND NOT FOUND ===== ========= in.net del.net true.net for.net is.net none.net try.net from.net and.net or.net else.net with.net if.net as.net elif.net pass.net not.net def.net\n\nThanks to domainlib, the code for domaincheck.py is straightforward, as seen in Example 21-19.\n\nExample 21-19. domaincheck.py: utility for probing domains using domainlib\n\n#!/usr/bin/env python3 import asyncio import sys from keyword import kwlist\n\nfrom domainlib import multi_probe\n\nasync def main(tld: str) -> None: tld = tld.strip('.') names = (kw for kw in kwlist if len(kw) <= 4) domains = (f'{name}.{tld}'.lower() for name in names) print('FOUND\\t\\tNOT FOUND') print('=====\\t\\t=========') async for domain, found in multi_probe(domains): indent = '' if found else '\\t\\t' print(f'{indent}{domain}')\n\nif __name__ == '__main__': if len(sys.argv) == 2: asyncio.run(main(sys.argv[1])) else: print('Please provide a TLD.', f'Example: {sys.argv[0]} COM.BR')\n\n816\n\n|\n\nChapter 21: Asynchronous Programming\n\nGenerate keywords with length up to 4.\n\nGenerate domain names with the given suffix as TLD.\n\nFormat a header for the tabular output.\n\nAsynchronously iterate over multi_probe(domains).\n\nSet indent to zero or two tabs to put the result in the proper column.\n\nRun the main coroutine with the given command-line argument.\n\nGenerators have one extra use unrelated to iteration: they can be made into context managers. This also applies to asynchronous generators.\n\nAsynchronous generators as context managers\n\nWriting our own asynchronous context managers is not a frequent programming task, but if you need to write one, consider using the @asynccontextmanager decora‐ tor added to the contextlib module in Python 3.7. That’s very similar to the @con textmanager decorator we studied in “Using @contextmanager” on page 664.\n\nAn interesting example combining @asynccontextmanager with loop.run_in_execu tor appears in Caleb Hattingh’s book Using Asyncio in Python. Example 21-20 is Caleb’s code—with a single change and added callouts.\n\nExample 21-20. Example using @asynccontextmanager and loop.run_in_executor\n\nfrom contextlib import asynccontextmanager\n\n@asynccontextmanager async def web_page(url): loop = asyncio.get_running_loop() data = await loop.run_in_executor( None, download_webpage, url) yield data await loop.run_in_executor(None, update_stats, url)\n\nasync with web_page('google.com') as data: process(data)\n\nThe decorated function must be an asynchronous generator.\n\nMinor update to Caleb’s code: use the lightweight get_running_loop instead of get_event_loop.\n\nAsynchronous Iteration and Asynchronous Iterables\n\n|\n\n817\n\nSuppose download_webpage is a blocking function using the requests library; we run it in a separate thread to avoid blocking the event loop.\n\nAll lines before this yield expression will become the __aenter__ coroutine- method of the asynchronous context manager built by the decorator. The value of data will be bound to the data variable after the as clause in the async with statement below.\n\nLines after the yield will become the __aexit__ coroutine method. Here, another blocking call is delegated to the thread executor.\n\nUse web_page with async with.\n\nThis is very similar to the sequential @contextmanager decorator. Please see “Using @contextmanager” on page 664 for more details, including error handling at the yield line. For another example of @asynccontextmanager, see the contextlib doc‐ umentation.\n\nNow let’s wrap up our coverage of asynchronous generator functions by contrasting them with native coroutines.\n\nAsynchronous generators versus native coroutines\n\nHere are some key similarities and differences between a native coroutine and an asynchronous generator function:\n\nBoth are declared with async def. • An asynchronous generator always has a yield expression in its body—that’s what makes it a generator. A native coroutine never contains yield.\n\nA native coroutine may return some value other than None. An asynchronous generator can only use empty return statements.\n\nNative coroutines are awaitable: they can be driven by await expressions or passed to one of the many asyncio functions that take awaitable arguments, such as create_task. Asynchronous generators are not awaitable. They are asynchro‐ nous iterables, driven by async for or by asynchronous comprehensions.\n\nTime to talk about asynchronous comprehensions.\n\nAsync Comprehensions and Async Generator Expressions PEP 530—Asynchronous Comprehensions introduced the use of async for and await in the syntax of comprehensions and generator expressions, starting with Python 3.6.\n\n818\n\n|\n\nChapter 21: Asynchronous Programming\n\nThe only construct defined by PEP 530 that can appear outside an async def body is an asynchronous generator expression.\n\nDefining and using an asynchronous generator expression\n\nGiven the multi_probe asynchronous generator from Example 21-18, we could write another asynchronous generator returning only the names of the domains found. Here is how—again using the asynchronous console launched with -m asyncio:\n\n>>> from domainlib import multi_probe >>> names = 'python.org rust-lang.org golang.org no-lang.invalid'.split() >>> gen_found = (name async for name, found in multi_probe(names) if found) >>> gen_found <async_generator object <genexpr> at 0x10a8f9700> >>> async for name in gen_found: ... print(name) ... golang.org python.org rust-lang.org\n\nThe use of async for makes this an asynchronous generator expression. It can be defined anywhere in a Python module.\n\nThe asynchronous generator expression builds an async_generator object— exactly the same type of object returned by an asynchronous generator function like multi_probe.\n\nThe asynchronous generator object is driven by the async for statement, which in turn can only appear inside an async def body or in the magic asynchronous console I used in this example.\n\nTo summarize: an asynchronous generator expression can be defined anywhere in your program, but it can only be consumed inside a native coroutine or asynchro‐ nous generator function.\n\nThe remaining constructs introduced by PEP 530 can only be defined and used inside native coroutines or asynchronous generator functions.\n\nAsynchronous comprehensions\n\nYury Selivanov—the author of PEP 530—justifies the need for asynchronous com‐ prehensions with three short code snippets reproduced next.\n\nWe can all agree that we should be able to rewrite this code:\n\nresult = [] async for i in aiter():\n\nAsynchronous Iteration and Asynchronous Iterables\n\n|\n\n819\n\nif i % 2: result.append(i)\n\nlike this:\n\nresult = [i async for i in aiter() if i % 2]\n\nIn addition, given a native coroutine fun, we should be able to write this:\n\nresult = [await fun() for fun in funcs]\n\nUsing await in a list comprehension is similar to using asyn cio.gather. But gather gives you more control over exception handling, thanks to its optional return_exceptions argument. Caleb Hattingh recommends always setting return_excep tions=True (the default is False). Please see the asyncio.gather documentation for more.\n\nBack to the magic asynchronous console:\n\n>>> names = 'python.org rust-lang.org golang.org no-lang.invalid'.split() >>> names = sorted(names) >>> coros = [probe(name) for name in names] >>> await asyncio.gather(*coros) [Result(domain='golang.org', found=True), Result(domain='no-lang.invalid', found=False), Result(domain='python.org', found=True), Result(domain='rust-lang.org', found=True)] >>> [await probe(name) for name in names] [Result(domain='golang.org', found=True), Result(domain='no-lang.invalid', found=False), Result(domain='python.org', found=True), Result(domain='rust-lang.org', found=True)] >>>\n\nNote that I sorted the list of names to show that the results come out in the order they were submitted, in both cases.\n\nPEP 530 allows the use of async for and await in list comprehensions as well as in dict and set comprehensions. For example, here is a dict comprehension to store the results of multi_probe in the asynchronous console:\n\n>>> {name: found async for name, found in multi_probe(names)} {'golang.org': True, 'python.org': True, 'no-lang.invalid': False, 'rust-lang.org': True}\n\nWe can use the await keyword in the expression before the for or async for clause, and also in the expression after the if clause. Here is a set comprehension in the asynchronous console, collecting only the domains that were found:\n\n>>> {name for name in names if (await probe(name)).found} {'rust-lang.org', 'python.org', 'golang.org'}\n\n820\n\n|\n\nChapter 21: Asynchronous Programming\n\nI had to put extra parentheses around the await expression due to the higher prece‐ dence of the __getattr__ operator . (dot).\n\nAgain, all of these comprehensions can only appear inside an async def body or in the enchanted asynchronous console.\n\nNow let’s talk about a very important feature of the async statements, async expres‐ sions, and the objects they create. Those constructs are often used with asyncio but, they are actually library independent.\n\nasync Beyond asyncio: Curio Python’s async/await language constructs are not tied to any specific event loop or library.17 Thanks to the extensible API provided by special methods, anyone suffi‐ ciently motivated can write their own asynchronous runtime environment and framework to drive native coroutines, asynchronous generators, etc.\n\nThat’s what David Beazley did in his Curio project. He was interested in rethinking how these new language features could be used in a framework built from scratch. Recall that asyncio was released in Python 3.4, and it used yield from instead of await, so its API could not leverage asynchronous context managers, asynchronous iterators, and everything else that the async/await keywords made possible. As a result, Curio has a cleaner API and a simpler implementation, compared to asyncio.\n\nExample 21-21 shows the blogdom.py script (Example 21-1) rewritten to use Curio.\n\nExample 21-21. blogdom.py: Example 21-1, now using Curio\n\n#!/usr/bin/env python3 from curio import run, TaskGroup import curio.socket as socket from keyword import kwlist\n\nMAX_KEYWORD_LEN = 4\n\nasync def probe(domain: str) -> tuple[str, bool]: try: await socket.getaddrinfo(domain, None) except socket.gaierror: return (domain, False) return (domain, True)\n\n17 That’s in contrast with JavaScript, where async/await is hardwired to the built-in event loop and runtime\n\nenvironment, i.e., a browser, Node.js, or Deno.\n\nasync Beyond asyncio: Curio\n\n|\n\n821\n\nasync def main() -> None: names = (kw for kw in kwlist if len(kw) <= MAX_KEYWORD_LEN) domains = (f'{name}.dev'.lower() for name in names) async with TaskGroup() as group: for domain in domains: await group.spawn(probe, domain) async for task in group: domain, found = task.result mark = '+' if found else ' ' print(f'{mark} {domain}')\n\nif __name__ == '__main__': run(main())\n\nprobe doesn’t need to get the event loop, because…\n\n…getaddrinfo is a top-level function of curio.socket, not a method of a loop object—as it is in asyncio.\n\nA TaskGroup is a core concept in Curio, to monitor and control several corou‐ tines, and to make sure they are all executed and cleaned up.\n\nTaskGroup.spawn is how you start a coroutine, managed by a specific TaskGroup instance. The coroutine is wrapped by a Task.\n\nIterating with async for over a TaskGroup yields Task instances as each is completed. This corresponds in Example 21-1 using for … as_completed(…):.\n\nto\n\nthe\n\nline\n\nCurio pioneered this sensible way to start an asynchronous program in Python.\n\nTo expand on the last point: if you look at the asyncio code examples for the first edition of Fluent Python, you’ll see lines like these, repeated over and over:\n\nloop = asyncio.get_event_loop() loop.run_until_complete(main()) loop.close()\n\nA Curio TaskGroup is an asynchronous context manager that replaces several ad hoc APIs and coding patterns in asyncio. We just saw how iterating over a TaskGroup makes the asyncio.as_completed(…) function unnecessary. Another example: instead of a special gather function, this snippet from the “Task Groups” docs col‐ lects the results of all tasks in the group:\n\nasync with TaskGroup(wait=all) as g: await g.spawn(coro1) await g.spawn(coro2)\n\n822\n\n|\n\nChapter 21: Asynchronous Programming\n\nawait g.spawn(coro3) print('Results:', g.results)\n\nTask groups support structured concurrency: a form of concurrent programming that constrains all the activity of a group of asynchronous tasks to a single entry and exit point. This is analogous to structured programming, which eschewed the GOTO com‐ mand and introduced block statements to limit the entry and exit points of loops and subroutines. When used as an asynchronous context manager, a TaskGroup ensures that all tasks spawned inside are completed or cancelled, and any exceptions raised, upon exiting the enclosed block.\n\nStructured concurrency will probably be adopted by asyncio in upcoming Python releases. A strong indication appears in PEP 654–Exception Groups and except*, which was approved for Python 3.11. The “Motivation” section mentions Trio’s “nurseries,” their name for task groups: “Implementing a better task spawning API in asyncio, inspired by Trio nurseries, was the main motiva‐ tion for this PEP.”\n\nAnother important feature of Curio is better support for programming with corou‐ tines and threads in the same codebase—a necessity in most nontrivial asynchronous programs. Starting a thread with await spawn_thread(func, …) returns an Asyn cThread object with a Task-like interface. Threads can call coroutines thanks to a special AWAIT(coro) function—named in all caps because await is now a keyword.\n\nCurio also provides a UniversalQueue that can be used to coordinate the work among threads, Curio coroutines, and asyncio coroutines. That’s right, Curio has features that allow it to run in a thread along with asyncio in another thread, in the same process, communicating via UniversalQueue and UniversalEvent. The API for these “universal” classes is the same inside and outside of coroutines, but in a corou‐ tine, you need to prefix calls with await.\n\nAs I write this in October 2021, HTTPX is the first HTTP client library compatible with Curio, but I don’t know of any asynchronous database libraries that support it yet. In the Curio repository there is an impressive set of network programming exam‐ ples, including one using WebSocket, and another implementing the RFC 8305— Happy Eyeballs concurrent algorithm for connecting to IPv6 endpoints with fast fall‐ back to IPv4 if needed.\n\nThe design of Curio has been influential. The Trio framework started by Nathaniel J. Smith was heavily inspired by Curio. Curio may also have prompted Python contrib‐ utors to improve the usability of the asyncio API. For example, in its earliest releases, asyncio users very often had to get and pass around a loop object because some essential functions were either loop methods or required a loop argument. In recent\n\nasync Beyond asyncio: Curio\n\n|\n\n823\n\nversions of Python, direct access to the loop is not needed as often, and in fact several functions that accepted an optional loop are now deprecating that argument.\n\nType annotations for asynchronous types are our next topic.\n\nType Hinting Asynchronous Objects The return type of a native coroutine describes what you get when you await on that coroutine, which is the type of the object that appears in the return statements in the body of the native coroutine function.18\n\nThis chapter provided many examples of annotated native coroutines, including probe from Example 21-21:\n\nasync def probe(domain: str) -> tuple[str, bool]: try: await socket.getaddrinfo(domain, None) except socket.gaierror: return (domain, False) return (domain, True)\n\nIf you need to annotate a parameter that takes a coroutine object, then the generic type is:\n\nclass typing.Coroutine(Awaitable[V_co], Generic[T_co, T_contra, V_co]): ...\n\nThat type, and the following types were introduced in Python 3.5 and 3.6 to annotate asynchronous objects:\n\nclass typing.AsyncContextManager(Generic[T_co]): ... class typing.AsyncIterable(Generic[T_co]): ... class typing.AsyncIterator(AsyncIterable[T_co]): ... class typing.AsyncGenerator(AsyncIterator[T_co], Generic[T_co, T_contra]): ... class typing.Awaitable(Generic[T_co]): ...\n\nWith Python ≥ 3.9, use the collections.abc equivalents of these.\n\nI want to highlight three aspects of those generic types.\n\nFirst: they are all covariant on the first type parameter, which is the type of the items yielded from these objects. Recall rule #1 of “Variance rules of thumb” on page 551:\n\n18 This differs from the annotations of classic coroutines, as discussed in “Generic Type Hints for Classic\n\nCoroutines” on page 650.\n\n824\n\n|\n\nChapter 21: Asynchronous Programming\n\nIf a formal type parameter defines a type for data that comes out of the object, it can be covariant.\n\nSecond: AsyncGenerator and Coroutine are contravariant on the second to last parameter. That’s the type of the argument of the low-level .send() method that the event loop calls to drive asynchronous generators and coroutines. As such, it is an “input” type. Therefore, it can be contravariant, per Variance Rule of Thumb #2:\n\nIf a formal type parameter defines a type for data that goes into the object after its ini‐ tial construction, it can be contravariant.\n\nThird: AsyncGenerator has no return type, in contrast with typing.Generator, which we saw in “Generic Type Hints for Classic Coroutines” on page 650. Returning a value by raising StopIteration(value) was one of the hacks that enabled genera‐ tors to operate as coroutines and support yield from, as we saw in “Classic Corou‐ tines” on page 641. There is no such overlap among the asynchronous objects: AsyncGenerator objects don’t return values, and are completely separate from native coroutine objects, which are annotated with typing.Coroutine.\n\nFinally, let’s briefly discuss the advantages and challenges of asynchronous programming.\n\nHow Async Works and How It Doesn’t The sections closing this chapter discuss high-level ideas around asynchronous pro‐ gramming, regardless of the language or library you are using.\n\nLet’s begin by explaining the #1 reason why asynchronous programming is appealing, followed by a popular myth, and how to deal with it.\n\nRunning Circles Around Blocking Calls Ryan Dahl, the inventor of Node.js, introduces the philosophy of his project by say‐ ing “We’re doing I/O completely wrong.”19 He defines a blocking function as one that does file or network I/O, and argues that we can’t treat them as we treat nonblocking functions. To explain why, he presents the numbers in the second column of Table 21-1.\n\n19 Video: “Introduction to Node.js” at 4:55.\n\nHow Async Works and How It Doesn’t\n\n|\n\n825",
      "page_number": 819
    },
    {
      "number": 42,
      "title": "Segment 42 (pages 842-863)",
      "start_page": 842,
      "end_page": 863,
      "detection_method": "synthetic",
      "content": "Table 21-1. Modern computer latency for reading data from different devices; third column shows proportional times in a scale easier to understand for us slow humans\n\nDevice L1 cache\n\nCPU cycles 3\n\nProportional “human” scale 3 seconds\n\nL2 cache\n\n14\n\n14 seconds\n\nRAM\n\n250\n\n250 seconds\n\ndisk\n\n41,000,000\n\n1.3 years\n\nnetwork\n\n240,000,000\n\n7.6 years\n\nTo make sense of Table 21-1, bear in mind that modern CPUs with GHz clocks run billions of cycles per second. Let’s say that a CPU runs exactly 1 billion cycles per sec‐ ond. That CPU can make more than 333 million L1 cache reads in 1 second, or 4 (four!) network reads in the same time. The third column of Table 21-1 puts those numbers in perspective by multiplying the second column by a constant factor. So, in an alternate universe, if one read from L1 cache took 3 seconds, then a network read would take 7.6 years!\n\nTable 21-1 explains why a disciplined approach to asynchronous programming can lead to high-performance servers. The challenge is achieving that discipline. The first step is to recognize that “I/O bound system” is a fantasy.\n\nThe Myth of I/O-Bound Systems A commonly repeated meme is that asynchronous programming is good for “I/O bound systems.” I learned the hard way that there are no “I/O-bound systems.” You may have I/O-bound functions. Perhaps the vast majority of the functions in your system are I/O bound; i.e., they spend more time waiting for I/O than crunching data. While waiting, they cede control to the event loop, which can then drive some other pending task. But inevitably, any nontrivial system will have some parts that are CPU bound. Even trivial systems reveal that, under stress. In “Soapbox” on page 829, I tell the story of two asynchronous programs that struggled with CPU-bound func‐ tions slowing down the event loop with severe impact on performance.\n\nGiven that any nontrivial system will have CPU-bound functions, dealing with them is the key to success in asynchronous programming.\n\nAvoiding CPU-Bound Traps If you’re using Python at scale, you should have some automated tests designed specifically to detect performance regressions as soon as they appear. This is critically important with asynchronous code, but also relevant to threaded Python code— because of the GIL. If you wait until the slowdown starts bothering the development team, it’s too late. The fix will probably require some major makeover.\n\n826\n\n|\n\nChapter 21: Asynchronous Programming\n\nHere are some options for when you identify a CPU-hogging bottleneck:\n\nDelegate the task to a Python process pool.\n\nDelegate the task to an external task queue.\n\nRewrite the relevant code in Cython, C, Rust, or some other language that com‐ piles to machine code and interfaces with the Python/C API, preferably releasing the GIL.\n\nDecide that you can afford the performance hit and do nothing—but record the decision to make it easier to revert to it later.\n\nThe external task queue should be chosen and integrated as soon as possible at the start of the project, so that nobody in the team hesitates to use it when needed.\n\nThe last option—do nothing—falls in the category of technical debt.\n\nConcurrent programming is a fascinating topic, and I would like to write a lot more about it. But it is not the main focus of this book, and this is already one of the longest chapters, so let’s wrap it up.\n\nChapter Summary\n\nThe problem with normal approaches to asynchronous programming is that they’re all-or-nothing propositions. You rewrite all your code so none of it blocks or you’re just wasting your time.\n\n—Alvaro Videla and Jason J. W. Williams, RabbitMQ in Action\n\nI chose that epigraph for this chapter for two reasons. At a high level, it reminds us to avoid blocking the event loop by delegating slow tasks to a different processing unit, from a simple thread all the way to a distributed task queue. At a lower level, it is also a warning: once you write your first async def, your program is inevitably going to have more and more async def, await, async with, and async for. And using non- asynchronous libraries suddenly becomes a challenge.\n\nAfter the simple spinner examples in Chapter 19, here our main focus was asynchro‐ nous programming with native coroutines, starting with the blogdom.py DNS prob‐ ing example, followed by the concept of awaitables. While reading the source code of flags_asyncio.py, we found the first example of an asynchronous context manager.\n\nThe more advanced variations of the flag downloading program introduced two powerful functions: the asyncio.as_completed generator and the loop.run_in_exec utor coroutine. We also saw the concept and application of a semaphore to limit the number of concurrent downloads—as expected from well-behaved HTTP clients.\n\nChapter Summary\n\n|\n\n827\n\nServer-side asynchronous programming was presented through the mojifinder exam‐ ples: a FastAPI web service and tcp_mojifinder.py—the latter using just asyncio and the TCP protocol.\n\nAsynchronous iteration and asynchronous iterables were the next major topic, with sections on async for, Python’s async console, asynchronous generators, asynchro‐ nous generator expressions, and asynchronous comprehensions.\n\nThe last example in the chapter was blogdom.py rewritten with the Curio framework, to demonstrate how Python’s asynchronous features are not tied to the asyncio package. Curio also showcases the concept of structured concurrency, which may have an industry-wide impact, bringing more clarity to concurrent code.\n\nFinally, the sections under “How Async Works and How It Doesn’t” on page 825 discuss the main appeal of asynchronous programming, the misconception of “I/O- bound systems,” and dealing with the inevitable CPU-bound parts of your program.\n\nFurther Reading David Beazley’s PyOhio 2016 keynote “Fear and Awaiting in Async” is a fantastic, live-coded introduction to the potential of the language features made possible by Yury Selivanov’s contribution of the async/await keywords in Python 3.5. At one point, Beazley complains that await can’t be used in list comprehensions, but that was fixed by Selivanov in PEP 530—Asynchronous Comprehensions, implemented in Python 3.6 later in that same year. Apart from that, everything else in Beazley’s keynote is timeless, as he demonstrates how the asynchronous objects we saw in this chapter work, without the help of any framework—just a simple run function using .send(None) to drive coroutines. Only at the very end Beazley shows Curio, which he started that year as an experiment to see how far can you go doing asyn‐ chronous programming without a foundation of callbacks or futures, just coroutines. As it turns out, you can go very far—as demonstrated by the evolution of Curio and the later creation of Trio by Nathaniel J. Smith. Curio’s documentation has links to more talks by Beazley on the subject.\n\nBesides starting Trio, Nathaniel J. Smith wrote two deep blog posts that I highly rec‐ ommend: “Some thoughts on asynchronous API design in a post-async/await world”, contrasting the design of Curio with that of asyncio,and “Notes on structured concur‐ rency, or: Go statement considered harmful”, about structured concurrency. Smith also gave a long and informative answer to the question: “What is the core difference between asyncio and trio?” on StackOverflow.\n\nTo learn more about the asyncio package, I’ve mentioned the best written resources I know at the start of this chapter: the official documentation after the outstanding overhaul started by Yury Selivanov in 2018, and Caleb Hattingh’s book Using Asyncio in Python (O’Reilly). In the official documentation, make sure to read “Developing\n\n828\n\n|\n\nChapter 21: Asynchronous Programming\n\nwith asyncio”: documenting the asyncio debug mode, and also discussing common mistakes and traps and how to avoid them.\n\nFor a very accessible, 30-minute introduction to asynchronous programming in gen‐ eral and also asyncio, watch Miguel Grinberg’s “Asynchronous Python for the Com‐ plete Beginner”, presented at PyCon 2017. Another great is “Demystifying Python’s Async and Await Keywords”, presented by Michael Ken‐ nedy, where among other things I learned about the unsync library that provides a decorator to delegate the execution of coroutines, I/O-bound functions, and CPU- bound functions to asyncio, threading, or multiprocessing as needed.\n\nintroduction\n\nAt EuroPython 2019, Lynn Root—a global leader of PyLadies—presented the excel‐ lent “Advanced asyncio: Solving Real-world Production Problems”, informed by her experience using Python as a staff engineer at Spotify.\n\nIn 2020, Łukasz Langa recorded a series of great videos about asyncio, starting with “Learn Python’s AsyncIO #1—The Async Ecosystem”. Langa also made the super cool video “AsyncIO + Music” for PyCon 2020 that not only shows asyncio applied in a very concrete event-oriented domain, but also explains it from the ground up.\n\nAnother area dominated by event-oriented programming is embedded systems. That’s why Damien George added support for async/await in his MicroPython inter‐ preter for microcontrollers. At PyCon Australia 2018, Matt Trentini demonstrated the uasyncio library, a subset of asyncio that is part of MicroPython’s standard library.\n\nFor higher-level thinking about async programming in Python, read the blog post “Python async frameworks—Beyond developer tribalism” by Tom Christie.\n\nFinally, I recommend “What Color Is Your Function?” by Bob Nystrom, discussing the incompatible execution models of plain functions versus async functions—a.k.a. coroutines—in JavaScript, Python, C#, and other languages. Spoiler alert: Nystrom’s conclusion is that the language that got this right is Go, where all functions are the same color. I like that about Go. But I also think Nathaniel J. Smith has a point when he wrote “Go statement considered harmful”. Nothing is perfect, and concurrent programming is always hard.\n\nSoapbox\n\nHow a Slow Function Almost Spoiled the uvloop Benchmarks\n\nIn 2016, Yury Selivanov released uvloop, “a fast, drop-in replacement of the built-in asyncio event loop.” The benchmarks presented in Selivanov’s blog post announcing the library in 2016 are very impressive. He wrote: “it is at least 2x faster than nodejs, gevent, as well as any other Python asynchronous framework. The performance of uvloop-based asyncio is close to that of Go programs.”\n\nFurther Reading\n\n|\n\n829\n\nHowever, the post reveals that uvloop is able to match the performance of Go under two conditions:\n\n1. Go is configured to use a single thread. That makes the Go runtime behave simi‐ larly to asyncio: concurrency is achieved via multiple coroutines driven by an event loop, all in the same thread.20\n\n2. The Python 3.5 code uses httptools in addition to uvloop itself.\n\nSelivanov explains that he wrote httptools after benchmarking uvloop with aiohttp— one of the first full-featured HTTP libraries built on asyncio:\n\nHowever, the performance bottleneck in aiohttp turned out to be its HTTP parser, which is so slow, that it matters very little how fast the underlying I/O library is. To make things more interesting, we created a Python binding for http-parser (Node.js HTTP parser C library, originally developed for NGINX). The library is called httptools, and is available on Github and PyPI.\n\nNow think about that: Selivanov’s HTTP performance tests consisted of a simple echo server written in the different languages/libraries, pounded by the wrk bench‐ marking tool. Most developers would consider a simple echo server an “I/O-bound system,” right? But it turned out that parsing HTTP headers is CPU bound, and it had a slow Python implementation in aiohttp in when Selivanov did the benchmarks in 2016. Whenever a function written in Python was parsing headers, the event loop was blocked. The impact was so significant that Selivanov went to the extra trouble of writing httptools. Without optimizing the CPU-bound code, the performance gains of a faster event loop were lost.\n\nDeath by a Thousand Cuts\n\nInstead of a simple echo server, imagine a complex and evolving Python system with tens of thousands of lines of asynchronous code, interfacing with many external libra‐ ries. Years ago I was asked to help diagnose performance problems in a system like that. It was written in Python 2.7 with the Twisted framework—a solid library and in many ways a precursor to asyncio itself.\n\nPython was used to build a façade for the web UI, integrating functionality provided by preexisting libraries and command-line tools written in other languages—but not designed for concurrent execution.\n\n20 Using a single thread was the default setting until Go 1.5 was released. Years before, Go had already earned a well-deserved reputation for enabling highly concurrent networked systems. One more evidence that concur‐ rency doesn’t require multiple threads or CPU cores.\n\n830\n\n|\n\nChapter 21: Asynchronous Programming\n\nThe project was ambitious; it had been in development for more than a year already, but it was not in production yet.21 Over time, the developers noticed that the performance of the whole system was decreasing, and they were having a hard time finding the bottlenecks.\n\nWhat was happening: with each added feature, more CPU-bound code was slowing down Twisted’s event loop. Python’s role as a glue language meant there was a lot of data parsing and conversion between formats. There wasn’t a single bottleneck: the problem was spread over countless little functions added over months of develop‐ ment. Fixing that would require rethinking the architecture of the system, rewriting a lot of code, probably leveraging a task queue, and perhaps using microservices or cus‐ tom libraries written in languages better suited for CPU-intensive concurrent pro‐ cessing. The stakeholders were not prepared to make that additional investment, and the project was cancelled shortly afterwards.\n\nWhen I told this story to Glyph Lefkowitz—founder the Twisted project—he said that one of his priorities at the start of an asynchronous programming project is to decide which tools he will use to farm out the CPU-intensive tasks. This conversation with Glyph was the inspiration for “Avoiding CPU-Bound Traps” on page 826.\n\n21 Regardless of technical choices, this was probably the biggest mistake in this project: the stakeholders did not go for an MVP approach—delivering a Minimum Viable Product as soon as possible, and then adding fea‐ tures at a steady pace.\n\nFurther Reading\n\n|\n\n831\n\nPART V Metaprogramming\n\nCHAPTER 22 Dynamic Attributes and Properties\n\nThe crucial importance of properties is that their existence makes it perfectly safe and indeed advisable for you to expose public data attributes as part of your class’s public interface.\n\n— Martelli, Ravenscroft, and Holden, “Why properties are important”1\n\nData attributes and methods are collectively known as attributes in Python. A method is an attribute that is callable. Dynamic attributes present the same interface as data attributes—i.e., obj.attr—but are computed on demand. This follows Ber‐ trand Meyer’s Uniform Access Principle:\n\nAll services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation.2\n\nThere are several ways to implement dynamic attributes in Python. This chapter cov‐ ers the simplest ways: the @property decorator and the __getattr__ special method.\n\nA user-defined class implementing __getattr__ can implement a variation of dynamic attributes that I call virtual attributes: attributes that are not explicitly declared anywhere in the source code of the class, and are not present in the instance __dict__, but may be retrieved elsewhere or computed on the fly whenever a user tries to read a nonexistent attribute like obj.no_such_attr.\n\nCoding dynamic and virtual attributes is the kind of metaprogramming that frame‐ work authors do. However, in Python the basic techniques are straightforward, so we can use them in everyday data wrangling tasks. That’s how we’ll start this chapter.\n\n1 Alex Martelli, Anna Ravenscroft, and Steve Holden, Python in a Nutshell, 3rd ed. (O’Reilly), p. 123.\n\n2 Bertrand Meyer, Object-Oriented Software Construction, 2nd ed. (Pearson), p. 57.\n\n835\n\nWhat’s New in This Chapter Most of the updates to this chapter were motivated by a discussion of @func tools.cached_property (introduced in Python 3.8), as well as the combined use of @property with @functools.cache (new in 3.9). This affected the code for the Record and Event classes that appear in “Computed Properties” on page 845. I also added a refactoring to leverage the PEP 412—Key-Sharing Dictionary optimization.\n\nTo highlight more relevant features while keeping the examples readable, I removed some nonessential code—merging the old DbRecord class into Record, replacing shelve.Shelve with a dict, and deleting the logic to download the OSCON dataset —which the examples now read from a local file included in the Fluent Python code repository.\n\nData Wrangling with Dynamic Attributes In the next few examples, we’ll leverage dynamic attributes to work with a JSON dataset published by O’Reilly for the OSCON 2014 conference. Example 22-1 shows four records from that dataset.3\n\nExample 22-1. Sample records from osconfeed.json; some field contents abbreviated\n\n{ \"Schedule\": { \"conferences\": [{\"serial\": 115 }], \"events\": [ { \"serial\": 34505, \"name\": \"Why Schools Don´t Use Open Source to Teach Programming\", \"event_type\": \"40-minute conference session\", \"time_start\": \"2014-07-23 11:30:00\", \"time_stop\": \"2014-07-23 12:10:00\", \"venue_serial\": 1462, \"description\": \"Aside from the fact that high school programming...\", \"website_url\": \"http://oscon.com/oscon2014/public/schedule/detail/34505\", \"speakers\": [157509], \"categories\": [\"Education\"] } ], \"speakers\": [ { \"serial\": 157509, \"name\": \"Robert Lefkowitz\", \"photo\": null, \"url\": \"http://sharewave.com/\", \"position\": \"CTO\",\n\n3 OSCON—O’Reilly Open Source Conference—was a casualty of the COVID-19 pandemic. The original 744\n\nKB JSON file I used for these examples is no longer online as of January 10, 2021. You’ll find a copy of oscon‐ feed.json in the example code repository.\n\n836\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\n\"affiliation\": \"Sharewave\", \"twitter\": \"sharewaveteam\", \"bio\": \"Robert ´r0ml´ Lefkowitz is the CTO at Sharewave, a startup...\" } ], \"venues\": [ { \"serial\": 1462, \"name\": \"F151\", \"category\": \"Conference Venues\" } ] } }\n\nExample 22-1 shows 4 of the 895 records in the JSON file. The entire dataset is a sin‐ gle JSON object with the key \"Schedule\", and its value is another mapping with four keys: \"conferences\", \"events\", \"speakers\", and \"venues\". Each of those four keys maps to a list of records. In the full dataset, the \"events\", \"speakers\", and \"venues\" lists have dozens or hundreds of records, while \"conferences\" has only that one record shown in Example 22-1. Every record has a \"serial\" field, which is a unique identifier for the record within the list.\n\nI used Python’s console to explore the dataset, as shown in Example 22-2.\n\nExample 22-2. Interactive exploration of osconfeed.json\n\n>>> import json >>> with open('data/osconfeed.json') as fp: ... feed = json.load(fp) >>> sorted(feed['Schedule'].keys()) ['conferences', 'events', 'speakers', 'venues'] >>> for key, value in sorted(feed['Schedule'].items()): ... print(f'{len(value):3} {key}') ... 1 conferences 484 events 357 speakers 53 venues >>> feed['Schedule']['speakers'][-1]['name'] 'Carina C. Zona' >>> feed['Schedule']['speakers'][-1]['serial'] 141590 >>> feed['Schedule']['events'][40]['name'] 'There *Will* Be Bugs' >>> feed['Schedule']['events'][40]['speakers'] [3471, 5199]\n\nfeed is a dict holding nested dicts and lists, with string and integer values.\n\nList the four record collections inside \"Schedule\".\n\nData Wrangling with Dynamic Attributes\n\n|\n\n837\n\nDisplay record counts for each collection.\n\nNavigate through the nested dicts and lists to get the name of the last speaker.\n\nGet the serial number of that same speaker.\n\nEach event has a 'speakers' list with zero or more speaker serial numbers.\n\nExploring JSON-Like Data with Dynamic Attributes Example 22-2 is simple enough, but the syntax feed['Schedule']['events'][40] ['name'] is cumbersome. In JavaScript, you can get the same value by writing feed.Schedule.events[40].name. It’s easy to implement a dict-like class that does the same in Python—there are plenty of implementations on the web.4 I wrote FrozenJSON, which is simpler than most recipes because it supports reading only: it’s just for exploring the data. FrozenJSON is also recursive, dealing automatically with nested mappings and lists.\n\nExample 22-3 is a demonstration of FrozenJSON, and the source code is shown in Example 22-4.\n\nExample 22-3. FrozenJSON from Example 22-4 allows reading attributes like name, and calling methods like .keys() and .items()\n\n>>> import json >>> raw_feed = json.load(open('data/osconfeed.json')) >>> feed = FrozenJSON(raw_feed) >>> len(feed.Schedule.speakers) 357 >>> feed.keys() dict_keys(['Schedule']) >>> sorted(feed.Schedule.keys()) ['conferences', 'events', 'speakers', 'venues'] >>> for key, value in sorted(feed.Schedule.items()): ... print(f'{len(value):3} {key}') ... 1 conferences 484 events 357 speakers 53 venues >>> feed.Schedule.speakers[-1].name 'Carina C. Zona' >>> talk = feed.Schedule.events[40] >>> type(talk)\n\n4 Two examples are AttrDict and addict.\n\n838\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\n<class 'explore0.FrozenJSON'> >>> talk.name 'There *Will* Be Bugs' >>> talk.speakers [3471, 5199] >>> talk.flavor Traceback (most recent call last): ... KeyError: 'flavor'\n\nBuild a FrozenJSON instance from the raw_feed made of nested dicts and lists.\n\nFrozenJSON allows traversing nested dicts by using attribute notation; here we show the length of the list of speakers.\n\nMethods of the underlying dicts can also be accessed, like .keys(), to retrieve the record collection names.\n\nUsing items(), we can retrieve the record collection names and their contents, to display the len() of each of them.\n\nA list, such as feed.Schedule.speakers, remains a list, but the items inside are converted to FrozenJSON if they are mappings.\n\nItem 40 in the events list was a JSON object; now it’s a FrozenJSON instance.\n\nEvent records have a speakers list with speaker serial numbers.\n\nTrying to read a missing attribute raises KeyError, instead of the usual AttributeError.\n\nThe keystone of the FrozenJSON class is the __getattr__ method, which we already used in the Vector example in “Vector Take #3: Dynamic Attribute Access” on page 407, to retrieve Vector components by letter: v.x, v.y, v.z, etc. It’s essential to recall that the __getattr__ special method is only invoked by the interpreter when the usual process fails to retrieve an attribute (i.e., when the named attribute cannot be found in the instance, nor in the class or in its superclasses).\n\nThe last line of Example 22-3 exposes a minor issue with my code: trying to read a missing attribute should raise AttributeError, and not KeyError as shown. When I implemented the error handling to do that, the __getattr__ method became twice as long, distracting from the most important logic I wanted to show. Given that users would know that a FrozenJSON is built from mappings and lists, I think the KeyError is not too confusing.\n\nData Wrangling with Dynamic Attributes\n\n|\n\n839\n\nExample 22-4. explore0.py: turn a JSON dataset into a FrozenJSON holding nested FrozenJSON objects, lists, and simple types\n\nfrom collections import abc\n\nclass FrozenJSON: \"\"\"A read-only façade for navigating a JSON-like object using attribute notation \"\"\"\n\ndef __init__(self, mapping): self.__data = dict(mapping)\n\ndef __getattr__(self, name): try: return getattr(self.__data, name) except AttributeError: return FrozenJSON.build(self.__data[name])\n\ndef __dir__(self): return self.__data.keys()\n\n@classmethod def build(cls, obj): if isinstance(obj, abc.Mapping): return cls(obj) elif isinstance(obj, abc.MutableSequence): return [cls.build(item) for item in obj] else: return obj\n\nBuild a dict from the mapping argument. This ensures we get a mapping or something that can be converted to one. The double-underscore prefix on __data makes it a private attribute.\n\n__getattr__ is called only when there’s no attribute with that name.\n\nIf name matches an attribute of the instance __data dict, return that. This is how calls like feed.keys() are handled: the keys method is an attribute of the __data dict.\n\n840\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nOtherwise, fetch the item with the key name from self.__data, and return the result of calling FrozenJSON.build() on that.5\n\nImplementing __dir__ suports the dir() built-in, which in turns supports auto- completion in the standard Python console as well as IPython, Jupyter Notebook, etc. This simple code will enable recursive auto-completion based on the keys in self.__data, because __getattr__ builds FrozenJSON instances on the fly—use‐ ful for interactive exploration of the data.\n\nThis is an alternate constructor, a common use for the @classmethod decorator.\n\nIf obj is a mapping, build a FrozenJSON with it. This is an example of goose typ‐ ing—see “Goose Typing” on page 442 if you need a refresher.\n\nIf it is a MutableSequence, it must be a list,6 so we build a list by passing each item in obj recursively to .build().\n\nIf it’s not a dict or a list, return the item as it is.\n\nA FrozenJSON instance has the __data private instance attribute stored under the name _FrozenJSON__data, as explained in “Private and ‘Protected’ Attributes in Python” on page 382. Attempts to retrieve attributes by other names will trigger __getattr__. This method will first look if the self.__data dict has an attribute (not a key!) by that name; this allows FrozenJSON instances to handle dict methods such as items, by delegating to self.__data.items(). If self.__data doesn’t have an attribute with the given name, __getattr__ uses name as a key to retrieve an item from self.__data, and passes that item to FrozenJSON.build. This allows navigating through nested structures in the JSON data, as each nested mapping is converted to another FrozenJSON instance by the build class method.\n\nNote that FrozenJSON does not transform or cache the original dataset. As we tra‐ verse the data, __getattr__ creates FrozenJSON instances again and again. That’s OK for a dataset of this size, and for a script that will only be used to explore or convert the data.\n\n5 The expression self.__data[name] is where a KeyError exception may occur. Ideally, it should be handled\n\nand an AttributeError raised instead, because that’s what is expected from __getattr__. The diligent reader is invited to code the error handling as an exercise.\n\n6 The source of the data is JSON, and the only collection types in JSON data are dict and list.\n\nData Wrangling with Dynamic Attributes\n\n|\n\n841\n\nAny script that generates or emulates dynamic attribute names from arbitrary sour‐ ces must deal with one issue: the keys in the original data may not be suitable attribute names. The next section addresses this.\n\nThe Invalid Attribute Name Problem The FrozenJSON code doesn’t handle attribute names that are Python keywords. For example, if you build an object like this:\n\n>>> student = FrozenJSON({'name': 'Jim Bo', 'class': 1982})\n\nYou won’t be able to read student.class because class is a reserved keyword in Python:\n\n>>> student.class File \"<stdin>\", line 1 student.class ^ SyntaxError: invalid syntax\n\nYou can always do this, of course:\n\n>>> getattr(student, 'class') 1982\n\nBut the idea of FrozenJSON is to provide convenient access to the data, so a better solution is checking whether a key in the mapping given to FrozenJSON.__init__ is a keyword, and if so, append an _ to it, so the attribute can be read like this:\n\n>>> student.class_ 1982\n\nThis can be achieved by replacing the one-liner __init__ from Example 22-4 with the version in Example 22-5.\n\nExample 22-5. explore1.py: append an _ to attribute names that are Python keywords\n\ndef __init__(self, mapping): self.__data = {} for key, value in mapping.items(): if keyword.iskeyword(key): key += '_' self.__data[key] = value\n\nThe keyword.iskeyword(…) function is exactly what we need; to use it, the key word module must be imported, which is not shown in this snippet.\n\nA similar problem may arise if a key in a JSON record is not a valid Python identifier:\n\n>>> x = FrozenJSON({'2be':'or not'}) >>> x.2be\n\n842\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nFile \"<stdin>\", line 1 x.2be ^ SyntaxError: invalid syntax\n\nSuch problematic keys are easy to detect in Python 3 because the str class provides the s.isidentifier() method, which tells you whether s is a valid Python identifier according to the language grammar. But turning a key that is not a valid identifier into a valid attribute name is not trivial. One solution would be to implement __geti tem__ to allow attribute access using notation like x['2be']. For the sake of simplic‐ ity, I will not worry about this issue.\n\nAfter giving some thought to the dynamic attribute names, let’s turn to another essential feature of FrozenJSON: the logic of the build class method. Fro zen.JSON.build is used by __getattr__ to return a different type of object depend‐ ing on the value of the attribute being accessed: nested structures are converted to FrozenJSON instances or lists of FrozenJSON instances.\n\nInstead of a class method, the same logic could be implemented as the __new__ spe‐ cial method, as we’ll see next.\n\nFlexible Object Creation with __new__ We often refer to __init__ as the constructor method, but that’s because we adopted jargon from other languages. In Python, __init__ gets self as the first argument, therefore the object already exists when __init__ is called by the interpreter. Also, __init__ cannot return anything. So it’s really an initializer, not a constructor.\n\nWhen a class is called to create an instance, the special method that Python calls on that class to construct an instance is __new__. It’s a class method, but gets special treatment, so the @classmethod decorator is not applied to it. Python takes the instance returned by __new__ and then passes it as the first argument self of __init__. We rarely need to code __new__, because the implementation inherited from object suffices for the vast majority of use cases.\n\nIf necessary, the __new__ method can also return an instance of a different class. When that happens, the interpreter does not call __init__. In other words, Python’s logic for building an object is similar to this pseudocode:\n\n# pseudocode for object construction def make(the_class, some_arg): new_object = the_class.__new__(some_arg) if isinstance(new_object, the_class): the_class.__init__(new_object, some_arg) return new_object\n\n# the following statements are roughly equivalent\n\nData Wrangling with Dynamic Attributes\n\n|\n\n843\n\nx = Foo('bar') x = make(Foo, 'bar')\n\nExample 22-6 shows a variation of FrozenJSON where the logic of the former build class method was moved to __new__.\n\nExample 22-6. explore2.py: using __new__ instead of build to construct new objects that may or may not be instances of FrozenJSON\n\nfrom collections import abc import keyword\n\nclass FrozenJSON: \"\"\"A read-only façade for navigating a JSON-like object using attribute notation \"\"\"\n\ndef __new__(cls, arg): if isinstance(arg, abc.Mapping): return super().__new__(cls) elif isinstance(arg, abc.MutableSequence): return [cls(item) for item in arg] else: return arg\n\ndef __init__(self, mapping): self.__data = {} for key, value in mapping.items(): if keyword.iskeyword(key): key += '_' self.__data[key] = value\n\ndef __getattr__(self, name): try: return getattr(self.__data, name) except AttributeError: return FrozenJSON(self.__data[name])\n\ndef __dir__(self): return self.__data.keys()\n\nAs a class method, the first argument __new__ gets is the class itself, and the remaining arguments are the same that __init__ gets, except for self.\n\nThe default behavior is to delegate to the __new__ of a superclass. In this case, we are calling __new__ from the object base class, passing FrozenJSON as the only argument.\n\nThe remaining lines of __new__ are exactly as in the old build method.\n\n844\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nThis was where FrozenJSON.build was called before; now we just call the FrozenJSON class, which Python handles by calling FrozenJSON.__new__.\n\nThe __new__ method gets the class as the first argument because, usually, the created object will be an instance of that class. So, in FrozenJSON.__new__, when the expression super().__new__(cls) effectively calls object.__new__(FrozenJSON), the instance built by the object class is actually an instance of FrozenJSON. The __class__ attribute of the new instance will hold a reference to FrozenJSON, even though the actual construction is performed by object.__new__, implemented in C, in the guts of the interpreter.\n\nThe OSCON JSON dataset is structured in a way that is not helpful for interactive exploration. For example, the event at index 40, titled 'There *Will* Be Bugs' has two speakers, 3471 and 5199. Finding the names of the speakers is awkward, because those are serial numbers and the Schedule.speakers list is not indexed by them. To get each speaker, we must iterate over that list until we find a record with a matching serial number. Our next task is restructuring the data to prepare for automatic retrieval of linked records.\n\nComputed Properties We first saw the @property decorator in Chapter 11, in the section, “A Hashable Vec‐ tor2d” on page 374. In Example 11-7, I used two properties in Vector2d just to make the x and y attributes read-only. Here we will see properties that compute values, leading to a discussion of how to cache such values.\n\nThe records in the 'events' list of the OSCON JSON data contain integer serial numbers pointing to records in the 'speakers' and 'venues' lists. For example, this is the record for a conference talk (with an elided description):\n\n{ \"serial\": 33950, \"name\": \"There *Will* Be Bugs\", \"event_type\": \"40-minute conference session\", \"time_start\": \"2014-07-23 14:30:00\", \"time_stop\": \"2014-07-23 15:10:00\", \"venue_serial\": 1449, \"description\": \"If you're pushing the envelope of programming...\", \"website_url\": \"http://oscon.com/oscon2014/public/schedule/detail/33950\", \"speakers\": [3471, 5199], \"categories\": [\"Python\"] }\n\nWe will implement an Event class with venue and speakers properties to return the linked data automatically—in other words, “dereferencing” the serial number. Given an Event instance, Example 22-7 shows the desired behavior.\n\nComputed Properties\n\n|\n\n845\n\nExample 22-7. Reading venue and speakers returns Record objects\n\n>>> event <Event 'There *Will* Be Bugs'> >>> event.venue <Record serial=1449> >>> event.venue.name 'Portland 251' >>> for spkr in event.speakers: ... print(f'{spkr.serial}: {spkr.name}') ... 3471: Anna Martelli Ravenscroft 5199: Alex Martelli\n\nGiven an Event instance…\n\n…reading event.venue returns a Record object instead of a serial number.\n\nNow it’s easy to get the name of the venue.\n\nThe event.speakers property returns a list of Record instances.\n\nAs usual, we will build the code step-by-step, starting with the Record class and a function to read the JSON data and return a dict with Record instances.\n\nStep 1: Data-Driven Attribute Creation Example 22-8 shows the doctest to guide this first step.\n\nExample 22-8. Test-driving schedule_v1.py (from Example 22-9)\n\n>>> records = load(JSON_PATH) >>> speaker = records['speaker.3471'] >>> speaker <Record serial=3471> >>> speaker.name, speaker.twitter ('Anna Martelli Ravenscroft', 'annaraven')\n\nload a dict with the JSON data.\n\nThe keys in records are strings built from the record type and serial number.\n\nspeaker is an instance of the Record class defined in Example 22-9.\n\nFields from the original JSON can be retrieved as Record instance attributes.\n\nThe code for schedule_v1.py is in Example 22-9.\n\n846\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nExample 22-9. schedule_v1.py: reorganizing the OSCON schedule data\n\nimport json\n\nJSON_PATH = 'data/osconfeed.json'\n\nclass Record: def __init__(self, **kwargs): self.__dict__.update(kwargs)\n\ndef __repr__(self): return f'<{self.__class__.__name__} serial={self.serial!r}>'\n\ndef load(path=JSON_PATH): records = {} with open(path) as fp: raw_data = json.load(fp) for collection, raw_records in raw_data['Schedule'].items(): record_type = collection[:-1] for raw_record in raw_records: key = f'{record_type}.{raw_record[\"serial\"]}' records[key] = Record(**raw_record) return records\n\nThis is a common shortcut to build an instance with attributes created from key‐ word arguments (detailed explanation follows).\n\nUse the serial field to build the custom Record representation shown in Example 22-8.\n\nload will ultimately return a dict of Record instances.\n\nParse the JSON, returning native Python objects: lists, dicts, strings, numbers, etc.\n\nIterate over the four top-level lists named 'conferences', 'events', 'speak ers', and 'venues'.\n\nrecord_type is the list name without the last character, so speakers becomes speaker. In Python ≥ 3.9 we can do this more explicitly with collection.remove suffix('s')—see PEP 616—String methods to remove prefixes and suffixes.\n\nBuild the key in the format 'speaker.3471'.\n\nCreate a Record instance and save it in records with the key.\n\nComputed Properties\n\n|\n\n847\n\nThe Record.__init__ method illustrates an old Python hack. Recall that the __dict__ of an object is where its attributes are kept—unless __slots__ is declared in the class, as we saw in “Saving Memory with __slots__” on page 384. So, updating an instance __dict__ with a mapping is a quick way to create a bunch of attributes in that instance.7\n\nDepending on the application, the Record class may need to deal with keys that are not valid attribute names, as we saw in “The Invalid Attribute Name Problem” on page 842. Dealing with that issue would distract from the key idea of this example, and is not a problem in the dataset we are reading.\n\nThe definition of Record in Example 22-9 is so simple that you may be wondering why I did not use it before, instead of the more complicated FrozenJSON. There are two reasons. First, FrozenJSON works by recursively converting the nested mappings and lists; Record doesn’t need that because our converted dataset doesn’t have map‐ pings nested in mappings or lists. The records contain only strings, integers, lists of strings, and lists of integers. Second reason: FrozenJSON provides access to the embedded __data dict attributes—which we used to invoke methods like .keys()— and now we don’t need that functionality either.\n\nThe Python standard library provides classes similar to Record, where each instance has an arbitrary set of attributes built from keyword arguments given to __init__: types.SimpleNamespace, argparse.Namespace, and multiprocessing.managers.Name space. I wrote the simpler Record class to highlight the essential idea: __init__ updating the instance __dict__.\n\nAfter reorganizing the schedule dataset, we can enhance the Record class to automat‐ ically retrieve venue and speaker records referenced in an event record. We’ll use properties to do that in the next examples.\n\nStep 2: Property to Retrieve a Linked Record The goal of this next version is: given an event record, reading its venue property will return a Record. This is similar to what the Django ORM does when you access a ForeignKey field: instead of the key, you get the linked model object.\n\n7 By the way, Bunch is the name of the class used by Alex Martelli to share this tip in a recipe from 2001 titled\n\n“The simple but handy ‘collector of a bunch of named stuff’ class”.\n\n848\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nWe’ll start with the venue property. See the partial interaction in Example 22-10 as an example.\n\nExample 22-10. Extract from the doctests of schedule_v2.py\n\n>>> event = Record.fetch('event.33950') >>> event <Event 'There *Will* Be Bugs'> >>> event.venue <Record serial=1449> >>> event.venue.name 'Portland 251' >>> event.venue_serial 1449\n\nThe Record.fetch static method gets a Record or an Event from the dataset.\n\nNote that event is an instance of the Event class.\n\nAccessing event.venue returns a Record instance.\n\nNow it’s easy to find out the name of an event.venue.\n\nThe Event instance also has a venue_serial attribute, from the JSON data.\n\nEvent is a subclass of Record adding a venue to retrieve linked records, and a special‐ ized __repr__ method.\n\nThe code for this section is in the schedule_v2.py module in the Fluent Python code repository. The example has nearly 60 lines, so I’ll present it in parts, starting with the enhanced Record class.\n\nExample 22-11. schedule_v2.py: Record class with a new fetch method\n\nimport inspect import json\n\nJSON_PATH = 'data/osconfeed.json'\n\nclass Record:\n\n__index = None\n\ndef __init__(self, **kwargs): self.__dict__.update(kwargs)\n\ndef __repr__(self): return f'<{self.__class__.__name__} serial={self.serial!r}>'\n\nComputed Properties\n\n|\n\n849",
      "page_number": 842
    },
    {
      "number": 43,
      "title": "Segment 43 (pages 865-885)",
      "start_page": 865,
      "end_page": 885,
      "detection_method": "synthetic",
      "content": "Event extends Record.\n\nIf the instance has a name attribute, it is used to produce a custom representation. Otherwise, delegate to the __repr__ from Record.\n\nThe venue property builds a key from the venue_serial attribute, and passes it to the fetch class method, inherited from Record (the reason for using self.__class__ is explained shortly).\n\nthe venue method of Example 22-12 returns self The second .__class__.fetch(key). Why not simply call self.fetch(key)? The simpler form works with the specific OSCON dataset because there is no event record with a 'fetch' key. But, if an event record had a key named 'fetch', then within that spe‐ cific Event instance, the reference self.fetch would retrieve the value of that field, instead of the fetch class method that Event inherits from Record. This is a subtle bug, and it could easily sneak through testing because it depends on the dataset.\n\nline of\n\nWhen creating instance attribute names from data, there is always the risk of bugs due to shadowing of class attributes—such as methods—or data loss through accidental overwriting of existing instance attributes. These problems may explain why Python dicts are not like JavaScript objects in the first place.\n\nIf the Record class behaved more like a mapping, implementing a dynamic __geti tem__ instead of a dynamic __getattr__, there would be no risk of bugs from over‐ writing or shadowing. A custom mapping is probably the Pythonic way to implement Record. But if I took that road, we’d not be studying the tricks and traps of dynamic attribute programming.\n\nThe final piece of this example is the revised load function in Example 22-13.\n\nExample 22-13. schedule_v2.py: the load function\n\ndef load(path=JSON_PATH): records = {} with open(path) as fp: raw_data = json.load(fp) for collection, raw_records in raw_data['Schedule'].items(): record_type = collection[:-1] cls_name = record_type.capitalize() cls = globals().get(cls_name, Record) if inspect.isclass(cls) and issubclass(cls, Record): factory = cls else: factory = Record\n\nComputed Properties\n\n|\n\n851\n\nfor raw_record in raw_records: key = f'{record_type}.{raw_record[\"serial\"]}' records[key] = factory(**raw_record) return records\n\nSo far, no changes from the load in schedule_v1.py (Example 22-9).\n\nCapitalize the record_type to get a possible class name; e.g., 'event' becomes 'Event'.\n\nGet an object by that name from the module global scope; get the Record class if there’s no such object.\n\nIf the object just retrieved is a class, and is a subclass of Record…\n\n…bind the factory name to it. This means factory may be any subclass of Record, depending on the record_type.\n\nOtherwise, bind the factory name to Record.\n\nThe for loop that creates the key and saves the records is the same as before, except that…\n\n…the object stored in records is constructed by factory, which may be Record or a subclass like Event, selected according to the record_type.\n\nNote that the only record_type that has a custom class is Event, but if classes named Speaker or Venue are coded, load will automatically use those classes when building and saving records, instead of the default Record class.\n\nWe’ll now apply the same idea to a new speakers property in the Events class.\n\nStep 3: Property Overriding an Existing Attribute The name of the venue property in Example 22-12 does not match a field name in records of the \"events\" collection. Its data comes from a venue_serial field name. In contrast, each record in the events collection has a speakers field with a list of serial numbers. We want to expose that information as a speakers property in Event instances, which returns a list of Record instances. This name clash requires some special attention, as Example 22-14 reveals.\n\nExample 22-14. schedule_v3.py: the speakers property\n\n@property def speakers(self):\n\n852\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nspkr_serials = self.__dict__['speakers'] fetch = self.__class__.fetch return [fetch(f'speaker.{key}') for key in spkr_serials]\n\nThe data we want is in a speakers attribute, but we must retrieve it directly from the instance __dict__ to avoid a recursive call to the speakers property.\n\nReturn a list of all records with keys corresponding to the numbers in spkr_serials.\n\nInside the speakers method, trying to read self.speakers will invoke the property itself, quickly raising a RecursionError. However, if we read the same data via self.__dict__['speakers'], Python’s usual algorithm for retrieving attributes is bypassed, the property is not called, and the recursion is avoided. For this reason, reading or writing data directly to an object’s __dict__ is a common Python meta‐ programming trick.\n\nThe interpreter evaluates obj.my_attr by first looking at the class of obj. If the class has a property with the my_attr name, that property shadows an instance attribute by the same name. Exam‐ ples in “Properties Override Instance Attributes” on page 861 will demonstrate this, and Chapter 23 will reveal that a property is implemented as a descriptor—a more powerful and general abstraction.\n\nAs I coded the list comprehension in Example 22-14, my programmer’s lizard brain thought: “This may be expensive.” Not really, because events in the OSCON dataset have few speakers, so coding anything more complicated would be premature opti‐ mization. However, caching a property is a common need—and there are caveats. So let’s see how to do that in the next examples.\n\nStep 4: Bespoke Property Cache Caching properties is a common need because there is an expectation that an expres‐ sion like event.venue should be inexpensive.8 Some form of caching could become necessary if the Record.fetch method behind the Event properties needed to query a database or a web API.\n\n8 This is actually a downside of Meyer’s Uniform Access Principle, which I mentioned in the opening of this\n\nchapter. Read the optional “Soapbox” on page 875 if you’re interested in this discussion.\n\nComputed Properties\n\n|\n\n853\n\nIn the first edition Fluent Python, I coded the custom caching logic for the speakers method, as shown in Example 22-15.\n\nExample 22-15. Custom caching logic using hasattr disables key-sharing optimization\n\n@property def speakers(self): if not hasattr(self, '__speaker_objs'): spkr_serials = self.__dict__['speakers'] fetch = self.__class__.fetch self.__speaker_objs = [fetch(f'speaker.{key}') for key in spkr_serials] return self.__speaker_objs\n\nIf the instance doesn’t have an attribute named __speaker_objs, fetch the speaker objects and store them there.\n\nReturn self.__speaker_objs.\n\nThe handmade caching in Example 22-15 is straightforward, but creating an attribute after the instance is initialized defeats the PEP 412—Key-Sharing Dictionary optimi‐ zation, as explained in “Practical Consequences of How dict Works” on page 102. Depending on the size of the dataset, the difference in memory usage may be impor‐ tant.\n\nA similar hand-rolled solution that works well with the key-sharing optimization requires coding an __init__ for the Event class, to create the necessary __speaker_objs initialized to None, and then checking for that in the speakers method. See Example 22-16.\n\nExample 22-16. Storage defined in __init__ to leverage key-sharing optimization\n\nclass Event(Record):\n\ndef __init__(self, **kwargs): self.__speaker_objs = None super().__init__(**kwargs)\n\n# 15 lines omitted... @property def speakers(self): if self.__speaker_objs is None: spkr_serials = self.__dict__['speakers'] fetch = self.__class__.fetch self.__speaker_objs = [fetch(f'speaker.{key}') for key in spkr_serials] return self.__speaker_objs\n\n854\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nExamples 22-15 and 22-16 illustrate simple caching techniques that are fairly com‐ mon in legacy Python codebases. However, in multithreaded programs, handmade caches like those introduce race conditions that may lead to corrupted data. If two threads are reading a property that was not previously cached, the first thread will need to compute the data for the cache attribute (__speaker_objs in the examples) and the second thread may read a cached value that is not yet complete.\n\nFortunately, Python 3.8 introduced the @functools.cached_property decorator, which is thread safe. Unfortunately, it comes with a couple of caveats, explained next.\n\nStep 5: Caching Properties with functools The functools module provides three decorators for caching. We saw @cache and @lru_cache in “Memoization with functools.cache” on page 320 (Chapter 9). Python 3.8 introduced @cached_property.\n\nThe functools.cached_property decorator caches the result of the method in an instance attribute with the same name. For example, in Example 22-17, the value computed by the venue method is stored in a venue attribute in self. After that, when client code tries to read venue, the newly created venue instance attribute is used instead of the method.\n\nExample 22-17. Simple use of a @cached_property\n\n@cached_property def venue(self): key = f'venue.{self.venue_serial}' return self.__class__.fetch(key)\n\nIn “Step 3: Property Overriding an Existing Attribute” on page 852, we saw that a property shadows an instance attribute by the same name. If that is true, how can @cached_property work? If the property overrides the instance attribute, the venue attribute will be ignored and the venue method will always be called, computing the key and running fetch every time!\n\nThe answer is a bit sad: cached_property is a misnomer. The @cached_property decorator does not create a full-fledged property, it creates a nonoverriding descriptor. A descriptor is an object that manages the access to an attribute in another class. We will dive into descriptors in Chapter 23. The property decorator is a high-level API to create an overriding descriptor. Chapter 23 will include a through explanation about overriding versus nonoverriding descriptors.\n\nFor now, let us set aside the underlying implementation and focus on the differences between cached_property and property from a user’s point of view. Raymond Het‐ tinger explains them very well in the Python docs:\n\nComputed Properties\n\n|\n\n855\n\nThe mechanics of cached_property() are somewhat different from property(). A regular property blocks attribute writes unless a setter is defined. In contrast, a cached_property allows writes. The cached_property decorator only runs on lookups and only when an attribute of the same name doesn’t exist. When it does run, the cached_property writes to the attribute with the same name. Subsequent attribute reads and writes take precedence over the cached_property method and it works like a normal attribute. The cached value can be cleared by deleting the attribute. This allows the cached_prop erty method to run again.9\n\nBack to our Event class: the specific behavior of @cached_property makes it unsuita‐ ble to decorate speakers, because that method relies on an existing attribute also named speakers, containing the serial numbers of the event speakers.\n\n@cached_property has some important limitations:\n\nIt cannot be used as a drop-in replacement to @property if the decorated method already depends on an instance attribute with the same name.\n\nIt cannot be used in a class that defines __slots__.\n\nIt defeats the key-sharing optimization of the instance __dict__, because it creates an instance attribute after __init__.\n\nDespite these limitations, @cached_property addresses a common need in a simple way, and it is thread safe. Its Python code is an example of using a reentrant lock.\n\nThe @cached_property documentation recommends an alternative solution that we can use with speakers: stacking @property and @cache decorators, as shown in Example 22-18.\n\nExample 22-18. Stacking @property on @cache\n\n@property @cache def speakers(self): spkr_serials = self.__dict__['speakers'] fetch = self.__class__.fetch\n\n9 Source: @functools.cached_property documentation. I know Raymond Hettinger authored this explanation\n\nbecause he wrote it as a response to an issue I filed: bpo42781—functools.cached_property docs should explain that it is non-overriding. Hettinger is a major contributor to the official Python docs and standard library. He also wrote the excellent “Descriptor HowTo Guide”, a key resource for Chapter 23.\n\n856\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nreturn [fetch(f'speaker.{key}') for key in spkr_serials]\n\nThe order is important: @property goes on top…\n\n…of @cache.\n\nRecall from “Stacked Decorators” on page 322 the meaning of that syntax. The top three lines of Example 22-18 are similar to:\n\nspeakers = property(cache(speakers))\n\nThe @cache is applied to speakers, returning a new function. That function then is decorated by @property, which replaces it with a newly constructed property.\n\nThis wraps up our discussion of read-only properties and caching decorators, explor‐ ing the OSCON dataset. In the next section, we start a new series of examples creat‐ ing read/write properties.\n\nUsing a Property for Attribute Validation Besides computing attribute values, properties are also used to enforce business rules by changing a public attribute into an attribute protected by a getter and setter without affecting client code. Let’s work through an extended example.\n\nLineItem Take #1: Class for an Item in an Order Imagine an app for a store that sells organic food in bulk, where customers can order nuts, dried fruit, or cereals by weight. In that system, each order would hold a sequence of line items, and each line item could be represented by an instance of a class, as in Example 22-19.\n\nExample 22-19. bulkfood_v1.py: the simplest LineItem class\n\nclass LineItem:\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\nThat’s nice and simple. Perhaps too simple. Example 22-20 shows a problem.\n\nUsing a Property for Attribute Validation\n\n|\n\n857\n\nExample 22-20. A negative weight results in a negative subtotal\n\n>>> raisins = LineItem('Golden raisins', 10, 6.95) >>> raisins.subtotal() 69.5 >>> raisins.weight = -20 # garbage in... >>> raisins.subtotal() # garbage out... -139.0\n\nThis is a toy example, but not as fanciful as you may think. Here is a story from the early days of Amazon.com:\n\nWe found that customers could order a negative quantity of books! And we would credit their credit card with the price and, I assume, wait around for them to ship the books.\n\n— Jeff Bezos, founder and CEO of Amazon.com10\n\nHow do we fix this? We could change the interface of LineItem to use a getter and a setter for the weight attribute. That would be the Java way, and it’s not wrong.\n\nOn the other hand, it’s natural to be able to set the weight of an item by just assign‐ ing to it; and perhaps the system is in production with other parts already accessing item.weight directly. In this case, the Python way would be to replace the data attribute with a property.\n\nLineItem Take #2: A Validating Property Implementing a property will allow us to use a getter and a setter, but the interface of LineItem will not change (i.e., setting the weight of a LineItem will still be written as raisins.weight = 12).\n\nExample 22-21 lists the code for a read/write weight property.\n\nExample 22-21. bulkfood_v2.py: a LineItem with a weight property\n\nclass LineItem:\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\n10 Direct quote by Jeff Bezos in the Wall Street Journal story, “Birth of a Salesman” (October 15, 2011). Note that\n\nas of 2021, you need a subscription to read the article.\n\n858\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\n@property def weight(self): return self.__weight\n\n@weight.setter def weight(self, value): if value > 0: self.__weight = value else: raise ValueError('value must be > 0')\n\nHere the property setter is already in use, making sure that no instances with negative weight can be created.\n\n@property decorates the getter method.\n\nAll the methods that implement a property share the name of the public attribute: weight.\n\nThe actual value is stored in a private attribute __weight.\n\nThe decorated getter has a .setter attribute, which is also a decorator; this ties the getter and setter together.\n\nIf the value is greater than zero, we set the private __weight.\n\nOtherwise, ValueError is raised.\n\nNote how a LineItem with an invalid weight cannot be created now:\n\n>>> walnuts = LineItem('walnuts', 0, 10.00) Traceback (most recent call last): ... ValueError: value must be > 0\n\nNow we have protected weight from users providing negative values. Although buy‐ ers usually can’t set the price of an item, a clerical error or a bug may create a LineI tem with a negative price. To prevent that, we could also turn price into a property, but this would entail some repetition in our code.\n\nRemember the Paul Graham quote from Chapter 17: “When I see patterns in my pro‐ grams, I consider it a sign of trouble.” The cure for repetition is abstraction. There are two ways to abstract away property definitions: using a property factory or a descrip‐ tor class. The descriptor class approach is more flexible, and we’ll devote Chapter 23 to a full discussion of it. Properties are in fact implemented as descriptor classes\n\nUsing a Property for Attribute Validation\n\n|\n\n859\n\nthemselves. But here we will continue our exploration of properties by implementing a property factory as a function.\n\nBut before we can implement a property factory, we need to have a deeper under‐ standing of properties.\n\nA Proper Look at Properties Although often used as a decorator, the property built-in is actually a class. In Python, functions and classes are often interchangeable, because both are callable and there is no new operator for object instantiation, so invoking a constructor is no dif‐ ferent from invoking a factory function. And both can be used as decorators, as long as they return a new callable that is a suitable replacement of the decorated callable.\n\nThis is the full signature of the property constructor:\n\nproperty(fget=None, fset=None, fdel=None, doc=None)\n\nAll arguments are optional, and if a function is not provided for one of them, the cor‐ responding operation is not allowed by the resulting property object.\n\nThe property type was added in Python 2.2, but the @ decorator syntax appeared only in Python 2.4, so for a few years, properties were defined by passing the accessor functions as the first two arguments.\n\nThe “classic” syntax for defining properties without decorators is illustrated in Example 22-22.\n\nExample 22-22. bulkfood_v2b.py: same as Example 22-21, but without using decorators\n\nclass LineItem:\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\ndef get_weight(self): return self.__weight\n\ndef set_weight(self, value): if value > 0: self.__weight = value else: raise ValueError('value must be > 0')\n\n860\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nweight = property(get_weight, set_weight)\n\nA plain getter.\n\nA plain setter.\n\nBuild the property and assign it to a public class attribute.\n\nThe classic form is better than the decorator syntax in some situations; the code of the property factory we’ll discuss shortly is one example. On the other hand, in a class body with many methods, the decorators make it explicit which are the getters and setters, without depending on the convention of using get and set prefixes in their names.\n\nThe presence of a property in a class affects how attributes in instances of that class can be found in a way that may be surprising at first. The next section explains.\n\nProperties Override Instance Attributes Properties are always class attributes, but they actually manage attribute access in the instances of the class.\n\nIn “Overriding Class Attributes” on page 389 we saw that when an instance and its class both have a data attribute by the same name, the instance attribute overrides, or instance. the class attribute—at shadows, Example 22-23 illustrates this point.\n\nleast when read\n\nthrough\n\nthat\n\nExample 22-23. Instance attribute shadows the class data attribute\n\n>>> class Class: ... data = 'the class data attr' ... @property ... def prop(self): ... return 'the prop value' ... >>> obj = Class() >>> vars(obj) {} >>> obj.data 'the class data attr' >>> obj.data = 'bar' >>> vars(obj) {'data': 'bar'} >>> obj.data 'bar' >>> Class.data 'the class data attr'\n\nA Proper Look at Properties\n\n|\n\n861\n\nDefine Class with two class attributes: the data attribute and the prop property.\n\nvars returns the __dict__ of obj, showing it has no instance attributes.\n\nReading from obj.data retrieves the value of Class.data.\n\nWriting to obj.data creates an instance attribute.\n\nInspect the instance to see the instance attribute.\n\nNow reading from obj.data retrieves the value of the instance attribute. When read from the obj instance, the instance data shadows the class data.\n\nThe Class.data attribute is intact.\n\nNow, let’s try to override the prop attribute on the obj instance. Resuming the previ‐ ous console session, we have Example 22-24.\n\nExample 22-24. Instance attribute does not shadow the class property (continued from Example 22-23)\n\n>>> Class.prop <property object at 0x1072b7408> >>> obj.prop 'the prop value' >>> obj.prop = 'foo' Traceback (most recent call last): ... AttributeError: can't set attribute >>> obj.__dict__['prop'] = 'foo' >>> vars(obj) {'data': 'bar', 'prop': 'foo'} >>> obj.prop 'the prop value' >>> Class.prop = 'baz' >>> obj.prop 'foo'\n\nReading prop directly from Class retrieves the property object itself, without running its getter method.\n\nReading obj.prop executes the property getter.\n\nTrying to set an instance prop attribute fails.\n\nPutting 'prop' directly in the obj.__dict__ works.\n\n862\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nWe can see that obj now has two instance attributes: data and prop.\n\nHowever, reading obj.prop still runs the property getter. The property is not shadowed by an instance attribute.\n\nOverwriting Class.prop destroys the property object.\n\nNow obj.prop retrieves the instance attribute. Class.prop is not a property any‐ more, so it no longer overrides obj.prop.\n\nAs a final demonstration, we’ll add a new property to Class, and see it overriding an instance attribute. Example 22-25 picks up where Example 22-24 left off.\n\nExample 22-25. New class property shadows the existing instance attribute (continued from Example 22-24)\n\n>>> obj.data 'bar' >>> Class.data 'the class data attr' >>> Class.data = property(lambda self: 'the \"data\" prop value') >>> obj.data 'the \"data\" prop value' >>> del Class.data >>> obj.data 'bar'\n\nobj.data retrieves the instance data attribute.\n\nClass.data retrieves the class data attribute.\n\nOverwrite Class.data with a new property.\n\nobj.data is now shadowed by the Class.data property.\n\nDelete the property.\n\nobj.data now reads the instance data attribute again.\n\nThe main point of this section is that an expression like obj.data does not start the search for data in obj. The search actually starts at obj.__class__, and only if there is no property named data in the class, Python looks in the obj instance itself. This applies to overriding descriptors in general, of which properties are just one example. Further treatment of descriptors must wait for Chapter 23.\n\nA Proper Look at Properties\n\n|\n\n863\n\nNow back to properties. Every Python code unit—modules, functions, classes, meth‐ ods—can have a docstring. The next topic is how to attach documentation to properties.\n\nProperty Documentation When tools such as the console help() function or IDEs need to display the docu‐ mentation of a property, they extract the information from the __doc__ attribute of the property.\n\nIf used with the classic call syntax, property can get the documentation string as the doc argument:\n\nweight = property(get_weight, set_weight, doc='weight in kilograms')\n\nThe docstring of the getter method—the one with the @property decorator itself—is used as the documentation of the property as a whole. Figure 22-1 shows the help screens generated from the code in Example 22-26.\n\nFigure 22-1. Screenshots of the Python console when issuing the commands help(Foo.bar) and help(Foo). Source code is in Example 22-26.\n\nExample 22-26. Documentation for a property\n\nclass Foo:\n\n@property def bar(self): \"\"\"The bar attribute\"\"\" return self.__dict__['bar']\n\n@bar.setter def bar(self, value): self.__dict__['bar'] = value\n\n864\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nNow that we have these property essentials covered, let’s go back to the issue of pro‐ tecting both the weight and price attributes of LineItem so they only accept values greater than zero—but without implementing two nearly identical pairs of getters/ setters by hand.\n\nCoding a Property Factory We’ll create a factory to create quantity properties—so named because the managed attributes represent quantities that can’t be negative or zero in the application. Example 22-27 shows the clean look of the LineItem class using two instances of quantity properties: one for managing the weight attribute, the other for price.\n\nExample 22-27. bulkfood_v2prop.py: the quantity property factory in use\n\nclass LineItem: weight = quantity('weight') price = quantity('price')\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\nUse the factory to define the first custom property, weight, as a class attribute.\n\nThis second call builds another custom property, price.\n\nHere the property is already active, making sure a negative or 0 weight is rejected.\n\nThe properties are also in use here, retrieving the values stored in the instance.\n\nRecall that properties are class attributes. When building each quantity property, we need to pass the name of the LineItem attribute that will be managed by that specific property. Having to type the word weight twice in this line is unfortunate:\n\nweight = quantity('weight')\n\nBut avoiding that repetition is complicated because the property has no way of know‐ ing which class attribute name will be bound to it. Remember: the righthand side of an assignment is evaluated first, so when quantity() is invoked, the weight class attribute doesn’t even exist.\n\nCoding a Property Factory\n\n|\n\n865\n\nImproving the quantity property so that the user doesn’t need to retype the attribute name is a nontrivial metaprogramming prob‐ lem. We’ll solve that problem in Chapter 23.\n\nExample 22-28 lists the implementation of the quantity property factory.11\n\nExample 22-28. bulkfood_v2prop.py: the quantity property factory\n\ndef quantity(storage_name):\n\ndef qty_getter(instance): return instance.__dict__[storage_name]\n\ndef qty_setter(instance, value): if value > 0: instance.__dict__[storage_name] = value else: raise ValueError('value must be > 0')\n\nreturn property(qty_getter, qty_setter)\n\nThe storage_name argument determines where the data for each property is stored; for the weight, the storage name will be 'weight'.\n\nThe first argument of the qty_getter could be named self, but that would be strange because this is not a class body; instance refers to the LineItem instance where the attribute will be stored.\n\nqty_getter references storage_name, so it will be preserved in the closure of this function; the value is retrieved directly from the instance.__dict__ to bypass the property and avoid an infinite recursion.\n\nqty_setter is defined, also taking instance as first argument.\n\nThe value is stored directly in the instance.__dict__, again bypassing the property.\n\nBuild a custom property object and return it.\n\n11 This code is adapted from “Recipe 9.21. Avoiding Repetitive Property Methods” from Python Cookbook, 3rd\n\ned., by David Beazley and Brian K. Jones (O’Reilly).\n\n866\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nThe bits of Example 22-28 that deserve careful study revolve around the stor age_name variable. When you code each property in the traditional way, the name of the attribute where you will store a value is hardcoded in the getter and setter meth‐ ods. But here, the qty_getter and qty_setter functions are generic, and they depend on the storage_name variable to know where to get/set the managed attribute in the instance __dict__. Each time the quantity factory is called to build a property, the storage_name must be set to a unique value.\n\nThe functions qty_getter and qty_setter will be wrapped by the property object created in the last line of the factory function. Later, when called to perform their duties, these functions will read the storage_name from their closures to determine where to retrieve/store the managed attribute values.\n\nIn Example 22-29, I create and inspect a LineItem instance, exposing the storage attributes.\n\nExample 22-29. bulkfood_v2prop.py: exploring properties and storage attributes\n\n>>> nutmeg = LineItem('Moluccan nutmeg', 8, 13.95) >>> nutmeg.weight, nutmeg.price (8, 13.95) >>> nutmeg.__dict__ {'description': 'Moluccan nutmeg', 'weight': 8, 'price': 13.95}\n\nReading the weight and price through the properties shadowing the namesake instance attributes.\n\nUsing vars to inspect the nutmeg instance: here we see the actual instance attributes used to store the values.\n\nNote how the properties built by our factory leverage the behavior described in “Properties Override Instance Attributes” on page 861: the weight property overrides the weight instance attribute so that every reference to self.weight or nut meg.weight is handled by the property functions, and the only way to bypass the property logic is to access the instance __dict__ directly.\n\nThe code in Example 22-28 may be a bit tricky, but it’s concise: it’s identical in length in to Example 22-21. The LineItem definition in Example 22-27 looks much better without the noise of the getter/setters.\n\nthe weight property\n\nthe decorated getter/setter pair defining\n\njust\n\nIn a real system, that same kind of validation may appear in many fields, across sev‐ eral classes, and the quantity factory would be placed in a utility module to be used over and over again. Eventually that simple factory could be refactored into a more\n\nCoding a Property Factory\n\n|\n\n867\n\nextensible descriptor class, with specialized subclasses performing different valida‐ tions. We’ll do that in Chapter 23.\n\nNow let us wrap up the discussion of properties with the issue of attribute deletion.\n\nHandling Attribute Deletion We can use the del statement to delete not only variables, but also attributes:\n\n>>> class Demo: ... pass ... >>> d = Demo() >>> d.color = 'green' >>> d.color 'green' >>> del d.color >>> d.color Traceback (most recent call last): File \"<stdin>\", line 1, in <module> AttributeError: 'Demo' object has no attribute 'color'\n\nIn practice, deleting attributes is not something we do every day in Python, and the requirement to handle it with a property is even more unusual. But it is supported, and I can think of a silly example to demonstrate it.\n\nIn a property definition, the @my_property.deleter decorator wraps the method in charge of deleting the attribute managed by the property. As promised, silly Example 22-30 is inspired by the scene with the Black Knight from Monty Python and the Holy Grail.12\n\nExample 22-30. blackknight.py\n\nclass BlackKnight:\n\ndef __init__(self): self.phrases = [ ('an arm', \"'Tis but a scratch.\"), ('another arm', \"It's just a flesh wound.\"), ('a leg', \"I'm invincible!\"), ('another leg', \"All right, we'll call it a draw.\") ]\n\n@property def member(self): print('next member is:')\n\n12 The bloody scene is available on Youtube as I review this in October 2021.\n\n868\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nreturn self.phrases[0][0]\n\n@member.deleter def member(self): member, text = self.phrases.pop(0) print(f'BLACK KNIGHT (loses {member}) -- {text}')\n\nThe doctests in blackknight.py are in Example 22-31.\n\nExample 22-31. blackknight.py: doctests for Example 22-30 (the Black Knight never concedes defeat)\n\n>>> knight = BlackKnight() >>> knight.member next member is: 'an arm' >>> del knight.member BLACK KNIGHT (loses an arm) -- 'Tis but a scratch. >>> del knight.member BLACK KNIGHT (loses another arm) -- It's just a flesh wound. >>> del knight.member BLACK KNIGHT (loses a leg) -- I'm invincible! >>> del knight.member BLACK KNIGHT (loses another leg) -- All right, we'll call it a draw.\n\nUsing the classic call syntax instead of decorators, the fdel argument configures the deleter function. For example, the member property would be coded like this in the body of the BlackKnight class:\n\nmember = property(member_getter, fdel=member_deleter)\n\nIf you are not using a property, attribute deletion can also be handled by implement‐ ing the lower-level __delattr__ special method, presented in “Special Methods for Attribute Handling” on page 871. Coding a silly class with __delattr__ is left as an exercise to the procrastinating reader.\n\nProperties are a powerful feature, but sometimes simpler or lower-level alternatives are preferable. In the final section of this chapter, we’ll review some of the core APIs that Python offers for dynamic attribute programming.\n\nEssential Attributes and Functions for Attribute Handling Throughout this chapter, and even before in the book, we’ve used some of the built- in functions and special methods Python provides for dealing with dynamic attributes. This section gives an overview of them in one place, because their docu‐ mentation is scattered in the official docs.\n\nEssential Attributes and Functions for Attribute Handling\n\n|\n\n869\n\nSpecial Attributes that Affect Attribute Handling The behavior of many of the functions and special methods listed in the following sections depend on three special attributes:\n\n__class__\n\nA reference to the object’s class (i.e., obj.__class__ is the same as type(obj)). Python looks for special methods such as __getattr__ only in an object’s class, and not in the instances themselves.\n\n__dict__\n\nA mapping that stores the writable attributes of an object or class. An object that has a __dict__ can have arbitrary new attributes set at any time. If a class has a __slots__ attribute, then its instances may not have a __dict__. See __slots__ (next).\n\n__slots__\n\nAn attribute that may be defined in a class to save memory. __slots__ is a tuple of strings naming the allowed attributes.13 If the '__dict__' name is not in __slots__, then the instances of that class will not have a __dict__ of their own, and only the attributes listed in __slots__ will be allowed in those instances. Recall “Saving Memory with __slots__” on page 384 for more.\n\nBuilt-In Functions for Attribute Handling These five built-in functions perform object attribute reading, writing, and introspection:\n\ndir([object])\n\nLists most attributes of the object. The official docs say dir is intended for inter‐ active use so it does not provide a comprehensive list of attributes, but an “inter‐ esting” set of names. dir can inspect objects implemented with or without a __dict__. The __dict__ attribute itself is not listed by dir, but the __dict__ keys are listed. Several special attributes of classes, such as __mro__, __bases__, and __name__, are not listed by dir either. You can customize the output of dir by implementing the __dir__ special method, as we saw in Example 22-4. If the optional object argument is not given, dir lists the names in the current scope.\n\n13 Alex Martelli points out that, although __slots__ can be coded as a list, it’s better to be explicit and always use a tuple, because changing the list in the __slots__ after the class body is processed has no effect, so it would be misleading to use a mutable sequence there.\n\n870\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\ngetattr(object, name[, default])\n\nGets the attribute identified by the name string from the object. The main use case is to retrieve attributes (or methods) whose names we don’t know before‐ hand. This may fetch an attribute from the object’s class or from a superclass. If no such attribute exists, getattr raises AttributeError or returns the default value, if given. One great example of using gettatr is in the Cmd.onecmd method in the cmd package of the standard library, where it is used to get and execute a user-defined command.\n\nhasattr(object, name)\n\nReturns True if the named attribute exists in the object, or can be somehow fetched through it (by inheritance, for example). The documentation explains: “This is implemented by calling getattr(object, name) and seeing whether it raises an AttributeError or not.”\n\nsetattr(object, name, value)\n\nAssigns the value to the named attribute of object, if the object allows it. This may create a new attribute or overwrite an existing one.\n\nvars([object])\n\nReturns the __dict__ of object; vars can’t deal with instances of classes that define __slots__ and don’t have a __dict__ (contrast with dir, which handles such instances). Without an argument, vars() does the same as locals(): returns a dict representing the local scope.\n\nSpecial Methods for Attribute Handling When implemented in a user-defined class, the special methods listed here handle attribute retrieval, setting, deletion, and listing.\n\nAttribute access using either dot notation or the built-in functions getattr, hasattr, and setattr triggers the appropriate special methods listed here. Reading and writ‐ ing attributes directly in the instance __dict__ does not trigger these special methods —and that’s the usual way to bypass them if needed.\n\nSection “3.3.11. Special method lookup” of the “Data model” chapter warns:\n\nFor custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary.\n\nIn other words, assume that the special methods will be retrieved on the class itself, even when the target of the action is an instance. For this reason, special methods are not shadowed by instance attributes with the same name.\n\nIn the following examples, assume there is a class named Class, obj is an instance of Class, and attr is an attribute of obj.\n\nEssential Attributes and Functions for Attribute Handling\n\n|\n\n871",
      "page_number": 865
    },
    {
      "number": 44,
      "title": "Segment 44 (pages 886-909)",
      "start_page": 886,
      "end_page": 909,
      "detection_method": "synthetic",
      "content": "For every one of these special methods, it doesn’t matter if the attribute access is done using dot notation or one of the built-in functions listed in “Built-In Functions for Attribute Handling” on page 870. For example, both obj.attr and getattr(obj, 'attr', 42) trigger Class.__getattribute__(obj, 'attr').\n\n__delattr__(self, name)\n\nAlways called when there is an attempt to delete an attribute using the del state‐ ment; e.g., del obj.attr triggers Class.__delattr__(obj, 'attr'). If attr is a property, its deleter method is never called if the class implements __delattr__.\n\n__dir__(self)\n\nCalled when dir is invoked on the object, to provide a listing of attributes; e.g., dir(obj) triggers Class.__dir__(obj). Also used by tab-completion in all modern Python consoles.\n\n__getattr__(self, name)\n\nCalled only when an attempt to retrieve the named attribute fails, after the obj, Class, and its superclasses are searched. The expressions obj.no_such_attr, get attr(obj, 'no_such_attr'), and hasattr(obj, 'no_such_attr') may trigger Class.__getattr__(obj, 'no_such_attr'), but only if an attribute by that name cannot be found in obj or in Class and its superclasses.\n\n__getattribute__(self, name)\n\nAlways called when there is an attempt to retrieve the named attribute directly from Python code (the interpreter may bypass this in some cases, for example, to get the __repr__ method). Dot notation and the getattr and hasattr built-ins trigger this method. __getattr__ is only invoked after __getattribute__, and only when __getattribute__ raises AttributeError. To retrieve attributes of the instance obj without triggering an infinite recursion, implementations of __getattribute__ should use super().__getattribute__(obj, name).\n\n__setattr__(self, name, value)\n\nAlways called when there is an attempt to set the named attribute. Dot notation and the setattr built-in trigger this method; e.g., both obj.attr = 42 and setattr(obj, 'attr', 42) trigger Class.__setattr__(obj, 'attr', 42).\n\nIn practice, because they are unconditionally called and affect prac‐ the __getattribute__ and tically every attribute access, __setattr__ special methods are harder to use correctly than __getattr__, which only handles nonexisting attribute names. Using properties or descriptors is less error prone than defining these special methods.\n\n872\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nThis concludes our dive into properties, special methods, and other techniques for coding dynamic attributes.\n\nChapter Summary We started our coverage of dynamic attributes by showing practical examples of sim‐ ple classes to make it easier to deal with a JSON dataset. The first example was the FrozenJSON class that converted nested dicts and lists into nested FrozenJSON instan‐ ces and lists of them. The FrozenJSON code demonstrated the use of the __getattr__ special method to convert data structures on the fly, whenever their attributes were read. The last version of FrozenJSON showcased the use of the __new__ constructor method to transform a class into a flexible factory of objects, not limited to instances of itself.\n\nWe then converted the JSON dataset to a dict storing instances of a Record class. The first rendition of Record was a few lines long and introduced the “bunch” idiom: using self.__dict__.update(**kwargs) to build arbitrary attributes from keyword arguments passed to __init__. The second iteration added the Event class, imple‐ menting automatic retrieval of linked records through properties. Computed prop‐ erty values sometimes require caching, and we covered a few ways of doing that.\n\nAfter realizing that @functools.cached_property is not always applicable, we learned about an alternative: combining @property on top of @functools.cache, in that order.\n\nCoverage of properties continued with the LineItem class, where a property was deployed to protect a weight attribute from negative or zero values that make no business sense. After a deeper look at property syntax and semantics, we created a property factory to enforce the same validation on weight and price, without coding multiple getters and setters. The property factory leveraged subtle concepts—such as closures, and instance attribute overriding by properties—to provide an elegant generic solution using the same number of lines as a single hand-coded property definition.\n\nFinally, we had a brief look at handling attribute deletion with properties, followed by an overview of the key special attributes, built-in functions, and special methods that support attribute metaprogramming in the core Python language.\n\nFurther Reading The official documentation for the attribute handling and introspection built-in functions is Chapter 2, “Built-in Functions” of The Python Standard Library. The related special methods and the __slots__ special attribute are documented in The Python Language Reference in “3.3.2. Customizing attribute access”. The semantics of\n\nChapter Summary\n\n|\n\n873\n\nhow special methods are invoked bypassing instances is explained in “3.3.9. Special method lookup”. In Chapter 4, “Built-in Types,” of The Python Standard Library, “4.13. Special Attributes” covers __class__ and __dict__ attributes.\n\nPython Cookbook, 3rd ed., by David Beazley and Brian K. Jones (O’Reilly) has several recipes covering the topics of this chapter, but I will highlight three that are outstand‐ ing: “Recipe 8.8. Extending a Property in a Subclass” addresses the thorny issue of overriding the methods inside a property inherited from a superclass; “Recipe 8.15. Delegating Attribute Access” implements a proxy class showcasing most special methods from “Special Methods for Attribute Handling” on page 871 in this book; and the awesome “Recipe 9.21. Avoiding Repetitive Property Methods,” which was the basis for the property factory function presented in Example 22-28.\n\nPython in a Nutshell, 3rd ed., by Alex Martelli, Anna Ravenscroft, and Steve Holden (O’Reilly) is rigorous and objective. They devote only three pages to properties, but that’s because the book follows an axiomatic presentation style: the preceding 15 pages or so provide a thorough description of the semantics of Python classes from the ground up, including descriptors, which are how properties are actually imple‐ mented under the hood. So by the time Martelli et al., get to properties, they pack a lot of insights in those three pages—including what I selected to open this chapter.\n\nBertrand Meyer—quoted in the Uniform Access Principle definition in this chapter opening—pioneered the Design by Contract methodology, designed the Eiffel lan‐ guage, and wrote the excellent Object-Oriented Software Construction, 2nd ed. (Pear‐ son). The first six chapters provide one of the best conceptual introductions to OO analysis and design I’ve seen. Chapter 11 presents Design by Contract, and Chapter 35 offers Meyer’s assessments of some influential object-oriented languages: Simula, Smalltalk, CLOS (the Common Lisp Object System), Objective-C, C++, and Java, with brief comments on some others. Only in the last page of the book does he reveal that the highly readable “notation” he uses as pseudocode is Eiffel.\n\n874\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nSoapbox Meyer’s Uniform Access Principle is aesthetically appealing. As a programmer using an API, I shouldn’t have to care whether product.price simply fetches a data attribute or performs a computation. As a consumer and a citizen, I do care: in e- commerce today the value of product.price often depends on who is asking, so it’s certainly not a mere data attribute. In fact, it’s common practice that the price is lower if the query comes from outside the store—say, from a price-comparison engine. This effectively punishes loyal customers who like to browse within a particu‐ lar store. But I digress.\n\nThe previous digression does raise a relevant point for programming: although the Uniform Access Principle makes perfect sense in an ideal world, in reality, users of an API may need to know whether reading product.price is potentially too expensive or time-consuming. That’s a problem with programming abstractions in general: they make it hard to reason about the runtime cost of evaluating an expression. On the other hand, abstractions let users accomplish more with less code. It’s a trade-off. As usual in matters of software engineering, Ward Cunningham’s original wiki hosts insightful arguments about the merits of the Uniform Access Principle.\n\nIn object-oriented programming languages, application or violations of the Uniform Access Principle often revolve around the syntax of reading public data attributes ver‐ sus invoking getter/setter methods.\n\nSmalltalk and Ruby address this issue in a simple and elegant way: they don’t support public data attributes at all. Every instance attribute in these languages is private, so every access to them must be through methods. But their syntax makes this painless: in Ruby, product.price invokes the price getter; in Smalltalk, it’s simply product price.\n\nAt the other end of the spectrum, the Java language allows the programmer to choose among four access-level modifiers—including the no-name default that the Java Tutorial calls “package-private.”\n\nThe general practice does not agree with the syntax established by the Java designers, though. Everybody in Java-land agrees that attributes should be private, and you must spell it out every time, because it’s not the default. When all attributes are pri‐ vate, all access to them from outside the class must go through accessors. Java IDEs include shortcuts for generating accessor methods automatically. Unfortunately, the IDE is not so helpful when you must read the code six months later. It’s up to you to wade through a sea of do-nothing accessors to find those that add value by imple‐ menting some business logic.\n\nFurther Reading\n\n|\n\n875\n\nAlex Martelli speaks for the majority of the Python community when he calls acces‐ sors “goofy idioms” and then provides these examples that look very different but do the same thing:14\n\nsomeInstance.widgetCounter += 1 # rather than... someInstance.setWidgetCounter(someInstance.getWidgetCounter() + 1)\n\nSometimes when designing APIs, I’ve wondered whether every method that does not take an argument (besides self), returns a value (other than None), and is a pure function (i.e., has no side effects) should be replaced by a read-only property. In this chapter, the LineItem.subtotal method (as in Example 22-27) would be a good can‐ didate to become a read-only property. Of course, this excludes methods that are designed to change the object, such as my_list.clear(). It would be a terrible idea to turn that into a property, so that merely accessing my_list.clear would delete the contents of the list!\n\nIn the Pingo GPIO library, which I coauthored (mentioned in “The __missing__ Method” on page 91), much of the user-level API is based on properties. For example, to read the current value of an analog pin, the user writes pin.value, and setting a digital pin mode is written as pin.mode = OUT. Behind the scenes, reading an analog pin value or setting a digital pin mode may involve a lot of code, depending on the specific board driver. We decided to use properties in Pingo because we want the API to be comfortable to use even in interactive environments like a Jupyter Notebook, and we feel pin.mode = OUT is easier on the eyes and on the fingers than pin.set_mode(OUT).\n\nAlthough I find the Smalltalk and Ruby solution cleaner, I think the Python approach makes more sense than the Java one. We are allowed to start simple, coding data members as public attributes, because we know they can always be wrapped by prop‐ erties (or descriptors, which we’ll talk about in the next chapter).\n\n__new__ Is Better than new\n\nAnother example of the Uniform Access Principle (or a variation of it) is the fact that function calls and object instantiation use the same syntax in Python: my_obj = foo(), where foo may be a class or any other callable.\n\nOther languages influenced by C++ syntax have a new operator that makes instantia‐ tion look different than a call. Most of the time, the user of an API doesn’t care whether foo is a function or a class. For years I was under the impression that property was a function. In normal usage, it makes no difference.\n\n14 Alex Martelli, Python in a Nutshell, 2nd ed. (O’Reilly), p. 101.\n\n876\n\n|\n\nChapter 22: Dynamic Attributes and Properties\n\nThere are many good reasons for replacing constructors with factories.15 A popular motive is limiting the number of instances by returning previously built ones (as in the Singleton pattern). A related use is caching expensive object construction. Also, sometimes it’s convenient to return objects of different types, depending on the argu‐ ments given.\n\nCoding a constructor is simpler; providing a factory adds flexibility at the expense of more code. In languages that have a new operator, the designer of an API must decide in advance whether to stick with a simple constructor or invest in a factory. If the ini‐ tial choice is wrong, the correction may be costly—all because new is an operator.\n\nSometimes it may also be convenient to go the other way, and replace a simple func‐ tion with a class.\n\nIn Python, classes and functions are interchangeable in many situations. Not only because there’s no new operator, but also because there is the __new__ special method, which can turn a class into a factory producing objects of different kinds (as we saw in “Flexible Object Creation with __new__” on page 843) or returning prebuilt instances instead of creating a new one every time.\n\nThis function-class duality would be easier to leverage if PEP 8 — Style Guide for Python Code did not recommend CamelCase for class names. On the other hand, dozens of classes in the standard library have lowercase names (e.g., property, str, defaultdict, etc.). So maybe the use of lowercase class names is a feature, and not a bug. But however we look at it, the inconsistent capitalization of classes in the Python standard library poses a usability problem.\n\nAlthough calling a function is not different from calling a class, it’s good to know which is which because of another thing we can do with a class: subclassing. So I per‐ sonally use CamelCase in every class that I code, and I wish all classes in the Python standard library used the same convention. I am looking at you, collections.Order edDict and collections.defaultdict.\n\n15 The reasons I am about to mention are given in the Dr. Dobbs Journal article titled “Java’s new Considered\n\nHarmful”, by Jonathan Amsterdam and in “Consider static factory methods instead of constructors,” which is Item 1 of the award-winning book Effective Java, 3rd ed., by Joshua Bloch (Addison-Wesley).\n\nFurther Reading\n\n|\n\n877\n\nCHAPTER 23 Attribute Descriptors\n\nLearning about descriptors not only provides access to a larger toolset, it creates a deeper understanding of how Python works and an appreciation for the elegance of its design.\n\n— Raymond Hettinger, Python core developer and guru1\n\nDescriptors are a way of reusing the same access logic in multiple attributes. For example, field types in ORMs, such as the Django ORM and SQLAlchemy, are descriptors, managing the flow of data from the fields in a database record to Python object attributes and vice versa.\n\nA descriptor is a class that implements a dynamic protocol consisting of the __get__, __set__, and __delete__ methods. The property class implements the full descrip‐ tor protocol. As usual with dynamic protocols, partial implementations are OK. In fact, most descriptors we see in real code implement only __get__ and __set__, and many implement only one of these methods.\n\nDescriptors are a distinguishing feature of Python, deployed not only at the applica‐ tion level but also in the language infrastructure. User-defined functions are descrip‐ tors. We’ll see how the descriptor protocol allows methods to operate as bound or unbound methods, depending on how they are called.\n\nUnderstanding descriptors is key to Python mastery. This is what this chapter is about.\n\nIn this chapter we’ll refactor the bulk food example we first saw in “Using a Property for Attribute Validation” on page 857, replacing properties with descriptors. This will make it easier to reuse the attribute validation logic across different classes. We’ll\n\n1 Raymond Hettinger, Descriptor HowTo Guide.\n\n879\n\ntackle the concepts of overriding and nonoverriding descriptors, and realize that Python functions are descriptors. Finally we’ll see some tips about implementing descriptors.\n\nWhat’s New in This Chapter The Quantity descriptor example in “LineItem Take #4: Automatic Naming of Stor‐ age Attributes” on page 887 was dramatically simplified thanks to the __set_name__ special method added to the descriptor protocol in Python 3.6.\n\nI removed the property factory example formerly in “LineItem Take #4: Automatic Naming of Storage Attributes” on page 887 because it became irrelevant: the point was to show an alternative way of solving the Quantity problem, but with the addition of __set_name__, the descriptor solution becomes much simpler.\n\nThe AutoStorage class that used to appear in “LineItem Take #5: A New Descriptor Type” on page 889 is also gone because __set_name__ made it obsolete.\n\nDescriptor Example: Attribute Validation As we saw in “Coding a Property Factory” on page 865, a property factory is a way to avoid repetitive coding of getters and setters by applying functional programming patterns. A property factory is a higher-order function that creates a parameterized set of accessor functions and builds a custom property instance from them, with clo‐ sures to hold settings like the storage_name. The object-oriented way of solving the same problem is a descriptor class.\n\nWe’ll continue the series of LineItem examples where we left off, in “Coding a Prop‐ erty Factory” on page 865, by refactoring the quantity property factory into a Quan tity descriptor class. This will make it easier to use.\n\nLineItem Take #3: A Simple Descriptor As we said in the introduction, a class implementing a __get__, a __set__, or a __delete__ method is a descriptor. You use a descriptor by declaring instances of it as class attributes of another class.\n\nWe’ll create a Quantity descriptor, and the LineItem class will use two instances of Quantity: one for managing the weight attribute, the other for price. A diagram helps, so take a look at Figure 23-1.\n\n880\n\n|\n\nChapter 23: Attribute Descriptors\n\nFigure 23-1. UML class diagram for LineItem using a descriptor class named Quan tity. Underlined attributes in UML are class attributes. Note that weight and price are instances of Quantity attached to the LineItem class, but LineItem instances also have their own weight and price attributes where those values are stored.\n\nNote that the word weight appears twice in Figure 23-1, because there are really two distinct attributes named weight: one is a class attribute of LineItem, the other is an instance attribute that will exist in each LineItem object. This also applies to price.\n\nTerms to understand descriptors\n\nImplementing and using descriptors involves several components, and it is useful to be precise when naming those components. I will use the following terms and defini‐ tions as I describe the examples in this chapter. They will be easier to understand once you see the code, but I wanted to put the definitions up front so you can refer back to them when needed.\n\nDescriptor class\n\nA class implementing the descriptor protocol. That’s Quantity in Figure 23-1.\n\nManaged class\n\nThe class where the descriptor instances are declared as class attributes. In Figure 23-1, LineItem is the managed class.\n\nDescriptor instance\n\nEach instance of a descriptor class, declared as a class attribute of the managed class. In Figure 23-1, each descriptor instance is represented by a composition arrow with an underlined name (the underline means class attribute in UML). The black diamonds touch the LineItem class, which contains the descriptor instances.\n\nDescriptor Example: Attribute Validation\n\n|\n\n881\n\nManaged instance\n\nOne instance of the managed class. In this example, LineItem instances are the managed instances (they are not shown in the class diagram).\n\nStorage attribute\n\nAn attribute of the managed instance that holds the value of a managed attribute for that particular instance. In Figure 23-1, the LineItem instance attributes weight and price are the storage attributes. They are distinct from the descriptor instances, which are always class attributes.\n\nManaged attribute\n\nA public attribute in the managed class that is handled by a descriptor instance, with values stored in storage attributes. In other words, a descriptor instance and a storage attribute provide the infrastructure for a managed attribute.\n\nIt’s important to realize that Quantity instances are class attributes of LineItem. This crucial point is highlighted by the mills and gizmos in Figure 23-2.\n\nFigure 23-2. UML class diagram annotated with MGN (Mills & Gizmos Notation): classes are mills that produce gizmos—the instances. The Quantity mill produces two gizmos with round heads, which are attached to the LineItem mill: weight and price. The LineItem mill produces rectangular gizmos that have their own weight and price attributes where those values are stored.\n\n882\n\n|\n\nChapter 23: Attribute Descriptors\n\nIntroducing Mills & Gizmos Notation After explaining descriptors many times, I realized UML is not very good at showing relationships involving classes and instances, like the relationship between a managed class and the descriptor instances.2 So I invented my own “language,” the Mills & Giz‐ mos Notation (MGN), which I use to annotate UML diagrams.\n\nMGN is designed to make very clear the distinction between classes and instances. See Figure 23-3. In MGN, a class is drawn as a “mill,” a complicated machine that produces gizmos. Classes/mills are always machines with levers and dials. The gizmos are the instances, and they look much simpler. When this book is rendered in color, gizmos have the same color as the mill that made it.\n\nFigure 23-3. MGN sketch showing the LineItem class making three instances, and Quan tity making two. One instance of Quantity is retrieving a value stored in a LineItem instance.\n\nFor this example, I drew LineItem instances as rows in a tabular invoice, with three cells representing the three attributes (description, weight, and price). Because Quantity instances are descriptors, they have a magnifying glass to __get__ values, and a claw to __set__ values. When we get to metaclasses, you’ll thank me for these doodles.\n\nEnough doodling for now. Here is the code: Example 23-1 shows the Quantity descriptor class, and Example 23-2 lists a new LineItem class using two instances of Quantity.\n\n2 Classes and instances are drawn as rectangles in UML class diagrams. There are visual differences, but instan‐\n\nces are rarely shown in class diagrams, so developers may not recognize them as such.\n\nDescriptor Example: Attribute Validation\n\n|\n\n883\n\nExample 23-1. bulkfood_v3.py: Quantity descriptor does not accept negative values\n\nclass Quantity:\n\ndef __init__(self, storage_name): self.storage_name = storage_name\n\ndef __set__(self, instance, value): if value > 0: instance.__dict__[self.storage_name] = value else: msg = f'{self.storage_name} must be > 0' raise ValueError(msg)\n\ndef __get__(self, instance, owner): return instance.__dict__[self.storage_name]\n\nDescriptor is a protocol-based feature; no subclassing is needed to implement one.\n\nEach Quantity instance will have a storage_name attribute: that’s the name of the storage attribute to hold the value in the managed instances.\n\n__set__ is called when there is an attempt to assign to the managed attribute. Here, self is the descriptor instance (i.e., LineItem.weight or LineItem.price), instance is the managed instance (a LineItem instance), and value is the value being assigned.\n\nWe must store the attribute value directly into __dict__; calling set attr (instance, self.storage_name) would trigger the __set__ method again, leading to infinite recursion.\n\nWe need to implement __get__ because the name of the managed attribute may not be the same as the storage_name. The owner argument will be explained shortly.\n\nImplementing __get__ is necessary because a user could write something like this:\n\nclass House: rooms = Quantity('number_of_rooms')\n\nIn the House class, the managed attribute is rooms, but the storage attribute is number_of_rooms. Given a House instance named chaos_manor, reading and writing chaos_manor.rooms goes through the Quantity descriptor instance attached to rooms, but reading and writing chaos_manor.number_of_rooms bypasses the descriptor.\n\n884\n\n|\n\nChapter 23: Attribute Descriptors\n\nNote that __get__ receives three arguments: self, instance, and owner. The owner argument is a reference to the managed class (e.g., LineItem), and it’s useful if you want the descriptor to support retrieving a class attribute—perhaps to emulate Python’s default behavior of retrieving a class attribute when the name is not found in the instance.\n\nIf a managed attribute, such as weight, is retrieved via the class like Line Item.weight, the descriptor __get__ method receives None as the value for the instance argument.\n\nTo support introspection and other metaprogramming tricks by the user, it’s a good practice to make __get__ return the descriptor instance when the managed attribute is accessed through the class. To do that, we’d code __get__ like this:\n\ndef __get__(self, instance, owner): if instance is None: return self else: return instance.__dict__[self.storage_name]\n\nExample 23-2 demonstrates the use of Quantity in LineItem.\n\nExample 23-2. bulkfood_v3.py: Quantity descriptors manage attributes in LineItem\n\nclass LineItem: weight = Quantity('weight') price = Quantity('price')\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\nThe first descriptor instance will manage the weight attribute.\n\nThe second descriptor instance will manage the price attribute.\n\nThe rest of the class body is as simple and clean as the original code in bulk‐ food_v1.py (Example 22-19).\n\nDescriptor Example: Attribute Validation\n\n|\n\n885\n\nThe code in Example 23-2 works as intended, preventing the sale of truffles for $0:3\n\n>>> truffle = LineItem('White truffle', 100, 0) Traceback (most recent call last): ... ValueError: value must be > 0\n\nWhen coding descriptor __get__ and __set__ methods, keep in mind what the self and instance arguments mean: self is the descriptor instance, and instance is the managed instance. Descriptors managing instance attributes should store values in the managed instances. That’s why Python provides the instance argument to the descriptor methods.\n\nIt may be tempting, but wrong, to store the value of each managed attribute in the descriptor instance itself. In other words, in the __set__ method, instead of coding:\n\ninstance.__dict__[self.storage_name] = value\n\nthe tempting, but bad, alternative would be:\n\nself.__dict__[self.storage_name] = value\n\nTo understand why this would be wrong, think about the meaning of the first two arguments to __set__: self and instance. Here, self is the descriptor instance, which is actually a class attribute of the managed class. You may have thousands of LineItem instances in memory at one time, but you’ll only have two instances of the descriptors: the class attributes LineItem.weight and LineItem.price. So anything you store in the descriptor instances themselves is actually part of a LineItem class attribute, and therefore is shared among all LineItem instances.\n\nA drawback of Example 23-2 is the need to repeat the names of the attributes when the descriptors are instantiated in the managed class body. It would be nice if the LineItem class could be declared like this:\n\nclass LineItem: weight = Quantity() price = Quantity()\n\n# remaining methods as before\n\nAs it stands, Example 23-2 requires naming each Quantity explicitly, which is not only inconvenient but dangerous. If a programmer copying and pasting code forgets to edit both names and writes something like price = Quantity('weight'), the\n\n3 White truffles cost thousands of dollars per pound. Disallowing the sale of truffles for $0.01 is left as an exer‐ cise for the enterprising reader. I know a person who actually bought an $1,800 encyclopedia of statistics for $18 because of an error in an online store (not Amazon.com in this case).\n\n886\n\n|\n\nChapter 23: Attribute Descriptors\n\nprogram will misbehave badly, clobbering the value of weight whenever the price is set.\n\nThe problem is that—as we saw in Chapter 6—the righthand side of an assignment is executed before the variable exists. The expression Quantity() is evaluated to create a descriptor instance, and there is no way the code in the Quantity class can guess the name of the variable to which the descriptor will be bound (e.g., weight or price).\n\nThankfully, the descriptor protocol now supports the aptly named __set_name__ special method. We’ll see how to use it next.\n\nAutomatic naming of a descriptor storage attribute used to be a thorny issue. In the first edition of Fluent Python, I devoted several pages and lines of code in this chapter and the next to presenting different solutions, including the use of a class decorator, and then metaclasses in Chapter 24. This was greatly simplified in Python 3.6.\n\nLineItem Take #4: Automatic Naming of Storage Attributes To avoid retyping the attribute name in the descriptor instances, we’ll implement __set_name__ to set the storage_name of each Quantity instance. The __set_name__ special method was added to the descriptor protocol in Python 3.6. The interpreter calls __set_name__ on each descriptor it finds in a class body—if the descriptor implements it.4\n\nIn Example 23-3, the LineItem descriptor class doesn’t need an __init__. Instead, __set_item__ saves the name of the storage attribute.\n\nExample 23-3. bulkfood_v4.py: __set_name__ sets the name for each Quantity descriptor instance\n\nclass Quantity:\n\ndef __set_name__(self, owner, name): self.storage_name = name\n\ndef __set__(self, instance, value): if value > 0: instance.__dict__[self.storage_name] = value\n\n4 More precisely, __set_name__ is called by type.__new__—the constructor of objects representing classes. The type built-in is actually a metaclass, the default class of user-defined classes. This is hard to grasp at first, but rest assured: Chapter 24 is devoted to the dynamic configuration of classes, including the concept of metaclasses.\n\nDescriptor Example: Attribute Validation\n\n|\n\n887\n\nelse: msg = f'{self.storage_name} must be > 0' raise ValueError(msg)\n\n# no __get__ needed\n\nclass LineItem: weight = Quantity() price = Quantity()\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\nself is the descriptor instance (not the managed instance), owner is the managed class, and name is the name of the attribute of owner to which this descriptor instance was assigned in the class body of owner.\n\nThis is what the __init__ did in Example 23-1.\n\nThe __set__ method here is exactly the same as in Example 23-1.\n\nImplementing __get__ is not necessary because the name of the storage attribute matches the name of the managed attribute. The expression product.price gets the price attribute directly from the LineItem instance.\n\nNow we don’t need to pass the managed attribute name to the Quantity con‐ structor. That was the goal for this version.\n\nLooking at Example 23-3, you may think that’s a lot of code just for managing a cou‐ ple of attributes, but it’s important to realize that the descriptor logic is now abstrac‐ ted into a separate code unit: the Quantity class. Usually we do not define a descriptor in the same module where it’s used, but in a separate utility module designed to be used across the application—even in many applications, if you are developing a library or framework.\n\nWith this in mind, Example 23-4 better represents the typical usage of a descriptor.\n\nExample 23-4. bulkfood_v4c.py: LineItem definition uncluttered; the Quantity descriptor class now resides in the imported model_v4c module\n\nimport model_v4c as model\n\n888\n\n|\n\nChapter 23: Attribute Descriptors\n\nclass LineItem: weight = model.Quantity() price = model.Quantity()\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\nImport the model_v4c module where Quantity is implemented.\n\nPut model.Quantity to use.\n\nDjango users will notice that Example 23-4 looks a lot like a model definition. It’s no coincidence: Django model fields are descriptors.\n\nBecause descriptors are implemented as classes, we can leverage inheritance to reuse some of the code we have for new descriptors. That’s what we’ll do in the following section.\n\nLineItem Take #5: A New Descriptor Type The imaginary organic food store hits a snag: somehow a line item instance was cre‐ ated with a blank description, and the order could not be fulfilled. To prevent that, we’ll create a new descriptor, NonBlank. As we design NonBlank, we realize it will be very much like the Quantity descriptor, except for the validation logic.\n\nThis prompts a refactoring, producing Validated, an abstract class that overrides the __set__ method, calling a validate method that must be implemented by sub‐ classes.\n\nWe’ll then rewrite Quantity, and implement NonBlank by inheriting from Validated and just coding the validate methods.\n\nThe relationship among Validated, Quantity, and NonBlank is an application of the template method as described in the Design Patterns classic:\n\nA template method defines an algorithm in terms of abstract operations that subclasses override to provide concrete behavior.5\n\n5 Gamma et al., Design Patterns: Elements of Reusable Object-Oriented Software, p. 326.\n\nDescriptor Example: Attribute Validation\n\n|\n\n889\n\nIn Example 23-5, Validated.__set__ is the template method and self.validate is the abstract operation.\n\nExample 23-5. model_v5.py: the Validated ABC\n\nimport abc\n\nclass Validated(abc.ABC):\n\ndef __set_name__(self, owner, name): self.storage_name = name\n\ndef __set__(self, instance, value): value = self.validate(self.storage_name, value) instance.__dict__[self.storage_name] = value\n\n@abc.abstractmethod def validate(self, name, value): \"\"\"return validated value or raise ValueError\"\"\"\n\n__set__ delegates validation to the validate method…\n\n…then uses the returned value to update the stored value.\n\nvalidate is an abstract method; this is the template method.\n\nAlex Martelli prefers to call this design pattern Self-Delegation, and I agree it’s a more descriptive name: the first line of __set__ self-delegates to validate.6\n\nThe concrete Validated subclasses in this example are Quantity and NonBlank, shown in Example 23-6.\n\nExample 23-6. model_v5.py: Quantity and NonBlank, concrete Validated subclasses\n\nclass Quantity(Validated): \"\"\"a number greater than zero\"\"\"\n\ndef validate(self, name, value): if value <= 0: raise ValueError(f'{name} must be > 0') return value\n\nclass NonBlank(Validated): \"\"\"a string with at least one non-space character\"\"\"\n\n6 Slide #50 of Alex Martelli’s “Python Design Patterns” talk. Highly recommended.\n\n890\n\n|\n\nChapter 23: Attribute Descriptors\n\ndef validate(self, name, value): value = value.strip() if not value: raise ValueError(f'{name} cannot be blank') return value\n\nImplementation of the template method required by the Validated.validate abstract method.\n\nIf nothing is left after leading and trailing blanks are stripped, reject the value.\n\nRequiring the concrete validate methods to return the validated value gives them an opportunity to clean up, convert, or normalize the data received. In this case, value is returned without leading or trailing blanks.\n\nUsers of model_v5.py don’t need to know all these details. What matters is that they get to use Quantity and NonBlank to automate the validation of instance attributes. See the latest LineItem class in Example 23-7.\n\nExample 23-7. bulkfood_v5.py: LineItem using Quantity and NonBlank descriptors\n\nimport model_v5 as model\n\nclass LineItem: description = model.NonBlank() weight = model.Quantity() price = model.Quantity()\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\nImport the model_v5 module, giving it a friendlier name.\n\nPut model.NonBlank to use. The rest of the code is unchanged.\n\nThe LineItem examples we’ve seen in this chapter demonstrate a typical use of descriptors to manage data attributes. Descriptors like Quantity are called overriding descriptors because its __set__ method overrides (i.e., intercepts and overrules) the setting of an instance attribute by the same name in the managed instance. However, there are also nonoverriding descriptors. We’ll explore this distinction in detail in the next section.\n\nDescriptor Example: Attribute Validation\n\n|\n\n891\n\nOverriding Versus Nonoverriding Descriptors Recall that there is an important asymmetry in the way Python handles attributes. Reading an attribute through an instance normally returns the attribute defined in the instance, but if there is no such attribute in the instance, a class attribute will be retrieved. On the other hand, assigning to an attribute in an instance normally creates the attribute in the instance, without affecting the class at all.\n\nThis asymmetry also affects descriptors, in effect creating two broad categories of descriptors, depending on whether the __set__ method is implemented. If __set__ is present, the class is an overriding descriptor; otherwise, it is a nonoverriding descriptor. These terms will make sense as we study descriptor behaviors in the next examples.\n\nObserving the different descriptor categories requires a few classes, so we’ll use the code in Example 23-8 as our test bed for the following sections.\n\nEvery __get__ and __set__ method in Example 23-8 calls print_args so their invocations are displayed in a readable way. Understanding print_args and the auxiliary functions cls_name and display is not important, so don’t get distracted by them.\n\nExample 23-8. descriptorkinds.py: simple classes for studying descriptor overriding behaviors\n\n### auxiliary functions for display only ###\n\ndef cls_name(obj_or_cls): cls = type(obj_or_cls) if cls is type: cls = obj_or_cls return cls.__name__.split('.')[-1]\n\ndef display(obj): cls = type(obj) if cls is type: return f'<class {obj.__name__}>' elif cls in [type(None), int]: return repr(obj) else: return f'<{cls_name(obj)} object>'\n\ndef print_args(name, *args): pseudo_args = ', '.join(display(x) for x in args) print(f'-> {cls_name(args[0])}.__{name}__({pseudo_args})')\n\n### essential classes for this example ###\n\n892\n\n|\n\nChapter 23: Attribute Descriptors\n\nclass Overriding: \"\"\"a.k.a. data descriptor or enforced descriptor\"\"\"\n\ndef __get__(self, instance, owner): print_args('get', self, instance, owner)\n\ndef __set__(self, instance, value): print_args('set', self, instance, value)\n\nclass OverridingNoGet: \"\"\"an overriding descriptor without ``__get__``\"\"\"\n\ndef __set__(self, instance, value): print_args('set', self, instance, value)\n\nclass NonOverriding: \"\"\"a.k.a. non-data or shadowable descriptor\"\"\"\n\ndef __get__(self, instance, owner): print_args('get', self, instance, owner)\n\nclass Managed: over = Overriding() over_no_get = OverridingNoGet() non_over = NonOverriding()\n\ndef spam(self): print(f'-> Managed.spam({display(self)})')\n\nAn overriding descriptor class with __get__ and __set__.\n\nThe print_args function is called by every descriptor method in this example.\n\nAn overriding descriptor without a __get__ method.\n\nNo __set__ method here, so this is a nonoverriding descriptor.\n\nThe managed class, using one instance of each of the descriptor classes.\n\nThe spam method is here for comparison, because methods are also descriptors.\n\nIn the following sections, we will examine the behavior of attribute reads and writes on the Managed class, and one instance of it, going through each of the different descriptors defined.\n\nOverriding Versus Nonoverriding Descriptors\n\n|\n\n893\n\nOverriding Descriptors A descriptor that implements the __set__ method is an overriding descriptor, because although it is a class attribute, a descriptor implementing __set__ will override attempts to assign to instance attributes. This is how Example 23-3 was implemented. Properties are also overriding descriptors: if you don’t provide a setter function, the default __set__ from the property class will raise AttributeError to signal that the attribute is read-only. Given the code in Example 23-8, experiments with an overrid‐ ing descriptor can be seen in Example 23-9.\n\nPython contributors and authors use different terms when discus‐ sing these concepts. I adopted “overriding descriptor” from the book Python in a Nutshell. The official Python documentation uses “data descriptor,” but “overriding descriptor” highlights the special behavior. Overriding descriptors are also called “enforced descrip‐ tors.” Synonyms for nonoverriding descriptors include “nondata descriptors” or “shadowable descriptors.”\n\nExample 23-9. Behavior of an overriding descriptor\n\n>>> obj = Managed() >>> obj.over -> Overriding.__get__(<Overriding object>, <Managed object>, <class Managed>) >>> Managed.over -> Overriding.__get__(<Overriding object>, None, <class Managed>) >>> obj.over = 7 -> Overriding.__set__(<Overriding object>, <Managed object>, 7) >>> obj.over -> Overriding.__get__(<Overriding object>, <Managed object>, <class Managed>) >>> obj.__dict__['over'] = 8 >>> vars(obj) {'over': 8} >>> obj.over -> Overriding.__get__(<Overriding object>, <Managed object>, <class Managed>)\n\nCreate Managed object for testing.\n\nobj.over triggers the descriptor __get__ method, passing the managed instance obj as the second argument.\n\nManaged.over triggers the descriptor __get__ method, passing None as the sec‐ ond argument (instance).\n\nAssigning to obj.over triggers the descriptor __set__ method, passing the value 7 as the last argument.\n\n894\n\n|\n\nChapter 23: Attribute Descriptors\n\nReading obj.over still invokes the descriptor __get__ method.\n\nBypassing the descriptor, setting a value directly to the obj.__dict__.\n\nVerify that the value is in the obj.__dict__, under the over key.\n\nHowever, even with an instance attribute named over, the Managed.over descriptor still overrides attempts to read obj.over.\n\nOverriding Descriptor Without __get__ Properties and other overriding descriptors, such as Django model fields, implement both __set__ and __get__, but it’s also possible to implement only __set__, as we saw in Example 23-2. In this case, only writing is handled by the descriptor. Reading the descriptor through an instance will return the descriptor object itself because there is no __get__ to handle that access. If a namesake instance attribute is created with a new value via direct access to the instance __dict__, the __set__ method will still override further attempts to set that attribute, but reading that attribute will sim‐ ply return the new value from the instance, instead of returning the descriptor object. In other words, the instance attribute will shadow the descriptor, but only when read‐ ing. See Example 23-10.\n\nExample 23-10. Overriding descriptor without __get__\n\n>>> obj.over_no_get <__main__.OverridingNoGet object at 0x665bcc> >>> Managed.over_no_get <__main__.OverridingNoGet object at 0x665bcc> >>> obj.over_no_get = 7 -> OverridingNoGet.__set__(<OverridingNoGet object>, <Managed object>, 7) >>> obj.over_no_get <__main__.OverridingNoGet object at 0x665bcc> >>> obj.__dict__['over_no_get'] = 9 >>> obj.over_no_get 9 >>> obj.over_no_get = 7 -> OverridingNoGet.__set__(<OverridingNoGet object>, <Managed object>, 7) >>> obj.over_no_get 9\n\nThis overriding descriptor doesn’t have a __get__ method, so reading obj.over_no_get retrieves the descriptor instance from the class.\n\nThe same thing happens if we retrieve the descriptor instance directly from the managed class.\n\nOverriding Versus Nonoverriding Descriptors\n\n|\n\n895\n\nTrying to set a value to obj.over_no_get invokes the __set__ descriptor method.\n\nBecause our __set__ doesn’t make changes, reading obj.over_no_get again retrieves the descriptor instance from the managed class.\n\nGoing through the instance __dict__ to set an instance attribute named over_no_get.\n\nNow that over_no_get instance attribute shadows the descriptor, but only for reading.\n\nTrying to assign a value to obj.over_no_get still goes through the descriptor set.\n\nBut for reading, that descriptor is shadowed as long as there is a namesake instance attribute.\n\nNonoverriding Descriptor A descriptor that does not implement __set__ is a nonoverriding descriptor. Setting an instance attribute with the same name will shadow the descriptor, rendering it ineffective for handling that attribute in that specific instance. Methods and @func tools.cached_property descriptors. implemented Example 23-11 shows the operation of a nonoverriding descriptor.\n\nare\n\nas nonoverriding\n\nExample 23-11. Behavior of a nonoverriding descriptor\n\n>>> obj = Managed() >>> obj.non_over -> NonOverriding.__get__(<NonOverriding object>, <Managed object>, <class Managed>) >>> obj.non_over = 7 >>> obj.non_over 7 >>> Managed.non_over -> NonOverriding.__get__(<NonOverriding object>, None, <class Managed>) >>> del obj.non_over >>> obj.non_over -> NonOverriding.__get__(<NonOverriding object>, <Managed object>, <class Managed>)\n\nobj.non_over triggers the descriptor __get__ method, passing obj as the second argument.\n\nManaged.non_over is a nonoverriding descriptor, so there is no __set__ to inter‐ fere with this assignment.\n\n896\n\n|\n\nChapter 23: Attribute Descriptors",
      "page_number": 886
    },
    {
      "number": 45,
      "title": "Segment 45 (pages 910-929)",
      "start_page": 910,
      "end_page": 929,
      "detection_method": "synthetic",
      "content": "The obj now has an instance attribute named non_over, which shadows the namesake descriptor attribute in the Managed class.\n\nThe Managed.non_over descriptor is still there, and catches this access via the class.\n\nIf the non_over instance attribute is deleted…\n\n…then reading obj.non_over hits the __get__ method of the descriptor in the class, but note that the second argument is the managed instance.\n\nIn the previous examples, we saw several assignments to an instance attribute with the same name as a descriptor, and different results according to the presence of a __set__ method in the descriptor.\n\nThe setting of attributes in the class cannot be controlled by descriptors attached to the same class. In particular, this means that the descriptor attributes themselves can be clobbered by assigning to the class, as the next section explains.\n\nOverwriting a Descriptor in the Class Regardless of whether a descriptor is overriding or not, it can be overwritten by assignment to the class. This is a monkey-patching technique, but in Example 23-12 the descriptors are replaced by integers, which would effectively break any class that depended on the descriptors for proper operation.\n\nExample 23-12. Any descriptor can be overwritten on the class itself\n\n>>> obj = Managed() >>> Managed.over = 1 >>> Managed.over_no_get = 2 >>> Managed.non_over = 3 >>> obj.over, obj.over_no_get, obj.non_over (1, 2, 3)\n\nCreate a new instance for later testing.\n\nOverwrite the descriptor attributes in the class.\n\nThe descriptors are really gone.\n\nExample 23-12 reveals another asymmetry regarding reading and writing attributes: although the reading of a class attribute can be controlled by a descriptor with __get__ attached to the managed class, the writing of a class attribute cannot be han‐ dled by a descriptor with __set__ attached to the same class.\n\nOverriding Versus Nonoverriding Descriptors\n\n|\n\n897\n\nIn order to control the setting of attributes in a class, you have to attach descriptors to the class of the class—in other words, the met‐ aclass. By default, the metaclass of user-defined classes is type, and you cannot add attributes to type. But in Chapter 24, we’ll create our own metaclasses.\n\nLet’s now focus on how descriptors are used to implement methods in Python.\n\nMethods Are Descriptors A function within a class becomes a bound method when invoked on an instance because all user-defined functions have a __get__ method, therefore they operate as descriptors when attached to a class. Example 23-13 demonstrates reading the spam method from the Managed class introduced in Example 23-8.\n\nExample 23-13. A method is a nonoverriding descriptor\n\n>>> obj = Managed() >>> obj.spam <bound method Managed.spam of <descriptorkinds.Managed object at 0x74c80c>> >>> Managed.spam <function Managed.spam at 0x734734> >>> obj.spam = 7 >>> obj.spam 7\n\nReading from obj.spam retrieves a bound method object.\n\nBut reading from Managed.spam retrieves a function.\n\nAssigning a value to obj.spam shadows the class attribute, rendering the spam method inaccessible from the obj instance.\n\nFunctions do not implement __set__, therefore they are nonoverriding descriptors, as the last line of Example 23-13 shows.\n\nThe other key takeaway from Example 23-13 is that obj.spam and Managed.spam retrieve different objects. As usual with descriptors, the __get__ of a function returns a reference to itself when the access happens through the managed class. But when the access goes through an instance, the __get__ of the function returns a bound method object: a callable that wraps the function and binds the managed instance (e.g., obj) to the first argument of the function (i.e., self), like the functools.par tial function does (as seen in “Freezing Arguments with functools.partial” on page 247). For a deeper understanding of this mechanism, take a look at Example 23-14.\n\n898\n\n|\n\nChapter 23: Attribute Descriptors\n\nExample 23-14. method_is_descriptor.py: a Text class, derived from UserString\n\nimport collections\n\nclass Text(collections.UserString):\n\ndef __repr__(self): return 'Text({!r})'.format(self.data)\n\ndef reverse(self): return self[::-1]\n\nNow let’s investigate the Text.reverse method. See Example 23-15.\n\nExample 23-15. Experiments with a method\n\n>>> word = Text('forward') >>> word Text('forward') >>> word.reverse() Text('drawrof') >>> Text.reverse(Text('backward')) Text('drawkcab') >>> type(Text.reverse), type(word.reverse) (<class 'function'>, <class 'method'>) >>> list(map(Text.reverse, ['repaid', (10, 20, 30), Text('stressed')])) ['diaper', (30, 20, 10), Text('desserts')] >>> Text.reverse.__get__(word) <bound method Text.reverse of Text('forward')> >>> Text.reverse.__get__(None, Text) <function Text.reverse at 0x101244e18> >>> word.reverse <bound method Text.reverse of Text('forward')> >>> word.reverse.__self__ Text('forward') >>> word.reverse.__func__ is Text.reverse True\n\nThe repr of a Text instance looks like a Text constructor call that would make an equal instance.\n\nThe reverse method returns the text spelled backward.\n\nA method called on the class works as a function.\n\nNote the different types: a function and a method.\n\nMethods Are Descriptors\n\n|\n\n899\n\nText.reverse operates as a function, even working with objects that are not instances of Text.\n\nAny function is a nonoverriding descriptor. Calling its __get__ with an instance retrieves a method bound to that instance.\n\nCalling the function’s __get__ with None as the instance argument retrieves the function itself.\n\nThe expression word.reverse actually invokes Text.reverse.__get__(word), returning the bound method.\n\nThe bound method object has a __self__ attribute holding a reference to the instance on which the method was called.\n\nThe __func__ attribute of the bound method is a reference to the original func‐ tion attached to the managed class.\n\nThe bound method object also has a __call__ method, which handles the actual invocation. This method calls the original function referenced in __func__, passing the __self__ attribute of the method as the first argument. That’s how the implicit binding of the conventional self argument works.\n\nThe way functions are turned into bound methods is a prime example of how descriptors are used as infrastructure in the language.\n\nAfter this deep dive into how descriptors and methods work, let’s go through some practical advice about their use.\n\nDescriptor Usage Tips The following list addresses some practical consequences of the descriptor character‐ istics just described:\n\nUse property to keep it simple\n\nThe property built-in creates overriding descriptors implementing __set__ and __get__ even if you do not define a setter method.7 The default __set__ of a property raises AttributeError: can't set attribute, so a property is the easiest way to create a read-only attribute, avoiding the issue described next.\n\n7 A __delete__ method is also provided by the property decorator, even if no deleter method is defined by\n\nyou.\n\n900\n\n|\n\nChapter 23: Attribute Descriptors\n\nRead-only descriptors require __set__\n\nIf you use a descriptor class to implement a read-only attribute, you must remember to code both __get__ and __set__, otherwise setting a namesake attribute on an instance will shadow the descriptor. The __set__ method of a read-only attribute should just raise AttributeError with a suitable message.8\n\nValidation descriptors can work with __set__ only\n\nIn a descriptor designed only for validation, the __set__ method should check the value argument it gets, and if valid, set it directly in the instance __dict__ using the descriptor instance name as key. That way, reading the attribute with the same name from the instance will be as fast as possible, because it will not require a __get__. See the code for Example 23-3.\n\nCaching can be done efficiently with __get__ only\n\nIf you code just the __get__ method, you have a nonoverriding descriptor. These are useful to make some expensive computation and then cache the result by set‐ ting an attribute by the same name on the instance.9 The namesake instance attribute will shadow the descriptor, so subsequent access to that attribute will fetch it directly from the instance __dict__ and not trigger the descriptor __get__ anymore. The @functools.cached_property decorator actually pro‐ duces a nonoverriding descriptor.\n\nNonspecial methods can be shadowed by instance attributes\n\nBecause functions and methods only implement __get__, they are nonoverriding descriptors. A simple assignment like my_obj.the_method = 7 means that fur‐ ther access to the_method through that instance will retrieve the number 7— without affecting the class or other instances. However, this issue does not inter‐ fere with special methods. The interpreter only looks for special methods in the class itself, in other words, repr(x) is executed as x.__class__.__repr__(x), so a __repr__ attribute defined in x has no effect on repr(x). For the same reason, the existence of an attribute named __getattr__ in an instance will not subvert the usual attribute access algorithm.\n\nThe fact that nonspecial methods can be overridden so easily in instances may sound fragile and error prone, but I personally have never been bitten by this in more than 20 years of Python coding. On the other hand, if you are doing a lot of dynamic\n\n8 Python is not consistent in such messages. Trying to change the c.real attribute of a complex number gets AttributeError: readonly attribute, but an attempt to change c.conjugate (a method of complex), results in AttributeError: 'complex' object attribute 'conjugate' is read-only. Even the spelling of “read-only” is different.\n\n9 However, recall that creating instance attributes after the __init__ method runs defeats the key-sharing memory optimization, as discussed in from “Practical Consequences of How dict Works” on page 102.\n\nDescriptor Usage Tips\n\n|\n\n901\n\nattribute creation, where the attribute names come from data you don’t control (as we did in the earlier parts of this chapter), then you should be aware of this and per‐ haps implement some filtering or escaping of the dynamic attribute names to pre‐ serve your sanity.\n\nThe FrozenJSON class in Example 22-5 is safe from instance attribute shadowing methods because its only methods are special methods and the build class method. Class methods are safe as long as they are always accessed through the class, as I did with FrozenJSON.build in Example 22-5—later replaced by __new__ in Example 22-6. The Record and Event classes presented in “Com‐ puted Properties” on page 845 are also safe: they implement only special methods, static methods, and properties. Properties are overriding descriptors, so they are not shadowed by instance attributes.\n\nTo close this chapter, we’ll cover two features we saw with properties that we have not addressed in the context of descriptors: documentation and handling attempts to delete a managed attribute.\n\nDescriptor Docstring and Overriding Deletion The docstring of a descriptor class is used to document every instance of the descrip‐ tor in the managed class. Figure 23-4 shows the help displays for the LineItem class with the Quantity and NonBlank descriptors from Examples 23-6 and 23-7.\n\nThat is somewhat unsatisfactory. In the case of LineItem, it would be good to add, for example, the information that weight must be in kilograms. That would be trivial with properties, because each property handles a specific managed attribute. But with descriptors, the same Quantity descriptor class is used for weight and price.10\n\nThe second detail we discussed with properties, but have not addressed with descrip‐ tors, is handling attempts to delete a managed attribute. That can be done by imple‐ menting a __delete__ method alongside or instead of the usual __get__ and/or __set__ in the descriptor class. I deliberately omitted coverage of __delete__ because I believe real-world usage is rare. If you need this, please see the “Implement‐ ing Descriptors” section of the Python Data Model documentation. Coding a silly descriptor class with __delete__ is left as an exercise to the leisurely reader.\n\n10 Customizing the help text for each descriptor instance is surprisingly hard. One solution requires dynamically\n\nbuilding a wrapper class for each descriptor instance.\n\n902\n\n|\n\nChapter 23: Attribute Descriptors\n\nFigure 23-4. Screenshots of the Python console when issuing the commands help(LineI tem.weight) and help(LineItem).\n\nChapter Summary The first example of this chapter was a continuation of the LineItem examples from Chapter 22. In Example 23-2, we replaced properties with descriptors. We saw that a descriptor is a class that provides instances that are deployed as attributes in the man‐ aged class. Discussing this mechanism required special terminology, introducing terms such as managed instance and storage attribute.\n\nIn “LineItem Take #4: Automatic Naming of Storage Attributes” on page 887, we removed the requirement that Quantity descriptors were declared with an explicit storage_name, which was redundant and error prone. The solution was to imple‐ ment the __set_name__ special method in Quantity, to save the name of the man‐ aged property as self.storage_name.\n\n“LineItem Take #5: A New Descriptor Type” on page 889 showed how to subclass an abstract descriptor class to share code while building specialized descriptors with some common functionality.\n\nChapter Summary\n\n|\n\n903\n\nWe then looked at the different behaviors of descriptors providing or omitting the __set__ method, making the crucial distinction between overriding and nonoverrid‐ ing descriptors, a.k.a. data and nondata descriptors. Through detailed testing we uncovered when descriptors are in control and when they are shadowed, bypassed, or overwritten.\n\nFollowing that, we studied a particular category of nonoverriding descriptors: meth‐ ods. Console experiments revealed how a function attached to a class becomes a method when accessed through an instance, by leveraging the descriptor protocol.\n\nTo conclude the chapter, “Descriptor Usage Tips” on page 900 presented practical tips, and “Descriptor Docstring and Overriding Deletion” on page 902 provided a brief look at how to document descriptors.\n\nAs noted in “What’s New in This Chapter” on page 880, several examples in this chapter became much simpler thanks to the __set_name__ special method of the descriptor protocol, added in Python 3.6. That’s language evolution!\n\nFurther Reading Besides the obligatory reference to the “Data Model” chapter, Raymond Hettinger’s “Descriptor HowTo Guide” is a valuable resource—part of the HowTo collection in the official Python documentation.\n\nAs usual with Python object model subjects, Martelli, Ravenscroft, and Holden’s Python in a Nutshell, 3rd ed. (O’Reilly) is authoritative and objective. Martelli also has a presentation titled “Python’s Object Model,” which covers properties and descriptors in depth (see the slides and video).\n\nBeware that any coverage of descriptors written or recorded before PEP 487 was adopted in 2016 is likely to contain examples that are needlessly complicated today, because __set_name__ was not sup‐ ported in Python versions prior to 3.6.\n\nFor more practical examples, Python Cookbook, 3rd ed., by David Beazley and Brian K. Jones (O’Reilly), has many recipes illustrating descriptors, of which I want to highlight “6.12. Reading Nested and Variable-Sized Binary Structures,” “8.10. Using Lazily Computed Properties,” “8.13. Implementing a Data Model or Type System,” and “9.9. Defining Decorators As Classes.” The last recipe of which addresses deep issues with the interaction of function decorators, descriptors, and methods, explaining how a function decorator implemented as a class with __call__ also\n\n904\n\n|\n\nChapter 23: Attribute Descriptors\n\nneeds to implement __get__ if it wants to work with decorating methods as well as functions.\n\nPEP 487—Simpler customization of class creation introduced the __set_name__ spe‐ cial method, and includes an example of a validating descriptor.\n\nSoapbox\n\nThe Design of self\n\nThe requirement to explicitly declare self as a first argument in methods is a contro‐ versial design decision in Python. After 23 years using the language, I am used to it. I think that decision is an example of “worse is better”: a design philosophy described by computer scientist Richard P. Gabriel in “The Rise of Worse is Better”. The first priority of this philosophy is “simplicity,” which Gabriel presents as:\n\nThe design must be simple, both in implementation and interface. It is more impor‐ tant for the implementation to be simple than the interface. Simplicity is the most important consideration in a design.\n\nPython’s explicit self embodies that design philosophy. The implementation is sim‐ ple—elegant even—at the expense of the user interface: a method signature like def zfill(self, width): doesn’t visually match the invocation label.zfill(8).\n\nModula-3 introduced that convention with the same identifier self. But there is a key difference: in Modula-3, interfaces are declared separately from their implemen‐ tation, and in the interface declaration the self argument is omitted, so from the user’s perspective, a method appears in an interface declaration with the same explicit parameters used to call it.\n\nOver time, Python’s error messages related to method arguments became clearer. For a user-defined method with one argument besides self, if the user invokes obj.meth(), Python 2.7 raised:\n\nTypeError: meth() takes exactly 2 arguments (1 given)\n\nIn Python 3, the confusing argument count is not mentioned, and the missing argu‐ ment is named:\n\nTypeError: meth() missing 1 required positional argument: 'x'\n\nBesides the use of self as an explicit argument, the requirement to qualify every access to instance attributes with self is also criticized. See, for example, A. M. Kuch‐ ling’s famous “Python Warts” post (archived); Kuchling himself is not so bothered by the self qualifier, but he mentions it—probably echoing opinions from the comp.lang.python group. I personally don’t mind typing the self qualifier: it’s good to distinguish local variables from attributes. My issue is with the use of self in the def statement.\n\nFurther Reading\n\n|\n\n905\n\nAnyone who is unhappy about the explicit self in Python can feel a lot better by con‐ sidering the baffling semantics of the implicit this in JavaScript. Guido had some good reasons to make self work as it does, and he wrote about them in “Adding Sup‐ port for User-Defined Classes”, a post on his blog, The History of Python.\n\n906\n\n|\n\nChapter 23: Attribute Descriptors\n\nCHAPTER 24 Class Metaprogramming\n\nEveryone knows that debugging is twice as hard as writing a program in the first place. So if you’re as clever as you can be when you write it, how will you ever debug it? —Brian W. Kernighan and P. J. Plauger, The Elements of Programming Style1\n\nClass metaprogramming is the art of creating or customizing classes at runtime. Classes are first-class objects in Python, so a function can be used to create a new class at any time, without using the class keyword. Class decorators are also func‐ tions, but designed to inspect, change, and even replace the decorated class with another class. Finally, metaclasses are the most advanced tool for class metaprogram‐ ming: they let you create whole new categories of classes with special traits, such as the abstract base classes we’ve already seen.\n\nMetaclasses are powerful, but hard to justify and even harder to get right. Class deco‐ rators solve many of the same problems and are easier to understand. Furthermore, Python 3.6 implemented PEP 487—Simpler customization of class creation, provid‐ ing special methods supporting tasks that previously required metaclasses or class decorators.2\n\nThis chapter presents the class metaprogramming techniques in ascending order of complexity.\n\n1 Quote from Chapter 2, “Expression” of The Elements of Programming Style, 2nd ed. (McGraw-Hill), page 10.\n\n2 That doesn’t mean PEP 487 broke code that used those features. It just means that some code that used class decorators or metaclasses prior to Python 3.6 can now be refactored to use plain classes, resulting in simpler and possibly more efficient code.\n\n907\n\nThis is an exciting topic, and it’s easy to get carried away. So I must offer this advice.\n\nFor the sake of readability and maintainability, you should proba‐ bly avoid the techniques described in this chapter in application code.\n\nOn the other hand, these are the tools of the trade if you want to write the next great Python framework.\n\nWhat’s New in This Chapter All the code in the “Class Metaprogramming” chapter of the first edition of Fluent Python still runs correctly. However, some of the previous examples no longer repre‐ sent the simplest solutions in light of new features added since Python 3.6.\n\nI replaced those examples with different ones, highlighting Python’s new metaprog‐ ramming features or adding further requirements to justify the use of the more advanced techniques. Some of the new examples leverage type hints to provide class builders similar to the @dataclass decorator and typing.NamedTuple.\n\n“Metaclasses in the Real World” on page 947 is a new section with some high-level con‐ siderations about the applicability of metaclasses.\n\nSome of the best refactorings are removing code made redundant by newer and simpler ways of solving the same problems. This applies to production code as well as books.\n\nWe’ll get started by reviewing attributes and methods defined in the Python Data Model for all classes.\n\nClasses as Objects Like most program entities in Python, classes are also objects. Every class has a num‐ ber of attributes defined in the Python Data Model, documented in “4.13. Special Attributes” of the “Built-in Types” chapter in The Python Standard Library. Three of those attributes appeared several times in this book already: __class__, __name__, and __mro__. Other class standard attributes are:\n\ncls.__bases__\n\nThe tuple of base classes of the class.\n\n908\n\n|\n\nChapter 24: Class Metaprogramming\n\ncls.__qualname__\n\nThe qualified name of a class or function, which is a dotted path from the global scope of the module to the class definition. This is relevant when the class is defined inside another class. For example, in a Django model class such as Ox, there is an inner class called Meta. The __qualname__ of Meta is Ox.Meta, but its __name__ is just Meta. The specification for this attribute is PEP 3155—Qualified name for classes and functions.\n\ncls.__subclasses__()\n\nThis method returns a list of the immediate subclasses of the class. The imple‐ mentation uses weak references to avoid circular references between the super‐ class and its subclasses—which hold a strong reference to the superclasses in their __bases__ attribute. The method lists subclasses currently in memory. Sub‐ classes in modules not yet imported will not appear in the result.\n\ncls.mro()\n\nThe interpreter calls this method when building a class to obtain the tuple of superclasses stored in the __mro__ attribute of the class. A metaclass can override this method to customize the method resolution order of the class under construction.\n\nNone of the attributes mentioned in this section are listed by the dir(…) function.\n\nNow, if a class is an object, what is the class of a class?\n\ntype: The Built-In Class Factory We usually think of type as a function that returns the class of an object, because that’s what type(my_object) does: it returns my_object.__class__.\n\nHowever, type is a class that creates a new class when invoked with three arguments.\n\nConsider this simple class:\n\nclass MyClass(MySuperClass, MyMixin): x = 42\n\ndef x2(self): return self.x * 2\n\nUsing the type constructor, you can create MyClass at runtime with this code:\n\ntype: The Built-In Class Factory\n\n|\n\n909\n\nMyClass = type('MyClass', (MySuperClass, MyMixin), {'x': 42, 'x2': lambda self: self.x * 2}, )\n\nThat type call is functionally equivalent to the previous class MyClass… block statement.\n\nWhen Python reads a class statement, it calls type to build the class object with these parameters:\n\nname\n\nThe identifier that appears after the class keyword, e.g., MyClass.\n\nbases\n\nThe tuple of superclasses given in parentheses after the class identifier, or (object,) if superclasses are not mentioned in the class statement.\n\ndict\n\nA mapping of attribute names to values. Callables become methods, as we saw in “Methods Are Descriptors” on page 898. Other values become class attributes.\n\nThe type constructor accepts optional keyword arguments, which are ignored by type itself, but are passed untouched into __init_subclass__, which must consume them. We’ll study that special method in “Introducing __init_subclass__” on page 914, but I won’t cover the use of keyword arguments. For more, please read PEP 487—Simpler customization of class creation.\n\nThe type class is a metaclass: a class that builds classes. In other words, instances of the type class are classes. The standard library provides a few other metaclasses, but type is the default:\n\n>>> type(7) <class 'int'> >>> type(int) <class 'type'> >>> type(OSError) <class 'type'> >>> class Whatever: ... pass ... >>> type(Whatever) <class 'type'>\n\nWe’ll build custom metaclasses in “Metaclasses 101” on page 931.\n\nNext, we’ll use the type built-in to make a function that builds classes.\n\n910\n\n|\n\nChapter 24: Class Metaprogramming\n\nA Class Factory Function The standard library has a class factory function that appears several times in this book: collections.namedtuple. In Chapter 5 we also saw typing.NamedTuple and @dataclass. All of these class builders leverage techniques covered in this chapter.\n\nWe’ll start with a super simple factory for classes of mutable objects—the simplest possible replacement for @dataclass.\n\nSuppose I’m writing a pet shop application and I want to store data for dogs as simple records. But I don’t want to write boilerplate like this:\n\nclass Dog: def __init__(self, name, weight, owner): self.name = name self.weight = weight self.owner = owner\n\nBoring…each field name appears three times, and that boilerplate doesn’t even buy us a nice repr:\n\n>>> rex = Dog('Rex', 30, 'Bob') >>> rex <__main__.Dog object at 0x2865bac>\n\nTaking a hint from collections.namedtuple, let’s create a record_factory that cre‐ ates simple classes like Dog on the fly. Example 24-1 shows how it should work.\n\nExample 24-1. Testing record_factory, a simple class factory\n\n>>> Dog = record_factory('Dog', 'name weight owner') >>> rex = Dog('Rex', 30, 'Bob') >>> rex Dog(name='Rex', weight=30, owner='Bob') >>> name, weight, _ = rex >>> name, weight ('Rex', 30) >>> \"{2}'s dog weighs {1}kg\".format(*rex) \"Bob's dog weighs 30kg\" >>> rex.weight = 32 >>> rex Dog(name='Rex', weight=32, owner='Bob') >>> Dog.__mro__ (<class 'factories.Dog'>, <class 'object'>)\n\nFactory can be called like namedtuple: class name, followed by attribute names separated by spaces in a single string.\n\nNice repr.\n\nA Class Factory Function\n\n|\n\n911\n\nInstances are iterable, so they can be conveniently unpacked on assignment…\n\n…or when passing to functions like format.\n\nA record instance is mutable.\n\nThe newly created class inherits from object—no relationship to our factory.\n\nThe code for record_factory is in Example 24-2.3\n\nExample 24-2. record_factory.py: a simple class factory\n\nfrom typing import Union, Any from collections.abc import Iterable, Iterator\n\nFieldNames = Union[str, Iterable[str]]\n\ndef record_factory(cls_name: str, field_names: FieldNames) -> type[tuple]:\n\nslots = parse_identifiers(field_names)\n\ndef __init__(self, *args, **kwargs) -> None: attrs = dict(zip(self.__slots__, args)) attrs.update(kwargs) for name, value in attrs.items(): setattr(self, name, value)\n\ndef __iter__(self) -> Iterator[Any]: for name in self.__slots__: yield getattr(self, name)\n\ndef __repr__(self): values = ', '.join(f'{name}={value!r}' for name, value in zip(self.__slots__, self)) cls_name = self.__class__.__name__ return f'{cls_name}({values})'\n\ncls_attrs = dict( __slots__=slots, __init__=__init__, __iter__=__iter__, __repr__=__repr__, )\n\nreturn type(cls_name, (object,), cls_attrs)\n\n3 Thanks to my friend J. S. O. Bueno for contributing to this example.\n\n912\n\n|\n\nChapter 24: Class Metaprogramming\n\ndef parse_identifiers(names: FieldNames) -> tuple[str, ...]: if isinstance(names, str): names = names.replace(',', ' ').split() if not all(s.isidentifier() for s in names): raise ValueError('names must all be valid identifiers') return tuple(names)\n\nUser can provide field names as a single string or an iterable of strings.\n\nAccept arguments like the first two of collections.namedtuple; return a type— i.e., a class that behaves like a tuple.\n\nBuild a tuple of attribute names; this will be the __slots__ attribute of the new class.\n\nThis function will become the __init__ method in the new class. It accepts posi‐ tional and/or keyword arguments.4\n\nYield the field values in the order given by __slots__.\n\nProduce the nice repr, iterating over __slots__ and self.\n\nAssemble a dictionary of class attributes.\n\nBuild and return the new class, calling the type constructor.\n\nConvert names separated by spaces or commas to list of str.\n\nExample 24-2 is the first time we’ve seen type in a type hint. If the annotation was just -> type, that would mean that record_factory returns a class—and it would be correct. But the annotation -> type[tuple] is more precise: it says the returned class will be a subclass of tuple.\n\nThe last line of record_factory in Example 24-2 builds a class named by the value of cls_name, with object as its single immediate base class, and with a namespace loaded with __slots__, __init__, __iter__, and __repr__, of which the last three are instance methods.\n\nWe could have named the __slots__ class attribute anything else, but then we’d have to implement __setattr__ to validate the names of attributes being assigned,\n\n4 I did not add type hints to the arguments because the actual types are Any. I put the return type hint because\n\notherwise Mypy will not check inside the method.\n\nA Class Factory Function\n\n|\n\n913\n\nbecause for our record-like classes we want the set of attributes to be always the same and in the same order. However, recall that the main feature of __slots__ is saving memory when you are dealing with millions of instances, and using __slots__ has some drawbacks, discussed in “Saving Memory with __slots__” on page 384.\n\nInstances of classes created by record_factory are not serializable —that is, they can’t be exported with the dump function from the pickle module. Solving this problem is beyond the scope of this example, which aims to show the type class in action in a simple use case. For the full solution, study the source code for collections.namedtuple; search for the word “pickling.”\n\nNow let’s see how to emulate more modern class builders like typing.NamedTuple, which takes a user-defined class written as a class statement, and automatically enhances it with more functionality.\n\nIntroducing __init_subclass__ Both __init_subclass__ and __set_name__ were proposed in PEP 487—Simpler customization of class creation. We saw the __set_name__ special method for descriptors for the first time in “LineItem Take #4: Automatic Naming of Storage Attributes” on page 887. Now let’s study __init_subclass__.\n\nIn Chapter 5, we saw that typing.NamedTuple and @dataclass let programmers use the class statement to specify attributes for a new class, which is then enhanced by the class builder with the automatic addition of essential methods like __init__, __repr__, __eq__, etc.\n\nBoth of these class builders read type hints in the user’s class statement to enhance the class. Those type hints also allow static type checkers to validate code that sets or gets those attributes. However, NamedTuple and @dataclass do not take advantage of the type hints for attribute validation at runtime. The Checked class in the next example does.\n\nIt is not possible to support every conceivable static type hint for runtime type checking, which is probably why typing.NamedTuple and @dataclass don’t even try it. However, some types that are also concrete classes can be used with Checked. This includes sim‐ ple types often used for field contents, such as str, int, float, and bool, as well as lists of those types.\n\nExample 24-3 shows how to use Checked to build a Movie class.\n\n914\n\n|\n\nChapter 24: Class Metaprogramming\n\nExample 24-3. initsub/checkedlib.py: doctest for creating a Movie subclass of Checked\n\n>>> class Movie(Checked): ... title: str ... year: int ... box_office: float ... >>> movie = Movie(title='The Godfather', year=1972, box_office=137) >>> movie.title 'The Godfather' >>> movie Movie(title='The Godfather', year=1972, box_office=137.0)\n\nMovie inherits from Checked—which we’ll define later in Example 24-5.\n\nEach attribute is annotated with a constructor. Here I used built-in types.\n\nMovie instances must be created using keyword arguments.\n\nIn return, you get a nice __repr__.\n\nThe constructors used as the attribute type hints may be any callable that takes zero or one argument and returns a value suitable for the intended field type, or rejects the argument by raising TypeError or ValueError.\n\nUsing built-in types for the annotations in Example 24-3 means the values must be acceptable by the constructor of the type. For int, this means any x such that int(x) returns an int. For str, anything goes at runtime, because str(x) works with any x in Python.5\n\nWhen called with no arguments, the constructor should return a default value of its type.6\n\nThis is standard behavior for Python’s built-in constructors:\n\n>>> int(), float(), bool(), str(), list(), dict(), set() (0, 0.0, False, '', [], {}, set())\n\n5 That’s true for any object, except when its class overrides the __str__ or __repr__ methods inherited from\n\nobject with broken implementations.\n\n6 This solution avoids using None as a default. Avoiding null values is a good idea. They are hard to avoid in\n\ngeneral, but easy in some cases. In Python as well as SQL, I prefer to represent missing data in a text field with an empty string instead of None or NULL. Learning Go reinforced this idea: variables and struct fields of primi‐ tive types in Go are initialized by default with a “zero value.” See “Zero values” in the online Tour of Go if you are curious.\n\nIntroducing __init_subclass__\n\n|\n\n915\n\nIn a Checked subclass like Movie, missing parameters create instances with default values returned by the field constructors. For example:\n\n>>> Movie(title='Life of Brian') Movie(title='Life of Brian', year=0, box_office=0.0)\n\nThe constructors are used for validation during instantiation and when an attribute is set directly on an instance:\n\n>>> blockbuster = Movie(title='Avatar', year=2009, box_office='billions') Traceback (most recent call last): ... TypeError: 'billions' is not compatible with box_office:float >>> movie.year = 'MCMLXXII' Traceback (most recent call last): ... TypeError: 'MCMLXXII' is not compatible with year:int\n\nChecked Subclasses and Static Type Checking\n\nIn a .py source file with a movie instance of Movie, as defined in Example 24-3, Mypy flags this assignment as a type error:\n\nmovie.year = 'MCMLXXII'\n\nHowever, Mypy can’t detect type errors in this constructor call:\n\nblockbuster = Movie(title='Avatar', year='MMIX')\n\nThat’s because Movie inherits Checked.__init__, and the signature of that method must accept any keyword arguments to support arbitrary user-defined classes. On the other hand, if you declare a Checked subclass field with the type hint list[float], Mypy can flag assignments of lists with incompatible contents, but Checked will ignore the type parameter and treat that the same as list.\n\nNow let’s look at the implementation of checkedlib.py. The first class is the Field descriptor, as shown in Example 24-4.\n\nExample 24-4. initsub/checkedlib.py: the Field descriptor class\n\nfrom collections.abc import Callable from typing import Any, NoReturn, get_type_hints\n\nclass Field: def __init__(self, name: str, constructor: Callable) -> None: if not callable(constructor) or constructor is type(None): raise TypeError(f'{name!r} type hint must be callable') self.name = name\n\n916\n\n|\n\nChapter 24: Class Metaprogramming",
      "page_number": 910
    },
    {
      "number": 46,
      "title": "Segment 46 (pages 930-951)",
      "start_page": 930,
      "end_page": 951,
      "detection_method": "synthetic",
      "content": "self.constructor = constructor\n\ndef __set__(self, instance: Any, value: Any) -> None: if value is ...: value = self.constructor() else: try: value = self.constructor(value) except (TypeError, ValueError) as e: type_name = self.constructor.__name__ msg = f'{value!r} is not compatible with {self.name}:{type_name}' raise TypeError(msg) from e instance.__dict__[self.name] = value\n\nRecall that since Python 3.9, the Callable type for annotations is the ABC in collections.abc, and not the deprecated typing.Callable.\n\nThis is a minimal Callable type hint; the parameter type and return type for constructor are both implicitly Any.\n\nFor runtime checking, we use the callable built-in.7 The test against type(None) is necessary because Python reads None in a type as NoneType, the class of None (therefore callable), but a useless constructor that only returns None.\n\nIf Checked.__init__ sets the value as ... (the Ellipsis built-in object), we call the constructor with no arguments.\n\nOtherwise, call the constructor with the given value.\n\nIf constructor raises either of these exceptions, we raise TypeError with a help‐ ful message including the names of the field and constructor; e.g., 'MMIX' is not compatible with year:int.\n\nIf no exceptions were raised, the value is stored in the instance.__dict__.\n\nIn __set__, we need to catch TypeError and ValueError because built-in construc‐ tors may raise either of them, depending on the argument. For example, float(None) raises TypeError, but float('A') raises ValueError. On the other hand, float('8') raises no error and returns 8.0. I hereby declare that this is a feature and not a bug of this toy example.\n\n7 I believe that callable should be made suitable for type hinting. As of May 6, 2021, this is an open issue.\n\nIntroducing __init_subclass__\n\n|\n\n917\n\nIn “LineItem Take #4: Automatic Naming of Storage Attributes” on page 887, we saw the handy __set_name__ special method for descriptors. We don’t need it in the Field class because the descriptors are not instantiated in client source code; the user declares types that are constructors, as we saw in the Movie class (Example 24-3). Instead, the Field descriptor instances are created at runtime by the Checked.__init_subclass__ method, which we’ll see in Example 24-5.\n\nNow let’s focus on the Checked class. I split it in two listings. Example 24-5 shows the top of the class, which includes the most important methods in this example. The remaining methods are in Example 24-6.\n\nExample 24-5. initsub/checkedlib.py: the most important methods of the Checked class\n\nclass Checked: @classmethod def _fields(cls) -> dict[str, type]: return get_type_hints(cls)\n\ndef __init_subclass__(subclass) -> None: super().__init_subclass__() for name, constructor in subclass._fields().items(): setattr(subclass, name, Field(name, constructor))\n\ndef __init__(self, **kwargs: Any) -> None: for name in self._fields(): value = kwargs.pop(name, ...) setattr(self, name, value) if kwargs: self.__flag_unknown_attrs(*kwargs)\n\nI wrote this class method to hide the call to typing.get_type_hints from the rest of the class. If I need to support Python ≥ 3.10 only, I’d call inspect.get_annotations instead. Review “Problems with Annotations at Run‐ time” on page 538 for the issues with those functions.\n\n__init_subclass__ is called when a subclass of the current class is defined. It gets that new subclass as its first argument—which is why I named the argument subclass instead of the usual cls. For more on this, see “__init_subclass__ Is Not a Typical Class Method” on page 919.\n\nsuper().__init_subclass__() is not strictly necessary, but should be invoked to play nice with other classes that might implement .__init_subclass__() in\n\n918\n\n|\n\nChapter 24: Class Metaprogramming\n\nthe same inheritance graph. See “Multiple Inheritance and Method Resolution Order” on page 494.\n\nIterate over each field name and constructor…\n\n…creating an attribute on subclass with that name bound to a Field descriptor parameterized with name and constructor.\n\nFor each name in the class fields…\n\n…get the corresponding value from kwargs and remove it from kwargs. Using ... (the Ellipsis object) as default allows us to distinguish between argu‐ ments given the value None from arguments that were not given.8\n\nThis setattr call triggers Checked.__setattr__, shown in Example 24-6.\n\nIf there are remaining items in kwargs, their names do not match any of the declared fields, and __init__ will fail.\n\nThe error is reported by __flag_unknown_attrs, listed in Example 24-6. It takes a *names argument with the unknown attribute names. I used a single asterisk in *kwargs to pass its keys as a sequence of arguments.\n\n__init_subclass__ Is Not a Typical Class Method The @classmethod decorator is never used with __init_subclass__, but that doesn’t mean much, because the __new__ special method behaves as a class method even without @classmethod. The first argument that Python passes to __init_subclass__ is a class. However, it is never the class where __init_subclass__ is implemented: it is a newly defined subclass of that class. That’s unlike __new__ and every other class method that I know about. Therefore, I think __init_subclass__ is not a class method in the usual sense, and it is misleading to name the first argument cls. The __init_suclass__ documentation names the argument cls but explains: “…called whenever the containing class is subclassed. cls is then the new subclass.”\n\nNow let’s see the remaining methods of the Checked class, continuing from Example 24-5. Note that I prepended _ to the _fields and _asdict method names\n\n8 As mentioned in “Loops, Sentinels, and Poison Pills” on page 721, the Ellipsis object is a convenient and\n\nsafe sentinel value. It has been around for a long time, but recently people are finding more uses for it, as we see in type hints and NumPy.\n\nIntroducing __init_subclass__\n\n|\n\n919\n\nfor the same reason the collections.namedtuple API does: to reduce the chance of name clashes with user-defined field names.\n\nExample 24-6. initsub/checkedlib.py: remaining methods of the Checked class\n\ndef __setattr__(self, name: str, value: Any) -> None: if name in self._fields(): cls = self.__class__ descriptor = getattr(cls, name) descriptor.__set__(self, value) else: self.__flag_unknown_attrs(name)\n\ndef __flag_unknown_attrs(self, *names: str) -> NoReturn: plural = 's' if len(names) > 1 else '' extra = ', '.join(f'{name!r}' for name in names) cls_name = repr(self.__class__.__name__) raise AttributeError(f'{cls_name} object has no attribute{plural} {extra}')\n\ndef _asdict(self) -> dict[str, Any]: return { name: getattr(self, name) for name, attr in self.__class__.__dict__.items() if isinstance(attr, Field) }\n\ndef __repr__(self) -> str: kwargs = ', '.join( f'{key}={value!r}' for key, value in self._asdict().items() ) return f'{self.__class__.__name__}({kwargs})'\n\nIntercept all attempts to set an instance attribute. This is needed to prevent set‐ ting an unknown attribute.\n\nIf the attribute name is known, fetch the corresponding descriptor.\n\nUsually we don’t need to call the descriptor __set__ explicitly. It was necessary in this case because __setattr__ intercepts all attempts to set an attribute on the instance, including in the presence of an overriding descriptor such as Field.9\n\nOtherwise, the attribute name is unknown, and an exception will be raised by __flag_unknown_attrs.\n\n9 The subtle concept of an overriding descriptor was explained in “Overriding Descriptors” on page 894.\n\n920\n\n|\n\nChapter 24: Class Metaprogramming\n\nBuild a helpful error message listing all unexpected arguments, and raise Attribu teError. This is a rare example of the NoReturn special type, covered in “NoRe‐ turn” on page 294.\n\nCreate a dict from the attributes of a Movie object. I’d call this method _as_dict, but I followed the convention started by the _asdict method in col lections.namedtuple.\n\nImplementing a nice __repr__ is the main reason for having _asdict in this example.\n\nThe Checked example illustrates how to handle overriding descriptors when imple‐ menting __setattr__ to block arbitrary attribute setting after instantiation. It is debatable whether implementing __setattr__ is worthwhile in this example. Without it, setting movie.director = 'Greta Gerwig' would succeed, but the director attribute would not be checked in any way, and would not appear in the __repr__ nor would it be included in the dict returned by _asdict—both defined in Example 24-6.\n\nIn record_factory.py (Example 24-2) I solved this issue using the __slots__ class attribute. However, this simpler solution is not viable in this case, as explained next.\n\nWhy __init_subclass__ Cannot Configure __slots__ The __slots__ attribute is only effective if it is one of the entries in the class name‐ space passed to type.__new__. Adding __slots__ to an existing class has no effect. Python invokes __init_subclass__ only after the class is built—by then it’s too late to configure __slots__. A class decorator can’t configure __slots__ either, because it is applied even later than __init_subclass__. We’ll explore these timing issues in “What Happens When: Import Time Versus Runtime” on page 925.\n\nTo configure __slots__ at runtime, your own code must build the class namespace passed as the last argument of type.__new__. To do that, you can write a class factory function, like record_factory.py, or you can take the nuclear option and implement a metaclass. We will see how to dynamically configure __slots__ in “Metaclasses 101” on page 931.\n\nBefore PEP 487 simplified the customization of class creation with __init_sub class__ in Python 3.7, similar functionality had to be implemented using a class dec‐ orator. That’s the focus of the next section.\n\nIntroducing __init_subclass__\n\n|\n\n921\n\nEnhancing Classes with a Class Decorator A class decorator is a callable that behaves similarly to a function decorator: it gets the decorated class as an argument, and should return a class to replace the decorated class. Class decorators often return the decorated class itself, after injecting more methods in it via attribute assignment.\n\nProbably the most common reason to choose a class decorator over the simpler __init_subclass__ is to avoid interfering with other class features, such as inheri‐ tance and metaclasses.10\n\nIn this section, we’ll study checkeddeco.py, which provides the same service as check‐ edlib.py, but using a class decorator. As usual, we’ll start by looking at a usage exam‐ ple, extracted from the doctests in checkeddeco.py (Example 24-7).\n\nExample 24-7. checkeddeco.py: creating a Movie class decorated with @checked\n\n>>> @checked ... class Movie: ... title: str ... year: int ... box_office: float ... >>> movie = Movie(title='The Godfather', year=1972, box_office=137) >>> movie.title 'The Godfather' >>> movie Movie(title='The Godfather', year=1972, box_office=137.0)\n\nThe only difference between Example 24-7 and Example 24-3 is the way the Movie class is declared: it is decorated with @checked instead of subclassing Checked. Other‐ wise, the external behavior is the same, including the type validation and default value assignments shown after Example 24-3 in “Introducing __init_subclass__” on page 914.\n\nNow let’s look at the implementation of checkeddeco.py. The imports and Field class are the same as in checkedlib.py, listed in Example 24-4. There is no other class, only functions in checkeddeco.py.\n\nThe logic previously implemented in __init_subclass__ is now part of the checked function—the class decorator listed in Example 24-8.\n\n10 This rationale appears in the abstract of PEP 557–Data Classes to explain why it was implemented as a class\n\ndecorator.\n\n922\n\n|\n\nChapter 24: Class Metaprogramming\n\nExample 24-8. checkeddeco.py: the class decorator\n\ndef checked(cls: type) -> type: for name, constructor in _fields(cls).items(): setattr(cls, name, Field(name, constructor))\n\ncls._fields = classmethod(_fields) # type: ignore\n\ninstance_methods = ( __init__, __repr__, __setattr__, _asdict, __flag_unknown_attrs, ) for method in instance_methods: setattr(cls, method.__name__, method)\n\nreturn cls\n\nRecall that classes are instances of type. These type hints strongly suggest this is a class decorator: it takes a class and returns a class.\n\n_fields is a top-level function defined later in the module (in Example 24-9).\n\nReplacing each attribute returned by _fields with a Field descriptor instance is what __init_subclass__ did in Example 24-5. Here there is more work to do…\n\nBuild a class method from _fields, and add it to the decorated class. The type: ignore comment is needed because Mypy complains that type has no _fields attribute.\n\nModule-level functions that will become instance methods of the decorated class.\n\nAdd each of the instance_methods to cls.\n\nReturn the decorated cls, fulfilling the essential contract of a class decorator.\n\nEnhancing Classes with a Class Decorator\n\n|\n\n923\n\nEvery top-level function in checkeddeco.py is prefixed with an underscore, except the checked decorator. This naming convention makes sense for a couple of reasons:\n\nchecked is part of the public interface of the checkeddeco.py module, but the other functions are not.\n\nThe functions in Example 24-9 will be injected in the decorated class, and the leading _ reduces the chance of naming conflicts with user-defined attributes and methods of the decorated class.\n\nThe rest of checkeddeco.py is listed in Example 24-9. Those module-level functions have the same code as the corresponding methods of the Checked class of checked‐ lib.py. They were explained in Examples 24-5 and 24-6.\n\nNote that the _fields function does double duty in checkeddeco.py. It is used as a regular function in the first line of the checked decorator, and it will also be injected as a class method of the decorated class.\n\nExample 24-9. checkeddeco.py: the methods to be injected in the decorated class\n\ndef _fields(cls: type) -> dict[str, type]: return get_type_hints(cls)\n\ndef __init__(self: Any, **kwargs: Any) -> None: for name in self._fields(): value = kwargs.pop(name, ...) setattr(self, name, value) if kwargs: self.__flag_unknown_attrs(*kwargs)\n\ndef __setattr__(self: Any, name: str, value: Any) -> None: if name in self._fields(): cls = self.__class__ descriptor = getattr(cls, name) descriptor.__set__(self, value) else: self.__flag_unknown_attrs(name)\n\ndef __flag_unknown_attrs(self: Any, *names: str) -> NoReturn: plural = 's' if len(names) > 1 else '' extra = ', '.join(f'{name!r}' for name in names) cls_name = repr(self.__class__.__name__) raise AttributeError(f'{cls_name} has no attribute{plural} {extra}')\n\ndef _asdict(self: Any) -> dict[str, Any]: return { name: getattr(self, name) for name, attr in self.__class__.__dict__.items() if isinstance(attr, Field)\n\n924\n\n|\n\nChapter 24: Class Metaprogramming\n\n}\n\ndef __repr__(self: Any) -> str: kwargs = ', '.join( f'{key}={value!r}' for key, value in self._asdict().items() ) return f'{self.__class__.__name__}({kwargs})'\n\nThe checkeddeco.py module implements a simple but usable class decorator. Python’s @dataclass does a lot more. It supports many configuration options, adds more methods to the decorated class, handles or warns about conflicts with user-defined methods in the decorated class, and even traverses the __mro__ to collect user- defined attributes declared in the superclasses of the decorated class. The source code of the dataclasses package in Python 3.9 is more than 1,200 lines long.\n\nFor metaprogramming classes, we must be aware of when the Python interpreter evaluates each block of code during the construction of a class. This is covered next.\n\nWhat Happens When: Import Time Versus Runtime Python programmers talk about “import time” versus “runtime,” but the terms are not strictly defined and there is a gray area between them.\n\nAt import time, the interpreter:\n\n1. Parses the source code of a .py module in one pass from top to bottom. This is when a SyntaxError may occur.\n\n2. Compiles the bytecode to be executed.\n\n3. Executes the top-level code of the compiled module.\n\nIf there is an up-to-date .pyc file available in the local __pycache__, parsing and compiling are skipped because the bytecode is ready to run.\n\nAlthough parsing and compiling are definitely “import time” activities, other things may happen at that time, because almost every statement in Python is executable in the sense that they can potentially run user code and may change the state of the user program.\n\nIn particular, the import statement is not merely a declaration,11 but it actually runs all the top-level code of a module when it is imported for the first time in the process. Further imports of the same module will use a cache, and then the only effect will be binding the imported objects to names in the client module. That top-level code may\n\n11 Contrast with the import statement in Java, which is just a declaration to let the compiler know that certain\n\npackages are required.\n\nWhat Happens When: Import Time Versus Runtime\n\n|\n\n925\n\ndo anything, including actions typical of “runtime,” such as writing to a log or con‐ necting to a database.12 That’s why the border between “import time” and “runtime” is fuzzy: the import statement can trigger all sorts of “runtime” behavior. Conversely, “import time” can also happen deep inside runtime, because the import statement and the __import__() built-in can be used inside any regular function.\n\nThis is all rather abstract and subtle, so let’s do some experiments to see what hap‐ pens when.\n\nEvaluation Time Experiments Consider an evaldemo.py script that uses a class decorator, a descriptor, and a class builder based on __init_subclass__, all defined in a builderlib.py module. The modules have several print calls to show what happens under the covers. Otherwise, they don’t perform anything useful. The goal of these experiments is to observe the order in which these print calls happen.\n\nApplying a class decorator and a class builder with __init_sub class__ together in single class is likely a sign of overengineering or desperation. This unusual combination is useful in these experi‐ ments to show the timing of the changes that a class decorator and __init_subclass__ can apply to a class.\n\nLet’s start by checking out builderlib.py, split into two parts: Example 24-10 and Example 24-11.\n\nExample 24-10. builderlib.py: top of the module\n\nprint('@ builderlib module start')\n\nclass Builder: print('@ Builder body')\n\ndef __init_subclass__(cls): print(f'@ Builder.__init_subclass__({cls!r})')\n\ndef inner_0(self): print(f'@ SuperA.__init_subclass__:inner_0({self!r})')\n\ncls.method_a = inner_0\n\ndef __init__(self):\n\n12 I’m not saying opening a database connection just because a module is imported is a good idea, only pointing\n\nout it can be done.\n\n926\n\n|\n\nChapter 24: Class Metaprogramming\n\nsuper().__init__() print(f'@ Builder.__init__({self!r})')\n\ndef deco(cls): print(f'@ deco({cls!r})')\n\ndef inner_1(self): print(f'@ deco:inner_1({self!r})')\n\ncls.method_b = inner_1 return cls\n\nThis is a class builder to implement…\n\n…an __init_subclass__ method.\n\nDefine a function to be added to the subclass in the assignment below.\n\nA class decorator.\n\nFunction to be added to the decorated class.\n\nReturn the class received as an argument.\n\nContinuing with builderlib.py in Example 24-11…\n\nExample 24-11. builderlib.py: bottom of the module\n\nclass Descriptor: print('@ Descriptor body')\n\ndef __init__(self): print(f'@ Descriptor.__init__({self!r})')\n\ndef __set_name__(self, owner, name): args = (self, owner, name) print(f'@ Descriptor.__set_name__{args!r}')\n\ndef __set__(self, instance, value): args = (self, instance, value) print(f'@ Descriptor.__set__{args!r}')\n\ndef __repr__(self): return '<Descriptor instance>'\n\nprint('@ builderlib module end')\n\nWhat Happens When: Import Time Versus Runtime\n\n|\n\n927\n\nA descriptor class to demonstrate when…\n\n…a descriptor instance is created, and when…\n\n…__set_name__ will be invoked during the owner class construction.\n\nLike the other methods, this __set__ doesn’t do anything except display its argu‐ ments.\n\nIf you import builderlib.py in the Python console, this is what you get:\n\n>>> import builderlib @ builderlib module start @ Builder body @ Descriptor body @ builderlib module end\n\nNote that the lines printed by builderlib.py are prefixed with @.\n\nNow let’s turn to evaldemo.py, which will trigger special methods in builderlib.py (Example 24-12).\n\nExample 24-12. evaldemo.py: script to experiment with builderlib.py\n\n#!/usr/bin/env python3\n\nfrom builderlib import Builder, deco, Descriptor\n\nprint('# evaldemo module start')\n\n@deco class Klass(Builder): print('# Klass body')\n\nattr = Descriptor()\n\ndef __init__(self): super().__init__() print(f'# Klass.__init__({self!r})')\n\ndef __repr__(self): return '<Klass instance>'\n\ndef main(): obj = Klass() obj.method_a() obj.method_b() obj.attr = 999\n\n928\n\n|\n\nChapter 24: Class Metaprogramming\n\nif __name__ == '__main__': main()\n\nprint('# evaldemo module end')\n\nApply a decorator.\n\nSubclass Builder to trigger its __init_subclass__.\n\nInstantiate the descriptor.\n\nThis will only be called if the module is run as the main program.\n\nThe print calls in evaldemo.py show a # prefix. If you open the console again and import evaldemo.py, Example 24-13 is the output.\n\nExample 24-13. Console experiment with evaldemo.py\n\n>>> import evaldemo @ builderlib module start @ Builder body @ Descriptor body @ builderlib module end # evaldemo module start # Klass body @ Descriptor.__init__(<Descriptor instance>) @ Descriptor.__set_name__(<Descriptor instance>, <class 'evaldemo.Klass'>, 'attr') @ Builder.__init_subclass__(<class 'evaldemo.Klass'>) @ deco(<class 'evaldemo.Klass'>) # evaldemo module end\n\nThe top four lines are the result of from builderlib import… . They will not appear if you didn’t close the console after the previous experiment, because buil‐ derlib.py is already loaded.\n\nThis signals that Python started reading the body of Klass. At this point, the class object does not exist yet.\n\nThe descriptor instance is created and bound to attr in the namespace that Python will pass to the default class object constructor: type.__new__.\n\nAt this point, Python’s built-in type.__new__ has created the Klass object and calls __set_name__ on each descriptor instance of descriptor classes that provide that method, passing Klass as the owner argument.\n\nWhat Happens When: Import Time Versus Runtime\n\n|\n\n929\n\ntype.__new__ then calls __init_subclass__ on the superclass of Klass, passing Klass as the single argument.\n\nWhen type.__new__ returns the class object, Python applies the decorator. In this example, the class returned by deco is bound to Klass in the module namespace.\n\nThe implementation of type.__new__ is written in C. The behavior I just described is documented in the “Creating the class object” section of Python’s “Data Model” ref‐ erence.\n\nNote that the main() function of evaldemo.py (Example 24-12) was not executed in the console session (Example 24-13), therefore no instance of Klass was created. All the action we saw was triggered by “import time” operations: importing builderlib and defining Klass.\n\nIf you run evaldemo.py as a script, you will see the same output as Example 24-13 with extra lines right before the end. The extra lines are the result of running main() (Example 24-14).\n\nExample 24-14. Running evaldemo.py as a program\n\n$ ./evaldemo.py [... 9 lines omitted ...] @ deco(<class '__main__.Klass'>) @ Builder.__init__(<Klass instance>) # Klass.__init__(<Klass instance>) @ SuperA.__init_subclass__:inner_0(<Klass instance>) @ deco:inner_1(<Klass instance>) @ Descriptor.__set__(<Descriptor instance>, <Klass instance>, 999) # evaldemo module end\n\nThe top 10 lines—including this one—are the same as shown in Example 24-13.\n\nTriggered by super().__init__() in Klass.__init__.\n\nTriggered by obj.method_a() SuperA.__init_subclass__.\n\nin main; method_a was\n\ninjected by\n\nTriggered by obj.method_b() in main; method_b was injected by deco.\n\nTriggered by obj.attr = 999 in main.\n\nA base class with __init_subclass__ and a class decorator are powerful tools, but they are limited to working with a class already built by type.__new__ under the\n\n930\n\n|\n\nChapter 24: Class Metaprogramming\n\ncovers. In the rare occasions when you need to adjust the arguments passed to type.__new__, you need a metaclass. That’s the final destination of this chapter—and this book.\n\nMetaclasses 101\n\n[Metaclasses] are deeper magic than 99% of users should ever worry about. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why).\n\n—Tim Peters, inventor of the Timsort algorithm and prolific Python contributor13\n\nA metaclass is a class factory. In contrast with record_factory from Example 24-2, a metaclass is written as a class. In other words, a metaclass is a class whose instances are classes. Figure 24-1 depicts a metaclass using the Mills & Gizmos Notation: a mill producing another mill.\n\nFigure 24-1. A metaclass is a class that builds classes.\n\nConsider the Python object model: classes are objects, therefore each class must be an instance of some other class. By default, Python classes are instances of type. In other words, type is the metaclass for most built-in and user-defined classes:\n\n>>> str.__class__ <class 'type'> >>> from bulkfood_v5 import LineItem >>> LineItem.__class__ <class 'type'>\n\n13 Message to comp.lang.python, subject: “Acrimony in c.l.p.”. This is another part of the same message from\n\nDecember 23, 2002, quoted in the Preface. The TimBot was inspired that day.\n\nMetaclasses 101\n\n|\n\n931\n\n>>> type.__class__ <class 'type'>\n\nTo avoid infinite regress, the class of type is type, as the last line shows.\n\nNote that I am not saying that str or LineItem are subclasses of type. What I am saying is that str and LineItem are instances of type. They all are subclasses of object. Figure 24-2 may help you confront this strange reality.\n\nFigure 24-2. Both diagrams are true. The left one emphasizes that str, type, and LineI tem are subclasses of object. The right one makes it clear that str, object, and LineI tem are instances type, because they are all classes.\n\nThe classes object and type have a unique relationship: object is an instance of type, and type is a subclass of object. This relation‐ ship is “magic”: it cannot be expressed in Python because either class would have to exist before the other could be defined. The fact that type is an instance of itself is also magical.\n\nThe next snippet shows that the class of collections.Iterable is abc.ABCMeta. Note that Iterable is an abstract class, but ABCMeta is a concrete class—after all, Iterable is an instance of ABCMeta:\n\n>>> from collections.abc import Iterable >>> Iterable.__class__ <class 'abc.ABCMeta'> >>> import abc >>> from abc import ABCMeta >>> ABCMeta.__class__ <class 'type'>\n\nUltimately, the class of ABCMeta is also type. Every class is an instance of type, directly or indirectly, but only metaclasses are also subclasses of type. That’s the most important relationship to understand metaclasses: a metaclass, such as ABCMeta,\n\n932\n\n|\n\nChapter 24: Class Metaprogramming\n\ninherits from type the power to construct classes. Figure 24-3 illustrates this crucial relationship.\n\nFigure 24-3. Iterable is a subclass of object and an instance of ABCMeta. Both object and ABCMeta are instances of type, but the key relationship here is that ABCMeta is also a subclass of type, because ABCMeta is a metaclass. In this diagram, Iterable is the only abstract class.\n\nThe important takeaway here is that metaclasses are subclasses of type, and that’s what makes them work as class factories. A metaclass can customize its instances by implementing special methods, as the next sections demonstrate.\n\nHow a Metaclass Customizes a Class To use a metaclass, it’s critical to understand how __new__ works on any class. This was discussed in “Flexible Object Creation with __new__” on page 843.\n\nThe same mechanics happen at a “meta” level when a metaclass is about to create a new instance, which is a class. Consider this declaration:\n\nclass Klass(SuperKlass, metaclass=MetaKlass): x = 42 def __init__(self, y): self.y = y\n\nTo process that class statement, Python calls MetaKlass.__new__ with these arguments:\n\nmeta_cls\n\nThe metaclass itself (MetaKlass), because __new__ works as class method.\n\nMetaclasses 101\n\n|\n\n933\n\ncls_name\n\nThe string Klass.\n\nbases\n\nThe single-element tuple (SuperKlass,), with more elements in the case of mul‐ tiple inheritance.\n\ncls_dict\n\nA mapping like:\n\n{x: 42, `__init__`: <function __init__ at 0x1009c4040>}\n\nWhen you implement MetaKlass.__new__, you can inspect and change those argu‐ ments before passing them to super().__new__, which will eventually call type.__new__ to create the new class object.\n\nAfter super().__new__ returns, you can also apply further processing to the newly created class before returning Klass.__init_subclass__, passing the class you created, and then applies a class decorator to it, if one is present. Finally, Python binds the class object to its name in the surrounding namespace—usually the global namespace of a module, if the class statement was a top-level statement.\n\nthen calls Super\n\nit\n\nto Python. Python\n\nThe most common processing made in a metaclass __new__ is to add or replace items in the cls_dict—the mapping that represents the namespace of the class under con‐ struction. For instance, before calling super().__new__, you can inject methods in the class under construction by adding functions to cls_dict. However, note that adding methods can also be done after the class is built, which is why we were able to do it using __init_subclass__ or a class decorator.\n\nOne attribute that you must add to the cls_dict before type.__new__ runs is __slots__, as discussed in “Why __init_subclass__ Cannot Configure __slots__” on page 921. The __new__ method of a metaclass is the ideal place to configure __slots__. The next section shows how to do that.\n\nA Nice Metaclass Example The MetaBunch metaclass presented here is a variation of the last example in Chapter 4 of Python in a Nutshell, 3rd ed., by Alex Martelli, Anna Ravenscroft, and Steve\n\n934\n\n|\n\nChapter 24: Class Metaprogramming\n\nHolden, written to run on Python 2.7 and 3.5.14 Assuming Python 3.6 or later, I was able to further simplify the code.\n\nFirst, let’s see what the Bunch base class provides:\n\n>>> class Point(Bunch): ... x = 0.0 ... y = 0.0 ... color = 'gray' ... >>> Point(x=1.2, y=3, color='green') Point(x=1.2, y=3, color='green') >>> p = Point() >>> p.x, p.y, p.color (0.0, 0.0, 'gray') >>> p Point()\n\nRemember that Checked assigns names to the Field descriptors in subclasses based on class variable type hints, which do not actually become attributes on the class since they don’t have values.\n\nBunch subclasses, on the other hand, use actual class attributes with values, which then become the default values of the instance attributes. The generated __repr__ omits the arguments for attributes that are equal to the defaults.\n\nMetaBunch—the metaclass of Bunch—generates __slots__ for the new class from the class attributes declared in the user’s class. This blocks the instantiation and later assignment of undeclared attributes:\n\n>>> Point(x=1, y=2, z=3) Traceback (most recent call last): ... AttributeError: No slots left for: 'z' >>> p = Point(x=21) >>> p.y = 42 >>> p Point(x=21, y=42) >>> p.flavor = 'banana' Traceback (most recent call last): ... AttributeError: 'Point' object has no attribute 'flavor'\n\n14 The authors kindly gave me permission to use their example. MetaBunch first appeared in a message posted by Martelli in the comp.lang.python group on July 7, 2002, with the subject line “a nice metaclass example (was Re: structs in python)”, following a discussion about record-like data structures in Python. Martelli’s original code for Python 2.2 still runs after a single change: to use a metaclass in Python 3, you must use the metaclass keyword argument in the class declaration, e.g., Bunch(metaclass=MetaBunch), instead of the older conven‐ tion of adding a __metaclass__ class-level attribute.\n\nMetaclasses 101\n\n|\n\n935\n\nNow let’s dive into the elegant code of MetaBunch in Example 24-15.\n\nExample 24-15. metabunch/from3.6/bunch.py: MetaBunch metaclass and Bunch class\n\nclass MetaBunch(type): def __new__(meta_cls, cls_name, bases, cls_dict):\n\ndefaults = {}\n\ndef __init__(self, **kwargs): for name, default in defaults.items(): setattr(self, name, kwargs.pop(name, default)) if kwargs: extra = ', '.join(kwargs) raise AttributeError(f'No slots left for: {extra!r}')\n\ndef __repr__(self): rep = ', '.join(f'{name}={value!r}' for name, default in defaults.items() if (value := getattr(self, name)) != default) return f'{cls_name}({rep})'\n\nnew_dict = dict(__slots__=[], __init__=__init__, __repr__=__repr__)\n\nfor name, value in cls_dict.items(): if name.startswith('__') and name.endswith('__'): if name in new_dict: raise AttributeError(f\"Can't set {name!r} in {cls_name!r}\") new_dict[name] = value else: new_dict['__slots__'].append(name) defaults[name] = value return super().__new__(meta_cls, cls_name, bases, new_dict)\n\nclass Bunch(metaclass=MetaBunch): pass\n\nTo create a new metaclass, inherit from type.\n\n__new__ works as a class method, but the class is a metaclass, so I like to name the first argument meta_cls (mcs is a common alternative). The remaining three arguments are the same as the three-argument signature for calling type() directly to create a class.\n\ndefaults will hold a mapping of attribute names and their default values.\n\nThis will be injected into the new class.\n\n936\n\n|\n\nChapter 24: Class Metaprogramming\n\nRead the defaults and set the corresponding instance attribute with a value pop‐ ped from kwargs or a default.\n\nIf there is still any item in kwargs, it means there are no slots left where we can place them. We believe in failing fast as best practice, so we don’t want to silently ignore extra items. A quick and effective solution is to pop one item from kwargs and try to set it on the instance, triggering an AttributeError on purpose.\n\n__repr__ returns a string that looks like a constructor call—e.g., Point(x=3), omitting the keyword arguments with default values.\n\nInitialize namespace for the new class.\n\nIterate over the namespace of the user’s class.\n\nIf a dunder name is found, copy the item to the new class namespace, unless it’s already there. This prevents users from overwriting __init__, __repr__, and other attributes set by Python, such as __qualname__ and __module__.\n\nIf not a dunder name, append to __slots__ and save its value in defaults.\n\nBuild and return the new class.\n\nProvide a base class, so users don’t need to see MetaBunch.\n\nMetaBunch works because it is able to configure __slots__ before calling super().__new__ to build the final class. As usual when metaprogramming, under‐ standing the sequence of actions is key. Let’s do another evaluation time experiment, now with a metaclass.\n\nMetaclass Evaluation Time Experiment This is a variation of “Evaluation Time Experiments” on page 926, adding a metaclass to the mix. The builderlib.py module is the same as before, but the main script is now evaldemo_meta.py, listed in Example 24-16.\n\nExample 24-16. evaldemo_meta.py: experimenting with a metaclass\n\n#!/usr/bin/env python3\n\nfrom builderlib import Builder, deco, Descriptor from metalib import MetaKlass\n\nprint('# evaldemo_meta module start')\n\nMetaclasses 101\n\n|\n\n937\n\n@deco class Klass(Builder, metaclass=MetaKlass): print('# Klass body')\n\nattr = Descriptor()\n\ndef __init__(self): super().__init__() print(f'# Klass.__init__({self!r})')\n\ndef __repr__(self): return '<Klass instance>'\n\ndef main(): obj = Klass() obj.method_a() obj.method_b() obj.method_c() obj.attr = 999\n\nif __name__ == '__main__': main()\n\nprint('# evaldemo_meta module end')\n\nImport MetaKlass from metalib.py, which we’ll see in Example 24-18.\n\nDeclare Klass as a subclass of Builder and an instance of MetaKlass.\n\nThis method is injected by MetaKlass.__new__, as we’ll see.\n\nIn the interest of science, Example 24-16 defies all reason and applies three different metaprogramming techniques together on Klass: a decorator, a base class using __init_subclass__, and a custom metaclass. If you do this in production code, please don’t blame me. Again, the goal is to observe the order in which the three techniques interfere in the class construction process.\n\nAs in the previous evaluation time experiment, this example does nothing but print messages revealing the flow of execution. Example 24-17 shows the code for the top part of metalib.py—the rest is in Example 24-18.\n\nExample 24-17. metalib.py: the NosyDict class\n\nprint('% metalib module start')\n\n938\n\n|\n\nChapter 24: Class Metaprogramming",
      "page_number": 930
    },
    {
      "number": 47,
      "title": "Segment 47 (pages 952-973)",
      "start_page": 952,
      "end_page": 973,
      "detection_method": "synthetic",
      "content": "import collections\n\nclass NosyDict(collections.UserDict): def __setitem__(self, key, value): args = (self, key, value) print(f'% NosyDict.__setitem__{args!r}') super().__setitem__(key, value)\n\ndef __repr__(self): return '<NosyDict instance>'\n\nI wrote the NosyDict class to override __setitem__ to display each key and value as they are set. The metaclass will use a NosyDict instance to hold the namespace of the class under construction, revealing more of Python’s inner workings.\n\nThe main attraction of metalib.py is the metaclass in Example 24-18. It implements the __prepare__ special method, a class method that Python only invokes on meta‐ classes. The __prepare__ method provides the earliest opportunity to influence the process of creating a new class.\n\nWhen coding a metaclass, I find it useful to adopt this naming con‐ vention for special method arguments:\n\nUse cls instead of self for instance methods, because the instance is a class.\n\nUse meta_cls instead of cls for class methods, because the class is a metaclass. Recall that __new__ behaves as a class method even without the @classmethod decorator.\n\nExample 24-18. metalib.py: the MetaKlass\n\nclass MetaKlass(type): print('% MetaKlass body')\n\n@classmethod def __prepare__(meta_cls, cls_name, bases): args = (meta_cls, cls_name, bases) print(f'% MetaKlass.__prepare__{args!r}') return NosyDict()\n\ndef __new__(meta_cls, cls_name, bases, cls_dict): args = (meta_cls, cls_name, bases, cls_dict) print(f'% MetaKlass.__new__{args!r}') def inner_2(self): print(f'% MetaKlass.__new__:inner_2({self!r})')\n\ncls = super().__new__(meta_cls, cls_name, bases, cls_dict.data)\n\nMetaclasses 101\n\n|\n\n939\n\ncls.method_c = inner_2\n\nreturn cls\n\ndef __repr__(cls): cls_name = cls.__name__ return f\"<class {cls_name!r} built by MetaKlass>\"\n\nprint('% metalib module end')\n\n__prepare__ should be declared as a class method. It is not an instance method because the class under construction does not exist yet when Python calls __prepare__.\n\nPython calls __prepare__ on a metaclass to obtain a mapping to hold the name‐ space of the class under construction.\n\nReturn NosyDict instance to be used as the namespace.\n\ncls_dict is a NosyDict instance returned by __prepare__.\n\ntype.__new__ requires a real dict as the last argument, so I give it the data attribute of NosyDict, inherited from UserDict.\n\nInject a method in the newly created class.\n\nAs usual, __new__ must return the object just created—in this case, the new class.\n\nDefining __repr__ on a metaclass allows customizing the repr() of class objects.\n\nThe main use case for __prepare__ before Python 3.6 was to provide an OrderedDict to hold the attributes of the class under construction, so that the metaclass __new__ could process those attributes in the order in which they appear in the source code of the user’s class definition. Now that dict preserves the insertion order, __prepare__ is rarely needed. You will see a creative use for it in “A Metaclass Hack with __pre‐ pare__” on page 950.\n\nImporting metalib.py in the Python console is not very exciting. Note the use of % to prefix the lines output by this module:\n\n>>> import metalib % metalib module start % MetaKlass body % metalib module end\n\nLots of things happen if you import evaldemo_meta.py, as you can see in Example 24-19.\n\n940\n\n|\n\nChapter 24: Class Metaprogramming\n\nExample 24-19. Console experiment with evaldemo_meta.py\n\n>>> import evaldemo_meta @ builderlib module start @ Builder body @ Descriptor body @ builderlib module end % metalib module start % MetaKlass body % metalib module end # evaldemo_meta module start % MetaKlass.__prepare__(<class 'metalib.MetaKlass'>, 'Klass', (<class 'builderlib.Builder'>,)) % NosyDict.__setitem__(<NosyDict instance>, '__module__', 'evaldemo_meta') % NosyDict.__setitem__(<NosyDict instance>, '__qualname__', 'Klass') # Klass body @ Descriptor.__init__(<Descriptor instance>) % NosyDict.__setitem__(<NosyDict instance>, 'attr', <Descriptor instance>) % NosyDict.__setitem__(<NosyDict instance>, '__init__', <function Klass.__init__ at …>) % NosyDict.__setitem__(<NosyDict instance>, '__repr__', <function Klass.__repr__ at …>) % NosyDict.__setitem__(<NosyDict instance>, '__classcell__', <cell at …: empty>) % MetaKlass.__new__(<class 'metalib.MetaKlass'>, 'Klass', (<class 'builderlib.Builder'>,), <NosyDict instance>) @ Descriptor.__set_name__(<Descriptor instance>, <class 'Klass' built by MetaKlass>, 'attr') @ Builder.__init_subclass__(<class 'Klass' built by MetaKlass>) @ deco(<class 'Klass' built by MetaKlass>) # evaldemo_meta module end\n\nThe lines before this are the result of importing builderlib.py and metalib.py.\n\nPython invokes __prepare__ to start processing a class statement.\n\nBefore parsing the class body, Python adds the __module__ and __qualname__ entries to the namespace of the class under construction.\n\nThe descriptor instance is created…\n\n…and bound to attr in the class namespace.\n\n__init__ and __repr__ methods are defined and added to the namespace.\n\nOnce Python finishes processing the class body, it calls MetaKlass.__new__.\n\n__set_name__, __init_subclass__, and the decorator are invoked in this order, after the __new__ method of the metaclass returns the newly constructed class.\n\nMetaclasses 101\n\n|\n\n941\n\nIf you run evaldemo_meta.py as script, main() is called, and a few more things happen (Example 24-20).\n\nExample 24-20. Running evaldemo_meta.py as a program\n\n$ ./evaldemo_meta.py [... 20 lines omitted ...] @ deco(<class 'Klass' built by MetaKlass>) @ Builder.__init__(<Klass instance>) # Klass.__init__(<Klass instance>) @ SuperA.__init_subclass__:inner_0(<Klass instance>) @ deco:inner_1(<Klass instance>) % MetaKlass.__new__:inner_2(<Klass instance>) @ Descriptor.__set__(<Descriptor instance>, <Klass instance>, 999) # evaldemo_meta module end\n\nThe top 21 lines—including this one—are the same shown in Example 24-19.\n\nTriggered by obj.method_c() in main; method_c was injected by Meta Klass.__new__.\n\nLet’s now go back to the idea of the Checked class with the Field descriptors imple‐ menting runtime type validation, and see how it can be done with a metaclass.\n\nA Metaclass Solution for Checked I don’t want to encourage premature optimization and overengineering, so here is a make-believe scenario to justify rewriting checkedlib.py with __slots__, which requires the application of a metaclass. Feel free to skip it.\n\nA Bit of Storytelling Our checkedlib.py using __init_subclass__ is a company-wide success, and our pro‐ duction servers have millions of instances of Checked subclasses in memory at any one time.\n\nProfiling a proof-of-concept, we discover that using __slots__ will reduce the cloud hosting bill for two reasons:\n\nLower memory usage, as Checked instances don’t need their own __dict__ • Higher performance, by removing __setattr__, which was created just to block unexpected attributes, but is triggered at instantiation and for all attribute setting before Field.__set__ is called to do its job\n\n942\n\n|\n\nChapter 24: Class Metaprogramming\n\nThe metaclass/checkedlib.py module we’ll study next is a drop-in replacement for init‐ sub/checkedlib.py. The doctests embedded in them are identical, as well as the check‐ edlib_test.py files for pytest.\n\nThe complexity in checkedlib.py is abstracted away from the user. Here is the source code of a script using the package:\n\nfrom checkedlib import Checked\n\nclass Movie(Checked): title: str year: int box_office: float\n\nif __name__ == '__main__': movie = Movie(title='The Godfather', year=1972, box_office=137) print(movie) print(movie.title)\n\nThat concise Movie class definition leverages three instances of the Field validating descriptor, a __slots__ configuration, five methods inherited from Checked, and a metaclass to put it all together. The only visible part of checkedlib is the Checked base class.\n\nConsider Figure 24-4. The Mills & Gizmos Notation complements the UML class diagram by making the relationship between classes and instances more visible.\n\nFor example, a Movie class using the new checkedlib.py is an instance of CheckedMeta, and a subclass of Checked. Also, the title, year, and box_office class attributes of Movie are three separate instances of Field. Each Movie instance has its own _title, _year, and _box_office attributes, to store the values of the corresponding fields.\n\nNow let’s study the code, starting with the Field class, shown in Example 24-21.\n\nThe Field descriptor class is now a bit different. In the previous examples, each Field descriptor instance stored its value in the managed instance using an attribute of the same name. For example, in the Movie class, the title descriptor stored the field value in a title attribute in the managed instance. This made it unnecessary for Field to provide a __get__ method.\n\nHowever, when a class like Movie uses __slots__, it cannot have class attributes and instance attributes with the same name. Each descriptor instance is a class attribute, and now we need separate per-instance storage attributes. The code uses the descrip‐ tor name prefixed with a single _. Therefore Field instances have separate name and storage_name attributes, and we implement Field.__get__.\n\nA Metaclass Solution for Checked\n\n|\n\n943\n\nFigure 24-4. UML class diagram annotated with MGN: the CheckedMeta meta-mill builds the Movie mill. The Field mill builds the title, year, and box_office descrip‐ tors, which are class attributes of Movie. The per-instance data for the fields is stored in the _title, _year, and _box_office instance attributes of Movie. Note the package boundary of checkedlib. The developer of Movie doesn’t need to grok all the machi‐ nery inside checkedlib.py.\n\nExample 24-21 shows the source code for Field, with callouts describing only the changes in this version.\n\nExample 24-21. metaclass/checkedlib.py: the Field descriptor with storage_name and __get__\n\nclass Field: def __init__(self, name: str, constructor: Callable) -> None: if not callable(constructor) or constructor is type(None): raise TypeError(f'{name!r} type hint must be callable') self.name = name self.storage_name = '_' + name self.constructor = constructor\n\ndef __get__(self, instance, owner=None): if instance is None: return self return getattr(instance, self.storage_name)\n\ndef __set__(self, instance: Any, value: Any) -> None: if value is ...: value = self.constructor() else:\n\n944\n\n|\n\nChapter 24: Class Metaprogramming\n\ntry: value = self.constructor(value) except (TypeError, ValueError) as e: type_name = self.constructor.__name__ msg = f'{value!r} is not compatible with {self.name}:{type_name}' raise TypeError(msg) from e setattr(instance, self.storage_name, value)\n\nCompute storage_name from the name argument.\n\nIf __get__ gets None as the instance argument, the descriptor is being read from the managed class itself, not a managed instance. So we return the descriptor.\n\nOtherwise, return the value stored in the attribute named storage_name.\n\n__set__ now uses setattr to set or update the managed attribute.\n\nExample 24-22 shows the code for the metaclass that drives this example.\n\nExample 24-22. metaclass/checkedlib.py: the CheckedMeta metaclass\n\nclass CheckedMeta(type):\n\ndef __new__(meta_cls, cls_name, bases, cls_dict): if '__slots__' not in cls_dict: slots = [] type_hints = cls_dict.get('__annotations__', {}) for name, constructor in type_hints.items(): field = Field(name, constructor) cls_dict[name] = field slots.append(field.storage_name)\n\ncls_dict['__slots__'] = slots\n\nreturn super().__new__( meta_cls, cls_name, bases, cls_dict)\n\n__new__ is the only method implemented in CheckedMeta.\n\nOnly enhance the class if its cls_dict doesn’t include __slots__. If __slots__ is already present, assume it is the Checked base class and not a user-defined sub‐ class, and build the class as is.\n\nTo get the type hints in prior examples, we used typing.get_type_hints, but that requires an existing class as the first argument. At this point, the class we are configuring does not exist yet, so we need to retrieve the __annotations__\n\nA Metaclass Solution for Checked\n\n|\n\n945\n\ndirectly from the cls_dict—the namespace of the class under construction, which Python passes as the last argument to the metaclass __new__.\n\nIterate over type_hints to…\n\n…build a Field for each annotated attribute…\n\n…overwrite the corresponding entry in cls_dict with the Field instance…\n\n…and append the storage_name of the field in the list we’ll use to…\n\n…populate the __slots__ entry in cls_dict—the namespace of the class under construction.\n\nFinally, we call super().__new__.\n\nThe last part of metaclass/checkedlib.py is the Checked base class that users of this library will subclass to enhance their classes, like Movie.\n\nThe code for this version of Checked is the same as Checked in initsub/checkedlib.py (listed in Example 24-5 and Example 24-6), with three changes:\n\n1. Added an empty __slots__ to signal to CheckedMeta.__new__ that this class doesn’t require special processing.\n\n2. Removed __init_subclass__. Its job is now done by CheckedMeta.__new__. 3. Removed __setattr__. It became redundant because adding __slots__ to the user-defined class prevents setting undeclared attributes.\n\nExample 24-23 is a complete listing of the final version of Checked.\n\nExample 24-23. metaclass/checkedlib.py: the Checked base class\n\nclass Checked(metaclass=CheckedMeta): __slots__ = () # skip CheckedMeta.__new__ processing\n\n@classmethod def _fields(cls) -> dict[str, type]: return get_type_hints(cls)\n\ndef __init__(self, **kwargs: Any) -> None: for name in self._fields(): value = kwargs.pop(name, ...) setattr(self, name, value) if kwargs: self.__flag_unknown_attrs(*kwargs)\n\n946\n\n|\n\nChapter 24: Class Metaprogramming\n\ndef __flag_unknown_attrs(self, *names: str) -> NoReturn: plural = 's' if len(names) > 1 else '' extra = ', '.join(f'{name!r}' for name in names) cls_name = repr(self.__class__.__name__) raise AttributeError(f'{cls_name} object has no attribute{plural} {extra}')\n\ndef _asdict(self) -> dict[str, Any]: return { name: getattr(self, name) for name, attr in self.__class__.__dict__.items() if isinstance(attr, Field) }\n\ndef __repr__(self) -> str: kwargs = ', '.join( f'{key}={value!r}' for key, value in self._asdict().items() ) return f'{self.__class__.__name__}({kwargs})'\n\nThis concludes the third rendering of a class builder with validated descriptors.\n\nThe next section covers some general issues related to metaclasses.\n\nMetaclasses in the Real World Metaclasses are powerful, but tricky. Before deciding to implement a metaclass, con‐ sider the following points.\n\nModern Features Simplify or Replace Metaclasses Over time, several common use cases of metaclasses were made redundant by new language features:\n\nClass decorators\n\nSimpler to understand than metaclasses, and less likely to cause conflicts with base classes and metaclasses.\n\n__set_name__\n\nAvoids the need for custom metaclass logic to automatically set the name of a descriptor.15\n\n15 In the first edition of Fluent Python, the more advanced versions of the LineItem class used a metaclass just to set the storage name of the attributes. See the code in the metaclasses of bulkfood in the first edition code repository.\n\nMetaclasses in the Real World\n\n|\n\n947\n\n__init_subclass__\n\nProvides a way to customize class creation that is transparent to the end user and even simpler than a decorator—but may introduce conflicts in a complex class hierarchy.\n\nBuilt-in dict preserving key insertion order\n\nEliminated the #1 reason to use __prepare__: to provide an OrderedDict to store the namespace of the class under construction. Python only calls __prepare__ on metaclasses, so if you needed to process the class namespace in the order it appears in the source code, you had to use a metaclass before Python 3.6.\n\nAs of 2021, every actively maintained version of CPython supports all the features just listed.\n\nI keep advocating these features because I see too much unnecessary complexity in our profession, and metaclasses are a gateway to complexity.\n\nMetaclasses Are Stable Language Features Metaclasses were introduced in Python 2.2 in 2002, together with so-called “new- style classes,” descriptors, and properties.\n\nIt is remarkable that the MetaBunch example, first posted by Alex Martelli in July 2002, still works in Python 3.9—the only change being the way to specify the meta‐ class to use, which in Python 3 is done with the syntax class Bunch(metaclass=Meta Bunch):.\n\nNone of the additions I mentioned in “Modern Features Simplify or Replace Meta‐ classes” on page 947 broke existing code using metaclasses. But legacy code using metaclasses can often be simplified by leveraging those features, especially if you can drop support to Python versions before 3.6—which are no longer maintained.\n\nA Class Can Only Have One Metaclass If your class declaration involves two or more metaclasses, you will see this puzzling error message:\n\nTypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases\n\nThis may happen even without multiple inheritance. For example, a declaration like this could trigger that TypeError:\n\nclass Record(abc.ABC, metaclass=PersistentMeta): pass\n\nWe saw that abc.ABC is an instance of the abc.ABCMeta metaclass. If that Persistent metaclass is not itself a subclass of abc.ABCMeta, you get a metaclass conflict.\n\n948\n\n|\n\nChapter 24: Class Metaprogramming\n\nThere are two ways of dealing with that error:\n\nFind some other way of doing what you need to do, while avoiding at least one of the metaclasses involved.\n\nWrite your own PersistentABCMeta metaclass as a subclass of both abc.ABCMeta and PersistentMeta, using multiple inheritance, and use that as the only meta‐ class for Record.16\n\nI can imagine the solution of the metaclass with two base meta‐ classes implemented to meet a deadline. In my experience, meta‐ class programming always takes longer than anticipated, which makes this approach risky before a hard deadline. If you do it and make the deadline, the code may contain subtle bugs. Even in the absence of known bugs, you should consider this approach as tech‐ nical debt simply because it is hard to understand and maintain.\n\nMetaclasses Should Be Implementation Details Besides type, there are only six metaclasses in the entire Python 3.9 standard library. The better known metaclasses are probably abc.ABCMeta, typing.NamedTupleMeta, and enum.EnumMeta. None of them are intended to appear explicitly in user code. We may consider them implementation details.\n\nAlthough you can do some really wacky metaprogramming with metaclasses, it’s best to heed the principle of least astonishment so that most users can indeed regard met‐ aclasses as implementation details.17\n\nIn recent years, some metaclasses in the Python standard library were replaced by other mechanisms, without breaking the public API of their packages. The simplest way to future-proof such APIs is to offer a regular class that users subclass to access the functionality provided by the metaclass, as we’ve done in our examples.\n\nTo wrap up our coverage of class metaprogramming, I will share with you the cool‐ est, small example of metaclass I found as I researched this chapter.\n\n16 If you just got dizzy considering the implications of multiple inheritance with metaclasses, good for you. I’d\n\nstay way from this solution as well.\n\n17 I made a living writing Django code for a few years before I decided to study how Django’s model fields were\n\nimplemented. Only then I learned about descriptors and metaclasses.\n\nMetaclasses in the Real World\n\n|\n\n949\n\nA Metaclass Hack with __prepare__ When I updated this chapter for the second edition, I needed to find simple but illu‐ minating examples to replace the bulkfood LineItem code that no longer require met‐ aclasses since Python 3.6.\n\nThe simplest and most interesting metaclass idea was given to me by João S. O. Bueno—better known as JS in the Brazilian Python community. One application of his idea is to create a class that autogenerates numeric constants:\n\n>>> class Flavor(AutoConst): ... banana ... coconut ... vanilla ... >>> Flavor.vanilla 2 >>> Flavor.banana, Flavor.coconut (0, 1)\n\nYes, that code works as shown! That’s actually a doctest in autoconst_demo.py.\n\nHere is the user-friendly AutoConst base class and the metaclass behind it, imple‐ mented in autoconst.py:\n\nclass AutoConstMeta(type): def __prepare__(name, bases, **kwargs): return WilyDict()\n\nclass AutoConst(metaclass=AutoConstMeta): pass\n\nThat’s it.\n\nClearly the trick is in WilyDict.\n\nWhen Python processes the namespace of the user’s class and reads banana, it looks up that name in the mapping provided by __prepare__: an instance of WilyDict. WilyDict implements __missing__, covered in “The __missing__ Method” on page 91. The WilyDict instance initially has no 'banana' key, so the __missing__ method is triggered. It makes an item on the fly with the key 'banana' and the value 0, returning that value. Python is happy with that, then tries to retrieve 'coconut'. Wily Dict promptly adds that entry with the value 1, returning it. The same happens with 'vanilla', which is then mapped to 2.\n\n950\n\n|\n\nChapter 24: Class Metaprogramming\n\nWe’ve seen __prepare__ and __missing__ before. The real innovation is how JS put them together.\n\nHere is the source code for WilyDict, also from autoconst.py:\n\nclass WilyDict(dict): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.__next_value = 0\n\ndef __missing__(self, key): if key.startswith('__') and key.endswith('__'): raise KeyError(key) self[key] = value = self.__next_value self.__next_value += 1 return value\n\nWhile experimenting, I found that Python looked up __name__ in the namespace of the class under construction, causing WilyDict to add a __name__ entry, and incre‐ ment __next_value. So I added that if statement in __missing__ to raise KeyError for keys that look like dunder attributes.\n\nThe autoconst.py package both requires and illustrates mastery of Python’s dynamic class building machinery.\n\nI had a great time adding more functionality to AutoConstMeta and AutoConst, but instead of sharing my experiments, I will let you have fun playing with JS’s ingenious hack.\n\nHere are some ideas:\n\nMake it possible to retrieve the constant name if you have the value. For example, Flavor[2] could return 'vanilla'. You can to this by implementing __geti tem__ in AutoConstMeta. Since Python 3.9, you can implement __class_geti tem__ in AutoConst itself.\n\nSupport iteration over the class, by implementing __iter__ on the metaclass. I would make the __iter__ yield the constants as (name, value) pairs.\n\nImplement a new Enum variant. This would be a major undertaking, because the enum package is full of tricks, including the EnumMeta metaclass with hundreds of lines of code and a nontrivial __prepare__ method.\n\nEnjoy!\n\nA Metaclass Hack with __prepare__\n\n|\n\n951\n\nThe __class_getitem__ special method was added in Python 3.9 to support generic types, as part of PEP 585—Type Hinting Gener‐ ics In Standard Collections. Thanks to __class_getitem__, Python’s core developers did not have to write a new metaclass for the built-in types to implement __getitem__ so that we could write generic type hints like list[int]. This is a narrow feature, but rep‐ resentative of a wider use case for metaclasses: implementing oper‐ ators and other special methods to work at the class level, such as making the class itself iterable, just like Enum subclasses.\n\nWrapping Up Metaclasses, as well as class decorators and __init_subclass__ are useful for:\n\nSubclass registration\n\nSubclass structural validation\n\nApplying decorators to many methods at once\n\nObject serialization\n\nObject-relational mapping\n\nObject-based persistence\n\nImplementing special methods at the class level\n\nImplementing class features found in other languages, such as traits and aspect- oriented programming\n\nClass metaprogramming can also help with performance issues in some cases, by per‐ forming tasks at import time that otherwise would execute repeatedly at runtime.\n\nTo wrap up, let’s recall Alex Martelli’s final advice from his essay “Waterfowl and ABCs” on page 443:\n\nAnd, don’t define custom ABCs (or metaclasses) in production code… if you feel the urge to do so, I’d bet it’s likely to be a case of “all problems look like a nail”-syndrome for somebody who just got a shiny new hammer—you (and future maintainers of your code) will be much happier sticking with straightforward and simple code, eschewing such depths.\n\nI believe Martelli’s advice applies not only to ABCs and metaclasses, but also to class hierarchies, operator overloading, function decorators, descriptors, class decorators, and class builders using __init_subclass__.\n\nThose powerful tools exist primarily to support library and framework development. Applications naturally should use those tools, as provided by the Python standard\n\n952\n\n|\n\nChapter 24: Class Metaprogramming\n\nlibrary or external packages. But implementing them in application code is often pre‐ mature abstraction.\n\nGood frameworks are extracted, not invented.18\n\n—David Heinemeier Hansson, creator of Ruby on Rails\n\nChapter Summary This chapter started with an overview of attributes found in class objects, such as __qualname__ and the __subclasses__() method. Next, we saw how the type built- in can be used to construct classes at runtime.\n\nThe __init_subclass__ special method was introduced, with the first iteration of a Checked base class designed to replace attribute type hints in user-defined subclasses with Field instances that apply constructors to enforce the type of those attributes at runtime.\n\nThe same idea was implemented with a @checked class decorator that adds features to user-defined classes, similar to what __init_subclass__ allows. We saw that neither __init_subclass__ nor a class decorator can dynamically configure __slots__, because they operate only after a class is created.\n\nThe concepts of “import time” and “runtime” were clarified with experiments show‐ ing the order in which Python code is executed when modules, descriptors, class dec‐ orators, and __init_subclass__ is involved.\n\nOur coverage of metaclasses began with an overall explanation of type as a metaclass, and how user-defined metaclasses can implement __new__ to customize the classes it builds. We then saw our first custom metaclass, the classic MetaBunch example using __slots__. Next, another evaluation time experiment demonstrated how the __pre pare__ and __new__ methods of a metaclass are invoked earlier than __init_sub class__ and class decorators, providing opportunities for deeper class customization.\n\nThe third iteration of a Checked class builder with Field descriptors and custom __slots__ configuration was presented, followed by some general considerations about metaclass usage in practice.\n\nFinally, we saw the AutoConst hack invented by João S. O. Bueno, based on the cun‐ ning idea of a metaclass with __prepare__ returning a mapping that implements __missing__. In less than 20 lines of code, autoconst.py showcases the power of com‐ bining Python metaprogramming techniques\n\n18 The phrase is widely quoted. I found an early direct quote in a post in DHH’s blog from 2005.\n\nChapter Summary\n\n|\n\n953\n\nI haven’t yet found a language that manages to be easy for beginners, practical for professionals, and exciting for hackers in the way that Python is. Thanks, Guido van Rossum and everybody else who makes it so.\n\nFurther Reading Caleb Hattingh—a technical reviewer of this book—wrote the autoslot package, pro‐ viding a metaclass to automatically create a __slots__ attribute in a user-defined class by inspecting the bytecode of __init__ and finding all assignments to attributes of self. It’s useful and also an excellent example to study: only 74 lines of code in autoslot.py, including 20 lines of comments explaining the most difficult parts.\n\nThe essential references for this chapter in the Python documentation are “3.3.3. Cus‐ tomizing class creation” in the “Data Model” chapter of The Python Language Refer‐ ence, which covers __init_subclass__ and metaclasses. The type class documentation in the “Built-in Functions” page, and “4.13. Special Attributes” of the “Built-in Types” chapter in the The Python Standard Library are also essential read‐ ing.\n\nIn the The Python Standard Library, the types module documentation covers two class metaprogramming: that functions added types.new_class and types.prepare_class.\n\nin Python 3.3\n\nsimplify\n\nClass decorators were formalized in PEP 3129—Class Decorators, written by Collin Winter, with the reference implementation authored by Jack Diederich. The PyCon 2009 talk “Class Decorators: Radically Simple” (video), also by Jack Diederich, is a quick introduction to the feature. Besides @dataclass, an interesting—and much simpler—example of a class decorator in Python’s standard library is func tools.total_ordering that generates special methods for object comparison.\n\nFor metaclasses, the main reference in Python’s documentation is PEP 3115—Meta‐ classes in Python 3000, in which the __prepare__ special method was introduced.\n\nPython in a Nutshell, 3rd ed., by Alex Martelli, Anna Ravenscroft, and Steve Holden, is authoritative, but was written before PEP 487—Simpler customization of class cre‐ ation came out. The main metaclass example in that book—MetaBunch—is still valid, because it can’t be written with simpler mechanisms. Brett Slatkin’s Effective Python, 2nd ed. (Addison-Wesley) has several up-to-date examples of class building techni‐ ques, including metaclasses.\n\n954\n\n|\n\nChapter 24: Class Metaprogramming\n\nTo learn about the origins of class metaprogramming in Python, I recommend Guido van Rossum’s paper from 2003, “Unifying types and classes in Python 2.2”. The text applies to modern Python as well, as it covers what were then called the “new-style” class semantics—the default semantics in Python 3—including descriptors and meta‐ classes. One of the references cited by Guido is Putting Metaclasses to Work: a New Dimension in Object-Oriented Programming, by Ira R. Forman and Scott H. Danforth (Addison-Wesley), a book to which he gave five stars on Amazon.com, adding the following review:\n\nThis book contributed to the design for metaclasses in Python 2.2\n\nToo bad this is out of print; I keep referring to it as the best tutorial I know for the difficult subject of cooperative multiple inheritance, supported by Python via the super() function.19\n\nIf you are keen on metaprogramming, you may wish Python had the ultimate meta‐ programming feature: syntactic macros, as offered in the Lisp family of languages and —more recently—by Elixir and Rust. Syntactic macros are more powerful and less error prone than the primitive code substitution macros in the C language. They are special functions that rewrite source code using custom syntax into standard code before the compilation step, enabling developers to introduce new language con‐ structs without changing the compiler. Like operator overloading, syntactic macros can be abused. But as long as the community understands and manages the down‐ sides, they support powerful and user-friendly abstractions, like DSLs (Domain- Specific Languages). In September 2020, Python core developer Mark Shannon posted PEP 638—Syntactic Macros, advocating just that. A year after it was initially published, PEP 638 was still in draft and there were no ongoing discussions about it. Clearly it’s not a top priority for the Python core developers. I would like to see PEP 638 further discussed and eventually approved. Syntactic macros would allow the Python community to experiment with controversial new features, such as the walrus operator (PEP 572), pattern matching (PEP 634), and alternative rules for evaluating type hints (PEPs 563 and 649) before making permanent changes to the core lan‐ guage. Meanwhile, you can get a taste of syntactic macros with the MacroPy package.\n\n19 I bought a used copy and found it a very challenging read.\n\nFurther Reading\n\n|\n\n955\n\nSoapbox I will start the last soapbox in the book with a long quote from Brian Harvey and Matthew Wright, two computer science professors from the University of California (Berkeley and Santa Barbara). In their book, Simply Scheme: Introducing Computer Science (MIT Press), Harvey and Wright wrote:\n\nThere are two schools of thought about teaching computer science. We might carica‐ ture the two views this way:\n\n1. The conservative view: Computer programs have become too large and com‐ plex to encompass in a human mind. Therefore, the job of computer science education is to teach people how to discipline their work in such a way that 500 mediocre programmers can join together and produce a program that correctly meets its specification.\n\n2. The radical view: Computer programs have become too large and complex to encompass in a human mind. Therefore, the job of computer science education is to teach people how to expand their minds so that the programs can fit, by learning to think in a vocabulary of larger, more powerful, more flexible ideas than the obvious ones. Each unit of programming thought must have a big pay‐ off in the capabilities of the program. —Brian Harvey and Matthew Wright, preface to Simply Scheme20\n\nHarvey and Wright’s exaggerated descriptions are about teaching computer science, but they also apply to programming language design. By now, you should have guessed that I subscribe to the “radical” view, and I believe Python was designed in that spirit.\n\nThe property idea is a great step forward compared to the accessors-from-the-start approach practically demanded by Java and supported by Java IDEs generating get‐ ters/setters with a keyboard shortcut. The main advantage of properties is to let us start our programs simply exposing attributes as public—in the spirit of KISS—know‐ ing a public attribute can become a property at any time without much pain. But the descriptor idea goes way beyond that, providing a framework for abstracting away repetitive accessor logic. That framework is so effective that essential Python con‐ structs use it behind the scenes.\n\nAnother powerful idea is functions as first-class objects, paving the way to higher- order functions. Turns out the combination of descriptors and higher-order func‐ tions enable the unification of functions and methods. A function’s __get__ produces\n\n20 See p. xvii. Full text available at Berkeley.edu.\n\n956\n\n|\n\nChapter 24: Class Metaprogramming\n\na method object on the fly by binding the instance to the self argument. This is elegant.21\n\nFinally, we have the idea of classes as first-class objects. It’s an outstanding feat of design that a beginner-friendly language provides powerful abstractions such as class builders, class decorators, and full-fledged, user-defined metaclasses. Best of all, the advanced features are integrated in a way that does not complicate Python’s suitabil‐ ity for casual programming (they actually help it, under the covers). The convenience and success of frameworks such as Django and SQLAlchemy owe much to meta‐ classes. Over the years, class metaprogramming in Python is becoming simpler and simpler, at least for common use cases. The best language features are those that ben‐ efit everyone, even if some Python users are not aware of them. But they can always learn and create the next great library.\n\nI look forward to learning about your contributions to the Python community and ecosystem!\n\n21 Machine Beauty: Elegance and the Heart of Technology by David Gelernter (Basic Books) opens with an intri‐ guing discussion of elegance and aesthetics in works of engineering, from bridges to software. The later chap‐ ters are not great, but the opening is worth the price.\n\nFurther Reading\n\n|\n\n957\n\nAfterword\n\nPython is a language for consenting adults.\n\n—Alan Runyan, cofounder of Plone\n\nAlan’s pithy definition expresses one of the best qualities of Python: it gets out of the way and lets you do what you must. This also means it doesn’t give you tools to restrict what others can do with your code and the objects it builds.\n\nAt age 30, Python is still growing in popularity. But of course, it is not perfect. Among the top irritants to me is the inconsistent use of CamelCase, snake_case, and joinedwords in the standard library. But the language definition and the standard library are only part of an ecosystem. The community of users and contributors is the best part of the Python ecosystem.\n\nHere is one example of the community at its best: while writing about asyncio in the first edition, I was frustrated because the API has many functions, dozens of which are coroutines, and you had to call the coroutines with yield from—now with await —but you can’t do that with regular functions. This was documented in the asyncio pages, but sometimes you had to read a few paragraphs to find out whether a particu‐ lar function was a coroutine. So I sent a message to python-tulip titled “Proposal: make coroutines stand out in the asyncio docs”. Victor Stinner, an asyncio core devel‐ oper; Andrew Svetlov, main author of aiohttp; Ben Darnell, lead developer of Tor‐ nado; and Glyph Lefkowitz, inventor of Twisted, joined the conversation. Darnell suggested a solution, Alexander Shorin explained how to implement it in Sphinx, and Stinner added the necessary configuration and markup. Less than 12 hours after I raised the issue, the entire asyncio documentation set online was updated with the coroutine tags you can see today.\n\nThat story did not happen in an exclusive club. Anybody can join the python-tulip list, and I had posted only a few times when I wrote the proposal. The story illustrates a community that is really open to new ideas and new members. Guido van Rossum used to hang out in python-tulip and often answered basic questions.\n\n959\n\nAnother example of openness: the Python Software Foundation (PSF) has been working to increase diversity in the Python community. Some encouraging results are already in. The 2013–2014 PSF board saw the first women elected directors: Jes‐ sica McKellar and Lynn Root. In 2015, Diana Clarke chaired PyCon North America in Montréal, where about one-third of the speakers were women. PyLadies became a truly global movement, and I am proud that we have so many PyLadies chapters in Brazil.\n\nIf you are a Pythonista but you have not engaged with the community, I encourage you to do so. Seek the PyLadies or Python Users Group (PUG) in your area. If there isn’t one, create it. Python is everywhere, so you will not be alone. Travel to events if you can. Join live events too. During the Covid-19 pandemic I learned a lot in the “hallway tracks” of online conferences. Come to a PythonBrasil conference—we’ve had international speakers regularly for many years now. Hanging out with fellow Pythonistas brings real benefits besides all the knowledge sharing. Like real jobs and real friendships.\n\nI know I could not have written this book without the help of many friends I made over the years in the Python community.\n\nMy father, Jairo Ramalho, used to say “Só erra quem trabalha,” Portuguese for “Only those who work make mistakes,” great advice to avoid being paralyzed by the fear of making errors. I certainly made my share of mistakes while writing this book. The reviewers, editors, and early release readers caught many of them. Within hours of the first edition early release, a reader was reporting typos in the errata page for the book. Other readers contributed more reports, and friends contacted me directly to offer suggestions and corrections. The O’Reilly copyeditors will catch other errors during the production process, which will start as soon as I manage to stop writing. I take responsibility and apologize for any errors and suboptimal prose that remains.\n\nI am very happy to bring this second edition to conclusion, mistakes and all, and I am very grateful to everybody who helped along the way.\n\nI hope to see you soon at some live event. Please come say hi if you see me around!\n\nFurther Reading I will wrap up the book with references regarding what it its to be “Pythonic”—the main question this book tried to address.\n\nBrandon Rhodes is an awesome Python teacher, and his talk “A Python Æsthetic: Beauty and Why I Python” is beautiful, starting with the use of Unicode U+00C6 (LATIN CAPITAL LETTER AE) in the title. Another awesome teacher, Raymond Het‐ tinger, spoke of beauty in Python at PyCon US 2013: “Transforming Code into Beau‐ tiful, Idiomatic Python”.\n\n960\n\n| Afterword\n\nThe “Evolution of Style Guides” thread that Ian Lee started on Python-ideas is worth reading. Lee is the maintainer of the pep8 package that checks Python source code for PEP 8 compliance. To check the code in this book, I used flake8, which wraps pep8, pyflakes, and Ned Batchelder’s McCabe complexity plug-in.\n\nBesides PEP 8, other influential style guides are the Google Python Style Guide and the Pocoo Styleguide, from the team that brought us Flake, Sphinx, Jinja 2, and other great Python libraries.\n\nThe Hitchhiker’s Guide to Python! is a collective work about writing Pythonic code. Its most prolific contributor is Kenneth Reitz, a community hero thanks to his beau‐ tifully Pythonic requests package. David Goodger presented a tutorial at PyCon US 2008 titled “Code Like a Pythonista: Idiomatic Python”. If printed, the tutorial notes are 30 pages long. Goodger created both reStructuredText and docutils—the foun‐ dations of Sphinx, Python’s excellent documentation system (which, by the way, is also the official documentation system for MongoDB and many other projects).\n\nMartijn Faassen tackles the question head-on in “What is Pythonic?” In the python- list, there is a thread with that same title. Martijn’s post is from 2005, and the thread from 2003, but the Pythonic ideal hasn’t changed much—neither has the language, for that matter. A great thread with “Pythonic” in the title is “Pythonic way to sum n- th list element?”, from which I quoted extensively in the “Soapbox” on page 427.\n\nPEP 3099 — Things that will Not Change in Python 3000 explains why many things are the way they are, even after the major overhaul that was Python 3. For a long time, Python 3 was nicknamed Python 3000, but it arrived a few centuries sooner—to the dismay of some. PEP 3099 was written by Georg Brandl, compiling many opin‐ ions expressed by the BDFL, Guido van Rossum. The “Python Essays” page lists sev‐ eral texts by Guido himself.\n\nAfterword\n\n|\n\n961",
      "page_number": 952
    },
    {
      "number": 48,
      "title": "Segment 48 (pages 974-993)",
      "start_page": 974,
      "end_page": 993,
      "detection_method": "synthetic",
      "content": "Symbols != (not equal to) operator, 577 !r conversion field, 12 % (modulo) operator, 5, 12 %r placeholder, 12 * (star) operator, 10, 36-37, 50-56, 240, 572-574 ** (double star) operator, 80, 240 *= (star equals) operator, 53-56, 580-585 *_ symbol, 42 *_new*_, 843-845 + operator, 10, 50-56, 566-572 += (addition assignment) operator, 53-56,\n\n580-585\n\n+ELLIPSIS directive, 7 := (Walrus operator), 26 < (less than) operator, 577 <= (less than or equal to) operator, 577 == (equality) operator, 206, 225, 577 > (greater than) operator, 577 >= (greater than or equal to) operator, 577 @ sign, 574-576 @asyncio.coroutine decorator, 777 @cached_property, 856 @contextmanager decorator, 664-669 @dataclass\n\ndefault settings, 180 example using, 187-189 field options, 180-183 init-only variables, 186 keyword parameters accepted by, 179 post-init processing, 183-185 typed class attributes, 185 __hash__ method, 180\n\n@typing.overload decorator, 520-526\n\nIndex\n\n[] (square brackets), 6, 26, 35, 49 \\ (backslash), 26 \\ line continuation escape, 26 \\N{} (Unicode literals escape notation), 136 _ symbol, 41 __ (double underscore), 3 __abs__, 11 __add__, 11 __bool__, 13 __bytes__, 365 __call__, 360 __class__, 870, 908 __contains__, 7, 93 __delattr__, 872 __delete__, 879 __del__, 219 __dict__, 870 __dir__, 872 __enter__, 658 __eq__, 411-416 __exit__, 658 __format__, 365, 370, 418-425, 428 __getattribute__, 872 __getattr__, 407-411, 872 __getitem__, 5-8, 49, 403-407 __get__, 879 __hash__, 180, 411-416 __iadd__, 53 __init_subclass__, 914-921 __init__, 9, 183, 399 __invert__, 563 __iter__, 603-610 __len__, 5-8, 17, 403-407 __missing__, 91-95\n\n963\n\n__mro__, 908 __mul__, 11 __name__, 908 __neg__, 563 __post_init__, 183 __pos__, 563 __prepare__, 950-952 __repr__, 11-13, 364, 399 __setattr__, 872 __setitem__, 49 __set__, 879 __slots__, 384-388, 411, 870, 921 __str__, 13, 364 {} (curly brackets), 26 ǀ (pipe) operator, 80, 686 ǀ= (pipe equals) operator, 80 … (ellipsis), 7, 49\n\nA abc.ABC class, 449 abc.Iterable, 281 abc.Sequence, 281 ABCs (abstract base classes) ABC syntax details, 457 defining and using ABCs, 451-457 further reading on, 482 goose typing and, 442-445 overview of, 481 in Python standard library, 449-451 Soapbox discussion, 484-486 structural typing with, 464-466 subclassing ABCs, 447-449, 458-460 type hints (type annotations), 278-280 UML class diagrams, 14-15 usage of register, 463 virtual subclasses of ABCs, 460-463\n\nabs built-in function, 10 actual type parameters, 544 addition assignment (+=) operator, 53-56,\n\n580-585 aliasing, 204-208 anonymous functions, 236, 251, 311 Any type, 266-269 AnyStr, 286 .append method, 67 apply function, 234-236 arguments\n\nfreezing with functools.partial, 247 key argument, 74\n\n964\n\n|\n\nIndex\n\nkeyword-only arguments, 242\n\narrays, 23, 59-62 as keyword, 41 assignment expression (:=), 26 asynchronous generators, 238, 777 asynchronous programming\n\nasynchronous context managers, 786-787 asyncio script example, 778-781 avoiding CPU-bound traps, 826 awaitables, 781 benefits of, 825 Curio project, 821-824 delegating tasks to executors, 797-798 enhancing asyncio downloader, 787-797 further reading on, 828 iteration and iterables, 811-821 myth of I/O-bound systems, 826 overview of, 827 relevant terminology, 777 significant changes to, 776 Soapbox discussion, 829 topics covered, 775 type hinting asynchronous objects, 824 writing asyncio servers, 799-811 Asynchronous Server Gateway Interface\n\n(ASGI), 732 asyncio package\n\nachieving peak performance with, 785 documentation, 776 downloading with, 782-786 enhancing asyncio downloader, 787-797 example script, 778-781 queue implementation by, 69 writing asyncio servers, 799-811\n\nasyncpg, 786 attribute descriptors (see also attributes; dynamic attributes and properties) attribute validation, 880-891 descriptor docstring and overriding dele‐\n\ntion, 902\n\ndescriptor usage tips, 900-902 further reading on, 904 methods as descriptors, 898-900 overriding versus nonoverriding, 855,\n\n892-898 overview of, 903 purpose of, 879 relevant terminology, 881 significant changes to, 880\n\nSoapbox discussion, 905 topics covered, 879\n\nattributes (see also attribute descriptors; dynamic attributes and properties) dynamic attribute access, 407-411 handling attribute deletion, 868 overriding class attributes, 389-391 private and protected, 382-384 properties and up-front costs, 394 safety versus security in private, 395 using attribute descriptors for validation,\n\n880-891\n\nusing properties for attribute validation,\n\n857-860\n\nvirtual attributes, 835\n\naugmented assignment operators, 53-56,\n\n580-585\n\naverages, computing, 643-645 await keyword, 781\n\nB backslash (\\), 26 behavioral subtyping, 268 binary records, parsing with struct, 118 binary sequences, 120 (see also Unicode text\n\nversus bytes) bisect module, 58 blue tool, 259 BOMs (byte-order marks), 129 bool type, 13 Boolean values, custom types and, 13 built-in functions, 238 byte sequences, 128 (see also Unicode text ver‐\n\nsus bytes)\n\nbytecode, disassembling, 310\n\nC call by sharing, 213 callable objects\n\nnine types of, 237-239 user-defined, 239 using iter() with, 598-599\n\nCallable type, 291 card deck example, 5-8 Cartesian products, 27-29 case folding, 142 chain generator, 633 ChainMap, 95 characters\n\nfinding Unicode by name, 151-153 numeric meaning of, 153-155\n\nChardet library, 129 cladistics, 444 class metaprogramming\n\nbenefits and drawbacks of, 907 built-in class factory, 909 class factory function, 911-914 classes as objects, 908 enhancing classes with class decorators,\n\n922-925\n\nfurther reading on, 954 import time versus runtime, 925-931 __init_subclass__, 914-921 metaclass basics, 931-942 metaclass issues, 947-949 metaclass solution for checkedlib.py,\n\n942-947 overview of, 953 __prepare__ method, 950-952 significant changes to, 908 Soapbox discussion, 956 useful applications of metaclasses, 952\n\nclasses (see also protocols) as callable objects, 238 implementing generic classes, 541-544 topics covered, xxi undocumented classes, 557 classic refactoring strategy, 342-346 classmethod decorator, 369 client codes, 632 clock decorators\n\nclass-based, 335 parameterized, 332-334\n\nclosures (see decorators and closures) cls.mro(), 909 cls.__bases__, 908 cls.__qualname__, 909 cls.__subclasses__(), 909 code examples, obtaining and using, xxiv code points, 119, 161 code smells, 163, 190-192, 446 codecs, 123 Collection API, 14-15 collections.abc module\n\nabstract base classes defined in, 449 ChainMap, 95 Counter, 96 defaultdict and OrderedDict, 85, 95\n\nIndex\n\n|\n\n965\n\nMapping and MutableMapping ABCs, 83 multiple inheritance in, 502 UserDict, 97\n\ncollections.deque class, 67-70 collections.namedtuple, 5, 169-172 Command pattern, 355-357 comments and questions, xxv comparison operators, 206, 577-580 computed properties\n\ncaching properties with functools, 855-857 data-driven attribute creation, 846-848 properties that compute values, 845 property caching, 853-855 property overriding existing attributes, 852 property to retrieve linked records, 848-852\n\nconcatenation, 50-56 concurrency models\n\nbasics of concurrency, 696 benefits of concurrency, 695 further reading on, 734-739 Global Interpreter Lock impact, 713-715 Hello World example, 701-712 indefinite loops and sentinels, 721 multicore processors and, 725-733 overview of, 733 process pools, 716-725 Python programming concepts, 699-701 relevant terminology, 697-699 significant changes to, 696 Soapbox discussion, 739-741 structured concurrency, 823 topics covered, 696\n\nconcurrent executors\n\nconcurrent web downloads, 744-754 downloads with progress display and error\n\nhandling, 762-772 Executor.map, 758-761 further reading on, 772 launching processes with concur‐\n\nrent.futures, 754-758\n\noverview of, 772 purpose of, 743 significant changes to, 743 Soapbox discussion, 773\n\nconcurrent.futures\n\ndownloading with, 749-750 launching processes with, 754-758\n\nconsistent-with relationships, 268 Container interface, 15\n\n966\n\n|\n\nIndex\n\ncontainer sequences, 22, 73 contention, 699 context managers\n\n@contextmanager decorator, 664-669 asynchronous, 786-787 asynchronous generators as, 817 contextlib utilities, 663 creative uses for, 658 demonstrations of, 659-662 methods included in interface, 658 parenthesized in Python 3.10, 663 purpose of, 658\n\ncontravariance (see variance) control flow, xxi (see also asynchronous pro‐ gramming; concurrent executors; concur‐ rency models; iterators; generators; with, match, and else blocks)\n\ncooperative multiple inheritance, 497 copies\n\ndeep, 211-213 shallow, 208-211 coroutine objects, 642 coroutines\n\ncomputing running averages, 643-645 definition of term, 698 further reading on, 652 generator-based, 777 generic type hints for, 650 Global Interpreter Lock impact, 715 overview of, 652 returning values from, 646-650 significant changes to, 594 Soapbox discussion, 654 spinners (loading indicators) using, 706-710 topics covered, 594 types of, 777 understanding classic, 641\n\nCounter, 96 covariance (see variance) CPU-bound systems, 826 Curio project, 821-824 curly brackets ({}), 26\n\nD Dask, 727 data attributes (see attributes) data class builders\n\n@dataclass, 179-189 classic named tuples, 169-172\n\ndata class as code smell, 190-192 further reading on, 196 main features, 167-169 overview of, 164-167, 195 pattern matching class instances, 192-195 significant changes to, 164 Soapbox discussion, 197 topics covered, 163 type hints, 173-179 typed named tuples, 172\n\ndata descriptors (see overriding descriptors) data model (see Python Data Model) data science, 727 data structures, xxi (see also data class builders; dictionaries and sets; object references; sequences; Unicode text versus bytes)\n\ndata wrangling\n\nwith dynamic attributes, 836-838 flexible object creation, 843-845 invalid attribute name problem, 842 JSON-like data, 838-842 decimal.Decimal class, 565 decoding (see also Unicode text versus bytes)\n\nbasics of, 123-124 definition of, 119 understanding encode/decode problems,\n\n125-131\n\ndecorator-enhanced strategy pattern, 353-355 decorators and closures\n\nclassmethod versus staticmethod, 369 closure basics, 311-314 closures in lis.py, 685 decorator basics, 304-306 decorator execution, 306 decorator implementation, 317-320 decorators in Python standard library,\n\n320-323\n\nenhancing classes with class decorators,\n\n922-925\n\nfurther reading on, 336 nonlocal declarations, 315-317 overview of, 336 parameterized decorators, 329-335 purpose of, 303 registration decorators, 308 significant changes to, 304 Soapbox discussion, 338-340 topics covered, 303 variable scope rules, 308-310\n\ndeep copies, 211-213 defaultdict, 85, 90 defensive programming, 87, 440-442 del statement, 219-221, 868 delegating generators, 632 deprecated collection types, 272 deque (double-ended queue), 59, 67-70 descriptor classes, 881 descriptor instances, 881 descriptors, 177, 879 (see also attribute descrip‐\n\ntors)\n\ndesign patterns (see functions, design patterns\n\nwith first-class)\n\ndestructuring, 40 diacritics, normalization and, 144-148 dictcomps (dict comprehensions), 79 dictionaries and sets\n\nautomatic handling of missing keys, 90-95 consequences of how dict works, 102 consequences of how set works, 107 dictionary views, 101-102 further reading on, 113 immutable mappings, 99 internals of, 78 modern dict syntax, 78-81 overview of, 112 pattern matching with mappings, 81-83 set operations, 107-110 set operations on dict views, 110 set theory, 103-106 significant changes to, 78 Soapbox discussion, 114 standard API of mapping types, 83-90 topics covered, 77 variations of dict, 95-99 dir([object]) function, 870 dis module, 310 displays, formatting, 370-374 distributed task queues, 732 Django generic views mixins, 504-507 doctest package\n\ndocumentation, xxii ellipsis in, 7\n\ndouble star (**) operator, 80, 240 double underscore (__), 3 double() function, 466-468 Dublin Core Schema, 187 duck typing, 87, 261, 302, 402, 427, 431, 470 dunder methods, 4\n\nIndex\n\n|\n\n967\n\ndynamic attributes and properties\n\ncoding property factories, 865-868 computed properties, 845-857 data wrangling with dynamic attributes,\n\n836-845\n\ndynamic versus virtual attributes, 835 essential attributes and functions for attribute handling, 869-873\n\nfurther reading on, 873 handling attribute deletion, 868 overview of, 873 property class, 860-865 significant changes to, 836 Soapbox discussion, 875-877 using properties for attribute validation,\n\n857-860\n\ndynamic protocols, 403, 435 dynamic type, 266-269\n\nE ellipsis (…), 7, 49 else blocks, 687-689 emojis\n\nbuilding, 118 console font and, 136 finding characters by name, 151-153 in the Museum of Modern Art, 160 increasing issues with, 162 UCS-2 versus UTF-16 encoding, 124 varied support for, 152\n\nencoding (see also Unicode text versus bytes)\n\nbasics of, 123-124 definition of, 119 encoding defaults, 134-139 understanding encode/decode problems,\n\n125-131\n\nequality (==) operator, 206, 225, 577 error handling, in network I/O, 762-772 execution units, 697 Executor.map, 758-761 executors, delegating tasks to, 797-798 (see also\n\nconcurrent executors) explicit self argument, 905\n\nF f-string syntax\n\nbenefits of, 5 delegation of formatting by, 370\n\n968\n\n|\n\nIndex\n\nstring representation using special methods,\n\n12\n\nfail-fast philosophy, 87, 417, 440-442 FastAPI framework, 800-804 FIFO (first in, first out), 59, 67 filter function, 27, 234-236 filtering generator functions, 619 first-class functions (see functions, as first-class\n\nobjects)\n\nfirst-class objects, 231 flake8 tool, 259 flat sequences, 22, 73 flawed typing, 296 fluentpython.com, xxiii ForkingMixIn, 503 formal type parameters, 544 format() function, 370 forward reference problem, 538 free variables, 313, 685 frozenset, 103 (see also dictionaries and sets) function decorators (see decorators and clo‐\n\nsures)\n\nfunction parameters, introspection of, 232 function-class duality, 876 function-oriented refactoring strategy, 347-350 functional programming packages for, 243-249 with Python, 250\n\nfunctions\n\nabs built-in function, 10 dir([object]) function, 870 disassembling bytecode of, 310 double() function, 466 filter, map, and reduce functions, 27, 234 format() function, 370 getattr function, 871 getattr(object, name[, default]) function,\n\n871\n\nglobals() function, 351 hasattr function, 871 higher-order functions, 234-236 id() function, 206 iter() function, 596 len() function, 6 map function, 27 max() function, 521 repr() function, 364 setattr funcion, 871\n\nsetattr(object, name, value) function, 871,\n\n871\n\nsingle dispatch generic functions, 324-329 str() function, 13, 364 super() function, 411, 488 zip() function, 416\n\nfunctions, as first-class objects (see also decora‐\n\ntors and closures) anonymous functions, 236 callable objects, 237-239 definition of term, 231 flexible parameter handling and, 240-243 further reading on, 250 higher-order functions, 234-236 overview of, 249 packages for functional programming,\n\n243-249\n\nsignificant changes to, 232 Soapbox discussion, 250 topics covered, xxi treating functions like objects, 232-234 user-defined callable types, 239\n\nfunctions, design patterns with first-class\n\nCommand pattern, 355-357 decorator-enhanced strategy pattern,\n\n353-355\n\ndynamic languages and, 341 further reading on, 358 overview of, 357 refactoring strategies, 342-353 significant changes to, 342 Soapbox discussion, 359\n\nfunctions, type hints in\n\nannotating positional only and variadic\n\nparameters, 295\n\nbenefits and drawbacks of, 253 flawed typing and strong testing, 296 further reading on, 298 gradual typing, 254-260 overview of, 297 significant changes to, 254 Soapbox discussion, 299-302 supported operations and, 261-265 topics covered, 254 types usable in annotations, 266-295\n\nfunctools module\n\ncaching properties with, 855-857 freezing arguments with, 247-249 functools.cache decorator, 320-323\n\nfunctools.lru_cache function, 323 functools.singledispatch decorator, 326-329\n\nfutures\n\nbasics of, 751-754 definition of term, 743 futures.as_completed, 769-772\n\nG garbage collection, 219-221, 226 generator expressions (genexps), 26, 29, 235,\n\n613, 818-821\n\ngenerators\n\narithmetic progression generators, 615-619 asynchronous generator functions, 812-818 examples of, 607-610 further reading on, 652 generator functions in Python standard\n\nlibrary, 238, 619-630\n\ngenerator-based coroutines, 777 generic iterable types, 639 humble generators, 784 iterable reducing functions, 630-631 versus iterators, 614 lazy generators, 610-613 overview of, 652 Sentence classes with, 606 significant changes to, 594 Soapbox discussion, 654 subgenerators with yield from expression,\n\n632-639\n\ntopics covered, 594 when to use generator expressions, 613 yield keyword, 607\n\ngeneric classes, implementing, 541-544 generic collections\n\nparameterized generics and TypeVar,\n\n282-286\n\nSoapbox discussion, 302 type annotations and, 271-272\n\ngeneric functions, single dispatch, 324-329 generic mapping types, 276 generic static protocols, 552-554 getattr function, 871 getattr(object, name[, default]) function, 871 gevent library, 711 Global Interpreter Lock (GIL), 66, 699,\n\n713-715, 725, 736 globals() function, 351 goose typing\n\nIndex\n\n|\n\n969\n\nABC syntax details, 457 ABCs in Python standard library, 449-451 abstract base classes (ABCs), 442-445 defining and using ABCs, 451-457 definition of term, 431 overview of, 446 structural typing with ABCs, 464-466 subclassing ABCs, 447-449, 458-460 usage of register, 463 virtual subclasses of ABCs, 460-463\n\ngradual type system (see also type hints (type\n\nannotations)) abstract base classes, 278-280 Any type, 266-267 basics of, 254 Callable type, 291 further reading on, 555 generic collections, 271-272 generic mappings, 276 implementing generic classes, 541-544 implementing generic static protocols,\n\n552-554\n\nin practice, 255-260 Iterable, 280-282 legacy support and deprecated collection\n\ntypes, 272\n\nNoReturn type, 294 Optional and Union types, 270 overloaded signatures, 520-526 overview of, 554 parameterized generics and TypeVar,\n\n282-286\n\nreading hints at runtime, 537-541 significant changes to, 519 simple types and classes, 269 Soapbox discussion, 557 static protocols, 286-291 subtype-of versus consistent-with relation‐\n\nships, 267-269 topics covered, 519 tuple types, 274-276 type casting, 534-537 TypedDict, 526 variance and, 544-551 greater than (>) operator, 577 greater than or equal to (>=) operator, 577 greenlet package, 710\n\n970\n\n|\n\nIndex\n\nH hasattr function, 871 hash code, versus hash value, 84 hash tables, 77 hashable, definition of, 84 heapq package, 69 higher-order functions, 234-236 HTTPServer class, 503 HTTPX library, 782-786 humble generators, 784\n\nI I/O (input/output) (see network I/O) id() function, 206 immutable mappings, 99 immutable sequences, 24 implicit conversion, 117 import time versus runtime, 306, 925 indefinite loops, 721 infix operators, 561, 574-576 inheritance and subclassing best practices, 510-514 further reading on, 515 mixin classes, 500-502 multiple inheritance and method resolution\n\norder, 494-499\n\noverview of, 514 real-world examples of, 502-509 significant changes to, 488 Soapbox discussion, 517-518 subclassing ABCs, 447-449, 458-460 subclassing built-in types, 490-494 super() function, 488-490 topics covered, 487 virtual subclasses of ABCs, 460-463 input expanding generator functions, 625 interfaces (see also goose typing; protocols)\n\nContainer interface, 15 further reading on, 482 Iterable interface, 15, 280, 435 overview of, 481 protocols as informal, 427 role in object-oriented programming, 431 significant changes to, 433 Sized interface, 15 Soapbox discussion, 484-486 topics covered, 433 typing map, 432 ways of defining and using, 431\n\ninterning, 222 invalid attribute name problem, 842 inverted indexes, 799 is operator, 206, 221 .items method, 110 iter() function, 596-599 Iterable interface, 15, 280-282, 435-437 iterables\n\nasynchronous, 811-821 iterable reducing functions, 630-631 versus iterators, 599-603 unpacking, 35-38\n\niterators\n\nasynchronous, 811-821 further reading on, 652 versus generators, 614 generic iterable types, 639 iter() function, 596-599 versus iterables, 599-603 lazy sentences, 610-613 overview of, 652 role of, 593 Sentence classes with __iter__, 603-610 sequence protocol, 594-596 significant changes to, 594 Soapbox discussion, 654 topics covered, 594\n\nitertools module, 618\n\nJ JSON-like data, 838-842\n\nK key argument, 74 keys\n\nautomatic handling of missing, 90-95 converting nonstring keys to str, 98 hashability, 84 persistent storage for mapping, 97 practical consequences of using dict, 102 preserving key insertion order, 15, 948 sorting multiple, 244\n\n.keys method, 110 keyword class patterns, 193 keyword-only arguments, 242 keywords\n\nas keyword, 41 await keyword, 781 lambda keyword, 236\n\nnonlocal keyword, 315-317, 683 reserved keywords, 679 yield keyword, 238, 605-610, 614, 642, 645,\n\n669\n\nKISS principle, 427, 517, 739\n\nL lambda keyword, 236 lazy sentences, 610-613 Least Recently Used (LRU), 323 len() function, 6 less than (<) operator, 577 less than or equal to (<=) operator, 577 line breaks, 26 lis.py interpreter\n\nEnvironment class, 673 evaluate function, 676-685 imports and types, 671 OR-patterns, 686 parser, 671-673 pattern matching in, 43-47 Procedure class, 685-686 REPL (read-eval-print-loop), 675 Scheme syntax, 669-671 topics covered, 669\n\nlist comprehensions (listcomps) asynchronous, 818-821 building lists from cartesian products, 27 building sequences with, 25 versus generator expressions, 29 local scope within, 26 readability and, 25 syntax tip, 26 versus map and filter functions, 27, 235\n\nlists\n\nalternatives to, 59-70 building lists of lists, 51 list.sort versus sorted built-in, 56-58 mixed-bag, 74 multiline, 26 shallow copies of, 208-211 versus tuples, 34 using tuples as immutable, 32-34\n\nlocks, definition of term, 699 LRU (see Least Recently Used)\n\nM magic methods, 4, 19 managed attributes, 882\n\nIndex\n\n|\n\n971\n\nmanaged classes, 881 managed instances, 882 map function, 27, 234-236 mappings\n\nautomatic handling of missing keys, 90-95 case-insensitive, 500-502 immutable mappings, 99 mapping generator functions, 620 merging, 80 pattern matching with, 81-83 standard API of mapping types, 83-90 unpacking, 80\n\nmatch blocks (see with, match, and else blocks) match/case statement, 38, 81 mathematical vector operations, 566 max() function, 521-526 memoization, 320-323 memory, saving with __slots__, 384-388 memoryview class, 62-64 metaclasses\n\nbasics of, 931-933 considerations for use, 947-949 customizing classes, 933 definition of term, 910 example metaclass, 934-937 metaclass evaluation time experiment,\n\n937-942\n\nmetaclass solution for checkedlib.py,\n\n942-947\n\nuseful applications of, 952\n\nmetaobjects, 19 metaprogramming, xxii (see also attribute descriptors; class metaprogramming; dynamic attributes and properties) method resolution order (MRO), 494-499 methods, as callable objects, 238 (see also sequences, special methods for; special methods)\n\nMeyer's Uniform Access Principle, 875-876 Mills & Gizmos Notation (MGN), 883 mixin classes, 500-502 mixin methods, 502 modulo (%) operator, 5, 12 monkey-patching, 438-440, 486, 897 MRO (see method resolution order) multicore processing data science, 727 distributed task queues, 732 increased availability of, 725\n\n972\n\n|\n\nIndex\n\nserver-side web/mobile development, 728 system administration, 726 WSGI application servers, 730\n\nmultiline lists, 26 multiple inheritance (see also inheritance and\n\nsubclassing) method resolution order and, 494-499 real-world examples of, 502-509\n\nmultiplication, scalar, 10, 572-574 multiprocessing package, 69, 704 mutable objects, 225 (see also object references) mutable parameters, 214-218 mutable sequences, 24 mutable values, inserting or updating, 87-90 MutableMapping ABC, 83 Mypy type checker, 255-260 my_fmt.format() method, 5\n\nN name mangling, 382 namedtuple, 169-172 native coroutines\n\nversus asynchronous generators, 818 definition of term, 777 functions defined with async def, 238 humble generators and, 784\n\nnetwork I/O\n\ndownloading with asyncio, 782-786 downloading with concurrent.futures,\n\n749-750\n\ndownloads with progress display and error\n\nhandling, 762-772\n\nenhancing asyncio downloader, 787-797 essential role of concurrency in, 744-746 myth of I/O-bound systems, 826 role of futures, 751-754 sequential download script, 746-749\n\nNFC (see Normalization Form C) nominal typing, 262 nonlocal keyword, 315-317, 683 nonoverriding descriptors, 855, 892-898 NoReturn type, 294 Normalization Form C (NFC), 140 normalized text matching, 143-148 not equal to (!=) operator, 577 numbers ABCs, 478-481 numbers package, 279 numeric protocols, 478-481 numeric tower, 279\n\nnumeric types\n\nchecking for convertibility, 468, 480 emulating using special methods, 9-12 hashability of, 84 support for, 479\n\nNumPy, 64-67\n\nO object references\n\naliasing, 204-208 deep copies, 211-213 del and garbage collection, 219-221 distinction between objects and their\n\nnames, 201\n\nfunction parameters as references, 213-218 further reading on, 224 immutability and, 221 overview of, 223 shallow copies, 208-211 Soapbox discussion, 225 variables as labels versus boxes, 202-204\n\nobjects\n\ncallable objects, 237-239, 598-599 first-class, 231 flexible object creation, 843-845 mutable, 225 treating functions like, 232-234 user-defined callable objects, 239\n\noperator module, 243-247 operator overloading\n\naugmented assignment operators, 580-585 basics of, 562 further reading on, 587 infix operator method names, 576 infix operators, 561 overloading * for scalar multiplication,\n\n572-574\n\noverloading + for vector addition, 566-572 overview of, 585 rich comparison operators, 577-580 significant changes to, 562 Soapbox discussion, 588 topics covered, 562 unary operators, 563-566 using @ as infix operator, 574-576\n\nOptional type, 270 OR-patterns, 686 OrderedDict, 85, 95 os functions, str versus bytes in, 156\n\noverloaded signatures, 520-526 overriding descriptors, 855, 863, 892-898\n\nP parallelism, 695, 697 parameterized decorators, 329-335 parameterized types, 544 parameters\n\nannotating positional only and variadic\n\nparameters, 295\n\nintrospection of function parameters, 232 keyword-only, 242 mutable, 214-218 parameter passing, 213 positional, 240-243\n\npattern matching *_ symbol, 42 destructuring, 40 in lis.py interpreter, 43-47, 669-687 with mappings, 81-83 match/case statement, 38 pattern matching class instances, 192-195 tuples and lists, 41 type information, 42 _ symbol, 41\n\npatterns (see functions, design patterns with\n\nfirst-class; pattern matching)\n\npickle module, 97 Pingo library, 99 pipe (ǀ) operator, 80, 686 pipe equals (ǀ=) operator, 80 plain text, 129, 161 .pop method, 67 positional class patterns, 194 positional parameters, 240-243 positional patterns, 377 process pools\n\ncode for multicore prime checker, 719-723 example problem, 716 process-based solution, 718 thread-based nonsolution, 724 understanding elapsed times, 718 varying process numbers, 723\n\nprocesses\n\ndefinition of term, 698 launching with concurrent.futures, 754-758\n\nprogress displays, 762-772 Project Jupyter, 727 proper tail calls (PTC), 691-693\n\nIndex\n\n|\n\n973\n\nproperties (see computed properties; dynamic\n\nattributes and properties)\n\nproperty class, 860-865 protocol classes, 403 Protocol type, 286-291 protocols (see also interfaces)\n\ndefensive programming, 440-442 duck typing and, 402 further reading on, 482 implementing at runtime, 438-440 implementing generic static protocols,\n\n552-554\n\nas informal interfaces, 427 meanings of protocol, 434 numeric, 478-481 overview of, 481 sequence and iterable protocols, 435-437 significant changes to, 433 Soapbox discussion, 484-486 static protocols, 403, 466-481 topics covered, 433\n\nPSF (see Python Software Foundation) PUG (see Python Users Group) PyICU, 150 PyLadies, 960 pytest package, xxii Python\n\nappreciating language-specific features, xix approach to learning, xx-xxii community support for, 959 fluentpython.com, xxiii functional programming with, 250 functioning with multicore processors,\n\n725-733\n\nfurther reading on, 960 prerequisites to learning, xx target audience, xx versions featured, xx\n\nPython Data Model\n\nfurther reading on, 18 __getitem__ and __len__, 5-8 making len work with custom objects, 17 overview of, 3, 18 significant changes to, 4 Soapbox discussion, 19 special methods overview, 15-17 using special methods, 8-15\n\nPython Software Foundation (PSF), 960 Python type checkers, 255\n\n974\n\n|\n\nIndex\n\nPython Users Group (PUG), 960 python-tulip list, 959 Pythonic Card Deck example, 5-8 Pythonic objects (see also objects) alternative constructor for, 368 building user-defined classes, 363 classmethod versus staticmethod, 369 formatted displays, 370-374 further reading on, 392 hashable Vector2d, 374-377 object representations, 364 overriding class attributes, 389-391 overview of, 391 private and protected attributes, 382-384 saving memory with __slots__, 384-388 significant changes to, 364 Soapbox discussion, 394-396 supporting positional patterns, 377 topics covered, 363 Vector2d class example, 365-368 Vector2d full listing, 378-381\n\nPythonic sums, 428-430 pyuca library, 150, 158\n\nQ quantity properties, 865-868 questions and comments, xxv queues\n\ndefinition of term, 698 deque (double-ended queue), 59, 67 distributed task queues, 732 implementing, 69\n\nR race conditions, 723 random.choice function, 6 recycling (see garbage collection) reduce function, 234-236 reducing functions, 412, 630-631 refactoring strategies\n\nchoosing the best, 350 classic, 342-346 Command pattern, 355-357 decorator-enhanced pattern, 353-355 finding strategies in modules, 351-353 function-oriented, 347-350\n\nreference counting, 219 registration decorators, 308, 329-332 regular expressions, str versus bytes in, 155\n\nrepr() function, 364 reserved keywords, 679 rich comparison operators, 577-580 running averages, computing, 643-645\n\nS S-expression, 669 salts, 85 Scheme language, 43-47, 669-671 SciPy, 64-67 scope\n\ndynamic scope versus lexical scope, 338-339 function local scope, 310 module global scope, 310 variable scope rules, 308-310 within comprehensions and generator\n\nexpressions, 26 semaphores, 790-794 Sentence classes, 603-610 sentinels, 721 sequence protocol, 435-437, 594-596 sequences\n\nalternatives to lists, 59-70 further reading on, 71 list comprehensions and generator expres‐\n\nsions, 25-30\n\nlist.sort versus sorted built-in, 56-58 overview of, 70 overview of built-in, 22-24 pattern matching with, 38-47 significant changes to, 22 slicing, 47-50 Soapbox discussion, 73-75 topics covered, 22 tuples, 30-35 uniform handling of, 21 unpacking sequences and iterables, 35-38 using + and * with, 50-56 sequences, special methods for\n\napplications beyond three dimensions, 398 dynamic attribute access, 407-411 __format__, 418-425 further reading on, 426 __hash__ and __eq__, 411-416 overview of, 425 protocols and duck typing, 402 significant changes to, 398 sliceable sequences, 403-407 Soapbox discussion, 427-430\n\ntopics covered, 397 Vector implementation strategy, 398 Vector2d compatibility, 399-401\n\nsequential.py program, 716 server-side web/mobile development, 728 servers\n\nAsynchronous Server Gateway Interface\n\n(ASGI), 732\n\nHTTPServer class, 503 TCP servers, 804-811 test servers, 765 ThreadingHTTPServer class, 503 Web Server Gateway Interface (WSGI), 730 writing asyncio servers, 799-811\n\nsetattr function, 871 sets (see also dictionaries and sets)\n\nconsequences of how set works, 107 set comprehensions, 106 set literals, 105 set operations, 107-110 set operations on dict views, 110 set theory, 103-105 shallow copies, 208-211 shelve module, 97 simple class patterns, 192 single dispatch generic functions, 324-329 Sized interface, 15 slicing\n\nassigning to slices, 50 excluding last item in, 47 multidimensional slicing and ellipses, 49 slice objects, 48 sliceable sequences, 403-407\n\nSoapbox sidebars\n\n@dataclass, 197 anonymous functions, 251 __call__, 360 code points, 161 data model versus object model, 19 design patterns, 359 duck typing, 302, 427 dynamic scope versus lexical scope, 338-339 equality (==) operator, 225 explicit self argument, 905 flat versus container sequences, 73 __format__, 428 function-class duality, 876 functional programming with Python, 250 generic collections, 302\n\nIndex\n\n|\n\n975\n\ninheritance across languages, 518 interfaces, 486 key argument, 74 lis.py and evaluate function, 693 magic methods, 19 metaobjects, 19 minimalistic iterator interface, 654 mixed-bag lists, 74 monkey-patching, 486 multilevel class hierarchies, 517 mutability, 225 non-ASCII names in source code, 160 object destruction and garbage collection,\n\n226\n\noperator overloading, 588 Oracle, Google, and the Timbot, 74 plain text, 161 pluggable generators, 654-656 programming language design, 956 proper tail calls (PTC), 691-693 properties and up-front costs, 394 protocols as informal interfaces, 427 Python decorators and decorator design\n\npattern, 339\n\nPythonic sums, 428-430 safety versus security in private attributes,\n\n395\n\nstatic typing, 484 syntactic sugar, 114 thread avoidance, 773 threads-and-locks versus actor-style pro‐\n\ngramming, 739-741 trade-offs of built-ins, 517 tuples, 73 Twisted library, 830 type hints (type annotations), 299-302 typing map, 485 undocumented classes, 557 Uniform Access Principle, 875-876 uvloop, 829 variance notation in other classes, 558 with statements, 691\n\nsorted function, 56-58 special methods (see also sequences, special\n\nmethods for) advantages of using, 6 Boolean values of custom types, 13 calling, 8 Collection API, 14-15\n\n976\n\n|\n\nIndex\n\nemulating numeric types, 9-12 __getitem__ and __len__, 5-8 naming conventions, 3 purpose of, 3 special method names (operators excluded),\n\n15\n\nspecial method names and symbols for\n\noperators, 16\n\nstring representation, 12\n\nspinners (loading indicators) (see also network\n\nI/O) comparing supervisor functions, 711 created using coroutines, 706-710 created with multiprocessing package, 704 created with threading, 701-704 Global Interpreter Lock impact, 713-715 keeping alive, 715\n\nsquare brackets ([]), 6, 26, 35, 49 stacked decorators, 322 star (*) operator, 10, 36-37, 50-56, 240, 572-574 star equals (*=) operator, 580-585 static duck typing, 291, 432, 515 static protocols\n\nbest practices for protocol design, 476 definition of, 435 designing, 474-476 versus dynamic protocols, 403 extending, 477 implementing generic static protocols,\n\n552-554\n\nlimitations of runtime protocol checks, 471 numbers ABCS and numeric protocols,\n\n478-481\n\nruntime checkable, 468-471 Soapbox discussion, 484 supporting, 472-474 type hints (type annotations), 286-291 typed double function, 466-468\n\nstatic typing, 431 staticmethod decorator, 369 storage attributes, 882 str() function, 13, 364 str.format() method, 5, 370 Strategy pattern, 342-346 strings\n\ndefault sorting of, 58 dual-mode str and bytes APIs, 155-157 normalizing Unicode for reliable compari‐\n\nsons, 140-148\n\nrepresentation using special methods, 12\n\nstrong testing, 296 struct module, 118 structural typing, 464-466 structured concurrency, 823 subclassing (see inheritance and subclassing) subgenerators, 632 subtype-of relationships, 267 super() function, 411, 488-490 syntactic sugar, 114 SyntaxError, 128 system administration, 726\n\nT tail call optimization (TCO), 691-693 TCP servers, 804-811 TensorFlow, 727 test servers, 765 text files, handling, 131-139 (see also Unicode\n\ntext versus bytes)\n\nThreadingHTTPServer class, 503 ThreadingMixIn class, 503 threads\n\ndefinition of term, 698 enhancing asyncio downloader, 788-797 further reading on, 734 Global Interpreter Lock impact, 714 spinners (loading indicators) using, 701-704 thread avoidance, 773 thread-based process pools, 724\n\nthrottling, 790-794 Timsort algorithm, 74 Tkinter GUI toolkit\n\nbenefits and drawbacks of, 513 multiple inheritance in, 507-509 tree structures, traversing, 634-639 tuples\n\nclassic named tuples, 169-172 immutability and, 221 as immutable lists, 32-34 versus lists, 34 nature of, 73 as records, 30-32 relative immutability of, 207 simplified memory diagram for, 23 tuple unpacking, 32 type hints (type annotations), 274-276 typing.NamedTuple, 172\n\nTwisted library, 830\n\ntype casting, 534-537 type hints (type annotations)\n\nannotating positional only and variadic\n\nparameters, 295\n\nfor asynchronous objects, 824 basics of, 173-179 benefits and drawbacks of, 253 flawed typing and strong testing, 296 further reading on, 298 generic type hints for coroutines, 650 gradual typing, 254-260 (see also gradual\n\ntype system) overview of, 297 significant changes to, 254 Soapbox discussion, 299-302 supported operations and, 261-265 topics covered, 254 types usable in, 266-295 typed double function, 466-468 TypedDict, 164, 526-534 Typeshed project, 280 TypeVar, 282-286 typing map, 432, 485 (see also type hints (type\n\nannotations)) typing module, 266 typing.NamedTuple, 172\n\nU UCA (see Unicode Collation Algorithm) UCS-2 encoding, 124 UML class diagrams\n\nABCs in collections.abc, 449 annotated with MGN, 882, 943 Command design pattern, 355 django.views.generic.base module, 504 django.views.generic.list module, 506 fundamental collection types, 14 managed and descriptor classes, 880 MutableSequence ABC and superclasses,\n\n448\n\nSequence ABC and abstract classes, 436 simplified for collections.abc, 24 simplified for MutableMapping and super‐\n\nclasses, 83\n\nsimplified for MutableSet and superclasses,\n\n107\n\nStrategy design pattern, 342 Tkinter Text widget class and superclasses,\n\n498\n\nIndex\n\n|\n\n977\n\nTomboList, 461\n\nunary operators, 563-566 undocumented classes, 557 Unicode Collation Algorithm (UCA), 150 Unicode literals escape notation (\\N{}), 136 Unicode sandwich, 131 Unicode text versus bytes\n\nbasic encoders/decoders, 123-124 byte essentials, 120-123 characters and Unicode standard, 118-120 dual-mode str and bytes APIs, 155-157 further reading on, 158 handling text files, 131-139 normalizing Unicode for reliable compari‐\n\nsons, 140-148 overview of, 157 significant changes to, 118 Soapbox discussion, 160 sorting Unicode text, 148-150 topics covered, 117 understanding encode/decode problems,\n\n125-131\n\nUnicode database, 150-155\n\nUnicodeDecodeError, 126 UnicodeEncodeError, 125 Uniform Access Principle, 875-876 Union type, 270 unittest module, xxii unpacking\n\niterables and mappings, 240 mapping unpackings, 80 nested, 37 sequences and iterables, 35 using * to grab excess items, 36 with * in function calls and sequence liter‐\n\nals, 37\n\nuser-defined functions, 238 UserDict, 97-99 UTF-8 decoding, 129 UTF-8-SIG encoding, 130 uvloop, 829\n\nV variable annotations\n\nmeaning of, 175-179 syntax of, 174\n\nvariable scope rules, 308-310 variables\n\nfree, 313\n\n978\n\n|\n\nIndex\n\ninit-only variables, 186 as labels versus boxes, 202-204 lookup logic, 316 variadic parameters, 295 variance\n\ncontravariant types, 547 covariant types, 546 in callable types, 292 invariant types, 545 overview of, 549 relevance of, 544 rules of thumb, 551 variance notation in other classes, 558\n\nvars([object]) function, 871 Vector class, multidimensional\n\napplications beyond three dimensions, 398 dynamic attribute access, 407-411 __format__, 418-425 further reading on, 426 __hash__ and __eq__, 411-416 implementation strategy, 398 overview of, 425 protocols and duck typing, 402 sliceable sequences, 403-407 topics covered, 397 Vector2d compatibility, 399-401\n\nVector2d\n\nclass example, 365-368 full listing, 378-381 hashable, 374\n\nvectors\n\noverloading + for vector addition, 566-572 representing two-dimensional, 9-12\n\nvirtual attributes, 835 virtual subclasses, 460-463\n\nW Walrus operator (:=), 26 weak references, 221 Web Server Gateway Interface (WSGI), 730 web/mobile development, 728 with, match, and else blocks\n\ncontext managers and with blocks, 658-669 else clause, 687-689 further reading on, 690 overview of, 689 pattern matching in lis.py, 669-687 purpose of with statements, 658 significant changes to, 658\n\nSoapbox discussion, 691-693 topics covered, 657\n\nY yield from expression, 632-639\n\nyield keyword, 238, 605-610, 614, 642, 645, 669\n\nZ zero-based indexing, 47 zip() function, 416\n\nIndex\n\n|\n\n979\n\nAbout the Author\n\nLuciano Ramalho was a web developer before the Netscape IPO in 1995, and switched from Perl to Java to Python in 1998. He joined Thoughtworks in 2015, where he is a Principal Consultant in the São Paulo office. He has delivered keynotes, talks, and tutorials at Python events in the Americas, Europe, and Asia, and also pre‐ sented at Go and Elixir conferences, focusing on language design topics. Ramalho is a fellow of the Python Software Foundation and cofounder of Garoa Hacker Clube, the first hackerspace in Brazil.\n\nColophon\n\nThe animal on the cover of Fluent Python is a Namaqua sand lizard (Pedioplanis namaquensis), found throughout Namibia in arid savannah and semi-desert regions.\n\nThe Namaqua sand lizard has a black body with four white stripes running down its back, brown legs with white spots, a white belly, and a long, pinkish-brown tail. It is one of the fastest of the lizards active during the day and feeds on small insects. It inhabits sparsely vegetated sand gravel flats. Female Namaqua sand lizards lay between three to five eggs in November, and these lizards spends the rest of winter dormant in burrows that they dig near the base of bushes.\n\nThe current conservation status of the Namaqua sand lizard is of “Least Concern.” Many of the animals on O’Reilly covers are endangered; all of them are important to the world.\n\nThe cover illustration is by Karen Montgomery, based on a black and white engrav‐ ing from Wood’s Natural History. The cover fonts are Gilroy Semibold and Guardian Sans. The text font is Adobe Minion Pro; the heading font is Adobe Myriad Con‐ densed; and the code font is Dalton Maag’s Ubuntu Mono.\n\nLearn from experts. Become one yourself.\n\nBooks | Live online courses Instant Answers | Virtual events Videos | Interactive learning\n\nGet started at oreilly.com.\n\n5 7 1\n\nc n\n\na d e M y\n\ni\n\nl l i\n\ne R O\n\n’\n\nf o k r a m e d a r t d e r e t s g e r\n\ni\n\na\n\nl l i\n\ne R O\n\n’\n\n.\n\nc n\n\na d e M y\n\ni\n\nl l i\n\ne R O 2 2 0 2 ©\n\n’",
      "page_number": 974
    },
    {
      "number": 49,
      "title": "Segment 49 (pages 994-1010)",
      "start_page": 994,
      "end_page": 1010,
      "detection_method": "synthetic",
      "content": "",
      "page_number": 994
    },
    {
      "number": 50,
      "title": "Segment 50 (pages 1011-1011)",
      "start_page": 1011,
      "end_page": 1011,
      "detection_method": "synthetic",
      "content": "",
      "page_number": 1011
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "content": "Fluent Python\n\n2nd Edition Covers Python 3.10\n\nClear, Concise, and Effective Programming\n\nLuciano Ramalho",
      "content_length": 105,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 3,
      "content": "Beijing Beijing\n\nBoston Boston\n\nSECOND EDITION\n\nFluent Python Clear, Concise, and Effective Programming\n\nLuciano Ramalho\n\nFarnham Sebastopol Farnham Sebastopol\n\nTokyo Tokyo",
      "content_length": 172,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 4,
      "content": "Fluent Python by Luciano Ramalho\n\nCopyright © 2022 Luciano Ramalho. All rights reserved.\n\nPrinted in the United States of America.\n\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\n\nO’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles (http://oreilly.com). For more information, contact our corporate/institu‐ tional sales department: 800-998-9938 or corporate@oreilly.com.\n\nAcquisitions Editor: Amanda Quinn Development Editor: Jeff Bleiel Production Editor: Daniel Elfanbaum Copyeditor: Sonia Saruba Proofreader: Kim Cofer\n\nIndexer: Judith McConville Interior Designer: David Futato Cover Designer: Karen Montgomery Illustrator: Kate Dullea\n\nApril 2022:\n\nSecond Edition\n\nRevision History for the Second Edition 2022-03-31: First Release\n\nSee http://oreilly.com/catalog/errata.csp?isbn=9781492056355 for release details.\n\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. Fluent Python, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.\n\nThe views expressed in this work are those of the author and do not represent the publisher’s views. While the publisher and the author have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the author disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work. Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.\n\n978-1-492-05635-5\n\n[LSI]",
      "content_length": 1914,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 5,
      "content": "Para Marta, com todo o meu amor.",
      "content_length": 32,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 7,
      "content": "Table of Contents\n\nPreface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xix\n\nPart I. Data Structures\n\n1. The Python Data Model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 What’s New in This Chapter 4 A Pythonic Card Deck 5 How Special Methods Are Used 8 Emulating Numeric Types 9 String Representation 12 Boolean Value of a Custom Type 13 Collection API 14 Overview of Special Methods 15 Why len Is Not a Method 17 Chapter Summary 18 Further Reading 18\n\n2. An Array of Sequences. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 What’s New in This Chapter 22 Overview of Built-In Sequences 22 List Comprehensions and Generator Expressions 25 List Comprehensions and Readability 25 Listcomps Versus map and filter 27 Cartesian Products 27 Generator Expressions 29 Tuples Are Not Just Immutable Lists 30 Tuples as Records 30\n\nv",
      "content_length": 1040,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 8,
      "content": "Tuples as Immutable Lists 32 Comparing Tuple and List Methods 34 Unpacking Sequences and Iterables 35 Using * to Grab Excess Items 36 Unpacking with * in Function Calls and Sequence Literals 37 Nested Unpacking 37 Pattern Matching with Sequences 38 Pattern Matching Sequences in an Interpreter 43 Slicing 47 Why Slices and Ranges Exclude the Last Item 47 Slice Objects 48 Multidimensional Slicing and Ellipsis 49 Assigning to Slices 50 Using + and * with Sequences 50 Building Lists of Lists 51 Augmented Assignment with Sequences 53 A += Assignment Puzzler 54 list.sort Versus the sorted Built-In 56 When a List Is Not the Answer 59 Arrays 59 Memory Views 62 NumPy 64 Deques and Other Queues 67 Chapter Summary 70 Further Reading 71\n\n3. Dictionaries and Sets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 What’s New in This Chapter 78 Modern dict Syntax 78 dict Comprehensions 79 Unpacking Mappings 80 Merging Mappings with | 80 Pattern Matching with Mappings 81 Standard API of Mapping Types 83 What Is Hashable 84 Overview of Common Mapping Methods 85 Inserting or Updating Mutable Values 87 Automatic Handling of Missing Keys 90 defaultdict: Another Take on Missing Keys 90 The __missing__ Method 91 Inconsistent Usage of __missing__ in the Standard Library 94 Variations of dict 95\n\nvi\n\n|\n\nTable of Contents",
      "content_length": 1376,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 9,
      "content": "collections.OrderedDict 95 collections.ChainMap 95 collections.Counter 96 shelve.Shelf 97 Subclassing UserDict Instead of dict 97 Immutable Mappings 99 Dictionary Views 101 Practical Consequences of How dict Works 102 Set Theory 103 Set Literals 105 Set Comprehensions 106 Practical Consequences of How Sets Work 107 Set Operations 107 Set Operations on dict Views 110 Chapter Summary 112 Further Reading 113\n\n4. Unicode Text Versus Bytes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117 What’s New in This Chapter 118 Character Issues 118 Byte Essentials 120 Basic Encoders/Decoders 123 Understanding Encode/Decode Problems 125 Coping with UnicodeEncodeError 125 Coping with UnicodeDecodeError 126 SyntaxError When Loading Modules with Unexpected Encoding 128 How to Discover the Encoding of a Byte Sequence 128 BOM: A Useful Gremlin 129 Handling Text Files 131 Beware of Encoding Defaults 134 Normalizing Unicode for Reliable Comparisons 140 Case Folding 142 Utility Functions for Normalized Text Matching 143 Extreme “Normalization”: Taking Out Diacritics 144 Sorting Unicode Text 148 Sorting with the Unicode Collation Algorithm 150 The Unicode Database 150 Finding Characters by Name 151 Numeric Meaning of Characters 153 Dual-Mode str and bytes APIs 155 str Versus bytes in Regular Expressions 155 str Versus bytes in os Functions 156 vii",
      "content_length": 1396,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 10,
      "content": "Chapter Summary 157 Further Reading 158\n\n5. Data Class Builders. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163 What’s New in This Chapter 164 Overview of Data Class Builders 164 Main Features 167 Classic Named Tuples 169 Typed Named Tuples 172 Type Hints 101 173 No Runtime Effect 173 Variable Annotation Syntax 174 The Meaning of Variable Annotations 175 More About @dataclass 179 Field Options 180 Post-init Processing 183 Typed Class Attributes 185 Initialization Variables That Are Not Fields 186 @dataclass Example: Dublin Core Resource Record 187 Data Class as a Code Smell 190 Data Class as Scaffolding 191 Data Class as Intermediate Representation 191 Pattern Matching Class Instances 192 Simple Class Patterns 192 Keyword Class Patterns 193 Positional Class Patterns 194 Chapter Summary 195 Further Reading 196\n\n6. Object References, Mutability, and Recycling. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201 What’s New in This Chapter 202 Variables Are Not Boxes 202 Identity, Equality, and Aliases 204 Choosing Between == and is 206 The Relative Immutability of Tuples 207 Copies Are Shallow by Default 208 Deep and Shallow Copies of Arbitrary Objects 211 Function Parameters as References 213 Mutable Types as Parameter Defaults: Bad Idea 214 Defensive Programming with Mutable Parameters 216 del and Garbage Collection 219 Tricks Python Plays with Immutables 221 Table of Contents\n\n6. Object References, Mutability, and Recycling. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201 What’s New in This Chapter 202 Variables Are Not Boxes 202 Identity, Equality, and Aliases 204 Choosing Between == and is 206 The Relative Immutability of Tuples 207 Copies Are Shallow by Default 208 Deep and Shallow Copies of Arbitrary Objects 211 Function Parameters as References 213 Mutable Types as Parameter Defaults: Bad Idea 214 Defensive Programming with Mutable Parameters 216 del and Garbage Collection 219 Tricks Python Plays with Immutables 221 Table of Contents",
      "content_length": 2073,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 11,
      "content": "Chapter Summary 223 Further Reading 224\n\nPart II.\n\nFunctions as Objects\n\n7. Functions as First-Class Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231 What’s New in This Chapter 232 Treating a Function Like an Object 232 Higher-Order Functions 234 Modern Replacements for map, filter, and reduce 235 Anonymous Functions 236 The Nine Flavors of Callable Objects 237 User-Defined Callable Types 239 From Positional to Keyword-Only Parameters 240 Positional-Only Parameters 242 Packages for Functional Programming 243 The operator Module 243 Freezing Arguments with functools.partial 247 Chapter Summary 249 Further Reading 250\n\n8. Type Hints in Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253 What’s New in This Chapter 254 About Gradual Typing 254 Gradual Typing in Practice 255 Starting with Mypy 256 Making Mypy More Strict 257 A Default Parameter Value 258 Using None as a Default 260 Types Are Defined by Supported Operations 260 Types Usable in Annotations 266 The Any Type 266 Simple Types and Classes 269 Optional and Union Types 270 Generic Collections 271 Tuple Types 274 Generic Mappings 276 Abstract Base Classes 278 Iterable 280 Parameterized Generics and TypeVar 282 Static Protocols 286\n\nTable of Contents\n\n|\n\nix",
      "content_length": 1343,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 12,
      "content": "Callable 291 NoReturn 294 Annotating Positional Only and Variadic Parameters 295 Imperfect Typing and Strong Testing 296 Chapter Summary 297 Further Reading 298\n\n9. Decorators and Closures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303 What’s New in This Chapter 304 Decorators 101 304 When Python Executes Decorators 306 Registration Decorators 308 Variable Scope Rules 308 Closures 311 The nonlocal Declaration 315 Variable Lookup Logic 316 Implementing a Simple Decorator 317 How It Works 318 Decorators in the Standard Library 320 Memoization with functools.cache 320 Using lru_cache 323 Single Dispatch Generic Functions 324 Parameterized Decorators 329 A Parameterized Registration Decorator 329 The Parameterized Clock Decorator 332 A Class-Based Clock Decorator 335 Chapter Summary 336 Further Reading 336\n\n10. Design Patterns with First-Class Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341 What’s New in This Chapter 342 Case Study: Refactoring Strategy 342 Classic Strategy 342 Function-Oriented Strategy 347 Choosing the Best Strategy: Simple Approach 350 Finding Strategies in a Module 351 Decorator-Enhanced Strategy Pattern 353 The Command Pattern 355 Chapter Summary 357 Further Reading 358\n\nx\n\n|\n\nTable of Contents",
      "content_length": 1324,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 13,
      "content": "Part III.\n\nClasses and Protocols\n\n11. A Pythonic Object. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 363 What’s New in This Chapter 364 Object Representations 364 Vector Class Redux 365 An Alternative Constructor 368 classmethod Versus staticmethod 369 Formatted Displays 370 A Hashable Vector2d 374 Supporting Positional Pattern Matching 377 Complete Listing of Vector2d, Version 3 378 Private and “Protected” Attributes in Python 382 Saving Memory with __slots__ 384 Simple Measure of __slot__ Savings 387 Summarizing the Issues with __slots__ 388 Overriding Class Attributes 389 Chapter Summary 391 Further Reading 392\n\n12. Special Methods for Sequences. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397 What’s New in This Chapter 398 Vector: A User-Defined Sequence Type 398 Vector Take #1: Vector2d Compatible 399 Protocols and Duck Typing 402 Vector Take #2: A Sliceable Sequence 403 How Slicing Works 404 A Slice-Aware __getitem__ 406 Vector Take #3: Dynamic Attribute Access 407 Vector Take #4: Hashing and a Faster == 411 Vector Take #5: Formatting 418 Chapter Summary 425 Further Reading 426 Interfaces, Protocols, and ABCs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 431 The Typing Map 432 What’s New in This Chapter 433 Two Kinds of Protocols 434 Programming Ducks 435 Python Digs Sequences 436 Monkey Patching: Implementing a Protocol at Runtime 438 Defensive Programming and “Fail Fast” 440\n\nTable of Contents\n\n|\n\nxi",
      "content_length": 1584,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 14,
      "content": "14.\n\nxii\n\n|\n\nGoose Typing 442 Subclassing an ABC 447 ABCs in the Standard Library 449 Defining and Using an ABC 451 ABC Syntax Details 457 Subclassing an ABC 458 A Virtual Subclass of an ABC 460 Usage of register in Practice 463 Structural Typing with ABCs 464 Static Protocols 466 The Typed double Function 466 Runtime Checkable Static Protocols 468 Limitations of Runtime Protocol Checks 471 Supporting a Static Protocol 472 Designing a Static Protocol 474 Best Practices for Protocol Design 476 Extending a Protocol 477 The numbers ABCs and Numeric Protocols 478 Chapter Summary 481 Further Reading 482\n\nInheritance: For Better or for Worse. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487 What’s New in This Chapter 488 The super() Function 488 Subclassing Built-In Types Is Tricky 490 Multiple Inheritance and Method Resolution Order 494 Mixin Classes 500 Case-Insensitive Mappings 500 Multiple Inheritance in the Real World 502 ABCs Are Mixins Too 502 ThreadingMixIn and ForkingMixIn 503 Django Generic Views Mixins 504 Multiple Inheritance in Tkinter 507 Coping with Inheritance 510 Favor Object Composition over Class Inheritance 510 Understand Why Inheritance Is Used in Each Case 510 Make Interfaces Explicit with ABCs 511 Use Explicit Mixins for Code Reuse 511 Provide Aggregate Classes to Users 511 Subclass Only Classes Designed for Subclassing 512 Avoid Subclassing from Concrete Classes 513 Tkinter: The Good, the Bad, and the Ugly 513\n\nTable of Contents",
      "content_length": 1505,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 15,
      "content": "Chapter Summary 514 Further Reading 515\n\n15. More About Type Hints. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 519 What’s New in This Chapter 519 Overloaded Signatures 520 Max Overload 521 Takeaways from Overloading max 525 TypedDict 526 Type Casting 534 Reading Type Hints at Runtime 537 Problems with Annotations at Runtime 538 Dealing with the Problem 540 Implementing a Generic Class 541 Basic Jargon for Generic Types 544 Variance 544 An Invariant Dispenser 545 A Covariant Dispenser 546 A Contravariant Trash Can 547 Variance Review 549 Implementing a Generic Static Protocol 552 Chapter Summary 554 Further Reading 555\n\n16. Operator Overloading. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 561 What’s New in This Chapter 562 Operator Overloading 101 562 Unary Operators 563 Overloading + for Vector Addition 566 Overloading * for Scalar Multiplication 572 Using @ as an Infix Operator 574 Wrapping-Up Arithmetic Operators 576 Rich Comparison Operators 577 Augmented Assignment Operators 580 Chapter Summary 585 Further Reading 587 Control Flow\n\n16. Operator Overloading. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 561 What’s New in This Chapter 562 Operator Overloading 101 562 Unary Operators 563 Overloading + for Vector Addition 566 Overloading * for Scalar Multiplication 572 Using @ as an Infix Operator 574 Wrapping-Up Arithmetic Operators 576 Rich Comparison Operators 577 Augmented Assignment Operators 580 Chapter Summary 585 Further Reading 587 Control Flow\n\n17.\n\nIterators, Generators, and Classic Coroutines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593 What’s New in This Chapter 594\n\nTable of Contents\n\n|\n\nxiii",
      "content_length": 1834,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 16,
      "content": "A Sequence of Words 594 Why Sequences Are Iterable: The iter Function 596 Using iter with a Callable 598 Iterables Versus Iterators 599 Sentence Classes with __iter__ 603 Sentence Take #2: A Classic Iterator 603 Don’t Make the Iterable an Iterator for Itself 605 Sentence Take #3: A Generator Function 606 How a Generator Works 607 Lazy Sentences 610 Sentence Take #4: Lazy Generator 610 Sentence Take #5: Lazy Generator Expression 611 When to Use Generator Expressions 613 An Arithmetic Progression Generator 615 Arithmetic Progression with itertools 618 Generator Functions in the Standard Library 619 Iterable Reducing Functions 630 Subgenerators with yield from 632 Reinventing chain 633 Traversing a Tree 634 Generic Iterable Types 639 Classic Coroutines 641 Example: Coroutine to Compute a Running Average 643 Returning a Value from a Coroutine 646 Generic Type Hints for Classic Coroutines 650 Chapter Summary 652 Further Reading 652\n\n18. with, match, and else Blocks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 657 What’s New in This Chapter 658 Context Managers and with Blocks 658 The contextlib Utilities 663 Using @contextmanager 664 Pattern Matching in lis.py: A Case Study 669 Scheme Syntax 669 Imports and Types 671 The Parser 671 The Environment 673 The REPL 675 The Evaluator 676 Procedure: A Class Implementing a Closure 685 Using OR-patterns 686 Table of Contents\n\n18. with, match, and else Blocks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 657 What’s New in This Chapter 658 Context Managers and with Blocks 658 The contextlib Utilities 663 Using @contextmanager 664 Pattern Matching in lis.py: A Case Study 669 Scheme Syntax 669 Imports and Types 671 The Parser 671 The Environment 673 The REPL 675 The Evaluator 676 Procedure: A Class Implementing a Closure 685 Using OR-patterns 686 Table of Contents",
      "content_length": 1922,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 17,
      "content": "Do This, Then That: else Blocks Beyond if 687 Chapter Summary 689 Further Reading 690\n\n19. Concurrency Models in Python. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 695 What’s New in This Chapter 696 The Big Picture 696 A Bit of Jargon 697 Processes, Threads, and Python’s Infamous GIL 699 A Concurrent Hello World 701 Spinner with Threads 701 Spinner with Processes 704 Spinner with Coroutines 706 Supervisors Side-by-Side 711 The Real Impact of the GIL 713 Quick Quiz 713 A Homegrown Process Pool 716 Process-Based Solution 718 Understanding the Elapsed Times 718 Code for the Multicore Prime Checker 719 Experimenting with More or Fewer Processes 723 Thread-Based Nonsolution 724 Python in the Multicore World 725 System Administration 726 Data Science 727 Server-Side Web/Mobile Development 728 WSGI Application Servers 730 Distributed Task Queues 732 Chapter Summary 733 Further Reading 734 Concurrency with Threads and Processes 734 The GIL 736 Concurrency Beyond the Standard Library 736 Concurrency and Scalability Beyond Python 738\n\n20. Concurrent Executors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 743 What’s New in This Chapter 743 Concurrent Web Downloads 744 A Sequential Download Script 746 Downloading with concurrent.futures 749 Where Are the Futures? 751 Launching Processes with concurrent.futures 754\n\nTable of Contents\n\n|\n\nxv",
      "content_length": 1453,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 18,
      "content": "Multicore Prime Checker Redux 755 Experimenting with Executor.map 758 Downloads with Progress Display and Error Handling 762 Error Handling in the flags2 Examples 766 Using futures.as_completed 769 Chapter Summary 772 Further Reading 772\n\n21. Asynchronous Programming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 775 What’s New in This Chapter 776 A Few Definitions 777 An asyncio Example: Probing Domains 778 Guido’s Trick to Read Asynchronous Code 780 New Concept: Awaitable 781 Downloading with asyncio and HTTPX 782 The Secret of Native Coroutines: Humble Generators 784 The All-or-Nothing Problem 785 Asynchronous Context Managers 786 Enhancing the asyncio Downloader 787 Using asyncio.as_completed and a Thread 788 Throttling Requests with a Semaphore 790 Making Multiple Requests for Each Download 794 Delegating Tasks to Executors 797 Writing asyncio Servers 799 A FastAPI Web Service 800 An asyncio TCP Server 804 Asynchronous Iteration and Asynchronous Iterables 811 Asynchronous Generator Functions 812 Async Comprehensions and Async Generator Expressions 818 async Beyond asyncio: Curio 821 Type Hinting Asynchronous Objects 824 How Async Works and How It Doesn’t 825 Running Circles Around Blocking Calls 825 The Myth of I/O-Bound Systems 826 Avoiding CPU-Bound Traps 826 Chapter Summary 827 Further Reading 828 Table of Contents\n\n21. Asynchronous Programming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 775 What’s New in This Chapter 776 A Few Definitions 777 An asyncio Example: Probing Domains 778 Guido’s Trick to Read Asynchronous Code 780 New Concept: Awaitable 781 Downloading with asyncio and HTTPX 782 The Secret of Native Coroutines: Humble Generators 784 The All-or-Nothing Problem 785 Asynchronous Context Managers 786 Enhancing the asyncio Downloader 787 Using asyncio.as_completed and a Thread 788 Throttling Requests with a Semaphore 790 Making Multiple Requests for Each Download 794 Delegating Tasks to Executors 797 Writing asyncio Servers 799 A FastAPI Web Service 800 An asyncio TCP Server 804 Asynchronous Iteration and Asynchronous Iterables 811 Asynchronous Generator Functions 812 Async Comprehensions and Async Generator Expressions 818 async Beyond asyncio: Curio 821 Type Hinting Asynchronous Objects 824 How Async Works and How It Doesn’t 825 Running Circles Around Blocking Calls 825 The Myth of I/O-Bound Systems 826 Avoiding CPU-Bound Traps 826 Chapter Summary 827 Further Reading 828 Table of Contents",
      "content_length": 2543,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 19,
      "content": "Part V. Metaprogramming\n\n22. Dynamic Attributes and Properties. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 835 What’s New in This Chapter 836 Data Wrangling with Dynamic Attributes 836 Exploring JSON-Like Data with Dynamic Attributes 838 The Invalid Attribute Name Problem 842 Flexible Object Creation with __new__ 843 Computed Properties 845 Step 1: Data-Driven Attribute Creation 846 Step 2: Property to Retrieve a Linked Record 848 Step 3: Property Overriding an Existing Attribute 852 Step 4: Bespoke Property Cache 853 Step 5: Caching Properties with functools 855 Using a Property for Attribute Validation 857 LineItem Take #1: Class for an Item in an Order 857 LineItem Take #2: A Validating Property 858 A Proper Look at Properties 860 Properties Override Instance Attributes 861 Property Documentation 864 Coding a Property Factory 865 Handling Attribute Deletion 868 Essential Attributes and Functions for Attribute Handling 869 Special Attributes that Affect Attribute Handling 870 Built-In Functions for Attribute Handling 870 Special Methods for Attribute Handling 871 Chapter Summary 873 Further Reading 873\n\n23. Attribute Descriptors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 879 What’s New in This Chapter 880 Descriptor Example: Attribute Validation 880 LineItem Take #3: A Simple Descriptor 880 LineItem Take #4: Automatic Naming of Storage Attributes 887 LineItem Take #5: A New Descriptor Type 889 Overriding Versus Nonoverriding Descriptors 892 Overriding Descriptors 894 Overriding Descriptor Without __get__ 895 Nonoverriding Descriptor 896 Overwriting a Descriptor in the Class 897 Methods Are Descriptors 898 Descriptor Usage Tips 900\n\nTable of Contents\n\n|\n\nxvii",
      "content_length": 1787,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 20,
      "content": "Descriptor Docstring and Overriding Deletion 902 Chapter Summary 903 Further Reading 904\n\n24. Class Metaprogramming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 907 What’s New in This Chapter 908 Classes as Objects 908 type: The Built-In Class Factory 909 A Class Factory Function 911 Introducing __init_subclass__ 914 Why __init_subclass__ Cannot Configure __slots__ 921 Enhancing Classes with a Class Decorator 922 What Happens When: Import Time Versus Runtime 925 Evaluation Time Experiments 926 Metaclasses 101 931 How a Metaclass Customizes a Class 933 A Nice Metaclass Example 934 Metaclass Evaluation Time Experiment 937 A Metaclass Solution for Checked 942 Metaclasses in the Real World 947 Modern Features Simplify or Replace Metaclasses 947 Metaclasses Are Stable Language Features 948 A Class Can Only Have One Metaclass 948 Metaclasses Should Be Implementation Details 949 A Metaclass Hack with __prepare__ 950 Wrapping Up 952 Chapter Summary 953 Further Reading 954\n\nAfterword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 959\n\nIndex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 963\n\nxviii\n\n|\n\nTable of Contents",
      "content_length": 1361,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 21,
      "content": "Preface\n\nHere’s the plan: when someone uses a feature you don’t understand, simply shoot them. This is easier than learning something new, and before too long the only living coders will be writing in an easily understood, tiny subset of Python 0.9.6 <wink>.1\n\n—Tim Peters, legendary core developer and author of The Zen of Python\n\n“Python is an easy to learn, powerful programming language.” Those are the first words of the official Python 3.10 tutorial. That is true, but there is a catch: because the language is easy to learn and put to use, many practicing Python programmers leverage only a fraction of its powerful features.\n\nAn experienced programmer may start writing useful Python code in a matter of hours. As the first productive hours become weeks and months, a lot of developers go on writing Python code with a very strong accent carried from languages learned before. Even if Python is your first language, often in academia and in introductory books it is presented while carefully avoiding language-specific features.\n\nAs a teacher introducing Python to programmers experienced in other languages, I see another problem that this book tries to address: we only miss stuff we know about. Coming from another language, anyone may guess that Python supports regu‐ lar expressions, and look that up in the docs. But if you’ve never seen tuple unpacking or descriptors before, you will probably not search for them, and you may end up not using those features just because they are specific to Python.\n\nThis book is not an A-to-Z exhaustive reference of Python. Its emphasis is on the lan‐ guage features that are either unique to Python or not found in many other popular languages. This is also mostly a book about the core language and some of its libra‐ ries. I will rarely talk about packages that are not in the standard library, even though the Python package index now lists more than 60,000 libraries, and many of them are incredibly useful.\n\n1 Message to the comp.lang.python Usenet group, Dec. 23, 2002: “Acrimony in c.l.p”.\n\nxix",
      "content_length": 2054,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 22,
      "content": "Who This Book Is For This book was written for practicing Python programmers who want to become pro‐ ficient in Python 3. I tested the examples in Python 3.10—most of them also in Python 3.9 and 3.8. When an example requires Python 3.10, it should be clearly marked.\n\nIf you are not sure whether you know enough Python to follow along, review the top‐ ics of the official Python tutorial. Topics covered in the tutorial will not be explained here, except for some features that are new.\n\nWho This Book Is Not For If you are just learning Python, this book is going to be hard to follow. Not only that, if you read it too early in your Python journey, it may give you the impression that every Python script should leverage special methods and metaprogramming tricks. Premature abstraction is as bad as premature optimization.\n\nFive Books in One I recommend that everyone read Chapter 1, “The Python Data Model”. The core audience for this book should not have trouble jumping directly to any part in this book after Chapter 1, but often I assume you’ve read preceding chapters in each spe‐ cific part. Think of Parts I through V as books within the book.\n\nI tried to emphasize using what is available before discussing how to build your own. For example, in Part I, Chapter 2 covers sequence types that are ready to use, includ‐ ing some that don’t get a lot of attention, like collections.deque. Building user- defined sequences is only addressed in Part III, where we also see how to leverage the abstract base classes (ABCs) from collections.abc. Creating your own ABCs is dis‐ cussed even later in Part III, because I believe it’s important to be comfortable using an ABC before writing your own.\n\nThis approach has a few advantages. First, knowing what is ready to use can save you from reinventing the wheel. We use existing collection classes more often than we implement our own, and we can give more attention to the advanced usage of avail‐ able tools by deferring the discussion on how to create new ones. We are also more likely to inherit from existing ABCs than to create a new ABC from scratch. And finally, I believe it is easier to understand the abstractions after you’ve seen them in action.\n\nThe downside of this strategy is the forward references scattered throughout the chapters. I hope these will be easier to tolerate now that you know why I chose this path.\n\nxx\n\n| Preface",
      "content_length": 2398,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 23,
      "content": "How the Book Is Organized Here are the main topics in each part of the book:\n\nPart I, “Data Structures”\n\nChapter 1 introduces the Python Data Model and explains why the special meth‐ ods (e.g., __repr__) are the key to the consistent behavior of objects of all types. Special methods are covered in more detail throughout the book. The remaining chapters in this part cover the use of collection types: sequences, mappings, and sets, as well as the str versus bytes split—the cause of much celebration among Python 3 users and much pain for Python 2 users migrating their codebases. Also covered are the high-level class builders in the standard library: named tuple fac‐ tories and the @dataclass decorator. Pattern matching—new in Python 3.10—is covered in sections in Chapters 2, 3, and 5, which discuss sequence patterns, mapping patterns, and class patterns. The last chapter in Part I is about the life cycle of objects: references, mutability, and garbage collection.\n\nPart II, “Functions as Objects”\n\nHere we talk about functions as first-class objects in the language: what that means, how it affects some popular design patterns, and how to implement func‐ tion decorators by leveraging closures. Also covered here is the general concept of callables in Python, function attributes, introspection, parameter annotations, and the new nonlocal declaration in Python 3. Chapter 8 introduces the major new topic of type hints in function signatures.\n\nPart III, “Classes and Protocols”\n\nNow the focus is on building classes “by hand”—as opposed to using the class builders covered in Chapter 5. Like any Object-Oriented (OO) language, Python has its particular set of features that may or may not be present in the language in which you and I learned class-based programming. The chapters explain how to build your own collections, abstract base classes (ABCs), and protocols, as well as how to cope with multiple inheritance, and how to implement operator overloading—when that makes sense. Chapter 15 continues the coverage of type hints.\n\nPart IV, “Control Flow”\n\nCovered in this part are the language constructs and libraries that go beyond tra‐ ditional control flow with conditionals, loops, and subroutines. We start with generators, then visit context managers and coroutines, including the challenging but powerful new yield from syntax. Chapter 18 includes a significant example using pattern matching in a simple but functional language interpreter. Chap‐ ter 19, “Concurrency Models in Python” is a new chapter presenting an overview of alternatives for concurrent and parallel processing in Python, their limitations, and how software architecture allows Python to operate at web scale. I rewrote\n\nPreface\n\n|\n\nxxi",
      "content_length": 2731,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 24,
      "content": "the chapter about asynchronous programming to emphasize core language fea‐ tures—e.g., await, async dev, async for, and async with, and show how they are used with asyncio and other frameworks.\n\nPart V, “Metaprogramming”\n\nThis part starts with a review of techniques for building classes with attributes created dynamically to handle semi-structured data, such as JSON datasets. Next, we cover the familiar properties mechanism, before diving into how object attribute access works at a lower level in Python using descriptors. The relation‐ ship among functions, methods, and descriptors is explained. Throughout Part V, the step-by-step implementation of a field validation library uncovers subtle issues that lead to the advanced tools of the final chapter: class decorators and metaclasses.\n\nHands-On Approach Often we’ll use the interactive Python console to explore the language and libraries. I feel it is important to emphasize the power of this learning tool, particularly for those readers who’ve had more experience with static, compiled languages that don’t pro‐ vide a read-eval-print loop (REPL).\n\nOne of the standard Python testing packages, doctest, works by simulating console sessions and verifying that the expressions evaluate to the responses shown. I used doctest to check most of the code in this book, including the console listings. You don’t need to use or even know about doctest to follow along: the key feature of doctests is that they look like transcripts of interactive Python console sessions, so you can easily try out the demonstrations yourself.\n\nSometimes I will explain what we want to accomplish by showing a doctest before the code that makes it pass. Firmly establishing what is to be done before thinking about how to do it helps focus our coding effort. Writing tests first is the basis of test-driven development (TDD), and I’ve also found it helpful when teaching. If you are unfami‐ liar with doctest, take a look at its documentation and this book’s example code repository.\n\nI also wrote unit tests for some of the larger examples using pytest—which I find eas‐ ier to use and more powerful than the unittest module in the standard library. You’ll find that you can verify the correctness of most of the code in the book by typing python3 -m doctest example_script.py or pytest in the command shell of your OS. The pytest.ini configuration at the root of the example code repository ensures that doctests are collected and executed by the pytest command.\n\nxxii\n\n| Preface",
      "content_length": 2519,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 25,
      "content": "Soapbox: My Personal Perspective I have been using, teaching, and debating Python since 1998, and I enjoy studying and comparing programming languages, their design, and the theory behind them. At the end of some chapters, I have added “Soapbox” sidebars with my own perspec‐ tive about Python and other languages. Feel free to skip these if you are not into such discussions. Their content is completely optional.\n\nCompanion Website: fluentpython.com Covering new features—like type hints, data classes, and pattern matching—made this second edition almost 30% larger than the first. To keep the book luggable, I moved some content to fluentpython.com. You will find links to articles I published there in several chapters. Some sample chapters are also in the companion website. The full text is available online at the O’Reilly Learning subscription service. The example code repository is on GitHub.\n\nConventions Used in This Book The following typographical conventions are used in this book:\n\nItalic\n\nIndicates new terms, URLs, email addresses, filenames, and file extensions.\n\nConstant width\n\nUsed for program listings, as well as within paragraphs to refer to program ele‐ ments such as variable or function names, databases, data types, environment variables, statements, and keywords.\n\nNote that when a line break falls within a constant_width term, a hyphen is not added—it could be misunderstood as part of the term.\n\nConstant width bold\n\nShows commands or other text that should be typed literally by the user.\n\nConstant width italic\n\nShows text that should be replaced with user-supplied values or by values deter‐ mined by context.\n\nPreface\n\n|\n\nxxiii",
      "content_length": 1665,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 26,
      "content": "This element signifies a tip or suggestion.\n\nThis element signifies a general note.\n\nThis element indicates a warning or caution.\n\nUsing Code Examples Every script and most code snippets that appear in the book are available in the Flu‐ ent Python code repository on GitHub at https://fpy.li/code.\n\nIf you have a technical question or a problem using the code examples, please send email to bookquestions@oreilly.com.\n\nThis book is here to help you get your job done. In general, if example code is offered with this book, you may use it in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing examples from O’Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product’s documentation does require permission.\n\nWe appreciate, but generally do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN, e.g., “Fluent Python, 2nd ed., by Luciano Ramalho (O’Reilly). Copyright 2022 Luciano Ramalho, 978-1-492-05635-5.”\n\nIf you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at permissions@oreilly.com.\n\nxxiv\n\n| Preface",
      "content_length": 1492,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 27,
      "content": "O’Reilly Online Learning\n\nFor more than 40 years, O’Reilly Media has provided technol‐ ogy and business training, knowledge, and insight to help companies succeed.\n\nOur unique network of experts and innovators share their knowledge and expertise through books, articles, and our online learning platform. O’Reilly’s online learning platform gives you on-demand access to live training courses, in-depth learning paths, interactive coding environments, and a vast collection of text and video from O’Reilly and 200+ other publishers. For more information, visit http://oreilly.com.\n\nHow to Contact Us Please address comments and questions concerning this book to the publisher:\n\nO’Reilly Media, Inc. 1005 Gravenstein Highway North Sebastopol, CA 95472 800-998-9938 (in the United States or Canada) 707-829-0515 (international or local) 707-829-0104 (fax)\n\nWe have a web page for this book, where we list errata, examples, and any additional information. You can access this page at https://fpy.li/p-4.\n\nEmail bookquestions@oreilly.com to comment or ask technical questions about this book.\n\nFor news and information about our books and courses, visit http://oreilly.com.\n\nFind us on Facebook: http://facebook.com/oreilly.\n\nFollow us on Twitter: https://twitter.com/oreillymedia.\n\nWatch us on YouTube: http://www.youtube.com/oreillymedia.\n\nAcknowledgments I did not expect updating a Python book five years later to be such a major undertak‐ ing, but it was. Marta Mello, my beloved wife, was always there when I needed her. My dear friend Leonardo Rochael helped me from the earliest writing to the final technical review, including consolidating and double-checking the feedback from the other tech reviewers, readers, and editors. I honestly don’t know if I’d have made it without your support, Marta and Leo. Thank you so much!\n\nPreface\n\n|\n\nxxv",
      "content_length": 1846,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 28,
      "content": "Jürgen Gmach, Caleb Hattingh, Jess Males, Leonardo Rochael, and Miroslav Šedivý were the outstanding technical review team for the second edition. They reviewed the whole book. Bill Behrman, Bruce Eckel, Renato Oliveira, and Rodrigo Bernardo Pimentel reviewed specific chapters. Their many suggestions from different perspec‐ tives made the book much better.\n\nMany readers sent corrections or made other contributions during the early release phase, including: Guilherme Alves, Christiano Anderson, Konstantin Baikov, K. Alex Birch, Michael Boesl, Lucas Brunialti, Sergio Cortez, Gino Crecco, Chukwuerika Dike, Juan Esteras, Federico Fissore, Will Frey, Tim Gates, Alexander Hagerman, Chen Hanxiao, Sam Hyeong, Simon Ilincev, Parag Kalra, Tim King, David Kwast, Tina Lapine, Wanpeng Li, Guto Maia, Scott Martindale, Mark Meyer, Andy McFar‐ land, Chad McIntire, Diego Rabatone Oliveira, Francesco Piccoli, Meredith Rawls, Michael Robinson, Federico Tula Rovaletti, Tushar Sadhwani, Arthur Constantino Scardua, Randal L. Schwartz, Avichai Sefati, Guannan Shen, William Simpson, Vivek Vashist, Jerry Zhang, Paul Zuradzki—and others who did not want to be named, sent corrections after I delivered the draft, or are omitted because I failed to record their names—sorry.\n\nDuring my research, I learned about typing, concurrency, pattern matching, and metaprogramming while interacting with Michael Albert, Pablo Aguilar, Kaleb Bar‐ rett, David Beazley, J. S. O. Bueno, Bruce Eckel, Martin Fowler, Ivan Levkivskyi, Alex Martelli, Peter Norvig, Sebastian Rittau, Guido van Rossum, Carol Willing, and Jelle Zijlstra.\n\nO’Reilly editors Jeff Bleiel, Jill Leonard, and Amelia Blevins made suggestions that improved the flow of the book in many places. Jeff Bleiel and production editor Danny Elfanbaum supported me throughout this long marathon.\n\nThe insights and suggestions of every one of them made the book better and more accurate. Inevitably, there will still be bugs of my own creation in the final product. I apologize in advance.\n\nFinally, I want to extend my heartfelt thanks to my colleagues at Thoughtworks Brazil —and especially to my sponsor, Alexey Bôas—who supported this project in many ways, all the way.\n\nOf course, everyone who helped me understand Python and write the first edition now deserves double thanks. There would be no second edition without a successful first.\n\nxxvi\n\n| Preface",
      "content_length": 2398,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 29,
      "content": "Acknowledgments for the First Edition The Bauhaus chess set by Josef Hartwig is an example of excellent design: beautiful, simple, and clear. Guido van Rossum, son of an architect and brother of a master font designer, created a masterpiece of language design. I love teaching Python because it is beautiful, simple, and clear.\n\nAlex Martelli and Anna Ravenscroft were the first people to see the outline of this book and encouraged me to submit it to O’Reilly for publication. Their books taught me idiomatic Python and are models of clarity, accuracy, and depth in technical writ‐ ing. Alex’s 6,200+ Stack Overflow posts are a fountain of insights about the language and its proper use.\n\nMartelli and Ravenscroft were also technical reviewers of this book, along with Len‐ nart Regebro and Leonardo Rochael. Everyone in this outstanding technical review team has at least 15 years of Python experience, with many contributions to high- impact Python projects in close contact with other developers in the community. Together they sent me hundreds of corrections, suggestions, questions, and opinions, adding tremendous value to the book. Victor Stinner kindly reviewed Chapter 21, bringing his expertise as an asyncio maintainer to the technical review team. It was a great privilege and a pleasure to collaborate with them over these past several months.\n\nEditor Meghan Blanchette was an outstanding mentor, helping me improve the orga‐ nization and flow of the book, letting me know when it was boring, and keeping me from delaying even more. Brian MacDonald edited chapters in Part II while Meghan was away. I enjoyed working with them, and with everyone I’ve contacted at O’Reilly, including the Atlas development and support team (Atlas is the O’Reilly book pub‐ lishing platform, which I was fortunate to use to write this book).\n\nMario Domenech Goulart provided numerous, detailed suggestions starting with the first early release. I also received valuable feedback from Dave Pawson, Elias Dor‐ neles, Leonardo Alexandre Ferreira Leite, Bruce Eckel, J. S. Bueno, Rafael Gonçalves, Alex Chiaranda, Guto Maia, Lucas Vido, and Lucas Brunialti.\n\nOver the years, a number of people urged me to become an author, but the most per‐ suasive were Rubens Prates, Aurelio Jargas, Rudá Moura, and Rubens Altimari. Mauricio Bussab opened many doors for me, including my first real shot at writing a book. Renzo Nuccitelli supported this writing project all the way, even if that meant a slow start for our partnership at python.pro.br.\n\nThe wonderful Brazilian Python community is knowledgeable, generous, and fun. The Python Brasil group has thousands of people, and our national conferences bring together hundreds, but the most influential in my journey as a Pythonista were Leo‐ nardo Rochael, Adriano Petrich, Daniel Vainsencher, Rodrigo RBP Pimentel, Bruno Gola, Leonardo Santagada, Jean Ferri, Rodrigo Senra, J. S. Bueno, David Kwast, Luiz\n\nPreface\n\n|\n\nxxvii",
      "content_length": 2961,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 30,
      "content": "Irber, Osvaldo Santana, Fernando Masanori, Henrique Bastos, Gustavo Niemayer, Pedro Werneck, Gustavo Barbieri, Lalo Martins, Danilo Bellini, and Pedro Kroger.\n\nDorneles Tremea was a great friend (incredibly generous with his time and knowl‐ edge), an amazing hacker, and the most inspiring leader of the Brazilian Python Association. He left us too early.\n\nMy students over the years taught me a lot through their questions, insights, feed‐ back, and creative solutions to problems. Érico Andrei and Simples Consultoria made it possible for me to focus on being a Python teacher for the first time.\n\nMartijn Faassen was my Grok mentor and shared invaluable insights with me about Python and Neanderthals. His work and that of Paul Everitt, Chris McDonough, Tres Seaver, Jim Fulton, Shane Hathaway, Lennart Regebro, Alan Runyan, Alexander Limi, Martijn Pieters, Godefroid Chapelle, and others from the Zope, Plone, and Pyr‐ amid planets have been decisive in my career. Thanks to Zope and surfing the first web wave, I was able to start making a living with Python in 1998. José Octavio Cas‐ tro Neves was my partner in the first Python-centric software house in Brazil.\n\nI have too many gurus in the wider Python community to list them all, but besides those already mentioned, I am indebted to Steve Holden, Raymond Hettinger, A.M. Kuchling, David Beazley, Fredrik Lundh, Doug Hellmann, Nick Coghlan, Mark Pil‐ grim, Martijn Pieters, Bruce Eckel, Michele Simionato, Wesley Chun, Brandon Craig Rhodes, Philip Guo, Daniel Greenfeld, Audrey Roy, and Brett Slatkin for teaching me new and better ways to teach Python.\n\nMost of these pages were written in my home office and in two labs: CoffeeLab and Garoa Hacker Clube. CoffeeLab is the caffeine-geek headquarters in Vila Madalena, São Paulo, Brazil. Garoa Hacker Clube is a hackerspace open to all: a community lab where anyone can freely try out new ideas.\n\nThe Garoa community provided inspiration, infrastructure, and slack. I think Aleph would enjoy this book.\n\nMy mother, Maria Lucia, and my father, Jairo, always supported me in every way. I wish he was here to see the book; I am glad I can share it with her.\n\nMy wife, Marta Mello, endured 15 months of a husband who was always working, but remained supportive and coached me through some critical moments in the project when I feared I might drop out of the marathon.\n\nThank you all, for everything.\n\nxxviii\n\n| Preface",
      "content_length": 2426,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 31,
      "content": "PART I Data Structures",
      "content_length": 22,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 33,
      "content": "CHAPTER 1 The Python Data Model\n\nGuido’s sense of the aesthetics of language design is amazing. I’ve met many fine lan‐ guage designers who could build theoretically beautiful languages that no one would ever use, but Guido is one of those rare people who can build a language that is just slightly less theoretically beautiful but thereby is a joy to write programs in.\n\n—Jim Hugunin, creator of Jython, cocreator of AspectJ, and architect of the .Net DLR1\n\nOne of the best qualities of Python is its consistency. After working with Python for a while, you are able to start making informed, correct guesses about features that are new to you.\n\nHowever, if you learned another object-oriented language before Python, you may find it strange to use len(collection) instead of collection.len(). This apparent oddity is the tip of an iceberg that, when properly understood, is the key to every‐ thing we call Pythonic. The iceberg is called the Python Data Model, and it is the API that we use to make our own objects play well with the most idiomatic language features.\n\nYou can think of the data model as a description of Python as a framework. It formal‐ izes the interfaces of the building blocks of the language itself, such as sequences, functions, iterators, coroutines, classes, context managers, and so on.\n\nWhen using a framework, we spend a lot of time coding methods that are called by the framework. The same happens when we leverage the Python Data Model to build new classes. The Python interpreter invokes special methods to perform basic object operations, often triggered by special syntax. The special method names are always written with leading and trailing double underscores. For example, the syntax\n\n1 “Story of Jython”, written as a foreword to Jython Essentials by Samuele Pedroni and Noel Rappin (O’Reilly).\n\n3",
      "content_length": 1835,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 34,
      "content": "obj[key] is supported by the __getitem__ special method. In order to evaluate my_collection[key], the interpreter calls my_collection.__getitem__(key).\n\nWe implement special methods when we want our objects to support and interact with fundamental language constructs such as:\n\nCollections\n\nAttribute access • Iteration (including asynchronous iteration using async for)\n\nOperator overloading\n\nFunction and method invocation\n\nString representation and formatting • Asynchronous programming using await\n\nObject creation and destruction • Managed contexts using the with or async with statements\n\nMagic and Dunder\n\nThe term magic method is slang for special method, but how do we talk about a specific method like __getitem__? I learned to say “dunder-getitem” from author and teacher Steve Holden. “Dun‐ der” is a shortcut for “double underscore before and after.” That’s why the special methods are also known as dunder methods. The “Lexical Analysis” chapter of The Python Language Reference warns that “Any use of __*__ names, in any context, that does not follow explicitly documented use, is subject to breakage without warning.”\n\nWhat’s New in This Chapter This chapter had few changes from the first edition because it is an introduction to the Python Data Model, which is quite stable. The most significant changes are:\n\nSpecial methods supporting asynchronous programming and other new features, added to the tables in “Overview of Special Methods” on page 15.\n\nFigure 1-2 showing the use of special methods in “Collection API” on page 14, including the collections.abc.Collection abstract base class introduced in Python 3.6.\n\n4\n\n|\n\nChapter 1: The Python Data Model",
      "content_length": 1674,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 35,
      "content": "Also, here and throughout this second edition I adopted the f-string syntax intro‐ duced in Python 3.6, which is more readable and often more convenient than the older string formatting notations: the str.format() method and the % operator.\n\nOne reason to still use my_fmt.format() is when the definition of my_fmt must be in a different place in the code than where the for‐ matting operation needs to happen. For instance, when my_fmt has multiple lines and is better defined in a constant, or when it must come from a configuration file, or from the database. Those are real needs, but don’t happen very often.\n\nA Pythonic Card Deck Example 1-1 is simple, but it demonstrates the power of implementing just two spe‐ cial methods, __getitem__ and __len__.\n\nExample 1-1. A deck as a sequence of playing cards\n\nimport collections\n\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n\nclass FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split()\n\ndef __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\ndef __len__(self): return len(self._cards)\n\ndef __getitem__(self, position): return self._cards[position]\n\nThe first thing to note is the use of collections.namedtuple to construct a simple class to represent individual cards. We use namedtuple to build classes of objects that are just bundles of attributes with no custom methods, like a database record. In the example, we use it to provide a nice representation for the cards in the deck, as shown in the console session:\n\n>>> beer_card = Card('7', 'diamonds') >>> beer_card Card(rank='7', suit='diamonds')\n\nA Pythonic Card Deck\n\n|\n\n5",
      "content_length": 1696,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 36,
      "content": "But the point of this example is the FrenchDeck class. It’s short, but it packs a punch. First, like any standard Python collection, a deck responds to the len() function by returning the number of cards in it:\n\n>>> deck = FrenchDeck() >>> len(deck) 52\n\nReading specific cards from the deck—say, the first or the last—is easy, thanks to the __getitem__ method:\n\n>>> deck[0] Card(rank='2', suit='spades') >>> deck[-1] Card(rank='A', suit='hearts')\n\nShould we create a method to pick a random card? No need. Python already has a function to get a random item from a sequence: random.choice. We can use it on a deck instance:\n\n>>> from random import choice >>> choice(deck) Card(rank='3', suit='hearts') >>> choice(deck) Card(rank='K', suit='spades') >>> choice(deck) Card(rank='2', suit='clubs')\n\nWe’ve just seen two advantages of using special methods to leverage the Python Data Model:\n\nUsers of your classes don’t have to memorize arbitrary method names for stan‐ dard operations. (“How to get the number of items? Is it .size(), .length(), or what?”)\n\nIt’s easier to benefit from the rich Python standard library and avoid reinventing the wheel, like the random.choice function.\n\nBut it gets better.\n\nBecause our __getitem__ delegates to the [] operator of self._cards, our deck automatically supports slicing. Here’s how we look at the top three cards from a brand-new deck, and then pick just the aces by starting at index 12 and skipping 13 cards at a time:\n\n>>> deck[:3] [Card(rank='2', suit='spades'), Card(rank='3', suit='spades'), Card(rank='4', suit='spades')] >>> deck[12::13] [Card(rank='A', suit='spades'), Card(rank='A', suit='diamonds'), Card(rank='A', suit='clubs'), Card(rank='A', suit='hearts')]\n\n6\n\n|\n\nChapter 1: The Python Data Model",
      "content_length": 1753,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 37,
      "content": "Just by implementing the __getitem__ special method, our deck is also iterable:\n\n>>> for card in deck: # doctest: +ELLIPSIS ... print(card) Card(rank='2', suit='spades') Card(rank='3', suit='spades') Card(rank='4', suit='spades') ...\n\nWe can also iterate over the deck in reverse:\n\n>>> for card in reversed(deck): # doctest: +ELLIPSIS ... print(card) Card(rank='A', suit='hearts') Card(rank='K', suit='hearts') Card(rank='Q', suit='hearts') ...\n\nEllipsis in doctests\n\nWhenever possible, I extracted the Python console listings in this book from doctest to ensure accuracy. When the output was too long, the elided part is marked by an ellipsis (...), like in the last line in the preceding code. In such cases, I used the # doctest: +ELLIPSIS directive to make the doctest pass. If you are trying these examples in the interactive console, you may omit the doctest comments altogether.\n\nIteration is often implicit. If a collection has no __contains__ method, the in opera‐ tor does a sequential scan. Case in point: in works with our FrenchDeck class because it is iterable. Check it out:\n\n>>> Card('Q', 'hearts') in deck True >>> Card('7', 'beasts') in deck False\n\nHow about sorting? A common system of ranking cards is by rank (with aces being highest), then by suit in the order of spades (highest), hearts, diamonds, and clubs (lowest). Here is a function that ranks cards by that rule, returning 0 for the 2 of clubs and 51 for the ace of spades:\n\nsuit_values = dict(spades=3, hearts=2, diamonds=1, clubs=0)\n\ndef spades_high(card): rank_value = FrenchDeck.ranks.index(card.rank) return rank_value * len(suit_values) + suit_values[card.suit]\n\nGiven spades_high, we can now list our deck in order of increasing rank:\n\nA Pythonic Card Deck\n\n|\n\n7",
      "content_length": 1748,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 38,
      "content": ">>> for card in sorted(deck, key=spades_high): # doctest: +ELLIPSIS ... print(card) Card(rank='2', suit='clubs') Card(rank='2', suit='diamonds') Card(rank='2', suit='hearts') ... (46 cards omitted) Card(rank='A', suit='diamonds') Card(rank='A', suit='hearts') Card(rank='A', suit='spades')\n\nAlthough FrenchDeck implicitly inherits from the object class, most of its function‐ ality is not inherited, but comes from leveraging the data model and composition. By implementing the special methods __len__ and __getitem__, our FrenchDeck behaves like a standard Python sequence, allowing it to benefit from core language features (e.g., iteration and slicing) and from the standard library, as shown by the examples using random.choice, reversed, and sorted. Thanks to composition, the __len__ and __getitem__ implementations can delegate all the work to a list object, self._cards.\n\nHow About Shuffling?\n\nAs implemented so far, a FrenchDeck cannot be shuffled because it is immutable: the cards and their positions cannot be changed, except by violating encapsulation and handling the _cards attribute directly. In Chapter 13, we will fix that by adding a one- line __setitem__ method.\n\nHow Special Methods Are Used The first thing to know about special methods is that they are meant to be called by the Python interpreter, and not by you. You don’t write my_object.__len__(). You write len(my_object) and, if my_object is an instance of a user-defined class, then Python calls the __len__ method you implemented.\n\nBut the interpreter takes a shortcut when dealing for built-in types like list, str, bytearray, or extensions like the NumPy arrays. Python variable-sized collections written in C include a struct2 called PyVarObject, which has an ob_size field holding the number of items in the collection. So, if my_object is an instance of one of those built-ins, then len(my_object) retrieves the value of the ob_size field, and this is much faster than calling a method.\n\n2 A C struct is a record type with named fields.\n\n8\n\n|\n\nChapter 1: The Python Data Model",
      "content_length": 2062,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 39,
      "content": "More often than not, the special method call is implicit. For example, the statement for i in x: actually causes the invocation of iter(x), which in turn may call x.__iter__() if that is available, or use x.__getitem__(), as in the FrenchDeck example.\n\nNormally, your code should not have many direct calls to special methods. Unless you are doing a lot of metaprogramming, you should be implementing special meth‐ ods more often than invoking them explicitly. The only special method that is fre‐ quently called by user code directly is __init__ to invoke the initializer of the superclass in your own __init__ implementation.\n\nIf you need to invoke a special method, it is usually better to call the related built-in function (e.g., len, iter, str, etc.). These built-ins call the corresponding special method, but often provide other services and—for built-in types—are faster than method calls. See, for example, “Using iter with a Callable” on page 598 in Chapter 17.\n\nIn the next sections, we’ll see some of the most important uses of special methods:\n\nEmulating numeric types\n\nString representation of objects\n\nBoolean value of an object\n\nImplementing collections\n\nEmulating Numeric Types Several special methods allow user objects to respond to operators such as +. We will cover that in more detail in Chapter 16, but here our goal is to further illustrate the use of special methods through another simple example.\n\nWe will implement a class to represent two-dimensional vectors—that is, Euclidean vectors like those used in math and physics (see Figure 1-1).\n\nThe built-in complex type can be used to represent two- dimensional vectors, but our class can be extended to represent n- dimensional vectors. We will do that in Chapter 17.\n\nHow Special Methods Are Used\n\n|\n\n9",
      "content_length": 1781,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 40,
      "content": "Figure 1-1. Example of two-dimensional vector addition; Vector(2, 4) + Vector(2, 1) results in Vector(4, 5).\n\nWe will start designing the API for such a class by writing a simulated console session that we can use later as a doctest. The following snippet tests the vector addition pic‐ tured in Figure 1-1:\n\n>>> v1 = Vector(2, 4) >>> v2 = Vector(2, 1) >>> v1 + v2 Vector(4, 5)\n\nNote how the + operator results in a new Vector, displayed in a friendly format at the console.\n\nThe abs built-in function returns the absolute value of integers and floats, and the magnitude of complex numbers, so to be consistent, our API also uses abs to calcu‐ late the magnitude of a vector:\n\n>>> v = Vector(3, 4) >>> abs(v) 5.0\n\nWe can also implement the * operator to perform scalar multiplication (i.e., multi‐ plying a vector by a number to make a new vector with the same direction and a multiplied magnitude):\n\n>>> v * 3 Vector(9, 12) >>> abs(v * 3) 15.0\n\n10\n\n|\n\nChapter 1: The Python Data Model",
      "content_length": 985,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 41,
      "content": "Example 1-2 is a Vector class implementing the operations just described, through the use of the special methods __repr__, __abs__, __add__, and __mul__.\n\nExample 1-2. A simple two-dimensional vector class\n\n\"\"\" vector2d.py: a simplistic class demonstrating some special methods\n\nIt is simplistic for didactic reasons. It lacks proper error handling, especially in the ``__add__`` and ``__mul__`` methods.\n\nThis example is greatly expanded later in the book.\n\nAddition::\n\n>>> v1 = Vector(2, 4) >>> v2 = Vector(2, 1) >>> v1 + v2 Vector(4, 5)\n\nAbsolute value::\n\n>>> v = Vector(3, 4) >>> abs(v) 5.0\n\nScalar multiplication::\n\n>>> v * 3 Vector(9, 12) >>> abs(v * 3) 15.0\n\n\"\"\"\n\nimport math\n\nclass Vector:\n\ndef __init__(self, x=0, y=0): self.x = x self.y = y\n\ndef __repr__(self): return f'Vector({self.x!r}, {self.y!r})'\n\ndef __abs__(self): return math.hypot(self.x, self.y)\n\ndef __bool__(self):\n\nHow Special Methods Are Used\n\n|\n\n11",
      "content_length": 924,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 42,
      "content": "return bool(abs(self))\n\ndef __add__(self, other): x = self.x + other.x y = self.y + other.y return Vector(x, y)\n\ndef __mul__(self, scalar): return Vector(self.x * scalar, self.y * scalar)\n\nWe implemented five special methods in addition to the familiar __init__. Note that none of them is directly called within the class or in the typical usage of the class illustrated by the doctests. As mentioned before, the Python interpreter is the only frequent caller of most special methods.\n\nExample 1-2 implements two operators: + and *, to show basic usage of __add__ and __mul__. In both cases, the methods create and return a new instance of Vector, and do not modify either operand—self or other are merely read. This is the expected behavior of infix operators: to create new objects and not touch their operands. I will have a lot more to say about that in Chapter 16.\n\nAs implemented, Example 1-2 allows multiplying a Vector by a number, but not a number by a Vector, which violates the commu‐ tative property of scalar multiplication. We will fix that with the special method __rmul__ in Chapter 16.\n\nIn the following sections, we discuss the other special methods in Vector.\n\nString Representation The __repr__ special method is called by the repr built-in to get the string represen‐ tation of the object for inspection. Without a custom __repr__, Python’s console would display a Vector instance <Vector object at 0x10e100070>.\n\nThe interactive console and debugger call repr on the results of the expressions eval‐ uated, as does the %r placeholder in classic formatting with the % operator, and the !r conversion field in the new format string syntax used in f-strings the str.format method.\n\nNote that the f-string in our __repr__ uses !r to get the standard representation of the attributes to be displayed. This is good practice, because it shows the crucial dif‐ ference between Vector(1, 2) and Vector('1', '2')—the latter would not work in the context of this example, because the constructor’s arguments should be numbers, not str.\n\n12\n\n|\n\nChapter 1: The Python Data Model",
      "content_length": 2087,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 43,
      "content": "The string returned by __repr__ should be unambiguous and, if possible, match the source code necessary to re-create the represented object. That is why our Vector representation looks like calling the constructor of the class (e.g., Vector(3, 4)).\n\nIn contrast, __str__ is called by the str() built-in and implicitly used by the print function. It should return a string suitable for display to end users.\n\nSometimes same string returned by __repr__ is user-friendly, and you don’t need to code __str__ because the implementation inherited from the object class calls __repr__ as a fallback. Example 5-2 is one of several examples in this book with a custom __str__.\n\nProgrammers with prior experience in languages with a toString method tend to implement __str__ and not __repr__. If you only implement one of these special methods in Python, choose __repr__. “What is the difference between __str__ and __repr__ in Python?” is a Stack Overflow question with excellent contributions from Pythonistas Alex Martelli and Martijn Pieters.\n\nBoolean Value of a Custom Type Although Python has a bool type, it accepts any object in a Boolean context, such as the expression controlling an if or while statement, or as operands to and, or, and not. To determine whether a value x is truthy or falsy, Python applies bool(x), which returns either True or False.\n\nBy default, instances of user-defined classes are considered truthy, unless either __bool__ or __len__ is implemented. Basically, bool(x) calls x.__bool__() and uses the result. If __bool__ is not implemented, Python tries to invoke x.__len__(), and if that returns zero, bool returns False. Otherwise bool returns True.\n\nOur implementation of __bool__ is conceptually simple: it returns False if the mag‐ nitude of the vector is zero, True otherwise. We convert the magnitude to a Boolean using bool(abs(self)) because __bool__ is expected to return a Boolean. Outside of __bool__ methods, it is rarely necessary to call bool() explicitly, because any object can be used in a Boolean context.\n\nNote how the special method __bool__ allows your objects to follow the truth value testing rules defined in the “Built-in Types” chapter of The Python Standard Library documentation.\n\nHow Special Methods Are Used\n\n|\n\n13",
      "content_length": 2269,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 44,
      "content": "A faster implementation of Vector.__bool__ is this:\n\ndef __bool__(self): return bool(self.x or self.y)\n\nThis is harder to read, but avoids the trip through abs, __abs__, the squares, and square root. The explicit conversion to bool is needed because __bool__ must return a Boolean, and or returns either operand as is: x or y evaluates to x if that is truthy, otherwise the result is y, whatever that is.\n\nCollection API Figure 1-2 documents the interfaces of the essential collection types in the language. All the classes in the diagram are ABCs—abstract base classes. ABCs and the collec tions.abc module are covered in Chapter 13. The goal of this brief section is to give a panoramic view of Python’s most important collection interfaces, showing how they are built from special methods.\n\nFigure 1-2. UML class diagram with fundamental collection types. Method names in italic are abstract, so they must be implemented by concrete subclasses such as list and dict. The remaining methods have concrete implementations, therefore subclasses can inherit them.\n\nEach of the top ABCs has a single special method. The Collection ABC (new in Python 3.6) unifies the three essential interfaces that every collection should implement:\n\n14\n\n|\n\nChapter 1: The Python Data Model",
      "content_length": 1271,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 45,
      "content": "Iterable to support for, unpacking, and other forms of iteration • Sized to support the len built-in function • Container to support the in operator\n\nPython does not require concrete classes to actually inherit from any of these ABCs. Any class that implements __len__ satisfies the Sized interface.\n\nThree very important specializations of Collection are:\n\nSequence, formalizing the interface of built-ins like list and str • Mapping, implemented by dict, collections.defaultdict, etc. • Set, the interface of the set and frozenset built-in types\n\nOnly Sequence is Reversible, because sequences support arbitrary ordering of their contents, while mappings and sets do not.\n\nSince Python 3.7, the dict type is officially “ordered,” but that only means that the key insertion order is preserved. You cannot rearrange the keys in a dict however you like.\n\nAll the special methods in the Set ABC implement infix operators. For example, a & b computes the intersection of sets a and b, and is implemented in the __and__ special method.\n\nThe next two chapters will cover standard library sequences, mappings, and sets in detail.\n\nNow let’s consider the major categories of special methods defined in the Python Data Model.\n\nOverview of Special Methods The “Data Model” chapter of The Python Language Reference lists more than 80 spe‐ cial method names. More than half of them implement arithmetic, bitwise, and com‐ parison operators. As an overview of what is available, see the following tables.\n\nTable 1-1 shows special method names, excluding those used to implement infix operators or core math functions like abs. Most of these methods will be covered throughout the book, including the most recent additions: asynchronous special methods such as __anext__ (added in Python 3.5), and the class customization hook, __init_subclass__ (from Python 3.6).\n\nOverview of Special Methods\n\n|\n\n15",
      "content_length": 1887,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 46,
      "content": "Table 1-1. Special method names (operators excluded)\n\nCategory String/bytes representation\n\nMethod names\n\n__repr__ __str__ __format__ __bytes__ __fspath__\n\nConversion to number\n\n__bool__ __complex__ __int__ __float__ __hash__ __index__\n\nEmulating collections\n\n__len__ __getitem__ __setitem__ __delitem__ __contains__\n\nIteration\n\n__iter__ __aiter__ __next__ __anext__ __reversed__\n\nCallable or coroutine execution\n\n__call__ __await__\n\nContext management\n\n__enter__ __exit__ __aexit__ __aenter__\n\nInstance creation and destruction __new__ __init__ __del__\n\nAttribute management\n\n__getattr__ __getattribute__ __setattr__ __delattr__ __dir__\n\nAttribute descriptors\n\n__get__ __set__ __delete__ __set_name__\n\nAbstract base classes\n\n__instancecheck__ __subclasscheck__\n\nClass metaprogramming\n\n__prepare__ __init_subclass__ __class_getitem__ __mro_entries__\n\nInfix and numerical operators are supported by the special methods listed in Table 1-2. Here the most recent names are __matmul__, __rmatmul__, and __imat mul__, added in Python 3.5 to support the use of @ as an infix operator for matrix multiplication, as we’ll see in Chapter 16.\n\nTable 1-2. Special method names and symbols for operators\n\nOperator category Unary numeric\n\nSymbols\n\n+ abs()\n\nMethod names\n\n__neg__ __pos__ __abs__\n\nRich comparison\n\n< <= == != > >=\n\n__lt__ __le__ __eq__ __ne__ __gt__ __ge__\n\nArithmetic\n\n+ - * / // % @ divmod() round() ** pow()\n\n__add__ __sub__ __mul__ __truediv__ __floordiv__ __mod__ __matmul__ __div mod__ __round__ __pow__\n\nReversed arithmetic\n\n(arithmetic operators with swapped operands)\n\n__radd__ __rsub__ __rmul__ __rtrue div__ __rfloordiv__ __rmod__ __rmat mul__ __rdivmod__ __rpow__\n\nAugmented assignment arithmetic\n\n+= -= *= /= //= %= @= **=\n\n__iadd__ __isub__ __imul__ __itrue div__ __ifloordiv__ __imod__ __imat mul__ __ipow__\n\nBitwise\n\n& | ^ << >> ~\n\n__and__ __or__ __xor__ __lshift__ __rshift__ __invert__\n\nReversed bitwise\n\n(bitwise operators with swapped operands)\n\n__rand__ __ror__ __rxor__ __rlshift__ __rrshift__\n\n16\n\n|\n\nChapter 1: The Python Data Model",
      "content_length": 2058,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 47,
      "content": "Operator category Augmented assignment bitwise\n\nSymbols\n\n&= |= ^= <<= >>=\n\nMethod names\n\n__iand__ __ior__ __ixor__ __ilshift__ __irshift__\n\nPython calls a reversed operator special method on the second operand when the corresponding special method on the first operand cannot be used. Augmented assignments are shortcuts combining an infix operator with variable assignment, e.g., a += b.\n\nChapter 16 explains reversed operators and augmented assignment in detail.\n\nWhy len Is Not a Method I asked this question to core developer Raymond Hettinger in 2013, and the key to his answer was a quote from “The Zen of Python”: “practicality beats purity.” In “How Special Methods Are Used” on page 8, I described how len(x) runs very fast when x is an instance of a built-in type. No method is called for the built-in objects of CPython: the length is simply read from a field in a C struct. Getting the number of items in a collection is a common operation and must work efficiently for such basic and diverse types as str, list, memoryview, and so on.\n\nIn other words, len is not called as a method because it gets special treatment as part of the Python Data Model, just like abs. But thanks to the special method __len__, you can also make len work with your own custom objects. This is a fair compromise between the need for efficient built-in objects and the consistency of the language. Also from “The Zen of Python”: “Special cases aren’t special enough to break the rules.”\n\nIf you think of abs and len as unary operators, you may be more inclined to forgive their functional look and feel, as opposed to the method call syntax one might expect in an object-oriented lan‐ guage. In fact, the ABC language—a direct ancestor of Python that pioneered many of its features—had an # operator that was the equivalent of len (you’d write #s). When used as an infix operator, written x#s, it counted the occurrences of x in s, which in Python you get as s.count(x), for any sequence s.\n\nWhy len Is Not a Method\n\n|\n\n17",
      "content_length": 2012,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 48,
      "content": "Chapter Summary By implementing special methods, your objects can behave like the built-in types, enabling the expressive coding style the community considers Pythonic.\n\nA basic requirement for a Python object is to provide usable string representations of itself, one used for debugging and logging, another for presentation to end users. That is why the special methods __repr__ and __str__ exist in the data model.\n\nEmulating sequences, as shown with the FrenchDeck example, is one of the most common uses of the special methods. For example, database libraries often return query results wrapped in sequence-like collections. Making the most of existing sequence types is the subject of Chapter 2. Implementing your own sequences will be covered in Chapter 12, when we create a multidimensional extension of the Vector class.\n\nThanks to operator overloading, Python offers a rich selection of numeric types, from the built-ins to decimal.Decimal and fractions.Fraction, all supporting infix arithmetic operators. The NumPy data science libraries support infix operators with matrices and tensors. Implementing operators—including reversed operators and augmented assignment—will be shown in Chapter 16 via enhancements of the Vector example.\n\nThe use and implementation of the majority of the remaining special methods of the Python Data Model are covered throughout this book.\n\nFurther Reading The “Data Model” chapter of The Python Language Reference is the canonical source for the subject of this chapter and much of this book.\n\nPython in a Nutshell, 3rd ed. by Alex Martelli, Anna Ravenscroft, and Steve Holden (O’Reilly) has excellent coverage of the data model. Their description of the mechan‐ ics of attribute access is the most authoritative I’ve seen apart from the actual C source code of CPython. Martelli is also a prolific contributor to Stack Overflow, with more than 6,200 answers posted. See his user profile at Stack Overflow.\n\nDavid Beazley has two books covering the data model in detail in the context of Python 3: Python Essential Reference, 4th ed. (Addison-Wesley), and Python Cook‐ book, 3rd ed. (O’Reilly), coauthored with Brian K. Jones.\n\nThe Art of the Metaobject Protocol (MIT Press) by Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow explains the concept of a metaobject protocol, of which the Python Data Model is one example.\n\n18\n\n|\n\nChapter 1: The Python Data Model",
      "content_length": 2411,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 49,
      "content": "Soapbox\n\nData Model or Object Model?\n\nWhat the Python documentation calls the “Python Data Model,” most authors would say is the “Python object model.” Martelli, Ravenscroft, and Holden’s Python in a Nutshell, 3rd ed., and David Beazley’s Python Essential Reference, 4th ed. are the best books covering the Python Data Model, but they refer to it as the “object model.” On Wikipedia, the first definition of “object model” is: “The properties of objects in gen‐ eral in a specific computer programming language.” This is what the Python Data Model is about. In this book, I will use “data model” because the documentation favors that term when referring to the Python object model, and because it is the title of the chapter of The Python Language Reference most relevant to our discussions.\n\nMuggle Methods\n\nThe Original Hacker’s Dictionary defines magic as “yet unexplained, or too compli‐ cated to explain” or “a feature not generally publicized which allows something other‐ wise impossible.”\n\nThe Ruby community calls their equivalent of the special methods magic methods. Many in the Python community adopt that term as well. I believe the special methods are the opposite of magic. Python and Ruby empower their users with a rich metaob‐ ject protocol that is fully documented, enabling muggles like you and me to emulate many of the features available to core developers who write the interpreters for those languages.\n\nIn contrast, consider Go. Some objects in that language have features that are magic, in the sense that we cannot emulate them in our own user-defined types. For exam‐ ple, Go arrays, strings, and maps support the use brackets for item access, as in a[i]. But there’s no way to make the [] notation work with a new collection type that you define. Even worse, Go has no user-level concept of an iterable interface or an iterator object, therefore its for/range syntax is limited to supporting five “magic” built-in types, including arrays, strings, and maps.\n\nMaybe in the future, the designers of Go will enhance its metaobject protocol. But currently, it is much more limited than what we have in Python or Ruby.\n\nMetaobjects\n\nThe Art of the Metaobject Protocol (AMOP) is my favorite computer book title. But I mention it because the term metaobject protocol is useful to think about the Python Data Model and similar features in other languages. The metaobject part refers to the objects that are the building blocks of the language itself. In this context, protocol is a synonym of interface. So a metaobject protocol is a fancy synonym for object model: an API for core language constructs.\n\nFurther Reading\n\n|\n\n19",
      "content_length": 2647,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 50,
      "content": "20\n\nA rich metaobject protocol enables extending a language to support new program‐ ming paradigms. Gregor Kiczales, the first author of the AMOP book, later became a pioneer in aspect-oriented programming and the initial author of AspectJ, an exten‐ sion of Java implementing that paradigm. Aspect-oriented programming is much easier to implement in a dynamic language like Python, and some frameworks do it. The most important example is zope.interface, part of the framework on which the Plone content management system is built.\n\n|\n\nChapter 1: The Python Data Model",
      "content_length": 569,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 51,
      "content": "CHAPTER 2 An Array of Sequences\n\nAs you may have noticed, several of the operations mentioned work equally for texts, lists and tables. Texts, lists and tables together are called ‘trains’. [...] The FOR com‐ mand also works generically on trains.\n\n—Leo Geurts, Lambert Meertens, and Steven Pembertonm, ABC Programmer’s Handbook1\n\nBefore creating Python, Guido was a contributor to the ABC language—a 10-year research project to design a programming environment for beginners. ABC intro‐ duced many ideas we now consider “Pythonic”: generic operations on different types of sequences, built-in tuple and mapping types, structure by indentation, strong typing without variable declarations, and more. It’s no accident that Python is so user-friendly.\n\nPython inherited from ABC the uniform handling of sequences. Strings, lists, byte sequences, arrays, XML elements, and database results share a rich set of common operations, including iteration, slicing, sorting, and concatenation.\n\nUnderstanding the variety of sequences available in Python saves us from reinventing the wheel, and their common interface inspires us to create APIs that properly sup‐ port and leverage existing and future sequence types.\n\nMost of the discussion in this chapter applies to sequences in general, from the famil‐ iar list to the str and bytes types added in Python 3. Specific topics on lists, tuples, arrays, and queues are also covered here, but the specifics of Unicode strings and byte sequences appear in Chapter 4. Also, the idea here is to cover sequence types that are ready to use. Creating your own sequence types is the subject of Chapter 12.\n\n1 Leo Geurts, Lambert Meertens, and Steven Pemberton, ABC Programmer’s Handbook, p. 8. (Bosko Books).\n\n21",
      "content_length": 1744,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 52,
      "content": "These are the main topics this chapter will cover:\n\nList comprehensions and the basics of generator expressions\n\nUsing tuples as records versus using tuples as immutable lists\n\nSequence unpacking and sequence patterns\n\nReading from slices and writing to slices\n\nSpecialized sequence types, like arrays and queues\n\nWhat’s New in This Chapter The most important update in this chapter is “Pattern Matching with Sequences” on page 38. That’s the first time the new pattern matching feature of Python 3.10 appears in this second edition.\n\nOther changes are not updates but improvements over the first edition:\n\nNew diagram and description of the internals of sequences, contrasting contain‐ ers and flat sequences\n\nBrief comparison of the performance and storage characteristics of list versus tuple\n\nCaveats of tuples with mutable elements, and how to detect them if needed\n\nI moved coverage of named tuples to “Classic Named Tuples” on page 169 in Chapter 5, where they are compared to typing.NamedTuple and @dataclass.\n\nTo make room for new content and keep the page count within reason, the section “Managing Ordered Sequences with Bisect” from the first edition is now a post in the fluentpython.com com‐ panion website.\n\nOverview of Built-In Sequences The standard library offers a rich selection of sequence types implemented in C:\n\nContainer sequences\n\nCan hold items of different types, including nested containers. Some examples: list, tuple, and collections.deque.\n\nFlat sequences\n\nHold items of one simple type. Some examples: str, bytes, and array.array.\n\n22\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1604,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 53,
      "content": "A container sequence holds references to the objects it contains, which may be of any type, while a flat sequence stores the value of its contents in its own memory space, not as distinct Python objects. See Figure 2-1.\n\nFigure 2-1. Simplified memory diagrams for a tuple and an array, each with three items. Gray cells represent the in-memory header of each Python object—not drawn to proportion. The tuple has an array of references to its items. Each item is a separate Python object, possibly holding references to other Python objects, like that two-item list. In contrast, the Python array is a single object, holding a C language array of three doubles.\n\nThus, flat sequences are more compact, but they are limited to holding primitive machine values like bytes, integers, and floats.\n\nEvery Python object in memory has a header with metadata. The simplest Python object, a float, has a value field and two metadata fields:\n\nob_refcnt: the object’s reference count • ob_type: a pointer to the object’s type • ob_fval: a C double holding the value of the float\n\nOn a 64-bit Python build, each of those fields takes 8 bytes. That’s why an array of floats is much more compact than a tuple of floats: the array is a single object holding the raw values of the floats, while the tuple consists of several objects—the tuple itself and each float object contained in it.\n\nOverview of Built-In Sequences\n\n|\n\n23",
      "content_length": 1410,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 54,
      "content": "Another way of grouping sequence types is by mutability:\n\nMutable sequences\n\nFor example, list, bytearray, array.array, and collections.deque.\n\nImmutable sequences\n\nFor example, tuple, str, and bytes.\n\nFigure 2-2 helps visualize how mutable sequences inherit all methods from immuta‐ ble sequences, and implement several additional methods. The built-in concrete sequence types do not actually subclass the Sequence and MutableSequence abstract base classes (ABCs), but they are virtual subclasses registered with those ABCs—as we’ll see in Chapter 13. Being virtual subclasses, tuple and list pass these tests:\n\n>>> from collections import abc >>> issubclass(tuple, abc.Sequence) True >>> issubclass(list, abc.MutableSequence) True\n\nFigure 2-2. Simplified UML class diagram for some classes from collections.abc (super‐ classes are on the left; inheritance arrows point from subclasses to superclasses; names in italic are abstract classes and abstract methods).\n\nKeep in mind these common traits: mutable versus immutable; container versus flat. They are helpful to extrapolate what you know about one sequence type to others.\n\nThe most fundamental sequence type is the list: a mutable container. I expect you are very familiar with lists, so we’ll jump right into list comprehensions, a powerful way of building lists that is sometimes underused because the syntax may look unusual at first. Mastering list comprehensions opens the door to generator expres‐ sions, which—among other uses—can produce elements to fill up sequences of any type. Both are the subject of the next section.\n\n24\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1628,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 55,
      "content": "List Comprehensions and Generator Expressions A quick way to build a sequence is using a list comprehension (if the target is a list) or a generator expression (for other kinds of sequences). If you are not using these syntactic forms on a daily basis, I bet you are missing opportunities to write code that is more readable and often faster at the same time.\n\nIf you doubt my claim that these constructs are “more readable,” read on. I’ll try to convince you.\n\nFor brevity, many Python programmers refer to list comprehen‐ sions as listcomps, and generator expressions as genexps. I will use these words as well.\n\nList Comprehensions and Readability Here is a test: which do you find easier to read, Example 2-1 or Example 2-2?\n\nExample 2-1. Build a list of Unicode code points from a string\n\n>>> symbols = '$¢£¥€¤' >>> codes = [] >>> for symbol in symbols: ... codes.append(ord(symbol)) ... >>> codes [36, 162, 163, 165, 8364, 164]\n\nExample 2-2. Build a list of Unicode code points from a string, using a listcomp\n\n>>> symbols = '$¢£¥€¤' >>> codes = [ord(symbol) for symbol in symbols] >>> codes [36, 162, 163, 165, 8364, 164]\n\nAnybody who knows a little bit of Python can read Example 2-1. However, after learning about listcomps, I find Example 2-2 more readable because its intent is explicit.\n\nA for loop may be used to do lots of different things: scanning a sequence to count or pick items, computing aggregates (sums, averages), or any number of other tasks. The code in Example 2-1 is building up a list. In contrast, a listcomp is more explicit. Its goal is always to build a new list.\n\nList Comprehensions and Generator Expressions\n\n|\n\n25",
      "content_length": 1650,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 56,
      "content": "Of course, it is possible to abuse list comprehensions to write truly incomprehensible code. I’ve seen Python code with listcomps used just to repeat a block of code for its side effects. If you are not doing something with the produced list, you should not use that syntax. Also, try to keep it short. If the list comprehension spans more than two lines, it is probably best to break it apart or rewrite it as a plain old for loop. Use your best judgment: for Python, as for English, there are no hard-and-fast rules for clear writing.\n\nSyntax Tip\n\nIn Python code, line breaks are ignored inside pairs of [], {}, or (). So you can build multiline lists, listcomps, tuples, dictionaries, etc., without using the \\ line continuation escape, which doesn’t work if you accidentally type a space after it. Also, when those delimiter pairs are used to define a literal with a comma-separated series of items, a trailing comma will be ignored. So, for example, when cod‐ ing a multiline list literal, it is thoughtful to put a comma after the last item, making it a little easier for the next coder to add one more item to that list, and reducing noise when reading diffs.\n\nLocal Scope Within Comprehensions and Generator Expressions In Python 3, list comprehensions, generator expressions, and their siblings set and dict comprehensions, have a local scope to hold the variables assigned in the for clause.\n\nHowever, variables assigned with the “Walrus operator” := remain accessible after those comprehensions or expressions return—unlike local variables in a function. PEP 572—Assignment Expressions defines the scope of the target of := as the enclos‐ ing function, unless there is a global or nonlocal declaration for that target.2\n\n>>> x = 'ABC' >>> codes = [ord(x) for x in x] >>> x 'ABC' >>> codes [65, 66, 67] >>> codes = [last := ord(c) for c in x] >>> last 67 >>> c Traceback (most recent call last):\n\n2 Thanks to reader Tina Lapine for pointing this out.\n\n26\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 2001,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 57,
      "content": "File \"<stdin>\", line 1, in <module> NameError: name 'c' is not defined\n\nx was not clobbered: it’s still bound to 'ABC'.\n\nlast remains.\n\nc is gone; it existed only inside the listcomp.\n\nList comprehensions build lists from sequences or any other iterable type by filtering and transforming items. The filter and map built-ins can be composed to do the same, but readability suffers, as we will see next.\n\nListcomps Versus map and filter Listcomps do everything the map and filter functions do, without the contortions of the functionally challenged Python lambda. Consider Example 2-3.\n\nExample 2-3. The same list built by a listcomp and a map/filter composition\n\n>>> symbols = '$¢£¥€¤' >>> beyond_ascii = [ord(s) for s in symbols if ord(s) > 127] >>> beyond_ascii [162, 163, 165, 8364, 164] >>> beyond_ascii = list(filter(lambda c: c > 127, map(ord, symbols))) >>> beyond_ascii [162, 163, 165, 8364, 164]\n\nI used to believe that map and filter were faster than the equivalent listcomps, but Alex Martelli pointed out that’s not the case—at least not in the preceding examples. The 02-array-seq/listcomp_speed.py script in the Fluent Python code repository is a simple speed test comparing listcomp with filter/map.\n\nI’ll have more to say about map and filter in Chapter 7. Now we turn to the use of listcomps to compute Cartesian products: a list containing tuples built from all items from two or more lists.\n\nCartesian Products Listcomps can build lists from the Cartesian product of two or more iterables. The items that make up the Cartesian product are tuples made from items from every input iterable. The resulting list has a length equal to the lengths of the input iterables multiplied. See Figure 2-3.\n\nList Comprehensions and Generator Expressions\n\n|\n\n27",
      "content_length": 1765,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 58,
      "content": "Figure 2-3. The Cartesian product of 3 card ranks and 4 suits is a sequence of 12 pairings.\n\nFor example, imagine you need to produce a list of T-shirts available in two colors and three sizes. Example 2-4 shows how to produce that list using a listcomp. The result has six items.\n\nExample 2-4. Cartesian product using a list comprehension\n\n>>> colors = ['black', 'white'] >>> sizes = ['S', 'M', 'L'] >>> tshirts = [(color, size) for color in colors for size in sizes] >>> tshirts [('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'), ('white', 'M'), ('white', 'L')] >>> for color in colors: ... for size in sizes: ... print((color, size)) ... ('black', 'S') ('black', 'M') ('black', 'L') ('white', 'S') ('white', 'M') ('white', 'L') >>> tshirts = [(color, size) for size in sizes ... for color in colors] >>> tshirts [('black', 'S'), ('white', 'S'), ('black', 'M'), ('white', 'M'), ('black', 'L'), ('white', 'L')]\n\n28\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 966,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 59,
      "content": "This generates a list of tuples arranged by color, then size.\n\nNote how the resulting list is arranged as if the for loops were nested in the same order as they appear in the listcomp.\n\nTo get items arranged by size, then color, just rearrange the for clauses; adding a line break to the listcomp makes it easier to see how the result will be ordered.\n\nIn Example 1-1 (Chapter 1), I used the following expression to initialize a card deck with a list made of 52 cards from all 13 ranks of each of the 4 suits, sorted by suit, then rank:\n\nself._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\nListcomps are a one-trick pony: they build lists. To generate data for other sequence types, a genexp is the way to go. The next section is a brief look at genexps in the context of building sequences that are not lists.\n\nGenerator Expressions To initialize tuples, arrays, and other types of sequences, you could also start from a listcomp, but a genexp (generator expression) saves memory because it yields items one by one using the iterator protocol instead of building a whole list just to feed another constructor.\n\nGenexps use the same syntax as listcomps, but are enclosed in parentheses rather than brackets.\n\nExample 2-5 shows basic usage of genexps to build a tuple and an array.\n\nExample 2-5. Initializing a tuple and an array from a generator expression\n\n>>> symbols = '$¢£¥€¤' >>> tuple(ord(symbol) for symbol in symbols) (36, 162, 163, 165, 8364, 164) >>> import array >>> array.array('I', (ord(symbol) for symbol in symbols)) array('I', [36, 162, 163, 165, 8364, 164])\n\nIf the generator expression is the single argument in a function call, there is no need to duplicate the enclosing parentheses.\n\nThe array constructor takes two arguments, so the parentheses around the gen‐ erator expression are mandatory. The first argument of the array constructor defines the storage type used for the numbers in the array, as we’ll see in “Arrays” on page 59.\n\nList Comprehensions and Generator Expressions\n\n|\n\n29",
      "content_length": 2038,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 60,
      "content": "Example 2-6 uses a genexp with a Cartesian product to print out a roster of T-shirts of two colors in three sizes. In contrast with Example 2-4, here the six-item list of T- shirts is never built in memory: the generator expression feeds the for loop produc‐ ing one item at a time. If the two lists used in the Cartesian product had a thousand items each, using a generator expression would save the cost of building a list with a million items just to feed the for loop.\n\nExample 2-6. Cartesian product in a generator expression\n\n>>> colors = ['black', 'white'] >>> sizes = ['S', 'M', 'L'] >>> for tshirt in (f'{c} {s}' for c in colors for s in sizes): ... print(tshirt) ... black S black M black L white S white M white L\n\nThe generator expression yields items one by one; a list with all six T-shirt varia‐ tions is never produced in this example.\n\nChapter 17 explains how generators work in detail. Here the idea was just to show the use of generator expressions to initialize sequences other than lists, or to produce output that you don’t need to keep in memory.\n\nNow we move on to the other fundamental sequence type in Python: the tuple.\n\nTuples Are Not Just Immutable Lists Some introductory texts about Python present tuples as “immutable lists,” but that is short selling them. Tuples do double duty: they can be used as immutable lists and also as records with no field names. This use is sometimes overlooked, so we will start with that.\n\nTuples as Records Tuples hold records: each item in the tuple holds the data for one field, and the posi‐ tion of the item gives its meaning.\n\nIf you think of a tuple just as an immutable list, the quantity and the order of the items may or may not be important, depending on the context. But when using a\n\n30\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1799,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 61,
      "content": "tuple as a collection of fields, the number of items is usually fixed and their order is always important.\n\nExample 2-7 shows tuples used as records. Note that in every expression, sorting the tuple would destroy the information because the meaning of each field is given by its position in the tuple.\n\nExample 2-7. Tuples used as records\n\n>>> lax_coordinates = (33.9425, -118.408056) >>> city, year, pop, chg, area = ('Tokyo', 2003, 32_450, 0.66, 8014) >>> traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'), ... ('ESP', 'XDA205856')] >>> for passport in sorted(traveler_ids): ... print('%s/%s' % passport) ... BRA/CE342567 ESP/XDA205856 USA/31195855 >>> for country, _ in traveler_ids: ... print(country) ... USA BRA ESP\n\nLatitude and longitude of the Los Angeles International Airport.\n\nData about Tokyo: name, year, population (thousands), population change (%), and area (km²).\n\nA list of tuples of the form (country_code, passport_number).\n\nAs we iterate over the list, passport is bound to each tuple.\n\nThe % formatting operator understands tuples and treats each item as a separate field.\n\nThe for loop knows how to retrieve the items of a tuple separately—this is called “unpacking.” Here we are not interested in the second item, so we assign it to _, a dummy variable.\n\nTuples Are Not Just Immutable Lists\n\n|\n\n31",
      "content_length": 1329,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 62,
      "content": "In general, using _ as a dummy variable is just a convention. It’s just a strange but valid variable name. However, in a match/case statement, _ is a wildcard that matches any value but is not bound to a value. See “Pattern Matching with Sequences” on page 38. And in the Python console, the result of the preceding command is assigned to _—unless the result is None.\n\nWe often think of records as data structures with named fields. Chapter 5 presents two ways of creating tuples with named fields.\n\nBut often, there’s no need to go through the trouble of creating a class just to name the fields, especially if you leverage unpacking and avoid using indexes to access the fields. In Example 2-7, we assigned ('Tokyo', 2003, 32_450, 0.66, 8014) to city, year, pop, chg, area in a single statement. Then, the % operator assigned each item in the passport tuple to the corresponding slot in the format string in the print argument. Those are two examples of tuple unpacking.\n\nThe term tuple unpacking is widely used by Pythonistas, but itera‐ ble unpacking is gaining traction, as in the title of PEP 3132 — Extended Iterable Unpacking.\n\n“Unpacking Sequences and Iterables” on page 35 presents a lot more about unpacking not only tuples, but sequences and iterables in general.\n\nNow let’s consider the tuple class as an immutable variant of the list class.\n\nTuples as Immutable Lists The Python interpreter and standard library make extensive use of tuples as immuta‐ ble lists, and so should you. This brings two key benefits:\n\nClarity\n\nWhen you see a tuple in code, you know its length will never change.\n\nPerformance\n\nA tuple uses less memory than a list of the same length, and it allows Python to do some optimizations.\n\nHowever, be aware that the immutability of a tuple only applies to the references contained in it. References in a tuple cannot be deleted or replaced. But if one of those references points to a mutable object, and that object is changed, then the value of the tuple changes. The next snippet illustrates this point by creating two tuples—a and b—which are initially equal. Figure 2-4 represents the initial layout of the b tuple in memory.\n\n32\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 2205,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 63,
      "content": "Figure 2-4. The content of the tuple itself is immutable, but that only means the refer‐ ences held by the tuple will always point to the same objects. However, if one of the ref‐ erenced objects is mutable—like a list—its content may change.\n\nWhen the last item in b is changed, b and a become different:\n\n>>> a = (10, 'alpha', [1, 2]) >>> b = (10, 'alpha', [1, 2]) >>> a == b True >>> b[-1].append(99) >>> a == b False >>> b (10, 'alpha', [1, 2, 99])\n\nTuples with mutable items can be a source of bugs. As we’ll see in “What Is Hasha‐ ble” on page 84, an object is only hashable if its value cannot ever change. An unhasha‐ ble tuple cannot be inserted as a dict key, or a set element.\n\nIf you want to determine explicitly if a tuple (or any object) has a fixed value, you can use the hash built-in to create a fixed function like this:\n\n>>> def fixed(o): ... try: ... hash(o) ... except TypeError: ... return False ... return True ... >>> tf = (10, 'alpha', (1, 2)) >>> tm = (10, 'alpha', [1, 2]) >>> fixed(tf) True\n\nTuples Are Not Just Immutable Lists\n\n|\n\n33",
      "content_length": 1062,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 64,
      "content": ">>> fixed(tm) False\n\nWe explore this issue further in “The Relative Immutability of Tuples” on page 207.\n\nDespite this caveat, tuples are widely used as immutable lists. They offer some perfor‐ mance advantages explained by Python core developer Raymond Hettinger in a StackOverflow answer to the question: “Are tuples more efficient than lists in Python?”. To summarize, Hettinger wrote:\n\nTo evaluate a tuple literal, the Python compiler generates bytecode for a tuple constant in one operation; but for a list literal, the generated bytecode pushes each element as a separate constant to the data stack, and then builds the list. • Given a tuple t, tuple(t) simply returns a reference to the same t. There’s no need to copy. In contrast, given a list l, the list(l) constructor must create a new copy of l.\n\nBecause of its fixed length, a tuple instance is allocated the exact memory space it needs. Instances of list, on the other hand, are allocated with room to spare, to amortize the cost of future appends.\n\nThe references to the items in a tuple are stored in an array in the tuple struct, while a list holds a pointer to an array of references stored elsewhere. The indi‐ rection is necessary because when a list grows beyond the space currently alloca‐ ted, Python needs to reallocate the array of references to make room. The extra indirection makes CPU caches less effective.\n\nComparing Tuple and List Methods When using a tuple as an immutable variation of list, it is good to know how similar their APIs are. As you can see in Table 2-1, tuple supports all list methods that do not involve adding or removing items, with one exception—tuple lacks the __reversed__ method. However, that is just for optimization; reversed(my_tuple) works without it.\n\nTable 2-1. Methods and attributes found in list or tuple (methods implemented by object are omitted for brevity)\n\nlist\n\ntuple\n\ns.__add__(s2)\n\n\n\n\n\ns + s2—concatenation\n\ns.__iadd__(s2)\n\n\n\ns += s2—in-place concatenation\n\ns.append(e)\n\n\n\nAppend one element after last\n\ns.clear()\n\n\n\nDelete all items\n\ns.__contains__(e)\n\n\n\n\n\ne in s\n\ns.copy()\n\n\n\nShallow copy of the list\n\n34\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 2167,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 65,
      "content": "list\n\ntuple\n\ns.count(e)\n\n\n\n\n\nCount occurrences of an element\n\ns.__delitem__(p)\n\n\n\nRemove item at position p\n\ns.extend(it)\n\n\n\nAppend items from iterable it\n\ns.__getitem__(p)\n\n\n\n\n\ns[p]—get item at position\n\ns.__getnewargs__()\n\n\n\nSupport for optimized serialization with pickle\n\ns.index(e)\n\n\n\n\n\nFind position of first occurrence of e\n\ns.insert(p, e)\n\n\n\nInsert element e before the item at position p\n\ns.__iter__()\n\n\n\n\n\nGet iterator\n\ns.__len__()\n\n\n\n\n\nlen(s)—number of items\n\ns.__mul__(n)\n\n\n\n\n\ns * n—repeated concatenation\n\ns.__imul__(n)\n\ns.__rmul__(n)\n\n\n\n\n\n\n\ns *= n—in-place repeated concatenation n * s—reversed repeated concatenationa\n\ns.pop([p])\n\n\n\nRemove and return last item or item at optional position p\n\ns.remove(e)\n\n\n\nRemove first occurrence of element e by value\n\ns.reverse()\n\n\n\nReverse the order of the items in place\n\ns.__reversed__()\n\n\n\nGet iterator to scan items from last to first\n\ns.__setitem__(p, e)\n\n\n\ns[p] = e—put e in position p, overwriting existing itemb\n\ns.sort([key], [reverse]) ●\n\nSort items in place with optional keyword arguments key and reverse\n\na Reversed operators are explained in Chapter 16. b Also used to overwrite a subsequence. See “Assigning to Slices” on page 50.\n\nNow let’s switch to an important subject for idiomatic Python programming: tuple, list, and iterable unpacking.\n\nUnpacking Sequences and Iterables Unpacking is important because it avoids unnecessary and error-prone use of indexes to extract elements from sequences. Also, unpacking works with any iterable object as the data source—including iterators, which don’t support index notation ([]). The only requirement is that the iterable yields exactly one item per variable in the receiving end, unless you use a star (*) to capture excess items, as explained in “Using * to Grab Excess Items” on page 36.\n\nThe most visible form of unpacking is parallel assignment; that is, assigning items from an iterable to a tuple of variables, as you can see in this example:\n\n>>> lax_coordinates = (33.9425, -118.408056) >>> latitude, longitude = lax_coordinates # unpacking >>> latitude\n\nUnpacking Sequences and Iterables\n\n|\n\n35",
      "content_length": 2119,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 66,
      "content": "33.9425 >>> longitude -118.408056\n\nAn elegant application of unpacking is swapping the values of variables without using a temporary variable:\n\n>>> b, a = a, b\n\nAnother example of unpacking is prefixing an argument with * when calling a function:\n\n>>> divmod(20, 8) (2, 4) >>> t = (20, 8) >>> divmod(*t) (2, 4) >>> quotient, remainder = divmod(*t) >>> quotient, remainder (2, 4)\n\nThe preceding code shows another use of unpacking: allowing functions to return multiple values in a way that is convenient to the caller. As another example, the os.path.split() function builds a tuple (path, last_part) from a filesystem path:\n\n>>> import os >>> _, filename = os.path.split('/home/luciano/.ssh/id_rsa.pub') >>> filename 'id_rsa.pub'\n\nAnother way of using just some of the items when unpacking is to use the * syntax, as we’ll see right away.\n\nUsing * to Grab Excess Items Defining function parameters with *args to grab arbitrary excess arguments is a classic Python feature.\n\nIn Python 3, this idea was extended to apply to parallel assignment as well:\n\n>>> a, b, *rest = range(5) >>> a, b, rest (0, 1, [2, 3, 4]) >>> a, b, *rest = range(3) >>> a, b, rest (0, 1, [2]) >>> a, b, *rest = range(2) >>> a, b, rest (0, 1, [])\n\nIn the context of parallel assignment, the * prefix can be applied to exactly one vari‐ able, but it can appear in any position:\n\n36\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1390,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 67,
      "content": ">>> a, *body, c, d = range(5) >>> a, body, c, d (0, [1, 2], 3, 4) >>> *head, b, c, d = range(5) >>> head, b, c, d ([0, 1], 2, 3, 4)\n\nUnpacking with * in Function Calls and Sequence Literals PEP 448—Additional Unpacking Generalizations introduced more flexible syntax for iterable unpacking, best summarized in “What’s New In Python 3.5”.\n\nIn function calls, we can use * multiple times:\n\n>>> def fun(a, b, c, d, *rest): ... return a, b, c, d, rest ... >>> fun(*[1, 2], 3, *range(4, 7)) (1, 2, 3, 4, (5, 6))\n\nThe * can also be used when defining list, tuple, or set literals, as shown in these examples from “What’s New In Python 3.5”:\n\n>>> *range(4), 4 (0, 1, 2, 3, 4) >>> [*range(4), 4] [0, 1, 2, 3, 4] >>> {*range(4), 4, *(5, 6, 7)} {0, 1, 2, 3, 4, 5, 6, 7}\n\nPEP 448 introduced similar new syntax for **, which we’ll see in “Unpacking Map‐ pings” on page 80.\n\nFinally, a powerful feature of tuple unpacking is that it works with nested structures.\n\nNested Unpacking The target of an unpacking can use nesting, e.g., (a, b, (c, d)). Python will do the right thing if the value has the same nesting structure. Example 2-8 shows nested unpacking in action.\n\nExample 2-8. Unpacking nested tuples to access the longitude\n\nmetro_areas = [ ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)), ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)), ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)), ]\n\nUnpacking Sequences and Iterables\n\n|\n\n37",
      "content_length": 1552,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 68,
      "content": "def main(): print(f'{\"\":15} | {\"latitude\":>9} | {\"longitude\":>9}') for name, _, _, (lat, lon) in metro_areas: if lon <= 0: print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')\n\nif __name__ == '__main__': main()\n\nEach tuple holds a record with four fields, the last of which is a coordinate pair.\n\nBy assigning the last field to a nested tuple, we unpack the coordinates.\n\nThe lon <= 0: test selects only cities in the Western hemisphere.\n\nThe output of Example 2-8 is:\n\n| latitude | longitude Mexico City | 19.4333 | -99.1333 New York-Newark | 40.8086 | -74.0204 São Paulo | -23.5478 | -46.6358\n\nThe target of an unpacking assignment can also be a list, but good use cases are rare. Here is the only one I know: if you have a database query that returns a single record (e.g., the SQL code has a LIMIT 1 clause), then you can unpack and at the same time make sure there’s only one result with this code:\n\n>>> [record] = query_returning_single_row()\n\nIf the record has only one field, you can get it directly, like this:\n\n>>> [[field]] = query_returning_single_row_with_single_field()\n\nBoth of these could be written with tuples, but don’t forget the syntax quirk that single-item tuples must be written with a trailing comma. So the first target would be (record,) and the second ((field,),). In both cases you get a silent bug if you for‐ get a comma.3\n\nNow let’s study pattern matching, which supports even more powerful ways to unpack sequences.\n\nPattern Matching with Sequences The most visible new feature in Python 3.10 is pattern matching with the match/case statement proposed in PEP 634—Structural Pattern Matching: Specification.\n\n3 Thanks to tech reviewer Leonardo Rochael for this example.\n\n38\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1735,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 69,
      "content": "Python core developer Carol Willing wrote the excellent introduc‐ tion to pattern matching in the “Structural Pattern Matching” sec‐ tion of “What’s New In Python 3.10”. You may want to read that quick overview. In this book, I chose to split the coverage of pat‐ tern matching over different chapters, depending on the pattern types: “Pattern Matching with Mappings” on page 81 and “Pattern Matching Class Instances” on page 192. An extended example is in “Pattern Matching in lis.py: A Case Study” on page 669.\n\nHere is a first example of match/case handling sequences. Imagine you are designing a robot that accepts commands sent as sequences of words and numbers, like BEEPER 440 3. After splitting into parts and parsing the numbers, you’d have a message like ['BEEPER', 440, 3]. You could use a method like this to handle such messages:\n\nExample 2-9. Method from an imaginary Robot class\n\ndef handle_command(self, message): match message: case ['BEEPER', frequency, times]: self.beep(times, frequency) case ['NECK', angle]: self.rotate_neck(angle) case ['LED', ident, intensity]: self.leds[ident].set_brightness(ident, intensity) case ['LED', ident, red, green, blue]: self.leds[ident].set_color(ident, red, green, blue) case _: raise InvalidCommand(message)\n\nThe expression after the match keyword is the subject. The subject is the data that Python will try to match to the patterns in each case clause.\n\nThis pattern matches any subject that is a sequence with three items. The first item must be the string 'BEEPER'. The second and third item can be anything, and they will be bound to the variables frequency and times, in that order.\n\nThis matches any subject with two items, the first being 'NECK'.\n\nThis will match a subject with three items starting with 'LED'. If the number of items does not match, Python proceeds to the next case.\n\nAnother sequence pattern starting with 'LED', now with five items—including the 'LED' constant.\n\nPattern Matching with Sequences\n\n|\n\n39",
      "content_length": 1986,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 70,
      "content": "This is the default case. It will match any subject that did not match a previous pattern. The _ variable is special, as we’ll soon see.\n\nOn the surface, match/case may look like the switch/case statement from the C lan‐ guage—but that’s only half the story.4 One key improvement of match over switch is destructuring—a more advanced form of unpacking. Destructuring is a new word in the Python vocabulary, but it is commonly used in the documentation of languages that support pattern matching—like Scala and Elixir.\n\nAs a first example of destructuring, Example 2-10 shows part of Example 2-8 rewrit‐ ten with match/case.\n\nExample 2-10. Destructuring nested tuples—requires Python ≥ 3.10\n\nmetro_areas = [ ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)), ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)), ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)), ]\n\ndef main(): print(f'{\"\":15} | {\"latitude\":>9} | {\"longitude\":>9}') for record in metro_areas: match record: case [name, _, _, (lat, lon)] if lon <= 0: print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')\n\nThe subject of this match is record— i.e., each of the tuples in metro_areas.\n\nA case clause has two parts: a pattern and an optional guard with the if keyword.\n\nIn general, a sequence pattern matches the subject if:\n\n1. The subject is a sequence and;\n\n2. The subject and the pattern have the same number of items and;\n\n3. Each corresponding item matches, including nested items.\n\n4 In my view, a sequence of if/elif/elif/.../else blocks is a fine replacement for switch/case. It doesn’t\n\nsuffer from the fallthrough and dangling else problems that some language designers irrationally copied from C—decades after they were widely known as the cause of countless bugs.\n\n40\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1891,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 71,
      "content": "For example, the pattern [name, _, _, (lat, lon)] in Example 2-10 matches a sequence with four items, and the last item must be a two-item sequence.\n\nSequence patterns may be written as tuples or lists or any combination of nested tuples and lists, but it makes no difference which syntax you use: in a sequence pat‐ tern, square brackets and parentheses mean the same thing. I wrote the pattern as a list with a nested 2-tuple just to avoid repeating brackets or parentheses in Example 2-10.\n\nA sequence pattern can match instances of most actual or virtual subclasses of collec tions.abc.Sequence, with the exception of str, bytes, and bytearray.\n\nInstances of str, bytes, and bytearray are not handled as sequen‐ ces in the context of match/case. A match subject of one of those types is treated as an “atomic” value—like the integer 987 is treated as one value, not a sequence of digits. Treating those three types as sequences could cause bugs due to unintended matches. If you want to treat an object of those types as a sequence subject, convert it in the match clause. For example, see tuple(phone) in the following:\n\nmatch tuple(phone): case ['1', *rest]: # North America and Caribbean ... case ['2', *rest]: # Africa and some territories ... case ['3' | '4', *rest]: # Europe ...\n\nIn the standard library, these types are compatible with sequence patterns:\n\nlist memoryview array.array tuple range collections.deque\n\nUnlike unpacking, patterns don’t destructure iterables that are not sequences (such as iterators).\n\nThe _ symbol is special in patterns: it matches any single item in that position, but it is never bound to the value of the matched item. Also, the _ is the only variable that can appear more than once in a pattern.\n\nYou can bind any part of a pattern with a variable using the as keyword:\n\ncase [name, _, _, (lat, lon) as coord]:\n\nGiven the subject ['Shanghai', 'CN', 24.9, (31.1, 121.3)], the preceding pat‐ tern will match, and set the following variables:\n\nPattern Matching with Sequences\n\n|\n\n41",
      "content_length": 2026,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 72,
      "content": "Variable\n\nSet Value\n\nname\n\n'Shanghai'\n\nlat\n\n31.1\n\nlon\n\n121.3\n\ncoord\n\n(31.1, 121.3)\n\nWe can make patterns more specific by adding type information. For example, the following pattern matches the same nested sequence structure as the previous exam‐ ple, but the first item must be an instance of str, and both items in the 2-tuple must be instances of float:\n\ncase [str(name), _, _, (float(lat), float(lon))]:\n\nThe expressions str(name) and float(lat) look like constructor calls, which we’d use to convert name and lat to str and float. But in the context of a pattern, that syntax performs a runtime type check: the preceding pattern will match a four-item sequence in which item 0 must be a str, and item 3 must be a pair of floats. Additionally, the str in item 0 will be bound to the name variable, and the floats in item 3 will be bound to lat and lon, respectively. So, although str(name) borrows the syntax of a constructor call, the semantics are completely different in the context of a pattern. Using arbitrary classes in patterns is covered in “Pattern Matching Class Instances” on page 192.\n\nOn the other hand, if we want to match any subject sequence starting with a str, and ending with a nested sequence of two floats, we can write:\n\ncase [str(name), *_, (float(lat), float(lon))]:\n\nThe *_ matches any number of items, without binding them to a variable. Using *extra instead of *_ would bind the items to extra as a list with 0 or more items.\n\nThe optional guard clause starting with if is evaluated only if the pattern matches, and can reference variables bound in the pattern, as in Example 2-10:\n\nmatch record: case [name, _, _, (lat, lon)] if lon <= 0: print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')\n\nThe nested block with the print statement runs only if the pattern matches and the guard expression is truthy.\n\n42\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1870,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 73,
      "content": "Destructuring with patterns is so expressive that sometimes a match with a single case can make code simpler. Guido van Ros‐ sum has a collection of case/match examples, including one that he titled “A very deep iterable and type match with extraction”.\n\nExample 2-10 is not an improvement over Example 2-8. It’s just an example to con‐ trast two ways of doing the same thing. The next example shows how pattern match‐ ing contributes to clear, concise, and effective code.\n\nPattern Matching Sequences in an Interpreter Peter Norvig of Stanford University wrote lis.py: an interpreter for a subset of the Scheme dialect of the Lisp programming language in 132 lines of beautiful and reada‐ ble Python code. I took Norvig’s MIT-licensed source and updated it to Python 3.10 to showcase pattern matching. In this section, we’ll compare a key part of Norvig’s code—which uses if/elif and unpacking—with a rewrite using match/case.\n\nThe two main functions of lis.py are parse and evaluate.5 The parser takes Scheme parenthesized expressions and returns Python lists. Here are two examples:\n\n>>> parse('(gcd 18 45)') ['gcd', 18, 45] >>> parse(''' ... (define double ... (lambda (n) ... (* n 2))) ... ''') ['define', 'double', ['lambda', ['n'], ['*', 'n', 2]]]\n\nThe evaluator takes lists like these and executes them. The first example is calling a gcd function with 18 and 45 as arguments. When evaluated, it computes the greatest common divisor of the arguments: 9. The second example is defining a function named double with a parameter n. The body of the function is the expression (* n 2). The result of calling a function in Scheme is the value of the last expression in its body.\n\nOur focus here is destructuring sequences, so I will not explain the evaluator actions. See “Pattern Matching in lis.py: A Case Study” on page 669 to learn more about how lis.py works.\n\nExample 2-11 shows Norvig’s evaluator with minor changes, abbreviated to show only the sequence patterns.\n\n5 The latter is named eval in Norvig’s code; I renamed it to avoid confusion with Python’s eval built-in.\n\nPattern Matching with Sequences\n\n|\n\n43",
      "content_length": 2120,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 74,
      "content": "Example 2-11. Matching patterns without match/case\n\ndef evaluate(exp: Expression, env: Environment) -> Any: \"Evaluate an expression in an environment.\" if isinstance(exp, Symbol): # variable reference return env[exp] # ... lines omitted elif exp[0] == 'quote': # (quote exp) (_, x) = exp return x elif exp[0] == 'if': # (if test conseq alt) (_, test, consequence, alternative) = exp if evaluate(test, env): return evaluate(consequence, env) else: return evaluate(alternative, env) elif exp[0] == 'lambda': # (lambda (parm…) body…) (_, parms, *body) = exp return Procedure(parms, body, env) elif exp[0] == 'define': (_, name, value_exp) = exp env[name] = evaluate(value_exp, env) # ... more lines omitted\n\nNote how each elif clause checks the first item of the list, and then unpacks the list, ignoring the first item. The extensive use of unpacking suggests that Norvig is a fan of pattern matching, but he wrote that code originally for Python 2 (though it now works with any Python 3).\n\nUsing match/case in Python ≥ 3.10, we can refactor evaluate as shown in Example 2-12.\n\nExample 2-12. Pattern matching with match/case—requires Python ≥ 3.10\n\ndef evaluate(exp: Expression, env: Environment) -> Any: \"Evaluate an expression in an environment.\" match exp: # ... lines omitted case ['quote', x]: return x case ['if', test, consequence, alternative]: if evaluate(test, env): return evaluate(consequence, env) else: return evaluate(alternative, env) case ['lambda', [*parms], *body] if body: return Procedure(parms, body, env) case ['define', Symbol() as name, value_exp]: env[name] = evaluate(value_exp, env) # ... more lines omitted\n\n44\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1674,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 75,
      "content": "case _: raise SyntaxError(lispstr(exp))\n\nMatch if subject is a two-item sequence starting with 'quote'.\n\nMatch if subject is a four-item sequence starting with 'if'.\n\nMatch if subject is a sequence of three or more items starting with 'lambda'. The guard ensures that body is not empty.\n\nMatch if subject is a three-item sequence starting with 'define', followed by an instance of Symbol.\n\nIt is good practice to have a catch-all case. In this example, if exp doesn’t match any of the patterns, the expression is malformed, and I raise SyntaxError.\n\nWithout a catch-all, the whole match statement does nothing when a subject does not match any case—and this can be a silent failure.\n\nNorvig deliberately avoided error checking in lis.py to keep the code easy to under‐ stand. With pattern matching, we can add more checks and still keep it readable. For example, in the 'define' pattern, the original code does not ensure that name is an instance of Symbol—that would require an if block, an isinstance call, and more code. Example 2-12 is shorter and safer than Example 2-11.\n\nAlternative patterns for lambda\n\nThis is the syntax of lambda in Scheme, using the syntactic convention that the suffix … means the element may appear zero or more times:\n\n(lambda (parms…) body1 body2…)\n\nA simple pattern for the lambda case 'lambda' would be this:\n\ncase ['lambda', parms, *body] if body:\n\nHowever, that matches any value in the parms position, including the first 'x' in this invalid subject:\n\n['lambda', 'x', ['*', 'x', 2]]\n\nThe nested list after the lambda keyword in Scheme holds the names of the formal parameters for the function, and it must be a list even if it has only one element. It may also be an empty list, if the function takes no parameters—like Python’s ran dom.random().\n\nIn Example 2-12, I made the 'lambda' pattern safer using a nested sequence pattern:\n\nPattern Matching with Sequences\n\n|\n\n45",
      "content_length": 1908,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 76,
      "content": "case ['lambda', [*parms], *body] if body: return Procedure(parms, body, env)\n\nIn a sequence pattern, * can appear only once per sequence. Here we have two sequences: the outer and the inner.\n\nAdding the characters [*] around parms made the pattern look more like the Scheme syntax it handles, and gave us an additional structural check.\n\nShortcut syntax for function definition\n\nScheme has an alternative define syntax to create a named function without using a nested lambda. This is the syntax:\n\n(define (name parm…) body1 body2…)\n\nThe define keyword is followed by a list with the name of the new function and zero or more parameter names. After that list comes the function body with one or more expressions.\n\nAdding these two lines to the match takes care of the implementation:\n\ncase ['define', [Symbol() as name, *parms], *body] if body: env[name] = Procedure(parms, body, env)\n\nI’d place that case after the other define case in Example 2-12. The order between the define cases is irrelevant in this example because no subject can match both of these patterns: the second element must be a Symbol in the original define case, but it must be a sequence starting with a Symbol in the define shortcut for function definition.\n\nNow consider how much work we’d have adding support for this second define syn‐ tax without the help of pattern matching in Example 2-11. The match statement does a lot more than the switch in C-like languages.\n\nPattern matching is an example of declarative programming: the code describes “what” you want to match, instead of “how” to match it. The shape of the code fol‐ lows the shape of the data, as Table 2-2 illustrates.\n\nTable 2-2. Some Scheme syntactic forms and case patterns to handle them\n\nScheme syntax\n\nSequence pattern\n\n(quote exp)\n\n['quote', exp]\n\n(if test conseq alt)\n\n['if', test, conseq, alt]\n\n(lambda (parms…) body1 body2…)\n\n['lambda', [*parms], *body] if body\n\n(define name exp)\n\n['define', Symbol() as name, exp]\n\n(define (name parms…) body1 body2…)\n\n['define', [Symbol() as name, *parms], *body] if body\n\n46\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 2098,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 77,
      "content": "I hope this refactoring of Norvig’s evaluate with pattern matching convinced you that match/case can make your code more readable and safer.\n\nWe’ll see more of lis.py in “Pattern Matching in lis.py: A Case Study” on page 669, when we’ll review the complete match/case example in evaluate. If you want to learn more about Norvig’s lis.py, read his wonderful post “(How to Write a (Lisp) Interpreter (in Python))”.\n\nThis concludes our first tour of unpacking, destructuring, and pattern matching with sequences. We’ll cover other types of patterns in later chapters.\n\nEvery Python programmer knows that sequences can be sliced using the s[a:b] syn‐ tax. We now turn to some less well-known facts about slicing.\n\nSlicing A common feature of list, tuple, str, and all sequence types in Python is the sup‐ port of slicing operations, which are more powerful than most people realize.\n\nIn this section, we describe the use of these advanced forms of slicing. Their imple‐ mentation in a user-defined class will be covered in Chapter 12, in keeping with our philosophy of covering ready-to-use classes in this part of the book, and creating new classes in Part III.\n\nWhy Slices and Ranges Exclude the Last Item The Pythonic convention of excluding the last item in slices and ranges works well with the zero-based indexing used in Python, C, and many other languages. Some convenient features of the convention are:\n\nIt’s easy to see the length of a slice or range when only the stop position is given: range(3) and my_list[:3] both produce three items.\n\nIt’s easy to compute the length of a slice or range when start and stop are given: just subtract stop - start.\n\nIt’s easy to split a sequence in two parts at any index x, without overlapping: sim‐ ply get my_list[:x] and my_list[x:]. For example:\n\n>>> l = [10, 20, 30, 40, 50, 60] >>> l[:2] # split at 2 [10, 20] >>> l[2:] [30, 40, 50, 60] >>> l[:3] # split at 3 [10, 20, 30]\n\nSlicing\n\n|\n\n47",
      "content_length": 1939,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 78,
      "content": ">>> l[3:] [40, 50, 60]\n\nThe best arguments for this convention were written by the Dutch computer scientist Edsger W. Dijkstra (see the last reference in “Further Reading” on page 71).\n\nNow let’s take a close look at how Python interprets slice notation.\n\nSlice Objects This is no secret, but worth repeating just in case: s[a:b:c] can be used to specify a stride or step c, causing the resulting slice to skip items. The stride can also be nega‐ tive, returning items in reverse. Three examples make this clear:\n\n>>> s = 'bicycle' >>> s[::3] 'bye' >>> s[::-1] 'elcycib' >>> s[::-2] 'eccb'\n\nAnother example was shown in Chapter 1 when we used deck[12::13] to get all the aces in the unshuffled deck:\n\n>>> deck[12::13] [Card(rank='A', suit='spades'), Card(rank='A', suit='diamonds'), Card(rank='A', suit='clubs'), Card(rank='A', suit='hearts')]\n\nThe notation a:b:c is only valid within [] when used as the indexing or subscript operator, and it produces a slice object: slice(a, b, c). As we will see in “How Slic‐ ing Works” on page 404, to evaluate the expression seq[start:stop:step], Python calls seq.__getitem__(slice(start, stop, step)). Even if you are not imple‐ menting your own sequence types, knowing about slice objects is useful because it lets you assign names to slices, just like spreadsheets allow naming of cell ranges.\n\nSuppose you need to parse flat-file data like the invoice shown in Example 2-13. Instead of filling your code with hardcoded slices, you can name them. See how read‐ able this makes the for loop at the end of the example.\n\nExample 2-13. Line items from a flat-file invoice\n\n>>> invoice = \"\"\" ... 0.....6.................................40........52...55........ ... 1909 Pimoroni PiBrella $17.50 3 $52.50 ... 1489 6mm Tactile Switch x20 $4.95 2 $9.90 ... 1510 Panavise Jr. - PV-201 $28.00 1 $28.00 ... 1601 PiTFT Mini Kit 320x240 $34.95 1 $34.95 ... \"\"\"\n\n48\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1932,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 79,
      "content": ">>> SKU = slice(0, 6) >>> DESCRIPTION = slice(6, 40) >>> UNIT_PRICE = slice(40, 52) >>> QUANTITY = slice(52, 55) >>> ITEM_TOTAL = slice(55, None) >>> line_items = invoice.split('\\n')[2:] >>> for item in line_items: ... print(item[UNIT_PRICE], item[DESCRIPTION]) ... $17.50 Pimoroni PiBrella $4.95 6mm Tactile Switch x20 $28.00 Panavise Jr. - PV-201 $34.95 PiTFT Mini Kit 320x240\n\nWe’ll come back to slice objects when we discuss creating your own collections in “Vector Take #2: A Sliceable Sequence” on page 403. Meanwhile, from a user perspec‐ tive, slicing includes additional features such as multidimensional slices and ellipsis (...) notation. Read on.\n\nMultidimensional Slicing and Ellipsis The [] operator can also take multiple indexes or slices separated by commas. The __getitem__ and __setitem__ special methods that handle the [] operator simply receive the indices in a[i, j] as a tuple. In other words, to evaluate a[i, j], Python calls a.__getitem__((i, j)).\n\nThis is used, for instance, in the external NumPy package, where items of a two- dimensional numpy.ndarray can be fetched using the syntax a[i, j] and a two-dimensional slice obtained with an expression like a[m:n, k:l]. Example 2-22 later in this chapter shows the use of this notation.\n\nExcept for memoryview, the built-in sequence types in Python are one-dimensional, so they support only one index or slice, and not a tuple of them.6\n\nThe ellipsis—written with three full stops (...) and not … (Unicode U+2026)—is rec‐ ognized as a token by the Python parser. It is an alias to the Ellipsis object, the sin‐ gle instance of the ellipsis class.7 As such, it can be passed as an argument to functions and as part of a slice specification, as in f(a, ..., z) or a[i:...]. NumPy uses ... as a shortcut when slicing arrays of many dimensions; for example,\n\n6 In “Memory Views” on page 62 we show that specially constructed memory views can have more than one\n\ndimension.\n\n7 No, I did not get this backwards: the ellipsis class name is really all lowercase, and the instance is a built-in\n\nnamed Ellipsis, just like bool is lowercase but its instances are True and False.\n\nSlicing\n\n|\n\n49",
      "content_length": 2161,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 80,
      "content": "if x is a four-dimensional array, x[i, ...] is a shortcut for x[i, :, :, :,]. See “NumPy quickstart” to learn more about this.\n\nAt the time of this writing, I am unaware of uses of Ellipsis or multidimensional indexes and slices in the Python standard library. If you spot one, let me know. These syntactic features exist to support user-defined types and extensions such as NumPy.\n\nSlices are not just useful to extract information from sequences; they can also be used to change mutable sequences in place—that is, without rebuilding them from scratch.\n\nAssigning to Slices Mutable sequences can be grafted, excised, and otherwise modified in place using slice notation on the lefthand side of an assignment statement or as the target of a del statement. The next few examples give an idea of the power of this notation:\n\n>>> l = list(range(10)) >>> l [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> l[2:5] = [20, 30] >>> l [0, 1, 20, 30, 5, 6, 7, 8, 9] >>> del l[5:7] >>> l [0, 1, 20, 30, 5, 8, 9] >>> l[3::2] = [11, 22] >>> l [0, 1, 20, 11, 5, 22, 9] >>> l[2:5] = 100 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can only assign an iterable >>> l[2:5] = [100] >>> l [0, 1, 100, 22, 9]\n\nWhen the target of the assignment is a slice, the righthand side must be an itera‐ ble object, even if it has just one item.\n\nEvery coder knows that concatenation is a common operation with sequences. Intro‐ ductory Python tutorials explain the use of + and * for that purpose, but there are some subtle details on how they work, which we cover next.\n\nUsing + and * with Sequences Python programmers expect that sequences support + and *. Usually both operands of + must be of the same sequence type, and neither of them is modified, but a new sequence of that same type is created as result of the concatenation.\n\n50\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1868,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 81,
      "content": "To concatenate multiple copies of the same sequence, multiply it by an integer. Again, a new sequence is created:\n\n>>> l = [1, 2, 3] >>> l * 5 [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] >>> 5 * 'abcd' 'abcdabcdabcdabcdabcd'\n\nBoth + and * always create a new object, and never change their operands.\n\nBeware of expressions like a * n when a is a sequence containing mutable items, because the result may surprise you. For example, trying to initialize a list of lists as my_list = [[]] * 3 will result in a list with three references to the same inner list, which is proba‐ bly not what you want.\n\nThe next section covers the pitfalls of trying to use * to initialize a list of lists.\n\nBuilding Lists of Lists Sometimes we need to initialize a list with a certain number of nested lists—for example, to distribute students in a list of teams or to represent squares on a game board. The best way of doing so is with a list comprehension, as in Example 2-14.\n\nExample 2-14. A list with three lists of length 3 can represent a tic-tac-toe board\n\n>>> board = [['_'] * 3 for i in range(3)] >>> board [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']] >>> board[1][2] = 'X' >>> board [['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]\n\nCreate a list of three lists of three items each. Inspect the structure.\n\nPlace a mark in row 1, column 2, and check the result.\n\nA tempting, but wrong, shortcut is doing it like Example 2-15.\n\nExample 2-15. A list with three references to the same list is useless\n\n>>> weird_board = [['_'] * 3] * 3 >>> weird_board [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']] >>> weird_board[1][2] = 'O'\n\nUsing + and * with Sequences\n\n|\n\n51",
      "content_length": 1667,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 82,
      "content": ">>> weird_board [['_', '_', 'O'], ['_', '_', 'O'], ['_', '_', 'O']]\n\nThe outer list is made of three references to the same inner list. While it is unchanged, all seems right.\n\nPlacing a mark in row 1, column 2, reveals that all rows are aliases referring to the same object.\n\nThe problem with Example 2-15 is that, in essence, it behaves like this code:\n\nrow = ['_'] * 3 board = [] for i in range(3): board.append(row)\n\nThe same row is appended three times to board.\n\nOn the other hand, the list comprehension from Example 2-14 is equivalent to this code:\n\n>>> board = [] >>> for i in range(3): ... row = ['_'] * 3 ... board.append(row) ... >>> board [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']] >>> board[2][0] = 'X' >>> board [['_', '_', '_'], ['_', '_', '_'], ['X', '_', '_']]\n\nEach iteration builds a new row and appends it to board.\n\nOnly row 2 is changed, as expected.\n\nIf either the problem or the solution in this section is not clear to you, relax. Chapter 6 was written to clarify the mechanics and pit‐ falls of references and mutable objects.\n\nSo far we have discussed the use of the plain + and * operators with sequences, but there are also the += and *= operators, which produce very different results, depend‐ ing on the mutability of the target sequence. The following section explains how that works.\n\n52\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1367,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 83,
      "content": "Augmented Assignment with Sequences The augmented assignment operators += and *= behave quite differently, depending on the first operand. To simplify the discussion, we will focus on augmented addition first (+=), but the concepts also apply to *= and to other augmented assignment operators.\n\nThe special method that makes += work is __iadd__ (for “in-place addition”).\n\nHowever, if __iadd__ is not implemented, Python falls back to calling __add__. Con‐ sider this simple expression:\n\n>>> a += b\n\nIf a implements __iadd__, that will be called. In the case of mutable sequences (e.g., list, bytearray, array.array), a will be changed in place (i.e., the effect will be sim‐ ilar to a.extend(b)). However, when a does not implement __iadd__, the expression a += b has the same effect as a = a + b: the expression a + b is evaluated first, producing a new object, which is then bound to a. In other words, the identity of the object bound to a may or may not change, depending on the availability of __iadd__.\n\nIn general, for mutable sequences, it is a good bet that __iadd__ is implemented and that += happens in place. For immutable sequences, clearly there is no way for that to happen.\n\nWhat I just wrote about += also applies to *=, which is implemented via __imul__. The __iadd__ and __imul__ special methods are discussed in Chapter 16. Here is a demonstration of *= with a mutable sequence and then an immutable one:\n\n>>> l = [1, 2, 3] >>> id(l) 4311953800 >>> l *= 2 >>> l [1, 2, 3, 1, 2, 3] >>> id(l) 4311953800 >>> t = (1, 2, 3) >>> id(t) 4312681568 >>> t *= 2 >>> id(t) 4301348296\n\nID of the initial list.\n\nAfter multiplication, the list is the same object, with new items appended.\n\nUsing + and * with Sequences\n\n|\n\n53",
      "content_length": 1732,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 84,
      "content": "ID of the initial tuple.\n\nAfter multiplication, a new tuple was created.\n\nRepeated concatenation of immutable sequences is inefficient, because instead of just appending new items, the interpreter has to copy the whole target sequence to create a new one with the new items concatenated.8\n\nWe’ve seen common use cases for +=. The next section shows an intriguing corner case that highlights what “immutable” really means in the context of tuples.\n\nA += Assignment Puzzler Try to answer without using the console: what is the result of evaluating the two expressions in Example 2-16?9\n\nExample 2-16. A riddle\n\n>>> t = (1, 2, [30, 40]) >>> t[2] += [50, 60]\n\nWhat happens next? Choose the best answer:\n\nA. t becomes (1, 2, [30, 40, 50, 60]). B. TypeError is raised with the message 'tuple' object does not support item\n\nassignment.\n\nC. Neither.\n\nD. Both A and B.\n\nWhen I saw this, I was pretty sure the answer was B, but it’s actually D, “Both A and B”! Example 2-17 is the actual output from a Python 3.9 console.10\n\n8 str is an exception to this description. Because string building with += in loops is so common in real codeba‐ ses, CPython is optimized for this use case. Instances of str are allocated in memory with extra room, so that concatenation does not require copying the whole string every time.\n\n9 Thanks to Leonardo Rochael and Cesar Kawakami for sharing this riddle at the 2013 PythonBrasil\n\nConference.\n\n10 Readers suggested that the operation in the example can be done with t[2].extend([50,60]), without errors. I am aware of that, but my intent is to show the strange behavior of the += operator in this case.\n\n54\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1668,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 85,
      "content": "Example 2-17. The unexpected result: item t2 is changed and an exception is raised\n\n>>> t = (1, 2, [30, 40]) >>> t[2] += [50, 60] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'tuple' object does not support item assignment >>> t (1, 2, [30, 40, 50, 60])\n\nOnline Python Tutor is an awesome online tool to visualize how Python works in detail. Figure 2-5 is a composite of two screenshots showing the initial and final states of the tuple t from Example 2-17.\n\nFigure 2-5. Initial and final state of the tuple assignment puzzler (diagram generated by Online Python Tutor).\n\nIf you look at the bytecode Python generates for the expression s[a] += b (Example 2-18), it becomes clear how that happens.\n\nExample 2-18. Bytecode for the expression s[a] += b\n\n>>> dis.dis('s[a] += b') 1 0 LOAD_NAME 0 (s) 3 LOAD_NAME 1 (a) 6 DUP_TOP_TWO 7 BINARY_SUBSCR 8 LOAD_NAME 2 (b) 11 INPLACE_ADD 12 ROT_THREE 13 STORE_SUBSCR 14 LOAD_CONST 0 (None) 17 RETURN_VALUE\n\nUsing + and * with Sequences\n\n|\n\n55",
      "content_length": 1018,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 86,
      "content": "Put the value of s[a] on TOS (Top Of Stack).\n\nPerform TOS += b. This succeeds if TOS refers to a mutable object (it’s a list, in Example 2-17).\n\nAssign s[a] = TOS. This fails if s is immutable (the t tuple in Example 2-17).\n\nThis example is quite a corner case—in 20 years using Python, I have never seen this strange behavior actually bite somebody.\n\nI take three lessons from this:\n\nAvoid putting mutable items in tuples.\n\nAugmented assignment is not an atomic operation—we just saw it throwing an exception after doing part of its job.\n\nInspecting Python bytecode is not too difficult, and can be helpful to see what is going on under the hood.\n\nAfter witnessing the subtleties of using + and * for concatenation, we can change the subject to another essential operation with sequences: sorting.\n\nlist.sort Versus the sorted Built-In The list.sort method sorts a list in place—that is, without making a copy. It returns None to remind us that it changes the receiver11 and does not create a new list. This is an important Python API convention: functions or methods that change an object in place should return None to make it clear to the caller that the receiver was changed, and no new object was created. Similar behavior can be seen, for example, in the ran dom.shuffle(s) function, which shuffles the mutable sequence s in place, and returns None.\n\nThe convention of returning None to signal in-place changes has a drawback: we cannot cascade calls to those methods. In contrast, methods that return new objects (e.g., all str methods) can be cas‐ caded in the fluent interface style. See Wikipedia’s “Fluent inter‐ face” entry for further description of this topic.\n\nIn contrast, the built-in function sorted creates a new list and returns it. It accepts any iterable object as an argument, including immutable sequences and generators\n\n11 Receiver is the target of a method call, the object bound to self in the method body.\n\n56\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1976,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 87,
      "content": "(see Chapter 17). Regardless of the type of iterable given to sorted, it always returns a newly created list.\n\nBoth list.sort and sorted take two optional, keyword-only arguments:\n\nreverse\n\nIf True, the items are returned in descending order (i.e., by reversing the compar‐ ison of the items). The default is False.\n\nkey\n\nA one-argument function that will be applied to each item to produce its sorting key. For example, when sorting a list of strings, key=str.lower can be used to perform a case-insensitive sort, and key=len will sort the strings by character length. The default is the identity function (i.e., the items themselves are compared).\n\nYou can also use the optional keyword parameter key with the min() and max() built-ins and with other functions from the stan‐ dard library (e.g., itertools.groupby() and heapq.nlargest()).\n\nHere are a few examples to clarify the use of these functions and keyword arguments. The examples also demonstrate that Python’s sorting algorithm is stable (i.e., it pre‐ serves the relative ordering of items that compare equally):12\n\n>>> fruits = ['grape', 'raspberry', 'apple', 'banana'] >>> sorted(fruits) ['apple', 'banana', 'grape', 'raspberry'] >>> fruits ['grape', 'raspberry', 'apple', 'banana'] >>> sorted(fruits, reverse=True) ['raspberry', 'grape', 'banana', 'apple'] >>> sorted(fruits, key=len) ['grape', 'apple', 'banana', 'raspberry'] >>> sorted(fruits, key=len, reverse=True) ['raspberry', 'banana', 'grape', 'apple'] >>> fruits ['grape', 'raspberry', 'apple', 'banana'] >>> fruits.sort() >>> fruits ['apple', 'banana', 'grape', 'raspberry']\n\n12 Python’s main sorting algorithm is named Timsort after its creator, Tim Peters. For a bit of Timsort trivia, see\n\nthe “Soapbox” on page 73.\n\nlist.sort Versus the sorted Built-In\n\n|\n\n57",
      "content_length": 1788,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 88,
      "content": "This produces a new list of strings sorted alphabetically.13\n\nInspecting the original list, we see it is unchanged.\n\nThis is the previous “alphabetical” ordering, reversed.\n\nA new list of strings, now sorted by length. Because the sorting algorithm is stable, “grape” and “apple,” both of length 5, are in the original order.\n\nThese are the strings sorted by length in descending order. It is not the reverse of the previous result because the sorting is stable, so again “grape” appears before “apple.”\n\nSo far, the ordering of the original fruits list has not changed.\n\nThis sorts the list in place, and returns None (which the console omits).\n\nNow fruits is sorted.\n\nBy default, Python sorts strings lexicographically by character code. That means ASCII uppercase letters will come before lowercase let‐ ters, and non-ASCII characters are unlikely to be sorted in a sensi‐ ble way. “Sorting Unicode Text” on page 148 covers proper ways of sorting text as humans would expect.\n\nOnce your sequences are sorted, they can be very efficiently searched. A binary search algorithm is already provided in the bisect module of the Python standard library. That module also includes the bisect.insort function, which you can use to make sure that your sorted sequences stay sorted. You’ll find an illustrated introduction to the bisect module in the “Managing Ordered Sequences with Bisect” post in the flu‐ entpython.com companion website.\n\nMuch of what we have seen so far in this chapter applies to sequences in general, not just lists or tuples. Python programmers sometimes overuse the list type because it is so handy—I know I’ve done it. For example, if you are processing large lists of numbers, you should consider using arrays instead. The remainder of the chapter is devoted to alternatives to lists and tuples.\n\n13 The words in this example are sorted alphabetically because they are 100% made of lowercase ASCII charac‐\n\nters. See the warning after the example.\n\n58\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 2008,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 89,
      "content": "When a List Is Not the Answer The list type is flexible and easy to use, but depending on specific requirements, there are better options. For example, an array saves a lot of memory when you need to handle millions of floating-point values. On the other hand, if you are constantly adding and removing items from opposite ends of a list, it’s good to know that a deque (double-ended queue) is a more efficient FIFO14 data structure.\n\nIf your code frequently checks whether an item is present in a col‐ lection (e.g., item in my_collection), consider using a set for my_collection, especially if it holds a large number of items. Sets are optimized for fast membership checking. They are also iterable, but they are not sequences because the ordering of set items is unspecified. We cover them in Chapter 3.\n\nFor the remainder of this chapter, we discuss mutable sequence types that can replace lists in many cases, starting with arrays.\n\nArrays If a list only contains numbers, an array.array is a more efficient replacement. Arrays support all mutable sequence operations (including .pop, .insert, and .extend), as well as additional methods for fast loading and saving, such as .frombytes and .tofile.\n\nA Python array is as lean as a C array. As shown in Figure 2-1, an array of float values does not hold full-fledged float instances, but only the packed bytes repre‐ senting their machine values—similar to an array of double in the C language. When creating an array, you provide a typecode, a letter to determine the underlying C type used to store each item in the array. For example, b is the typecode for what C calls a signed char, an integer ranging from –128 to 127. If you create an array('b'), then each item will be stored in a single byte and interpreted as an inte‐ ger. For large sequences of numbers, this saves a lot of memory. And Python will not let you put any number that does not match the type for the array.\n\nExample 2-19 shows creating, saving, and loading an array of 10 million floating- point random numbers.\n\n14 First in, first out—the default behavior of queues.\n\nWhen a List Is Not the Answer\n\n|\n\n59",
      "content_length": 2134,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 90,
      "content": "Example 2-19. Creating, saving, and loading a large array of floats\n\n>>> from array import array >>> from random import random >>> floats = array('d', (random() for i in range(10**7))) >>> floats[-1] 0.07802343889111107 >>> fp = open('floats.bin', 'wb') >>> floats.tofile(fp) >>> fp.close() >>> floats2 = array('d') >>> fp = open('floats.bin', 'rb') >>> floats2.fromfile(fp, 10**7) >>> fp.close() >>> floats2[-1] 0.07802343889111107 >>> floats2 == floats True\n\nImport the array type.\n\nCreate an array of double-precision floats (typecode 'd') from any iterable object —in this case, a generator expression.\n\nInspect the last number in the array.\n\nSave the array to a binary file.\n\nCreate an empty array of doubles.\n\nRead 10 million numbers from the binary file.\n\nInspect the last number in the array.\n\nVerify that the contents of the arrays match.\n\nAs you can see, array.tofile and array.fromfile are easy to use. If you try the example, you’ll notice they are also very fast. A quick experiment shows that it takes about 0.1 seconds for array.fromfile to load 10 million double-precision floats from a binary file created with array.tofile. That is nearly 60 times faster than reading the numbers from a text file, which also involves parsing each line with the float built-in. Saving with array.tofile is about seven times faster than writing one float per line in a text file. In addition, the size of the binary file with 10 million dou‐ bles is 80,000,000 bytes (8 bytes per double, zero overhead), while the text file has 181,515,739 bytes for the same data.\n\n60\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1605,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 91,
      "content": "For the specific case of numeric arrays representing binary data, such as raster images, Python has the bytes and bytearray types discussed in Chapter 4.\n\nWe wrap up this section on arrays with Table 2-3, comparing the features of list and array.array.\n\nTable 2-3. Methods and attributes found in list or array (deprecated array methods and those also implemented by object are omitted for brevity)\n\nlist\n\narray\n\ns.__add__(s2)\n\n\n\n\n\ns + s2—concatenation\n\ns.__iadd__(s2)\n\n\n\n\n\ns += s2—in-place concatenation\n\ns.append(e)\n\n\n\n\n\nAppend one element after last\n\ns.byteswap()\n\n\n\nSwap bytes of all items in array for endianness conversion\n\ns.clear()\n\n\n\nDelete all items\n\ns.__contains__(e)\n\n\n\n\n\ne in s\n\ns.copy()\n\n\n\nShallow copy of the list\n\ns.__copy__()\n\n\n\nSupport for copy.copy\n\ns.count(e)\n\n\n\n\n\nCount occurrences of an element\n\ns.__deepcopy__()\n\n\n\nOptimized support for copy.deepcopy\n\ns.__delitem__(p)\n\n\n\n\n\nRemove item at position p\n\ns.extend(it)\n\n\n\n\n\nAppend items from iterable it\n\ns.frombytes(b)\n\n\n\nAppend items from byte sequence interpreted as packed machine values\n\ns.fromfile(f, n)\n\n\n\nAppend n items from binary file f interpreted as packed machine values\n\ns.fromlist(l)\n\n\n\nAppend items from list; if one causes TypeError, none are appended\n\ns.__getitem__(p)\n\n\n\n\n\ns[p]—get item or slice at position\n\ns.index(e)\n\n\n\n\n\nFind position of first occurrence of e\n\ns.insert(p, e)\n\n\n\n\n\nInsert element e before the item at position p\n\ns.itemsize\n\n\n\nLength in bytes of each array item\n\ns.__iter__()\n\n\n\n\n\nGet iterator\n\ns.__len__()\n\n\n\n\n\nlen(s)—number of items\n\ns.__mul__(n)\n\n\n\n\n\ns * n—repeated concatenation\n\ns.__imul__(n)\n\ns.__rmul__(n)\n\n\n\n\n\n\n\n\n\ns *= n—in-place repeated concatenation n * s—reversed repeated concatenationa\n\ns.pop([p])\n\n\n\n\n\nRemove and return item at position p (default: last)\n\ns.remove(e)\n\n\n\n\n\nRemove first occurrence of element e by value\n\ns.reverse()\n\n\n\n\n\nReverse the order of the items in place\n\ns.__reversed__()\n\n\n\nGet iterator to scan items from last to first\n\ns.__setitem__(p, e)\n\n\n\n\n\ns[p] = e—put e in position p, overwriting existing item or slice\n\nWhen a List Is Not the Answer\n\n|\n\n61",
      "content_length": 2094,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 92,
      "content": "list\n\narray\n\ns.sort([key], [reverse]) ●\n\nSort items in place with optional keyword arguments key and reverse\n\ns.tobytes()\n\n\n\nReturn items as packed machine values in a bytes object\n\ns.tofile(f)\n\n\n\nSave items as packed machine values to binary file f\n\ns.tolist()\n\n\n\nReturn items as numeric objects in a list\n\ns.typecode a Reversed operators are explained in Chapter 16.\n\n\n\nOne-character string identifying the C type of the items\n\nAs of Python 3.10, the array type does not have an in-place sort method like list.sort(). If you need to sort an array, use the built-in sorted function to rebuild the array:\n\na = array.array(a.typecode, sorted(a))\n\nTo keep a sorted array sorted while adding items to it, use the bisect.insort function.\n\nIf you do a lot of work with arrays and don’t know about memoryview, you’re missing out. See the next topic.\n\nMemory Views The built-in memoryview class is a shared-memory sequence type that lets you handle slices of arrays without copying bytes. It was inspired by the NumPy library (which we’ll discuss shortly in “NumPy” on page 64). Travis Oliphant, lead author of NumPy, answers the question, “When should a memoryview be used?” like this:\n\nA memoryview is essentially a generalized NumPy array structure in Python itself (without the math). It allows you to share memory between data-structures (things like PIL images, SQLite databases, NumPy arrays, etc.) without first copying. This is very important for large data sets.\n\nUsing notation similar to the array module, the memoryview.cast method lets you change the way multiple bytes are read or written as units without moving bits around. memoryview.cast returns yet another memoryview object, always sharing the same memory.\n\nExample 2-20 shows how to create alternate views on the same array of 6 bytes, to operate on it as a 2×3 matrix or a 3×2 matrix.\n\nExample 2-20. Handling 6 bytes of memory as 1×6, 2×3, and 3×2 views\n\n>>> from array import array >>> octets = array('B', range(6))\n\n62\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 2023,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 93,
      "content": ">>> m1 = memoryview(octets) >>> m1.tolist() [0, 1, 2, 3, 4, 5] >>> m2 = m1.cast('B', [2, 3]) >>> m2.tolist() [[0, 1, 2], [3, 4, 5]] >>> m3 = m1.cast('B', [3, 2]) >>> m3.tolist() [[0, 1], [2, 3], [4, 5]] >>> m2[1,1] = 22 >>> m3[1,1] = 33 >>> octets array('B', [0, 1, 2, 33, 22, 5])\n\nBuild array of 6 bytes (typecode 'B').\n\nBuild memoryview from that array, then export it as a list.\n\nBuild new memoryview from that previous one, but with 2 rows and 3 columns.\n\nYet another memoryview, now with 3 rows and 2 columns.\n\nOverwrite byte in m2 at row 1, column 1 with 22.\n\nOverwrite byte in m3 at row 1, column 1 with 33.\n\nDisplay original array, proving that the memory was shared among octets, m1, m2, and m3.\n\nThe awesome power of memoryview can also be used to corrupt. Example 2-21 shows how to change a single byte of an item in an array of 16-bit integers.\n\nExample 2-21. Changing the value of a 16-bit integer array item by poking one of its bytes\n\n>>> numbers = array.array('h', [-2, -1, 0, 1, 2]) >>> memv = memoryview(numbers) >>> len(memv) 5 >>> memv[0] -2 >>> memv_oct = memv.cast('B') >>> memv_oct.tolist() [254, 255, 255, 255, 0, 0, 1, 0, 2, 0] >>> memv_oct[5] = 4 >>> numbers array('h', [-2, -1, 1024, 1, 2])\n\nWhen a List Is Not the Answer\n\n|\n\n63",
      "content_length": 1255,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 94,
      "content": "Build memoryview from array of 5 16-bit signed integers (typecode 'h').\n\nmemv sees the same 5 items in the array.\n\nCreate memv_oct by casting the elements of memv to bytes (typecode 'B').\n\nExport elements of memv_oct as a list of 10 bytes, for inspection.\n\nAssign value 4 to byte offset 5.\n\nNote the change to numbers: a 4 in the most significant byte of a 2-byte unsigned integer is 1024.\n\nYou’ll find an example of inspecting memoryview with the struct package at fluentpython.com: “Parsing binary records with struct”.\n\nMeanwhile, if you are doing advanced numeric processing in arrays, you should be using the NumPy libraries. We’ll take a brief look at them right away.\n\nNumPy Throughout this book, I make a point of highlighting what is already in the Python standard library so you can make the most of it. But NumPy is so awesome that a detour is warranted.\n\nFor advanced array and matrix operations, NumPy is the reason why Python became mainstream in scientific computing applications. NumPy implements multi- dimensional, homogeneous arrays and matrix types that hold not only numbers but also user-defined records, and provides efficient element-wise operations.\n\nSciPy is a library, written on top of NumPy, offering many scientific computing algo‐ rithms from linear algebra, numerical calculus, and statistics. SciPy is fast and reliable because it leverages the widely used C and Fortran codebase from the Netlib Reposi‐ tory. In other words, SciPy gives scientists the best of both worlds: an interactive prompt and high-level Python APIs, together with industrial-strength number- crunching functions optimized in C and Fortran.\n\nAs a very brief NumPy demo, Example 2-22 shows some basic operations with two- dimensional arrays.\n\n64\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1787,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 95,
      "content": "Example 2-22. Basic operations with rows and columns in a numpy.ndarray\n\n>>> import numpy as np >>> a = np.arange(12) >>> a array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) >>> type(a) <class 'numpy.ndarray'> >>> a.shape (12,) >>> a.shape = 3, 4 >>> a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) >>> a[2] array([ 8, 9, 10, 11]) >>> a[2, 1] 9 >>> a[:, 1] array([1, 5, 9]) >>> a.transpose() array([[ 0, 4, 8], [ 1, 5, 9], [ 2, 6, 10], [ 3, 7, 11]])\n\nImport NumPy, after installing (it’s not in the Python standard library). Conven‐ tionally, numpy is imported as np.\n\nBuild and inspect a numpy.ndarray with integers 0 to 11.\n\nInspect the dimensions of the array: this is a one-dimensional, 12-element array.\n\nChange the shape of the array, adding one dimension, then inspecting the result.\n\nGet row at index 2.\n\nGet element at index 2, 1.\n\nGet column at index 1.\n\nCreate a new array by transposing (swapping columns with rows).\n\nNumPy also supports high-level operations for loading, saving, and operating on all elements of a numpy.ndarray:\n\n>>> import numpy >>> floats = numpy.loadtxt('floats-10M-lines.txt')\n\nWhen a List Is Not the Answer\n\n|\n\n65",
      "content_length": 1155,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 96,
      "content": ">>> floats[-3:] array([ 3016362.69195522, 535281.10514262, 4566560.44373946]) >>> floats *= .5 >>> floats[-3:] array([ 1508181.34597761, 267640.55257131, 2283280.22186973]) >>> from time import perf_counter as pc >>> t0 = pc(); floats /= 3; pc() - t0 0.03690556302899495 >>> numpy.save('floats-10M', floats) >>> floats2 = numpy.load('floats-10M.npy', 'r+') >>> floats2 *= 6 >>> floats2[-3:] memmap([ 3016362.69195522, 535281.10514262, 4566560.44373946])\n\nLoad 10 million floating-point numbers from a text file.\n\nUse sequence slicing notation to inspect the last three numbers.\n\nMultiply every element in the floats array by .5 and inspect the last three elements again.\n\nImport the high-resolution performance measurement timer (available since Python 3.3).\n\nDivide every element by 3; the elapsed time for 10 million floats is less than 40 milliseconds.\n\nSave the array in a .npy binary file.\n\nLoad the data as a memory-mapped file into another array; this allows efficient processing of slices of the array even if it does not fit entirely in memory.\n\nInspect the last three elements after multiplying every element by 6.\n\nThis was just an appetizer.\n\nNumPy and SciPy are formidable libraries, and are the foundation of other awesome tools such as the Pandas—which implements efficient array types that can hold non‐ numeric data and provides import/export functions for many different formats, like .csv, .xls, SQL dumps, HDF5, etc.—and scikit-learn, currently the most widely used Machine Learning toolset. Most NumPy and SciPy functions are implemented in C or C++, and can leverage all CPU cores because they release Python’s GIL (Global Interpreter Lock). The Dask project supports parallelizing NumPy, Pandas, and scikit-learn processing across clusters of machines. These packages deserve entire books about them. This is not one of those books. But no overview of Python sequen‐ ces would be complete without at least a quick look at NumPy arrays.\n\n66\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1999,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 97,
      "content": "Having looked at flat sequences—standard arrays and NumPy arrays—we now turn to a completely different set of replacements for the plain old list: queues.\n\nDeques and Other Queues The .append and .pop methods make a list usable as a stack or a queue (if you use .append and .pop(0), you get FIFO behavior). But inserting and removing from the head of a list (the 0-index end) is costly because the entire list must be shifted in memory.\n\nThe class collections.deque is a thread-safe double-ended queue designed for fast inserting and removing from both ends. It is also the way to go if you need to keep a list of “last seen items” or something of that nature, because a deque can be bounded —i.e., created with a fixed maximum length. If a bounded deque is full, when you add a new item, it discards an item from the opposite end. Example 2-23 shows some typ‐ ical operations performed on a deque.\n\nExample 2-23. Working with a deque\n\n>>> from collections import deque >>> dq = deque(range(10), maxlen=10) >>> dq deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10) >>> dq.rotate(3) >>> dq deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10) >>> dq.rotate(-4) >>> dq deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10) >>> dq.appendleft(-1) >>> dq deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10) >>> dq.extend([11, 22, 33]) >>> dq deque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10) >>> dq.extendleft([10, 20, 30, 40]) >>> dq deque([40, 30, 20, 10, 3, 4, 5, 6, 7, 8], maxlen=10)\n\nThe optional maxlen argument sets the maximum number of items allowed in this instance of deque; this sets a read-only maxlen instance attribute.\n\nRotating with n > 0 takes items from the right end and prepends them to the left; when n < 0 items are taken from left and appended to the right.\n\nWhen a List Is Not the Answer\n\n|\n\n67",
      "content_length": 1803,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 98,
      "content": "Appending to a deque that is full (len(d) == d.maxlen) discards items from the other end; note in the next line that the 0 is dropped.\n\nAdding three items to the right pushes out the leftmost -1, 1, and 2.\n\nNote that extendleft(iter) works by appending each successive item of the iter argument to the left of the deque, therefore the final position of the items is reversed.\n\nTable 2-4 compares the methods that are specific to list and deque (removing those that also appear in object).\n\nNote that deque implements most of the list methods, and adds a few that are spe‐ cific to its design, like popleft and rotate. But there is a hidden cost: removing items from the middle of a deque is not as fast. It is really optimized for appending and popping from the ends.\n\nThe append and popleft operations are atomic, so deque is safe to use as a FIFO queue in multithreaded applications without the need for locks.\n\nTable 2-4. Methods implemented in list or deque (those that are also implemented by object are omitted for brevity)\n\nlist deque\n\ns.__add__(s2)\n\n\n\ns + s2—concatenation\n\ns.__iadd__(s2)\n\n\n\n\n\ns += s2—in-place concatenation\n\ns.append(e)\n\n\n\n\n\nAppend one element to the right (after last)\n\ns.appendleft(e)\n\n\n\nAppend one element to the left (before first)\n\ns.clear()\n\n\n\n\n\nDelete all items\n\ns.__contains__(e)\n\n\n\ne in s\n\ns.copy()\n\n\n\nShallow copy of the list\n\ns.__copy__()\n\n\n\nSupport for copy.copy (shallow copy)\n\ns.count(e)\n\n\n\n\n\nCount occurrences of an element\n\ns.__delitem__(p)\n\n\n\n\n\nRemove item at position p\n\ns.extend(i)\n\n\n\n\n\nAppend items from iterable i to the right\n\ns.extendleft(i)\n\n\n\nAppend items from iterable i to the left\n\ns.__getitem__(p)\n\n\n\n\n\ns[p]—get item or slice at position\n\ns.index(e)\n\n\n\nFind position of first occurrence of e\n\ns.insert(p, e)\n\n\n\nInsert element e before the item at position p\n\ns.__iter__()\n\n\n\n\n\nGet iterator\n\ns.__len__()\n\n\n\n\n\nlen(s)—number of items\n\n68\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 1926,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 99,
      "content": "list deque\n\ns.__mul__(n)\n\n\n\ns * n—repeated concatenation\n\ns.__imul__(n)\n\ns.__rmul__(n)\n\ns.pop()\n\n\n\n\n\n\n\n\n\ns *= n—in-place repeated concatenation n * s—reversed repeated concatenationa Remove and return last itemb\n\ns.popleft()\n\n\n\nRemove and return first item\n\ns.remove(e)\n\n\n\n\n\nRemove first occurrence of element e by value\n\ns.reverse()\n\n\n\n\n\nReverse the order of the items in place\n\ns.__reversed__()\n\n\n\n\n\nGet iterator to scan items from last to first\n\ns.rotate(n)\n\n\n\nMove n items from one end to the other\n\ns.__setitem__(p, e)\n\n\n\n\n\ns[p] = e—put e in position p, overwriting existing item or slice\n\ns.sort([key], [reverse]) ●\n\nSort items in place with optional keyword arguments key and reverse\n\na Reversed operators are explained in Chapter 16. b a_list.pop(p) allows removing from position p, but deque does not support that option.\n\nBesides deque, other Python standard library packages implement queues:\n\nqueue\n\nThis provides the synchronized (i.e., thread-safe) classes SimpleQueue, Queue, LifoQueue, and PriorityQueue. These can be used for safe communication between threads. All except SimpleQueue can be bounded by providing a max size argument greater than 0 to the constructor. However, they don’t discard items to make room as deque does. Instead, when the queue is full, the insertion of a new item blocks—i.e., it waits until some other thread makes room by taking an item from the queue, which is useful to throttle the number of live threads.\n\nmultiprocessing\n\nImplements its own unbounded SimpleQueue and bounded Queue, very similar to those in the queue package, but designed for interprocess communication. A specialized multiprocessing.JoinableQueue is provided for task management.\n\nasyncio\n\nProvides Queue, LifoQueue, PriorityQueue, and JoinableQueue with APIs inspired by the classes in the queue and multiprocessing modules, but adapted for managing tasks in asynchronous programming.\n\nheapq\n\nIn contrast to the previous three modules, heapq does not implement a queue class, but provides functions like heappush and heappop that let you use a muta‐ ble sequence as a heap queue or priority queue.\n\nWhen a List Is Not the Answer\n\n|\n\n69",
      "content_length": 2155,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 100,
      "content": "This ends our overview of alternatives to the list type, and also our exploration of sequence types in general—except for the particulars of str and binary sequences, which have their own chapter (Chapter 4).\n\nChapter Summary Mastering the standard library sequence types is a prerequisite for writing concise, effective, and idiomatic Python code.\n\nPython sequences are often categorized as mutable or immutable, but it is also useful to consider a different axis: flat sequences and container sequences. The former are more compact, faster, and easier to use, but are limited to storing atomic data such as numbers, characters, and bytes. Container sequences are more flexible, but may sur‐ prise you when they hold mutable objects, so you need to be careful to use them cor‐ rectly with nested data structures.\n\nUnfortunately, Python has no foolproof immutable container sequence type: even “immutable” tuples can have their values changed when they contain mutable items like lists or user-defined objects.\n\nList comprehensions and generator expressions are powerful notations to build and initialize sequences. If you are not yet comfortable with them, take the time to master their basic usage. It is not hard, and soon you will be hooked.\n\nTuples in Python play two roles: as records with unnamed fields and as immutable lists. When using a tuple as an immutable list, remember that a tuple value is only guaranteed to be fixed if all the items in it are also immutable. Calling hash(t) on a tuple is a quick way to assert that its value is fixed. A TypeError will be raised if t contains mutable items.\n\nWhen a tuple is used as a record, tuple unpacking is the safest, most readable way of extracting the fields of the tuple. Beyond tuples, * works with lists and iterables in many contexts, and some of its use cases appeared in Python 3.5 with PEP 448— Additional Unpacking Generalizations. Python 3.10 introduced pattern matching with match/case, supporting more powerful unpacking, known as destructuring.\n\nSequence slicing is a favorite Python syntax feature, and it is even more powerful than many realize. Multidimensional slicing and ellipsis (...) notation, as used in NumPy, may also be supported by user-defined sequences. Assigning to slices is a very expressive way of editing mutable sequences.\n\nRepeated concatenation as in seq * n is convenient and, with care, can be used to initialize lists of lists containing immutable items. Augmented assignment with += and *= behaves differently for mutable and immutable sequences. In the latter case, these operators necessarily build new sequences. But if the target sequence is\n\n70\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 2686,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 101,
      "content": "mutable, it is usually changed in place—but not always, depending on how the sequence is implemented.\n\nThe sort method and the sorted built-in function are easy to use and flexible, thanks to the optional key argument: a function to calculate the ordering criterion. By the way, key can also be used with the min and max built-in functions.\n\nBeyond lists and tuples, the Python standard library provides array.array. Although NumPy and SciPy are not part of the standard library, if you do any kind of numeri‐ cal processing on large sets of data, studying even a small part of these libraries can take you a long way.\n\nWe closed by visiting the versatile and thread-safe collections.deque, comparing its API with that of list in Table 2-4 and mentioning other queue implementations in the standard library.\n\nFurther Reading Chapter 1, “Data Structures,” of the Python Cookbook, 3rd ed. (O’Reilly) by David Beazley and Brian K. Jones, has many recipes focusing on sequences, including “Recipe 1.11. Naming a Slice,” from which I learned the trick of assigning slices to variables to improve readability, illustrated in our Example 2-13.\n\nThe second edition of the Python Cookbook was written for Python 2.4, but much of its code works with Python 3, and a lot of the recipes in Chapters 5 and 6 deal with sequences. The book was edited by Alex Martelli, Anna Ravenscroft, and David Ascher, and it includes contributions by dozens of Pythonistas. The third edition was rewritten from scratch, and focuses more on the semantics of the language—particu‐ larly what has changed in Python 3—while the older volume emphasizes pragmatics (i.e., how to apply the language to real-world problems). Even though some of the second edition solutions are no longer the best approach, I honestly think it is worth‐ while to have both editions of the Python Cookbook on hand.\n\nThe official Python “Sorting HOW TO” has several examples of advanced tricks for using sorted and list.sort.\n\nPEP 3132—Extended Iterable Unpacking is the canonical source to read about the new use of *extra syntax on the lefthand side of parallel assignments. If you’d like a glimpse of Python evolving, “Missing *-unpacking generalizations” is a bug tracker issue proposing enhancements to the iterable unpacking notation. PEP 448—Addi‐ tional Unpacking Generalizations resulted from the discussions in that issue.\n\nFurther Reading\n\n|\n\n71",
      "content_length": 2401,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 102,
      "content": "As I mentioned in “Pattern Matching with Sequences” on page 38, Carol Willing’s “Structural Pattern Matching” section of “What’s New In Python 3.10” is a great introduction to this major new feature in about 1,400 words (that’s less than 5 pages when Firefox makes a PDF from the HTML). PEP 636—Structural Pattern Matching: Tutorial is also good, but longer. The same PEP 636 includes “Appendix A—Quick Intro”. It is shorter than Willing’s intro because it omits high-level considerations about why pattern matching is good for you. If you need more arguments to con‐ vince yourself or others that pattern matching is good for Python, read the 22-page PEP 635—Structural Pattern Matching: Motivation and Rationale.\n\nEli Bendersky’s blog post “Less copies in Python with the buffer protocol and memo‐ ryviews” includes a short tutorial on memoryview.\n\nThere are numerous books covering NumPy in the market, and many don’t mention “NumPy” in the title. Two examples are the open access Python Data Science Hand‐ book by Jake VanderPlas, and the second edition of Wes McKinney’s Python for Data Analysis.\n\n“NumPy is all about vectorization.” That is the opening sentence of Nicolas P. Rou‐ gier’s open access book From Python to NumPy. Vectorized operations apply mathe‐ matical functions to all elements of an array without an explicit loop written in Python. They can operate in parallel, using special vector instructions in modern CPUs, leveraging multiple cores or delegating to the GPU, depending on the library. The first example in Rougier’s book shows a speedup of 500 times after refactoring a nice Pythonic class using a generator method, into a lean and mean function calling a couple of NumPy vector functions.\n\nTo learn how to use deque (and other collections), see the examples and practical rec‐ ipes in “Container datatypes” in the Python documentation.\n\nThe best defense of the Python convention of excluding the last item in ranges and slices was written by Edsger W. Dijkstra himself, in a short memo titled “Why Num‐ bering Should Start at Zero”. The subject of the memo is mathematical notation, but it’s relevant to Python because Dijkstra explains with rigor and humor why a sequence like 2, 3, …, 12 should always be expressed as 2 ≤ i < 13. All other reason‐ able conventions are refuted, as is the idea of letting each user choose a convention. The title refers to zero-based indexing, but the memo is really about why it is desira‐ ble that 'ABCDE'[1:3] means 'BC' and not 'BCD' and why it makes perfect sense to write range(2, 13) to produce 2, 3, 4, …, 12. By the way, the memo is a handwritten note, but it’s beautiful and totally readable. Dijkstra’s handwriting is so clear that someone created a font out of his notes.\n\n72\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 2790,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 103,
      "content": "Soapbox\n\nThe Nature of Tuples\n\nIn 2012, I presented a poster about the ABC language at PyCon US. Before creating Python, Guido van Rossum had worked on the ABC interpreter, so he came to see my poster. Among other things, we talked about the ABC compounds, which are clearly the predecessors of Python tuples. Compounds also support parallel assign‐ ment and are used as composite keys in dictionaries (or tables, in ABC parlance). However, compounds are not sequences. They are not iterable and you cannot retrieve a field by index, much less slice them. You either handle the compound as whole or extract the individual fields using parallel assignment, that’s all.\n\nI told Guido that these limitations make the main purpose of compounds very clear: they are just records without field names. His response: “Making tuples behave as sequences was a hack.”\n\nThis illustrates the pragmatic approach that made Python more practical and more successful than ABC. From a language implementer perspective, making tuples behave as sequences costs little. As a result, the main use case for tuples as records is not so obvious, but we gained immutable lists—even if their type is not as clearly named as frozenlist.\n\nFlat Versus Container Sequences\n\nTo highlight the different memory models of the sequence types, I used the terms container sequence and flat sequence. The “container” word is from the “Data Model” documentation:\n\nSome objects contain references to other objects; these are called containers.\n\nI used the term “container sequence” to be specific, because there are containers in Python that are not sequences, like dict and set. Container sequences can be nested because they may contain objects of any type, including their own type.\n\nOn the other hand, flat sequences are sequence types that cannot be nested because they only hold simple atomic types like integers, floats, or characters.\n\nI adopted the term flat sequence because I needed something to contrast with “con‐ tainer sequence.”\n\nDespite the previous use of the word “containers” in the official documentation, there is an abstract class in collections.abc called Container. That ABC has just one method, __contains__—the special method behind the in operator. This means that strings and arrays, which are not containers in the traditional sense, are virtual sub‐ classes of Container because they implement __contains__. This is just one more example of humans using a word to mean different things. In this book I’ll write “container” with lowercase letters to mean “an object that contains references to\n\nFurther Reading\n\n|\n\n73",
      "content_length": 2606,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 104,
      "content": "74\n\nother objects,” and Container with a capitalized initial in a single-spaced font to refer to collections.abc.Container.\n\nMixed-Bag Lists\n\nIntroductory Python texts emphasize that lists can contain objects of mixed types, but in practice that feature is not very useful: we put items in a list to process them later, which implies that all items should support at least some operation in common (i.e., they should all “quack” whether or not they are genetically 100% ducks). For exam‐ ple, you can’t sort a list in Python 3 unless the items in it are comparable:\n\n>>> l = [28, 14, '28', 5, '9', '1', 0, 6, '23', 19] >>> sorted(l) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: unorderable types: str() < int()\n\nUnlike lists, tuples often hold items of different types. That’s natural: if each item in a tuple is a field, then each field may have a different type.\n\nkey Is Brilliant\n\nThe optional key argument of list.sort, sorted, max, and min is a great idea. Other languages force you to provide a two-argument comparison function like the depre‐ cated cmp(a, b) function in Python 2. Using key is both simpler and more efficient. It’s simpler because you just define a one-argument function that retrieves or calcu‐ lates whatever criterion you want to use to sort your objects; this is easier than writing a two-argument function to return –1, 0, 1. It is also more efficient because the key function is invoked only once per item, while the two-argument comparison is called every time the sorting algorithm needs to compare two items. Of course, Python also has to compare the keys while sorting, but that comparison is done in optimized C code and not in a Python function that you wrote.\n\nBy the way, using key we can sort a mixed bag of numbers and number-like strings. We just need to decide whether we want to treat all items as integers or strings:\n\n>>> l = [28, 14, '28', 5, '9', '1', 0, 6, '23', 19] >>> sorted(l, key=int) [0, '1', 5, 6, '9', 14, 19, '23', 28, '28'] >>> sorted(l, key=str) [0, '1', 14, 19, '23', 28, '28', 5, 6, '9']\n\nOracle, Google, and the Timbot Conspiracy\n\nThe sorting algorithm used in sorted and list.sort is Timsort, an adaptive algo‐ rithm that switches from insertion sort to merge sort strategies, depending on how ordered the data is. This is efficient because real-world data tends to have runs of sor‐ ted items. There is a Wikipedia article about it.\n\n|\n\nChapter 2: An Array of Sequences",
      "content_length": 2470,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 105,
      "content": "Timsort was first used in CPython in 2002. Since 2009, Timsort is also used to sort arrays in both standard Java and Android, a fact that became widely known when Oracle used some of the code related to Timsort as evidence of Google infringement of Sun’s intellectual property. For example, see this order by Judge William Alsup from 2012. In 2021, the US Supreme Court ruled Google’s use of Java code as “fair use.”\n\nTimsort was invented by Tim Peters, a Python core developer so prolific that he is believed to be an AI, the Timbot. You can read about that conspiracy theory in “Python Humor”. Tim also wrote “The Zen of Python”: import this.\n\nFurther Reading\n\n|\n\n75",
      "content_length": 668,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 107,
      "content": "CHAPTER 3 Dictionaries and Sets\n\nPython is basically dicts wrapped in loads of syntactic sugar.\n\n—Lalo Martins, early digital nomad and Pythonista\n\nWe use dictionaries in all our Python programs. If not directly in our code, then indi‐ rectly because the dict type is a fundamental part of Python’s implementation. Class and instance attributes, module namespaces, and function keyword arguments are some of the core Python constructs represented by dictionaries in memory. The __builtins__.__dict__ stores all built-in types, objects, and functions.\n\nBecause of their crucial role, Python dicts are highly optimized—and continue to get improvements. Hash tables are the engines behind Python’s high-performance dicts.\n\nOther built-in types based on hash tables are set and frozenset. These offer richer APIs and operators than the sets you may have encountered in other popular lan‐ guages. In particular, Python sets implement all the fundamental operations from set theory, like union, intersection, subset tests, etc. With them, we can express algo‐ rithms in a more declarative way, avoiding lots of nested loops and conditionals.\n\nHere is a brief outline of this chapter:\n\nModern syntax to build and handle dicts and mappings, including enhanced unpacking and pattern matching\n\nCommon methods of mapping types\n\nSpecial handling for missing keys • Variations of dict in the standard library • The set and frozenset types\n\nImplications of hash tables in the behavior of sets and dictionaries\n\n77",
      "content_length": 1499,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 108,
      "content": "What’s New in This Chapter Most changes in this second edition cover new features related to mapping types:\n\n“Modern dict Syntax” on page 78 covers enhanced unpacking syntax and different ways of merging mappings—including the | and |= operators supported by dicts since Python 3.9.\n\n“Pattern Matching with Mappings” on page 81 illustrates handling mappings with match/case, since Python 3.10.\n\n“collections.OrderedDict” on page 95 now focuses on the small but still relevant differences between dict and OrderedDict—considering that dict keeps the key insertion order since Python 3.6.\n\nNew sections on the view objects returned by dict.keys, dict.items, and dict.values: “Dictionary Views” on page 101 and “Set Operations on dict Views” on page 110.\n\nThe underlying implementation of dict and set still relies on hash tables, but the dict code has two important optimizations that save memory and preserve the inser‐ tion order of the keys in dict. “Practical Consequences of How dict Works” on page 102 and “Practical Consequences of How Sets Work” on page 107 summarize what you need to know to use them well.\n\nAfter adding more than 200 pages in this second edition, I moved the optional section “Internals of sets and dicts” to the fluentpy‐ thon.com companion website. The updated and expanded 18-page post includes explanations and diagrams about:\n\nThe hash table algorithm and data structures, starting with its use in set, which is simpler to understand.\n\nThe memory optimization that preserves key insertion order in dict instances (since Python 3.6).\n\nThe key-sharing layout for dictionaries holding instance attributes—the __dict__ of user-defined objects (optimiza‐ tion implemented in Python 3.3).\n\nModern dict Syntax The next sections describe advanced syntax features to build, unpack, and process mappings. Some of these features are not new in the language, but may be new to you. Others require Python 3.9 (like the | operator) or Python 3.10 (like match/ case). Let’s start with one of the best and oldest of these features.\n\n78\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 2086,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 109,
      "content": "dict Comprehensions Since Python 2.7, the syntax of listcomps and genexps was adapted to dict compre‐ hensions (and set comprehensions as well, which we’ll soon visit). A dictcomp (dict comprehension) builds a dict instance by taking key:value pairs from any iterable. Example 3-1 shows the use of dict comprehensions to build two dictionaries from the same list of tuples.\n\nExample 3-1. Examples of dict comprehensions\n\n>>> dial_codes = [ ... (880, 'Bangladesh'), ... (55, 'Brazil'), ... (86, 'China'), ... (91, 'India'), ... (62, 'Indonesia'), ... (81, 'Japan'), ... (234, 'Nigeria'), ... (92, 'Pakistan'), ... (7, 'Russia'), ... (1, 'United States'), ... ] >>> country_dial = {country: code for code, country in dial_codes} >>> country_dial {'Bangladesh': 880, 'Brazil': 55, 'China': 86, 'India': 91, 'Indonesia': 62, 'Japan': 81, 'Nigeria': 234, 'Pakistan': 92, 'Russia': 7, 'United States': 1} >>> {code: country.upper() ... for country, code in sorted(country_dial.items()) ... if code < 70} {55: 'BRAZIL', 62: 'INDONESIA', 7: 'RUSSIA', 1: 'UNITED STATES'}\n\nAn iterable of key-value pairs like dial_codes can be passed directly to the dict constructor, but…\n\n…here we swap the pairs: country is the key, and code is the value.\n\nSorting country_dial by name, reversing the pairs again, uppercasing values, and filtering items with code < 70.\n\nIf you’re used to listcomps, dictcomps are a natural next step. If you aren’t, the spread of the comprehension syntax means it’s now more profitable than ever to become fluent in it.\n\nModern dict Syntax\n\n|\n\n79",
      "content_length": 1557,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 110,
      "content": "Unpacking Mappings PEP 448—Additional Unpacking Generalizations enhanced the support of mapping unpackings in two ways, since Python 3.5.\n\nFirst, we can apply ** to more than one argument in a function call. This works when keys are all strings and unique across all arguments (because duplicate keyword argu‐ ments are forbidden):\n\n>>> def dump(**kwargs): ... return kwargs ... >>> dump(**{'x': 1}, y=2, **{'z': 3}) {'x': 1, 'y': 2, 'z': 3}\n\nSecond, ** can be used inside a dict literal—also multiple times:\n\n>>> {'a': 0, **{'x': 1}, 'y': 2, **{'z': 3, 'x': 4}} {'a': 0, 'x': 4, 'y': 2, 'z': 3}\n\nIn this case, duplicate keys are allowed. Later occurrences overwrite previous ones— see the value mapped to x in the example.\n\nThis syntax can also be used to merge mappings, but there are other ways. Please read on.\n\nMerging Mappings with | Python 3.9 supports using | and |= to merge mappings. This makes sense, since these are also the set union operators.\n\nThe | operator creates a new mapping:\n\n>>> d1 = {'a': 1, 'b': 3} >>> d2 = {'a': 2, 'b': 4, 'c': 6} >>> d1 | d2 {'a': 2, 'b': 4, 'c': 6}\n\nUsually the type of the new mapping will be the same as the type of the left operand —d1 in the example—but it can be the type of the second operand if user-defined types are involved, according to the operator overloading rules we explore in Chapter 16.\n\nTo update an existing mapping in place, use |=. Continuing from the previous exam‐ ple, d1 was not changed, but now it is:\n\n>>> d1 {'a': 1, 'b': 3} >>> d1 |= d2 >>> d1 {'a': 2, 'b': 4, 'c': 6}\n\n80\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1585,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 111,
      "content": "If you need to maintain code to run on Python 3.8 or earlier, the “Motivation” section of PEP 584—Add Union Operators To dict provides a good summary of other ways to merge mappings.\n\nNow let’s see how pattern matching applies to mappings.\n\nPattern Matching with Mappings The match/case statement supports subjects that are mapping objects. Patterns for mappings look like dict literals, but they can match instances of any actual or virtual subclass of collections.abc.Mapping.1\n\nIn Chapter 2 we focused on sequence patterns only, but different types of patterns can be combined and nested. Thanks to destructuring, pattern matching is a power‐ ful tool to process records structured like nested mappings and sequences, which we often need to read from JSON APIs and databases with semi-structured schemas, like MongoDB, EdgeDB, or PostgreSQL. Example 3-2 demonstrates that. The simple type hints in get_creators make it clear that it takes a dict and returns a list.\n\nExample 3-2. creator.py: get_creators() extracts names of creators from media records\n\ndef get_creators(record: dict) -> list: match record: case {'type': 'book', 'api': 2, 'authors': [*names]}: return names case {'type': 'book', 'api': 1, 'author': name}: return [name] case {'type': 'book'}: raise ValueError(f\"Invalid 'book' record: {record!r}\") case {'type': 'movie', 'director': name}: return [name] case _: raise ValueError(f'Invalid record: {record!r}')\n\n1 A virtual subclass is any class registered by calling the .register() method of an ABC, as explained in “A Virtual Subclass of an ABC” on page 460. A type implemented via Python/C API is also eligible if a specific marker bit is set. See Py_TPFLAGS_MAPPING.\n\nPattern Matching with Mappings\n\n|\n\n81",
      "content_length": 1730,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 112,
      "content": "Match any mapping with 'type': 'book', 'api' :2, and an 'authors' key mapped to a sequence. Return the items in the sequence, as a new list.\n\nMatch any mapping with 'type': 'book', 'api' :1, and an 'author' key mapped to any object. Return the object inside a list.\n\nAny other mapping with 'type': 'book' is invalid, raise ValueError.\n\nMatch any mapping with 'type': 'movie' and a 'director' key mapped to a single object. Return the object inside a list.\n\nAny other subject is invalid, raise ValueError.\n\nExample 3-2 shows some useful practices for handling semi-structured data such as JSON records:\n\nInclude a field describing the kind of record (e.g., 'type': 'movie') • Include a field identifying the schema version (e.g., 'api': 2') to allow for future evolution of public APIs\n\nHave case clauses to handle invalid records of a specific type (e.g., 'book'), as well as a catch-all\n\nNow let’s see how get_creators handles some concrete doctests:\n\n>>> b1 = dict(api=1, author='Douglas Hofstadter', ... type='book', title='Gödel, Escher, Bach') >>> get_creators(b1) ['Douglas Hofstadter'] >>> from collections import OrderedDict >>> b2 = OrderedDict(api=2, type='book', ... title='Python in a Nutshell', ... authors='Martelli Ravenscroft Holden'.split()) >>> get_creators(b2) ['Martelli', 'Ravenscroft', 'Holden'] >>> get_creators({'type': 'book', 'pages': 770}) Traceback (most recent call last): ... ValueError: Invalid 'book' record: {'type': 'book', 'pages': 770} >>> get_creators('Spam, spam, spam') Traceback (most recent call last): ... ValueError: Invalid record: 'Spam, spam, spam'\n\nNote that the order of the keys in the patterns is irrelevant, even if the subject is an OrderedDict as b2.\n\n82\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1744,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 113,
      "content": "In contrast with sequence patterns, mapping patterns succeed on partial matches. In the doctests, the b1 and b2 subjects include a 'title' key that does not appear in any 'book' pattern, yet they match.\n\nThere is no need to use **extra to match extra key-value pairs, but if you want to capture them as a dict, you can prefix one variable with **. It must be the last in the pattern, and **_ is forbidden because it would be redundant. A simple example:\n\n>>> food = dict(category='ice cream', flavor='vanilla', cost=199) >>> match food: ... case {'category': 'ice cream', **details}: ... print(f'Ice cream details: {details}') ... Ice cream details: {'flavor': 'vanilla', 'cost': 199}\n\nIn “Automatic Handling of Missing Keys” on page 90 we’ll study defaultdict and other mappings where key lookups via __getitem__ (i.e., d[key]) succeed because missing items are created on the fly. In the context of pattern matching, a match suc‐ ceeds only if the subject already has the required keys at the top of the match statement.\n\nThe automatic handling of missing keys is not triggered because pattern matching always uses the d.get(key, sentinel) method —where the default sentinel is a special marker value that cannot occur in user data.\n\nMoving on from syntax and structure, let’s study the API of mappings.\n\nStandard API of Mapping Types The collections.abc module provides the Mapping and MutableMapping ABCs describing the interfaces of dict and similar types. See Figure 3-1.\n\nThe main value of the ABCs is documenting and formalizing the standard interfaces for mappings, and serving as criteria for isinstance tests in code that needs to sup‐ port mappings in a broad sense:\n\n>>> my_dict = {} >>> isinstance(my_dict, abc.Mapping) True >>> isinstance(my_dict, abc.MutableMapping) True\n\nStandard API of Mapping Types\n\n|\n\n83",
      "content_length": 1825,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 114,
      "content": "Using isinstance with an ABC is often better than checking whether a function argument is of the concrete dict type, because then alternative mapping types can be used. We’ll discuss this in detail in Chapter 13.\n\nFigure 3-1. Simplified UML class diagram for the MutableMapping and its superclasses from collections.abc (inheritance arrows point from subclasses to superclasses; names in italic are abstract classes and abstract methods).\n\nTo implement a custom mapping, it’s easier to extend collections.UserDict, or to wrap a dict by composition, instead of subclassing these ABCs. The collec tions.UserDict class and all concrete mapping classes in the standard library encap‐ sulate the basic dict in their implementation, which in turn is built on a hash table. Therefore, they all share the limitation that the keys must be hashable (the values need not be hashable, only the keys). If you need a refresher, the next section explains.\n\nWhat Is Hashable Here is part of the definition of hashable adapted from the Python Glossary:\n\nAn object is hashable if it has a hash code which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same hash code.2\n\nNumeric types and flat immutable types str and bytes are all hashable. Container types are hashable if they are immutable and all contained objects are also hashable. A frozenset is always hashable, because every element it contains must be hashable\n\n2 The Python Glossary entry for “hashable” uses the term “hash value” instead of hash code. I prefer hash code because that is a concept often discussed in the context of mappings, where items are made of keys and val‐ ues, so it may be confusing to mention the hash code as a value. In this book, I only use hash code.\n\n84\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1901,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 115,
      "content": "by definition. A tuple is hashable only if all its items are hashable. See tuples tt, tl, and tf:\n\n>>> tt = (1, 2, (30, 40)) >>> hash(tt) 8027212646858338501 >>> tl = (1, 2, [30, 40]) >>> hash(tl) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: unhashable type: 'list' >>> tf = (1, 2, frozenset([30, 40])) >>> hash(tf) -4118419923444501110\n\nThe hash code of an object may be different depending on the version of Python, the machine architecture, and because of a salt added to the hash computation for secu‐ rity reasons.3 The hash code of a correctly implemented object is guaranteed to be constant only within one Python process.\n\nUser-defined types are hashable by default because their hash code is their id(), and the __eq__() method inherited from the object class simply compares the object IDs. If an object implements a custom __eq__() that takes into account its internal state, it will be hashable only if its __hash__() always returns the same hash code. In practice, this requires that __eq__() and __hash__() only take into account instance attributes that never change during the life of the object.\n\nNow let’s review the API of the most commonly used mapping types in Python: dict, defaultdict, and OrderedDict.\n\nOverview of Common Mapping Methods The basic API for mappings is quite rich. Table 3-1 shows the methods implemented by dict and two popular variations: defaultdict and OrderedDict, both defined in the collections module.\n\n3 See PEP 456—Secure and interchangeable hash algorithm to learn about the security implications and solu‐\n\ntions adopted.\n\nStandard API of Mapping Types\n\n|\n\n85",
      "content_length": 1647,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 116,
      "content": "Table 3-1. Methods of the mapping types dict, collections.defaultdict, and collec tions.OrderedDict (common object methods omitted for brevity); optional arguments are enclosed in […]\n\ndict\n\ndefaultdict\n\nOrderedDict\n\nd.clear()\n\n\n\n\n\n\n\nRemove all items\n\nd.__contains__(k)\n\n\n\n\n\n\n\nk in d\n\nd.copy()\n\n\n\n\n\n\n\nShallow copy\n\nd.__copy__()\n\n\n\nSupport for copy.copy(d)\n\nd.default_factory\n\n\n\nCallable invoked by __missing__ to set missing valuesa\n\nd.__delitem__(k)\n\n\n\n\n\n\n\ndel d[k]—remove item with key k\n\nd.fromkeys(it, [ini tial])\n\n\n\n\n\n\n\nNew mapping from keys in iterable, with optional initial value (defaults to None)\n\nd.get(k, [default])\n\n\n\n\n\n\n\nGet item with key k, return default or None if missing\n\nd.__getitem__(k)\n\n\n\n\n\n\n\nd[k]—get item with key k\n\nd.items()\n\n\n\n\n\n\n\nGet view over items—(key, value) pairs\n\nd.__iter__()\n\n\n\n\n\n\n\nGet iterator over keys\n\nd.keys()\n\n\n\n\n\n\n\nGet view over keys\n\nd.__len__()\n\n\n\n\n\n\n\nlen(d)—number of items\n\nd.__missing__(k)\n\n\n\nCalled when __getitem__ cannot find the key\n\nd.move_to_end(k, [last])\n\n\n\nMove k first or last position (last is True by default)\n\nd.__or__(other)\n\n\n\n\n\n\n\nSupport for d1 | d2 to create new dict merging d1 and d2 (Python ≥ 3.9)\n\nd.__ior__(other)\n\n\n\n\n\n\n\nSupport for d1 |= d2 to update d1 with d2 (Python ≥ 3.9)\n\nd.pop(k, [default])\n\n\n\n\n\n\n\nRemove and return value at k, or default or None if missing\n\nd.popitem()\n\n\n\n\n\n\n\nRemove and return the last inserted item as (key, value) b\n\nd.__reversed__()\n\n\n\n\n\n\n\nSupport for reverse(d)—returns iterator for keys from last to first inserted.\n\nd.__ror__(other)\n\n\n\n\n\n\n\nSupport for other | dd— reversed union operator (Python ≥ 3.9)c\n\n86\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1647,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 117,
      "content": "dict\n\ndefaultdict\n\nOrderedDict\n\nd.setdefault(k, [default])\n\n\n\n\n\n\n\nIf k in d, return d[k]; else set d[k] = default and return it\n\nd.__setitem__(k, v)\n\n\n\n\n\n\n\nd[k] = v—put v at k\n\nd.update(m, [**kwargs])\n\n\n\n\n\n\n\nUpdate d with items from mapping or iterable of (key, value) pairs\n\nd.values()\n\n\n\n\n\n\n\nGet view over values\n\na default_factory is not a method, but a callable attribute set by the end user when a defaultdict is instantiated. b OrderedDict.popitem(last=False) removes the first item inserted (FIFO). The last keyword argument is not supported in dict or defaultdict as recently as Python 3.10b3. c Reversed operators are explained in Chapter 16.\n\nThe way d.update(m) handles its first argument m is a prime example of duck typing: it first checks whether m has a keys method and, if it does, assumes it is a mapping. Otherwise, update() falls back to iterating over m, assuming its items are (key, value) pairs. The constructor for most Python mappings uses the logic of update() internally, which means they can be initialized from other mappings or from any iterable object producing (key, value) pairs.\n\nA subtle mapping method is setdefault(). It avoids redundant key lookups when we need to update the value of an item in place. The next section shows how to use it.\n\nInserting or Updating Mutable Values In line with Python’s fail-fast philosophy, dict access with d[k] raises an error when k is not an existing key. Pythonistas know that d.get(k, default) is an alternative to d[k] whenever a default value is more convenient than handling KeyError. How‐ ever, when you retrieve a mutable value and want to update it, there is a better way.\n\nConsider a script to index text, producing a mapping where each key is a word, and the value is a list of positions where that word occurs, as shown in Example 3-3.\n\nExample 3-3. Partial output from Example 3-4 processing the “Zen of Python”; each line shows a word and a list of occurrences coded as pairs: (line_number, column_number)\n\n$ python3 index0.py zen.txt a [(19, 48), (20, 53)] Although [(11, 1), (16, 1), (18, 1)] ambiguity [(14, 16)] and [(15, 23)] are [(21, 12)] aren [(10, 15)] at [(16, 38)] bad [(19, 50)]\n\nStandard API of Mapping Types\n\n|\n\n87",
      "content_length": 2214,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 118,
      "content": "be [(15, 14), (16, 27), (20, 50)] beats [(11, 23)] Beautiful [(3, 1)] better [(3, 14), (4, 13), (5, 11), (6, 12), (7, 9), (8, 11), (17, 8), (18, 25)] ...\n\nExample 3-4 is a suboptimal script written to show one case where dict.get is not the best way to handle a missing key. I adapted it from an example by Alex Martelli.4\n\nExample 3-4. index0.py uses dict.get to fetch and update a list of word occurrences from the index (a better solution is in Example 3-5)\n\n\"\"\"Build an index mapping word -> list of occurrences\"\"\"\n\nimport re import sys\n\nWORD_RE = re.compile(r'\\w+')\n\nindex = {} with open(sys.argv[1], encoding='utf-8') as fp: for line_no, line in enumerate(fp, 1): for match in WORD_RE.finditer(line): word = match.group() column_no = match.start() + 1 location = (line_no, column_no) # this is ugly; coded like this to make a point occurrences = index.get(word, []) occurrences.append(location) index[word] = occurrences\n\n# display in alphabetical order for word in sorted(index, key=str.upper): print(word, index[word])\n\nGet the list of occurrences for word, or [] if not found.\n\nAppend new location to occurrences.\n\nPut changed occurrences into index dict; this entails a second search through the index.\n\n4 The original script appears in slide 41 of Martelli’s “Re-learning Python” presentation. His script is actually a\n\ndemonstration of dict.setdefault, as shown in our Example 3-5.\n\n88\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1434,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 119,
      "content": "In the key= argument of sorted, I am not calling str.upper, just passing a refer‐ ence to that method so the sorted function can use it to normalize the words for sorting.5\n\nThe three lines dealing with occurrences in Example 3-4 can be replaced by a single line using dict.setdefault. Example 3-5 is closer to Alex Martelli’s code.\n\nExample 3-5. index.py uses dict.setdefault to fetch and update a list of word occurrences from the index in a single line; contrast with Example 3-4\n\n\"\"\"Build an index mapping word -> list of occurrences\"\"\"\n\nimport re import sys\n\nWORD_RE = re.compile(r'\\w+')\n\nindex = {} with open(sys.argv[1], encoding='utf-8') as fp: for line_no, line in enumerate(fp, 1): for match in WORD_RE.finditer(line): word = match.group() column_no = match.start() + 1 location = (line_no, column_no) index.setdefault(word, []).append(location)\n\n# display in alphabetical order for word in sorted(index, key=str.upper): print(word, index[word])\n\nGet the list of occurrences for word, or set it to [] if not found; setdefault returns the value, so it can be updated without requiring a second search.\n\nIn other words, the end result of this line…\n\nmy_dict.setdefault(key, []).append(new_value)\n\n…is the same as running…\n\nif key not in my_dict: my_dict[key] = [] my_dict[key].append(new_value)\n\n…except that the latter code performs at least two searches for key—three if it’s not found—while setdefault does it all with a single lookup.\n\n5 This is an example of using a method as a first-class function, the subject of Chapter 7.\n\nStandard API of Mapping Types\n\n|\n\n89",
      "content_length": 1577,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 120,
      "content": "A related issue, handling missing keys on any lookup (and not only when inserting), is the subject of the next section.\n\nAutomatic Handling of Missing Keys Sometimes it is convenient to have mappings that return some made-up value when a missing key is searched. There are two main approaches to this: one is to use a defaultdict instead of a plain dict. The other is to subclass dict or any other map‐ ping type and add a __missing__ method. Both solutions are covered next.\n\ndefaultdict: Another Take on Missing Keys A collections.defaultdict instance creates items with a default value on demand whenever a missing key is searched using d[k] syntax. Example 3-6 uses default dict to provide another elegant solution to the word index task from Example 3-5.\n\nHere is how it works: when instantiating a defaultdict, you provide a callable to produce a default value whenever __getitem__ is passed a nonexistent key argument.\n\nFor example, given a defaultdict created as dd = defaultdict(list), if 'new-key' is not in dd, the expression dd['new-key'] does the following steps:\n\n1. Calls list() to create a new list. 2. Inserts the list into dd using 'new-key' as key.\n\n3. Returns a reference to that list.\n\nThe callable that produces the default values is held in an instance attribute named default_factory.\n\nExample 3-6. index_default.py: using defaultdict instead of the setdefault method\n\n\"\"\"Build an index mapping word -> list of occurrences\"\"\"\n\nimport collections import re import sys\n\nWORD_RE = re.compile(r'\\w+')\n\nindex = collections.defaultdict(list) with open(sys.argv[1], encoding='utf-8') as fp: for line_no, line in enumerate(fp, 1): for match in WORD_RE.finditer(line): word = match.group() column_no = match.start() + 1 location = (line_no, column_no)\n\n90\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1807,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 121,
      "content": "index[word].append(location)\n\n# display in alphabetical order for word in sorted(index, key=str.upper): print(word, index[word])\n\nCreate a defaultdict with the list constructor as default_factory.\n\nIf word is not initially in the index, the default_factory is called to produce the missing value, which in this case is an empty list that is then assigned to index[word] and returned, so the .append(location) operation always suc‐ ceeds.\n\nIf no default_factory is provided, the usual KeyError is raised for missing keys.\n\nThe default_factory of a defaultdict is only invoked to provide default values for __getitem__ calls, and not for the other meth‐ ods. For example, if dd is a defaultdict, and k is a missing key, dd[k] will call the default_factory to create a default value, but dd.get(k) still returns None, and k in dd is False.\n\nThe mechanism that makes defaultdict work by calling default_factory is the __missing__ special method, a feature that we discuss next.\n\nThe __missing__ Method Underlying the way mappings deal with missing keys is the aptly named __missing__ method. This method is not defined in the base dict class, but dict is aware of it: if you subclass dict and provide a __missing__ method, the standard dict.__geti tem__ will call it whenever a key is not found, instead of raising KeyError.\n\nSuppose you’d like a mapping where keys are converted to str when looked up. A concrete use case is a device library for IoT,6 where a programmable board with general-purpose I/O pins (e.g., a Raspberry Pi or an Arduino) is represented by a Board class with a my_board.pins attribute, which is a mapping of physical pin iden‐ tifiers to pin software objects. The physical pin identifier may be just a number or a string like \"A0\" or \"P9_12\". For consistency, it is desirable that all keys in board.pins are strings, but it is also convenient looking up a pin by number, as in my_ardu ino.pin[13], so that beginners are not tripped when they want to blink the LED on pin 13 of their Arduinos. Example 3-7 shows how such a mapping would work.\n\n6 One such library is Pingo.io, no longer under active development.\n\nAutomatic Handling of Missing Keys\n\n|\n\n91",
      "content_length": 2174,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 122,
      "content": "Example 3-7. When searching for a nonstring key, StrKeyDict0 converts it to str when it is not found\n\nTests for item retrieval using `d[key]` notation::\n\n>>> d = StrKeyDict0([('2', 'two'), ('4', 'four')]) >>> d['2'] 'two' >>> d[4] 'four' >>> d[1] Traceback (most recent call last): ... KeyError: '1'\n\nTests for item retrieval using `d.get(key)` notation::\n\n>>> d.get('2') 'two' >>> d.get(4) 'four' >>> d.get(1, 'N/A') 'N/A'\n\nTests for the `in` operator::\n\n>>> 2 in d True >>> 1 in d False\n\nExample 3-8 implements a class StrKeyDict0 that passes the preceding doctests.\n\nA better way to create a user-defined mapping type is to subclass collections.UserDict in Example 3-9). Here we subclass dict just to show that __miss ing__ is supported by the built-in dict.__getitem__ method.\n\ninstead of dict (as we will do\n\nExample 3-8. StrKeyDict0 converts nonstring keys to str on lookup (see tests in Example 3-7)\n\nclass StrKeyDict0(dict):\n\ndef __missing__(self, key): if isinstance(key, str): raise KeyError(key) return self[str(key)]\n\n92\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1069,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 123,
      "content": "def get(self, key, default=None): try: return self[key] except KeyError: return default\n\ndef __contains__(self, key): return key in self.keys() or str(key) in self.keys()\n\nStrKeyDict0 inherits from dict.\n\nCheck whether key is already a str. If it is, and it’s missing, raise KeyError.\n\nBuild str from key and look it up.\n\nThe get method delegates to __getitem__ by using the self[key] notation; that gives the opportunity for our __missing__ to act.\n\nIf a KeyError was raised, __missing__ already failed, so we return the default.\n\nSearch for unmodified key (the instance may contain non-str keys), then for a str built from the key.\n\nTake a moment to consider why the test isinstance(key, str) is necessary in the __missing__ implementation.\n\nWithout that test, our __missing__ method would work OK for any key k—str or not str—whenever str(k) produced an existing key. But if str(k) is not an existing key, we’d have an infinite recursion. In the last line of __missing__, self[str(key)] would call __getitem__, passing that str key, which in turn would call __missing__ again.\n\nThe __contains__ method is also needed for consistent behavior in this example, because the operation k in d calls it, but the method inherited from dict does not fall back to invoking __missing__. There is a subtle detail in our implementation of __contains__: we do not check for the key in the usual Pythonic way—k in my_dict —because str(key) in self would recursively call __contains__. We avoid this by explicitly looking up the key in self.keys().\n\nA search like k in my_dict.keys() is efficient in Python 3 even for very large map‐ pings because dict.keys() returns a view, which is similar to a set, as we’ll see in “Set Operations on dict Views” on page 110. However, remember that k in my_dict does the same job, and is faster because it avoids the attribute lookup to find the .keys method.\n\nAutomatic Handling of Missing Keys\n\n|\n\n93",
      "content_length": 1926,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 124,
      "content": "I had a specific reason to use self.keys() in the __contains__ method in Example 3-8. The check for the unmodified key—key in self.keys()—is necessary for correctness because StrKeyDict0 does not enforce that all keys in the dictionary must be of type str. Our only goal with this simple example is to make searching “friendlier” and not enforce types.\n\nUser-defined classes derived from standard library mappings may or may not use __missing__ as a fallback in their implementations of __getitem__, get, or __contains__, as explained in the next section.\n\nInconsistent Usage of __missing__ in the Standard Library Consider the following scenarios, and how the missing key lookups are affected:\n\ndict subclass\n\nA subclass of dict implementing only __missing__ and no other method. In this case, __missing__ may be called only on d[k], which will use the __getitem__ inherited from dict.\n\ncollections.UserDict subclass\n\nLikewise, a subclass of UserDict implementing only __missing__ and no other method. The get method inherited from UserDict calls __getitem__. This means __missing__ may be called to handle lookups with d[k] and d.get(k).\n\nabc.Mapping subclass with the simplest possible __getitem__\n\nA minimal subclass of abc.Mapping implementing __missing__ and the required abstract methods, including an implementation of __getitem__ that does not call __missing__. The __missing__ method is never triggered in this class.\n\nabc.Mapping subclass with __getitem__ calling __missing__\n\nA minimal subclass of abc.Mapping implementing __missing__ and the required abstract methods, including an implementation of __getitem__ that calls __miss ing__. The __missing__ method is triggered in this class for missing key lookups made with d[k], d.get(k), and k in d.\n\nSee missing.py in the example code repository for demonstrations of the scenarios described here.\n\nThe four scenarios just described assume minimal implementations. If your subclass implements __getitem__, get, and __contains__, then you can make those methods use __missing__ or not, depending on your needs. The point of this section is to show that you must be careful when subclassing standard library mappings to use __missing__, because the base classes support different behaviors by default.\n\n94\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 2303,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 125,
      "content": "Don’t forget that the behavior of setdefault and update is also affected by key lookup. And finally, depending on the logic of your __missing__, you may need to implement special logic in __setitem__, to avoid inconsistent or surprising behavior. We’ll see an example of this in “Subclassing UserDict Instead of dict” on page 97.\n\nSo far we have covered the dict and defaultdict mapping types, but the standard library comes with other mapping implementations, which we discuss next.\n\nVariations of dict In this section is an overview of mapping types included in the standard library, besides defaultdict, already covered in “defaultdict: Another Take on Missing Keys” on page 90.\n\ncollections.OrderedDict Now that the built-in dict also keeps the keys ordered since Python 3.6, the most common reason to use OrderedDict is writing code that is backward compatible with earlier Python versions. Having said that, Python’s documentation lists some remain‐ ing differences between dict and OrderedDict, which I quote here—only reordering the items for relevance in daily use:\n\nThe equality operation for OrderedDict checks for matching order. • The popitem() method of OrderedDict has a different signature. It accepts an optional argument to specify which item is popped.\n\nOrderedDict has a move_to_end() method to efficiently reposition an element to an endpoint.\n\nThe regular dict was designed to be very good at mapping operations. Tracking insertion order was secondary.\n\nOrderedDict was designed to be good at reordering operations. Space efficiency, iteration speed, and the performance of update operations were secondary.\n\nAlgorithmically, OrderedDict can handle frequent reordering operations better than dict. This makes it suitable for tracking recent accesses (for example, in an LRU cache).\n\ncollections.ChainMap A ChainMap instance holds a list of mappings that can be searched as one. The lookup is performed on each input mapping in the order it appears in the constructor call, and succeeds as soon as the key is found in one of those mappings. For example:\n\nVariations of dict\n\n|\n\n95",
      "content_length": 2101,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 126,
      "content": ">>> d1 = dict(a=1, b=3) >>> d2 = dict(a=2, b=4, c=6) >>> from collections import ChainMap >>> chain = ChainMap(d1, d2) >>> chain['a'] 1 >>> chain['c'] 6\n\nThe ChainMap instance does not copy the input mappings, but holds references to them. Updates or insertions to a ChainMap only affect the first input mapping. Con‐ tinuing from the previous example:\n\n>>> chain['c'] = -1 >>> d1 {'a': 1, 'b': 3, 'c': -1} >>> d2 {'a': 2, 'b': 4, 'c': 6}\n\nChainMap is useful to implement interpreters for languages with nested scopes, where each mapping represents a scope context, from the innermost enclosing scope to the outermost scope. The “ChainMap objects” section of the collections docs has sev‐ eral examples of ChainMap usage, including this snippet inspired by the basic rules of variable lookup in Python:\n\nimport builtins pylookup = ChainMap(locals(), globals(), vars(builtins))\n\nExample 18-14 shows a ChainMap subclass used to implement an interpreter for a subset of the Scheme programming language.\n\ncollections.Counter A mapping that holds an integer count for each key. Updating an existing key adds to its count. This can be used to count instances of hashable objects or as a multiset (dis‐ cussed later in this section). Counter implements the + and - operators to combine tallies, and other useful methods such as most_common([n]), which returns an ordered list of tuples with the n most common items and their counts; see the docu‐ mentation. Here is Counter used to count letters in words:\n\n>>> ct = collections.Counter('abracadabra') >>> ct Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1}) >>> ct.update('aaaaazzz') >>> ct Counter({'a': 10, 'z': 3, 'b': 2, 'r': 2, 'c': 1, 'd': 1}) >>> ct.most_common(3) [('a', 10), ('z', 3), ('b', 2)]\n\n96\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1787,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 127,
      "content": "Note that the 'b' and 'r' keys are tied in third place, but ct.most_common(3) shows only three counts.\n\nTo use collections.Counter as a multiset, pretend each key is an element in the set, and the count is the number of occurrences of that element in the set.\n\nshelve.Shelf The shelve module in the standard library provides persistent storage for a mapping of string keys to Python objects serialized in the pickle binary format. The curious name of shelve makes sense when you realize that pickle jars are stored on shelves.\n\nThe shelve.open module-level function returns a shelve.Shelf instance—a simple key-value DBM database backed by the dbm module, with these characteristics:\n\nshelve.Shelf subclasses abc.MutableMapping, so it provides the essential meth‐ ods we expect of a mapping type.\n\nIn addition, shelve.Shelf provides a few other I/O management methods, like sync and close.\n\nA Shelf instance is a context manager, so you can use a with block to make sure it is closed after use.\n\nKeys and values are saved whenever a new value is assigned to a key.\n\nThe keys must be strings. • The values must be objects that the pickle module can serialize.\n\nThe documentation for the shelve, dbm, and pickle modules provides more details and some caveats.\n\nPython’s pickle is easy to use in the simplest cases, but has several drawbacks. Read Ned Batchelder’s “Pickle’s nine flaws” before adopting any solution involving pickle. In his post, Ned mentions other serialization formats to consider.\n\nOrderedDict, ChainMap, Counter, and Shelf are ready to use but can also be custom‐ ized by subclassing. In contrast, UserDict is intended only as a base class to be extended.\n\nSubclassing UserDict Instead of dict It’s better to create a new mapping type by extending collections.UserDict rather than dict. We realize that when we try to extend our StrKeyDict0 from Example 3-8 to make sure that any keys added to the mapping are stored as str.\n\nVariations of dict\n\n|\n\n97",
      "content_length": 1969,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 128,
      "content": "The main reason why it’s better to subclass UserDict rather than dict is that the built-in has some implementation shortcuts that end up forcing us to override meth‐ ods that we can just inherit from UserDict with no problems.7\n\nNote that UserDict does not inherit from dict, but uses composition: it has an inter‐ nal dict instance, called data, which holds the actual items. This avoids undesired recursion when coding special methods like __setitem__, and simplifies the coding of __contains__, compared to Example 3-8.\n\nThanks to UserDict, StrKeyDict (Example 3-9) is more concise than StrKeyDict0 (Example 3-8), but it does more: it stores all keys as str, avoiding unpleasant sur‐ prises if the instance is built or updated with data containing nonstring keys.\n\nExample 3-9. StrKeyDict always converts nonstring keys to str on insertion, update, and lookup\n\nimport collections\n\nclass StrKeyDict(collections.UserDict):\n\ndef __missing__(self, key): if isinstance(key, str): raise KeyError(key) return self[str(key)]\n\ndef __contains__(self, key): return str(key) in self.data\n\ndef __setitem__(self, key, item): self.data[str(key)] = item\n\nStrKeyDict extends UserDict.\n\n__missing__ is exactly as in Example 3-8.\n\n__contains__ is simpler: we can assume all stored keys are str, and we can check on self.data instead of invoking self.keys() as we did in StrKeyDict0.\n\n__setitem__ converts any key to a str. This method is easier to overwrite when we can delegate to the self.data attribute.\n\n7 The exact problem with subclassing dict and other built-ins is covered in “Subclassing Built-In Types Is\n\nTricky” on page 490.\n\n98\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1661,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 129,
      "content": "Because UserDict extends abc.MutableMapping, the remaining methods that make StrKeyDict a full-fledged mapping are inherited from UserDict, MutableMapping, or Mapping. The latter have several useful concrete methods, in spite of being abstract base classes (ABCs). The following methods are worth noting:\n\nMutableMapping.update\n\nThis powerful method can be called directly but is also used by __init__ to load the instance from other mappings, from iterables of (key, value) pairs, and keyword arguments. Because it uses self[key] = value to add items, it ends up calling our implementation of __setitem__.\n\nMapping.get\n\nIn StrKeyDict0 (Example 3-8), we had to code our own get to return the same results as __getitem__, but in Example 3-9 we inherited Mapping.get, which is implemented exactly like StrKeyDict0.get (see the Python source code).\n\nAntoine Pitrou authored PEP 455—Adding a key-transforming dictionary to collections and a patch to enhance the collections module with a TransformDict, that is more general than StrKey Dict and preserves the keys as they are provided, before the trans‐ formation is applied. PEP 455 was rejected in May 2015—see Raymond Hettinger’s rejection message. To experiment with Trans formDict, I extracted Pitrou’s patch from issue18986 into a stand‐ alone module (03-dict-set/transformdict.py in the Fluent Python second edition code repository).\n\nWe know there are immutable sequence types, but how about an immutable map‐ ping? Well, there isn’t a real one in the standard library, but a stand-in is available. That’s next.\n\nImmutable Mappings The mapping types provided by the standard library are all mutable, but you may need to prevent users from changing a mapping by accident. A concrete use case can be found, again, in a hardware programming library like Pingo, mentioned in “The __missing__ Method” on page 91: the board.pins mapping represents the physical GPIO pins on the device. As such, it’s useful to prevent inadvertent updates to board.pins because the hardware can’t be changed via software, so any change in the mapping would make it inconsistent with the physical reality of the device.\n\nThe types module provides a wrapper class called MappingProxyType, which, given a mapping, returns a mappingproxy instance that is a read-only but dynamic proxy for the original mapping. This means that updates to the original mapping can be seen in\n\nImmutable Mappings\n\n|\n\n99",
      "content_length": 2426,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 130,
      "content": "the mappingproxy, but changes cannot be made through it. See Example 3-10 for a brief demonstration.\n\nExample 3-10. MappingProxyType builds a read-only mappingproxy instance from a dict\n\n>>> from types import MappingProxyType >>> d = {1: 'A'} >>> d_proxy = MappingProxyType(d) >>> d_proxy mappingproxy({1: 'A'}) >>> d_proxy[1] 'A' >>> d_proxy[2] = 'x' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'mappingproxy' object does not support item assignment >>> d[2] = 'B' >>> d_proxy mappingproxy({1: 'A', 2: 'B'}) >>> d_proxy[2] 'B' >>>\n\nItems in d can be seen through d_proxy.\n\nChanges cannot be made through d_proxy.\n\nd_proxy is dynamic: any change in d is reflected.\n\nHere is how this could be used in practice in the hardware programming scenario: the constructor in a concrete Board subclass would fill a private mapping with the pin objects, and expose it to clients of the API via a public .pins attribute implemented as a mappingproxy. That way the clients would not be able to add, remove, or change pins by accident.\n\nNext, we’ll cover views—which allow high-performance operations on a dict, without unnecessary copying of data.\n\n100\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1214,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 131,
      "content": "Dictionary Views The dict instance methods .keys(), .values(), and .items() return instances of classes called dict_keys, dict_values, and dict_items, respectively. These dictio‐ nary views are read-only projections of the internal data structures used in the dict implementation. They avoid the memory overhead of the equivalent Python 2 meth‐ ods that returned lists duplicating data already in the target dict, and they also replace the old methods that returned iterators.\n\nExample 3-11 shows some basic operations supported by all dictionary views.\n\nExample 3-11. The .values() method returns a view of the values in a dict\n\n>>> d = dict(a=10, b=20, c=30) >>> values = d.values() >>> values dict_values([10, 20, 30]) >>> len(values) 3 >>> list(values) [10, 20, 30] >>> reversed(values) <dict_reversevalueiterator object at 0x10e9e7310> >>> values[0] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'dict_values' object is not subscriptable\n\nThe repr of a view object shows its content.\n\nWe can query the len of a view.\n\nViews are iterable, so it’s easy to create lists from them.\n\nViews implement __reversed__, returning a custom iterator.\n\nWe can’t use [] to get individual items from a view.\n\nA view object is a dynamic proxy. If the source dict is updated, you can immediately see the changes through an existing view. Continuing from Example 3-11:\n\n>>> d['z'] = 99 >>> d {'a': 10, 'b': 20, 'c': 30, 'z': 99} >>> values dict_values([10, 20, 30, 99])\n\nDictionary Views\n\n|\n\n101",
      "content_length": 1517,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 132,
      "content": "The classes dict_keys, dict_values, and dict_items are internal: they are not avail‐ able via __builtins__ or any standard library module, and even if you get a reference to one of them, you can’t use it to create a view from scratch in Python code:\n\n>>> values_class = type({}.values()) >>> v = values_class() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: cannot create 'dict_values' instances\n\nThe dict_values class is the simplest dictionary view—it implements only the __len__, __iter__, and __reversed__ special methods. In addition to these meth‐ ods, dict_keys and dict_items implement several set methods, almost as many as the frozenset class. After we cover sets, we’ll have more to say about dict_keys and dict_items in “Set Operations on dict Views” on page 110.\n\nNow let’s see some rules and tips informed by the way dict is implemented under the hood.\n\nPractical Consequences of How dict Works The hash table implementation of Python’s dict is very efficient, but it’s important to understand the practical effects of this design:\n\nKeys must be hashable objects. They must implement proper __hash__ and __eq__ methods as described in “What Is Hashable” on page 84.\n\nItem access by key is very fast. A dict may have millions of keys, but Python can locate a key directly by computing the hash code of the key and deriving an index offset into the hash table, with the possible overhead of a small number of tries to find a matching entry.\n\nKey ordering is preserved as a side effect of a more compact memory layout for dict in CPython 3.6, which became an official language feature in 3.7.\n\nDespite its new compact layout, dicts inevitably have a significant memory over‐ head. The most compact internal data structure for a container would be an array of pointers to the items.8 Compared to that, a hash table needs to store more data per entry, and Python needs to keep at least one-third of the hash table rows empty to remain efficient.\n\nTo save memory, avoid creating instance attributes outside of the __init__ method.\n\n8 That’s how tuples are stored.\n\n102\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 2148,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 133,
      "content": "That last tip about instance attributes comes from the fact that Python’s default behavior is to store instance attributes in a special __dict__ attribute, which is a dict attached to each instance.9 Since PEP 412—Key-Sharing Dictionary was implemented in Python 3.3, instances of a class can share a common hash table, stored with the class. That common hash table is shared by the __dict__ of each new instance that has the same attributes names as the first instance of that class when __init__ returns. Each instance __dict__ can then hold only its own attribute values as a sim‐ ple array of pointers. Adding an instance attribute after __init__ forces Python to create a new hash table just for the __dict__ of that one instance (which was the default behavior for all instances before Python 3.3). According to PEP 412, this opti‐ mization reduces memory use by 10% to 20% for object-oriented programs.\n\nThe details of the compact layout and key-sharing optimizations are rather complex. For more, please read “Internals of sets and dicts” at fluentpython.com.\n\nNow let’s dive into sets.\n\nSet Theory Sets are not new in Python, but are still somewhat underused. The set type and its immutable sibling frozenset first appeared as modules in the Python 2.3 standard library, and were promoted to built-ins in Python 2.6.\n\nIn this book, I use the word “set” to refer both to set and frozen set. When talking specifically about the set class, I use constant width font: set.\n\nA set is a collection of unique objects. A basic use case is removing duplication:\n\n>>> l = ['spam', 'spam', 'eggs', 'spam', 'bacon', 'eggs'] >>> set(l) {'eggs', 'spam', 'bacon'} >>> list(set(l)) ['eggs', 'spam', 'bacon']\n\n9 Unless the class has a __slots__ attribute, as explained in “Saving Memory with __slots__” on page 384.\n\nSet Theory\n\n|\n\n103",
      "content_length": 1827,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 134,
      "content": "If you want to remove duplicates but also preserve the order of the first occurrence of each item, you can now use a plain dict to do it, like this:\n\n>>> dict.fromkeys(l).keys() dict_keys(['spam', 'eggs', 'bacon']) >>> list(dict.fromkeys(l).keys()) ['spam', 'eggs', 'bacon']\n\nSet elements must be hashable. The set type is not hashable, so you can’t build a set with nested set instances. But frozenset is hashable, so you can have frozenset elements inside a set.\n\nIn addition to enforcing uniqueness, the set types implement many set operations as infix operators, so, given two sets a and b, a | b returns their union, a & b computes the intersection, a - b the difference, and a ^ b the symmetric difference. Smart use of set operations can reduce both the line count and the execution time of Python programs, at the same time making code easier to read and reason about—by remov‐ ing loops and conditional logic.\n\nFor example, imagine you have a large set of email addresses (the haystack) and a smaller set of addresses (the needles) and you need to count how many needles occur in the haystack. Thanks to set intersection (the & operator) you can code that in a simple line (see Example 3-12).\n\nExample 3-12. Count occurrences of needles in a haystack, both of type set\n\nfound = len(needles & haystack)\n\nWithout the intersection operator, you’d have to write Example 3-13 to accomplish the same task as Example 3-12.\n\nExample 3-13. Count occurrences of needles in a haystack (same end result as Example 3-12)\n\nfound = 0 for n in needles: if n in haystack: found += 1\n\nExample 3-12 runs slightly faster than Example 3-13. On the other hand, Example 3-13 works for any iterable objects needles and haystack, while Example 3-12 requires that both be sets. But, if you don’t have sets on hand, you can always build them on the fly, as shown in Example 3-14.\n\n104\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1903,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 135,
      "content": "Example 3-14. Count occurrences of needles in a haystack; these lines work for any iterable types\n\nfound = len(set(needles) & set(haystack))\n\n# another way: found = len(set(needles).intersection(haystack))\n\nOf course, there is an extra cost involved in building the sets in Example 3-14, but if either the needles or the haystack is already a set, the alternatives in Example 3-14 may be cheaper than Example 3-13.\n\nAny one of the preceding examples are capable of searching 1,000 elements in a hay stack of 10,000,000 items in about 0.3 milliseconds—that’s close to 0.3 microseconds per element.\n\nBesides the extremely fast membership test (thanks to the underlying hash table), the set and frozenset built-in types provide a rich API to create new sets or, in the case of set, to change existing ones. We will discuss the operations shortly, but first a note about syntax.\n\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nSyntax Quirk\n\nDon’t forget that to create an empty set, you should use the con‐ structor without an argument: set(). If you write {}, you’re creat‐ ing an empty dict—this hasn’t changed in Python 3.\n\nIn Python 3, the standard string representation of sets always uses the {…} notation, except for the empty set:\n\n>>> s = {1} >>> type(s) <class 'set'> >>> s {1} >>> s.pop() 1 >>> s set()\n\nSet Theory\n\n|\n\n105",
      "content_length": 1492,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 136,
      "content": "Literal set syntax like {1, 2, 3} is both faster and more readable than calling the constructor (e.g., set([1, 2, 3])). The latter form is slower because, to evaluate it, Python has to look up the set name to fetch the constructor, then build a list, and finally pass it to the constructor. In contrast, to process a literal like {1, 2, 3}, Python runs a specialized BUILD_SET bytecode.10\n\nThere is no special syntax to represent frozenset literals—they must be created by calling the constructor. The standard string representation in Python 3 looks like a frozenset constructor call. Note the output in the console session:\n\n>>> frozenset(range(10)) frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})\n\nSpeaking of syntax, the idea of listcomps was adapted to build sets as well.\n\nSet Comprehensions Set comprehensions (setcomps) were added way back in Python 2.7, together with the dictcomps that we saw in “dict Comprehensions” on page 79. Example 3-15 shows how.\n\nExample 3-15. Build a set of Latin-1 characters that have the word “SIGN” in their Unicode names\n\n>>> from unicodedata import name >>> {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i),'')} {'§', '=', '¢', '#', '¤', '<', '¥', 'µ', '×', '$', '¶', '£', '©', '°', '+', '÷', '±', '>', '¬', '®', '%'}\n\nImport name function from unicodedata to obtain character names.\n\nBuild set of characters with codes from 32 to 255 that have the word 'SIGN' in their names.\n\nThe order of the output changes for each Python process, because of the salted hash mentioned in “What Is Hashable” on page 84.\n\nSyntax matters aside, let’s now consider the behavior of sets.\n\n10 This may be interesting, but is not super important. The speed up will happen only when a set literal is evalu‐ ated, and that happens at most once per Python process—when a module is initially compiled. If you’re curi‐ ous, import the dis function from the dis module and use it to disassemble the bytecodes for a set literal— e.g., dis('{1}')—and a set call—dis('set([1])')\n\n106\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 2035,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 137,
      "content": "Practical Consequences of How Sets Work The set and frozenset types are both implemented with a hash table. This has these effects:\n\nSet elements must be hashable objects. They must implement proper __hash__ and __eq__ methods as described in “What Is Hashable” on page 84.\n\nMembership testing is very efficient. A set may have millions of elements, but an element can be located directly by computing its hash code and deriving an index offset, with the possible overhead of a small number of tries to find a matching element or exhaust the search.\n\nSets have a significant memory overhead, compared to a low-level array pointers to its elements—which would be more compact but also much slower to search beyond a handful of elements.\n\nElement ordering depends on insertion order, but not in a useful or reliable way. If two elements are different but have the same hash code, their position depends on which element is added first.\n\nAdding elements to a set may change the order of existing elements. That’s because the algorithm becomes less efficient if the hash table is more than two- thirds full, so Python may need to move and resize the table as it grows. When this happens, elements are reinserted and their relative ordering may change.\n\nSee “Internals of sets and dicts” at fluentpython.com for details.\n\nLet’s now review the rich assortment of operations provided by sets.\n\nSet Operations Figure 3-2 gives an overview of the methods you can use on mutable and immutable sets. Many of them are special methods that overload operators, such as & and >=. Table 3-2 shows the math set operators that have corresponding operators or meth‐ ods in Python. Note that some operators and methods perform in-place changes on the target set (e.g., &=, difference_update, etc.). Such operations make no sense in the ideal world of mathematical sets, and are not implemented in frozenset.\n\nPractical Consequences of How Sets Work\n\n|\n\n107",
      "content_length": 1936,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 138,
      "content": "The infix operators in Table 3-2 require that both operands be sets, but all other methods take one or more iterable arguments. For example, to produce the union of four collections, a, b, c, and d, you can call a.union(b, c, d), where a must be a set, but b, c, and d can be iterables of any type that produce hashable items. If you need to create a new set with the union of four iterables, instead of updating an existing set, you can write {*a, *b, *c, *d} since Python 3.5 thanks to PEP 448—Additional Unpacking Generalizations.\n\nFigure 3-2. Simplified UML class diagram for MutableSet and its superclasses from collections.abc (names in italic are abstract classes and abstract methods; reverse operator methods omitted for brevity).\n\nTable 3-2. Mathematical set operations: these methods either produce a new set or update the target set in place, if it’s mutable\n\nMath symbol S ∩ Z\n\nPython operator\n\ns & z\n\nMethod\n\ns.__and__(z)\n\nDescription\n\nIntersection of s and z\n\nz & s\n\ns.__rand__(z)\n\nReversed & operator\n\ns.intersection(it, …)\n\nIntersection of s and all sets built from iterables it, etc.\n\ns &= z\n\ns.__iand__(z)\n\ns updated with intersection of s and z\n\ns.intersection_update(it, …)\n\ns updated with intersection of s and all sets built from iterables it, etc.\n\nS ∪ Z\n\ns | z\n\ns.__or__(z)\n\nUnion of s and z\n\nz | s\n\ns.__ror__(z)\n\nReversed |\n\ns.union(it, …)\n\nUnion of s and all sets built from iterables it, etc.\n\n108\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1462,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 139,
      "content": "Math symbol\n\nPython operator\n\nMethod\n\nDescription\n\ns |= z\n\ns.__ior__(z)\n\ns updated with union of s and z\n\ns.update(it, …)\n\ns updated with union of s and all sets built from iterables it, etc.\n\nS \\ Z\n\ns - z\n\ns.__sub__(z)\n\nRelative complement or difference between s and z\n\nz - s\n\ns.__rsub__(z)\n\nReversed - operator\n\ns.difference(it, …)\n\nDifference between s and all sets built from iterables it, etc.\n\ns -= z\n\ns.__isub__(z)\n\ns updated with difference between s and z\n\ns.difference_update(it, …)\n\ns updated with difference between s and all sets built from iterables it, etc.\n\nS ∆ Z\n\ns ^ z\n\ns.__xor__(z)\n\nSymmetric difference (the complement of the intersection s & z)\n\nz ^ s\n\ns.__rxor__(z)\n\nReversed ^ operator\n\ns.symmetric_difference(it)\n\nComplement of s & set(it)\n\ns ^= z\n\ns.__ixor__(z)\n\ns updated with symmetric difference of s and z\n\ns.symmetric_differ ence_update(it, …)\n\ns updated with symmetric difference of s and all sets built from iterables it, etc.\n\nTable 3-3 lists set predicates: operators and methods that return True or False.\n\nTable 3-3. Set comparison operators and methods that return a bool\n\nMath symbol Python operator Method S ∩ Z = ∅\n\ns.isdisjoint(z)\n\nDescription s and z are disjoint (no elements in common)\n\ne ∈ S\n\ne in s\n\ns.__contains__(e) Element e is a member of s\n\nS ⊆ Z\n\ns <= z\n\ns.__le__(z)\n\ns is a subset of the z set\n\ns.issubset(it)\n\ns is a subset of the set built from the iterable it\n\nS ⊂ Z\n\ns < z\n\ns.__lt__(z)\n\ns is a proper subset of the z set\n\nS ⊇ Z\n\ns >= z\n\ns.__ge__(z)\n\ns is a superset of the z set\n\ns.issuperset(it)\n\ns is a superset of the set built from the iterable it\n\nS ⊃ Z\n\ns > z\n\ns.__gt__(z)\n\ns is a proper superset of the z set\n\nIn addition to the operators and methods derived from math set theory, the set types implement other methods of practical use, summarized in Table 3-4.\n\nPractical Consequences of How Sets Work\n\n|\n\n109",
      "content_length": 1875,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 140,
      "content": "Table 3-4. Additional set methods\n\nset\n\nfrozenset\n\ns.add(e)\n\n\n\nAdd element e to s\n\ns.clear()\n\n\n\nRemove all elements of s\n\ns.copy()\n\n●\n\nShallow copy of s\n\ns.discard(e) ●\n\nRemove element e from s if it is present\n\ns.__iter__() ● ●\n\nGet iterator over s\n\ns.__len__()\n\n●\n\nlen(s)\n\ns.pop()\n\n\n\nRemove and return an element from s, raising KeyError if s is empty\n\ns.remove(e)\n\n\n\nRemove element e from s, raising KeyError if e not in s\n\nThis completes our overview of the features of sets. As promised in “Dictionary Views” on page 101, we’ll now see how two of the dictionary view types behave very much like a frozenset.\n\nSet Operations on dict Views Table 3-5 shows that the view objects returned by the dict methods .keys() and .items() are remarkably similar to frozenset.\n\nTable 3-5. Methods implemented by frozenset, dict_keys, and dict_items\n\nfrozenset dict_keys dict_items Description\n\ns.__and__(z)\n\n\n\n\n\n\n\ns & z (intersection of s and z)\n\ns.__rand__(z)\n\n\n\n\n\n\n\nReversed & operator\n\ns.__contains__()\n\n\n\n\n\n\n\ne in s\n\ns.copy()\n\n\n\nShallow copy of s\n\ns.difference(it, …)\n\n\n\nDifference between s and iterables it, etc.\n\ns.intersection(it, …)\n\n\n\nIntersection of s and iterables it, etc.\n\ns.isdisjoint(z)\n\n\n\n\n\n\n\ns and z are disjoint (no elements in common)\n\ns.issubset(it)\n\n\n\ns is a subset of iterable it\n\ns.issuperset(it)\n\n\n\ns is a superset of iterable it\n\ns.__iter__()\n\n\n\n\n\n\n\nGet iterator over s\n\ns.__len__()\n\n\n\n\n\n\n\nlen(s)\n\ns.__or__(z)\n\n\n\n\n\n\n\ns | z (union of s and z)\n\ns.__ror__()\n\n\n\n\n\n\n\nReversed | operator\n\ns.__reversed__()\n\n\n\n\n\nGet iterator over s in reverse order\n\ns.__rsub__(z)\n\n\n\n\n\n\n\nReversed - operator\n\ns.__sub__(z)\n\n\n\n\n\n\n\ns - z (difference between s and z)\n\n110\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1698,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 141,
      "content": "frozenset dict_keys dict_items Description\n\ns.symmetric_differ ence(it)\n\n\n\nComplement of s & set(it)\n\ns.union(it, …)\n\n\n\nUnion of s and iterables it, etc.\n\ns.__xor__()\n\n\n\n\n\n\n\ns ^ z (symmetric difference of s and z)\n\ns.__rxor__()\n\n\n\n\n\n\n\nReversed ^ operator\n\nIn particular, dict_keys and dict_items implement the special methods to support the powerful set operators & (intersection), | (union), - (difference), and ^ (symmet‐ ric difference).\n\nFor example, using & is easy to get the keys that appear in two dictionaries:\n\n>>> d1 = dict(a=1, b=2, c=3, d=4) >>> d2 = dict(b=20, d=40, e=50) >>> d1.keys() & d2.keys() {'b', 'd'}\n\nNote that the return value of & is a set. Even better: the set operators in dictionary views are compatible with set instances. Check this out:\n\n>>> s = {'a', 'e', 'i'} >>> d1.keys() & s {'a'} >>> d1.keys() | s {'a', 'c', 'b', 'd', 'i', 'e'}\n\nA dict_items view only works as a set if all values in the dict are hashable. Attempting set operations on a dict_items view with an unhashable value raises TypeError: unhashable type 'T', with T as the type of the offending value. On the other hand, a dict_keys view can always be used as a set, because every key is hashable—by definition.\n\nUsing set operators with views will save a lot of loops and ifs when inspecting the contents of dictionaries in your code. Let Python’s efficient implementation in C work for you!\n\nWith this, we can wrap up this chapter.\n\nSet Operations on dict Views\n\n|\n\n111",
      "content_length": 1469,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 142,
      "content": "Chapter Summary Dictionaries are a keystone of Python. Over the years, the familiar {k1: v1, k2: v2} literal syntax was enhanced to support unpacking with **, pattern matching, as well as dict comprehensions.\n\nBeyond the basic dict, the standard library offers handy, ready-to-use specialized mappings like defaultdict, ChainMap, and Counter, all defined in the collections module. With the new dict implementation, OrderedDict is not as useful as before, but should remain in the standard library for backward compatibility—and has spe‐ cific characteristics that dict doesn’t have, such as taking into account key ordering in == comparisons. Also in the collections module is the UserDict, an easy to use base class to create custom mappings.\n\nTwo powerful methods available in most mappings are setdefault and update. The setdefault method can update items holding mutable values—for example, in a dict of list values—avoiding a second search for the same key. The update method allows bulk insertion or overwriting of items from any other mapping, from iterables providing (key, value) pairs, and from keyword arguments. Mapping constructors also use update internally, allowing instances to be initialized from mappings, itera‐ bles, or keyword arguments. Since Python 3.9, we can also use the |= operator to update a mapping, and the | operator to create a new one from the union of two mappings.\n\nA clever hook in the mapping API is the __missing__ method, which lets you cus‐ tomize what happens when a key is not found when using the d[k] syntax that invokes __getitem__.\n\nThe collections.abc module provides the Mapping and MutableMapping abstract base classes as standard interfaces, useful for runtime type checking. The Mapping ProxyType from the types module creates an immutable façade for a mapping you want to protect from accidental change. There are also ABCs for Set and MutableSet.\n\nDictionary views were a great addition in Python 3, eliminating the memory over‐ head of the Python 2 .keys(), .values(), and .items() methods that built lists duplicating data in the target dict instance. In addition, the dict_keys and dict_items classes support the most useful operators and methods of frozenset.\n\n112\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 2261,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 143,
      "content": "Further Reading In The Python Standard Library documentation, “collections—Container datatypes”, includes examples and practical recipes with several mapping types. The Python source code for the module Lib/collections/__init__.py is a great reference for anyone who wants to create a new mapping type or grok the logic of the existing ones. Chap‐ ter 1 of the Python Cookbook, 3rd ed. (O’Reilly) by David Beazley and Brian K. Jones has 20 handy and insightful recipes with data structures—the majority using dict in clever ways.\n\nGreg Gandenberger advocates for the continued use of collections.OrderedDict, on the grounds that “explicit is better than implicit,” backward compatibility, and the fact that some tools and libraries assume the ordering of dict keys is irrelevant—his post: “Python Dictionaries Are Now Ordered. Keep Using OrderedDict”.\n\nPEP 3106—Revamping dict.keys(), .values() and .items() is where Guido van Rossum presented the dictionary views feature for Python 3. In the abstract, he wrote that the idea came from the Java Collections Framework.\n\nPyPy was the first Python interpreter to implement Raymond Hettinger’s proposal of compact dicts, and they blogged about it in “Faster, more memory efficient and more ordered dictionaries on PyPy”, acknowledging that a similar layout was adopted in PHP 7, described in PHP’s new hashtable implementation. It’s always great when cre‐ ators cite prior art.\n\nAt PyCon 2017, Brandon Rhodes presented “The Dictionary Even Mightier”, a sequel to his classic animated presentation “The Mighty Dictionary”—including animated hash collisions! Another up-to-date, but more in-depth video on the internals of Python’s dict is “Modern Dictionaries” by Raymond Hettinger, where he tells that after initially failing to sell compact dicts to the CPython core devs, he lobbied the PyPy team, they adopted it, the idea gained traction, and was finally contributed to CPython 3.6 by INADA Naoki. For all details, check out the extensive comments in the CPython code for Objects/dictobject.c and the design document Objects/dict‐ notes.txt.\n\nThe rationale for adding sets to Python is documented in PEP 218—Adding a Built- In Set Object Type. When PEP 218 was approved, no special literal syntax was adop‐ ted for sets. The set literals were created for Python 3 and backported to Python 2.7, along with dict and set comprehensions. At PyCon 2019, I presented “Set Practice: learning from Python’s set types” describing use cases of sets in real programs, cover‐ ing their API design, and the implementation of uintset, a set class for integer ele‐ ments using a bit vector instead of a hash table, inspired by an example in Chapter 6 of the excellent The Go Programming Language, by Alan Donovan and Brian Ker‐ nighan (Addison-Wesley).\n\nFurther Reading\n\n|\n\n113",
      "content_length": 2813,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 144,
      "content": "IEEE’s Spectrum magazine has a story about Hans Peter Luhn, a prolific inventor who patented a punched card deck to select cocktail recipes depending on ingredi‐ ents available, among other diverse inventions including…hash tables! See “Hans Peter Luhn and the Birth of the Hashing Algorithm”.\n\nSoapbox\n\nSyntactic Sugar\n\nMy friend Geraldo Cohen once remarked that Python is “simple and correct.”\n\nProgramming language purists like to dismiss syntax as unimportant.\n\nSyntactic sugar causes cancer of the semicolon.\n\n—Alan Perlis\n\nSyntax is the user interface of a programming language, so it does matter in practice.\n\nBefore finding Python, I did some web programming using Perl and PHP. The syntax for mappings in these languages is very useful, and I badly miss it whenever I have to use Java or C.\n\nA good literal syntax for mappings is very convenient for configuration, table-driven implementations, and to hold data for prototyping and testing. That’s one lesson the designers of Go learned from dynamic languages. The lack of a good way to express structured data in code pushed the Java community to adopt the verbose and overly complex XML as a data format.\n\nJSON was proposed as “The Fat-Free Alternative to XML” and became a huge suc‐ cess, replacing XML in many contexts. A concise syntax for lists and dictionaries makes an excellent data interchange format.\n\nPHP and Ruby imitated the hash syntax from Perl, using => to link keys to values. JavaScript uses : like Python. Why use two characters when one is readable enough?\n\nJSON came from JavaScript, but it also happens to be an almost exact subset of Python syntax. JSON is compatible with Python except for the spelling of the values true, false, and null.\n\nArmin Ronacher tweeted that he likes to hack Python’s global namespace to add JSON-compatible aliases for Python’s True, False, and None so he can paste JSON directly in the console. The basic idea:\n\n114\n\n|\n\nChapter 3: Dictionaries and Sets",
      "content_length": 1965,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 145,
      "content": ">>> true, false, null = True, False, None >>> fruit = { ... \"type\": \"banana\", ... \"avg_weight\": 123.2, ... \"edible_peel\": false, ... \"species\": [\"acuminata\", \"balbisiana\", \"paradisiaca\"], ... \"issues\": null, ... } >>> fruit {'type': 'banana', 'avg_weight': 123.2, 'edible_peel': False, 'species': ['acuminata', 'balbisiana', 'paradisiaca'], 'issues': None}\n\nThe syntax everybody now uses for exchanging data is Python’s dict and list syn‐ tax. Now we have the nice syntax with the convenience of preserved insertion order.\n\nSimple and correct.\n\nFurther Reading\n\n|\n\n115",
      "content_length": 568,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 147,
      "content": "CHAPTER 4 Unicode Text Versus Bytes\n\nHumans use text. Computers speak bytes.\n\n—Esther Nam and Travis Fischer, “Character Encoding and Unicode in Python”1\n\nPython 3 introduced a sharp distinction between strings of human text and sequen‐ ces of raw bytes. Implicit conversion of byte sequences to Unicode text is a thing of the past. This chapter deals with Unicode strings, binary sequences, and the encod‐ ings used to convert between them.\n\nDepending on the kind of work you do with Python, you may think that understand‐ ing Unicode is not important. That’s unlikely, but anyway there is no escaping the str versus byte divide. As a bonus, you’ll find that the specialized binary sequence types provide features that the “all-purpose” Python 2 str type did not have.\n\nIn this chapter, we will visit the following topics:\n\nCharacters, code points, and byte representations • Unique features of binary sequences: bytes, bytearray, and memoryview\n\nEncodings for full Unicode and legacy character sets\n\nAvoiding and dealing with encoding errors\n\nBest practices when handling text files\n\nThe default encoding trap and standard I/O issues\n\nSafe Unicode text comparisons with normalization\n\n1 Slide 12 of PyCon 2014 talk “Character Encoding and Unicode in Python” (slides, video).\n\n117",
      "content_length": 1281,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 148,
      "content": "Utility functions for normalization, case folding, and brute-force diacritic removal\n\nProper sorting of Unicode text with locale and the pyuca library\n\nCharacter metadata in the Unicode database • Dual-mode APIs that handle str and bytes\n\nWhat’s New in This Chapter Support for Unicode in Python 3 has been comprehensive and stable, so the most notable addition is “Finding Characters by Name” on page 151, describing a utility for searching the Unicode database—a great way to find circled digits and smiling cats from the command line.\n\nOne minor change worth mentioning is the Unicode support on Windows, which is better and simpler since Python 3.6, as we’ll see in “Beware of Encoding Defaults” on page 134.\n\nLet’s start with the not-so-new, but fundamental concepts of characters, code points, and bytes.\n\nFor the second edition, I expanded the section about the struct module and published it online at “Parsing binary records with struct”, in the fluentpython.com companion website.\n\nThere you will also find “Building Multi-character Emojis”, describing how to make country flags, rainbow flags, people with different skin tones, and diverse family icons by combining Uni‐ code characters.\n\nCharacter Issues The concept of “string” is simple enough: a string is a sequence of characters. The problem lies in the definition of “character.”\n\nIn 2021, the best definition of “character” we have is a Unicode character. Accord‐ ingly, the items we get out of a Python 3 str are Unicode characters, just like the items of a unicode object in Python 2—and not the raw bytes we got from a Python 2 str.\n\nThe Unicode standard explicitly separates the identity of characters from specific byte representations:\n\n118\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1756,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 149,
      "content": "The identity of a character—its code point—is a number from 0 to 1,114,111 (base 10), shown in the Unicode standard as 4 to 6 hex digits with a “U+” prefix, from U+0000 to U+10FFFF. For example, the code point for the letter A is U +0041, the Euro sign is U+20AC, and the musical symbol G clef is assigned to code point U+1D11E. About 13% of the valid code points have characters assigned to them in Unicode 13.0.0, the standard used in Python 3.10.0b4.\n\nThe actual bytes that represent a character depend on the encoding in use. An encoding is an algorithm that converts code points to byte sequences and vice versa. The code point for the letter A (U+0041) is encoded as the single byte \\x41 in the UTF-8 encoding, or as the bytes \\x41\\x00 in UTF-16LE encoding. As another example, UTF-8 requires three bytes—\\xe2\\x82\\xac—to encode the Euro sign (U+20AC), but in UTF-16LE the same code point is encoded as two bytes: \\xac\\x20.\n\nConverting from code points to bytes is encoding; converting from bytes to code points is decoding. See Example 4-1.\n\nExample 4-1. Encoding and decoding\n\n>>> s = 'café' >>> len(s) 4 >>> b = s.encode('utf8') >>> b b'caf\\xc3\\xa9' >>> len(b) 5 >>> b.decode('utf8') 'café'\n\nThe str 'café' has four Unicode characters.\n\nEncode str to bytes using UTF-8 encoding.\n\nbytes literals have a b prefix.\n\nbytes b has five bytes (the code point for “é” is encoded as two bytes in UTF-8).\n\nDecode bytes to str using UTF-8 encoding.\n\nCharacter Issues\n\n|\n\n119",
      "content_length": 1471,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 150,
      "content": "If you need a memory aid to help distinguish .decode() from .encode(), convince yourself that byte sequences can be cryptic machine core dumps, while Unicode str objects are “human” text. Therefore, it makes sense that we decode bytes to str to get human-readable text, and we encode str to bytes for storage or transmission.\n\nAlthough the Python 3 str is pretty much the Python 2 unicode type with a new name, the Python 3 bytes is not simply the old str renamed, and there is also the closely related bytearray type. So it is worthwhile to take a look at the binary sequence types before advancing to encoding/decoding issues.\n\nByte Essentials The new binary sequence types are unlike the Python 2 str in many regards. The first thing to know is that there are two basic built-in types for binary sequences: the immutable bytes type introduced in Python 3 and the mutable bytearray, added way back in Python 2.6.2 The Python documentation sometimes uses the generic term “byte string” to refer to both bytes and bytearray. I avoid that confusing term.\n\nEach item in bytes or bytearray is an integer from 0 to 255, and not a one-character string like in the Python 2 str. However, a slice of a binary sequence always produces a binary sequence of the same type—including slices of length 1. See Example 4-2.\n\nExample 4-2. A five-byte sequence as bytes and as bytearray\n\n>>> cafe = bytes('café', encoding='utf_8') >>> cafe b'caf\\xc3\\xa9' >>> cafe[0] 99 >>> cafe[:1] b'c' >>> cafe_arr = bytearray(cafe) >>> cafe_arr bytearray(b'caf\\xc3\\xa9') >>> cafe_arr[-1:] bytearray(b'\\xa9')\n\nbytes can be built from a str, given an encoding.\n\nEach item is an integer in range(256).\n\n2 Python 2.6 and 2.7 also had bytes, but it was just an alias to the str type.\n\n120\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1794,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 151,
      "content": "Slices of bytes are also bytes—even slices of a single byte.\n\nThere is no literal syntax for bytearray: they are shown as bytearray() with a bytes literal as argument.\n\nA slice of bytearray is also a bytearray.\n\nThe fact that my_bytes[0] retrieves an int but my_bytes[:1] returns a bytes sequence of length 1 is only surprising because we are used to Python’s str type, where s[0] == s[:1]. For all other sequence types in Python, 1 item is not the same as a slice of length 1.\n\nAlthough binary sequences are really sequences of integers, their literal notation reflects the fact that ASCII text is often embedded in them. Therefore, four different displays are used, depending on each byte value:\n\nFor bytes with decimal codes 32 to 126—from space to ~ (tilde)—the ASCII char‐ acter itself is used.\n\nFor bytes corresponding to tab, newline, carriage return, and \\, the escape sequences \\t, \\n, \\r, and \\\\ are used.\n\nIf both string delimiters ' and \" appear in the byte sequence, the whole sequence is delimited by ', and any ' inside are escaped as \\'.3\n\nFor other byte values, a hexadecimal escape sequence is used (e.g., \\x00 is the null byte).\n\nThat is why in Example 4-2 you see b'caf\\xc3\\xa9': the first three bytes b'caf' are in the printable ASCII range, the last two are not.\n\nBoth bytes and bytearray support every str method except those that do format‐ ting (format, format_map) and those that depend on Unicode data, including case fold, isdecimal, isidentifier, isnumeric, isprintable, and encode. This means that you can use familiar string methods like endswith, replace, strip, translate, upper, and dozens of others with binary sequences—only using bytes and not str arguments. In addition, the regular expression functions in the re module also work\n\n3 Trivia: the ASCII “single quote” character that Python uses by default as the string delimiter is actually named APOSTROPHE in the Unicode standard. The real single quotes are asymmetric: left is U+2018 and right is U+2019.\n\nByte Essentials\n\n|\n\n121",
      "content_length": 2020,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 152,
      "content": "on binary sequences, if the regex is compiled from a binary sequence instead of a str. Since Python 3.5, the % operator works with binary sequences again.4\n\nBinary sequences have a class method that str doesn’t have, called fromhex, which builds a binary sequence by parsing pairs of hex digits optionally separated by spaces:\n\n>>> bytes.fromhex('31 4B CE A9') b'1K\\xce\\xa9'\n\nThe other ways of building bytes or bytearray instances are calling their construc‐ tors with:\n\nA str and an encoding keyword argument\n\nAn iterable providing items with values from 0 to 255 • An object that implements the buffer protocol (e.g., bytes, bytearray, memory view, array.array) that copies the bytes from the source object to the newly cre‐ ated binary sequence\n\nUntil Python 3.5, it was also possible to call bytes or bytearray with a single integer to create a binary sequence of that size initial‐ ized with null bytes. This signature was deprecated in Python 3.5 and removed in Python 3.6. See PEP 467—Minor API improve‐ ments for binary sequences.\n\nBuilding a binary sequence from a buffer-like object is a low-level operation that may involve type casting. See a demonstration in Example 4-3.\n\nExample 4-3. Initializing bytes from the raw data of an array\n\n>>> import array >>> numbers = array.array('h', [-2, -1, 0, 1, 2]) >>> octets = bytes(numbers) >>> octets b'\\xfe\\xff\\xff\\xff\\x00\\x00\\x01\\x00\\x02\\x00'\n\nTypecode 'h' creates an array of short integers (16 bits).\n\noctets holds a copy of the bytes that make up numbers.\n\nThese are the 10 bytes that represent the 5 short integers.\n\n4 It did not work in Python 3.0 to 3.4, causing much pain to developers dealing with binary data. The reversal is\n\ndocumented in PEP 461—Adding % formatting to bytes and bytearray.\n\n122\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1804,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 153,
      "content": "Creating a bytes or bytearray object from any buffer-like source will always copy the bytes. In contrast, memoryview objects let you share memory between binary data structures, as we saw in “Memory Views” on page 62.\n\nAfter this basic exploration of binary sequence types in Python, let’s see how they are converted to/from strings.\n\nBasic Encoders/Decoders The Python distribution bundles more than 100 codecs (encoder/decoders) for text to byte conversion and vice versa. Each codec has a name, like 'utf_8', and often aliases, such as 'utf8', 'utf-8', and 'U8', which you can use as the encoding argu‐ ment in functions like open(), str.encode(), bytes.decode(), and so on. Example 4-4 shows the same text encoded as three different byte sequences.\n\nExample 4-4. The string “El Niño” encoded with three codecs producing very different byte sequences\n\n>>> for codec in ['latin_1', 'utf_8', 'utf_16']: ... print(codec, 'El Niño'.encode(codec), sep='\\t') ... latin_1 b'El Ni\\xf1o' utf_8 b'El Ni\\xc3\\xb1o' utf_16 b'\\xff\\xfeE\\x00l\\x00 \\x00N\\x00i\\x00\\xf1\\x00o\\x00'\n\nFigure 4-1 demonstrates a variety of codecs generating bytes from characters like the letter “A” through the G-clef musical symbol. Note that the last three encodings are variable-length, multibyte encodings.\n\nFigure 4-1. Twelve characters, their code points, and their byte representation (in hex) in 7 different encodings (asterisks indicate that the character cannot be represented in that encoding).\n\nBasic Encoders/Decoders\n\n|\n\n123",
      "content_length": 1500,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 154,
      "content": "All those asterisks in Figure 4-1 make clear that some encodings, like ASCII and even the multibyte GB2312, cannot represent every Unicode character. The UTF encod‐ ings, however, are designed to handle every Unicode code point.\n\nThe encodings shown in Figure 4-1 were chosen as a representative sample:\n\nlatin1 a.k.a. iso8859_1\n\nImportant because it is the basis for other encodings, such as cp1252 and Uni‐ code itself (note how the latin1 byte values appear in the cp1252 bytes and even in the code points).\n\ncp1252\n\nA useful latin1 superset created by Microsoft, adding useful symbols like curly quotes and € (euro); some Windows apps call it “ANSI,” but it was never a real ANSI standard.\n\ncp437\n\nThe original character set of the IBM PC, with box drawing characters. Incom‐ patible with latin1, which appeared later.\n\ngb2312\n\nLegacy standard to encode the simplified Chinese ideographs used in mainland China; one of several widely deployed multibyte encodings for Asian languages.\n\nutf-8\n\nThe most common 8-bit encoding on the web, by far, as of July 2021, “W3Techs: Usage statistics of character encodings for websites” claims that 97% of sites use UTF-8, up from 81.4% when I wrote this paragraph in the first edition of this book in September 2014.\n\nutf-16le\n\nOne form of the UTF 16-bit encoding scheme; all UTF-16 encodings support code points beyond U+FFFF through escape sequences called “surrogate pairs.”\n\nUTF-16 superseded the original 16-bit Unicode 1.0 encoding— UCS-2—way back in 1996. UCS-2 is still used in many systems despite being deprecated since the last century because it only sup‐ ports code points up to U+FFFF. As of 2021, more than 57% of the allocated code points are above U+FFFF, including the all- important emojis.\n\nWith this overview of common encodings now complete, we move to handling issues in encoding and decoding operations.\n\n124\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1915,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 155,
      "content": "Understanding Encode/Decode Problems Although there is a generic UnicodeError exception, the error reported by Python is usually more specific: either a UnicodeEncodeError (when converting str to binary sequences) or a UnicodeDecodeError (when reading binary sequences into str). Loading Python modules may also raise SyntaxError when the source encoding is unexpected. We’ll show how to handle all of these errors in the next sections.\n\nThe first thing to note when you get a Unicode error is the exact type of the exception. Is it a UnicodeEncodeError, a UnicodeDeco deError, or some other error (e.g., SyntaxError) that mentions an encoding problem? To solve the problem, you have to understand it first.\n\nCoping with UnicodeEncodeError Most non-UTF codecs handle only a small subset of the Unicode characters. When converting text to bytes, if a character is not defined in the target encoding, Unico deEncodeError will be raised, unless special handling is provided by passing an errors argument to the encoding method or function. The behavior of the error han‐ dlers is shown in Example 4-5.\n\nExample 4-5. Encoding to bytes: success and error handling\n\n>>> city = 'São Paulo' >>> city.encode('utf_8') b'S\\xc3\\xa3o Paulo' >>> city.encode('utf_16') b'\\xff\\xfeS\\x00\\xe3\\x00o\\x00 \\x00P\\x00a\\x00u\\x00l\\x00o\\x00' >>> city.encode('iso8859_1') b'S\\xe3o Paulo' >>> city.encode('cp437') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"/.../lib/python3.4/encodings/cp437.py\", line 12, in encode return codecs.charmap_encode(input,errors,encoding_map) UnicodeEncodeError: 'charmap' codec can't encode character '\\xe3' in position 1: character maps to <undefined> >>> city.encode('cp437', errors='ignore') b'So Paulo' >>> city.encode('cp437', errors='replace') b'S?o Paulo' >>> city.encode('cp437', errors='xmlcharrefreplace') b'S&#227;o Paulo'\n\nUnderstanding Encode/Decode Problems\n\n|\n\n125",
      "content_length": 1913,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 156,
      "content": "The UTF encodings handle any str.\n\niso8859_1 also works for the 'São Paulo' string.\n\ncp437 can’t encode the 'ã' (“a” with tilde). The default error handler —'strict'—raises UnicodeEncodeError.\n\nThe error='ignore' handler skips characters that cannot be encoded; this is usually a very bad idea, leading to silent data loss.\n\nWhen encoding, error='replace' substitutes unencodable characters with '?'; data is also lost, but users will get a clue that something is amiss.\n\n'xmlcharrefreplace' replaces unencodable characters with an XML entity. If you can’t use UTF, and you can’t afford to lose data, this is the only option.\n\nThe codecs error handling is extensible. You may register extra strings for the errors argument by passing a name and an error handling function to the codecs.register_error function. See the codecs.register_error documentation.\n\nASCII is a common subset to all the encodings that I know about, therefore encoding should always work if the text is made exclusively of ASCII characters. Python 3.7 added a new boolean method str.isascii() to check whether your Unicode text is 100% pure ASCII. If it is, you should be able to encode it to bytes in any encoding without raising UnicodeEncodeError.\n\nCoping with UnicodeDecodeError Not every byte holds a valid ASCII character, and not every byte sequence is valid UTF-8 or UTF-16; therefore, when you assume one of these encodings while convert‐ ing a binary sequence to text, you will get a UnicodeDecodeError if unexpected bytes are found.\n\nOn the other hand, many legacy 8-bit encodings like 'cp1252', 'iso8859_1', and 'koi8_r' are able to decode any stream of bytes, including random noise, without reporting errors. Therefore, if your program assumes the wrong 8-bit encoding, it will silently decode garbage.\n\n126\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1834,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 157,
      "content": "Garbled characters are known as gremlins or mojibake (文字化け —Japanese for “transformed text”).\n\nExample 4-6 illustrates how using the wrong codec may produce gremlins or a UnicodeDecodeError.\n\nExample 4-6. Decoding from str to bytes: success and error handling\n\n>>> octets = b'Montr\\xe9al' >>> octets.decode('cp1252') 'Montréal' >>> octets.decode('iso8859_7') 'Montrιal' >>> octets.decode('koi8_r') 'MontrИal' >>> octets.decode('utf_8') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe9 in position 5: invalid continuation byte >>> octets.decode('utf_8', errors='replace') 'Montr�al'\n\nThe word “Montréal” encoded as latin1; '\\xe9' is the byte for “é”.\n\nDecoding with Windows 1252 works because it is a superset of latin1.\n\nISO-8859-7 is intended for Greek, so the '\\xe9' byte is misinterpreted, and no error is issued.\n\nKOI8-R is for Russian. Now '\\xe9' stands for the Cyrillic letter “И”.\n\nThe 'utf_8' codec detects that octets is not valid UTF-8, and raises UnicodeDe codeError.\n\nUsing 'replace' error handling, the \\xe9 is replaced by “�” (code point U+FFFD), the official Unicode REPLACEMENT CHARACTER intended to represent unknown characters.\n\nUnderstanding Encode/Decode Problems\n\n|\n\n127",
      "content_length": 1270,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 158,
      "content": "SyntaxError When Loading Modules with Unexpected Encoding UTF-8 is the default source encoding for Python 3, just as ASCII was the default for Python 2. If you load a .py module containing non-UTF-8 data and no encoding dec‐ laration, you get a message like this:\n\nSyntaxError: Non-UTF-8 code starting with '\\xe1' in file ola.py on line 1, but no encoding declared; see https://python.org/dev/peps/pep-0263/ for details\n\nBecause UTF-8 is widely deployed in GNU/Linux and macOS systems, a likely sce‐ nario is opening a .py file created on Windows with cp1252. Note that this error hap‐ pens even in Python for Windows, because the default encoding for Python 3 source is UTF-8 across all platforms.\n\nTo fix this problem, add a magic coding comment at the top of the file, as shown in Example 4-7.\n\nExample 4-7. ola.py: “Hello, World!” in Portuguese\n\n# coding: cp1252\n\nprint('Olá, Mundo!')\n\nNow that Python 3 source code is no longer limited to ASCII and defaults to the excellent UTF-8 encoding, the best “fix” for source code in legacy encodings like 'cp1252' is to convert them to UTF-8 already, and not bother with the coding comments. If your editor does not support UTF-8, it’s time to switch.\n\nSuppose you have a text file, be it source code or poetry, but you don’t know its encoding. How do you detect the actual encoding? Answers in the next section.\n\nHow to Discover the Encoding of a Byte Sequence How do you find the encoding of a byte sequence? Short answer: you can’t. You must be told.\n\nSome communication protocols and file formats, like HTTP and XML, contain head‐ ers that explicitly tell us how the content is encoded. You can be sure that some byte streams are not ASCII because they contain byte values over 127, and the way UTF-8 and UTF-16 are built also limits the possible byte sequences.\n\n128\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1859,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 159,
      "content": "Leo’s Hack for Guessing UTF-8 Decoding (The next paragraphs come from a note left by tech reviewer Leonardo Rochael in the draft of this book.)\n\nThe way UTF-8 was designed, it’s almost impossible for a random sequence of bytes, or even a nonrandom sequence of bytes coming from a non-UTF-8 encoding, to be decoded accidentally as garbage in UTF-8, instead of raising UnicodeDecodeError.\n\nThe reasons for this are that UTF-8 escape sequences never use ASCII characters, and these escape sequences have bit patterns that make it very hard for random data to be valid UTF-8 by accident.\n\nSo if you can decode some bytes containing codes > 127 as UTF-8, it’s probably UTF-8.\n\nIn dealing with Brazilian online services, some of which were attached to legacy back‐ ends, I’ve had, on occasion, to implement a decoding strategy of trying to decode via UTF-8 and treat a UnicodeDecodeError by decoding via cp1252. It was ugly but effective.\n\nHowever, considering that human languages also have their rules and restrictions, once you assume that a stream of bytes is human plain text, it may be possible to sniff out its encoding using heuristics and statistics. For example, if b'\\x00' bytes are common, it is probably a 16- or 32-bit encoding, and not an 8-bit scheme, because null characters in plain text are bugs. When the byte sequence b'\\x20\\x00' appears often, it is more likely to be the space character (U+0020) in a UTF-16LE encoding, rather than the obscure U+2000 EN QUAD character—whatever that is.\n\nThat is how the package “Chardet—The Universal Character Encoding Detector” works to guess one of more than 30 supported encodings. Chardet is a Python library that you can use in your programs, but also includes a command-line utility, charde tect. Here is what it reports on the source file for this chapter:\n\n$ chardetect 04-text-byte.asciidoc 04-text-byte.asciidoc: utf-8 with confidence 0.99\n\nAlthough binary sequences of encoded text usually don’t carry explicit hints of their encoding, the UTF formats may prepend a byte order mark to the textual content. That is explained next.\n\nBOM: A Useful Gremlin In Example 4-4, you may have noticed a couple of extra bytes at the beginning of a UTF-16 encoded sequence. Here they are again:\n\nUnderstanding Encode/Decode Problems\n\n|\n\n129",
      "content_length": 2290,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 160,
      "content": ">>> u16 = 'El Niño'.encode('utf_16') >>> u16 b'\\xff\\xfeE\\x00l\\x00 \\x00N\\x00i\\x00\\xf1\\x00o\\x00'\n\nThe bytes are b'\\xff\\xfe'. That is a BOM—byte-order mark—denoting the “little- endian” byte ordering of the Intel CPU where the encoding was performed.\n\nOn a little-endian machine, for each code point the least significant byte comes first: the letter 'E', code point U+0045 (decimal 69), is encoded in byte offsets 2 and 3 as 69 and 0:\n\n>>> list(u16) [255, 254, 69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 111, 0]\n\nOn a big-endian CPU, the encoding would be reversed; 'E' would be encoded as 0 and 69.\n\nTo avoid confusion, the UTF-16 encoding prepends the text to be encoded with the special invisible character ZERO WIDTH NO-BREAK SPACE (U+FEFF). On a little- endian system, that is encoded as b'\\xff\\xfe' (decimal 255, 254). Because, by design, there is no U+FFFE character in Unicode, the byte sequence b'\\xff\\xfe' must mean the ZERO WIDTH NO-BREAK SPACE on a little-endian encoding, so the codec knows which byte ordering to use.\n\nThere is a variant of UTF-16—UTF-16LE—that is explicitly little-endian, and another one explicitly big-endian, UTF-16BE. If you use them, a BOM is not generated:\n\n>>> u16le = 'El Niño'.encode('utf_16le') >>> list(u16le) [69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 111, 0] >>> u16be = 'El Niño'.encode('utf_16be') >>> list(u16be) [0, 69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 111]\n\nIf present, the BOM is supposed to be filtered by the UTF-16 codec, so that you only get the actual text contents of the file without the leading ZERO WIDTH NO-BREAK SPACE. The Unicode standard says that if a file is UTF-16 and has no BOM, it should be assumed to be UTF-16BE (big-endian). However, the Intel x86 architecture is little-endian, so there is plenty of little-endian UTF-16 with no BOM in the wild.\n\nThis whole issue of endianness only affects encodings that use words of more than one byte, like UTF-16 and UTF-32. One big advantage of UTF-8 is that it produces the same byte sequence regardless of machine endianness, so no BOM is needed. Nevertheless, some Windows applications (notably Notepad) add the BOM to UTF-8 files anyway—and Excel depends on the BOM to detect a UTF-8 file, otherwise it assumes the content is encoded with a Windows code page. This UTF-8 encoding with BOM is called UTF-8-SIG in Python’s codec registry. The character U+FEFF\n\n130\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 2431,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 161,
      "content": "encoded in UTF-8-SIG is the three-byte sequence b'\\xef\\xbb\\xbf'. So if a file starts with those three bytes, it is likely to be a UTF-8 file with a BOM.\n\nCaleb’s Tip about UTF-8-SIG\n\nCaleb Hattingh—one of the tech reviewers—suggests always using the UTF-8-SIG codec when reading UTF-8 files. This is harmless because UTF-8-SIG reads files with or without a BOM correctly, and does not return the BOM itself. When writing, I recommend using UTF-8 for general interoperability. For example, Python scripts can be made executable in Unix systems if they start with the comment: #!/usr/bin/env python3. The first two bytes of the file must be b'#!' for that to work, but the BOM breaks that con‐ vention. If you have a specific requirement to export data to apps that need the BOM, use UTF-8-SIG but be aware that Python’s codecs documentation says: “In UTF-8, the use of the BOM is dis‐ couraged and should generally be avoided.”\n\nWe now move on to handling text files in Python 3.\n\nHandling Text Files The best practice for handling text I/O is the “Unicode sandwich” (Figure 4-2).5 This means that bytes should be decoded to str as early as possible on input (e.g., when opening a file for reading). The “filling” of the sandwich is the business logic of your program, where text handling is done exclusively on str objects. You should never be encoding or decoding in the middle of other processing. On output, the str are enco‐ ded to bytes as late as possible. Most web frameworks work like that, and we rarely touch bytes when using them. In Django, for example, your views should output Unicode str; Django itself takes care of encoding the response to bytes, using UTF-8 by default.\n\nPython 3 makes it easier to follow the advice of the Unicode sandwich, because the open() built-in does the necessary decoding when reading and encoding when writing files in text mode, so all you get from my_file.read() and pass to my_file.write(text) are str objects.\n\nTherefore, using text files is apparently simple. But if you rely on default encodings, you will get bitten.\n\n5 I first saw the term “Unicode sandwich” in Ned Batchelder’s excellent “Pragmatic Unicode” talk at US PyCon\n\n2012.\n\nHandling Text Files\n\n|\n\n131",
      "content_length": 2214,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 162,
      "content": "Figure 4-2. Unicode sandwich: current best practice for text processing.\n\nConsider the console session in Example 4-8. Can you spot the bug?\n\nExample 4-8. A platform encoding issue (if you try this on your machine, you may or may not see the problem)\n\n>>> open('cafe.txt', 'w', encoding='utf_8').write('café') 4 >>> open('cafe.txt').read() 'cafÃ©'\n\nThe bug: I specified UTF-8 encoding when writing the file but failed to do so when reading it, so Python assumed Windows default file encoding—code page 1252—and the trailing bytes in the file were decoded as characters 'Ã©' instead of 'é'.\n\nI ran Example 4-8 on Python 3.8.1, 64 bits, on Windows 10 (build 18363). The same statements running on recent GNU/Linux or macOS work perfectly well because their default encoding is UTF-8, giving the false impression that everything is fine. If the encoding argument was omitted when opening the file to write, the locale default encoding would be used, and we’d read the file correctly using the same encoding. But then this script would generate files with different byte contents depending on the platform or even depending on locale settings in the same platform, creating compatibility problems.\n\nCode that has to run on multiple machines or on multiple occa‐ sions should never depend on encoding defaults. Always pass an explicit encoding= argument when opening text files, because the default may change from one machine to the next, or from one day to the next.\n\n132\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1509,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 163,
      "content": "A curious detail in Example 4-8 is that the write function in the first statement reports that four characters were written, but in the next line five characters are read. Example 4-9 is an extended version of Example 4-8, explaining that and other details.\n\nExample 4-9. Closer inspection of Example 4-8 running on Windows reveals the bug and how to fix it\n\n>>> fp = open('cafe.txt', 'w', encoding='utf_8') >>> fp <_io.TextIOWrapper name='cafe.txt' mode='w' encoding='utf_8'> >>> fp.write('café') 4 >>> fp.close() >>> import os >>> os.stat('cafe.txt').st_size 5 >>> fp2 = open('cafe.txt') >>> fp2 <_io.TextIOWrapper name='cafe.txt' mode='r' encoding='cp1252'> >>> fp2.encoding 'cp1252' >>> fp2.read() 'cafÃ©' >>> fp3 = open('cafe.txt', encoding='utf_8') >>> fp3 <_io.TextIOWrapper name='cafe.txt' mode='r' encoding='utf_8'> >>> fp3.read() 'café' >>> fp4 = open('cafe.txt', 'rb') >>> fp4 <_io.BufferedReader name='cafe.txt'> >>> fp4.read() b'caf\\xc3\\xa9'\n\nBy default, open uses text mode and returns a TextIOWrapper object with a spe‐ cific encoding.\n\nThe write method on a TextIOWrapper returns the number of Unicode charac‐ ters written.\n\nos.stat says the file has 5 bytes; UTF-8 encodes 'é' as 2 bytes, 0xc3 and 0xa9.\n\nOpening a text file with no explicit encoding returns a TextIOWrapper with the encoding set to a default from the locale.\n\nA TextIOWrapper object has an encoding attribute that you can inspect: cp1252 in this case.\n\nHandling Text Files\n\n|\n\n133",
      "content_length": 1465,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 164,
      "content": "In the Windows cp1252 encoding, the byte 0xc3 is an “Ã” (A with tilde), and 0xa9 is the copyright sign.\n\nOpening the same file with the correct encoding.\n\nThe expected result: the same four Unicode characters for 'café'.\n\nThe 'rb' flag opens a file for reading in binary mode.\n\nThe returned object is a BufferedReader and not a TextIOWrapper.\n\nReading that returns bytes, as expected.\n\nDo not open text files in binary mode unless you need to analyze the file contents to determine the encoding—even then, you should be using Chardet instead of reinventing the wheel (see “How to Discover the Encoding of a Byte Sequence” on page 128). Ordinary code should only use binary mode to open binary files, like raster images.\n\nThe problem in Example 4-9 has to do with relying on a default setting while opening a text file. There are several sources for such defaults, as the next section shows.\n\nBeware of Encoding Defaults Several settings affect the encoding defaults for I/O in Python. See the default_encod‐ ings.py script in Example 4-10.\n\nExample 4-10. Exploring encoding defaults\n\nimport locale import sys\n\nexpressions = \"\"\" locale.getpreferredencoding() type(my_file) my_file.encoding sys.stdout.isatty() sys.stdout.encoding sys.stdin.isatty() sys.stdin.encoding sys.stderr.isatty() sys.stderr.encoding sys.getdefaultencoding() sys.getfilesystemencoding() \"\"\"\n\n134\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1409,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 165,
      "content": "my_file = open('dummy', 'w')\n\nfor expression in expressions.split(): value = eval(expression) print(f'{expression:>30} -> {value!r}')\n\nThe output of Example 4-10 on GNU/Linux (Ubuntu 14.04 to 19.10) and macOS (10.9 to 10.14) is identical, showing that UTF-8 is used everywhere in these systems:\n\n$ python3 default_encodings.py locale.getpreferredencoding() -> 'UTF-8' type(my_file) -> <class '_io.TextIOWrapper'> my_file.encoding -> 'UTF-8' sys.stdout.isatty() -> True sys.stdout.encoding -> 'utf-8' sys.stdin.isatty() -> True sys.stdin.encoding -> 'utf-8' sys.stderr.isatty() -> True sys.stderr.encoding -> 'utf-8' sys.getdefaultencoding() -> 'utf-8' sys.getfilesystemencoding() -> 'utf-8'\n\nOn Windows, however, the output is Example 4-11.\n\nExample 4-11. Default encodings on Windows 10 PowerShell (output is the same on cmd.exe)\n\n> chcp Active code page: 437 > python default_encodings.py locale.getpreferredencoding() -> 'cp1252' type(my_file) -> <class '_io.TextIOWrapper'> my_file.encoding -> 'cp1252' sys.stdout.isatty() -> True sys.stdout.encoding -> 'utf-8' sys.stdin.isatty() -> True sys.stdin.encoding -> 'utf-8' sys.stderr.isatty() -> True sys.stderr.encoding -> 'utf-8' sys.getdefaultencoding() -> 'utf-8' sys.getfilesystemencoding() -> 'utf-8'\n\nchcp shows the active code page for the console: 437.\n\nRunning default_encodings.py with output to console.\n\nlocale.getpreferredencoding() is the most important setting.\n\nText files use locale.getpreferredencoding() by default.\n\nHandling Text Files\n\n|\n\n135",
      "content_length": 1514,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 166,
      "content": "The output is going to the console, so sys.stdout.isatty() is True.\n\nNow, sys.stdout.encoding is not the same as the console code page reported by chcp!\n\nUnicode support in Windows itself, and in Python for Windows, got better since I wrote the first edition of this book. Example 4-11 used to report four different encod‐ ings in Python 3.4 on Windows 7. The encodings for stdout, stdin, and stderr used to be the same as the active code page reported by the chcp command, but now they’re all utf-8 thanks to PEP 528—Change Windows console encoding to UTF-8 implemented in Python 3.6, and Unicode support in PowerShell in cmd.exe (since Windows 1809 from October 2018).6 It’s weird that chcp and sys.stdout.encoding say different things when stdout is writing to the console, but it’s great that now we can print Unicode strings without encoding errors on Windows—unless the user redirects output to a file, as we’ll soon see. That does not mean all your favorite emo‐ jis will appear in the console: that also depends on the font the console is using.\n\nAnother change was PEP 529—Change Windows filesystem encoding to UTF-8, also implemented in Python 3.6, which changed the filesystem encoding (used to repre‐ sent names of directories and files) from Microsoft’s proprietary MBCS to UTF-8.\n\nHowever, if the output of Example 4-10 is redirected to a file, like this:\n\nZ:\\>python default_encodings.py > encodings.log\n\nthen, the value of sys.stdout.isatty() becomes False, and sys.stdout.encoding is set by locale.getpreferredencoding(), 'cp1252' in that machine—but sys.stdin.encoding and sys.stderr.encoding remain utf-8.\n\nIn Example 4-12 I use the '\\N{}' escape for Unicode literals, where we write the official name of the character inside the \\N{}. It’s rather verbose, but explicit and safe: Python raises SyntaxError if the name doesn’t exist—much better than writing a hex number that could be wrong, but you’ll only find out much later. You’d probably want to write a comment explaining the character codes anyway, so the verbosity of \\N{} is easy to accept.\n\nThis means that a script like Example 4-12 works when printing to the console, but may break when output is redirected to a file.\n\n6 Source: “Windows Command-Line: Unicode and UTF-8 Output Text Buffer”.\n\n136\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 2318,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 167,
      "content": "Example 4-12. stdout_check.py\n\nimport sys from unicodedata import name\n\nprint(sys.version) print() print('sys.stdout.isatty():', sys.stdout.isatty()) print('sys.stdout.encoding:', sys.stdout.encoding) print()\n\ntest_chars = [ '\\N{HORIZONTAL ELLIPSIS}', # exists in cp1252, not in cp437 '\\N{INFINITY}', # exists in cp437, not in cp1252 '\\N{CIRCLED NUMBER FORTY TWO}', # not in cp437 or in cp1252 ]\n\nfor char in test_chars: print(f'Trying to output {name(char)}:') print(char)\n\nExample 4-12 displays the result of sys.stdout.isatty(), the value of sys. stdout.encoding, and these three characters:\n\n'…' HORIZONTAL ELLIPSIS—exists in CP 1252 but not in CP 437. • '∞' INFINITY—exists in CP 437 but not in CP 1252. • '㊷' CIRCLED NUMBER FORTY TWO—doesn’t exist in CP 1252 or CP 437.\n\nWhen I run stdout_check.py on PowerShell or cmd.exe, it works as captured in Figure 4-3.\n\nFigure 4-3. Running stdout_check.py on PowerShell.\n\nHandling Text Files\n\n|\n\n137",
      "content_length": 946,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 168,
      "content": "Despite chcp reporting the active code as 437, sys.stdout.encoding is UTF-8, so the HORIZONTAL ELLIPSIS and INFINITY both output correctly. The CIRCLED NUMBER FORTY TWO is replaced by a rectangle, but no error is raised. Presumably it is recog‐ nized as a valid character, but the console font doesn’t have the glyph to display it.\n\nHowever, when I redirect the output of stdout_check.py to a file, I get Figure 4-4.\n\nFigure 4-4. Running stdout_check.py on PowerShell, redirecting output.\n\nThe first problem demonstrated by Figure 4-4 is the UnicodeEncodeError mention‐ ing character '\\u221e', because sys.stdout.encoding is 'cp1252'—a code page that doesn’t have the INFINITY character.\n\nReading out.txt with the type command—or a Windows editor like VS Code or Sub‐ lime Text—shows that instead of HORIZONTAL ELLIPSIS, I got 'à' (LATIN SMALL LETTER A WITH GRAVE). As it turns out, the byte value 0x85 in CP 1252 means '…', but in CP 437 the same byte value represents 'à'. So it seems the active code page does matter, not in a sensible or useful way, but as partial explanation of a bad Uni‐ code experience.\n\nI used a laptop configured for the US market, running Windows 10 OEM to run these experiments. Windows versions localized for other countries may have different encoding configurations. For example, in Brazil the Windows console uses code page 850 by default—not 437.\n\nTo wrap up this maddening issue of default encodings, let’s give a final look at the different encodings in Example 4-11:\n\n138\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1549,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 169,
      "content": "If you omit the encoding argument when opening a file, the default is given by locale.getpreferredencoding() ('cp1252' in Example 4-11).\n\nThe encoding of sys.stdout|stdin|stderr used to be set by the PYTHONIOENCOD ING environment variable before Python 3.6—now that variable is ignored, unless PYTHONLEGACYWINDOWSSTDIO is set to a nonempty string. Otherwise, the encoding for standard I/O is UTF-8 for interactive I/O, or defined by locale.getpreferredencoding() if the output/input is redirected to/from a file. • sys.getdefaultencoding() is used internally by Python in implicit conversions of binary data to/from str. Changing this setting is not supported.\n\nsys.getfilesystemencoding() is used to encode/decode filenames (not file contents). It is used when open() gets a str argument for the filename; if the file‐ name is given as a bytes argument, it is passed unchanged to the OS API.\n\nOn GNU/Linux and macOS, all of these encodings are set to UTF-8 by default, and have been for several years, so I/O handles all Unicode characters. On Windows, not only are different encod‐ ings used in the same system, but they are usually code pages like 'cp850' or 'cp1252' that support only ASCII, with 127 additional characters that are not the same from one encoding to the other. Therefore, Windows users are far more likely to face encoding errors unless they are extra careful.\n\nTo summarize, the most important encoding setting is that returned by locale.get preferredencoding(): it is the default for opening text files and for sys.stdout/ stdin/stderr when they are redirected to files. However, the documentation reads (in part):\n\nlocale.getpreferredencoding(do_setlocale=True)\n\nReturn the encoding used for text data, according to user preferences. User pref‐ erences are expressed differently on different systems, and might not be available programmatically on some systems, so this function only returns a guess. […]\n\nTherefore, the best advice about encoding defaults is: do not rely on them.\n\nYou will avoid a lot of pain if you follow the advice of the Unicode sandwich and always are explicit about the encodings in your programs. Unfortunately, Unicode is painful even if you get your bytes correctly converted to str. The next two sections cover subjects that are simple in ASCII-land, but get quite complex on planet Uni‐ code: text normalization (i.e., converting text to a uniform representation for comparisons) and sorting.\n\nHandling Text Files\n\n|\n\n139",
      "content_length": 2474,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 170,
      "content": "Normalizing Unicode for Reliable Comparisons String comparisons are complicated by the fact that Unicode has combining charac‐ ters: diacritics and other marks that attach to the preceding character, appearing as one when printed.\n\nFor example, the word “café” may be composed in two ways, using four or five code points, but the result looks exactly the same:\n\n>>> s1 = 'café' >>> s2 = 'cafe\\N{COMBINING ACUTE ACCENT}' >>> s1, s2 ('café', 'café') >>> len(s1), len(s2) (4, 5) >>> s1 == s2 False\n\nPlacing COMBINING ACUTE ACCENT (U+0301) after “e” renders “é”. In the Unicode standard, sequences like 'é' and 'e\\u0301' are called “canonical equivalents,” and applications are supposed to treat them as the same. But Python sees two different sequences of code points, and considers them not equal.\n\nThe solution is unicodedata.normalize(). The first argument to that function is one of four strings: 'NFC', 'NFD', 'NFKC', and 'NFKD'. Let’s start with the first two.\n\nNormalization Form C (NFC) composes the code points to produce the shortest equivalent string, while NFD decomposes, expanding composed characters into base characters and separate combining characters. Both of these normalizations make comparisons work as expected, as the next example shows:\n\n>>> from unicodedata import normalize >>> s1 = 'café' >>> s2 = 'cafe\\N{COMBINING ACUTE ACCENT}' >>> len(s1), len(s2) (4, 5) >>> len(normalize('NFC', s1)), len(normalize('NFC', s2)) (4, 4) >>> len(normalize('NFD', s1)), len(normalize('NFD', s2)) (5, 5) >>> normalize('NFC', s1) == normalize('NFC', s2) True >>> normalize('NFD', s1) == normalize('NFD', s2) True\n\nKeyboard drivers usually generate composed characters, so text typed by users will be in NFC by default. However, to be safe, it may be good to normalize strings with normalize('NFC', user_text) before saving. NFC is also the normalization form recommended by the W3C in “Character Model for the World Wide Web: String Matching and Searching”.\n\n140\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 2010,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 171,
      "content": "Some single characters are normalized by NFC into another single character. The symbol for the ohm (Ω) unit of electrical resistance is normalized to the Greek upper‐ case omega. They are visually identical, but they compare as unequal, so it is essential to normalize to avoid surprises:\n\n>>> from unicodedata import normalize, name >>> ohm = '\\u2126' >>> name(ohm) 'OHM SIGN' >>> ohm_c = normalize('NFC', ohm) >>> name(ohm_c) 'GREEK CAPITAL LETTER OMEGA' >>> ohm == ohm_c False >>> normalize('NFC', ohm) == normalize('NFC', ohm_c) True\n\nThe other two normalization forms are NFKC and NFKD, where the letter K stands for “compatibility.” These are stronger forms of normalization, affecting the so-called “compatibility characters.” Although one goal of Unicode is to have a single “canoni‐ cal” code point for each character, some characters appear more than once for compatibility with preexisting standards. For example, the MICRO SIGN, µ (U+00B5), was added to Unicode to support round-trip conversion to latin1, which includes it, even though the same character is part of the Greek alphabet with code point U+03BC (GREEK SMALL LETTER MU). So, the micro sign is considered a “compatibility character.”\n\nIn the NFKC and NFKD forms, each compatibility character is replaced by a “com‐ patibility decomposition” of one or more characters that are considered a “preferred” representation, even if there is some formatting loss—ideally, the formatting should be the responsibility of external markup, not part of Unicode. To exemplify, the compatibility decomposition of the one-half fraction '½' (U+00BD) is the sequence of three characters '1/2', and the compatibility decomposition of the micro sign 'µ' (U +00B5) is the lowercase mu 'μ' (U+03BC).7\n\nHere is how the NFKC works in practice:\n\n>>> from unicodedata import normalize, name >>> half = '\\N{VULGAR FRACTION ONE HALF}' >>> print(half) ½ >>> normalize('NFKC', half) '1⁄2'\n\n7 Curiously, the micro sign is considered a “compatibility character,” but the ohm symbol is not. The end result\n\nis that NFC doesn’t touch the micro sign but changes the ohm symbol to capital omega, while NFKC and NFKD change both the ohm and the micro into Greek characters.\n\nNormalizing Unicode for Reliable Comparisons\n\n|\n\n141",
      "content_length": 2264,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 172,
      "content": ">>> for char in normalize('NFKC', half): ... print(char, name(char), sep='\\t') ... 1 DIGIT ONE ⁄ FRACTION SLASH 2 DIGIT TWO >>> four_squared = '4²' >>> normalize('NFKC', four_squared) '42' >>> micro = 'µ' >>> micro_kc = normalize('NFKC', micro) >>> micro, micro_kc ('µ', 'μ') >>> ord(micro), ord(micro_kc) (181, 956) >>> name(micro), name(micro_kc) ('MICRO SIGN', 'GREEK SMALL LETTER MU')\n\nAlthough '1⁄2' is a reasonable substitute for '½', and the micro sign is really a low‐ ercase Greek mu, converting '4²' to '42' changes the meaning. An application could store '4²' as '4<sup>2</sup>', but the normalize function knows nothing about formatting. Therefore, NFKC or NFKD may lose or distort information, but they can produce convenient intermediate representations for searching and indexing.\n\nUnfortunately, with Unicode everything is always more complicated than it first seems. For the VULGAR FRACTION ONE HALF, the NFKC normalization produced 1 and 2 joined by FRACTION SLASH, instead of SOLIDUS, a.k.a. “slash”—the familiar character with ASCII code decimal 47. Therefore, searching for the three-character ASCII sequence '1/2' would not find the normalized Unicode sequence.\n\nNFKC and NFKD normalization cause data loss and should be applied only in special cases like search and indexing, and not for permanent storage of text.\n\nWhen preparing text for searching or indexing, another operation is useful: case fold‐ ing, our next subject.\n\nCase Folding Case folding is essentially converting all text to lowercase, with some additional transformations. It is supported by the str.casefold() method.\n\nFor any string s containing only latin1 characters, s.casefold() produces the same result as s.lower(), with only two exceptions—the micro sign 'µ' is changed to the\n\n142\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1821,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 173,
      "content": "Greek lowercase mu (which looks the same in most fonts) and the German Eszett or “sharp s” (ß) becomes “ss”:\n\n>>> micro = 'µ' >>> name(micro) 'MICRO SIGN' >>> micro_cf = micro.casefold() >>> name(micro_cf) 'GREEK SMALL LETTER MU' >>> micro, micro_cf ('µ', 'μ') >>> eszett = 'ß' >>> name(eszett) 'LATIN SMALL LETTER SHARP S' >>> eszett_cf = eszett.casefold() >>> eszett, eszett_cf ('ß', 'ss')\n\nThere are nearly 300 code points for which str.casefold() and str.lower() return different results.\n\nAs usual with anything related to Unicode, case folding is a hard issue with plenty of linguistic special cases, but the Python core team made an effort to provide a solution that hopefully works for most users.\n\nIn the next couple of sections, we’ll put our normalization knowledge to use develop‐ ing utility functions.\n\nUtility Functions for Normalized Text Matching As we’ve seen, NFC and NFD are safe to use and allow sensible comparisons between Unicode strings. NFC is the best normalized form for most applications. str.case fold() is the way to go for case-insensitive comparisons.\n\nIf you work with text in many languages, a pair of functions like nfc_equal and fold_equal in Example 4-13 are useful additions to your toolbox.\n\nExample 4-13. normeq.py: normalized Unicode string comparison\n\n\"\"\" Utility functions for normalized Unicode string comparison.\n\nUsing Normal Form C, case sensitive:\n\n>>> s1 = 'café' >>> s2 = 'cafe\\u0301' >>> s1 == s2 False >>> nfc_equal(s1, s2) True\n\nNormalizing Unicode for Reliable Comparisons\n\n|\n\n143",
      "content_length": 1535,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 174,
      "content": ">>> nfc_equal('A', 'a') False\n\nUsing Normal Form C with case folding:\n\n>>> s3 = 'Straße' >>> s4 = 'strasse' >>> s3 == s4 False >>> nfc_equal(s3, s4) False >>> fold_equal(s3, s4) True >>> fold_equal(s1, s2) True >>> fold_equal('A', 'a') True\n\n\"\"\"\n\nfrom unicodedata import normalize\n\ndef nfc_equal(str1, str2): return normalize('NFC', str1) == normalize('NFC', str2)\n\ndef fold_equal(str1, str2): return (normalize('NFC', str1).casefold() == normalize('NFC', str2).casefold())\n\nBeyond Unicode normalization and case folding—which are both part of the Uni‐ code standard—sometimes it makes sense to apply deeper transformations, like changing 'café' into 'cafe'. We’ll see when and how in the next section.\n\nExtreme “Normalization”: Taking Out Diacritics The Google Search secret sauce involves many tricks, but one of them apparently is ignoring diacritics (e.g., accents, cedillas, etc.), at least in some contexts. Removing diacritics is not a proper form of normalization because it often changes the meaning of words and may produce false positives when searching. But it helps coping with some facts of life: people sometimes are lazy or ignorant about the correct use of dia‐ critics, and spelling rules change over time, meaning that accents come and go in liv‐ ing languages.\n\nOutside of searching, getting rid of diacritics also makes for more readable URLs, at least in Latin-based languages. Take a look at the URL for the Wikipedia article about the city of São Paulo:\n\nhttps://en.wikipedia.org/wiki/S%C3%A3o_Paulo\n\n144\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1569,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 175,
      "content": "The %C3%A3 part is the URL-escaped, UTF-8 rendering of the single letter “ã” (“a” with tilde). The following is much easier to recognize, even if it is not the right spelling:\n\nhttps://en.wikipedia.org/wiki/Sao_Paulo\n\nTo remove all diacritics from a str, you can use a function like Example 4-14.\n\nExample 4-14. simplify.py: function to remove all combining marks\n\nimport unicodedata import string\n\ndef shave_marks(txt): \"\"\"Remove all diacritic marks\"\"\" norm_txt = unicodedata.normalize('NFD', txt) shaved = ''.join(c for c in norm_txt if not unicodedata.combining(c)) return unicodedata.normalize('NFC', shaved)\n\nDecompose all characters into base characters and combining marks.\n\nFilter out all combining marks.\n\nRecompose all characters.\n\nExample 4-15 shows a couple of uses of shave_marks.\n\nExample 4-15. Two examples using shave_marks from Example 4-14\n\n>>> order = '“Herr Voß: • ½ cup of Œtker™ caffè latte • bowl of açaí.”' >>> shave_marks(order) '“Herr Voß: • ½ cup of Œtker™ caffe latte • bowl of acai.”' >>> Greek = 'Ζέφυρος, Zéfiro' >>> shave_marks(Greek) 'Ζεφυρος, Zefiro'\n\nOnly the letters “è”, “ç”, and “í” were replaced.\n\nBoth “έ” and “é” were replaced.\n\nThe function shave_marks from Example 4-14 works all right, but maybe it goes too far. Often the reason to remove diacritics is to change Latin text to pure ASCII, but shave_marks also changes non-Latin characters—like Greek letters—which will never become ASCII just by losing their accents. So it makes sense to analyze each base\n\nNormalizing Unicode for Reliable Comparisons\n\n|\n\n145",
      "content_length": 1555,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 176,
      "content": "character and to remove attached marks only if the base character is a letter from the Latin alphabet. This is what Example 4-16 does.\n\nExample 4-16. Function to remove combining marks from Latin characters (import statements are omitted as this is part of the simplify.py module from Example 4-14)\n\ndef shave_marks_latin(txt): \"\"\"Remove all diacritic marks from Latin base characters\"\"\" norm_txt = unicodedata.normalize('NFD', txt) latin_base = False preserve = [] for c in norm_txt: if unicodedata.combining(c) and latin_base: continue # ignore diacritic on Latin base char preserve.append(c) # if it isn't a combining char, it's a new base char if not unicodedata.combining(c): latin_base = c in string.ascii_letters shaved = ''.join(preserve) return unicodedata.normalize('NFC', shaved)\n\nDecompose all characters into base characters and combining marks.\n\nSkip over combining marks when base character is Latin.\n\nOtherwise, keep current character.\n\nDetect new base character and determine if it’s Latin.\n\nRecompose all characters.\n\nAn even more radical step would be to replace common symbols in Western texts (e.g., curly quotes, em dashes, bullets, etc.) into ASCII equivalents. This is what the function asciize does in Example 4-17.\n\nExample 4-17. Transform some Western typographical symbols into ASCII (this snippet is also part of simplify.py from Example 4-14)\n\nsingle_map = str.maketrans(\"\"\"‚ƒ„ˆ‹‘’“”•–—˜›\"\"\", \"\"\"'f\"^<''\"\"---~>\"\"\")\n\nmulti_map = str.maketrans({ '€': 'EUR', '…': '...', 'Æ': 'AE', 'æ': 'ae', 'Œ': 'OE', 'œ': 'oe',\n\n146\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1587,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 177,
      "content": "'™': '(TM)', '‰': '<per mille>', '†': '**', '‡': '***', })\n\nmulti_map.update(single_map)\n\ndef dewinize(txt): \"\"\"Replace Win1252 symbols with ASCII chars or sequences\"\"\" return txt.translate(multi_map)\n\ndef asciize(txt): no_marks = shave_marks_latin(dewinize(txt)) no_marks = no_marks.replace('ß', 'ss') return unicodedata.normalize('NFKC', no_marks)\n\nBuild mapping table for char-to-char replacement.\n\nBuild mapping table for char-to-string replacement.\n\nMerge mapping tables.\n\ndewinize does not affect ASCII or latin1 text, only the Microsoft additions to latin1 in cp1252.\n\nApply dewinize and remove diacritical marks.\n\nReplace the Eszett with “ss” (we are not using case fold here because we want to preserve the case).\n\nApply NFKC normalization to compose characters with their compatibility code points.\n\nExample 4-18 shows asciize in use.\n\nExample 4-18. Two examples using asciize from Example 4-17\n\n>>> order = '“Herr Voß: • ½ cup of Œtker™ caffè latte • bowl of açaí.”' >>> dewinize(order) '\"Herr Voß: - ½ cup of OEtker(TM) caffè latte - bowl of açaí.\"' >>> asciize(order) '\"Herr Voss: - 1⁄2 cup of OEtker(TM) caffe latte - bowl of acai.\"'\n\nNormalizing Unicode for Reliable Comparisons\n\n|\n\n147",
      "content_length": 1201,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 178,
      "content": "dewinize replaces curly quotes, bullets, and ™ (trademark symbol).\n\nasciize applies dewinize, drops diacritics, and replaces the 'ß'.\n\nDifferent languages have their own rules for removing diacritics. For example, Germans change the 'ü' into 'ue'. Our asciize function is not as refined, so it may or not be suitable for your lan‐ guage. It works acceptably for Portuguese, though.\n\nTo summarize, the functions in simplify.py go way beyond standard normalization and perform deep surgery on the text, with a good chance of changing its meaning. Only you can decide whether to go so far, knowing the target language, your users, and how the transformed text will be used.\n\nThis wraps up our discussion of normalizing Unicode text.\n\nNow let’s sort out Unicode sorting.\n\nSorting Unicode Text Python sorts sequences of any type by comparing the items in each sequence one by one. For strings, this means comparing the code points. Unfortunately, this produces unacceptable results for anyone who uses non-ASCII characters.\n\nConsider sorting a list of fruits grown in Brazil:\n\n>>> fruits = ['caju', 'atemoia', 'cajá', 'açaí', 'acerola'] >>> sorted(fruits) ['acerola', 'atemoia', 'açaí', 'caju', 'cajá']\n\nSorting rules vary for different locales, but in Portuguese and many languages that use the Latin alphabet, accents and cedillas rarely make a difference when sorting.8 So “cajá” is sorted as “caja,” and must come before “caju.”\n\nThe sorted fruits list should be:\n\n['açaí', 'acerola', 'atemoia', 'cajá', 'caju']\n\nThe standard way to sort non-ASCII text in Python is to use the locale.strxfrm function which, according to the locale module docs, “transforms a string to one that can be used in locale-aware comparisons.”\n\n8 Diacritics affect sorting only in the rare case when they are the only difference between two words—in that\n\ncase, the word with a diacritic is sorted after the plain word.\n\n148\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1940,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 179,
      "content": "To enable locale.strxfrm, you must first set a suitable locale for your application, and pray that the OS supports it. The sequence of commands in Example 4-19 may work for you.\n\nExample 4-19. locale_sort.py: using the locale.strxfrm function as the sort key\n\nimport locale my_locale = locale.setlocale(locale.LC_COLLATE, 'pt_BR.UTF-8') print(my_locale) fruits = ['caju', 'atemoia', 'cajá', 'açaí', 'acerola'] sorted_fruits = sorted(fruits, key=locale.strxfrm) print(sorted_fruits)\n\nRunning Example 4-19 on GNU/Linux (Ubuntu 19.10) with the pt_BR.UTF-8 locale installed, I get the correct result:\n\n'pt_BR.UTF-8' ['açaí', 'acerola', 'atemoia', 'cajá', 'caju']\n\nSo you need to call setlocale(LC_COLLATE, «your_locale») before using locale.strxfrm as the key when sorting.\n\nThere are some caveats, though:\n\nBecause locale settings are global, calling setlocale in a library is not recom‐ mended. Your application or framework should set the locale when the process starts, and should not change it afterward.\n\nThe locale must be installed on the OS, otherwise setlocale raises a locale.Error: unsupported locale setting exception.\n\nYou must know how to spell the locale name.\n\nThe locale must be correctly implemented by the makers of the OS. I was suc‐ cessful on Ubuntu 19.10, but not on macOS 10.14. On macOS, the call setlo cale(LC_COLLATE, 'pt_BR.UTF-8') returns the string 'pt_BR.UTF-8' with no complaints. But sorted(fruits, key=locale.strxfrm) produced the same incorrect result as sorted(fruits) did. I also tried the fr_FR, es_ES, and de_DE locales on macOS, but locale.strxfrm never did its job.9\n\nSo the standard library solution to internationalized sorting works, but seems to be well supported only on GNU/Linux (perhaps also on Windows, if you are an expert). Even then, it depends on locale settings, creating deployment headaches.\n\n9 Again, I could not find a solution, but did find other people reporting the same problem. Alex Martelli, one of the tech reviewers, had no problem using setlocale and locale.strxfrm on his Macintosh with macOS 10.9. In summary: your mileage may vary.\n\nSorting Unicode Text\n\n|\n\n149",
      "content_length": 2129,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 180,
      "content": "Fortunately, there is a simpler solution: the pyuca library, available on PyPI.\n\nSorting with the Unicode Collation Algorithm James Tauber, prolific Django contributor, must have felt the pain and created pyuca, a pure-Python implementation of the Unicode Collation Algorithm (UCA). Example 4-20 shows how easy it is to use.\n\nExample 4-20. Using the pyuca.Collator.sort_key method\n\n>>> import pyuca >>> coll = pyuca.Collator() >>> fruits = ['caju', 'atemoia', 'cajá', 'açaí', 'acerola'] >>> sorted_fruits = sorted(fruits, key=coll.sort_key) >>> sorted_fruits ['açaí', 'acerola', 'atemoia', 'cajá', 'caju']\n\nThis is simple and works on GNU/Linux, macOS, and Windows, at least with my small sample.\n\npyuca does not take the locale into account. If you need to customize the sorting, you can provide the path to a custom collation table to the Collator() constructor. Out of the box, it uses allkeys.txt, which is bundled with the project. That’s just a copy of the Default Unicode Collation Element Table from Unicode.org.\n\nPyICU: Miro’s Recommendation for Unicode Sorting\n\n(Tech reviewer Miroslav Šedivý is a polyglot and an expert on Uni‐ code. This is what he wrote about pyuca.)\n\npyuca has one sorting algorithm that does not respect the sorting order in individual languages. For instance, Ä in German is between A and B, while in Swedish it comes after Z. Have a look at PyICU that works like locale without changing the locale of the process. It is also needed if you want to change the case of iİ/ıI in Turkish. PyICU includes an extension that must be compiled, so it may be harder to install in some systems than pyuca, which is just Python.\n\nBy the way, that collation table is one of the many data files that comprise the Uni‐ code database, our next subject.\n\nThe Unicode Database The Unicode standard provides an entire database—in the form of several structured text files—that includes not only the table mapping code points to character names,\n\n150\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 2004,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 181,
      "content": "but also metadata about the individual characters and how they are related. For example, the Unicode database records whether a character is printable, is a letter, is a decimal digit, or is some other numeric symbol. That’s how the str methods isal pha, isprintable, isdecimal, and isnumeric work. str.casefold also uses infor‐ mation from a Unicode table.\n\nThe unicodedata.category(char) function returns the two-letter category of char from the Unicode database. The higher-level str methods are easier to use. For example, label.isalpha() returns True if every character in label belongs to one of these categories: Lm, Lt, Lu, Ll, or Lo. To learn what those codes mean, see “General Category” in the English Wikipedia’s “Unicode character property” article.\n\nFinding Characters by Name The unicodedata module has functions to retrieve character metadata, including uni codedata.name(), which returns a character’s official name in the standard. Figure 4-5 demonstrates that function.10\n\nFigure 4-5. Exploring unicodedata.name() in the Python console.\n\nYou can use the name() function to build apps that let users search for characters by name. Figure 4-6 demonstrates the cf.py command-line script that takes one or more words as arguments, and lists the characters that have those words in their official Unicode names. The full source code for cf.py is in Example 4-21.\n\n10 That’s an image—not a code listing—because emojis are not well supported by O’Reilly’s digital publishing\n\ntoolchain as I write this.\n\nThe Unicode Database\n\n|\n\n151",
      "content_length": 1544,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 182,
      "content": "Figure 4-6. Using cf.py to find smiling cats.\n\nEmoji support varies widely across operating systems and apps. In recent years the macOS terminal offers the best support for emojis, followed by modern GNU/Linux graphic terminals. Windows cmd.exe and PowerShell now support Unicode output, but as I write this section in January 2020, they still don’t display emojis— at least not “out of the box.” Tech reviewer Leonardo Rochael told me about a new, open source Windows Terminal by Microsoft, which may have better Unicode support than the older Microsoft consoles. I did not have time to try it.\n\nIn Example 4-21, note the if statement in the find function using the .issubset() method to quickly test whether all the words in the query set appear in the list of words built from the character’s name. Thanks to Python’s rich set API, we don’t need a nested for loop and another if to implement this check.\n\nExample 4-21. cf.py: the character finder utility\n\n#!/usr/bin/env python3 import sys import unicodedata\n\nSTART, END = ord(' '), sys.maxunicode + 1\n\ndef find(*query_words, start=START, end=END): query = {w.upper() for w in query_words} for code in range(start, end): char = chr(code) name = unicodedata.name(char, None) if name and query.issubset(name.split()): print(f'U+{code:04X}\\t{char}\\t{name}')\n\ndef main(words): if words: find(*words) else: print('Please provide words to find.')\n\nif __name__ == '__main__': main(sys.argv[1:])\n\n152\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1486,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 183,
      "content": "Set defaults for the range of code points to search.\n\nfind accepts query_words and optional keyword-only arguments to limit the range of the search, to facilitate testing.\n\nConvert query_words into a set of uppercased strings.\n\nGet the Unicode character for code.\n\nGet the name of the character, or None if the code point is unassigned.\n\nIf there is a name, split it into a list of words, then check that the query set is a subset of that list.\n\nPrint out line with code point in U+9999 format, the character, and its name.\n\nThe unicodedata module has other interesting functions. Next, we’ll see a few that are related to getting information from characters that have numeric meaning.\n\nNumeric Meaning of Characters The unicodedata module includes functions to check whether a Unicode character represents a number and, if so, its numeric value for humans—as opposed to its code point number. Example 4-22 shows the use of unicodedata.name() and unicode data.numeric(), along with the .isdecimal() and .isnumeric() methods of str.\n\nExample 4-22. Demo of Unicode database numerical character metadata (callouts describe each column in the output)\n\nimport unicodedata import re\n\nre_digit = re.compile(r'\\d')\n\nsample = '1\\xbc\\xb2\\u0969\\u136b\\u216b\\u2466\\u2480\\u3285'\n\nfor char in sample: print(f'U+{ord(char):04x}', char.center(6), 're_dig' if re_digit.match(char) else '-', 'isdig' if char.isdigit() else '-', 'isnum' if char.isnumeric() else '-', f'{unicodedata.numeric(char):5.2f}', unicodedata.name(char), sep='\\t')\n\nThe Unicode Database\n\n|\n\n153",
      "content_length": 1547,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 184,
      "content": "Code point in U+0000 format.\n\nCharacter centralized in a str of length 6.\n\nShow re_dig if character matches the r'\\d' regex.\n\nShow isdig if char.isdigit() is True.\n\nShow isnum if char.isnumeric() is True.\n\nNumeric value formatted with width 5 and 2 decimal places.\n\nUnicode character name.\n\nRunning Example 4-22 gives you Figure 4-7, if your terminal font has all those glyphs.\n\nFigure 4-7. macOS terminal showing numeric characters and metadata about them; re_dig means the character matches the regular expression r'\\d'.\n\nThe sixth column of Figure 4-7 is the result of calling unicodedata.numeric(char) on the character. It shows that Unicode knows the numeric value of symbols that represent numbers. So if you want to create a spreadsheet application that supports Tamil digits or Roman numerals, go for it!\n\nFigure 4-7 shows that the regular expression r'\\d' matches the digit “1” and the Devanagari digit 3, but not some other characters that are considered digits by the isdigit function. The re module is not as savvy about Unicode as it could be. The new regex module available on PyPI was designed to eventually replace re and pro‐ vides better Unicode support.11 We’ll come back to the re module in the next section.\n\n11 Although it was not better than re at identifying digits in this particular sample.\n\n154\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1362,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 185,
      "content": "Throughout this chapter we’ve used several unicodedata functions, but there are many more we did not cover. See the standard library documentation for the unicode data module.\n\nNext we’ll take a quick look at dual-mode APIs offering functions that accept str or bytes arguments with special handling depending on the type.\n\nDual-Mode str and bytes APIs Python’s standard library has functions that accept str or bytes arguments and behave differently depending on the type. Some examples can be found in the re and os modules.\n\nstr Versus bytes in Regular Expressions If you build a regular expression with bytes, patterns such as \\d and \\w only match ASCII characters; in contrast, if these patterns are given as str, they match Unicode digits or letters beyond ASCII. Example 4-23 and Figure 4-8 compare how letters, ASCII digits, superscripts, and Tamil digits are matched by str and bytes patterns.\n\nExample 4-23. ramanujan.py: compare behavior of simple str and bytes regular expressions\n\nimport re\n\nre_numbers_str = re.compile(r'\\d+') re_words_str = re.compile(r'\\w+') re_numbers_bytes = re.compile(rb'\\d+') re_words_bytes = re.compile(rb'\\w+')\n\ntext_str = (\"Ramanujan saw \\u0be7\\u0bed\\u0be8\\u0bef\" \" as 1729 = 1³ + 12³ = 9³ + 10³.\")\n\ntext_bytes = text_str.encode('utf_8')\n\nprint(f'Text\\n {text_str!r}') print('Numbers') print(' str :', re_numbers_str.findall(text_str)) print(' bytes:', re_numbers_bytes.findall(text_bytes)) print('Words') print(' str :', re_words_str.findall(text_str)) print(' bytes:', re_words_bytes.findall(text_bytes))\n\nThe first two regular expressions are of the str type.\n\nThe last two are of the bytes type.\n\nDual-Mode str and bytes APIs\n\n|\n\n155",
      "content_length": 1678,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 186,
      "content": "Unicode text to search, containing the Tamil digits for 1729 (the logical line con‐ tinues until the right parenthesis token).\n\nThis string is joined to the previous one at compile time (see “2.4.2. String literal concatenation” in The Python Language Reference).\n\nA bytes string is needed to search with the bytes regular expressions.\n\nThe str pattern r'\\d+' matches the Tamil and ASCII digits.\n\nThe bytes pattern rb'\\d+' matches only the ASCII bytes for digits.\n\nThe str pattern r'\\w+' matches the letters, superscripts, Tamil, and ASCII digits.\n\nThe bytes pattern rb'\\w+' matches only the ASCII bytes for letters and digits.\n\nFigure 4-8. Screenshot of running ramanujan.py from Example 4-23.\n\nExample 4-23 is a trivial example to make one point: you can use regular expressions on str and bytes, but in the second case, bytes outside the ASCII range are treated as nondigits and nonword characters.\n\nFor str regular expressions, there is a re.ASCII flag that makes \\w, \\W, \\b, \\B, \\d, \\D, \\s, and \\S perform ASCII-only matching. See the documentation of the re module for full details.\n\nAnother important dual-mode module is os.\n\nstr Versus bytes in os Functions The GNU/Linux kernel is not Unicode savvy, so in the real world you may find file‐ names made of byte sequences that are not valid in any sensible encoding scheme, and cannot be decoded to str. File servers with clients using a variety of OSes are particularly prone to this problem.\n\n156\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 1495,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 187,
      "content": "In order to work around this issue, all os module functions that accept filenames or pathnames take arguments as str or bytes. If one such function is called with a str argument, the argument will be automatically converted using the codec named by sys.getfilesystemencoding(), and the OS response will be decoded with the same codec. This is almost always what you want, in keeping with the Unicode sandwich best practice.\n\nBut if you must deal with (and perhaps fix) filenames that cannot be handled in that way, you can pass bytes arguments to the os functions to get bytes return values. This feature lets you deal with any file or pathname, no matter how many gremlins you may find. See Example 4-24.\n\nExample 4-24. listdir with str and bytes arguments and results\n\n>>> os.listdir('.') ['abc.txt', 'digits-of-π.txt'] >>> os.listdir(b'.') [b'abc.txt', b'digits-of-\\xcf\\x80.txt']\n\nThe second filename is “digits-of-π.txt” (with the Greek letter pi).\n\nGiven a byte argument, listdir returns filenames as bytes: b'\\xcf\\x80' is the UTF-8 encoding of the Greek letter pi.\n\nTo help with manual handling of str or bytes sequences that are filenames or path‐ names, the os module provides special encoding and decoding functions os.fsen code(name_or_path) and os.fsdecode(name_or_path). Both of these functions accept an argument of type str, bytes, or an object implementing the os.PathLike interface since Python 3.6.\n\nUnicode is a deep rabbit hole. Time to wrap up our exploration of str and bytes.\n\nChapter Summary We started the chapter by dismissing the notion that 1 character == 1 byte. As the world adopts Unicode, we need to keep the concept of text strings separated from the binary sequences that represent them in files, and Python 3 enforces this separation.\n\nAfter a brief overview of the binary sequence data types—bytes, bytearray, and memoryview—we jumped into encoding and decoding, with a sampling of important codecs, followed by approaches to prevent or deal with the infamous UnicodeEnco deError, UnicodeDecodeError, and the SyntaxError caused by wrong encoding in Python source files.\n\nChapter Summary\n\n|\n\n157",
      "content_length": 2129,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 188,
      "content": "We then considered the theory and practice of encoding detection in the absence of metadata: in theory, it can’t be done, but in practice the Chardet package pulls it off pretty well for a number of popular encodings. Byte order marks were then presented as the only encoding hint commonly found in UTF-16 and UTF-32 files—sometimes in UTF-8 files as well.\n\nIn the next section, we demonstrated opening text files, an easy task except for one pitfall: the encoding= keyword argument is not mandatory when you open a text file, but it should be. If you fail to specify the encoding, you end up with a program that manages to generate “plain text” that is incompatible across platforms, due to con‐ flicting default encodings. We then exposed the different encoding settings that Python uses as defaults and how to detect them. A sad realization for Windows users is that these settings often have distinct values within the same machine, and the val‐ ues are mutually incompatible; GNU/Linux and macOS users, in contrast, live in a happier place where UTF-8 is the default pretty much everywhere.\n\nUnicode provides multiple ways of representing some characters, so normalizing is a prerequisite for text matching. In addition to explaining normalization and case fold‐ ing, we presented some utility functions that you may adapt to your needs, including drastic transformations like removing all accents. We then saw how to sort Unicode text correctly by leveraging the standard locale module—with some caveats—and an alternative that does not depend on tricky locale configurations: the external pyuca package.\n\nWe leveraged the Unicode database to program a command-line utility to search for characters by name—in 28 lines of code, thanks to the power of Python. We glanced at other Unicode metadata, and had a brief overview of dual-mode APIs where some functions can be called with str or bytes arguments, producing different results.\n\nFurther Reading Ned Batchelder’s 2012 PyCon US talk “Pragmatic Unicode, or, How Do I Stop the Pain?” was outstanding. Ned is so professional that he provides a full transcript of the talk along with the slides and video.\n\n“Character encoding and Unicode in Python: How to (╯°□°)╯︵ ┻━┻ with dig‐ nity” (slides, video) was the excellent PyCon 2014 talk by Esther Nam and Travis Fischer, where I found this chapter’s pithy epigraph: “Humans use text. Computers speak bytes.”\n\nLennart Regebro—one of the technical reviewers for the first edition of this book— shares his “Useful Mental Model of Unicode (UMMU)” in the short post “Unconfus‐ ing Unicode: What Is Unicode?”. Unicode is a complex standard, so Lennart’s UMMU is a really useful starting point.\n\n158\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 2737,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 189,
      "content": "The official “Unicode HOWTO” in the Python docs approaches the subject from sev‐ eral different angles, from a good historic intro, to syntax details, codecs, regular expressions, filenames, and best practices for Unicode-aware I/O (i.e., the Unicode sandwich), with plenty of additional reference links from each section. Chapter 4, “Strings”, of Mark Pilgrim’s awesome book Dive into Python 3 (Apress) also provides a very good intro to Unicode support in Python 3. In the same book, Chapter 15 describes how the Chardet library was ported from Python 2 to Python 3, a valuable case study given that the switch from the old str to the new bytes is the cause of most migration pains, and that is a central concern in a library designed to detect encodings.\n\nIf you know Python 2 but are new to Python 3, Guido van Rossum’s “What’s New in Python 3.0” has 15 bullet points that summarize what changed, with lots of links. Guido starts with the blunt statement: “Everything you thought you knew about binary data and Unicode has changed.” Armin Ronacher’s blog post “The Updated Guide to Unicode on Python” is deep and highlights some of the pitfalls of Unicode in Python 3 (Armin is not a big fan of Python 3).\n\nChapter 2, “Strings and Text,” of the Python Cookbook, 3rd ed. (O’Reilly), by David Beazley and Brian K. Jones, has several recipes dealing with Unicode normalization, sanitizing text, and performing text-oriented operations on byte sequences. Chapter 5 covers files and I/O, and it includes “Recipe 5.17. Writing Bytes to a Text File,” show‐ ing that underlying any text file there is always a binary stream that may be accessed directly when needed. Later in the cookbook, the struct module is put to use in “Recipe 6.11. Reading and Writing Binary Arrays of Structures.”\n\nNick Coghlan’s “Python Notes” blog has two posts very relevant to this chapter: “Python 3 and ASCII Compatible Binary Protocols” and “Processing Text Files in Python 3”. Highly recommended.\n\nA list of encodings supported by Python is available at “Standard Encodings” in the codecs module documentation. If you need to get that list programmatically, see how it’s done in the /Tools/unicode/listcodecs.py script that comes with the CPython source code.\n\nThe books Unicode Explained by Jukka K. Korpela (O’Reilly) and Unicode Demysti‐ fied by Richard Gillam (Addison-Wesley) are not Python-specific but were very help‐ ful as I studied Unicode concepts. Programming with Unicode by Victor Stinner is a free, self-published book (Creative Commons BY-SA) covering Unicode in general, as well as tools and APIs in the context of the main operating systems and a few pro‐ gramming languages, including Python.\n\nThe W3C pages “Case Folding: An Introduction” and “Character Model for the World Wide Web: String Matching” cover normalization concepts, with the former being a gentle introduction and the latter a working group note written in dry\n\nFurther Reading\n\n|\n\n159",
      "content_length": 2949,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 190,
      "content": "standard-speak—the same tone of the “Unicode Standard Annex #15—Unicode Nor‐ malization Forms”. The “Frequently Asked Questions, Normalization” section from Unicode.org is more readable, as is the “NFC FAQ” by Mark Davis—author of several Unicode algorithms and president of the Unicode Consortium at the time of this writing.\n\nIn 2016, the Museum of Modern Art (MoMA) in New York added to its collection the original emoji, the 176 emojis designed by Shigetaka Kurita in 1999 for NTT DOCOMO—the Japanese mobile carrier. Going further back in history, Emojipedia published “Correcting the Record on the First Emoji Set”, crediting Japan’s SoftBank for the earliest known emoji set, deployed in cell phones in 1997. SoftBank’s set is the source of 90 emojis now in Unicode, including U+1F4A9 (PILE OF POO). Matthew Rothenberg’s emojitracker.com is a live dashboard showing counts of emoji usage on Twitter, updated in real time. As I write this, FACE WITH TEARS OF JOY (U+1F602) is the most popular emoji on Twitter, with more than 3,313,667,315 recorded occurrences.\n\nSoapbox\n\nNon-ASCII Names in Source Code: Should You Use Them?\n\nPython 3 allows non-ASCII identifiers in source code:\n\n>>> ação = 'PBR' # ação = stock >>> ε = 10**-6 # ε = epsilon\n\nSome people dislike the idea. The most common argument to stick with ASCII iden‐ tifiers is to make it easy for everyone to read and edit code. That argument misses the point: you want your source code to be readable and editable by its intended audi‐ ence, and that may not be “everyone.” If the code belongs to a multinational corpora‐ tion or is open source and you want contributors from around the world, the identifiers should be in English, and then all you need is ASCII.\n\nBut if you are a teacher in Brazil, your students will find it easier to read code that uses Portuguese variable and function names, correctly spelled. And they will have no difficulty typing the cedillas and accented vowels on their localized keyboards.\n\nNow that Python can parse Unicode names and UTF-8 is the default source encod‐ ing, I see no point in coding identifiers in Portuguese without accents, as we used to do in Python 2 out of necessity—unless you need the code to run on Python 2 also. If the names are in Portuguese, leaving out the accents won’t make the code more read‐ able to anyone.\n\nThis is my point of view as a Portuguese-speaking Brazilian, but I believe it applies across borders and cultures: choose the human language that makes the code easier to read by the team, then use the characters needed for correct spelling.\n\n160\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 2624,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 191,
      "content": "What Is “Plain Text”?\n\nFor anyone who deals with non-English text on a daily basis, “plain text” does not imply “ASCII.” The Unicode Glossary defines plain text like this:\n\nComputer-encoded text that consists only of a sequence of code points from a given standard, with no other formatting or structural information.\n\nThat definition starts very well, but I don’t agree with the part after the comma. HTML is a great example of a plain-text format that carries formatting and structural information. But it’s still plain text because every byte in such a file is there to repre‐ sent a text character, usually using UTF-8. There are no bytes with nontext meaning, as you can find in a .png or .xls document where most bytes represent packed binary values like RGB values and floating-point numbers. In plain text, numbers are repre‐ sented as sequences of digit characters.\n\nI am writing this book in a plain-text format called—ironically—AsciiDoc, which is part of the toolchain of O’Reilly’s excellent Atlas book publishing platform. AsciiDoc source files are plain text, but they are UTF-8, not ASCII. Otherwise, writing this chapter would have been really painful. Despite the name, AsciiDoc is just great.\n\nThe world of Unicode is constantly expanding and, at the edges, tool support is not always there. Not all characters I wanted to show were available in the fonts used to render the book. That’s why I had to use images instead of listings in several examples in this chapter. On the other hand, the Ubuntu and macOS terminals display most Unicode text very well—including the Japanese characters for the word “mojibake”: 文字化け.\n\nHow Are str Code Points Represented in RAM?\n\nThe official Python docs avoid the issue of how the code points of a str are stored in memory. It is really an implementation detail. In theory, it doesn’t matter: whatever the internal representation, every str must be encoded to bytes on output.\n\nIn memory, Python 3 stores each str as a sequence of code points using a fixed num‐ ber of bytes per code point, to allow efficient direct access to any character or slice.\n\nSince Python 3.3, when creating a new str object, the interpreter checks the charac‐ ters in it and chooses the most economic memory layout that is suitable for that par‐ ticular str: if there are only characters in the latin1 range, that str will use just one byte per code point. Otherwise, two or four bytes per code point may be used, depending on the str. This is a simplification; for the full details, look up PEP 393— Flexible String Representation.\n\nThe flexible string representation is similar to the way the int type works in Python 3: if the integer fits in a machine word, it is stored in one machine word. Otherwise, the interpreter switches to a variable-length representation like that of the Python 2 long type. It is nice to see the spread of good ideas.\n\nFurther Reading\n\n|\n\n161",
      "content_length": 2906,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 192,
      "content": "However, we can always count on Armin Ronacher to find problems in Python 3. He explained to me why that was not such as great idea in practice: it takes a single RAT (U+1F400) to inflate an otherwise all-ASCII text into a memory-hogging array using four bytes per character, when one byte would suffice for each character except the RAT. In addition, because of all the ways Unicode characters combine, the ability to quickly retrieve an arbitrary character by position is overrated—and extracting arbi‐ trary slices from Unicode text is naïve at best, and often wrong, producing mojibake. As emojis become more popular, these problems will only get worse.\n\n162\n\n|\n\nChapter 4: Unicode Text Versus Bytes",
      "content_length": 703,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 193,
      "content": "CHAPTER 5 Data Class Builders\n\nData classes are like children. They are okay as a starting point, but to participate as a grownup object, they need to take some responsibility.\n\n—Martin Fowler and Kent Beck1\n\nPython offers a few ways to build a simple class that is just a collection of fields, with little or no extra functionality. That pattern is known as a “data class”—and data classes is one of the packages that supports this pattern. This chapter covers three different class builders that you may use as shortcuts to write data classes:\n\ncollections.namedtuple\n\nThe simplest way—available since Python 2.6.\n\ntyping.NamedTuple\n\nAn alternative that requires type hints on the fields—since Python 3.5, with class syntax added in 3.6.\n\n@dataclasses.dataclass\n\nA class decorator that allows more customization than previous alternatives, adding lots of options and potential complexity—since Python 3.7.\n\nAfter covering those class builders, we will discuss why Data Class is also the name of a code smell: a coding pattern that may be a symptom of poor object-oriented design.\n\n1 From Refactoring, first edition, Chapter 3, “Bad Smells in Code, Data Class” section, page 87 (Addison-\n\nWesley).\n\n163",
      "content_length": 1203,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 194,
      "content": "typing.TypedDict may seem like another data class builder. It uses similar syntax and is described right after typing.NamedTuple in the typing module documentation for Python 3.9. However, TypedDict does not build concrete classes that you can instantiate. It’s just syntax to write type hints for function parame‐ ters and variables that will accept mapping values used as records, with keys as field names. We’ll see them in Chapter 15, “TypedDict” on page 526.\n\nWhat’s New in This Chapter This chapter is new in the second edition of Fluent Python. The section “Classic Named Tuples” on page 169 appeared in Chapter 2 of the first edition, but the rest of the chapter is completely new.\n\nWe begin with a high-level overview of the three class builders.\n\nOverview of Data Class Builders Consider a simple class to represent a geographic coordinate pair, as shown in Example 5-1.\n\nExample 5-1. class/coordinates.py\n\nclass Coordinate:\n\ndef __init__(self, lat, lon): self.lat = lat self.lon = lon\n\nThat Coordinate class does the job of holding latitude and longitude attributes. Writ‐ ing the __init__ boilerplate becomes old real fast, especially if your class has more than a couple of attributes: each of them is mentioned three times! And that boiler‐ plate doesn’t buy us basic features we’d expect from a Python object:\n\n>>> from coordinates import Coordinate >>> moscow = Coordinate(55.76, 37.62) >>> moscow <coordinates.Coordinate object at 0x107142f10> >>> location = Coordinate(55.76, 37.62) >>> location == moscow False >>> (location.lat, location.lon) == (moscow.lat, moscow.lon) True\n\n164\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1635,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 195,
      "content": "__repr__ inherited from object is not very helpful.\n\nMeaningless ==; the __eq__ method inherited from object compares object IDs.\n\nComparing two coordinates requires explicit comparison of each attribute.\n\nThe data class builders covered in this chapter provide the necessary __init__, __repr__, and __eq__ methods automatically, as well as other useful features.\n\nNone of the class builders discussed here depend on inheritance to do their work. Both collections.namedtuple and typing.Name dTuple build classes that are tuple subclasses. @dataclass is a class decorator that does not affect the class hierarchy in any way. Each of them uses different metaprogramming techniques to inject methods and data attributes into the class under construction.\n\nHere is a Coordinate class built with namedtuple—a factory function that builds a subclass of tuple with the name and fields you specify:\n\n>>> from collections import namedtuple >>> Coordinate = namedtuple('Coordinate', 'lat lon') >>> issubclass(Coordinate, tuple) True >>> moscow = Coordinate(55.756, 37.617) >>> moscow Coordinate(lat=55.756, lon=37.617) >>> moscow == Coordinate(lat=55.756, lon=37.617) True\n\nUseful __repr__.\n\nMeaningful __eq__.\n\nThe newer typing.NamedTuple provides the same functionality, adding a type anno‐ tation to each field:\n\n>>> import typing >>> Coordinate = typing.NamedTuple('Coordinate', ... [('lat', float), ('lon', float)]) >>> issubclass(Coordinate, tuple) True >>> typing.get_type_hints(Coordinate) {'lat': <class 'float'>, 'lon': <class 'float'>}\n\nOverview of Data Class Builders\n\n|\n\n165",
      "content_length": 1577,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 196,
      "content": "A typed named tuple can also be constructed with the fields given as keyword arguments, like this:\n\nCoordinate = typing.NamedTuple('Coordinate', lat=float, lon=float)\n\nThis is more readable, and also lets you provide the mapping of fields and types as **fields_and_types.\n\nSince Python 3.6, typing.NamedTuple can also be used in a class statement, with type annotations written as described in PEP 526—Syntax for Variable Annotations. This is much more readable, and makes it easy to override methods or add new ones. Example 5-2 is the same Coordinate class, with a pair of float attributes and a cus‐ tom __str__ to display a coordinate formatted like 55.8°N, 37.6°E.\n\nExample 5-2. typing_namedtuple/coordinates.py\n\nfrom typing import NamedTuple\n\nclass Coordinate(NamedTuple): lat: float lon: float\n\ndef __str__(self): ns = 'N' if self.lat >= 0 else 'S' we = 'E' if self.lon >= 0 else 'W' return f'{abs(self.lat):.1f}°{ns}, {abs(self.lon):.1f}°{we}'\n\nAlthough NamedTuple appears in the class statement as a super‐ class, it’s actually not. typing.NamedTuple uses the advanced func‐ tionality of a metaclass2 to customize the creation of the user’s class. Check this out:\n\n>>> issubclass(Coordinate, typing.NamedTuple) False >>> issubclass(Coordinate, tuple) True\n\nIn the __init__ method generated by typing.NamedTuple, the fields appear as parameters in the same order they appear in the class statement.\n\nLike typing.NamedTuple, the dataclass decorator supports PEP 526 syntax to declare instance attributes. The decorator reads the variable annotations and auto‐ matically generates methods for your class. For comparison, check out the equivalent\n\n2 Metaclasses are one of the subjects covered in Chapter 24, “Class Metaprogramming”.\n\n166\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1778,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 197,
      "content": "Coordinate class written with the help of the dataclass decorator, as shown in Example 5-3.\n\nExample 5-3. dataclass/coordinates.py\n\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True) class Coordinate: lat: float lon: float\n\ndef __str__(self): ns = 'N' if self.lat >= 0 else 'S' we = 'E' if self.lon >= 0 else 'W' return f'{abs(self.lat):.1f}°{ns}, {abs(self.lon):.1f}°{we}'\n\nNote that the body of the classes in Example 5-2 and Example 5-3 are identical—the difference is in the class statement itself. The @dataclass decorator does not depend on inheritance or a metaclass, so it should not interfere with your own use of these mechanisms.3 The Coordinate class in Example 5-3 is a subclass of object.\n\nMain Features The different data class builders have a lot in common, as summarized in Table 5-1.\n\nTable 5-1. Selected features compared across the three data class builders; x stands for an instance of a data class of that kind\n\nmutable instances\n\nnamedtuple NO\n\nNamedTuple NO\n\ndataclass YES\n\nclass statement syntax\n\nNO\n\nYES\n\nYES\n\nconstruct dict\n\nx._asdict()\n\nx._asdict()\n\ndataclasses.asdict(x)\n\nget field names\n\nx._fields\n\nx._fields\n\n[f.name for f in dataclasses.fields(x)]\n\nget defaults\n\nx._field_defaults\n\nx._field_defaults\n\n[f.default for f in dataclasses.fields(x)]\n\nget field types\n\nN/A\n\nx.__annotations__\n\nx.__annotations__\n\nnew instance with changes\n\nx._replace(…)\n\nx._replace(…)\n\ndataclasses.replace(x, …)\n\nnew class at runtime\n\nnamedtuple(…)\n\nNamedTuple(…)\n\ndataclasses.make_dataclass(…)\n\n3 Class decorators are covered in Chapter 24, “Class Metaprogramming,” along with metaclasses. Both are ways\n\nof customizing class behavior beyond what is possible with inheritance.\n\nOverview of Data Class Builders\n\n|\n\n167",
      "content_length": 1734,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 198,
      "content": "The classes built by typing.NamedTuple and @dataclass have an __annotations__ attribute holding the type hints for the fields. However, reading from __annotations__ directly is not recom‐ mended. Instead, the recommended best practice to get that information is to call inspect.get_annotations(MyClass) (added in Python 3.10) or typing.get_type_hints(MyClass) (Python 3.5 to 3.9). That’s because those functions provide extra services, like resolving forward references in type hints. We’ll come back to this issue much later in the book, in “Problems with Annotations at Runtime” on page 538.\n\nNow let’s discuss those main features.\n\nMutable instances\n\nA key difference between these class builders is that collections.namedtuple and typing.NamedTuple build tuple subclasses, therefore the instances are immutable. By default, @dataclass produces mutable classes. But the decorator accepts a key‐ word argument frozen—shown in Example 5-3. When frozen=True, the class will raise an exception if you try to assign a value to a field after the instance is initialized.\n\nClass statement syntax\n\nOnly typing.NamedTuple and dataclass support the regular class statement syn‐ tax, making it easier to add methods and docstrings to the class you are creating.\n\nConstruct dict\n\nBoth named tuple variants provide an instance method (._asdict) to construct a dict object from the fields in a data class instance. The dataclasses module pro‐ vides a function to do it: dataclasses.asdict.\n\nGet field names and default values\n\nAll three class builders let you get the field names and default values that may be con‐ figured for them. In named tuple classes, that metadata is in the ._fields and ._fields_defaults class attributes. You can get the same metadata from a data class decorated class using the fields function from the dataclasses module. It returns a tuple of Field objects that have several attributes, including name and default.\n\n168\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1972,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 199,
      "content": "Get field types\n\nClasses defined with the help of typing.NamedTuple and @dataclass have a mapping of field names to type the __annotations__ class attribute. As mentioned, use the typing.get_type_hints function instead of reading __annotations__ directly.\n\nNew instance with changes\n\nGiven a named tuple instance x, the call x._replace(**kwargs) returns a new instance with some attribute values replaced according to the keyword arguments given. The dataclasses.replace(x, **kwargs) module-level function does the same for an instance of a dataclass decorated class.\n\nNew class at runtime\n\nAlthough the class statement syntax is more readable, it is hardcoded. A framework may need to build data classes on the fly, at runtime. For that, you can use the default function call syntax of collections.namedtuple, which is likewise supported by typing.NamedTuple. The dataclasses module provides a make_dataclass function for the same purpose.\n\nAfter this overview of the main features of the data class builders, let’s focus on each of them in turn, starting with the simplest.\n\nClassic Named Tuples The collections.namedtuple function is a factory that builds subclasses of tuple enhanced with field names, a class name, and an informative __repr__. Classes built with namedtuple can be used anywhere where tuples are needed, and in fact many functions of the Python standard library that are used to return tuples now return named tuples for convenience, without affecting the user’s code at all.\n\nEach instance of a class built by namedtuple takes exactly the same amount of memory as a tuple because the field names are stored in the class.\n\nExample 5-4 shows how we could define a named tuple to hold information about a city.\n\nExample 5-4. Defining and using a named tuple type\n\n>>> from collections import namedtuple >>> City = namedtuple('City', 'name country population coordinates')\n\nClassic Named Tuples\n\n|\n\n169",
      "content_length": 1920,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 200,
      "content": ">>> tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667)) >>> tokyo City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667)) >>> tokyo.population 36.933 >>> tokyo.coordinates (35.689722, 139.691667) >>> tokyo[1] 'JP'\n\nTwo parameters are required to create a named tuple: a class name and a list of field names, which can be given as an iterable of strings or as a single space- delimited string.\n\nField values must be passed as separate positional arguments to the constructor (in contrast, the tuple constructor takes a single iterable).\n\nYou can access the fields by name or position.\n\nAs a tuple subclass, City inherits useful methods such as __eq__ and the special methods for comparison operators—including __lt__, which allows sorting lists of City instances.\n\nA named tuple offers a few attributes and methods in addition to those inherited from the tuple. Example 5-5 shows the most useful: the _fields class attribute, the class method _make(iterable), and the _asdict() instance method.\n\nExample 5-5. Named tuple attributes and methods (continued from the previous example)\n\n>>> City._fields ('name', 'country', 'population', 'location') >>> Coordinate = namedtuple('Coordinate', 'lat lon') >>> delhi_data = ('Delhi NCR', 'IN', 21.935, Coordinate(28.613889, 77.208889)) >>> delhi = City._make(delhi_data) >>> delhi._asdict() {'name': 'Delhi NCR', 'country': 'IN', 'population': 21.935, 'location': Coordinate(lat=28.613889, lon=77.208889)} >>> import json >>> json.dumps(delhi._asdict()) '{\"name\": \"Delhi NCR\", \"country\": \"IN\", \"population\": 21.935, \"location\": [28.613889, 77.208889]}'\n\n._fields is a tuple with the field names of the class.\n\n._make() builds City from an iterable; City(*delhi_data) would do the same.\n\n170\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1808,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 201,
      "content": "._asdict() returns a dict built from the named tuple instance.\n\n._asdict() is useful to serialize the data in JSON format, for example.\n\nThe _asdict method returned an OrderedDict until Python 3.7. Since Python 3.8, it returns a simple dict—which is OK now that we can rely on key insertion order. If you must have an Ordered Dict, the _asdict documentation recommends building one from the result: OrderedDict(x._asdict()).\n\nSince Python 3.7, namedtuple accepts the defaults keyword-only argument provid‐ ing an iterable of N default values for each of the N rightmost fields of the class. Example 5-6 shows how to define a Coordinate named tuple with a default value for a reference field.\n\nExample 5-6. Named tuple attributes and methods, continued from Example 5-5\n\n>>> Coordinate = namedtuple('Coordinate', 'lat lon reference', defaults=['WGS84']) >>> Coordinate(0, 0) Coordinate(lat=0, lon=0, reference='WGS84') >>> Coordinate._field_defaults {'reference': 'WGS84'}\n\nIn “Class statement syntax” on page 168, I mentioned it’s easier to code methods with the class syntax supported by typing.NamedTuple and @dataclass. You can also add methods to a namedtuple, but it’s a hack. Skip the following box if you’re not interes‐ ted in hacks.\n\nHacking a namedtuple to Inject a Method\n\nRecall how we built the Card class in Example 1-1 in Chapter 1:\n\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n\nLater in Chapter 1, I wrote a spades_high function for sorting. It would be nice if that logic was encapsulated in a method of Card, but adding spades_high to Card without the benefit of a class statement requires a quick hack: define the function and then assign it to a class attribute. Example 5-7 shows how.\n\nExample 5-7. frenchdeck.doctest: Adding a class attribute and a method to Card, the namedtuple from “A Pythonic Card Deck” on page 5\n\n>>> Card.suit_values = dict(spades=3, hearts=2, diamonds=1, clubs=0) >>> def spades_high(card): ... rank_value = FrenchDeck.ranks.index(card.rank)\n\nClassic Named Tuples\n\n|\n\n171",
      "content_length": 2029,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 202,
      "content": "... suit_value = card.suit_values[card.suit] ... return rank_value * len(card.suit_values) + suit_value ... >>> Card.overall_rank = spades_high >>> lowest_card = Card('2', 'clubs') >>> highest_card = Card('A', 'spades') >>> lowest_card.overall_rank() 0 >>> highest_card.overall_rank() 51\n\nAttach a class attribute with values for each suit.\n\nspades_high will become a method; the first argument doesn’t need to be named self. Anyway, it will get the receiver when called as a method.\n\nAttach the function to the Card class as a method named overall_rank.\n\nIt works!\n\nFor readability and future maintenance, it’s much better to code methods inside a class statement. But it’s good to know this hack is possible, because it may come in handy.4\n\nThis was a small detour to showcase the power of a dynamic language.\n\nNow let’s check out the typing.NamedTuple variation.\n\nTyped Named Tuples The Coordinate class with a default field from Example 5-6 can be written using typing.NamedTuple, as shown in Example 5-8.\n\nExample 5-8. typing_namedtuple/coordinates2.py\n\nfrom typing import NamedTuple\n\nclass Coordinate(NamedTuple): lat: float lon: float reference: str = 'WGS84'\n\n4 If you know Ruby, you know that injecting methods is a well-known but controversial technique among\n\nRubyists. In Python, it’s not as common, because it doesn’t work with any built-in type—str, list, etc. I con‐ sider this limitation of Python a blessing.\n\n172\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1465,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 203,
      "content": "Every instance field must be annotated with a type.\n\nThe reference instance field is annotated with a type and a default value.\n\nClasses built by typing.NamedTuple don’t have any methods beyond those that col lections.namedtuple also generates—and those that are inherited from tuple. The only difference is the presence of the __annotations__ class attribute—which Python completely ignores at runtime.\n\nGiven that the main feature of typing.NamedTuple are the type annotations, we’ll take a brief look at them before resuming our exploration of data class builders.\n\nType Hints 101 Type hints—a.k.a. type annotations—are ways to declare the expected type of func‐ tion arguments, return values, variables, and attributes.\n\nThe first thing you need to know about type hints is that they are not enforced at all by the Python bytecode compiler and interpreter.\n\nThis is a very brief introduction to type hints, just enough to make sense of the syntax and meaning of the annotations used in typ ing.NamedTuple and @dataclass declarations. We will cover type hints for function signatures in Chapter 8 and more advanced annotations in Chapter 15. Here we’ll mostly see hints with simple built-in types, such as str, int, and float, which are probably the most common types used to annotate fields of data classes.\n\nNo Runtime Effect Think about Python type hints as “documentation that can be verified by IDEs and type checkers.”\n\nThat’s because type hints have no impact on the runtime behavior of Python pro‐ grams. Check out Example 5-9.\n\nExample 5-9. Python does not enforce type hints at runtime\n\n>>> import typing >>> class Coordinate(typing.NamedTuple): ... lat: float ... lon: float ... >>> trash = Coordinate('Ni!', None) >>> print(trash) Coordinate(lat='Ni!', lon=None)\n\nType Hints 101\n\n|\n\n173",
      "content_length": 1801,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 204,
      "content": "I told you: no type checking at runtime!\n\nIf you type the code of Example 5-9 in a Python module, it will run and display a meaningless Coordinate, with no error or warning:\n\n$ python3 nocheck_demo.py Coordinate(lat='Ni!', lon=None)\n\nThe type hints are intended primarily to support third-party type checkers, like Mypy or the PyCharm IDE built-in type checker. These are static analysis tools: they check Python source code “at rest,” not running code.\n\nTo see the effect of type hints, you must run one of those tools on your code—like a linter. For instance, here is what Mypy has to say about the previous example:\n\n$ mypy nocheck_demo.py nocheck_demo.py:8: error: Argument 1 to \"Coordinate\" has incompatible type \"str\"; expected \"float\" nocheck_demo.py:8: error: Argument 2 to \"Coordinate\" has incompatible type \"None\"; expected \"float\"\n\nAs you can see, given the definition of Coordinate, Mypy knows that both arguments to create an instance must be of type float, but the assignment to trash uses a str and None.5\n\nNow let’s talk about the syntax and meaning of type hints.\n\nVariable Annotation Syntax Both typing.NamedTuple and @dataclass use the syntax of variable annotations defined in PEP 526. This is a quick introduction to that syntax in the context defining attributes in class statements.\n\nThe basic syntax of variable annotation is:\n\nvar_name: some_type\n\nThe “Acceptable type hints” section in PEP 484 explains what are acceptable types, but in the context of defining a data class, these types are more likely to be useful:\n\nA concrete class, for example, str or FrenchDeck • A parameterized collection type, like list[int], tuple[str, float], etc.\n\n5 In the context of type hints, None is not the NoneType singleton, but an alias for NoneType itself. This is strange when we stop to think about it, but appeals to our intuition and makes function return annotations easier to read in the common case of functions that return None.\n\n174\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1990,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 205,
      "content": "typing.Optional, for example, Optional[str]—to declare a field that can be a str or None\n\nYou can also initialize the variable with a value. In a typing.NamedTuple or @data class declaration, that value will become the default for that attribute if the corre‐ sponding argument is omitted in the constructor call:\n\nvar_name: some_type = a_value\n\nThe Meaning of Variable Annotations We saw in “No Runtime Effect” on page 173 that type hints have no effect at runtime. But at import time—when a module is loaded—Python does read them to build the __annotations__ dictionary that typing.NamedTuple and @dataclass then use to enhance the class.\n\nWe’ll start this exploration with a simple class in Example 5-10, so that we can later see what extra features are added by typing.NamedTuple and @dataclass.\n\nExample 5-10. meaning/demo_plain.py: a plain class with type hints\n\nclass DemoPlainClass: a: int b: float = 1.1 c = 'spam'\n\na becomes an entry in __annotations__, but is otherwise discarded: no attribute named a is created in the class.\n\nb is saved as an annotation, and also becomes a class attribute with value 1.1.\n\nc is just a plain old class attribute, not an annotation.\n\nWe can verify that in the console, first reading the __annotations__ of the Demo PlainClass, then trying to get its attributes named a, b, and c:\n\n>>> from demo_plain import DemoPlainClass >>> DemoPlainClass.__annotations__ {'a': <class 'int'>, 'b': <class 'float'>} >>> DemoPlainClass.a Traceback (most recent call last): File \"<stdin>\", line 1, in <module> AttributeError: type object 'DemoPlainClass' has no attribute 'a' >>> DemoPlainClass.b 1.1 >>> DemoPlainClass.c 'spam'\n\nType Hints 101\n\n|\n\n175",
      "content_length": 1680,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 206,
      "content": "Note that the __annotations__ special attribute is created by the interpreter to record the type hints that appear in the source code—even in a plain class.\n\nThe a survives only as an annotation. It doesn’t become a class attribute because no value is bound to it.6 The b and c are stored as class attributes because they are bound to values.\n\nNone of those three attributes will be in a new instance of DemoPlainClass. If you create an object o = DemoPlainClass(), o.a will raise AttributeError, while o.b and o.c will retrieve the class attributes with values 1.1 and 'spam'—that’s just nor‐ mal Python object behavior.\n\nInspecting a typing.NamedTuple\n\nNow let’s examine a class built with typing.NamedTuple (Example 5-11), using the same attributes and annotations as DemoPlainClass from Example 5-10.\n\nExample 5-11. meaning/demo_nt.py: a class built with typing.NamedTuple\n\nimport typing\n\nclass DemoNTClass(typing.NamedTuple): a: int b: float = 1.1 c = 'spam'\n\na becomes an annotation and also an instance attribute.\n\nb is another annotation, and also becomes an instance attribute with default value 1.1.\n\nc is just a plain old class attribute; no annotation will refer to it.\n\nInspecting the DemoNTClass, we get:\n\n>>> from demo_nt import DemoNTClass >>> DemoNTClass.__annotations__ {'a': <class 'int'>, 'b': <class 'float'>} >>> DemoNTClass.a <_collections._tuplegetter object at 0x101f0f940> >>> DemoNTClass.b <_collections._tuplegetter object at 0x101f0f8b0> >>> DemoNTClass.c 'spam'\n\n6 Python has no concept of undefined, one of the silliest mistakes in the design of JavaScript. Thank Guido!\n\n176\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1641,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 207,
      "content": "Here we have the same annotations for a and b as we saw in Example 5-10. But typ ing.NamedTuple creates a and b class attributes. The c attribute is just a plain class attribute with the value 'spam'.\n\nThe a and b class attributes are descriptors—an advanced feature covered in Chap‐ ter 23. For now, think of them as similar to property getters: methods that don’t require the explicit call operator () to retrieve an instance attribute. In practice, this means a and b will work as read-only instance attributes—which makes sense when we recall that DemoNTClass instances are just fancy tuples, and tuples are immutable.\n\nDemoNTClass also gets a custom docstring:\n\n>>> DemoNTClass.__doc__ 'DemoNTClass(a, b)'\n\nLet’s inspect an instance of DemoNTClass:\n\n>>> nt = DemoNTClass(8) >>> nt.a 8 >>> nt.b 1.1 >>> nt.c 'spam'\n\nTo construct nt, we need to give at least the a argument to DemoNTClass. The con‐ structor also takes a b argument, but it has a default value of 1.1, so it’s optional. The nt object has the a and b attributes as expected; it doesn’t have a c attribute, but Python retrieves it from the class, as usual.\n\nIf you try to assign values to nt.a, nt.b, nt.c, or even nt.z, you’ll get Attribute Error exceptions with subtly different error messages. Try that and reflect on the messages.\n\nInspecting a class decorated with dataclass\n\nNow, we’ll examine Example 5-12.\n\nExample 5-12. meaning/demo_dc.py: a class decorated with @dataclass\n\nfrom dataclasses import dataclass\n\n@dataclass class DemoDataClass: a: int b: float = 1.1 c = 'spam'\n\nType Hints 101\n\n|\n\n177",
      "content_length": 1574,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 208,
      "content": "a becomes an annotation and also an instance attribute controlled by a descriptor.\n\nb is another annotation, and also becomes an instance attribute with a descriptor and a default value 1.1.\n\nc is just a plain old class attribute; no annotation will refer to it.\n\nNow let’s check out __annotations__, __doc__, and the a, b, c attributes on Demo DataClass:\n\n>>> from demo_dc import DemoDataClass >>> DemoDataClass.__annotations__ {'a': <class 'int'>, 'b': <class 'float'>} >>> DemoDataClass.__doc__ 'DemoDataClass(a: int, b: float = 1.1)' >>> DemoDataClass.a Traceback (most recent call last): File \"<stdin>\", line 1, in <module> AttributeError: type object 'DemoDataClass' has no attribute 'a' >>> DemoDataClass.b 1.1 >>> DemoDataClass.c 'spam'\n\nThe __annotations__ and __doc__ are not surprising. However, there is no attribute named a in DemoDataClass—in contrast with DemoNTClass from Example 5-11, which has a descriptor to get a from the instances as read-only attributes (that myste‐ rious <_collections._tuplegetter>). That’s because the a attribute will only exist in instances of DemoDataClass. It will be a public attribute that we can get and set, unless the class is frozen. But b and c exist as class attributes, with b holding the default value for the b instance attribute, while c is just a class attribute that will not be bound to the instances.\n\nNow let’s see how a DemoDataClass instance looks:\n\n>>> dc = DemoDataClass(9) >>> dc.a 9 >>> dc.b 1.1 >>> dc.c 'spam'\n\nAgain, a and b are instance attributes, and c is a class attribute we get via the instance.\n\nAs mentioned, DemoDataClass instances are mutable—and no type checking is done at runtime:\n\n178\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1706,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 209,
      "content": ">>> dc.a = 10 >>> dc.b = 'oops'\n\nWe can do even sillier assignments:\n\n>>> dc.c = 'whatever' >>> dc.z = 'secret stash'\n\nNow the dc instance has a c attribute—but that does not change the c class attribute. And we can add a new z attribute. This is normal Python behavior: regular instances can have their own attributes that don’t appear in the class.7\n\nMore About @dataclass We’ve only seen simple examples of @dataclass use so far. The decorator accepts several keyword arguments. This is its signature:\n\n@dataclass(*, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)\n\nThe * in the first position means the remaining parameters are keyword-only. Table 5-2 describes them.\n\nTable 5-2. Keyword parameters accepted by the @dataclass decorator\n\nOption\n\ninit\n\nMeaning Generate __init__\n\nDefault\n\nTrue\n\nNotes Ignored if __init__ is implemented by user.\n\nrepr\n\nGenerate __repr__\n\nTrue\n\nIgnored if __repr__ is implemented by user.\n\neq\n\nGenerate __eq__\n\nTrue\n\nIgnored if __eq__ is implemented by user.\n\norder\n\nGenerate __lt__, __le__, __gt__, __ge__\n\nFalse\n\nIf True, raises exceptions if eq=False, or if any of the comparison methods that would be generated are defined or inherited.\n\nunsafe_hash\n\nGenerate __hash__\n\nFalse\n\nComplex semantics and several caveats— see: dataclass documentation.\n\nfrozen\n\nMake instances “immutable”\n\nFalse\n\nInstances will be reasonably safe from accidental change, but not really immutable.a\n\na @dataclass emulates immutability by generating __setattr__ and __delattr__, which raise data class.FrozenInstanceError—a subclass of AttributeError—when the user attempts to set or delete a field.\n\n7 Setting an attribute after __init__ defeats the __dict__ key-sharing memory optimization mentioned in\n\n“Practical Consequences of How dict Works” on page 102.\n\nMore About @dataclass\n\n|\n\n179",
      "content_length": 1834,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 210,
      "content": "The defaults are really the most useful settings for common use cases. The options you are more likely to change from the defaults are:\n\nfrozen=True\n\nProtects against accidental changes to the class instances.\n\norder=True\n\nAllows sorting of instances of the data class.\n\nGiven the dynamic nature of Python objects, it’s not too hard for a nosy programmer to go around the protection afforded by frozen=True. But the necessary tricks should be easy to spot in a code review.\n\nIf the eq and frozen arguments are both True, @dataclass produces a suitable __hash__ method, so the instances will be hashable. The generated __hash__ will use data from all fields that are not individually excluded using a field option we’ll see in “Field Options” on page 180. If frozen=False (the default), @dataclass will set __hash__ to None, signalling that the instances are unhashable, therefore overriding __hash__ from any superclass.\n\nPEP 557—Data Classes has this to say about unsafe_hash:\n\nAlthough not recommended, you can force Data Classes to create a __hash__ method with unsafe_hash=True. This might be the case if your class is logically immutable but can nonetheless be mutated. This is a specialized use case and should be considered carefully.\n\nI will leave unsafe_hash at that. If you feel you must use that option, check the data classes.dataclass documentation.\n\nFurther customization of the generated data class can be done at a field level.\n\nField Options We’ve already seen the most basic field option: providing (or not) a default value with the type hint. The instance fields you declare will become parameters in the gen‐ erated __init__. Python does not allow parameters without defaults after parameters with defaults, therefore after you declare a field with a default value, all remaining fields must also have default values.\n\nMutable default values are a common source of bugs for beginning Python develop‐ ers. In function definitions, a mutable default value is easily corrupted when one invocation of the function mutates the default, changing the behavior of further invo‐ cations—an issue we’ll explore in “Mutable Types as Parameter Defaults: Bad Idea” on page 214 (Chapter 6). Class attributes are often used as default attribute values for instances, including in data classes. And @dataclass uses the default values in the\n\n180\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 2384,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 211,
      "content": "type hints to generate parameters with defaults for __init__. To prevent bugs, @data class rejects the class definition in Example 5-13.\n\nExample 5-13. dataclass/club_wrong.py: this class raises ValueError\n\n@dataclass class ClubMember: name: str guests: list = []\n\nIf you load the module with that ClubMember class, this is what you get:\n\n$ python3 club_wrong.py Traceback (most recent call last): File \"club_wrong.py\", line 4, in <module> class ClubMember: ...several lines omitted... ValueError: mutable default <class 'list'> for field guests is not allowed: use default_factory\n\nThe ValueError message explains the problem and suggests a solution: use default_factory. Example 5-14 shows how to correct ClubMember.\n\nExample 5-14. dataclass/club.py: this ClubMember definition works\n\nfrom dataclasses import dataclass, field\n\n@dataclass class ClubMember: name: str guests: list = field(default_factory=list)\n\nIn the guests field of Example 5-14, instead of a literal list, the default value is set by calling the dataclasses.field function with default_factory=list.\n\nThe default_factory parameter lets you provide a function, class, or any other call‐ able, which will be invoked with zero arguments to build a default value each time an instance of the data class is created. This way, each instance of ClubMember will have its own list—instead of all instances sharing the same list from the class, which is rarely what we want and is often a bug.\n\nIt’s good that @dataclass rejects class definitions with a list default value in a field. However, be aware that it is a partial solu‐ tion that only applies to list, dict, and set. Other mutable values used as defaults will not be flagged by @dataclass. It’s up to you to understand the problem and remember to use a default factory to set mutable default values.\n\nMore About @dataclass\n\n|\n\n181",
      "content_length": 1850,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 212,
      "content": "If you browse the dataclasses module documentation, you’ll see a list field defined with a novel syntax, as in Example 5-15.\n\nExample 5-15. dataclass/club_generic.py: this ClubMember definition is more precise\n\nfrom dataclasses import dataclass, field\n\n@dataclass class ClubMember: name: str guests: list[str] = field(default_factory=list)\n\nlist[str] means “a list of str.”\n\nThe new syntax list[str] is a parameterized generic type: since Python 3.9, the list built-in accepts that bracket notation to specify the type of the list items.\n\nPrior to Python 3.9, the built-in collections did not support generic type notation. As a temporary workaround, there are correspond‐ ing collection types in the typing module. If you need a parameter‐ ized list type hint in Python 3.8 or earlier, you must import the List type from typing and use it: List[str]. For more about this issue, see “Legacy Support and Deprecated Collection Types” on page 272.\n\nWe’ll cover generics in Chapter 8. For now, note that Examples 5-14 and 5-15 are both correct, and the Mypy type checker does not complain about either of those class definitions.\n\nThe difference is that guests: list means that guests can be a list of objects of any kind, while guests: list[str] says that guests must be a list in which every item is a str. This will allow the type checker to find (some) bugs in code that puts invalid items in the list, or that read items from it.\n\nThe default_factory is likely to be the most common option of the field function, but there are several others, listed in Table 5-3.\n\nTable 5-3. Keyword arguments accepted by the field function\n\nOption\n\ndefault\n\nMeaning Default value for field\n\nDefault _MISSING_TYPEa\n\ndefault_factory\n\n0-parameter function used to produce a default _MISSING_TYPE\n\ninit\n\nInclude field in parameters to __init__\n\nTrue\n\nrepr\n\nInclude field in __repr__\n\nTrue\n\n182\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1910,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 213,
      "content": "Option\n\ncompare\n\nMeaning Use field in comparison methods __eq__, __lt__, etc.\n\nDefault\n\nTrue\n\nhash\n\nInclude field in __hash__ calculation\n\nNoneb\n\nmetadata\n\nMapping with user-defined data; ignored by the @dataclass\n\nNone\n\na dataclass._MISSING_TYPE is a sentinel value indicating the option was not provided. It exists so we can set None as an actual default value, a common use case. b The option hash=None means the field will be used in __hash__ only if compare=True.\n\nThe default option exists because the field call takes the place of the default value in the field annotation. If you want to create an athlete field with a default value of False, and also omit that field from the __repr__ method, you’d write this:\n\n@dataclass class ClubMember: name: str guests: list = field(default_factory=list) athlete: bool = field(default=False, repr=False)\n\nPost-init Processing The __init__ method generated by @dataclass only takes the arguments passed and assigns them—or their default values, if missing—to the instance attributes that are instance fields. But you may need to do more than that to initialize the instance. If that’s the case, you can provide a __post_init__ method. When that method exists, @dataclass will add code to the generated __init__ to call __post_init__ as the last step.\n\nCommon use cases for __post_init__ are validation and computing field values based on other fields. We’ll study a simple example that uses __post_init__ for both of these reasons.\n\nFirst, let’s look at the expected behavior of a ClubMember subclass named HackerClub Member, as described by doctests in Example 5-16.\n\nExample 5-16. dataclass/hackerclub.py: doctests for HackerClubMember\n\n\"\"\" ``HackerClubMember`` objects accept an optional ``handle`` argument::\n\n>>> anna = HackerClubMember('Anna Ravenscroft', handle='AnnaRaven') >>> anna HackerClubMember(name='Anna Ravenscroft', guests=[], handle='AnnaRaven')\n\nIf ``handle`` is omitted, it's set to the first part of the member's name::\n\nMore About @dataclass\n\n|\n\n183",
      "content_length": 2018,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 214,
      "content": ">>> leo = HackerClubMember('Leo Rochael') >>> leo HackerClubMember(name='Leo Rochael', guests=[], handle='Leo')\n\nMembers must have a unique handle. The following ``leo2`` will not be created, because its ``handle`` would be 'Leo', which was taken by ``leo``::\n\n>>> leo2 = HackerClubMember('Leo DaVinci') Traceback (most recent call last): ... ValueError: handle 'Leo' already exists.\n\nTo fix, ``leo2`` must be created with an explicit ``handle``::\n\n>>> leo2 = HackerClubMember('Leo DaVinci', handle='Neo') >>> leo2 HackerClubMember(name='Leo DaVinci', guests=[], handle='Neo') \"\"\"\n\nNote that we must provide handle as a keyword argument, because HackerClubMem ber inherits name and guests from ClubMember, and adds the handle field. The gen‐ erated docstring for HackerClubMember shows the order of the fields in the constructor call:\n\n>>> HackerClubMember.__doc__ \"HackerClubMember(name: str, guests: list = <factory>, handle: str = '')\"\n\nHere, <factory> is a short way of saying that some callable will produce the default value for guests (in our case, the factory is the list class). The point is: to provide a handle but no guests, we must pass handle as a keyword argument.\n\nThe “Inheritance” section of the dataclasses module documentation explains how the order of the fields is computed when there are several levels of inheritance.\n\nIn Chapter 14 we’ll talk about misusing inheritance, particularly when the superclasses are not abstract. Creating a hierarchy of data classes is usually a bad idea, but it served us well here to make Example 5-17 shorter, focusing on the handle field declaration and __post_init__ validation.\n\nExample 5-17 shows the implementation.\n\nExample 5-17. dataclass/hackerclub.py: code for HackerClubMember\n\nfrom dataclasses import dataclass from club import ClubMember\n\n184\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1845,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 215,
      "content": "@dataclass class HackerClubMember(ClubMember): all_handles = set() handle: str = ''\n\ndef __post_init__(self): cls = self.__class__ if self.handle == '': self.handle = self.name.split()[0] if self.handle in cls.all_handles: msg = f'handle {self.handle!r} already exists.' raise ValueError(msg) cls.all_handles.add(self.handle)\n\nHackerClubMember extends ClubMember.\n\nall_handles is a class attribute.\n\nhandle is an instance field of type str with an empty string as its default value; this makes it optional.\n\nGet the class of the instance.\n\nIf self.handle is the empty string, set it to the first part of name.\n\nIf self.handle is in cls.all_handles, raise ValueError.\n\nAdd the new handle to cls.all_handles.\n\nExample 5-17 works as intended, but is not satisfactory to a static type checker. Next, we’ll see why, and how to fix it.\n\nTyped Class Attributes If we type check Example 5-17 with Mypy, we are reprimanded:\n\n$ mypy hackerclub.py hackerclub.py:37: error: Need type annotation for \"all_handles\" (hint: \"all_handles: Set[<type>] = ...\") Found 1 error in 1 file (checked 1 source file)\n\nUnfortunately, the hint provided by Mypy (version 0.910 as I review this) is not help‐ ful in the context of @dataclass usage. First, it suggests using Set, but I am using Python 3.9 so I can use set—and avoid importing Set from typing. More impor‐ tantly, if we add a type hint like set[…] to all_handles, @dataclass will find that annotation and make all_handles an instance field. We saw this happening in “Inspecting a class decorated with dataclass” on page 177.\n\nMore About @dataclass\n\n|\n\n185",
      "content_length": 1589,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 216,
      "content": "The workaround defined in PEP 526—Syntax for Variable Annotations is ugly. To code a class variable with a type hint, we need to use a pseudotype named typ ing.ClassVar, which leverages the generics [] notation to set the type of the variable and also declare it a class attribute.\n\nTo make the type checker and @dataclass happy, this is how we are supposed to declare all_handles in Example 5-17:\n\nall_handles: ClassVar[set[str]] = set()\n\nThat type hint is saying:\n\nall_handles is a class attribute of type set-of-str, with an empty set as its default value.\n\nTo code that annotation, we must import ClassVar from the typing module.\n\nThe @dataclass decorator doesn’t care about the types in the annotations, except in two cases, and this is one of them: if the type is ClassVar, an instance field will not be generated for that attribute.\n\nThe other case where the type of the field is relevant to @dataclass is when declaring init-only variables, our next topic.\n\nInitialization Variables That Are Not Fields Sometimes you may need to pass arguments to __init__ that are not instance fields. Such arguments are called init-only variables by the dataclasses documentation. To declare an argument like that, the dataclasses module provides the pseudotype Init Var, which uses the same syntax of typing.ClassVar. The example given in the doc‐ umentation is a data class that has a field initialized from a database, and the database object must be passed to the constructor.\n\nExample 5-18 shows the code that illustrates the “Init-only variables” section.\n\nExample 5-18. Example from the dataclasses module documentation\n\n@dataclass class C: i: int j: int = None database: InitVar[DatabaseType] = None\n\ndef __post_init__(self, database): if self.j is None and database is not None: self.j = database.lookup('j')\n\nc = C(10, database=my_database)\n\n186\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1883,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 217,
      "content": "Note how the database attribute is declared. InitVar will prevent @dataclass from treating database as a regular field. It will not be set as an instance attribute, and the dataclasses.fields function will not list it. However, database will be one of the arguments that the generated __init__ will accept, and it will be also passed to __post_init__. If you write that method, you must add a corresponding argument to the method signature, as shown in Example 5-18.\n\nThis rather long overview of @dataclass covered the most useful features—some of them appeared in previous sections, like “Main Features” on page 167 where we cov‐ ered all three data class builders in parallel. The dataclasses documentation and PEP 526—Syntax for Variable Annotations have all the details.\n\nIn the next section, I present a longer example with @dataclass.\n\n@dataclass Example: Dublin Core Resource Record Often, classes built with @dataclass will have more fields than the very short exam‐ ples presented so far. Dublin Core provides the foundation for a more typical @data class example.\n\nThe Dublin Core Schema is a small set of vocabulary terms that can be used to describe digital resources (video, images, web pages, etc.), as well as physical resources such as books or CDs, and objects like artworks.8\n\n—Dublin Core on Wikipedia\n\nThe standard defines 15 optional fields; the Resource class in Example 5-19 uses 8 of them.\n\nExample 5-19. dataclass/resource.py: code for Resource, a class based on Dublin Core terms\n\nfrom dataclasses import dataclass, field from typing import Optional from enum import Enum, auto from datetime import date\n\nclass ResourceType(Enum): BOOK = auto() EBOOK = auto() VIDEO = auto()\n\n@dataclass\n\n8 Source: Dublin Core article in the English Wikipedia.\n\nMore About @dataclass\n\n|\n\n187",
      "content_length": 1801,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 218,
      "content": "class Resource: \"\"\"Media resource description.\"\"\" identifier: str title: str = '<untitled>' creators: list[str] = field(default_factory=list) date: Optional[date] = None type: ResourceType = ResourceType.BOOK description: str = '' language: str = '' subjects: list[str] = field(default_factory=list)\n\nThis Enum will provide type-safe values for the Resource.type field.\n\nidentifier is the only required field.\n\ntitle is the first field with a default. This forces all fields below to provide defaults.\n\nThe value of date can be a datetime.date instance, or None.\n\nThe type field default is ResourceType.BOOK.\n\nExample 5-20 shows a doctest to demonstrate how a Resource record appears in code.\n\nExample 5-20. dataclass/resource.py: code for Resource, a class based on Dublin Core terms\n\n>>> description = 'Improving the design of existing code' >>> book = Resource('978-0-13-475759-9', 'Refactoring, 2nd Edition', ... ['Martin Fowler', 'Kent Beck'], date(2018, 11, 19), ... ResourceType.BOOK, description, 'EN', ... ['computer programming', 'OOP']) >>> book # doctest: +NORMALIZE_WHITESPACE Resource(identifier='978-0-13-475759-9', title='Refactoring, 2nd Edition', creators=['Martin Fowler', 'Kent Beck'], date=datetime.date(2018, 11, 19), type=<ResourceType.BOOK: 1>, description='Improving the design of existing code', language='EN', subjects=['computer programming', 'OOP'])\n\nThe __repr__ generated by @dataclass is OK, but we can make it more readable. This is the format we want from repr(book):\n\n>>> book # doctest: +NORMALIZE_WHITESPACE Resource( identifier = '978-0-13-475759-9', title = 'Refactoring, 2nd Edition', creators = ['Martin Fowler', 'Kent Beck'], date = datetime.date(2018, 11, 19), type = <ResourceType.BOOK: 1>,\n\n188\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1774,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 219,
      "content": "description = 'Improving the design of existing code', language = 'EN', subjects = ['computer programming', 'OOP'], )\n\nExample 5-21 is the code of __repr__ to produce the format shown in the last snip‐ pet. This example uses dataclass.fields to get the names of the data class fields.\n\nExample 5-21. dataclass/resource_repr.py: code for __repr__ method implemented in the Resource class from Example 5-19\n\ndef __repr__(self): cls = self.__class__ cls_name = cls.__name__ indent = ' ' * 4 res = [f'{cls_name}('] for f in fields(cls): value = getattr(self, f.name) res.append(f'{indent}{f.name} = {value!r},')\n\nres.append(')') return '\\n'.join(res)\n\nStart the res list to build the output string with the class name and open parenthesis.\n\nFor each field f in the class…\n\n…get the named attribute from the instance.\n\nAppend an indented line with the name of the field and repr(value)—that’s what the !r does.\n\nAppend closing parenthesis.\n\nBuild a multiline string from res and return it.\n\nWith this example inspired by the soul of Dublin, Ohio, we conclude our tour of Python’s data class builders.\n\nData classes are handy, but your project may suffer if you overuse them. The next section explains.\n\nMore About @dataclass\n\n|\n\n189",
      "content_length": 1227,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 220,
      "content": "Data Class as a Code Smell Whether you implement a data class by writing all the code yourself or leveraging one of the class builders described in this chapter, be aware that it may signal a prob‐ lem in your design.\n\nIn Refactoring: Improving the Design of Existing Code, 2nd ed. (Addison-Wesley), Martin Fowler and Kent Beck present a catalog of “code smells”—patterns in code that may indicate the need for refactoring. The entry titled “Data Class” starts like this:\n\nThese are classes that have fields, getting and setting methods for fields, and nothing else. Such classes are dumb data holders and are often being manipulated in far too much detail by other classes.\n\nIn Fowler’s personal website, there’s an illuminating post titled “Code Smell”. The post is very relevant to our discussion because he uses data class as one example of a code smell and suggests how to deal with it. Here is the post, reproduced in full.9\n\nCode Smell\n\nBy Martin Fowler\n\nA code smell is a surface indication that usually corresponds to a deeper problem in the system. The term was first coined by Kent Beck while helping me with my Refac‐ toring book.\n\nThe quick definition above contains a couple of subtle points. Firstly, a smell is by definition something that’s quick to spot—or sniffable as I’ve recently put it. A long method is a good example of this—just looking at the code and my nose twitches if I see more than a dozen lines of Java.\n\nThe second is that smells don’t always indicate a problem. Some long methods are just fine. You have to look deeper to see if there is an underlying problem there— smells aren’t inherently bad on their own—they are often an indicator of a problem rather than the problem themselves.\n\nThe best smells are something that’s easy to spot and most of the time lead you to really interesting problems. Data classes (classes with all data and no behavior) are good examples of this. You look at them and ask yourself what behavior should be in this class. Then you start refactoring to move that behavior in there. Often simple questions and initial refactorings can be the vital step in turning anemic objects into something that really has class.\n\n9 I am fortunate to have Martin Fowler as a colleague at Thoughtworks, so it took just 20 minutes to get his\n\npermission.\n\n190\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 2343,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 221,
      "content": "One of the nice things about smells is that it’s easy for inexperienced people to spot them, even if they don’t know enough to evaluate if there’s a real problem or to cor‐ rect them. I’ve heard of lead developers who will pick a “smell of the week” and ask people to look for the smell and bring it up with the senior members of the team. Doing it one smell at a time is a good way of gradually teaching people on the team to be better programmers.\n\nThe main idea of object-oriented programming is to place behavior and data together in the same code unit: a class. If a class is widely used but has no significant behavior of its own, it’s possible that code dealing with its instances is scattered (and even duplicated) in methods and functions throughout the system—a recipe for mainte‐ nance headaches. That’s why Fowler’s refactorings to deal with a data class involve bringing responsibilities back into it.\n\nTaking that into account, there are a couple of common scenarios where it makes sense to have a data class with little or no behavior.\n\nData Class as Scaffolding In this scenario, the data class is an initial, simplistic implementation of a class to jump-start a new project or module. With time, the class should get its own methods, instead of relying on methods of other classes to operate on its instances. Scaffolding is temporary; eventually your custom class may become fully independent from the builder you used to start it.\n\nPython is also used for quick problem solving and experimentation, and then it’s OK to leave the scaffolding in place.\n\nData Class as Intermediate Representation A data class can be useful to build records about to be exported to JSON or some other interchange format, or to hold data that was just imported, crossing some sys‐ tem boundary. Python’s data class builders all provide a method or function to con‐ vert an instance to a plain dict, and you can always invoke the constructor with a dict used as keyword arguments expanded with **. Such a dict is very close to a JSON record.\n\nIn this scenario, the data class instances should be handled as immutable objects— even if the fields are mutable, you should not change them while they are in this intermediate form. If you do, you’re losing the key benefit of having data and behav‐ ior close together. When importing/exporting requires changing values, you should implement your own builder methods instead of using the given “as dict” methods or standard constructors.\n\nData Class as a Code Smell\n\n|\n\n191",
      "content_length": 2514,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 222,
      "content": "Now we change the subject to see how to write patterns that match instances of arbi‐ trary classes, and not just the sequences and mappings we’ve seen in “Pattern Match‐ ing with Sequences” on page 38 and “Pattern Matching with Mappings” on page 81.\n\nPattern Matching Class Instances Class patterns are designed to match class instances by type and—optionally—by attributes. The subject of a class pattern can be any class instance, not only instances of data classes.10\n\nThere are three variations of class patterns: simple, keyword, and positional. We’ll study them in that order.\n\nSimple Class Patterns We’ve already seen an example with simple class patterns used as subpatterns in “Pat‐ tern Matching with Sequences” on page 38:\n\ncase [str(name), _, _, (float(lat), float(lon))]:\n\nThat pattern matches a four-item sequence where the first item must be an instance of str, and the last item must be a 2-tuple with two instances of float.\n\nThe syntax for class patterns looks like a constructor invocation. The following is a class pattern that matches float values without binding a variable (the case body can refer to x directly if needed):\n\nmatch x: case float(): do_something_with(x)\n\nBut this is likely to be a bug in your code:\n\nmatch x: case float: # DANGER!!! do_something_with(x)\n\nIn the preceding example, case float: matches any subject, because Python sees float as a variable, which is then bound to the subject.\n\nThe simple pattern syntax of float(x) is a special case that applies only to nine blessed built-in types, listed at the end of the “Class Patterns” section of PEP 634— Structural Pattern Matching: Specification:\n\nbytes dict float frozenset int list set str tuple\n\n10 I put this content here because it is the earliest chapter focusing on user-defined classes, and I thought pattern matching with classes was too important to wait until Part II of the book. My philosophy: it’s more important to know how to use classes than to define classes.\n\n192\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 2013,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 223,
      "content": "In those classes, the variable that looks like a constructor argument—e.g., the x in float(x)—is bound to the whole subject instance or the part of the subject that matches a subpattern, as exemplified by str(name) in the sequence pattern we saw earlier:\n\ncase [str(name), _, _, (float(lat), float(lon))]:\n\nIf the class is not one of those nine blessed built-ins, then the argument-like variables represent patterns to be matched against attributes of an instance of that class.\n\nKeyword Class Patterns To understand how to use keyword class patterns, consider the following City class and five instances in Example 5-22.\n\nExample 5-22. City class and a few instances\n\nimport typing\n\nclass City(typing.NamedTuple): continent: str name: str country: str\n\ncities = [ City('Asia', 'Tokyo', 'JP'), City('Asia', 'Delhi', 'IN'), City('North America', 'Mexico City', 'MX'), City('North America', 'New York', 'US'), City('South America', 'São Paulo', 'BR'), ]\n\nGiven those definitions, the following function would return a list of Asian cities:\n\ndef match_asian_cities(): results = [] for city in cities: match city: case City(continent='Asia'): results.append(city) return results\n\nThe pattern City(continent='Asia') matches any City instance where the conti nent attribute value is equal to 'Asia', regardless of the values of the other attributes.\n\nIf you want to collect the value of the country attribute, you could write:\n\ndef match_asian_countries(): results = [] for city in cities:\n\nPattern Matching Class Instances\n\n|\n\n193",
      "content_length": 1525,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 224,
      "content": "match city: case City(continent='Asia', country=cc): results.append(cc) return results\n\nThe pattern City(continent='Asia', country=cc) matches the same Asian cities as before, but now the cc variable is bound to the country attribute of the instance. This also works if the pattern variable is called country as well:\n\nmatch city: case City(continent='Asia', country=country): results.append(country)\n\nKeyword class patterns are very readable, and work with any class that has public instance attributes, but they are somewhat verbose.\n\nPositional class patterns are more convenient in some cases, but they require explicit support by the class of the subject, as we’ll see next.\n\nPositional Class Patterns Given the definitions from Example 5-22, the following function would return a list of Asian cities, using a positional class pattern:\n\ndef match_asian_cities_pos(): results = [] for city in cities: match city: case City('Asia'): results.append(city) return results\n\nThe pattern City('Asia') matches any City instance where the first attribute value is 'Asia', regardless of the values of the other attributes.\n\nIf you want to collect the value of the country attribute, you could write:\n\ndef match_asian_countries_pos(): results = [] for city in cities: match city: case City('Asia', _, country): results.append(country) return results\n\nThe pattern City('Asia', _, country) matches the same cities as before, but now the country variable is bound to the third attribute of the instance.\n\nI’ve mentioned “first” or “third” attribute, but what does that really mean?\n\n194\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1612,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 225,
      "content": "What makes City or any class work with positional patterns is the presence of a spe‐ cial class attribute named __match_args__, which the class builders in this chapter automatically create. This is the value of __match_args__ in the City class:\n\n>>> City.__match_args__ ('continent', 'name', 'country')\n\nAs you can see, __match_args__ declares the names of the attributes in the order they will be used in positional patterns.\n\nIn “Supporting Positional Pattern Matching” on page 377 we’ll write code to define __match_args__ for a class we’ll create without the help of a class builder.\n\nYou can combine keyword and positional arguments in a pattern. Some, but not all, of the instance attributes available for matching may be listed in __match_args__. Therefore, sometimes you may need to use keyword arguments in addition to positional argu‐ ments in a pattern.\n\nTime for a chapter summary.\n\nChapter Summary The main topic of this chapter was the data class builders collections.namedtuple, typing.NamedTuple, and dataclasses.dataclass. We saw that each generates data classes from descriptions provided as arguments to a factory function, or from class statements with type hints in the case of the latter two. In particular, both named tuple variants produce tuple subclasses, adding only the ability to access fields by name, and providing a _fields class attribute listing the field names as a tuple of strings.\n\nNext we studied the main features of the three class builders side by side, including how to extract instance data as a dict, how to get the names and default values of fields, and how to make a new instance from an existing one.\n\nThis prompted our first look into type hints, particularly those used to annotate attributes in a class statement, using the notation introduced in Python 3.6 with PEP 526—Syntax for Variable Annotations. Probably the most surprising aspect of type hints in general is the fact that they have no effect at all at runtime. Python remains a dynamic language. External tools, like Mypy, are needed to take advantage of typing information to detect errors via static analysis of the source code. After a basic overview of the syntax from PEP 526, we studied the effect of annotations in a plain class and in classes built by typing.NamedTuple and @dataclass.\n\nChapter Summary\n\n|\n\n195",
      "content_length": 2331,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 226,
      "content": "Next, we covered the most commonly used features provided by @dataclass and the default_factory option of the dataclasses.field function. We also looked into the special pseudotype hints typing.ClassVar and dataclasses.InitVar that are important in the context of data classes. This main topic concluded with an example based on the Dublin Core Schema, which illustrated how to use dataclasses.fields to iterate over the attributes of a Resource instance in a custom __repr__.\n\nThen, we warned against possible abuse of data classes defeating a basic principle of object-oriented programming: data and the functions that touch it should be together in the same class. Classes with no logic may be a sign of misplaced logic.\n\nIn the last section, we saw how pattern matching works with subjects that are instan‐ ces of any class—not just classes built with the class builders presented in this chapter.\n\nFurther Reading Python’s standard documentation for the data class builders we covered is very good, and has quite a few small examples.\n\nFor @dataclass in particular, most of PEP 557—Data Classes was copied into the dataclasses module documentation. But PEP 557 has a few very informative sec‐ tions that were not copied, including “Why not just use namedtuple?”, “Why not just use typing.NamedTuple?”, and the “Rationale” section, which concludes with this Q&A:\n\nWhere is it not appropriate to use Data Classes?\n\nAPI compatibility with tuples or dicts is required. Type validation beyond that pro‐ vided by PEPs 484 and 526 is required, or value validation or conversion is required.\n\n—Eric V. Smith, PEP 557 “Rationale”\n\nOver at RealPython.com, Geir Arne Hjelle wrote a very complete “Ultimate guide to data classes in Python 3.7”.\n\nAt PyCon US 2018, Raymond Hettinger presented “Dataclasses: The code generator to end all code generators” (video).\n\nFor more features and advanced functionality, including validation, the attrs project led by Hynek Schlawack appeared years before dataclasses, and offers more fea‐ tures, promising to “bring back the joy of writing classes by relieving you from the drudgery of implementing object protocols (aka dunder methods).” The influence of attrs on @dataclass is acknowledged by Eric V. Smith in PEP 557. This probably includes Smith’s most important API decision: the use of a class decorator instead of a base class and/or a metaclass to do the job.\n\n196\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 2439,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 227,
      "content": "Glyph—founder of the Twisted project—wrote an excellent introduction to attrs in “The One Python Library Everyone Needs”. The attrs documentation includes a dis‐ cussion of alternatives.\n\nBook author, instructor, and mad computer scientist Dave Beazley wrote cluegen, yet another data class generator. If you’ve seen any of Dave’s talks, you know he is a mas‐ ter of metaprogramming Python from first principles. So I found it inspiring to learn from the cluegen README.md file the concrete use case that motivated him to write an alternative to Python’s @dataclass, and his philosophy of presenting an approach to solve the problem, in contrast to providing a tool: the tool may be quicker to use at first, but the approach is more flexible and can take you as far as you want to go.\n\nRegarding data class as a code smell, the best source I found was Martin Fowler’s book Refactoring, 2nd ed. This newest version is missing the quote from the epigraph of this chapter, “Data classes are like children…,” but otherwise it’s the best edition of Fowler’s most famous book, particularly for Pythonistas because the examples are in modern JavaScript, which is closer to Python than Java—the language of the first edition.\n\nThe website Refactoring Guru also has a description of the data class code smell.\n\nSoapbox The entry for “Guido” in “The Jargon File” is about Guido van Rossum. It says, among other things:\n\nMythically, Guido’s most important attribute besides Python itself is Guido’s time machine, a device he is reputed to possess because of the unnerving frequency with which user requests for new features have been met with the response “I just imple‐ mented that last night…”\n\nFor the longest time, one of the missing pieces in Python’s syntax has been a quick, standard way to declare instance attributes in a class. Many object-oriented languages have that. Here is part of a Point class definition in Smalltalk:\n\nObject subclass: #Point instanceVariableNames: 'x y' classVariableNames: '' package: 'Kernel-BasicObjects'\n\nThe second line lists the names of the instance attributes x and y. If there were class attributes, they would be in the third line.\n\nPython has always offered an easy way to declare class attributes, if they have an ini‐ tial value. But instance attributes are much more common, and Python coders have been forced to look into the __init__ method to find them, always afraid that there may be instance attributes created elsewhere in the class—or even created by external functions or methods of other classes.\n\nFurther Reading\n\n|\n\n197",
      "content_length": 2569,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 228,
      "content": "Now we have @dataclass, yay!\n\nBut they bring their own problems.\n\nFirst, when you use @dataclass, type hints are not optional. We’ve been promised for the last seven years, since PEP 484—Type Hints that they would always be optional. Now we have a major new language feature that requires them. If you don’t like the whole static typing trend, you may want to use attrs instead.\n\nSecond, the PEP 526 syntax for annotating instance and class attributes reverses the established convention of class statements: everything declared at the top-level of a class block was a class attribute (methods are class attributes, too). With PEP 526 and @dataclass, any attribute declared at the top level with a type hint becomes an instance attribute:\n\n@dataclass class Spam: repeat: int # instance attribute\n\nHere, repeat is also an instance attribute:\n\n@dataclass class Spam: repeat: int = 99 # instance attribute\n\nBut if there are no type hints, suddenly you are back in the good old times when dec‐ larations at the top level of the class belong to the class only:\n\n@dataclass class Spam: repeat = 99 # class attribute!\n\nFinally, if you want to annotate that class attribute with a type, you can’t use regular types because then it will become an instance attribute. You must resort to that pseu‐ dotype ClassVar annotation:\n\n@dataclass class Spam: repeat: ClassVar[int] = 99 # aargh!\n\nHere we are talking about the exception to the exception to the rule. This seems rather unPythonic to me.\n\nI did not take part in the discussions leading to PEP 526 or PEP 557—Data Classes, but here is an alternative syntax that I’d like to see:\n\n@dataclass class HackerClubMember: .name: str .guests: list = field(default_factory=list) .handle: str = ''\n\nall_handles = set()\n\n198\n\n|\n\nChapter 5: Data Class Builders",
      "content_length": 1792,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 229,
      "content": "Instance attributes must be declared with a . prefix.\n\nAny attribute name that doesn’t have a . prefix is a class attribute (as they always have been).\n\nThe language grammar would have to change to accept that. I find this quite readable, and it avoids the exception-to-the-exception issue.\n\nI wish I could borrow Guido’s time machine to go back to 2017 and sell this idea to the core team.\n\nFurther Reading\n\n|\n\n199",
      "content_length": 415,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 231,
      "content": "CHAPTER 6 Object References, Mutability, and Recycling\n\n“You are sad,” the Knight said in an anxious tone: “let me sing you a song to comfort you. […] The name of the song is called ‘HADDOCKS’ EYES’.”\n\n“Oh, that’s the name of the song, is it?” Alice said, trying to feel interested.\n\n“No, you don’t understand,” the Knight said, looking a little vexed. “That’s what the name is CALLED. The name really IS ‘THE AGED AGED MAN.’”\n\n—Adapted from Lewis Carroll, Through the Looking-Glass, and What Alice Found There\n\nAlice and the Knight set the tone of what we will see in this chapter. The theme is the distinction between objects and their names. A name is not the object; a name is a separate thing.\n\nWe start the chapter by presenting a metaphor for variables in Python: variables are labels, not boxes. If reference variables are old news to you, the analogy may still be handy if you need to explain aliasing issues to others.\n\nWe then discuss the concepts of object identity, value, and aliasing. A surprising trait of tuples is revealed: they are immutable but their values may change. This leads to a discussion of shallow and deep copies. References and function parameters are our next theme: the problem with mutable parameter defaults and the safe handling of mutable arguments passed by clients of our functions.\n\nThe last sections of the chapter cover garbage collection, the del command, and a selection of tricks that Python plays with immutable objects.\n\nThis is a rather dry chapter, but its topics lie at the heart of many subtle bugs in real Python programs.\n\n201",
      "content_length": 1580,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 232,
      "content": "What’s New in This Chapter The topics covered here are very fundamental and stable. There were no changes worth mentioning in this second edition.\n\nI added an example of using is to test for a sentinel object, and a warning about misuses of the is operator at the end of “Choosing Between == and is” on page 206.\n\nThis chapter used to be in Part IV, but I decided to bring it up earlier because it works better as an ending to Part II, “Data Structures,” than an opening to “Object- Oriented Idioms.”\n\nThe section on “Weak References” from the first edition of this book is now a post at fluentpython.com.\n\nLet’s start by unlearning that a variable is like a box where you store data.\n\nVariables Are Not Boxes In 1997, I took a summer course on Java at MIT. The professor, Lynn Stein,1 made the point that the usual “variables as boxes” metaphor actually hinders the under‐ standing of reference variables in object-oriented languages. Python variables are like reference variables in Java; a better metaphor is to think of variables as labels with names attached to objects. The next example and figure will help you understand why.\n\nExample 6-1 is a simple interaction that the “variables as boxes” idea cannot explain. Figure 6-1 illustrates why the box metaphor is wrong for Python, while sticky notes provide a helpful picture of how variables actually work.\n\nExample 6-1. Variables a and b hold references to the same list, not copies of the list\n\n>>> a = [1, 2, 3] >>> b = a >>> a.append(4) >>> b [1, 2, 3, 4]\n\n1 Lynn Andrea Stein is an award-winning computer science educator who currently teaches at Olin College of\n\nEngineering.\n\n202\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "content_length": 1703,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 233,
      "content": "Create a list [1, 2, 3] and bind the variable a to it.\n\nBind the variable b to the same value that a is referencing.\n\nModify the list referenced by a, by appending another item.\n\nYou can see the effect via the b variable. If we think of b as a box that stored a copy of the [1, 2, 3] from the a box, this behavior makes no sense.\n\nFigure 6-1. If you imagine variables are like boxes, you can’t make sense of assignment in Python; instead, think of variables as sticky notes, and Example 6-1 becomes easy to explain.\n\nTherefore, the b = a statement does not copy the contents of box a into box b. It attaches the label b to the object that already has the label a.\n\nProf. Stein also spoke about assignment in a very deliberate way. For example, when talking about a seesaw object in a simulation, she would say: “Variable s is assigned to the seesaw,” but never “The seesaw is assigned to variable s.” With reference vari‐ ables, it makes much more sense to say that the variable is assigned to an object, and not the other way around. After all, the object is created before the assignment. Example 6-2 proves that the righthand side of an assignment happens first.\n\nSince the verb “to assign” is used in contradictory ways, a useful alternative is “to bind”: Python’s assignment statement x = … binds the x name to the object created or referenced on the righthand side. And the object must exist before a name can be bound to it, as Example 6-2 proves.\n\nExample 6-2. Variables are bound to objects only after the objects are created\n\n>>> class Gizmo: ... def __init__(self): ... print(f'Gizmo id: {id(self)}') ... >>> x = Gizmo()\n\nVariables Are Not Boxes\n\n|\n\n203",
      "content_length": 1664,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 234,
      "content": "Gizmo id: 4301489152 >>> y = Gizmo() * 10 Gizmo id: 4301489432 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: unsupported operand type(s) for *: 'Gizmo' and 'int' >>> >>> dir() ['Gizmo', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'x']\n\nThe output Gizmo id: … is a side effect of creating a Gizmo instance.\n\nMultiplying a Gizmo instance will raise an exception.\n\nHere is proof that a second Gizmo was actually instantiated before the multiplica‐ tion was attempted.\n\nBut variable y was never created, because the exception happened while the righthand side of the assignment was being evaluated.\n\nTo understand an assignment in Python, read the righthand side first: that’s where the object is created or retrieved. After that, the variable on the left is bound to the object, like a label stuck to it. Just forget about the boxes.\n\nBecause variables are mere labels, nothing prevents an object from having several labels assigned to it. When that happens, you have aliasing, our next topic.\n\nIdentity, Equality, and Aliases Lewis Carroll is the pen name of Prof. Charles Lutwidge Dodgson. Mr. Carroll is not only equal to Prof. Dodgson, they are one and the same. Example 6-3 expresses this idea in Python.\n\nExample 6-3. charles and lewis refer to the same object\n\n>>> charles = {'name': 'Charles L. Dodgson', 'born': 1832} >>> lewis = charles >>> lewis is charles True >>> id(charles), id(lewis) (4300473992, 4300473992) >>> lewis['balance'] = 950\n\n204\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "content_length": 1585,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 235,
      "content": ">>> charles {'name': 'Charles L. Dodgson', 'born': 1832, 'balance': 950}\n\nlewis is an alias for charles.\n\nThe is operator and the id function confirm it.\n\nAdding an item to lewis is the same as adding an item to charles.\n\nHowever, suppose an impostor—let’s call him Dr. Alexander Pedachenko—claims he is Charles L. Dodgson, born in 1832. His credentials may be the same, but Dr. Peda‐ chenko is not Prof. Dodgson. Figure 6-2 illustrates this scenario.\n\nFigure 6-2. charles and lewis are bound to the same object; alex is bound to a sepa‐ rate object of equal value.\n\nExample 6-4 implements and tests the alex object depicted in Figure 6-2.\n\nExample 6-4. alex and charles compare equal, but alex is not charles\n\n>>> alex = {'name': 'Charles L. Dodgson', 'born': 1832, 'balance': 950} >>> alex == charles True >>> alex is not charles True\n\nalex refers to an object that is a replica of the object assigned to charles.\n\nThe objects compare equal because of the __eq__ implementation in the dict class.\n\nBut they are distinct objects. This is the Pythonic way of writing the negative identity comparison: a is not b.\n\nExample 6-3 is an example of aliasing. In that code, lewis and charles are aliases: two variables bound to the same object. On the other hand, alex is not an alias for\n\nIdentity, Equality, and Aliases\n\n|\n\n205",
      "content_length": 1322,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 236,
      "content": "charles: these variables are bound to distinct objects. The objects bound to alex and charles have the same value—that’s what == compares—but they have different identities.\n\nIn The Python Language Reference, “3.1. Objects, values and types” states:\n\nAn object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The is operator compares the identity of two objects; the id() function returns an integer representing its identity.\n\nThe real meaning of an object’s ID is implementation dependent. In CPython, id() returns the memory address of the object, but it may be something else in another Python interpreter. The key point is that the ID is guaranteed to be a unique integer label, and it will never change during the life of the object.\n\nIn practice, we rarely use the id() function while programming. Identity checks are most often done with the is operator, which compares the object IDs, so our code doesn’t need to call id() explicitly. Next, we’ll talk about is versus ==.\n\nFor tech reviewer Leonardo Rochael, the most frequent use for id() is while debugging, when the repr() of two objects look alike, but you need to understand whether two references are aliases or point to separate objects. If the references are in different contexts —such as different stack frames—using the is operator may not be viable.\n\nChoosing Between == and is The == operator compares the values of objects (the data they hold), while is com‐ pares their identities.\n\nWhile programming, we often care more about values than object identities, so == appears more frequently than is in Python code.\n\nHowever, if you are comparing a variable to a singleton, then it makes sense to use is. By far, the most common case is checking whether a variable is bound to None. This is the recommended way to do it:\n\nx is None\n\nAnd the proper way to write its negation is:\n\nx is not None\n\nNone is the most common singleton we test with is. Sentinel objects are another example of singletons we test with is. Here is one way to create and test a sentinel object:\n\n206\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "content_length": 2159,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 237,
      "content": "END_OF_DATA = object() # ... many lines def traverse(...): # ... more lines if node is END_OF_DATA: return # etc.\n\nThe is operator is faster than ==, because it cannot be overloaded, so Python does not have to find and invoke special methods to evaluate it, and computing is as sim‐ ple as comparing two integer IDs. In contrast, a == b is syntactic sugar for a.__eq__(b). The __eq__ method inherited from object compares object IDs, so it produces the same result as is. But most built-in types override __eq__ with more meaningful implementations that actually take into account the values of the object attributes. Equality may involve a lot of processing—for example, when comparing large collections or deeply nested structures.\n\nUsually we are more interested in object equality than identity. Checking for None is the only common use case for the is operator. Most other uses I see while reviewing code are wrong. If you are not sure, use ==. It’s usually what you want, and also works with None—albeit not as fast.\n\nTo wrap up this discussion of identity versus equality, we’ll see that the famously immutable tuple is not as unchanging as you may expect.\n\nThe Relative Immutability of Tuples Tuples, like most Python collections—lists, dicts, sets, etc.—are containers: they hold references to objects.2 If the referenced items are mutable, they may change even if the tuple itself does not. In other words, the immutability of tuples really refers to the physical contents of the tuple data structure (i.e., the references it holds), and does not extend to the referenced objects.\n\nExample 6-5 illustrates the situation in which the value of a tuple changes as a result of changes to a mutable object referenced in it. What can never change in a tuple is the identity of the items it contains.\n\n2 In contrast, flat sequences like str, bytes, and array.array don’t contain references but directly hold their\n\ncontents—characters, bytes, and numbers—in contiguous memory.\n\nIdentity, Equality, and Aliases\n\n|\n\n207",
      "content_length": 2020,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 238,
      "content": "Example 6-5. t1 and t2 initially compare equal, but changing a mutable item inside tuple t1 makes it different\n\n>>> t1 = (1, 2, [30, 40]) >>> t2 = (1, 2, [30, 40]) >>> t1 == t2 True >>> id(t1[-1]) 4302515784 >>> t1[-1].append(99) >>> t1 (1, 2, [30, 40, 99]) >>> id(t1[-1]) 4302515784 >>> t1 == t2 False\n\nt1 is immutable, but t1[-1] is mutable.\n\nBuild a tuple t2 whose items are equal to those of t1.\n\nAlthough distinct objects, t1 and t2 compare equal, as expected.\n\nInspect the identity of the list at t1[-1].\n\nModify the t1[-1] list in place.\n\nThe identity of t1[-1] has not changed, only its value.\n\nt1 and t2 are now different.\n\nThis relative immutability of tuples is behind the riddle “A += Assignment Puzzler” on page 54. It’s also the reason why some tuples are unhashable, as we’ve seen in “What Is Hashable” on page 84.\n\nThe distinction between equality and identity has further implications when you need to copy an object. A copy is an equal object with a different ID. But if an object contains other objects, should the copy also duplicate the inner objects, or is it OK to share them? There’s no single answer. Read on for a discussion.\n\nCopies Are Shallow by Default The easiest way to copy a list (or most built-in mutable collections) is to use the built- in constructor for the type itself. For example:\n\n>>> l1 = [3, [55, 44], (7, 8, 9)] >>> l2 = list(l1)\n\n208\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "content_length": 1440,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 239,
      "content": ">>> l2 [3, [55, 44], (7, 8, 9)] >>> l2 == l1 True >>> l2 is l1 False\n\nlist(l1) creates a copy of l1.\n\nThe copies are equal…\n\n…but refer to two different objects.\n\nFor lists and other mutable sequences, the shortcut l2 = l1[:] also makes a copy.\n\nHowever, using the constructor or [:] produces a shallow copy (i.e., the outermost container is duplicated, but the copy is filled with references to the same items held by the original container). This saves memory and causes no problems if all the items are immutable. But if there are mutable items, this may lead to unpleasant surprises.\n\nIn Example 6-6, we create a shallow copy of a list containing another list and a tuple, and then make changes to see how they affect the referenced objects.\n\nIf you have a connected computer on hand, I highly recommend watching the interactive animation for Example 6-6 at the Online Python Tutor. As I write this, direct linking to a prepared example at pythontutor.com is not working reliably, but the tool is awesome, so taking the time to copy and paste the code is worthwhile.\n\nExample 6-6. Making a shallow copy of a list containing another list; copy and paste this code to see it animated at the Online Python Tutor\n\nl1 = [3, [66, 55, 44], (7, 8, 9)] l2 = list(l1) l1.append(100) l1[1].remove(55) print('l1:', l1) print('l2:', l2) l2[1] += [33, 22] l2[2] += (10, 11) print('l1:', l1) print('l2:', l2)\n\nl2 is a shallow copy of l1. This state is depicted in Figure 6-3.\n\nAppending 100 to l1 has no effect on l2.\n\nCopies Are Shallow by Default\n\n|\n\n209",
      "content_length": 1545,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 240,
      "content": "Here we remove 55 from the inner list l1[1]. This affects l2 because l2[1] is bound to the same list as l1[1].\n\nFor a mutable object like the list referred by l2[1], the operator += changes the list in place. This change is visible at l1[1], which is an alias for l2[1].\n\n+= on a tuple creates a new tuple and rebinds the variable l2[2] here. This is the same as doing l2[2] = l2[2] + (10, 11). Now the tuples in the last position of l1 and l2 are no longer the same object. See Figure 6-4.\n\nFigure 6-3. Program state immediately after the assignment l2 = list(l1) in Example 6-6. l1 and l2 refer to distinct lists, but the lists share references to the same inner list object [66, 55, 44] and tuple (7, 8, 9). (Diagram generated by the Online Python Tutor.)\n\nThe output of Example 6-6 is Example 6-7, and the final state of the objects is depic‐ ted in Figure 6-4.\n\nExample 6-7. Output of Example 6-6\n\nl1: [3, [66, 44], (7, 8, 9), 100] l2: [3, [66, 44], (7, 8, 9)] l1: [3, [66, 44, 33, 22], (7, 8, 9), 100] l2: [3, [66, 44, 33, 22], (7, 8, 9, 10, 11)]\n\n210\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "content_length": 1117,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 241,
      "content": "Figure 6-4. Final state of l1 and l2: they still share references to the same list object, now containing [66, 44, 33, 22], but the operation l2[2] += (10, 11) created a new tuple with content (7, 8, 9, 10, 11), unrelated to the tuple (7, 8, 9) refer‐ enced by l1[2]. (Diagram generated by the Online Python Tutor.)\n\nIt should be clear now that shallow copies are easy to make, but they may or may not be what you want. How to make deep copies is our next topic.\n\nDeep and Shallow Copies of Arbitrary Objects Working with shallow copies is not always a problem, but sometimes you need to make deep copies (i.e., duplicates that do not share references of embedded objects). The copy module provides the deepcopy and copy functions that return deep and shallow copies of arbitrary objects.\n\nTo illustrate the use of copy() and deepcopy(), Example 6-8 defines a simple class, Bus, representing a school bus that is loaded with passengers and then picks up or drops off passengers on its route.\n\nExample 6-8. Bus picks up and drops off passengers\n\nclass Bus:\n\ndef __init__(self, passengers=None): if passengers is None: self.passengers = [] else: self.passengers = list(passengers)\n\ndef pick(self, name): self.passengers.append(name)\n\nCopies Are Shallow by Default\n\n|\n\n211",
      "content_length": 1269,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 242,
      "content": "def drop(self, name): self.passengers.remove(name)\n\nNow, in the interactive Example 6-9, we will create a bus object (bus1) and two clones—a shallow copy (bus2) and a deep copy (bus3)—to observe what happens as bus1 drops off a student.\n\nExample 6-9. Effects of using copy versus deepcopy\n\n>>> import copy >>> bus1 = Bus(['Alice', 'Bill', 'Claire', 'David']) >>> bus2 = copy.copy(bus1) >>> bus3 = copy.deepcopy(bus1) >>> id(bus1), id(bus2), id(bus3) (4301498296, 4301499416, 4301499752) >>> bus1.drop('Bill') >>> bus2.passengers ['Alice', 'Claire', 'David'] >>> id(bus1.passengers), id(bus2.passengers), id(bus3.passengers) (4302658568, 4302658568, 4302657800) >>> bus3.passengers ['Alice', 'Bill', 'Claire', 'David']\n\nUsing copy and deepcopy, we create three distinct Bus instances.\n\nAfter bus1 drops 'Bill', he is also missing from bus2.\n\nInspection of the passengers attributes shows that bus1 and bus2 share the same list object, because bus2 is a shallow copy of bus1.\n\nbus3 is a deep copy of bus1, so its passengers attribute refers to another list.\n\nNote that making deep copies is not a simple matter in the general case. Objects may have cyclic references that would cause a naïve algorithm to enter an infinite loop. The deepcopy function remembers the objects already copied to handle cyclic refer‐ ences gracefully. This is demonstrated in Example 6-10.\n\nExample 6-10. Cyclic references: b refers to a, and then is appended to a; deepcopy still manages to copy a\n\n>>> a = [10, 20] >>> b = [a, 30] >>> a.append(b) >>> a [10, 20, [[...], 30]] >>> from copy import deepcopy\n\n212\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "content_length": 1647,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 243,
      "content": ">>> c = deepcopy(a) >>> c [10, 20, [[...], 30]]\n\nAlso, a deep copy may be too deep in some cases. For example, objects may refer to external resources or singletons that should not be copied. You can control the behavior of both copy and deepcopy by implementing the __copy__() and __deepcopy__() special methods, as described in the copy module documentation.\n\nThe sharing of objects through aliases also explains how parameter passing works in Python, and the problem of using mutable types as parameter defaults. These issues will be covered next.\n\nFunction Parameters as References The only mode of parameter passing in Python is call by sharing. That is the same mode used in most object-oriented languages, including JavaScript, Ruby, and Java (this applies to Java reference types; primitive types use call by value). Call by sharing means that each formal parameter of the function gets a copy of each reference in the arguments. In other words, the parameters inside the function become aliases of the actual arguments.\n\nThe result of this scheme is that a function may change any mutable object passed as a parameter, but it cannot change the identity of those objects (i.e., it cannot alto‐ gether replace an object with another). Example 6-11 shows a simple function using += on one of its parameters. As we pass numbers, lists, and tuples to the function, the actual arguments passed are affected in different ways.\n\nExample 6-11. A function may change any mutable object it receives\n\n>>> def f(a, b): ... a += b ... return a ... >>> x = 1 >>> y = 2 >>> f(x, y) 3 >>> x, y (1, 2) >>> a = [1, 2] >>> b = [3, 4] >>> f(a, b) [1, 2, 3, 4] >>> a, b ([1, 2, 3, 4], [3, 4]) >>> t = (10, 20)\n\nFunction Parameters as References\n\n|\n\n213",
      "content_length": 1739,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 244,
      "content": ">>> u = (30, 40) >>> f(t, u) (10, 20, 30, 40) >>> t, u ((10, 20), (30, 40))\n\nThe number x is unchanged.\n\nThe list a is changed.\n\nThe tuple t is unchanged.\n\nAnother issue related to function parameters is the use of mutable values for defaults, as discussed next.\n\nMutable Types as Parameter Defaults: Bad Idea Optional parameters with default values are a great feature of Python function defini‐ tions, allowing our APIs to evolve while remaining backward compatible. However, you should avoid mutable objects as default values for parameters.\n\nTo illustrate this point, in Example 6-12, we take the Bus class from Example 6-8 and change its __init__ method to create HauntedBus. Here we tried to be clever, and instead of having a default value of passengers=None, we have passengers=[], thus avoiding the if in the previous __init__. This “cleverness” gets us into trouble.\n\nExample 6-12. A simple class to illustrate the danger of a mutable default\n\nclass HauntedBus: \"\"\"A bus model haunted by ghost passengers\"\"\"\n\ndef __init__(self, passengers=[]): self.passengers = passengers\n\ndef pick(self, name): self.passengers.append(name)\n\ndef drop(self, name): self.passengers.remove(name)\n\nWhen the passengers argument is not passed, this parameter is bound to the default list object, which is initially empty.\n\nThis assignment makes self.passengers an alias for passengers, which is itself an alias for the default list, when no passengers argument is given.\n\n214\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "content_length": 1523,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 245,
      "content": "When the methods .remove() and .append() are used with self.passengers, we are actually mutating the default list, which is an attribute of the function object.\n\nExample 6-13 shows the eerie behavior of the HauntedBus.\n\nExample 6-13. Buses haunted by ghost passengers\n\n>>> bus1 = HauntedBus(['Alice', 'Bill']) >>> bus1.passengers ['Alice', 'Bill'] >>> bus1.pick('Charlie') >>> bus1.drop('Alice') >>> bus1.passengers ['Bill', 'Charlie'] >>> bus2 = HauntedBus() >>> bus2.pick('Carrie') >>> bus2.passengers ['Carrie'] >>> bus3 = HauntedBus() >>> bus3.passengers ['Carrie'] >>> bus3.pick('Dave') >>> bus2.passengers ['Carrie', 'Dave'] >>> bus2.passengers is bus3.passengers True >>> bus1.passengers ['Bill', 'Charlie']\n\nbus1 starts with a two-passenger list.\n\nSo far, so good: no surprises with bus1.\n\nbus2 starts empty, so the default empty list is assigned to self.passengers.\n\nbus3 also starts empty, again the default list is assigned.\n\nThe default is no longer empty!\n\nNow Dave, picked by bus3, appears in bus2.\n\nThe problem: bus2.passengers and bus3.passengers refer to the same list.\n\nBut bus1.passengers is a distinct list.\n\nFunction Parameters as References\n\n|\n\n215",
      "content_length": 1170,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 246,
      "content": "The problem is that HauntedBus instances that don’t get an initial passenger list end up sharing the same passenger list among themselves.\n\nSuch bugs may be subtle. As Example 6-13 demonstrates, when a HauntedBus is instantiated with passengers, it works as expected. Strange things happen only when a HauntedBus starts empty, because then self.passengers becomes an alias for the default value of the passengers parameter. The problem is that each default value is evaluated when the function is defined—i.e., usually when the module is loaded—and the default values become attributes of the function object. So if a default value is a mutable object, and you change it, the change will affect every future call of the function.\n\nAfter running the lines in Example 6-13, you can inspect the HauntedBus.__init__ object and see the ghost students haunting its __defaults__ attribute:\n\n>>> dir(HauntedBus.__init__) # doctest: +ELLIPSIS ['__annotations__', '__call__', ..., '__defaults__', ...] >>> HauntedBus.__init__.__defaults__ (['Carrie', 'Dave'],)\n\nFinally, we can verify that bus2.passengers is an alias bound to the first element of the HauntedBus.__init__.__defaults__ attribute:\n\n>>> HauntedBus.__init__.__defaults__[0] is bus2.passengers True\n\nThe issue with mutable defaults explains why None is commonly used as the default value for parameters that may receive mutable values. In Example 6-8, __init__ checks whether the passengers argument is None. If it is, self.passengers is bound to a new empty list. If passengers is not None, the correct implementation binds a copy of that argument to self.passengers. The next section explains why copying the argument is a good practice.\n\nDefensive Programming with Mutable Parameters When you are coding a function that receives a mutable parameter, you should care‐ fully consider whether the caller expects the argument passed to be changed.\n\nFor example, if your function receives a dict and needs to modify it while processing it, should this side effect be visible outside of the function or not? Actually it depends on the context. It’s really a matter of aligning the expectation of the coder of the func‐ tion and that of the caller.\n\nThe last bus example in this chapter shows how a TwilightBus breaks expectations by sharing its passenger list with its clients. Before studying the implementation, see in Example 6-14 how the TwilightBus class works from the perspective of a client of the class.\n\n216\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "content_length": 2526,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 247,
      "content": "Example 6-14. Passengers disappear when dropped by a TwilightBus\n\n>>> basketball_team = ['Sue', 'Tina', 'Maya', 'Diana', 'Pat'] >>> bus = TwilightBus(basketball_team) >>> bus.drop('Tina') >>> bus.drop('Pat') >>> basketball_team ['Sue', 'Maya', 'Diana']\n\nbasketball_team holds five student names.\n\nA TwilightBus is loaded with the team.\n\nThe bus drops one student, then another.\n\nThe dropped passengers vanished from the basketball team!\n\nTwilightBus violates the “Principle of least astonishment,” a best practice of interface design.3 It surely is astonishing that when the bus drops a student, their name is removed from the basketball team roster.\n\nExample 6-15 is the implementation TwilightBus and an explanation of the problem.\n\nExample 6-15. A simple class to show the perils of mutating received arguments\n\nclass TwilightBus: \"\"\"A bus model that makes passengers vanish\"\"\"\n\ndef __init__(self, passengers=None): if passengers is None: self.passengers = [] else: self.passengers = passengers\n\ndef pick(self, name): self.passengers.append(name)\n\ndef drop(self, name): self.passengers.remove(name)\n\n3 See Principle of least astonishment in the English Wikipedia.\n\nFunction Parameters as References\n\n|\n\n217",
      "content_length": 1209,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 248,
      "content": "Here we are careful to create a new empty list when passengers is None.\n\nHowever, this assignment makes self.passengers an alias for passengers, which is itself an alias for the actual argument passed to __init__ (i.e., basket ball_team in Example 6-14).\n\nWhen the methods .remove() and .append() are used with self.passengers, we are actually mutating the original list received as an argument to the con‐ structor.\n\nThe problem here is that the bus is aliasing the list that is passed to the constructor. Instead, it should keep its own passenger list. The fix is simple: in __init__, when the passengers parameter is provided, self.passengers should be initialized with a copy of it, as we did correctly in Example 6-8:\n\ndef __init__(self, passengers=None): if passengers is None: self.passengers = [] else: self.passengers = list(passengers)\n\nMake a copy of the passengers list, or convert it to a list if it’s not one.\n\nNow our internal handling of the passenger list will not affect the argument used to initialize the bus. As a bonus, this solution is more flexible: now the argument passed to the passengers parameter may be a tuple or any other iterable, like a set or even database results, because the list constructor accepts any iterable. As we create our list to manage, we ensure that it supports the necessary .remove() own and .append() operations we use in the .pick() and .drop() methods.\n\nUnless a method is explicitly intended to mutate an object received as an argument, you should think twice before aliasing the argu‐ ment object by simply assigning it to an instance variable in your class. If in doubt, make a copy. Your clients will be happier. Of course, making a copy is not free: there is a cost in CPU and mem‐ ory. However, an API that causes subtle bugs is usually a bigger problem than one that is a little slower or uses more resources.\n\nNow let’s talk about one of the most misunderstood of Python’s statements: del.\n\n218\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "content_length": 2017,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 249,
      "content": "del and Garbage Collection\n\nObjects are never explicitly destroyed; however, when they become unreachable they may be garbage-collected.\n\n—“Data Model” chapter of The Python Language Reference\n\nThe first strange fact about del is that it’s not a function, it’s a statement. We write del x and not del(x)—although the latter also works, but only because the expres‐ sions x and (x) usually mean the same thing in Python.\n\nThe second surprising fact is that del deletes references, not objects. Python’s garbage collector may discard an object from memory as an indirect result of del, if the deleted variable was the last reference to the object. Rebinding a variable may also cause the number of references to an object to reach zero, causing its destruction.\n\n>>> a = [1, 2] >>> b = a >>> del a >>> b [1, 2] >>> b = [3]\n\nCreate object [1, 2] and bind a to it.\n\nBind b to the same [1, 2] object.\n\nDelete reference a.\n\n[1, 2] was not affected, because b still points to it.\n\nRebinding b to a different object removes the last remaining reference to [1, 2]. Now the garbage collector can discard that object.\n\nThere is a __del__ special method, but it does not cause the dis‐ posal of the instance, and should not be called by your code. __del__ is invoked by the Python interpreter when the instance is about to be destroyed to give it a chance to release external resources. You will seldom need to implement __del__ in your own code, yet some Python programmers spend time coding it for no good reason. The proper use of __del__ is rather tricky. See the __del__ special method documentation in the “Data Model” chap‐ ter of The Python Language Reference.\n\nIn CPython, the primary algorithm for garbage collection is reference counting. Essentially, each object keeps count of how many references point to it. As soon as\n\ndel and Garbage Collection\n\n|\n\n219",
      "content_length": 1857,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 250,
      "content": "that refcount reaches zero, the object is immediately destroyed: CPython calls the __del__ method on the object (if defined) and then frees the memory allocated to the object. In CPython 2.0, a generational garbage collection algorithm was added to detect groups of objects involved in reference cycles—which may be unreachable even with outstanding references to them, when all the mutual references are con‐ tained within the group. Other implementations of Python have more sophisticated garbage collectors that do not rely on reference counting, which means the __del__ method may not be called immediately when there are no more references to the object. See “PyPy, Garbage Collection, and a Deadlock” by A. Jesse Jiryu Davis for discussion of improper and proper use of __del__.\n\nTo demonstrate the end of an object’s life, Example 6-16 uses weakref.finalize to register a callback function to be called when an object is destroyed.\n\nExample 6-16. Watching the end of an object when no more references point to it\n\n>>> import weakref >>> s1 = {1, 2, 3} >>> s2 = s1 >>> def bye(): ... print('...like tears in the rain.') ... >>> ender = weakref.finalize(s1, bye) >>> ender.alive True >>> del s1 >>> ender.alive True >>> s2 = 'spam' ...like tears in the rain. >>> ender.alive False\n\ns1 and s2 are aliases referring to the same set, {1, 2, 3}.\n\nThis function must not be a bound method of the object about to be destroyed or otherwise hold a reference to it.\n\nRegister the bye callback on the object referred by s1.\n\nThe .alive attribute is True before the finalize object is called.\n\nAs discussed, del did not delete the object, just the s1 reference to it.\n\nRebinding the last reference, s2, makes {1, 2, 3} unreachable. It is destroyed, the bye callback is invoked, and ender.alive becomes False.\n\n220\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "content_length": 1867,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 251,
      "content": "The point of Example 6-16 is to make explicit that del does not delete objects, but objects may be deleted as a consequence of being unreachable after del is used.\n\nYou may be wondering why the {1, 2, 3} object was destroyed in Example 6-16. After all, the s1 reference was passed to the finalize function, which must have held on to it in order to monitor the object and invoke the callback. This works because finalize holds a weak reference to {1, 2, 3}. Weak references to an object do not increase its reference count. Therefore, a weak reference does not prevent the target object from being garbage collected. Weak references are useful in caching applica‐ tions because you don’t want the cached objects to be kept alive just because they are referenced by the cache.\n\nWeak references is a very specialized topic. That’s why I chose to skip it in this second edition. Instead, I published “Weak Refer‐ ences” on fluentpython.com.\n\nTricks Python Plays with Immutables\n\nThis optional section discusses some Python details that are not really important for users of Python, and that may not apply to other Python implementations or even future versions of CPython. Nevertheless, I’ve seen people stumble upon these corner cases and then start using the is operator incorrectly, so I felt they were worth mentioning.\n\nI was surprised to learn that, for a tuple t, t[:] does not make a copy, but returns a reference to the same object. You also get a reference to the same tuple if you write tuple(t).4 Example 6-17 proves it.\n\nExample 6-17. A tuple built from another is actually the same exact tuple\n\n>>> t1 = (1, 2, 3) >>> t2 = tuple(t1) >>> t2 is t1 True >>> t3 = t1[:] >>> t3 is t1 True\n\n4 This is clearly documented. Type help(tuple) in the Python console to read: “If the argument is a tuple, the\n\nreturn value is the same object.” I thought I knew everything about tuples before writing this book.\n\nTricks Python Plays with Immutables\n\n|\n\n221",
      "content_length": 1953,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 252,
      "content": "t1 and t2 are bound to the same object.\n\nAnd so is t3.\n\nThe same behavior can be observed with instances of str, bytes, and frozenset. Note that a frozenset is not a sequence, so fs[:] does not work if fs is a frozenset. But fs.copy() has the same effect: it cheats and returns a reference to the same object, and not a copy at all, as Example 6-18 shows.5\n\nExample 6-18. String literals may create shared objects\n\n>>> t1 = (1, 2, 3) >>> t3 = (1, 2, 3) >>> t3 is t1 False >>> s1 = 'ABC' >>> s2 = 'ABC' >>> s2 is s1 True\n\nCreating a new tuple from scratch.\n\nt1 and t3 are equal, but not the same object.\n\nCreating a second str from scratch.\n\nSurprise: a and b refer to the same str!\n\nThe sharing of string literals is an optimization technique called interning. CPython uses a similar technique with small integers to avoid unnecessary duplication of num‐ bers that appear frequently in programs like 0, 1, –1, etc. Note that CPython does not intern all strings or integers, and the criteria it uses to do so is an undocumented implementation detail.\n\nNever depend on str or int interning! Always use == instead of is to compare strings or integers for equality. Interning is an optimi‐ zation for internal use of the Python interpreter.\n\n5 The harmless lie of having the copy method not copying anything is justified by interface compatibility: it makes frozenset more compatible with set. Anyway, it makes no difference to the end user whether two identical immutable objects are the same or are copies.\n\n222\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "content_length": 1569,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 253,
      "content": "The tricks discussed in this section, including the behavior of frozenset.copy(), are harmless “lies” that save memory and make the interpreter faster. Do not worry about them, they should not give you any trouble because they only apply to immuta‐ ble types. Probably the best use of these bits of trivia is to win bets with fellow Pythonistas.6\n\nChapter Summary Every Python object has an identity, a type, and a value. Only the value of an object may change over time.7\n\nIf two variables refer to immutable objects that have equal values (a == b is True), in practice it rarely matters if they refer to copies or are aliases referring to the same object, because the value of an immutable object does not change, with one excep‐ tion. The exception being immutable collections such as tuples: if an immutable col‐ lection holds references to mutable items, then its value may actually change when the value of a mutable item changes. In practice, this scenario is not so common. What never changes in an immutable collection are the identities of the objects within. The frozenset class does not suffer from this problem because it can only hold hashable elements, and the value of hashable objects cannot ever change, by definition.\n\nThe fact that variables hold references has many practical consequences in Python programming:\n\nSimple assignment does not create copies. • Augmented assignment with += or *= creates new objects if the lefthand variable is bound to an immutable object, but may modify a mutable object in place.\n\nAssigning a new value to an existing variable does not change the object previ‐ ously bound to it. This is called a rebinding: the variable is now bound to a differ‐ ent object. If that variable was the last reference to the previous object, that object will be garbage collected.\n\n6 A terrible use for this information would be to ask about it when interviewing candidates or authoring ques‐ tions for “certification” exams. There are countless more important and useful facts to check for Python knowledge.\n\n7 Actually the type of an object may be changed by merely assigning a different class to its __class__ attribute,\n\nbut that is pure evil and I regret writing this footnote.\n\nChapter Summary\n\n|\n\n223",
      "content_length": 2241,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 254,
      "content": "Function parameters are passed as aliases, which means the function may change any mutable object received as an argument. There is no way to prevent this, except making local copies or using immutable objects (e.g., passing a tuple instead of a list).\n\nUsing mutable objects as default values for function parameters is dangerous because if the parameters are changed in place, then the default is changed, affecting every future call that relies on the default.\n\nIn CPython, objects are discarded as soon as the number of references to them rea‐ ches zero. They may also be discarded if they form groups with cyclic references but not outside references.\n\nIn some situations, it may be useful to hold a reference to an object that will not—by itself—keep an object alive. One example is a class that wants to keep track of all its current instances. This can be done with weak references, a low-level mechanism underlying the more useful collections WeakValueDictionary, WeakKeyDictionary, WeakSet, and the finalize function from the weakref module. For more on this, please see “Weak References” at fluentpython.com.\n\nFurther Reading The “Data Model” chapter of The Python Language Reference starts with a clear explanation of object identities and values.\n\nWesley Chun, author of the Core Python series of books, presented Understanding Python’s Memory Model, Mutability, and Methods at EuroPython 2011, covering not only the theme of this chapter but also the use of special methods.\n\nDoug Hellmann wrote the posts “copy – Duplicate Objects” and “weakref—Garbage- Collectable References to Objects” covering some of the topics we just discussed.\n\nMore information on the CPython generational garbage collector can be found in the gc module documentation, which starts with the sentence “This module provides an interface to the optional garbage collector.” The “optional” qualifier here may be sur‐ prising, but the “Data Model” chapter also states:\n\nAn implementation is allowed to postpone garbage collection or omit it altogether—it is a matter of implementation quality how garbage collection is implemented, as long as no objects are collected that are still reachable.\n\n224\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "content_length": 2244,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 255,
      "content": "Pablo Galindo wrote more in-depth treatment of Python’s GC in “Design of CPy‐ thon’s Garbage Collector” in the Python Developer’s Guide, aimed at new and experi‐ enced contributors to the CPython implementation.\n\nThe CPython 3.4 garbage collector improved handling of objects with a __del__ method, as described in PEP 442—Safe object finalization.\n\nWikipedia has an article about string interning, mentioning the use of this technique in several languages, including Python.\n\nWikipedia also as an article on “Haddocks’ Eyes”, the Lewis Carroll song I quoted at the top of this chapter. The Wikipedia editors wrote that the lyrics are used in works on logic and philosophy “to elaborate on the symbolic status of the concept of name: a name as identification marker may be assigned to anything, including another name, thus introducing different levels of symbolization.”\n\nSoapbox\n\nEqual Treatment to All Objects\n\nI learned Java before I discovered Python. The == operator in Java never felt right to me. It is much more common for programmers to care about equality than identity, but for objects (not primitive types), the Java == compares references, and not object values. Even for something as basic as comparing strings, Java forces you to use the .equals method. Even then, there is another catch: if you write a.equals(b) and a is null, you get a null pointer exception. The Java designers felt the need to over‐ load + for strings, so why not go ahead and overload == as well?\n\nPython gets this right. The == operator compares object values; is compares refer‐ ences. And because Python has operator overloading, == works sensibly with all objects in the standard library, including None, which is a proper object, unlike Java’s null.\n\nAnd of course, you can define __eq__ in your own classes to decide what == means for your instances. If you don’t override __eq__, the method inherited from object compares object IDs, so the fallback is that every instance of a user-defined class is considered different.\n\nThese are some of the things that made me switch from Java to Python as soon as I finished reading The Python Tutorial one afternoon in September 1998.\n\nMutability\n\nThis chapter would not be necessary if all Python objects were immutable. When you are dealing with unchanging objects, it makes no difference whether variables hold the actual objects or references to shared objects. If a == b is true, and neither object\n\nFurther Reading\n\n|\n\n225",
      "content_length": 2464,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 256,
      "content": "can change, they might as well be the same. That’s why string interning is safe. Object identity becomes important only when objects are mutable.\n\nIn “pure” functional programming, all data is immutable: appending to a collection actually creates a new collection. Elixir is one easy to learn, practical functional lan‐ guage in which all built-in types are immutable, including lists.\n\nPython, however, is not a functional language, much less a pure one. Instances of user-defined classes are mutable by default in Python—as in most object-oriented languages. When creating your own objects, you have to be extra careful to make them immutable, if that is a requirement. Every attribute of the object must also be immutable, otherwise you end up with something like the tuple: immutable as far as object IDs go, but the value of a tuple may change if it holds a mutable object.\n\nMutable objects are also the main reason why programming with threads is so hard to get right: threads mutating objects without proper synchronization produce cor‐ rupted data. Excessive synchronization, on the other hand, causes deadlocks. The Erlang language and platform—which includes Elixir—was designed to maximize uptime in highly concurrent, distributed applications such as telecommunications switches. Naturally, they chose immutable data by default.\n\nObject Destruction and Garbage Collection\n\nThere is no mechanism in Python to directly destroy an object, and this omission is actually a great feature: if you could destroy an object at any time, what would hap‐ pen to existing references pointing to it?\n\nGarbage collection in CPython is done primarily by reference counting, which is easy to implement, but is prone to memory leaking when there are reference cycles, so with version 2.0 (October 2000) a generational garbage collector was implemented, and it is able to dispose of unreachable objects kept alive by reference cycles.\n\nBut the reference counting is still there as a baseline, and it causes the immediate dis‐ posal of objects with zero references. This means that, in CPython—at least for now —it’s safe to write this:\n\nopen('test.txt', 'wt', encoding='utf-8').write('1, 2, 3')\n\nThat code is safe because the reference count of the file object will be zero after the write method returns, and Python will immediately close the file before destroying the object representing it in memory. However, the same line is not safe in Jython or IronPython that use the garbage collector of their host runtimes (the Java VM and the .NET CLR), which are more sophisticated but do not rely on reference counting and may take longer to destroy the object and close the file. In all cases, including CPython, the best practice is to explicitly close the file, and the most reliable way of doing it is using the with statement, which guarantees that the file will be closed even if exceptions are raised while it is open. Using with, the previous snippet becomes:\n\n226\n\n|\n\nChapter 6: Object References, Mutability, and Recycling",
      "content_length": 3023,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 257,
      "content": "with open('test.txt', 'wt', encoding='utf-8') as fp: fp.write('1, 2, 3')\n\nIf you are into the subject of garbage collectors, you may want to read Thomas Perl’s paper “Python Garbage Collector Implementations: CPython, PyPy and GaS”, from which I learned the bit about the safety of the open().write() in CPython.\n\nParameter Passing: Call by Sharing\n\nA popular way of explaining how parameter passing works in Python is the phrase: “Parameters are passed by value, but the values are references.” This is not wrong, but causes confusion because the most common parameter passing modes in older lan‐ guages are call by value (the function gets a copy of the argument) and call by refer‐ ence (the function gets a pointer to the argument). In Python, the function gets a copy of the arguments, but the arguments are always references. So the value of the refer‐ enced objects may be changed, if they are mutable, but their identity cannot. Also, because the function gets a copy of the reference in an argument, rebinding it in the function body has no effect outside of the function. I adopted the term call by sharing after reading up on the subject in Programming Language Pragmatics, 3rd ed., by Michael L. Scott (Morgan Kaufmann), section “8.3.1: Parameter Modes.”\n\nFurther Reading\n\n|\n\n227",
      "content_length": 1291,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 259,
      "content": "PART II Functions as Objects",
      "content_length": 28,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 261,
      "content": "CHAPTER 7 Functions as First-Class Objects\n\nI have never considered Python to be heavily influenced by functional languages, no matter what people say or think. I was much more familiar with imperative languages such as C and Algol 68 and although I had made functions first-class objects, I didn’t view Python as a functional programming language.\n\n— Guido van Rossum, Python BDFL1\n\nFunctions in Python are first-class objects. Programming language researchers define a “first-class object” as a program entity that can be:\n\nCreated at runtime\n\nAssigned to a variable or element in a data structure\n\nPassed as an argument to a function\n\nReturned as the result of a function\n\nIntegers, strings, and dictionaries are other examples of first-class objects in Python —nothing fancy here. Having functions as first-class objects is an essential feature of functional languages, such as Clojure, Elixir, and Haskell. However, first-class func‐ tions are so useful that they’ve been adopted by popular languages like JavaScript, Go, and Java (since JDK 8), none of which claim to be “functional languages.”\n\nThis chapter and most of Part III explore the practical applications of treating func‐ tions as objects.\n\n1 “Origins of Python’s ‘Functional’ Features”, from Guido’s The History of Python blog.\n\n231",
      "content_length": 1300,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 262,
      "content": "The term “first-class functions” is widely used as shorthand for “functions as first-class objects.” It’s not ideal because it implies an “elite” among functions. In Python, all functions are first-class.\n\nWhat’s New in This Chapter The section “The Nine Flavors of Callable Objects” on page 237 was titled “The Seven Flavors of Callable Objects” in the first edition of this book. The new callables are native coroutines and asynchronous generators, introduced in Python 3.5 and 3.6, respectively. Both are covered in Chapter 21, but they are mentioned here along with the other callables for completeness.\n\n“Positional-Only Parameters” on page 242 is a new section, covering a feature added in Python 3.8.\n\nI moved the discussion of runtime access to function annotations to “Reading Type Hints at Runtime” on page 537. When I wrote the first edition, PEP 484—Type Hints was still under consideration, and people used annotations in different ways. Since Python 3.5, annotations should conform to PEP 484. Therefore, the best place to cover them is when discussing type hints.\n\nThe first edition of this book had sections about the introspection of function objects that were too low-level and distracted from the main subject of this chapter. I merged those sections into a post titled “Introspection of Function Parameters” at fluentpython.com.\n\nNow let’s see why Python functions are full-fledged objects.\n\nTreating a Function Like an Object The console session in Example 7-1 shows that Python functions are objects. Here we create a function, call it, read its __doc__ attribute, and check that the function object itself is an instance of the function class.\n\nExample 7-1. Create and test a function, then read its __doc__ and check its type\n\n>>> def factorial(n): ... \"\"\"returns n!\"\"\" ... return 1 if n < 2 else n * factorial(n - 1) ... >>> factorial(42) 1405006117752879898543142606244511569936384000000000 >>> factorial.__doc__\n\n232\n\n|\n\nChapter 7: Functions as First-Class Objects",
      "content_length": 1991,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 263,
      "content": "'returns n!' >>> type(factorial) <class 'function'>\n\nThis is a console session, so we’re creating a function at “runtime.”\n\n__doc__ is one of several attributes of function objects.\n\nfactorial is an instance of the function class.\n\nThe __doc__ attribute is used to generate the help text of an object. In the Python console, the command help(factorial) will display a screen like Figure 7-1.\n\nFigure 7-1. Help screen for factorial; the text is built from the __doc__ attribute of the function.\n\nExample 7-2 shows the “first class” nature of a function object. We can assign it a variable fact and call it through that name. We can also pass factorial as an argu‐ ment to the map function. Calling map(function, iterable) returns an iterable where each item is the result of calling the first argument (a function) to successive elements of the second argument (an iterable), range(10) in this example.\n\nExample 7-2. Use factorial through a different name, and pass factorial as an argument\n\n>>> fact = factorial >>> fact <function factorial at 0x...> >>> fact(5) 120 >>> map(factorial, range(11)) <map object at 0x...> >>> list(map(factorial, range(11))) [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n\nTreating a Function Like an Object\n\n|\n\n233",
      "content_length": 1255,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 264,
      "content": "Having first-class functions enables programming in a functional style. One of the hallmarks of functional programming is the use of higher-order functions, our next topic.\n\nHigher-Order Functions A function that takes a function as an argument or returns a function as the result is a higher-order function. One example is map, shown in Example 7-2. Another is the built-in function sorted: the optional key argument lets you provide a function to be applied to each item for sorting, as we saw in “list.sort Versus the sorted Built-In” on page 56. For example, to sort a list of words by length, pass the len function as the key, as in Example 7-3.\n\nExample 7-3. Sorting a list of words by length\n\n>>> fruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana'] >>> sorted(fruits, key=len) ['fig', 'apple', 'cherry', 'banana', 'raspberry', 'strawberry'] >>>\n\nAny one-argument function can be used as the key. For example, to create a rhyme dictionary it might be useful to sort each word spelled backward. In Example 7-4, note that the words in the list are not changed at all; only their reversed spelling is used as the sort criterion, so that the berries appear together.\n\nExample 7-4. Sorting a list of words by their reversed spelling\n\n>>> def reverse(word): ... return word[::-1] >>> reverse('testing') 'gnitset' >>> sorted(fruits, key=reverse) ['banana', 'apple', 'fig', 'raspberry', 'strawberry', 'cherry'] >>>\n\nIn the functional programming paradigm, some of the best known higher-order functions are map, filter, reduce, and apply. The apply function was deprecated in Python 2.3 and removed in Python 3 because it’s no longer necessary. If you need to call a function with a dynamic set of arguments, you can write fn(*args, **kwargs) instead of apply(fn, args, kwargs).\n\nThe map, filter, and reduce higher-order functions are still around, but better alter‐ natives are available for most of their use cases, as the next section shows.\n\n234\n\n|\n\nChapter 7: Functions as First-Class Objects",
      "content_length": 2015,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 265,
      "content": "Modern Replacements for map, filter, and reduce Functional languages commonly offer the map, filter, and reduce higher-order functions (sometimes with different names). The map and filter functions are still built-ins in Python 3, but since the introduction of list comprehensions and genera‐ tor expressions, they are not as important. A listcomp or a genexp does the job of map and filter combined, but is more readable. Consider Example 7-5.\n\nExample 7-5. Lists of factorials produced with map and filter compared to alternatives coded as list comprehensions\n\n>>> list(map(factorial, range(6))) [1, 1, 2, 6, 24, 120] >>> [factorial(n) for n in range(6)] [1, 1, 2, 6, 24, 120] >>> list(map(factorial, filter(lambda n: n % 2, range(6)))) [1, 6, 120] >>> [factorial(n) for n in range(6) if n % 2] [1, 6, 120] >>>\n\nBuild a list of factorials from 0! to 5!.\n\nSame operation, with a list comprehension.\n\nList of factorials of odd numbers up to 5!, using both map and filter.\n\nList comprehension does the same job, replacing map and filter, and making lambda unnecessary.\n\nIn Python 3, map and filter return generators—a form of iterator—so their direct substitute is now a generator expression (in Python 2, these functions returned lists, therefore their closest alternative was a listcomp).\n\nThe reduce function was demoted from a built-in in Python 2 to the functools module in Python 3. Its most common use case, summation, is better served by the sum built-in available since Python 2.3 was released in 2003. This is a big win in terms of readability and performance (see Example 7-6).\n\nExample 7-6. Sum of integers up to 99 performed with reduce and sum\n\n>>> from functools import reduce >>> from operator import add >>> reduce(add, range(100)) 4950 >>> sum(range(100))\n\nHigher-Order Functions\n\n|\n\n235",
      "content_length": 1804,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 266,
      "content": "4950 >>>\n\nStarting with Python 3.0, reduce is no longer a built-in.\n\nImport add to avoid creating a function just to add two numbers.\n\nSum integers up to 99.\n\nSame task with sum—no need to import and call reduce and add.\n\nThe common idea of sum and reduce is to apply some operation to successive items in a series, accumulating previous results, thus reducing a series of values to a single value.\n\nOther reducing built-ins are all and any:\n\nall(iterable)\n\nReturns True if there are no falsy elements in the iterable; all([]) returns True.\n\nany(iterable)\n\nReturns True if any element of the iterable is truthy; any([]) returns False.\n\nI give a fuller explanation of reduce in “Vector Take #4: Hashing and a Faster ==” on page 411 where an ongoing example provides a meaningful context for the use of this function. The reducing functions are summarized later in the book when iterables are in focus, in “Iterable Reducing Functions” on page 630.\n\nTo use a higher-order function, sometimes it is convenient to create a small, . one-off function. That is why anonymous functions exist. We’ll cover them next.\n\nAnonymous Functions The lambda keyword creates an anonymous function within a Python expression.\n\nHowever, the simple syntax of Python limits the body of lambda functions to be pure expressions. In other words, the body cannot contain other Python statements such as while, try, etc. Assignment with = is also a statement, so it cannot occur in a lambda. The new assignment expression syntax using := can be used—but if you need it, your lambda is probably too complicated and hard to read, and it should be refac‐ tored into a regular function using def.\n\n236\n\n|\n\nChapter 7: Functions as First-Class Objects",
      "content_length": 1717,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 267,
      "content": "The best use of anonymous functions is in the context of an argument list for a higher-order function. For example, Example 7-7 is the rhyme index example from Example 7-4 rewritten with lambda, without defining a reverse function.\n\nExample 7-7. Sorting a list of words by their reversed spelling using lambda\n\n>>> fruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana'] >>> sorted(fruits, key=lambda word: word[::-1]) ['banana', 'apple', 'fig', 'raspberry', 'strawberry', 'cherry'] >>>\n\nOutside the limited context of arguments to higher-order functions, anonymous functions are rarely useful in Python. The syntactic restrictions tend to make nontriv‐ ial lambdas either unreadable or unworkable. If a lambda is hard to read, I strongly advise you follow Fredrik Lundh’s refactoring advice.\n\nFredrik Lundh’s lambda Refactoring Recipe If you find a piece of code hard to understand because of a lambda, Fredrik Lundh suggests this refactoring procedure:\n\n1. Write a comment explaining what the heck that lambda does.\n\n2. Study the comment for a while, and think of a name that captures the essence of the comment.\n\n3. Convert the lambda to a def statement, using that name.\n\n4. Remove the comment.\n\nThese steps are quoted from the “Functional Programming HOWTO”, a must read.\n\nThe lambda syntax is just syntactic sugar: a lambda expression creates a function object just like the def statement. That is just one of several kinds of callable objects in Python. The following section reviews all of them.\n\nThe Nine Flavors of Callable Objects The call operator () may be applied to other objects besides functions. To determine whether an object is callable, use the callable() built-in function. As of Python 3.9, the data model documentation lists nine callable types:\n\nThe Nine Flavors of Callable Objects\n\n|\n\n237",
      "content_length": 1832,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 268,
      "content": "User-defined functions\n\nCreated with def statements or lambda expressions.\n\nBuilt-in functions\n\nA function implemented in C (for CPython), like len or time.strftime.\n\nBuilt-in methods\n\nMethods implemented in C, like dict.get.\n\nMethods\n\nFunctions defined in the body of a class.\n\nClasses\n\nWhen invoked, a class runs its __new__ method to create an instance, then __init__ to initialize it, and finally the instance is returned to the caller. Because there is no new operator in Python, calling a class is like calling a function.2\n\nClass instances\n\nIf a class defines a __call__ method, then its instances may be invoked as func‐ tions—that’s the subject of the next section.\n\nGenerator functions\n\nFunctions or methods that use the yield keyword in their body. When called, they return a generator object.\n\nNative coroutine functions\n\nFunctions or methods defined with async def. When called, they return a coroutine object. Added in Python 3.5.\n\nAsynchronous generator functions\n\nFunctions or methods defined with async def that have yield in their body. When called, they return an asynchronous generator for use with async for. Added in Python 3.6.\n\nGenerators, native coroutines, and asynchronous generator functions are unlike other callables in that their return values are never application data, but objects that require further processing to yield application data or perform useful work. Genera‐ tor functions return iterators. Both are covered in Chapter 17. Native coroutine func‐ tions and asynchronous generator functions return objects that only work with the help of an asynchronous programming framework, such as asyncio. They are the sub‐ ject of Chapter 21.\n\n2 Calling a class usually creates an instance of that same class, but other behaviors are possible by overriding\n\n__new__. We’ll see an example of this in “Flexible Object Creation with __new__” on page 843.\n\n238\n\n|\n\nChapter 7: Functions as First-Class Objects",
      "content_length": 1937,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 269,
      "content": "Given the variety of existing callable types in Python, the safest way to determine whether an object is callable is to use the callable() built-in:\n\n>>> abs, str, 'Ni!' (<built-in function abs>, <class 'str'>, 'Ni!') >>> [callable(obj) for obj in (abs, str, 'Ni!')] [True, True, False]\n\nWe now move on to building class instances that work as callable objects.\n\nUser-Defined Callable Types Not only are Python functions real objects, but arbitrary Python objects may also be made to behave like functions. Implementing a __call__ instance method is all it takes.\n\nExample 7-8 implements a BingoCage class. An instance is built from any iterable, and stores an internal list of items, in random order. Calling the instance pops an item.3\n\nExample 7-8. bingocall.py: A BingoCage does one thing: picks items from a shuffled list\n\nimport random\n\nclass BingoCage:\n\ndef __init__(self, items): self._items = list(items) random.shuffle(self._items)\n\ndef pick(self): try: return self._items.pop() except IndexError: raise LookupError('pick from empty BingoCage')\n\ndef __call__(self): return self.pick()\n\n3 Why build a BingoCage when we already have random.choice? The choice function may return the same item multiple times, because the picked item is not removed from the collection given. Calling BingoCage never returns duplicate results—as long as the instance is filled with unique values.\n\nUser-Defined Callable Types\n\n|\n\n239",
      "content_length": 1423,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 270,
      "content": "__init__ accepts any iterable; building a local copy prevents unexpected side effects on any list passed as an argument.\n\nshuffle is guaranteed to work because self._items is a list.\n\nThe main method.\n\nRaise exception with custom message if self._items is empty.\n\nShortcut to bingo.pick(): bingo().\n\nHere is a simple demo of Example 7-8. Note how a bingo instance can be invoked as a function, and the callable() built-in recognizes it as a callable object:\n\n>>> bingo = BingoCage(range(3)) >>> bingo.pick() 1 >>> bingo() 0 >>> callable(bingo) True\n\nA class implementing __call__ is an easy way to create function-like objects that have some internal state that must be kept across invocations, like the remaining items in the BingoCage. Another good use case for __call__ is implementing decora‐ tors. Decorators must be callable, and it is sometimes convenient to “remember” something between calls of the decorator (e.g., for memoization—caching the results of expensive computations for later use) or to split a complex implementation into separate methods.\n\nThe functional approach to creating functions with internal state is to use closures. Closures, as well as decorators, are the subject of Chapter 9.\n\nNow let’s explore the powerful syntax Python offers to declare function parameters and pass arguments into them.\n\nFrom Positional to Keyword-Only Parameters One of the best features of Python functions is the extremely flexible parameter han‐ dling mechanism. Closely related are the use of * and ** to unpack iterables and mappings into separate arguments when we call a function. To see these features in action, see the code for Example 7-9 and tests showing its use in Example 7-10.\n\n240\n\n|\n\nChapter 7: Functions as First-Class Objects",
      "content_length": 1752,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 271,
      "content": "Example 7-9. tag generates HTML elements; a keyword-only argument class_ is used to pass “class” attributes as a workaround because class is a keyword in Python\n\ndef tag(name, *content, class_=None, **attrs): \"\"\"Generate one or more HTML tags\"\"\" if class_ is not None: attrs['class'] = class_ attr_pairs = (f' {attr}=\"{value}\"' for attr, value in sorted(attrs.items())) attr_str = ''.join(attr_pairs) if content: elements = (f'<{name}{attr_str}>{c}</{name}>' for c in content) return '\\n'.join(elements) else: return f'<{name}{attr_str} />'\n\nThe tag function can be invoked in many ways, as Example 7-10 shows.\n\nExample 7-10. Some of the many ways of calling the tag function from Example 7-9\n\n>>> tag('br') '<br />' >>> tag('p', 'hello') '<p>hello</p>' >>> print(tag('p', 'hello', 'world')) <p>hello</p> <p>world</p> >>> tag('p', 'hello', id=33) '<p id=\"33\">hello</p>' >>> print(tag('p', 'hello', 'world', class_='sidebar')) <p class=\"sidebar\">hello</p> <p class=\"sidebar\">world</p> >>> tag(content='testing', name=\"img\") '<img content=\"testing\" />' >>> my_tag = {'name': 'img', 'title': 'Sunset Boulevard', ... 'src': 'sunset.jpg', 'class': 'framed'} >>> tag(**my_tag) '<img class=\"framed\" src=\"sunset.jpg\" title=\"Sunset Boulevard\" />'\n\nA single positional argument produces an empty tag with that name.\n\nAny number of arguments after the first are captured by *content as a tuple.\n\nKeyword arguments not explicitly named in the tag signature are captured by **attrs as a dict.\n\nThe class_ parameter can only be passed as a keyword argument.\n\nFrom Positional to Keyword-Only Parameters\n\n|\n\n241",
      "content_length": 1595,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 272,
      "content": "The first positional argument can also be passed as a keyword.\n\nPrefixing the my_tag dict with ** passes all its items as separate arguments, which are then bound to the named parameters, with the remaining caught by **attrs. In this case we can have a 'class' key in the arguments dict, because it is a string, and does not clash with the class reserved word.\n\nKeyword-only arguments are a feature of Python 3. In Example 7-9, the class_ parameter can only be given as a keyword argument—it will never capture unnamed positional arguments. To specify keyword-only arguments when defining a function, name them after the argument prefixed with *. If you don’t want to support variable positional arguments but still want keyword-only arguments, put a * by itself in the signature, like this:\n\n>>> def f(a, *, b): ... return a, b ... >>> f(1, b=2) (1, 2) >>> f(1, 2) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: f() takes 1 positional argument but 2 were given\n\nNote that keyword-only arguments do not need to have a default value: they can be mandatory, like b in the preceding example.\n\nPositional-Only Parameters Since Python 3.8, user-defined function signatures may specify positional-only parameters. This feature always existed for built-in functions, such as divmod(a, b), which can only be called with positional parameters, and not as divmod(a=10, b=4).\n\nTo define a function requiring positional-only parameters, use / in the parameter list.\n\nThis example from “What’s New In Python 3.8” shows how to emulate the divmod built-in function:\n\ndef divmod(a, b, /): return (a // b, a % b)\n\nAll arguments to the left of the / are positional-only. After the /, you may specify other arguments, which work as usual.\n\n242\n\n|\n\nChapter 7: Functions as First-Class Objects",
      "content_length": 1807,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 273,
      "content": "The / in the parameter list is a syntax error in Python 3.7 or earlier.\n\nFor example, consider the tag function from Example 7-9. If we want the name parameter to be positional only, we can add a / after it in the function signature, like this:\n\ndef tag(name, /, *content, class_=None, **attrs): ...\n\nYou can find other examples of positional-only parameters in “What’s New In Python 3.8” and in PEP 570.\n\nAfter diving into Python’s flexible argument declaration features, the remainder of this chapter covers the most useful packages in the standard library for programming in a functional style.\n\nPackages for Functional Programming Although Guido makes it clear that he did not design Python to be a functional pro‐ gramming language, a functional coding style can be used to good extent, thanks to first-class functions, pattern matching, and the support of packages like operator and functools, which we cover in the next two sections.\n\nThe operator Module Often in functional programming it is convenient to use an arithmetic operator as a function. For example, suppose you want to multiply a sequence of numbers to calcu‐ late factorials without using recursion. To perform summation, you can use sum, but there is no equivalent function for multiplication. You could use reduce—as we saw in “Modern Replacements for map, filter, and reduce” on page 235—but this requires a function to multiply two items of the sequence. Example 7-11 shows how to solve this using lambda.\n\nExample 7-11. Factorial implemented with reduce and an anonymous function\n\nfrom functools import reduce\n\ndef factorial(n): return reduce(lambda a, b: a*b, range(1, n+1))\n\nPackages for Functional Programming\n\n|\n\n243",
      "content_length": 1696,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 274,
      "content": "The operator module provides function equivalents for dozens of operators so you don’t have to code trivial functions like lambda a, b: a*b. With it, we can rewrite Example 7-11 as Example 7-12.\n\nExample 7-12. Factorial implemented with reduce and operator.mul\n\nfrom functools import reduce from operator import mul\n\ndef factorial(n): return reduce(mul, range(1, n+1))\n\nAnother group of one-trick lambdas that operator replaces are functions to pick items from sequences or read attributes from objects: itemgetter and attrgetter are factories that build custom functions to do that.\n\nExample 7-13 shows a common use of itemgetter: sorting a list of tuples by the value of one field. In the example, the cities are printed sorted by country code (field 1). Essentially, itemgetter(1) creates a function that, given a collection, returns the item at index 1. That’s easier to write and read than lambda fields: fields[1], which does the same thing.\n\nExample 7-13. Demo of itemgetter to sort a list of tuples (data from Example 2-8)\n\n>>> metro_data = [ ... ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)), ... ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), ... ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)), ... ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), ... ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)), ... ] >>> >>> from operator import itemgetter >>> for city in sorted(metro_data, key=itemgetter(1)): ... print(city) ... ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)) ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)) ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)) ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)) ('New York-Newark', 'US', 20.104, (40.808611, -74.020386))\n\nIf you pass multiple index arguments to itemgetter, the function it builds will return tuples with the extracted values, which is useful for sorting on multiple keys:\n\n>>> cc_name = itemgetter(1, 0) >>> for city in metro_data: ... print(cc_name(city))\n\n244\n\n|\n\nChapter 7: Functions as First-Class Objects",
      "content_length": 2040,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 275,
      "content": "... ('JP', 'Tokyo') ('IN', 'Delhi NCR') ('MX', 'Mexico City') ('US', 'New York-Newark') ('BR', 'São Paulo') >>>\n\nBecause itemgetter uses the [] operator, it supports not only sequences but also mappings and any class that implements __getitem__.\n\nA sibling of itemgetter is attrgetter, which creates functions to extract object attributes by name. If you pass attrgetter several attribute names as arguments, it also returns a tuple of values. In addition, if any argument name contains a . (dot), attrgetter navigates through nested objects to retrieve the attribute. These behav‐ iors are shown in Example 7-14. This is not the shortest console session because we need to build a nested structure to showcase the handling of dotted attributes by attrgetter.\n\nExample 7-14. Demo of attrgetter to process a previously defined list of namedtuple called metro_data (the same list that appears in Example 7-13)\n\n>>> from collections import namedtuple >>> LatLon = namedtuple('LatLon', 'lat lon') >>> Metropolis = namedtuple('Metropolis', 'name cc pop coord') >>> metro_areas = [Metropolis(name, cc, pop, LatLon(lat, lon)) ... for name, cc, pop, (lat, lon) in metro_data] >>> metro_areas[0] Metropolis(name='Tokyo', cc='JP', pop=36.933, coord=LatLon(lat=35.689722, lon=139.691667)) >>> metro_areas[0].coord.lat 35.689722 >>> from operator import attrgetter >>> name_lat = attrgetter('name', 'coord.lat') >>> >>> for city in sorted(metro_areas, key=attrgetter('coord.lat')): ... print(name_lat(city)) ... ('São Paulo', -23.547778) ('Mexico City', 19.433333) ('Delhi NCR', 28.613889) ('Tokyo', 35.689722) ('New York-Newark', 40.808611)\n\nUse namedtuple to define LatLon.\n\nAlso define Metropolis.\n\nPackages for Functional Programming\n\n|\n\n245",
      "content_length": 1733,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 276,
      "content": "Build metro_areas list with Metropolis instances; note the nested tuple unpack‐ ing to extract (lat, lon) and use them to build the LatLon for the coord attribute of Metropolis.\n\nReach into element metro_areas[0] to get its latitude.\n\nDefine an attrgetter to retrieve the name and the coord.lat nested attribute.\n\nUse attrgetter again to sort list of cities by latitude.\n\nUse the attrgetter defined in\n\nto show only the city name and latitude.\n\nHere is a partial list of functions defined in operator (names starting with _ are omit‐ ted, because they are mostly implementation details):\n\n>>> [name for name in dir(operator) if not name.startswith('_')] ['abs', 'add', 'and_', 'attrgetter', 'concat', 'contains', 'countOf', 'delitem', 'eq', 'floordiv', 'ge', 'getitem', 'gt', 'iadd', 'iand', 'iconcat', 'ifloordiv', 'ilshift', 'imatmul', 'imod', 'imul', 'index', 'indexOf', 'inv', 'invert', 'ior', 'ipow', 'irshift', 'is_', 'is_not', 'isub', 'itemgetter', 'itruediv', 'ixor', 'le', 'length_hint', 'lshift', 'lt', 'matmul', 'methodcaller', 'mod', 'mul', 'ne', 'neg', 'not_', 'or_', 'pos', 'pow', 'rshift', 'setitem', 'sub', 'truediv', 'truth', 'xor']\n\nMost of the 54 names listed are self-evident. The group of names prefixed with i and the name of another operator—e.g., iadd, iand, etc.—correspond to the augmented assignment operators—e.g., +=, &=, etc. These change their first argument in place, if it is mutable; if not, the function works like the one without the i prefix: it simply returns the result of the operation.\n\nOf the remaining operator functions, methodcaller is the last we will cover. It is somewhat similar to attrgetter and itemgetter in that it creates a function on the fly. The function it creates calls a method by name on the object given as argument, as shown in Example 7-15.\n\nExample 7-15. Demo of methodcaller: second test shows the binding of extra arguments\n\n>>> from operator import methodcaller >>> s = 'The time has come' >>> upcase = methodcaller('upper') >>> upcase(s) 'THE TIME HAS COME' >>> hyphenate = methodcaller('replace', ' ', '-') >>> hyphenate(s) 'The-time-has-come'\n\n246\n\n|\n\nChapter 7: Functions as First-Class Objects",
      "content_length": 2166,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 277,
      "content": "The first test in Example 7-15 is there just to show methodcaller at work, but if you need to use the str.upper as a function, you can just call it on the str class and pass a string as an argument, like this:\n\n>>> str.upper(s) 'THE TIME HAS COME'\n\nThe second test in Example 7-15 shows that methodcaller can also do a partial appli‐ cation to freeze some arguments, like the functools.partial function does. That is our next subject.*Bold Text*opmod07\n\nFreezing Arguments with functools.partial The functools module provides several higher-order functions. We saw reduce in “Modern Replacements for map, filter, and reduce” on page 235. Another is partial: given a callable, it produces a new callable with some of the arguments of the original callable bound to predetermined values. This is useful to adapt a function that takes one or more arguments to an API that requires a callback with fewer arguments. Example 7-16 is a trivial demonstration.\n\nExample 7-16. Using partial to use a two-argument function where a one-argument callable is required\n\n>>> from operator import mul >>> from functools import partial >>> triple = partial(mul, 3) >>> triple(7) 21 >>> list(map(triple, range(1, 10))) [3, 6, 9, 12, 15, 18, 21, 24, 27]\n\nCreate new triple function from mul, binding the first positional argument to 3.\n\nTest it.\n\nUse triple with map; mul would not work with map in this example.\n\nA more useful example involves the unicode.normalize function that we saw in “Normalizing Unicode for Reliable Comparisons” on page 140. If you work with text from many languages, you may want to apply unicode.normalize('NFC', s) to any string s before comparing or storing it. If you do that often, it’s handy to have an nfc function to do so, as in Example 7-17.\n\nPackages for Functional Programming\n\n|\n\n247",
      "content_length": 1803,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 278,
      "content": "Example 7-17. Building a convenient Unicode normalizing function with partial\n\n>>> import unicodedata, functools >>> nfc = functools.partial(unicodedata.normalize, 'NFC') >>> s1 = 'café' >>> s2 = 'cafe\\u0301' >>> s1, s2 ('café', 'café') >>> s1 == s2 False >>> nfc(s1) == nfc(s2) True\n\npartial takes a callable as first argument, followed by an arbitrary number of posi‐ tional and keyword arguments to bind.\n\nExample 7-18 shows the use of partial with the tag function from Example 7-9, to freeze one positional argument and one keyword argument.\n\nExample 7-18. Demo of partial applied to the function tag from Example 7-9\n\n>>> from tagger import tag >>> tag <function tag at 0x10206d1e0> >>> from functools import partial >>> picture = partial(tag, 'img', class_='pic-frame') >>> picture(src='wumpus.jpeg') '<img class=\"pic-frame\" src=\"wumpus.jpeg\" />' >>> picture functools.partial(<function tag at 0x10206d1e0>, 'img', class_='pic-frame') >>> picture.func <function tag at 0x10206d1e0> >>> picture.args ('img',) >>> picture.keywords {'class_': 'pic-frame'}\n\nImport tag from Example 7-9 and show its ID.\n\nCreate the picture function from tag by fixing the first positional argument with 'img' and the class_ keyword argument with 'pic-frame'.\n\npicture works as expected.\n\n248\n\n|\n\nChapter 7: Functions as First-Class Objects",
      "content_length": 1325,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 279,
      "content": "partial() returns a functools.partial object.4\n\nA functools.partial object has attributes providing access to the original func‐ tion and the fixed arguments.\n\nThe functools.partialmethod function does the same job as partial, but is designed to work with methods.\n\nThe functools module also includes higher-order functions designed to be used as function decorators, such as cache and singledispatch, among others. Those functions are covered in Chapter 9, which also explains how to implement custom decorators.\n\nChapter Summary The goal of this chapter was to explore the first-class nature of functions in Python. The main ideas are that you can assign functions to variables, pass them to other functions, store them in data structures, and access function attributes, allowing frameworks and tools to act on that information.\n\nHigher-order functions, a staple of functional programming, are common in Python. The sorted, min, and max built-ins, and functools.partial are examples of com‐ monly used higher-order functions in the language. Using map, filter, and reduce is not as common as it used to be, thanks to list comprehensions (and similar con‐ structs like generator expressions) and the addition of reducing built-ins like sum, all, and any.\n\nCallables come in nine different flavors since Python 3.6, from the simple functions created with lambda to instances of classes implementing __call__. Generators and coroutines are also callable, although their behavior is very different from other calla‐ bles. All callables can be detected by the callable() built-in. Callables offer rich syn‐ tax for declaring formal parameters, including keyword-only parameters, positional- only parameters, and annotations.\n\nLastly, we covered some functions from the operator module and functools.par tial, which facilitate functional programming by minimizing the need for the func‐ tionally challenged lambda syntax.\n\n4 The source code for functools.py reveals that functools.partial is implemented in C and is used by default.\n\nIf that is not available, a pure-Python implementation of partial is available since Python 3.4.\n\nChapter Summary\n\n|\n\n249",
      "content_length": 2152,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 280,
      "content": "Further Reading The next chapters continue our exploration of programming with function objects. Chapter 8 is devoted to type hints in function parameters and return values. Chap‐ ter 9 dives into function decorators—a special kind of higher-order function—and the closure mechanism that makes them work. Chapter 10 shows how first-class functions can simplify some classic object-oriented design patterns.\n\nIn The Python Language Reference, “3.2. The standard type hierarchy” presents the nine callable types, along with all the other built-in types.\n\nChapter 7 of the Python Cookbook, 3rd ed. (O’Reilly), by David Beazley and Brian K. Jones, is an excellent complement to the current chapter as well as Chapter 9 of this book, covering mostly the same concepts with a different approach.\n\nSee PEP 3102—Keyword-Only Arguments if you are interested in the rationale and use cases for that feature.\n\nA great introduction to functional programming in Python is A. M. Kuchling’s “Python Functional Programming HOWTO”. The main focus of that text, however, is the use of iterators and generators, which are the subject of Chapter 17.\n\nThe StackOverflow question “Python: Why is functools.partial necessary?” has a highly informative (and funny) reply by Alex Martelli, coauthor of the classic Python in a Nutshell (O’Reilly).\n\nReflecting on the question “Is Python a functional language?”, I created one of my favorite talks, “Beyond Paradigms,” which I presented at PyCaribbean, PyBay, and PyConDE. See the slides and video from the Berlin presentation—where I met Miro‐ slav Šedivý and Jürgen Gmach, two of the technical reviewers of this book.\n\nSoapbox\n\nIs Python a Functional Language?\n\nSometime in the year 2000 I attended a Zope workshop at Zope Corporation in the United States when Guido van Rossum dropped by the classroom (he was not the instructor). In the Q&A that followed, somebody asked him which features of Python were borrowed from other languages. Guido’s answer: “Everything that is good in Python was stolen from other languages.”\n\nShriram Krishnamurthi, professor of Computer Science at Brown University, starts his “Teaching Programming Languages in a Post-Linnaean Age” paper with this:\n\nProgramming language “paradigms” are a moribund and tedious legacy of a bygone age. Modern language designers pay them no respect, so why do our courses slavishly adhere to them?\n\n250\n\n|\n\nChapter 7: Functions as First-Class Objects",
      "content_length": 2439,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 281,
      "content": "In that paper, Python is mentioned by name in this passage:\n\nWhat else to make of a language like Python, Ruby, or Perl? Their designers have no patience for the niceties of these Linnaean hierarchies; they borrow features as they wish, creating mélanges that utterly defy characterization.\n\nKrishnamurthi argues that instead of trying to classify languages in some taxonomy, it’s more useful to consider them as aggregations of features. His ideas inspired my talk “Beyond Paradigms,” mentioned at the end of “Further Reading” on page 250.\n\nEven if it was not Guido’s goal, endowing Python with first-class functions opened the door to functional programming. In his post, “Origins of Python’s Functional Features”, he says that map, filter, and reduce were the motivation for adding lambda to Python in the first place. All of these features were contributed together by Amrit Prem for Python 1.0 in 1994, according to Misc/HISTORY in the CPython source code.\n\nFunctions like map, filter, and reduce first appeared in Lisp, the original functional language. However, Lisp does not limit what can be done inside a lambda, because everything in Lisp is an expression. Python uses a statement-oriented syntax in which expressions cannot contain statements, and many language constructs are statements —including try/catch, which is what I miss most often when writing lambdas. This is the price to pay for Python’s highly readable syntax.5 Lisp has many strengths, but readability is not one of them.\n\nIronically, stealing the list comprehension syntax from another functional language— Haskell—significantly diminished the need for map and filter, and also for lambda.\n\nBesides the limited anonymous function syntax, the biggest obstacle to wider adop‐ tion of functional programming idioms in Python is the lack of tail-call elimination, an optimization that allows memory-efficient computation of a function that makes a recursive call at the “tail” of its body. In another blog post, “Tail Recursion Elimina‐ tion”, Guido gives several reasons why such optimization is not a good fit for Python. That post is a great read for the technical arguments, but even more so because the first three and most important reasons given are usability issues. It is no accident that Python is a pleasure to use, learn, and teach. Guido made it so.\n\nSo there you have it: Python is not, by design, a functional language—whatever that means. Python just borrows a few good ideas from functional languages.\n\nThe Problem with Anonymous Functions\n\nBeyond the Python-specific syntax constraints, anonymous functions have a serious drawback in any language: they have no name.\n\n5 There is also the problem of lost indentation when pasting code to web forums, but I digress.\n\nFurther Reading\n\n|\n\n251",
      "content_length": 2781,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 282,
      "content": "I am only half joking here. Stack traces are easier to read when functions have names. Anonymous functions are a handy shortcut, people have fun coding with them, but sometimes they get carried away—especially if the language and environment encourage deep nesting of anonymous functions, like JavaScript on Node.js do. Lots of nested anonymous functions make debugging and error handling hard. Asynchro‐ nous programming in Python is more structured, perhaps because the limited lambda syntax prevents its abuse and forces a more explicit approach. Promises, futures, and deferreds are concepts used in modern asynchronous APIs. Along with coroutines, they provide an escape from the so-called “callback hell.” I promise to write more about asynchronous programming in the future, but this subject must be deferred to Chapter 21.\n\n252\n\n|\n\nChapter 7: Functions as First-Class Objects",
      "content_length": 883,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 283,
      "content": "CHAPTER 8 Type Hints in Functions\n\nIt should also be emphasized that Python will remain a dynamically typed language, and the authors have no desire to ever make type hints mandatory, even by convention.\n\n—Guido van Rossum, Jukka Lehtosalo, and Łukasz Langa, PEP 484—Type Hints1\n\nType hints are the biggest change in the history of Python since the unification of types and classes in Python 2.2, released in 2001. However, type hints do not benefit all Python users equally. That’s why they should always be optional.\n\nPEP 484—Type Hints introduced syntax and semantics for explicit type declarations in function arguments, return values, and variables. The goal is to help developer tools find bugs in Python codebases via static analysis, i.e., without actually running the code through tests.\n\nThe main beneficiaries are professional software engineers using IDEs (Integrated Development Environments) and CI (Continuous Integration). The cost-benefit analysis that makes type hints attractive to that group does not apply to all users of Python.\n\nPython’s user base is much wider than that. It includes scientists, traders, journalists, artists, makers, analysts, and students in many fields—among others. For most of them, the cost of learning type hints is likely higher—unless they already know a language with static types, subtyping, and generics. The benefits will be lower for many of those users, given how they interact with Python, and the smaller size of their codebases and teams—often “teams” of one. Python’s default dynamic typing is\n\n1 PEP 484—Type Hints, “Rationale and Goals”; bold emphasis retained from the original.\n\n253",
      "content_length": 1646,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 284,
      "content": "simpler and more expressive when writing code for exploring data and ideas, as in data science, creative computing, and learning,\n\nThis chapter focuses on Python’s type hints in function signatures. Chapter 15 explores type hints in the context of classes, and other typing module features.\n\nThe major topics in this chapter are:\n\nA hands-on introduction to gradual typing with Mypy\n\nThe complementary perspectives of duck typing and nominal typing\n\nOverview of the main categories of types that can appear in annotations—this is about 60% of the chapter\n\nType hinting variadic parameters (*args, **kwargs)\n\nLimitations and downsides of type hints and static typing\n\nWhat’s New in This Chapter This chapter is completely new. Type hints appeared in Python 3.5 after I wrapped up the first edition of Fluent Python.\n\nGiven the limitations of a static type system, the best idea of PEP 484 was to intro‐ duce a gradual type system. Let’s begin by defining what that means.\n\nAbout Gradual Typing PEP 484 introduced a gradual type system to Python. Other languages with gradual type systems are Microsoft’s TypeScript, Dart (the language of the Flutter SDK, cre‐ ated by Google), and Hack (a dialect of PHP supported by Facebook’s HHVM virtual machine). The Mypy type checker itself started as a language: a gradually typed dia‐ lect of Python with its own interpreter. Guido van Rossum convinced the creator of Mypy, Jukka Lehtosalo, to make it a tool for checking annotated Python code.\n\nA gradual type system:\n\nIs optional\n\nBy default, the type checker should not emit warnings for code that has no type hints. Instead, the type checker assumes the Any type when it cannot determine the type of an object. The Any type is considered compatible with all other types.\n\nDoes not catch type errors at runtime\n\nType hints are used by static type checkers, linters, and IDEs to raise warnings. They do not prevent inconsistent values from being passed to functions or assigned to variables at runtime.\n\n254\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 2038,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 285,
      "content": "Does not enhance performance\n\nType annotations provide data that could, in theory, allow optimizations in the generated bytecode, but such optimizations are not implemented in any Python runtime that I am aware in of July 2021.2\n\nThe best usability feature of gradual typing is that annotations are always optional.\n\nWith static type systems, most type constraints are easy to express, many are cumber‐ some, some are hard, and a few are impossible.3 You may very well write an excellent piece of Python code, with good test coverage and passing tests, but still be unable to add type hints that satisfy a type checker. That’s OK; just leave out the problematic type hints and ship it!\n\nType hints are optional at all levels: you can have entire packages with no type hints, you can silence the type checker when you import one of those packages into a mod‐ ule where you use type hints, and you can add special comments to make the type checker ignore specific lines in your code.\n\nSeeking 100% coverage of type hints is likely to stimulate type hint‐ ing without proper thought, only to satisfy the metric. It will also prevent teams from making the most of the power and flexibility of Python. Code without type hints should naturally be accepted when annotations would make an API less user-friendly, or unduly complicate its implementation.\n\nGradual Typing in Practice Let’s see how gradual typing works in practice, starting with a simple function and gradually adding type hints to it, guided by Mypy.\n\nThere are several Python type checkers compatible with PEP 484, including Google’s pytype, Microsoft’s Pyright, Facebook’s Pyre— in addition to type checkers embedded in IDEs such as PyCharm. I picked Mypy for the examples because it’s the best known. How‐ ever, one of the others may be a better fit for some projects or teams. Pytype, for example, is designed to handle codebases with no type hints and still provide useful advice. It is more lenient than Mypy, and can also generate annotations for your code.\n\n2 A just-in-time compiler like the one in PyPy has much better data than type hints: it monitors the Python program as it runs, detects the concrete types in use, and generates optimized machine code for those concrete types.\n\n3 For example, recursive types are not supported as of July 2021—see typing module issue #182, Define a JSON\n\ntype and Mypy issue #731, Support recursive types.\n\nGradual Typing in Practice\n\n|\n\n255",
      "content_length": 2447,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 286,
      "content": "We will annotate a show_count function that returns a string with a count and a sin‐ gular or plural word, depending on the count:\n\n>>> show_count(99, 'bird') '99 birds' >>> show_count(1, 'bird') '1 bird' >>> show_count(0, 'bird') 'no birds'\n\nExample 8-1 shows the source code of show_count, without annotations.\n\nExample 8-1. show_count from messages.py without type hints\n\ndef show_count(count, word): if count == 1: return f'1 {word}' count_str = str(count) if count else 'no' return f'{count_str} {word}s'\n\nStarting with Mypy To begin type checking, I run the mypy command on the messages.py module:\n\n…/no_hints/ $ pip install mypy [lots of messages omitted...] …/no_hints/ $ mypy messages.py Success: no issues found in 1 source file\n\nMypy with default settings finds no problem with Example 8-1.\n\nI am using Mypy 0.910, the most recent release as I review this in July 2021. The Mypy “Introduction” warns that it “is officially beta software. There will be occasional changes that break backward compatibility.” Mypy is giving me at least one report that is not the same I got when I wrote this chapter in April 2020. By the time you read this, you may get different results than shown here.\n\nIf a function signature has no annotations, Mypy ignores it by default—unless config‐ ured otherwise.\n\nFor Example 8-2, I also have pytest unit tests. This is the code in messages_test.py.\n\nExample 8-2. messages_test.py without type hints\n\nfrom pytest import mark\n\nfrom messages import show_count\n\n256\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1539,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 287,
      "content": "@mark.parametrize('qty, expected', [ (1, '1 part'), (2, '2 parts'), ]) def test_show_count(qty, expected): got = show_count(qty, 'part') assert got == expected\n\ndef test_show_count_zero(): got = show_count(0, 'part') assert got == 'no parts'\n\nNow let’s add type hints, guided by Mypy.\n\nMaking Mypy More Strict The command-line option --disallow-untyped-defs makes Mypy flag any function definition that does not have type hints for all its parameters and for its return value.\n\nUsing --disallow-untyped-defs on the test file produces three errors and a note:\n\n…/no_hints/ $ mypy --disallow-untyped-defs messages_test.py messages.py:14: error: Function is missing a type annotation messages_test.py:10: error: Function is missing a type annotation messages_test.py:15: error: Function is missing a return type annotation messages_test.py:15: note: Use \"-> None\" if function does not return a value Found 3 errors in 2 files (checked 1 source file)\n\nFor the first steps with gradual typing, I prefer to use another option: --disallow- incomplete-defs. Initially, it tells me nothing:\n\n…/no_hints/ $ mypy --disallow-incomplete-defs messages_test.py Success: no issues found in 1 source file\n\nNow I can add just the return type to show_count in messages.py:\n\ndef show_count(count, word) -> str:\n\nThis is enough to make Mypy look at it. Using the same command line as before to check messages_test.py will lead Mypy to look at messages.py again:\n\n…/no_hints/ $ mypy --disallow-incomplete-defs messages_test.py messages.py:14: error: Function is missing a type annotation for one or more arguments Found 1 error in 1 file (checked 1 source file)\n\nNow I can gradually add type hints function by function, without getting warnings about functions that I haven’t annotated. This is a fully annotated signature that satis‐ fies Mypy:\n\ndef show_count(count: int, word: str) -> str:\n\nGradual Typing in Practice\n\n|\n\n257",
      "content_length": 1906,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 288,
      "content": "like --disallow- Instead of incomplete-defs, you can save your favorite as described in the Mypy configuration file documentation. You can have global set‐ tings and per-module settings. Here is a simple mypy.ini to get started:\n\ntyping command-line options\n\n[mypy] python_version = 3.9 warn_unused_configs = True disallow_incomplete_defs = True\n\nA Default Parameter Value The show_count function in Example 8-1 only works with regular nouns. If the plural can’t be spelled by appending an 's', we should let the user provide the plural form, like this:\n\n>>> show_count(3, 'mouse', 'mice') '3 mice'\n\nLet’s do a little “type-driven development.” First we add a test that uses that third argument. Don’t forget to add the return type hint to the test function, otherwise Mypy will not check it.\n\ndef test_irregular() -> None: got = show_count(2, 'child', 'children') assert got == '2 children'\n\nMypy detects the error:\n\n…/hints_2/ $ mypy messages_test.py messages_test.py:22: error: Too many arguments for \"show_count\" Found 1 error in 1 file (checked 1 source file)\n\nNow I edit show_count, adding the optional plural parameter in Example 8-3.\n\nExample 8-3. showcount from hints_2/messages.py with an optional parameter\n\ndef show_count(count: int, singular: str, plural: str = '') -> str: if count == 1: return f'1 {singular}' count_str = str(count) if count else 'no' if not plural: plural = singular + 's' return f'{count_str} {plural}'\n\nNow Mypy reports “Success.”\n\n258\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1509,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 289,
      "content": "Here is one typing mistake that Python does not catch. Can you spot it?\n\ndef hex2rgb(color=str) -> tuple[int, int, int]:\n\nMypy’s error report is not very helpful:\n\ncolors.py:24: error: Function is missing a type annotation for one or more arguments\n\nThe type hint for the color argument should be color: str. I wrote color=str, which is not an annotation: it sets the default value of color to str.\n\nIn my experience, it’s a common mistake and easy to overlook, especially in complicated type hints.\n\nThe following details are considered good style for type hints:\n\nNo space between the parameter name and the :; one space after the : • Spaces on both sides of the = that precedes a default parameter value\n\nOn the other hand, PEP 8 says there should be no spaces around the = if there is no type hint for that particular parameter.\n\nCode Style: Use flake8 and blue Instead of memorizing such silly rules, use tools like flake8 and blue. flake8 reports on code styling, among many other issues, and blue rewrites source code according to (most) rules embedded in the black code formatting tool.\n\nGiven the goal of enforcing a “standard” coding style, blue is better than black because it follows Python’s own style of using single quotes by default, double quotes as an alternative:\n\n>>> \"I prefer single quotes\" 'I prefer single quotes'\n\nThe preference for single quotes is embedded in repr(), among other places in CPy‐ thon. The doctest module depends on repr() using single quotes by default.\n\nOne of the authors of blue is Barry Warsaw, coauthor of PEP 8, Python core devel‐ oper since 1994, and a member of Python’s Steering Council from 2019 to present (July 2021). We are in very good company when we choose single quotes by default.\n\nIf you must use black, use the black -S option. Then it will leave your quotes as they are.\n\nGradual Typing in Practice\n\n|\n\n259",
      "content_length": 1870,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 290,
      "content": "Using None as a Default In Example 8-3, the parameter plural is annotated as str, and the default value is '', so there is no type conflict.\n\nI like that solution, but in other contexts None is a better default. If the optional parameter expects a mutable type, then None is the only sensible default—as we saw in “Mutable Types as Parameter Defaults: Bad Idea” on page 214.\n\nTo have None as the default for the plural parameter, here is what the signature would look like:\n\nfrom typing import Optional\n\ndef show_count(count: int, singular: str, plural: Optional[str] = None) -> str:\n\nLet’s unpack that:\n\nOptional[str] means plural may be a str or None. • You must explicitly provide the default value = None.\n\nIf you don’t assign a default value to plural, the Python runtime will treat it as a required parameter. Remember: at runtime, type hints are ignored.\n\nNote that we need to import Optional from the typing module. When importing types, it’s good practice to use the syntax from typing import X to reduce the length of the function signatures.\n\nOptional is not a great name, because that annotation does not make the parameter optional. What makes it optional is assigning a default value to the parameter. Optional[str] just means: the type of this parameter may be str or NoneType. In the Haskell and Elm languages, a similar type is named Maybe.\n\nNow that we’ve had a first practical view of gradual typing, let’s consider what the concept of type means in practice.\n\nTypes Are Defined by Supported Operations\n\nThere are many definitions of the concept of type in the literature. Here we assume that type is a set of values and a set of functions that one can apply to these values.\n\n—PEP 483—The Theory of Type Hints\n\n260\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1773,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 291,
      "content": "In practice, it’s more useful to consider the set of supported operations as the defin‐ ing characteristic of a type.4\n\nFor example, from the point of view of applicable operations, what are the valid types for x in the following function?\n\ndef double(x): return x * 2\n\nThe x parameter type may be numeric (int, complex, Fraction, numpy.uint32, etc.) but it may also be a sequence (str, tuple, list, array), an N-dimensional numpy.array, or any other type that implements or inherits a __mul__ method that accepts an int argument.\n\nHowever, consider this annotated double. Please ignore the missing return type for now, let’s focus on the parameter type:\n\nfrom collections import abc\n\ndef double(x: abc.Sequence): return x * 2\n\nA type checker will reject that code. If you tell Mypy that x is of type abc.Sequence, it will flag x * 2 as an error because the Sequence ABC does not implement or inherit the __mul__ method. At runtime, that code will work with concrete sequences such as str, tuple, list, array, etc., as well as numbers, because at runtime the type hints are ignored. But the type checker only cares about what is explicitly declared, and abc.Sequence has no __mul__.\n\nThat’s why the title of this section is “Types Are Defined by Supported Operations.” The Python runtime accepts any object as the x argument for both versions of the double function. The computation x * 2 may work, or it may raise TypeError if the operation is not supported by x. In contrast, Mypy will declare x * 2 as wrong while analyzing the annotated double source code, because it’s an unsupported operation for the declared type: x: abc.Sequence.\n\nIn a gradual type system, we have the interplay of two different views of types:\n\nDuck typing\n\nThe view adopted by Smalltalk—the pioneering object-oriented language—as well as Python, JavaScript, and Ruby. Objects have types, but variables (including\n\n4 Python doesn’t provide syntax to control the set of possible values for a type—except in Enum types. For exam‐ ple, using type hints you can’t define Quantity as an integer between 1 and 1000, or AirportCode as a 3-letter combination. NumPy offers uint8, int16, and other machine-oriented numeric types, but in the Python standard library we only have types with very small sets of values (NoneType, bool) or extremely large sets (float, int, str, all possible tuples, etc.).\n\nTypes Are Defined by Supported Operations\n\n|\n\n261",
      "content_length": 2420,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 292,
      "content": "parameters) are untyped. In practice, it doesn’t matter what the declared type of the object is, only what operations it actually supports. If I can invoke birdie.quack(), then birdie is a duck in this context. By definition, duck typ‐ ing is only enforced at runtime, when operations on objects are attempted. This is more flexible than nominal typing, at the cost of allowing more errors at run‐ time.5\n\nNominal typing\n\nThe view adopted by C++, Java, and C#, supported by annotated Python. Objects and variables have types. But objects only exist at runtime, and the type checker only cares about the source code where variables (including parameters) are annotated with type hints. If Duck is a subclass of Bird, you can assign a Duck instance to a parameter annotated as birdie: Bird. But in the body of the func‐ tion, the type checker considers the call birdie.quack() illegal, because birdie is nominally a Bird, and that class does not provide the .quack() method. It doesn’t matter if the actual argument at runtime is a Duck, because nominal typ‐ ing is enforced statically. The type checker doesn’t run any part of the program, it only reads the source code. This is more rigid than duck typing, with the advan‐ tage of catching some bugs earlier in a build pipeline, or even as the code is typed in an IDE.\n\nExample 8-4 is a silly example that contrasts duck typing and nominal typing, as well as static type checking and runtime behavior.6\n\nExample 8-4. birds.py\n\nclass Bird: pass\n\nclass Duck(Bird): def quack(self): print('Quack!')\n\ndef alert(birdie): birdie.quack()\n\ndef alert_duck(birdie: Duck) -> None: birdie.quack()\n\n5 Duck typing is an implicit form of structural typing, which Python ≥ 3.8 also supports with the introduction of typing.Protocol. This is covered later in this chapter—in “Static Protocols” on page 286—with more details in Chapter 13.\n\n6 Inheritance is often overused and hard to justify in examples that are realistic yet simple, so please accept this\n\nanimal example as a quick illustration of subtyping.\n\n262\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 2087,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 293,
      "content": "def alert_bird(birdie: Bird) -> None: birdie.quack()\n\nDuck is a subclass of Bird.\n\nalert has no type hints, so the type checker ignores it.\n\nalert_duck takes one argument of type Duck.\n\nalert_bird takes one argument of type Bird.\n\nType checking birds.py with Mypy, we see a problem:\n\n…/birds/ $ mypy birds.py birds.py:16: error: \"Bird\" has no attribute \"quack\" Found 1 error in 1 file (checked 1 source file)\n\nJust by analyzing the source code, Mypy sees that alert_bird is problematic: the type hint declares the birdie parameter with type Bird, but the body of the function calls birdie.quack()—and the Bird class has no such method.\n\nNow let’s try to use the birds module in daffy.py in Example 8-5.\n\nExample 8-5. daffy.py\n\nfrom birds import *\n\ndaffy = Duck() alert(daffy) alert_duck(daffy) alert_bird(daffy)\n\nValid call, because alert has no type hints.\n\nValid call, because alert_duck takes a Duck argument, and daffy is a Duck.\n\nValid call, because alert_bird takes a Bird argument, and daffy is also a Bird— the superclass of Duck.\n\nRunning Mypy on daffy.py raises the same error about the quack call in the alert_bird function defined in birds.py:\n\n…/birds/ $ mypy daffy.py birds.py:16: error: \"Bird\" has no attribute \"quack\" Found 1 error in 1 file (checked 1 source file)\n\nBut Mypy sees no problem with daffy.py itself: the three function calls are OK.\n\nNow, if you run daffy.py, this is what you get:\n\nTypes Are Defined by Supported Operations\n\n|\n\n263",
      "content_length": 1462,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 294,
      "content": "…/birds/ $ python3 daffy.py Quack! Quack! Quack!\n\nEverything works! Duck typing FTW!\n\nAt runtime, Python doesn’t care about declared types. It uses duck typing only. Mypy flagged an error in alert_bird, but calling it with daffy works fine at runtime. This may surprise many Pythonistas at first: a static type checker will sometimes find errors in programs that we know will execute.\n\nHowever, if months from now you are tasked with extending the silly bird example, you may be grateful for Mypy. Consider this woody.py module, which also uses birds, in Example 8-6.\n\nExample 8-6. woody.py\n\nfrom birds import *\n\nwoody = Bird() alert(woody) alert_duck(woody) alert_bird(woody)\n\nMypy finds two errors while checking woody.py:\n\n…/birds/ $ mypy woody.py birds.py:16: error: \"Bird\" has no attribute \"quack\" woody.py:5: error: Argument 1 to \"alert_duck\" has incompatible type \"Bird\"; expected \"Duck\" Found 2 errors in 2 files (checked 1 source file)\n\nThe first error is in birds.py: the birdie.quack() call in alert_bird, which we’ve seen before. The second error is in woody.py: woody is an instance of Bird, so the call alert_duck(woody) is invalid because that function requires a Duck. Every Duck is a Bird, but not every Bird is a Duck.\n\nAt runtime, none of the calls in woody.py succeed. The succession of failures is best illustrated in a console session with callouts in Example 8-7.\n\nExample 8-7. Runtime errors and how Mypy could have helped\n\n>>> from birds import * >>> woody = Bird() >>> alert(woody) Traceback (most recent call last): ... AttributeError: 'Bird' object has no attribute 'quack' >>>\n\n264\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1649,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 295,
      "content": ">>> alert_duck(woody) Traceback (most recent call last): ... AttributeError: 'Bird' object has no attribute 'quack' >>> >>> alert_bird(woody) Traceback (most recent call last): ... AttributeError: 'Bird' object has no attribute 'quack'\n\nMypy could not detect this error because there are no type hints in alert.\n\nMypy reported the problem: Argument 1 to \"alert_duck\" has incompatible type \"Bird\"; expected \"Duck\".\n\nMypy has been telling us since Example 8-4 that the body of the alert_bird function is wrong: \"Bird\" has no attribute \"quack\".\n\nThis little experiment shows that duck typing is easier to get started and is more flexi‐ ble, but allows unsupported operations to cause errors at runtime. Nominal typing detects errors before runtime, but sometimes can reject code that actually runs—such as the call alert_bird(daffy) in Example 8-5. Even if it sometimes works, the alert_bird function is misnamed: its body does require an object that supports the .quack() method, which Bird doesn’t have.\n\nIn this silly example, the functions are one-liners. But in real code they could be longer; they could pass the birdie argument to more functions, and the origin of the birdie argument could be many function calls away, making it hard to pinpoint the cause of a runtime error. The type checker prevents many such errors from ever hap‐ pening at runtime.\n\nThe value of type hints is questionable in the tiny examples that fit in a book. The benefits grow with the size of the codebase. That’s why companies with millions of lines of Python code—like Drop‐ box, Google, and Facebook—invested in teams and tools to sup‐ port the company-wide adoption of type hints, and have significant and increasing portions of their Python codebases type checked in their CI pipelines.\n\nIn this section we explored the relationship of types and operations in duck typing and nominal typing, starting with the simple double() function—which we left without proper type hints. Now we will tour the most important types used for anno‐ tating functions. We’ll see a good way to add type hints to double() when we reach “Static Protocols” on page 286. But before we get to that, there are more fundamental types to know.\n\nTypes Are Defined by Supported Operations\n\n|\n\n265",
      "content_length": 2254,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 296,
      "content": "Types Usable in Annotations Pretty much any Python type can be used in type hints, but there are restrictions and recommendations. In addition, the typing module introduced special constructs with semantics that are sometimes surprising.\n\nThis section covers all the major types you can use with annotations:\n\ntyping.Any\n\nSimple types and classes • typing.Optional and typing.Union\n\nGeneric collections, including tuples and mappings\n\nAbstract base classes\n\nGeneric iterables • Parameterized generics and TypeVar • typing.Protocols—the key to static duck typing • typing.Callable • typing.NoReturn—a good way to end this list\n\nWe’ll cover each of these in turn, starting with a type that is strange, apparently use‐ less, but crucially important.\n\nThe Any Type The keystone of any gradual type system is the Any type, also known as the dynamic type. When a type checker sees an untyped function like this:\n\ndef double(x): return x * 2\n\nit assumes this:\n\ndef double(x: Any) -> Any: return x * 2\n\nThat means the x argument and the return value can be of any type, including differ‐ ent types. Any is assumed to support every possible operation.\n\nContrast Any with object. Consider this signature:\n\ndef double(x: object) -> object:\n\nThis function also accepts arguments of every type, because every type is a subtype-of object.\n\n266\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1368,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 297,
      "content": "However, a type checker will reject this function:\n\ndef double(x: object) -> object: return x * 2\n\nThe problem is that object does not support the __mul__ operation. This is what Mypy reports:\n\n…/birds/ $ mypy double_object.py double_object.py:2: error: Unsupported operand types for * (\"object\" and \"int\") Found 1 error in 1 file (checked 1 source file)\n\nMore general types have narrower interfaces, i.e., they support fewer operations. The object class implements fewer operations than abc.Sequence, which implements fewer operations than abc.MutableSequence, which implements fewer operations than list.\n\nBut Any is a magic type that sits at the top and the bottom of the type hierarchy. It’s simultaneously the most general type—so that an argument n: Any accepts values of every type—and the most specialized type, supporting every possible operation. At least, that’s how the type checker understands Any.\n\nOf course, no type can support every possible operation, so using Any prevents the type checker from fulfilling its core mission: detecting potentially illegal operations before your program crashes with a runtime exception.\n\nSubtype-of versus consistent-with\n\nTraditional object-oriented nominal type systems rely on the is subtype-of relation‐ ship. Given a class T1 and a subclass T2, then T2 is subtype-of T1.\n\nConsider this code:\n\nclass T1: ...\n\nclass T2(T1): ...\n\ndef f1(p: T1) -> None: ...\n\no2 = T2()\n\nf1(o2) # OK\n\nTypes Usable in Annotations\n\n|\n\n267",
      "content_length": 1470,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 298,
      "content": "The call f1(o2) is an application of the Liskov Substitution Principle—LSP. Barbara Liskov7 actually defined is subtype-of in terms of supported operations: if an object of type T2 substitutes an object of type T1 and the program still behaves correctly, then T2 is subtype-of T1.\n\nContinuing from the previous code, this shows a violation of the LSP:\n\ndef f2(p: T2) -> None: ...\n\no1 = T1()\n\nf2(o1) # type error\n\nFrom the point of view of supported operations, this makes perfect sense: as a sub‐ class, T2 inherits and must support all operations that T1 does. So an instance of T2 can be used anywhere an instance of T1 is expected. But the reverse is not necessarily true: T2 may implement additional methods, so an instance of T1 may not be used everywhere an instance of T2 is expected. This focus on supported operations is reflected in the name behavioral subtyping, also used to refer to the LSP.\n\nIn a gradual type system, there is another relationship: consistent-with, which applies wherever subtype-of applies, with special provisions for type Any.\n\nThe rules for consistent-with are:\n\n1. Given T1 and a subtype T2, then T2 is consistent-with T1 (Liskov substitution). 2. Every type is consistent-with Any: you can pass objects of every type to an argu‐ ment declared of type Any.\n\n3. Any is consistent-with every type: you can always pass an object of type Any where an argument of another type is expected.\n\nConsidering the previous definitions of the objects o1 and o2, here are examples of valid code, illustrating rules #2 and #3:\n\ndef f3(p: Any) -> None: ...\n\no0 = object() o1 = T1() o2 = T2()\n\nf3(o0) # f3(o1) # all OK: rule #2 f3(o2) #\n\n7 MIT Professor, programming language designer, and Turing Award recipient. Wikipedia: Barbara Liskov.\n\n268\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1803,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 299,
      "content": "def f4(): # implicit return type: `Any` ...\n\no4 = f4() # inferred type: `Any`\n\nf1(o4) # f2(o4) # all OK: rule #3 f3(o4) #\n\nEvery gradual type system needs a wildcard type like Any.\n\nThe verb “to infer” is a fancy synomym for “to guess,” used in the context of type analysis. Modern type checkers in Python and other languages don’t require type annotations everywhere because they can infer the type of many expressions. For example, if I write x = len(s) * 10, the type checker doesn’t need an explicit local decla‐ ration to know that x is an int, as long as it can find type hints for the len built-in.\n\nNow we can explore the rest of the types used in annotations.\n\nSimple Types and Classes Simple types like int, float, str, and bytes may be used directly in type hints. Con‐ crete classes from the standard library, external packages, or user defined—French Deck, Vector2d, and Duck—may also be used in type hints.\n\nAbstract base classes are also useful in type hints. We’ll get back to them as we study collection types, and in “Abstract Base Classes” on page 278.\n\nAmong classes, consistent-with is defined like subtype-of: a subclass is consistent-with all its superclasses.\n\nHowever, “practicality beats purity,” so there is an important exception, which I dis‐ cuss in the following tip.\n\nint Is Consistent-With complex\n\nThere is no nominal subtype relationship between the built-in types int, float, and complex: they are direct subclasses of object. But PEP 484 declares that int is consistent-with float, and float is consistent-with complex. It makes sense in practice: int imple‐ ments all operations that float does, and int implements addi‐ tional ones as well—bitwise operations like &, |, <<, etc. The end result is: int is consistent-with complex. For i = 3, i.real is 3, and i.imag is 0.\n\nTypes Usable in Annotations\n\n|\n\n269",
      "content_length": 1846,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 300,
      "content": "Optional and Union Types We saw the Optional special type in “Using None as a Default” on page 260. It solves the problem of having None as a default, as in this example from that section:\n\nfrom typing import Optional\n\ndef show_count(count: int, singular: str, plural: Optional[str] = None) -> str:\n\nThe construct Optional[str] is actually a shortcut for Union[str, None], which means the type of plural may be str or None.\n\nBetter Syntax for Optional and Union in Python 3.10\n\nWe can write str | bytes instead of Union[str, bytes] since Python 3.10. It’s less typing, and there’s no need to import Optional or Union from typing. Contrast the old and new syntax for the type hint of the plural parameter of show_count:\n\nplural: Optional[str] = None # before plural: str | None = None # after\n\nThe | operator also works with isinstance and issubclass to build the second argument: isinstance(x, int | str). For more, see PEP 604—Complementary syntax for Union[].\n\nThe ord built-in function’s signature is a simple example of Union—it accepts str or bytes, and returns an int:8\n\ndef ord(c: Union[str, bytes]) -> int: ...\n\nHere is an example of a function that takes a str, but may return a str or a float:\n\nfrom typing import Union\n\ndef parse_token(token: str) -> Union[str, float]: try: return float(token) except ValueError: return token\n\nIf possible, avoid creating functions that return Union types, as they put an extra bur‐ den on the user—forcing them to check the type of the returned value at runtime to know what to do with it. But the parse_token in the preceding code is a reasonable use case in the context of a simple expression evaluator.\n\n8 To be more precise, ord only accepts str or bytes with len(s) == 1. But the type system currently can’t\n\nexpress this constraint.\n\n270\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1828,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 301,
      "content": "In “Dual-Mode str and bytes APIs” on page 155, we saw functions that accept either str or bytes arguments, but return str if the argument was str or bytes if the arguments was bytes. In those cases, the return type is determined by the input type, so Union is not an accurate solution. To properly annotate such functions, we need a type variable—presented in “Parameterized Generics and TypeVar” on page 282—or overloading, which we’ll see in “Overloa‐ ded Signatures” on page 520.\n\nUnion[] requires at least two types. Nested Union types have the same effect as a flat‐ tened Union. So this type hint:\n\nUnion[A, B, Union[C, D, E]]\n\nis the same as:\n\nUnion[A, B, C, D, E]\n\nUnion is more useful with types that are not consistent among themselves. For exam‐ ple: Union[int, float] is redundant because int is consistent-with float. If you just use float to annotate the parameter, it will accept int values as well.\n\nGeneric Collections Most Python collections are heterogeneous. For example, you can put any mixture of different types in a list. However, in practice that’s not very useful: if you put objects in a collection, you are likely to want to operate on them later, and usually this means they must share at least one common method.9\n\nGeneric types can be declared with type parameters to specify the type of the items they can handle.\n\nFor example, a list can be parameterized to constrain the type of the elements in it, as you can see in Example 8-8.\n\nExample 8-8. tokenize with type hints for Python ≥ 3.9\n\ndef tokenize(text: str) -> list[str]: return text.upper().split()\n\nIn Python ≥ 3.9, it means that tokenize returns a list where every item is of type str.\n\n9 In ABC—the language that most influenced the initial design of Python—each list was constrained to accept\n\nvalues of a single type: the type of the first item you put into it.\n\nTypes Usable in Annotations\n\n|\n\n271",
      "content_length": 1891,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 302,
      "content": "The annotations stuff: list and stuff: list[Any] mean the same thing: stuff is a list of objects of any type.\n\nIf you are using Python 3.8 or earlier, the concept is the same, but you need more code to make it work—as explained in the optional box “Legacy Support and Deprecated Collection Types” on page 272.\n\nPEP 585—Type Hinting Generics In Standard Collections lists collections from the standard library accepting generic type hints. The following list shows only those col‐ lections that use the simplest form of generic type hint, container[item]:\n\nlist collections.deque abc.Sequence abc.MutableSequence set abc.Container abc.Set abc.MutableSet frozenset abc.Collection\n\nThe tuple and mapping types support more complex type hints, as we’ll see in their respective sections.\n\nAs of Python 3.10, there is no good way to annotate array.array, taking into account the typecode constructor argument, which determines whether integers or floats are stored in the array. An even harder problem is how to type check integer ranges to prevent OverflowError at runtime when adding elements to arrays. For example, an array with typecode='B' can only hold int values from 0 to 255. Cur‐ rently, Python’s static type system is not up to this challenge.\n\nLegacy Support and Deprecated Collection Types\n\n(You may skip this box if you only use Python 3.9 or later.)\n\nFor Python 3.7 and 3.8, you need a __future__ import to make the [] notation work with built-in collections such as list, as shown in Example 8-9.\n\nExample 8-9. tokenize with type hints for Python ≥ 3.7\n\nfrom __future__ import annotations\n\ndef tokenize(text: str) -> list[str]: return text.upper().split()\n\nThe __future__ import does not work with Python 3.6 or earlier. Example 8-10 shows how to annotate tokenize in a way that works with Python ≥ 3.5.\n\nExample 8-10. tokenize with type hints for Python ≥ 3.5\n\nfrom typing import List\n\n272\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1940,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 303,
      "content": "def tokenize(text: str) -> List[str]: return text.upper().split()\n\nTo provide the initial support for generic type hints, the authors of PEP 484 created dozens of generic types in the typing module. Table 8-1 shows some of them. For the full list, visit the typing documentation.\n\nTable 8-1. Some collection types and their type hint equivalents\n\nCollection list\n\nType hint equivalent typing.List\n\nset\n\ntyping.Set\n\nfrozenset\n\ntyping.FrozenSet\n\ncollections.deque\n\ntyping.Deque\n\ncollections.abc.MutableSequence typing.MutableSequence\n\ncollections.abc.Sequence\n\ntyping.Sequence\n\ncollections.abc.Set\n\ntyping.AbstractSet\n\ncollections.abc.MutableSet\n\ntyping.MutableSet\n\nPEP 585—Type Hinting Generics In Standard Collections started a multiyear process to improve the usability of generic type hints. We can summarize that process in four steps:\n\n1. Introduce from __future__ import annotations in Python 3.7 to enable the use of standard library classes as generics with list[str] notation.\n\n2. Make that behavior the default in Python 3.9: list[str] now works without the future import.\n\n3. Deprecate all the redundant generic types from the typing module.10 Depreca‐ tion warnings will not be issued by the Python interpreter because type checkers should flag the deprecated types when the checked program targets Python 3.9 or newer.\n\n4. Remove those redundant generic types in the first version of Python released five years after Python 3.9. At the current cadence, that could be Python 3.14, a.k.a Python Pi.\n\nNow let’s see how to annotate generic tuples.\n\n10 One of my contributions to the typing module documentation was to add dozens of deprecation warnings as I reorganized the entries below “Module Contents” into subsections, under the supervision of Guido van Rossum.\n\nTypes Usable in Annotations\n\n|\n\n273",
      "content_length": 1811,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 304,
      "content": "Tuple Types There are three ways to annotate tuple types:\n\nTuples as records\n\nTuples as records with named fields\n\nTuples as immutable sequences\n\nTuples as records\n\nIf you’re using a tuple as a record, use the tuple built-in and declare the types of the fields within [].\n\nFor example, the type hint would be tuple[str, float, str] to accept a tuple with city name, population, and country: ('Shanghai', 24.28, 'China').\n\nConsider a function that takes a pair of geographic coordinates and returns a Geo‐ hash, used like this:\n\n>>> shanghai = 31.2304, 121.4737 >>> geohash(shanghai) 'wtw3sjq6q'\n\nExample 8-11 shows how geohash is defined, using the geolib package from PyPI.\n\nExample 8-11. coordinates.py with the geohash function\n\nfrom geolib import geohash as gh # type: ignore\n\nPRECISION = 9\n\ndef geohash(lat_lon: tuple[float, float]) -> str: return gh.encode(*lat_lon, PRECISION)\n\nThis comment stops Mypy from reporting that the geolib package doesn’t have type hints.\n\nlat_lon parameter annotated as a tuple with two float fields.\n\nFor Python < 3.9, import and use typing.Tuple in type hints. It is deprecated but will remain in the standard library at least until 2024.\n\n274\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1219,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 305,
      "content": "Tuples as records with named fields\n\nTo annotate a tuple with many fields, or specific types of tuple your code uses in many places, I highly recommend using typing.NamedTuple, as seen in Chapter 5. Example 8-12 shows a variation of Example 8-11 with NamedTuple.\n\nExample 8-12. coordinates_named.py with the NamedTuple Coordinates and the geo hash function\n\nfrom typing import NamedTuple\n\nfrom geolib import geohash as gh # type: ignore\n\nPRECISION = 9\n\nclass Coordinate(NamedTuple): lat: float lon: float\n\ndef geohash(lat_lon: Coordinate) -> str: return gh.encode(*lat_lon, PRECISION)\n\nAs explained in “Overview of Data Class Builders” on page 164, typing.NamedTuple is a factory for tuple subclasses, so Coordinate is consistent-with tuple[float, float] but the reverse is not true—after all, Coordinate has extra methods added by NamedTuple, like ._asdict(), and could also have user-defined methods.\n\nIn practice, this means that it is type safe to pass a Coordinate instance to the dis play function defined in the following:\n\ndef display(lat_lon: tuple[float, float]) -> str: lat, lon = lat_lon ns = 'N' if lat >= 0 else 'S' ew = 'E' if lon >= 0 else 'W' return f'{abs(lat):0.1f}°{ns}, {abs(lon):0.1f}°{ew}'\n\nTuples as immutable sequences\n\nTo annotate tuples of unspecified length that are used as immutable lists, you must specify a single type, followed by a comma and ... (that’s Python’s ellipsis token, made of three periods, not Unicode U+2026—HORIZONTAL ELLIPSIS).\n\nFor example, tuple[int, ...] is a tuple with int items.\n\nThe ellipsis indicates that any number of elements >= 1 is acceptable. There is no way to specify fields of different types for tuples of arbitrary length.\n\nThe annotations stuff: tuple[Any, ...] and stuff: tuple mean the same thing: stuff is a tuple of unspecified length with objects of any type.\n\nTypes Usable in Annotations\n\n|\n\n275",
      "content_length": 1870,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 306,
      "content": "Here is a columnize function that transforms a sequence into a table of rows and cells in the form of a list of tuples with unspecified lengths. This is useful to display items in columns, like this:\n\n>>> animals = 'drake fawn heron ibex koala lynx tahr xerus yak zapus'.split() >>> table = columnize(animals) >>> table [('drake', 'koala', 'yak'), ('fawn', 'lynx', 'zapus'), ('heron', 'tahr'), ('ibex', 'xerus')] >>> for row in table: ... print(''.join(f'{word:10}' for word in row)) ... drake koala yak fawn lynx zapus heron tahr ibex xerus\n\nExample 8-13 shows the implementation of columnize. Note the return type:\n\nlist[tuple[str, ...]]\n\nExample 8-13. columnize.py returns a list of tuples of strings\n\nfrom collections.abc import Sequence\n\ndef columnize( sequence: Sequence[str], num_columns: int = 0 ) -> list[tuple[str, ...]]: if num_columns == 0: num_columns = round(len(sequence) ** 0.5) num_rows, reminder = divmod(len(sequence), num_columns) num_rows += bool(reminder) return [tuple(sequence[i::num_rows]) for i in range(num_rows)]\n\nGeneric Mappings Generic mapping types are annotated as MappingType[KeyType, ValueType]. The built-in dict and the mapping types in collections and collections.abc accept that notation in Python ≥ 3.9. For earlier versions, you must use typing.Dict and other mapping types from the typing module, as described in “Legacy Support and Deprecated Collection Types” on page 272.\n\nExample 8-14 shows a practical use of a function returning an inverted index to search Unicode characters by name—a variation of Example 4-21 more suitable for server-side code that we’ll study in Chapter 21.\n\nGiven starting and ending Unicode character codes, name_index returns a dict[str, set[str]], which is an inverted index mapping each word to a set of characters that have that word in their names. For example, after indexing ASCII characters from 32\n\n276\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1921,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 307,
      "content": "to 64, here are the sets of characters mapped to the words 'SIGN' and 'DIGIT', and how to find the character named 'DIGIT EIGHT':\n\n>>> index = name_index(32, 65) >>> index['SIGN'] {'$', '>', '=', '+', '<', '%', '#'} >>> index['DIGIT'] {'8', '5', '6', '2', '3', '0', '1', '4', '7', '9'} >>> index['DIGIT'] & index['EIGHT'] {'8'}\n\nExample 8-14 shows the source code for charindex.py with the name_index function. Besides a dict[] type hint, this example has three features appearing for the first time in the book.\n\nExample 8-14. charindex.py\n\nimport sys import re import unicodedata from collections.abc import Iterator\n\nRE_WORD = re.compile(r'\\w+') STOP_CODE = sys.maxunicode + 1\n\ndef tokenize(text: str) -> Iterator[str]: \"\"\"return iterable of uppercased words\"\"\" for match in RE_WORD.finditer(text): yield match.group().upper()\n\ndef name_index(start: int = 32, end: int = STOP_CODE) -> dict[str, set[str]]: index: dict[str, set[str]] = {} for char in (chr(i) for i in range(start, end)): if name := unicodedata.name(char, ''): for word in tokenize(name): index.setdefault(word, set()).add(char) return index\n\ntokenize is a generator function. Chapter 17 is about generators.\n\nThe local variable index is annotated. Without the hint, Mypy says: Need type annotation for 'index' (hint: \"index: dict[<type>, <type>] = ...\").\n\nTypes Usable in Annotations\n\n|\n\n277",
      "content_length": 1360,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 308,
      "content": "I used the walrus operator := in the if condition. It assigns the result of the uni codedata.name() call to name, and the whole expression evaluates to that result. When the result is '', that’s falsy, and the index is not updated.11\n\nWhen using a dict as a record, it is common to have all keys of the str type, with values of different types depending on the keys. That is covered in “TypedDict” on page 526.\n\nAbstract Base Classes\n\nBe conservative in what you send, be liberal in what you accept.\n\n—Postel’s law, a.k.a. the Robustness Principle\n\nTable 8-1 lists several abstract classes from collections.abc. Ideally, a function should accept arguments of those abstract types—or their typing equivalents before Python 3.9—and not concrete types. This gives more flexibility to the caller.\n\nConsider this function signature:\n\nfrom collections.abc import Mapping\n\ndef name2hex(name: str, color_map: Mapping[str, int]) -> str:\n\nUsing abc.Mapping allows the caller to provide an instance of dict, defaultdict, ChainMap, a UserDict subclass, or any other type that is a subtype-of Mapping.\n\nIn contrast, consider this signature:\n\ndef name2hex(name: str, color_map: dict[str, int]) -> str:\n\nNow color_map must be a dict or one of its subtypes, such as defaultDict or OrderedDict. In particular, a subclass of collections.UserDict would not pass the type check for color_map, despite being the recommended way to create user-defined mappings, as we saw in “Subclassing UserDict Instead of dict” on page 97. Mypy would reject a UserDict or an instance of a class derived from it, because UserDict is not a subclass of dict; they are siblings. Both are subclasses of abc.MutableMapping.12\n\n11 I use := when it makes sense in a few examples, but I don’t cover it in the book. Please see PEP 572—Assign‐\n\nment Expressions for all the gory details.\n\n12 Actually, dict is a virtual subclass of abc.MutableMapping. The concept of a virtual subclass is explained in\n\nChapter 13. For now, know that issubclass(dict, abc.MutableMapping) is True, despite the fact that dict is implemented in C and does not inherit anything from abc.MutableMapping, but only from object.\n\n278\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 2200,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 309,
      "content": "Therefore, in general it’s better to use abc.Mapping or abc.MutableMapping in parameter type hints, instead of dict (or typing.Dict in legacy code). If the name2hex function doesn’t need to mutate the given color_map, the most accurate type hint for color_map is abc.Mapping. That way, the caller doesn’t need to provide an object that implements methods like setdefault, pop, and update, which are part of the MutableMapping interface, but not of Mapping. This has to do with the second part of Postel’s law: “Be liberal in what you accept.”\n\nPostel’s law also tells us to be conservative in what we send. The return value of a function is always a concrete object, so the return type hint should be a concrete type, as in the example from “Generic Collections” on page 271—which uses list[str]:\n\ndef tokenize(text: str) -> list[str]: return text.upper().split()\n\nUnder the entry of typing.List, the Python documentation says:\n\nGeneric version of list. Useful for annotating return types. To annotate arguments it is preferred to use an abstract collection type such as Sequence or Iterable.\n\nA similar comment appears in the entries for typing.Dict and typing.Set.\n\nRemember that most ABCs from collections.abc and other concrete classes from collections, as well as built-in collections, support generic type hint notation like collections.deque[str] starting with Python 3.9. The corresponding typing col‐ lections are only needed to support code written in Python 3.8 or earlier. The full list of classes that became generic appears in the “Implementation” section of PEP 585— Type Hinting Generics In Standard Collections.\n\nTo wrap up our discussion of ABCs in type hints, we need to talk about the numbers ABCs.\n\nThe fall of the numeric tower\n\nThe numbers package defines the so-called numeric tower described in PEP 3141—A Type Hierarchy for Numbers. The tower is linear hierarchy of ABCs, with Number at the top:\n\nNumber • Complex • Real • Rational • Integral\n\nTypes Usable in Annotations\n\n|\n\n279",
      "content_length": 2005,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 310,
      "content": "Those ABCs work perfectly well for runtime type checking, but they are not sup‐ ported for static type checking. The “Numeric Tower” section of PEP 484 rejects the numbers ABCs and dictates that the built-in types complex, float, and int should be treated as special cases, as explained in “int Is Consistent-With complex” on page 269.\n\nWe’ll come back to this issue in “The numbers ABCs and Numeric Protocols” on page 478, in Chapter 13, which is devoted to contrasting protocols and ABCs.\n\nIn practice, if you want to annotate numeric arguments for static type checking, you have a few options:\n\n1. Use one of the concrete types int, float, or complex—as recommended by PEP 488.\n\n2. Declare a union type like Union[float, Decimal, Fraction]. 3. If you want to avoid hardcoding concrete types, use numeric protocols like Sup portsFloat, covered in “Runtime Checkable Static Protocols” on page 468.\n\nThe upcoming section “Static Protocols” on page 286 is a prerequisite for understand‐ ing the numeric protocols.\n\nMeanwhile, let’s get to one of the most useful ABCs for type hints: Iterable.\n\nIterable The typing.List documentation I just quoted recommends Sequence and Iterable for function parameter type hints.\n\nOne example of the Iterable argument appears in the math.fsum function from the standard library:\n\ndef fsum(__seq: Iterable[float]) -> float:\n\nStub Files and the Typeshed Project\n\nAs of Python 3.10, the standard library has no annotations, but Mypy, PyCharm, etc. can find the necessary type hints in the Typeshed project, in the form of stub files: special source files with a .pyi extension that have annotated function and method signa‐ tures, without the implementation—much like header files in C. The signature for math.fsum is in /stdlib/2and3/math.pyi. The lead‐ ing underscores in __seq are a PEP 484 convention for positional- only parameters, explained in “Annotating Positional Only and Variadic Parameters” on page 295.\n\n280\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1991,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 311,
      "content": "Example 8-15 is another example using an Iterable parameter that produces items that are tuple[str, str]. Here is how the function is used:\n\n>>> l33t = [('a', '4'), ('e', '3'), ('i', '1'), ('o', '0')] >>> text = 'mad skilled noob powned leet' >>> from replacer import zip_replace >>> zip_replace(text, l33t) 'm4d sk1ll3d n00b p0wn3d l33t'\n\nExample 8-15 shows how it’s implemented.\n\nExample 8-15. replacer.py\n\nfrom collections.abc import Iterable\n\nFromTo = tuple[str, str]\n\ndef zip_replace(text: str, changes: Iterable[FromTo]) -> str: for from_, to in changes: text = text.replace(from_, to) return text\n\nFromTo is a type alias: I assigned tuple[str, str] to FromTo, to make the signa‐ ture of zip_replace more readable.\n\nchanges needs to be an Iterable[FromTo]; that’s the same as Itera ble[tuple[str, str]], but shorter and easier to read.\n\nExplicit TypeAlias in Python 3.10\n\nPEP 613—Explicit Type Aliases introduced a special type, TypeA lias, to make the assignments that create type aliases more visible and easier to type check. Starting with Python 3.10, this is the pre‐ ferred way to create type aliases:\n\nfrom typing import TypeAlias\n\nFromTo: TypeAlias = tuple[str, str]\n\nabc.Iterable versus abc.Sequence\n\nBoth math.fsum and replacer.zip_replace must iterate over the entire Iterable arguments to return a result. Given an endless iterable such as the itertools.cycle generator as input, these functions would consume all memory and crash the Python process. Despite this potential danger, it is fairly common in modern Python to offer functions that accept an Iterable input even if they must process it completely to return a result. That gives the caller the option of providing input data as a generator\n\nTypes Usable in Annotations\n\n|\n\n281",
      "content_length": 1754,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 312,
      "content": "instead of a prebuilt sequence, potentially saving a lot of memory if the number of input items is large.\n\nOn the other hand, the columnize function from Example 8-13 needs a Sequence parameter, and not an Iterable, because it must get the len() of the input to com‐ pute the number of rows up front.\n\nLike Sequence, Iterable is best used as a parameter type. It’s too vague as a return type. A function should be more precise about the concrete type it returns.\n\nClosely related to Iterable is the Iterator type, used as a return type in Example 8-14. We’ll get back to it in Chapter 17, which is about generators and classic iterators.\n\nParameterized Generics and TypeVar A parameterized generic is a generic type, written as list[T], where T is a type vari‐ able that will be bound to a specific type with each usage. This allows a parameter type to be reflected on the result type.\n\nExample 8-16 defines sample, a function that takes two arguments: a Sequence of ele‐ ments of type T, and an int. It returns a list of elements of the same type T, picked at random from the first argument.\n\nExample 8-16 shows the implementation.\n\nExample 8-16. sample.py\n\nfrom collections.abc import Sequence from random import shuffle from typing import TypeVar\n\nT = TypeVar('T')\n\ndef sample(population: Sequence[T], size: int) -> list[T]: if size < 1: raise ValueError('size must be >= 1') result = list(population) shuffle(result) return result[:size]\n\nHere are two examples of why I used a type variable in sample:\n\nIf called with a tuple of type tuple[int, ...]—which is consistent-with Sequence[int]—then the type parameter is int, so the return type is list[int].\n\n282\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1701,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 313,
      "content": "If called with a str—which is consistent-with Sequence[str]—then the type parameter is str, so the return type is list[str].\n\nWhy Is TypeVar Needed?\n\nThe authors of PEP 484 wanted to introduce type hints by adding the typing module and not changing anything else in the language. With clever metaprogramming they could make the [] operator work on classes like Sequence[T]. But the name of the T variable inside the brackets must be defined somewhere—otherwise the Python interpreter would need deep changes to support generic type notation as special use of []. That’s why the typing.TypeVar constructor is needed: to introduce the variable name in the cur‐ rent namespace. Languages such as Java, C#, and TypeScript don’t require the name of type variable to be declared beforehand, so they have no equivalent of Python’s TypeVar class.\n\nAnother example is the statistics.mode function from the standard library, which returns the most common data point from a series.\n\nHere is one usage example from the documentation:\n\n>>> mode([1, 1, 2, 3, 3, 3, 3, 4]) 3\n\nWithout using a TypeVar, mode could have the signature shown in Example 8-17.\n\nExample 8-17. mode_float.py: mode that operates on float and subtypes13\n\nfrom collections import Counter from collections.abc import Iterable\n\ndef mode(data: Iterable[float]) -> float: pairs = Counter(data).most_common(1) if len(pairs) == 0: raise ValueError('no mode for empty data') return pairs[0][0]\n\nMany uses of mode involve int or float values, but Python has other numerical types, and it is desirable that the return type follows the element type of the given Iterable. We can improve that signature using TypeVar. Let’s start with a simple, but wrong, parameterized signature:\n\n13 The implementation here is simpler than the one in the Python standard library statistics module.\n\nTypes Usable in Annotations\n\n|\n\n283",
      "content_length": 1865,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 314,
      "content": "from collections.abc import Iterable from typing import TypeVar\n\nT = TypeVar('T')\n\ndef mode(data: Iterable[T]) -> T:\n\nWhen it first appears in the signature, the type parameter T can be any type. The sec‐ ond time it appears, it will mean the same type as the first.\n\nTherefore, every iterable is consistent-with Iterable[T], including iterables of unhashable types that collections.Counter cannot handle. We need to restrict the possible types assigned to T. We’ll see two ways of doing that in the next two sections.\n\nRestricted TypeVar\n\nTypeVar accepts extra positional arguments to restrict the type parameter. We can improve the signature of mode to accept specific number types, like this:\n\nfrom collections.abc import Iterable from decimal import Decimal from fractions import Fraction from typing import TypeVar\n\nNumberT = TypeVar('NumberT', float, Decimal, Fraction)\n\ndef mode(data: Iterable[NumberT]) -> NumberT:\n\nThat’s better than before, and it was the signature for mode in the statistics.pyi stub file on typeshed on May 25, 2020.\n\nHowever, the statistics.mode documentation includes this example:\n\n>>> mode([\"red\", \"blue\", \"blue\", \"red\", \"green\", \"red\", \"red\"]) 'red'\n\nIn a hurry, we could just add str to the NumberT definition:\n\nNumberT = TypeVar('NumberT', float, Decimal, Fraction, str)\n\nThat certainly works, but NumberT is badly misnamed if it accepts str. More impor‐ tantly, we can’t keep listing types forever, as we realize mode can deal with them. We can do better with another feature of TypeVar, introduced next.\n\nBounded TypeVar\n\nLooking at the body of mode in Example 8-17, we see that the Counter class is used for ranking. Counter is based on dict, therefore the element type of the data iterable must be hashable.\n\nAt first, this signature may seem to work:\n\n284\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1835,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 315,
      "content": "from collections.abc import Iterable, Hashable\n\ndef mode(data: Iterable[Hashable]) -> Hashable:\n\nNow the problem is that the type of the returned item is Hashable: an ABC that implements only the __hash__ method. So the type checker will not let us do any‐ thing with the return value except call hash() on it. Not very useful.\n\nThe solution is another optional parameter of TypeVar: the bound keyword parame‐ ter. It sets an upper boundary for the acceptable types. In Example 8-18, we have bound=Hashable, which means the type parameter may be Hashable or any subtype- of it.14\n\nExample 8-18. mode_hashable.py: same as Example 8-17, with a more flexible signature\n\nfrom collections import Counter from collections.abc import Iterable, Hashable from typing import TypeVar\n\nHashableT = TypeVar('HashableT', bound=Hashable)\n\ndef mode(data: Iterable[HashableT]) -> HashableT: pairs = Counter(data).most_common(1) if len(pairs) == 0: raise ValueError('no mode for empty data') return pairs[0][0]\n\nTo summarize:\n\nA restricted type variable will be set to one of the types named in the TypeVar declaration.\n\nA bounded type variable will be set to the inferred type of the expression—as long as the inferred type is consistent-with the boundary declared in the bound= keyword argument of TypeVar.\n\nIt is unfortunate that the keyword argument to declare a bounded TypeVar is named bound=, because the verb “to bind” is commonly used to mean setting the value of a variable, which in the reference semantics of Python is best described as binding a name to the value. It would have been less confusing if the keyword argument was named boundary=.\n\n14 I contributed this solution to typeshed, and that’s how mode is annotated on statistics.pyi as of May 26, 2020.\n\nTypes Usable in Annotations\n\n|\n\n285",
      "content_length": 1791,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 316,
      "content": "The typing.TypeVar constructor has other optional parameters—covariant and con travariant—that we’ll cover in Chapter 15, “Variance” on page 544.\n\nLet’s conclude this introduction to TypeVar with AnyStr.\n\nThe AnyStr predefined type variable\n\nThe typing module includes a predefined TypeVar named AnyStr. It’s defined like this:\n\nAnyStr = TypeVar('AnyStr', bytes, str)\n\nAnyStr is used in many functions that accept either bytes or str, and return values of the given type.\n\nNow, on to typing.Protocol, a new feature of Python 3.8 that can support more Pythonic use of type hints.\n\nStatic Protocols\n\nIn object-oriented programming, the concept of a “protocol” as an informal interface is as old as Smalltalk, and is an essential part of Python from the beginning. However, in the context of type hints, a protocol is a typing.Protocol subclass defining an interface that a type checker can verify. Both kinds of protocols are covered in Chapter 13. This is just a brief introduction in the context of func‐ tion annotations.\n\nThe Protocol type, as presented in PEP 544—Protocols: Structural subtyping (static duck typing), is similar to interfaces in Go: a protocol type is defined by specifying one or more methods, and the type checker verifies that those methods are imple‐ mented where that protocol type is required.\n\nIn Python, a protocol definition is written as a typing.Protocol subclass. However, classes that implement a protocol don’t need to inherit, register, or declare any rela‐ tionship with the class that defines the protocol. It’s up to the type checker to find the available protocol types and enforce their usage.\n\nHere is a problem that can be solved with the help of Protocol and TypeVar. Suppose you want to create a function top(it, n) that returns the largest n elements of the iterable it:\n\n>>> top([4, 1, 5, 2, 6, 7, 3], 3) [7, 6, 5] >>> l = 'mango pear apple kiwi banana'.split() >>> top(l, 3) ['pear', 'mango', 'kiwi']\n\n286\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1991,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 317,
      "content": ">>> >>> l2 = [(len(s), s) for s in l] >>> l2 [(5, 'mango'), (4, 'pear'), (5, 'apple'), (4, 'kiwi'), (6, 'banana')] >>> top(l2, 3) [(6, 'banana'), (5, 'mango'), (5, 'apple')]\n\nA parameterized generic top would look like what’s shown in Example 8-19.\n\nExample 8-19. top function with an undefined T type parameter\n\ndef top(series: Iterable[T], length: int) -> list[T]: ordered = sorted(series, reverse=True) return ordered[:length]\n\nThe problem is how to constrain T? It cannot be Any or object, because the series must work with sorted. The sorted built-in actually accepts Iterable[Any], but that’s because the optional parameter key takes a function that computes an arbitrary sort key from each element. What happens if you give sorted a list of plain objects but don’t provide a key argument? Let’s try that:\n\n>>> l = [object() for _ in range(4)] >>> l [<object object at 0x10fc2fca0>, <object object at 0x10fc2fbb0>, <object object at 0x10fc2fbc0>, <object object at 0x10fc2fbd0>] >>> sorted(l) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: '<' not supported between instances of 'object' and 'object'\n\nThe error message shows that sorted uses the < operator on the elements of the itera‐ ble. Is this all it takes? Let’s do another quick experiment:15\n\n>>> class Spam: ... def __init__(self, n): self.n = n ... def __lt__(self, other): return self.n < other.n ... def __repr__(self): return f'Spam({self.n})' ... >>> l = [Spam(n) for n in range(5, 0, -1)] >>> l [Spam(5), Spam(4), Spam(3), Spam(2), Spam(1)] >>> sorted(l) [Spam(1), Spam(2), Spam(3), Spam(4), Spam(5)]\n\nThat confirms it: I can sort a list of Spam because Spam implements __lt__—the spe‐ cial method that supports the < operator.\n\n15 How wonderful it is to open an interactive console and rely on duck typing to explore language features like I\n\njust did. I badly miss this kind of exploration when I use languages that don’t support it.\n\nTypes Usable in Annotations\n\n|\n\n287",
      "content_length": 1980,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 318,
      "content": "So the T type parameter in Example 8-19 should be limited to types that implement __lt__. In Example 8-18 we needed a type parameter that implemented __hash__, so we were able to use typing.Hashable as the upper bound for the type parameter. But now there is no suitable type in typing or abc to use, so we need to create it.\n\nExample 8-20 shows the new SupportsLessThan type, a Protocol.\n\nExample 8-20. comparable.py: definition of a SupportsLessThan Protocol type\n\nfrom typing import Protocol, Any\n\nclass SupportsLessThan(Protocol): def __lt__(self, other: Any) -> bool: ...\n\nA protocol is a subclass of typing.Protocol.\n\nThe body of the protocol has one or more method definitions, with ... in their bodies.\n\nA type T is consistent-with a protocol P if T implements all the methods defined in P, with matching type signatures.\n\nGiven SupportsLessThan, we can now define this working version of top in Example 8-21.\n\nExample 8-21. top.py: definition of the top function using a TypeVar with bound=Sup portsLessThan\n\nfrom collections.abc import Iterable from typing import TypeVar\n\nfrom comparable import SupportsLessThan\n\nLT = TypeVar('LT', bound=SupportsLessThan)\n\ndef top(series: Iterable[LT], length: int) -> list[LT]: ordered = sorted(series, reverse=True) return ordered[:length]\n\nLet’s test-drive top. Example 8-22 shows part of a test suite for use with pytest. It tries calling top first with a generator expression that yields tuple[int, str], and then with a list of object. With the list of object, we expect to get a TypeError exception.\n\n288\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1595,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 319,
      "content": "Example 8-22. top_test.py: partial listing of the test suite for top\n\nfrom collections.abc import Iterator from typing import TYPE_CHECKING\n\nimport pytest\n\nfrom top import top\n\n# several lines omitted\n\ndef test_top_tuples() -> None: fruit = 'mango pear apple kiwi banana'.split() series: Iterator[tuple[int, str]] = ( (len(s), s) for s in fruit) length = 3 expected = [(6, 'banana'), (5, 'mango'), (5, 'apple')] result = top(series, length) if TYPE_CHECKING: reveal_type(series) reveal_type(expected) reveal_type(result) assert result == expected\n\n# intentional type error def test_top_objects_error() -> None: series = [object() for _ in range(4)] if TYPE_CHECKING: reveal_type(series) with pytest.raises(TypeError) as excinfo: top(series, 3) assert \"'<' not supported\" in str(excinfo.value)\n\nThe typing.TYPE_CHECKING constant is always False at runtime, but type check‐ ers pretend it is True when they are type checking.\n\nExplicit type declaration for the series variable, to make the Mypy output easier to read.16\n\nThis if prevents the next three lines from executing when the test runs.\n\nreveal_type() cannot be called at runtime, because it is not a regular function but a Mypy debugging facility—that’s why there is no import for it. Mypy will\n\n16 Without this type hint, Mypy would infer the type of series as Generator[Tuple[builtins.int, buil\n\ntins.str*], None, None], which is verbose but consistent-with Iterator[tuple[int, str]], as we’ll see in “Generic Iterable Types” on page 639.\n\nTypes Usable in Annotations\n\n|\n\n289",
      "content_length": 1533,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 320,
      "content": "output one debugging message for each reveal_type() pseudofunction call, showing the inferred type of the argument.\n\nThis line will be flagged as an error by Mypy.\n\nThe preceding tests pass—but they would pass anyway, with or without type hints in top.py. More to the point, if I check that test file with Mypy, I see that the TypeVar is working as intended. See the mypy command output in Example 8-23.\n\nAs of Mypy 0.910 (July 2021), the output of reveal_type does not show precisely the types I declared in some cases, but compatible types instead. For example, I did not use typing.Iterator but used abc.Iterator. Please ignore this detail. The Mypy output is still useful. I will pretend this issue of Mypy is fixed when discus‐ sing the output.\n\nExample 8-23. Output of mypy top_test.py (lines split for readability)\n\n…/comparable/ $ mypy top_test.py top_test.py:32: note: Revealed type is \"typing.Iterator[Tuple[builtins.int, builtins.str]]\" top_test.py:33: note: Revealed type is \"builtins.list[Tuple[builtins.int, builtins.str]]\" top_test.py:34: note: Revealed type is \"builtins.list[Tuple[builtins.int, builtins.str]]\" top_test.py:41: note: Revealed type is \"builtins.list[builtins.object*]\" top_test.py:43: error: Value of type variable \"LT\" of \"top\" cannot be \"object\" Found 1 error in 1 file (checked 1 source file)\n\nIn test_top_tuples, reveal_type(series) shows it is an Iterator[tuple[int, str]]—which I explicitly declared.\n\nreveal_type(result) confirms that the type returned by the top call is what I wanted: given the type of series, the result is list[tuple[int, str]].\n\nIn test_top_objects_error, reveal_type(series) shows it is list[object*]. Mypy puts a * after any type that was inferred: I did not annotate the type of series in this test.\n\nMypy flags the error that this test intentionally triggers: the element type of the Iterable series cannot be object (it must be of type SupportsLessThan).\n\nA key advantage of a protocol type over ABCs is that a type doesn’t need any special declaration to be consistent-with a protocol type. This allows a protocol to be created\n\n290\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 2138,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 321,
      "content": "leveraging preexisting types, or types implemented in code that we do not control. I don’t need to derive or register str, tuple, float, set, etc. with SupportsLessThan to use them where a SupportsLessThan parameter is expected. They only need to implement __lt__. And the type checker will still be able do its job, because Support sLessThan is explicitly defined as a Protocol—in contrast with the implicit protocols that are common with duck typing, which are invisible to the type checker.\n\nThe special Protocol class was introduced in PEP 544—Protocols: Structural subtyp‐ ing (static duck typing). Example 8-21 demonstrates why this feature is known as static duck typing: the solution to annotate the series parameter of top was to say “The nominal type of series doesn’t matter, as long as it implements the __lt__ method.” Python’s duck typing always allowed us to say that implicitly, leaving static type checkers clueless. A type checker can’t read CPython’s source code in C, or per‐ form console experiments to find out that sorted only requires that the elements support <.\n\nNow we can make duck typing explicit for static type checkers. That’s why it makes sense to say that typing.Protocol gives us static duck typing.17\n\nThere’s more to see about typing.Protocol. We’ll come back to it in Part IV, where Chapter 13 contrasts structural typing, duck typing, and ABCs—another approach to formalizing protocols. In addition, “Overloaded Signatures” on page 520 (Chapter 15) explains how to declare overloaded function signatures with @typing.overload, and includes an extensive example using typing.Protocol and a bounded TypeVar.\n\ntyping.Protocol makes it possible to annotate the double func‐ tion presented in “Types Are Defined by Supported Operations” on page 260 without losing functionality. The key is to define a protocol class with the __mul__ method. I invite you to do that as an exercise. The solution appears in “The Typed double Function” on page 466 (Chapter 13).\n\nCallable To annotate callback parameters or callable objects returned by higher-order func‐ tions, the collections.abc module provides the Callable type, available in the typ ing module for those not yet using Python 3.9. A Callable type is parameterized like this:\n\nCallable[[ParamType1, ParamType2], ReturnType]\n\n17 I don’t know who invented the term static duck typing, but it became more popular with the Go language, which has interface semantics that are more like Python’s protocols than the nominal interfaces of Java.\n\nTypes Usable in Annotations\n\n|\n\n291",
      "content_length": 2558,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 322,
      "content": "The parameter list—[ParamType1, ParamType2]—can have zero or more types.\n\nHere is an example in the context of a repl function, part of a simple interactive interpreter we’ll see in “Pattern Matching in lis.py: A Case Study” on page 669:18\n\ndef repl(input_fn: Callable[[Any], str] = input]) -> None:\n\nDuring normal usage, the repl function uses Python’s input built-in to read expres‐ sions from the user. However, for automated testing or for integration with other input sources, repl accepts an optional input_fn parameter: a Callable with the same parameter and return types as input.\n\nThe built-in input has this signature on typeshed:\n\ndef input(__prompt: Any = ...) -> str: ...\n\nThe input signature is consistent-with this Callable type hint:\n\nCallable[[Any], str]\n\nThere is no syntax to annotate optional or keyword argument types. The documenta‐ tion of typing.Callable says “such function types are rarely used as callback types.” If you need a type hint to match a function with a flexible signature, replace the whole parameter list with ...—like this:\n\nCallable[..., ReturnType]\n\nThe interaction of generic type parameters with a type hierarchy introduces a new typing concept: variance.\n\nVariance in Callable types\n\nImagine a temperature control system with a simple update function as shown in Example 8-24. The update function calls the probe function to get the current tem‐ perature, and calls display to show the temperature to the user. Both probe and dis play are passed as arguments to update for didactic reasons. The goal of the example is to contrast two Callable annotations: one with a return type, the other with a parameter type.\n\nExample 8-24. Illustrating variance.\n\nfrom collections.abc import Callable\n\ndef update( probe: Callable[[], float], display: Callable[[float], None]\n\n18 REPL stands for Read-Eval-Print-Loop, the basic behavior of interactive interpreters.\n\n292\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1942,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 323,
      "content": ") -> None: temperature = probe() # imagine lots of control code here display(temperature)\n\ndef probe_ok() -> int: return 42\n\ndef display_wrong(temperature: int) -> None: print(hex(temperature))\n\nupdate(probe_ok, display_wrong) # type error\n\ndef display_ok(temperature: complex) -> None: print(temperature)\n\nupdate(probe_ok, display_ok) # OK\n\nupdate takes two callables as arguments.\n\nprobe must be a callable that takes no arguments and returns a float.\n\ndisplay takes a float argument and returns None.\n\nprobe_ok is consistent-with Callable[[], float] because returning an int does not break code that expects a float.\n\ndisplay_wrong is not consistent-with Callable[[float], None] because there’s no guarantee that a function that expects an int can handle a float; for example, Python’s hex function accepts an int but rejects a float.\n\nMypy flags this line because display_wrong is incompatible with the type hint in the display parameter of update.\n\ndisplay_ok is consistent-with Callable[[float], None] because a function that accepts a complex can also handle a float argument.\n\nMypy is happy with this line.\n\nTo summarize, it’s OK to provide a callback that returns an int when the code expects a callback that returns a float, because an int value can always be used where a float is expected.\n\nFormally, we say that Callable[[], int] is subtype-of Callable[[], float]—as int is subtype-of float. This means that Callable is covariant on the return type\n\nTypes Usable in Annotations\n\n|\n\n293",
      "content_length": 1498,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 324,
      "content": "because the subtype-of relationship of the types int and float is in the same direc‐ tion as the relationship of the Callable types that use them as return types.\n\nOn the other hand, it’s a type error to provide a callback that takes a int argument when a callback that handles a float is required.\n\nFormally, Callable[[int], None] is not a subtype-of Callable[[float], None]. Although int is subtype-of float, in the parameterized Callable type the relation‐ ship is reversed: Callable[[float], None] is subtype-of Callable[[int], None]. Therefore we say that Callable is contravariant on the declared parameter types.\n\n“Variance” on page 544 in Chapter 15 explains variance with more details and examples of invariant, covariant, and contravariant types.\n\nFor now, rest assured that most parameterized generic types are invariant, therefore simpler. For example, if I declare scores: list[float], that tells me exactly what I can assign to scores. I can’t assign objects declared as list[int] or list[complex]:\n\nA list[int] object is not acceptable because it cannot hold float values which my code may need to put into scores. • A list[complex] object is not acceptable because my code may need to sort scores to find the median, but complex does not provide __lt__, therefore list[complex] is not sortable.\n\nNow we get to the last special type we’ll cover in this chapter.\n\nNoReturn This is a special type used only to annotate the return type of functions that never return. Usually, they exist to raise exceptions. There are dozens of such functions in the standard library.\n\nFor example, sys.exit() raises SystemExit to terminate the Python process.\n\nIts signature in typeshed is:\n\ndef exit(__status: object = ...) -> NoReturn: ...\n\nThe __status parameter is positional only, and it has a default value. Stub files don’t spell out the default values, they use ... instead. The type of __status is object, which means it may also be None, therefore it would be redundant to mark it Optional[object].\n\n294\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 2049,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 325,
      "content": "In Chapter 24, Example 24-6 uses NoReturn in the __flag_unknown_attrs, a method designed to produce a user-friendly and comprehensive error message, and then raise AttributeError.\n\nThe last section in this epic chapter is about positional and variadic parameters.\n\nAnnotating Positional Only and Variadic Parameters Recall the tag function from Example 7-9. The last time we saw its signature was in “Positional-Only Parameters” on page 242:\n\ndef tag(name, /, *content, class_=None, **attrs):\n\nHere is tag, fully annotated, written in several lines—a common convention for long signatures, with line breaks the way the blue formatter would do it:\n\nfrom typing import Optional\n\ndef tag( name: str, /, *content: str, class_: Optional[str] = None, **attrs: str, ) -> str:\n\nNote the type hint *content: str for the arbitrary positional parameters; this means all those arguments must be of type str. The type of the content local variable in the function body will be tuple[str, ...].\n\nThe type hint for the arbitrary keyword arguments is **attrs: str in this example, therefore the type of attrs inside the function will be dict[str, str]. For a type hint like **attrs: float, the type of attrs in the function would be dict[str, float].``\n\nIf the attrs parameter must accept values of different types, you’ll need to use a Union[] or Any: **attrs: Any.\n\nThe / notation for positional-only parameters is only available in Python ≥ 3.8. In Python 3.7 or earlier, that’s a syntax error. The PEP 484 convention is to prefix each positional-only parameter name with two underscores. Here is the tag signature again, now in two lines, using the PEP 484 convention:\n\nfrom typing import Optional\n\ndef tag(__name: str, *content: str, class_: Optional[str] = None, **attrs: str) -> str:\n\nMypy understands and enforces both ways of declaring positional-only parameters.\n\nAnnotating Positional Only and Variadic Parameters\n\n|\n\n295",
      "content_length": 1916,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 326,
      "content": "To close this chapter, let’s briefly consider the limits of type hints and the static type system they support.\n\nImperfect Typing and Strong Testing Maintainers of large corporate codebases report that many bugs are found by static type checkers and fixed more cheaply than if the bugs were discovered only after the code is running in production. However, it’s essential to note that automated testing was standard practice and widely adopted long before static typing was introduced in the companies that I know about.\n\nEven in the contexts where they are most beneficial, static typing cannot be trusted as the ultimate arbiter of correctness. It’s not hard to find:\n\nFalse positives\n\nTools report type errors on code that is correct.\n\nFalse negatives\n\nTools don’t report type errors on code that is incorrect.\n\nAlso, if we are forced to type check everything, we lose some of the expressive power of Python:\n\nSome handy features can’t be statically checked; for example, argument unpack‐ ing like config(**settings).\n\nAdvanced features like properties, descriptors, metaclasses, and metaprogram‐ ming in general are poorly supported or beyond comprehension for type checkers.\n\nType checkers lag behind Python releases, rejecting or even crashing while ana‐ lyzing code with new language features—for more than a year in some cases.\n\nCommon data constraints cannot be expressed in the type system—even simple ones. For example, type hints are unable to ensure “quantity must be an integer > 0” or “label must be a string with 6 to 12 ASCII letters.” In general, type hints are not help‐ ful to catch errors in business logic.\n\nGiven those caveats, type hints cannot be the mainstay of software quality, and mak‐ ing them mandatory without exception would amplify the downsides.\n\nConsider a static type checker as one of the tools in a modern CI pipeline, along with test runners, linters, etc. The point of a CI pipeline is to reduce software failures, and automated tests catch many bugs that are beyond the reach of type hints. Any code you can write in Python, you can test in Python—with or without type hints.\n\n296\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 2161,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 327,
      "content": "The title and conclusion of this section were inspired by Bruce Eckel’s article “Strong Typing vs. Strong Testing”, also published in the anthology The Best Software Writing I, edited by Joel Spolsky (Apress). Bruce is a fan of Python and author of books about C++, Java, Scala, and Kotlin. In that post, he tells how he was a static typ‐ ing advocate until he learned Python and concluded: “If a Python program has adequate unit tests, it can be as robust as a C++, Java, or C# program with adequate unit tests (although the tests in Python will be faster to write).”\n\nThis wraps up our coverage of Python’s type hints for now. They are also the main focus of Chapter 15, which covers generic classes, variance, overloaded signatures, type casting, and more. Meanwhile, type hints will make guest appearances in several examples throughout the book.\n\nChapter Summary We started with a brief introduction to the concept of gradual typing and then switched to a hands-on approach. It’s hard to see how gradual typing works without a tool that actually reads the type hints, so we developed an annotated function guided by Mypy error reports.\n\nBack to the idea of gradual typing, we explored how it is a hybrid of Python’s tradi‐ tional duck typing and the nominal typing more familiar to users of Java, C++, and other statically typed languages.\n\nMost of the chapter was devoted to presenting the major groups of types used in annotations. Many of the types we covered are related to familiar Python object types, such as collections, tuples, and callables—extended to support generic notation like Sequence[float]. Many of those types are temporary surrogates implemented in the typing module before the standard types were changed to support generics in Python 3.9.\n\nSome of the types are special entities. Any, Optional, Union, and NoReturn have noth‐ ing to do with actual objects in memory, but exist only in the abstract domain of the type system.\n\nWe studied parameterized generics and type variables, which bring more flexibility to type hints without sacrificing type safety.\n\nParameterized generics become even more expressive with the use of Protocol. Because it appeared only in Python 3.8, Protocol is not widely used yet—but it is hugely important. Protocol enables static duck typing: the essential bridge between Python’s duck-typed core and the nominal typing that allows static type checkers to catch bugs.\n\nChapter Summary\n\n|\n\n297",
      "content_length": 2448,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 328,
      "content": "While covering some of these types, we experimented with Mypy to see type checking errors and inferred types with the help of Mypy’s magic reveal_type() function.\n\nThe final section covered how to annotate positional-only and variadic parameters.\n\nType hints are a complex and evolving topic. Fortunately, they are an optional feature. Let us keep Python accessible to the widest user base and stop preaching that all Python code should have type hints—as I’ve seen in public sermons by typing evangelists.\n\nOur BDFL19 emeritus led this push toward type hints in Python, so it’s only fair that this chapter starts and ends with his words:\n\nI wouldn’t like a version of Python where I was morally obligated to add type hints all the time. I really do think that type hints have their place but there are also plenty of times that it’s not worth it, and it’s so wonderful that you can choose to use them.20\n\n—Guido van Rossum\n\nFurther Reading Bernát Gábor wrote in his excellent post, “The state of type hints in Python”:\n\nType hints should be used whenever unit tests are worth writing.\n\nI am a big fan of testing, but I also do a lot of exploratory coding. When I am explor‐ ing, tests and type hints are not helpful. They are a drag.\n\nGábor’s post is one of the best introductions to Python’s type hints that I found, along with Geir Arne Hjelle’s “Python Type Checking (Guide)”. “Hypermodern Python Chapter 4: Typing” by Claudio Jolowicz is a shorter introduction that also covers runtime type checking validation.\n\nFor deeper coverage, the Mypy documentation is the best source. It is valuable regardless of the type checker you are using, because it has tutorial and reference pages about Python typing in general—not just about the Mypy tool itself. There you will also find a handy cheat sheets and a very useful page about common issues and solutions.\n\nThe typing module documentation is a good quick reference, but it doesn’t go into much detail. PEP 483—The Theory of Type Hints includes a deep explanation about variance, using Callable to illustrate contravariance. The ultimate references are the PEP documents related to typing. There are more than 20 of them already. The\n\n19 “Benevolent Dictator For Life.” See Guido van van Rossum on the “Origin of BDFL”.\n\n20 From the YouTube video, “Type Hints by Guido van Rossum (March 2015)”. Quote starts at 13’40”. I did\n\nsome light editing for clarity.\n\n298\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 2453,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 329,
      "content": "intended audience of PEPs are Python core developers and Python’s Steering Coun‐ cil, so they assume a lot of prior knowledge and are certainly not light reading.\n\nAs mentioned, Chapter 15 covers more typing topics, and “Further Reading” on page 555 provides additional references, including Table 15-1, listing typing PEPs approved or under discussion as of late 2021.\n\n“Awesome Python Typing” is a valuable collection of links to tools and references.\n\nSoapbox\n\nJust Ride\n\nForget the ultralight, uncomfortable bikes, flashy jerseys, clunky shoes that clip onto tiny pedals, the grinding out of endless miles. Instead, ride like you did when you were a kid—just get on your bike and discover the pure joy of riding it.\n\n—Grant Petersen, Just Ride: A Radically Practical Guide to Riding Your Bike (Workman Publishing)\n\nIf coding is not your whole profession, but a useful tool in your profession, or some‐ thing you do to learn, tinker, and enjoy, you probably don’t need type hints any more than most bikers need shoes with stiff soles and metal cleats.\n\nJust code.\n\nThe Cognitive Effect of Typing\n\nI worry about the effect type hints will have on Python coding style.\n\nI agree that users of most APIs benefit from type hints. But Python attracted me— among other reasons—because it provides functions that are so powerful that they replace entire APIs, and we can write similarly powerful functions ourselves. Con‐ sider the max() built-in. It’s powerful, yet easy to understand. But I will show in “Max Overload” on page 521 that it takes 14 lines of type hints to properly annotate it—not counting a typing.Protocol and a few TypeVar definitions to support those type hints.\n\nI am concerned that strict enforcement of type hints in libraries will discourage pro‐ grammers from even considering writing such functions in the future.\n\nAccording to the English Wikipedia, “linguistic relativity”—a.k.a. the Sapir–Whorf hypothesis— is a “principle claiming that the structure of a language affects its speak‐ ers’ world view or cognition.” Wikipedia further explains:\n\nThe strong version says that language determines thought and that linguistic cate‐ gories limit and determine cognitive categories.\n\nFurther Reading\n\n|\n\n299",
      "content_length": 2225,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 330,
      "content": "The weak version says that linguistic categories and usage only influence thought and decisions.\n\nLinguists generally agree the strong version is false, but there is empirical evidence supporting the weak version.\n\nI am not aware of specific studies with programming languages, but in my experience they’ve had a big impact on how I approach problems. The first programming lan‐ guage I used professionally was Applesoft BASIC in the age of 8-bit computers. Recursion was not directly supported by BASIC—you had to roll your own call stack to use it. So I never considered using recursive algorithms or data structures. I knew at some conceptual level such things existed, but they weren’t part of my problem- solving toolbox.\n\nDecades later when I started with Elixir, I enjoyed solving problems with recursion and overused it—until I discovered that many of my solutions would be simpler if I used existing functions from the Elixir Enum and Stream modules. I learned that idiomatic Elixir application-level code rarely has explicit recursive calls, but uses enums and streams that implement recursion under the hood.\n\nLinguistic relativity could explain the widespread idea (also unproven) that learning different programming languages makes you a better programmer, particularly when the languages support different programming paradigms. Practicing Elixir made me more likely to apply functional patterns when I write Python or Go code.\n\nNow, back to Earth.\n\nThe requests package would probably have a very different API if Kenneth Reitz was determined (or told by his boss) to annotate all its functions. His goal was to write an API that was easy to use, flexible, and powerful. He succeeded, given the amazing popularity of requests—in May 2020, it’s #4 on PyPI Stats, with 2.6 million down‐ loads a day. #1 is urllib3, a dependency of requests.\n\nIn 2017, the requests maintainers decided not to spend their time writing type hints. One of the maintainers, Cory Benfield, had written an e-mail stating:\n\nI think that libraries with Pythonic APIs are the least likely to take up this typing sys‐ tem because it will provide the least value to them.\n\nIn that message, Benfield gave this extreme example of a tentative type definition for the files keyword argument of requests.request():\n\nOptional[ Union[ Mapping[ basestring, Union[ Tuple[basestring, Optional[Union[basestring, file]]], Tuple[basestring, Optional[Union[basestring, file]], Optional[basestring]],\n\n300\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 2513,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 331,
      "content": "Tuple[basestring, Optional[Union[basestring, file]], Optional[basestring], Optional[Headers]] ] ], Iterable[ Tuple[ basestring, Union[ Tuple[basestring, Optional[Union[basestring, file]]], Tuple[basestring, Optional[Union[basestring, file]], Optional[basestring]], Tuple[basestring, Optional[Union[basestring, file]], Optional[basestring], Optional[Headers]] ] ] ] ]\n\nAnd that assumes this definition:\n\nHeaders = Union[ Mapping[basestring, basestring], Iterable[Tuple[basestring, basestring]], ]\n\nDo you think requests would be the way it is if the maintainers insisted on 100% type hint coverage? SQLAlchemy is another important package that doesn’t play well with type hints.\n\nWhat makes these libraries great is embracing the dynamic nature of Python.\n\nWhile there are benefits to type hints, there is also a price to pay.\n\nFirst, there is the significant investment of understanding how the type system works. That’s a one-time cost.\n\nBut there is also a recurring cost, forever.\n\nWe lose some of the expressive power of Python if we insist on type checking every‐ thing. Beautiful features like argument unpacking—e.g., config(**settings)—are beyond comprehension for type checkers.\n\nIf you want to have a call like config(**settings) type checked, you must spell every argument out. That brings me memories of Turbo Pascal code I wrote 35 years ago.\n\nLibraries that use metaprogramming are hard or impossible to annotate. Surely meta‐ programming can be abused, but it’s also what makes many Python packages a joy to use.\n\nIf type hints are mandated top-down without exceptions in large companies, I bet soon we’ll see people using code generation to reduce boilerplate in Python source- code—a common practice with less dynamic languages.\n\nFurther Reading\n\n|\n\n301",
      "content_length": 1770,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 332,
      "content": "For some projects and contexts, type hints just don’t make sense. Even in contexts where they mostly make sense, they don’t make sense all the time. Any reasonable policy about the use of type hints must have exceptions.\n\nAlan Kay, the Turing Award laureate who pioneered object-oriented programming, once said:\n\nSome people are completely religious about type systems and as a mathematician I love the idea of type systems, but nobody has ever come up with one that has enough scope.21\n\nThank Guido for optional typing. Let’s use it as intended, and not aim to annotate everything into strict conformity to a coding style that looks like Java 1.5.\n\nDuck Typing FTW\n\nDuck typing fits my brain, and static duck typing is a good compromise allowing static type checking without losing a lot of flexibility that some nominal type systems only provide with a lot of complexity—if ever.\n\nBefore PEP 544, this whole idea of type hints seemed utterly unPythonic to me. I was very glad to see typing.Protocol land in Python. It brings balance to the force.\n\nGenerics or Specifics?\n\nFrom a Python perspective, the typing usage of the term “generic” is backward. Com‐ mon meanings of “generic” are “applicable to an entire class or group” or “without a brand name.”\n\nConsider list versus list[str]. The first is generic: it accepts any object. The sec‐ ond is specific: it only accepts str.\n\nThe term makes sense in Java, though. Before Java 1.5, all Java collections (except the magic array) were “specific”: they could only hold Object references, so we had to cast the items that came out of a collection to use them. With Java 1.5, collections got type parameters, and became “generic.”\n\n21 Source: “A Conversation with Alan Kay”.\n\n302\n\n|\n\nChapter 8: Type Hints in Functions",
      "content_length": 1768,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 333,
      "content": "CHAPTER 9 Decorators and Closures\n\nThere’s been a number of complaints about the choice of the name “decorator” for this feature. The major one is that the name is not consistent with its use in the GoF book.1 The name decorator probably owes more to its use in the compiler area—a syntax tree is walked and annotated.\n\n—PEP 318—Decorators for Functions and Methods\n\nFunction decorators let us “mark” functions in the source code to enhance their behavior in some way. This is powerful stuff, but mastering it requires understanding closures—which is what we get when functions capture variables defined outside of their bodies.\n\nThe most obscure reserved keyword in Python is nonlocal, introduced in Python 3.0. You can have a profitable life as a Python programmer without ever using it if you adhere to a strict regimen of class-centered object orientation. However, if you want to implement your own function decorators, you must understand closures, and then the need for nonlocal becomes obvious.\n\nAside from their application in decorators, closures are also essential for any type of programming using callbacks, and for coding in a functional style when it makes sense.\n\nThe end goal of this chapter is to explain exactly how function decorators work, from the simplest registration decorators to the rather more complicated parameterized ones. However, before we reach that goal we need to cover:\n\n1 That’s the 1995 Design Patterns book by the so-called Gang of Four (Gamma et al., Addison-Wesley).\n\n303",
      "content_length": 1513,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 334,
      "content": "How Python evaluates decorator syntax\n\nHow Python decides whether a variable is local\n\nWhy closures exist and how they work • What problem is solved by nonlocal\n\nWith this grounding, we can tackle further decorator topics:\n\nImplementing a well-behaved decorator • Powerful decorators in the standard library: @cache, @lru_cache, and @single dispatch\n\nImplementing a parameterized decorator\n\nWhat’s New in This Chapter The caching decorator functools.cache—new in Python 3.9—is simpler than the traditional functools.lru_cache, so I present it first. The latter is covered in “Using lru_cache” on page 323, including the simplified form added in Python 3.8.\n\n“Single Dispatch Generic Functions” on page 324 was expanded and now uses type hints, the preferred way to use functools.singledispatch since Python 3.7.\n\n“Parameterized Decorators” on page 329 now includes a class-based example, Example 9-27.\n\nI moved Chapter 10, “Design Patterns with First-Class Functions” to the end of Part II to improve the flow of the book. “Decorator-Enhanced Strategy Pattern” on page 353 is now in that chapter, along with other variations of the Strategy design pat‐ tern using callables.\n\nWe start with a very gentle introduction to decorators, and then proceed with the rest of the items listed in the chapter opening.\n\nDecorators 101 A decorator is a callable that takes another function as an argument (the decorated function).\n\nA decorator may perform some processing with the decorated function, and returns it or replaces it with another function or callable object.2\n\n2 If you replace “function” with “class” in the previous sentence, you have a brief description of what a class\n\ndecorator does. Class decorators are covered in Chapter 24.\n\n304\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1778,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 335,
      "content": "In other words, assuming an existing decorator named decorate, this code:\n\n@decorate def target(): print('running target()')\n\nhas the same effect as writing this:\n\ndef target(): print('running target()')\n\ntarget = decorate(target)\n\nThe end result is the same: at the end of either of these snippets, the target name is bound to whatever function is returned by decorate(target)—which may be the function initially named target, or may be a different function.\n\nTo confirm that the decorated function is replaced, see the console session in Example 9-1.\n\nExample 9-1. A decorator usually replaces a function with a different one\n\n>>> def deco(func): ... def inner(): ... print('running inner()') ... return inner ... >>> @deco ... def target(): ... print('running target()') ... >>> target() running inner() >>> target <function deco.<locals>.inner at 0x10063b598>\n\ndeco returns its inner function object.\n\ntarget is decorated by deco.\n\nInvoking the decorated target actually runs inner.\n\nInspection reveals that target is a now a reference to inner.\n\nStrictly speaking, decorators are just syntactic sugar. As we just saw, you can always simply call a decorator like any regular callable, passing another function. Sometimes that is actually convenient, especially when doing metaprogramming—changing pro‐ gram behavior at runtime.\n\nDecorators 101\n\n|\n\n305",
      "content_length": 1355,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 336,
      "content": "Three essential facts make a good summary of decorators:\n\nA decorator is a function or another callable.\n\nA decorator may replace the decorated function with a different one.\n\nDecorators are executed immediately when a module is loaded.\n\nNow let’s focus on the third point.\n\nWhen Python Executes Decorators A key feature of decorators is that they run right after the decorated function is defined. That is usually at import time (i.e., when a module is loaded by Python). Consider registration.py in Example 9-2.\n\nExample 9-2. The registration.py module\n\nregistry = []\n\ndef register(func): print(f'running register({func})') registry.append(func) return func\n\n@register def f1(): print('running f1()')\n\n@register def f2(): print('running f2()')\n\ndef f3(): print('running f3()')\n\ndef main(): print('running main()') print('registry ->', registry) f1() f2() f3()\n\nif __name__ == '__main__': main()\n\nregistry will hold references to functions decorated by @register.\n\nregister takes a function as an argument.\n\n306\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1051,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 337,
      "content": "Display what function is being decorated, for demonstration.\n\nInclude func in registry.\n\nReturn func: we must return a function; here we return the same received as argument.\n\nf1 and f2 are decorated by @register.\n\nf3 is not decorated.\n\nmain displays the registry, then calls f1(), f2(), and f3().\n\nmain() is only invoked if registration.py runs as a script.\n\nThe output of running registration.py as a script looks like this:\n\n$ python3 registration.py running register(<function f1 at 0x100631bf8>) running register(<function f2 at 0x100631c80>) running main() registry -> [<function f1 at 0x100631bf8>, <function f2 at 0x100631c80>] running f1() running f2() running f3()\n\nNote that register runs (twice) before any other function in the module. When reg ister is called, it receives the decorated function object as an argument—for exam‐ ple, <function f1 at 0x100631bf8>.\n\nAfter the module is loaded, the registry list holds references to the two decorated functions: f1 and f2. These functions, as well as f3, are only executed when explicitly called by main.\n\nIf registration.py is imported (and not run as a script), the output is this:\n\n>>> import registration running register(<function f1 at 0x10063b1e0>) running register(<function f2 at 0x10063b268>)\n\nAt this time, if you inspect registry, this is what you see:\n\n>>> registration.registry [<function f1 at 0x10063b1e0>, <function f2 at 0x10063b268>]\n\nThe main point of Example 9-2 is to emphasize that function decorators are executed as soon as the module is imported, but the decorated functions only run when they are explicitly invoked. This highlights the difference between what Pythonistas call import time and runtime.\n\nWhen Python Executes Decorators\n\n|\n\n307",
      "content_length": 1731,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 338,
      "content": "Registration Decorators Considering how decorators are commonly employed in real code, Example 9-2 is unusual in two ways:\n\nThe decorator function is defined in the same module as the decorated functions. A real decorator is usually defined in one module and applied to functions in other modules.\n\nThe register decorator returns the same function passed as an argument. In practice, most decorators define an inner function and return it.\n\nEven though the register decorator in Example 9-2 returns the decorated function unchanged, that technique is not useless. Similar decorators are used in many Python frameworks to add functions to some central registry—for example, a registry map‐ ping URL patterns to functions that generate HTTP responses. Such registration dec‐ orators may or may not change the decorated function.\n\nWe will see a registration decorator applied in “Decorator-Enhanced Strategy Pat‐ tern” on page 353 (Chapter 10).\n\nMost decorators do change the decorated function. They usually do it by defining an inner function and returning it to replace the decorated function. Code that uses inner functions almost always depends on closures to operate correctly. To under‐ stand closures, we need to take a step back and review how variable scopes work in Python.\n\nVariable Scope Rules In Example 9-3, we define and test a function that reads two variables: a local variable a—defined as function parameter—and variable b that is not defined anywhere in the function.\n\nExample 9-3. Function reading a local and a global variable\n\n>>> def f1(a): ... print(a) ... print(b) ... >>> f1(3) 3 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"<stdin>\", line 3, in f1 NameError: global name 'b' is not defined\n\n308\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1791,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 339,
      "content": "The error we got is not surprising. Continuing from Example 9-3, if we assign a value to a global b and then call f1, it works:\n\n>>> b = 6 >>> f1(3) 3 6\n\nNow, let’s see an example that may surprise you.\n\nTake a look at the f2 function in Example 9-4. Its first two lines are the same as f1 in Example 9-3, then it makes an assignment to b. But it fails at the second print, before the assignment is made.\n\nExample 9-4. Variable b is local, because it is assigned a value in the body of the function\n\n>>> b = 6 >>> def f2(a): ... print(a) ... print(b) ... b = 9 ... >>> f2(3) 3 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"<stdin>\", line 3, in f2 UnboundLocalError: local variable 'b' referenced before assignment\n\nNote that the output starts with 3, which proves that the print(a) statement was exe‐ cuted. But the second one, print(b), never runs. When I first saw this I was sur‐ prised, thinking that 6 should be printed, because there is a global variable b and the assignment to the local b is made after print(b).\n\nBut the fact is, when Python compiles the body of the function, it decides that b is a local variable because it is assigned within the function. The generated bytecode reflects this decision and will try to fetch b from the local scope. Later, when the call f2(3) is made, the body of f2 fetches and prints the value of the local variable a, but when trying to fetch the value of local variable b, it discovers that b is unbound.\n\nThis is not a bug, but a design choice: Python does not require you to declare vari‐ ables, but assumes that a variable assigned in the body of a function is local. This is much better than the behavior of JavaScript, which does not require variable declara‐ tions either, but if you do forget to declare that a variable is local (with var), you may clobber a global variable without knowing.\n\nVariable Scope Rules\n\n|\n\n309",
      "content_length": 1907,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 340,
      "content": "If we want the interpreter to treat b as a global variable and still assign a new value to it within the function, we use the global declaration:\n\n>>> b = 6 >>> def f3(a): ... global b ... print(a) ... print(b) ... b = 9 ... >>> f3(3) 3 6 >>> b 9\n\nIn the preceding examples, we can see two scopes in action:\n\nThe module global scope\n\nMade of names assigned to values outside of any class or function block.\n\nThe f3 function local scope\n\nMade of names assigned to values as parameters, or directly in the body of the function.\n\nThere is one other scope where variables can come from, which we call nonlocal and is fundamental for closures; we’ll see it in a bit.\n\nAfter this closer look at how variable scopes work in Python, we can tackle closures in the next section, “Closures” on page 311. If you are curious about the bytecode differ‐ ences between the functions in Examples 9-3 and 9-4, see the following sidebar.\n\nComparing Bytecodes The dis module provides an easy way to disassemble the bytecode of Python func‐ tions. Read Examples 9-5 and 9-6 to see the bytecodes for f1 and f2 from Examples 9-3 and 9-4.\n\nExample 9-5. Disassembly of the f1 function from Example 9-3\n\n>>> from dis import dis >>> dis(f1) 2 0 LOAD_GLOBAL 0 (print) 3 LOAD_FAST 0 (a) 6 CALL_FUNCTION 1 (1 positional, 0 keyword pair) 9 POP_TOP\n\n3 10 LOAD_GLOBAL 0 (print) 13 LOAD_GLOBAL 1 (b) 16 CALL_FUNCTION 1 (1 positional, 0 keyword pair)\n\n310\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1459,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 341,
      "content": "19 POP_TOP 20 LOAD_CONST 0 (None) 23 RETURN_VALUE\n\nLoad global name print.\n\nLoad local name a.\n\nLoad global name b.\n\nContrast the bytecode for f1 shown in Example 9-5 with the bytecode for f2 in Example 9-6.\n\nExample 9-6. Disassembly of the f2 function from Example 9-4\n\n>>> dis(f2) 2 0 LOAD_GLOBAL 0 (print) 3 LOAD_FAST 0 (a) 6 CALL_FUNCTION 1 (1 positional, 0 keyword pair) 9 POP_TOP\n\n3 10 LOAD_GLOBAL 0 (print) 13 LOAD_FAST 1 (b) 16 CALL_FUNCTION 1 (1 positional, 0 keyword pair) 19 POP_TOP\n\n4 20 LOAD_CONST 1 (9) 23 STORE_FAST 1 (b) 26 LOAD_CONST 0 (None) 29 RETURN_VALUE\n\nLoad local name b. This shows that the compiler considers b a local variable, even if the assignment to b occurs later, because the nature of the variable—whether it is local or not—cannot change in the body of the function.\n\nThe CPython virtual machine (VM) that runs the bytecode is a stack machine, so LOAD and POP operations refer to the stack. It is beyond the scope of this book to fur‐ ther describe the Python opcodes, but they are documented along with the dis mod‐ ule in “dis—Disassembler for Python bytecode”.\n\nClosures In the blogosphere, closures are sometimes confused with anonymous functions. Many confuse them because of the parallel history of those features: defining func‐ tions inside functions is not so common or convenient, until you have anonymous functions. And closures only matter when you have nested functions. So a lot of peo‐ ple learn both concepts at the same time.\n\nClosures\n\n|\n\n311",
      "content_length": 1495,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 342,
      "content": "Actually, a closure is a function—let’s call it f—with an extended scope that encom‐ passes variables referenced in the body of f that are not global variables or local vari‐ ables of f. Such variables must come from the local scope of an outer function that encompasses f.\n\nIt does not matter whether the function is anonymous or not; what matters is that it can access nonglobal variables that are defined outside of its body.\n\nThis is a challenging concept to grasp, and is better approached through an example.\n\nConsider an avg function to compute the mean of an ever-growing series of values; for example, the average closing price of a commodity over its entire history. Every day a new price is added, and the average is computed taking into account all prices so far.\n\nStarting with a clean slate, this is how avg could be used:\n\n>>> avg(10) 10.0 >>> avg(11) 10.5 >>> avg(12) 11.0\n\nWhere does avg come from, and where does it keep the history of previous values?\n\nFor starters, Example 9-7 is a class-based implementation.\n\nExample 9-7. average_oo.py: a class to calculate a running average\n\nclass Averager():\n\ndef __init__(self): self.series = []\n\ndef __call__(self, new_value): self.series.append(new_value) total = sum(self.series) return total / len(self.series)\n\nThe Averager class creates instances that are callable:\n\n>>> avg = Averager() >>> avg(10) 10.0 >>> avg(11) 10.5 >>> avg(12) 11.0\n\n312\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1448,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 343,
      "content": "Now, Example 9-8 is a functional implementation, using the higher-order function make_averager.\n\nExample 9-8. average.py: a higher-order function to calculate a running average\n\ndef make_averager(): series = []\n\ndef averager(new_value): series.append(new_value) total = sum(series) return total / len(series)\n\nreturn averager\n\nWhen invoked, make_averager returns an averager function object. Each time an averager is called, it appends the passed argument to the series, and computes the current average, as shown in Example 9-9.\n\nExample 9-9. Testing Example 9-8\n\n>>> avg = make_averager() >>> avg(10) 10.0 >>> avg(11) 10.5 >>> avg(15) 12.0\n\nNote the similarities of the examples: we call Averager() or make_averager() to get a callable object avg that will update the historical series and calculate the current mean. In Example 9-7, avg is an instance of Averager, and in Example 9-8, it is the inner function, averager. Either way, we just call avg(n) to include n in the series and get the updated mean.\n\nIt’s obvious where the avg of the Averager class keeps the history: the self.series instance attribute. But where does the avg function in the second example find the series?\n\nNote that series is a local variable of make_averager because the assignment series = [] happens in the body of that function. But when avg(10) is called, make_averager has already returned, and its local scope is long gone.\n\nWithin averager, series is a free variable. This is a technical term meaning a vari‐ able that is not bound in the local scope. See Figure 9-1.\n\nClosures\n\n|\n\n313",
      "content_length": 1573,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 344,
      "content": "Figure 9-1. The closure for averager extends the scope of that function to include the binding for the free variable series.\n\nInspecting the returned averager object shows how Python keeps the names of local and free variables in the __code__ attribute that represents the compiled body of the function. Example 9-10 demonstrates.\n\nExample 9-10. Inspecting the function created by make_averager in Example 9-8\n\n>>> avg.__code__.co_varnames ('new_value', 'total') >>> avg.__code__.co_freevars ('series',)\n\nThe value for series is kept in the __closure__ attribute of the returned function avg. Each item in avg.__closure__ corresponds to a name in avg. __code__ .co_freevars. These items are cells, and they have an attribute called cell_con tents where the actual value can be found. Example 9-11 shows these attributes.\n\nExample 9-11. Continuing from Example 9-9\n\n>>> avg.__code__.co_freevars ('series',) >>> avg.__closure__ (<cell at 0x107a44f78: list object at 0x107a91a48>,) >>> avg.__closure__[0].cell_contents [10, 11, 12]\n\nTo summarize: a closure is a function that retains the bindings of the free variables that exist when the function is defined, so that they can be used later when the func‐ tion is invoked and the defining scope is no longer available.\n\nNote that the only situation in which a function may need to deal with external vari‐ ables that are nonglobal is when it is nested in another function and those variables are part of the local scope of the outer function.\n\n314\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1533,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 345,
      "content": "The nonlocal Declaration Our previous implementation of make_averager was not efficient. In Example 9-8, we stored all the values in the historical series and computed their sum every time averager was called. A better implementation would only store the total and the number of items so far, and compute the mean from these two numbers.\n\nExample 9-12 is a broken implementation, just to make a point. Can you see where it breaks?\n\nExample 9-12. A broken higher-order function to calculate a running average without keeping all history\n\ndef make_averager(): count = 0 total = 0\n\ndef averager(new_value): count += 1 total += new_value return total / count\n\nreturn averager\n\nIf you try Example 9-12, here is what you get:\n\n>>> avg = make_averager() >>> avg(10) Traceback (most recent call last): ... UnboundLocalError: local variable 'count' referenced before assignment >>>\n\nThe problem is that the statement count += 1 actually means the same as count = count + 1, when count is a number or any immutable type. So we are actually assigning to count in the body of averager, and that makes it a local variable. The same problem affects the total variable.\n\nWe did not have this problem in Example 9-8 because we never assigned to the ser ies name; we only called series.append and invoked sum and len on it. So we took advantage of the fact that lists are mutable.\n\nBut with immutable types like numbers, strings, tuples, etc., all you can do is read, never update. If you try to rebind them, as in count = count + 1, then you are implicitly creating a local variable count. It is no longer a free variable, and therefore it is not saved in the closure.\n\nThe nonlocal Declaration\n\n|\n\n315",
      "content_length": 1686,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 346,
      "content": "To work around this, the nonlocal keyword was introduced in Python 3. It lets you declare a variable as a free variable even when it is assigned within the function. If a new value is assigned to a nonlocal variable, the binding stored in the closure is changed. A correct implementation of our newest make_averager looks like Example 9-13.\n\nExample 9-13. Calculate a running average without keeping all history (fixed with the use of nonlocal)\n\ndef make_averager(): count = 0 total = 0\n\ndef averager(new_value): nonlocal count, total count += 1 total += new_value return total / count\n\nreturn averager\n\nAfter studying the use of nonlocal, let’s summarize how Python’s variable lookup works.\n\nVariable Lookup Logic When a function is defined, the Python bytecode compiler determines how to fetch a variable x that appears in it, based on these rules:3\n\nIf there is a global x declaration, x comes from and is assigned to the x global variable module.4\n\nIf there is a nonlocal x declaration, x comes from and is assigned to the x local variable of the nearest surrounding function where x is defined.\n\nIf x is a parameter or is assigned a value in the function body, then x is the local variable.\n\nIf x is referenced but is not assigned and is not a parameter:\n\n— x will be looked up in the local scopes of the surrounding function bodies\n\n(nonlocal scopes).\n\n3 Thanks to tech reviewer Leonardo Rochael for suggesting this summary.\n\n4 Python does not have a program global scope, only module global scopes.\n\n316\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1549,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 347,
      "content": "— If not found in surrounding scopes, it will be read from the module global\n\nscope.\n\n— If not found in the global scope, it will be read from __builtins__.__dict__.\n\nNow that we have Python closures covered, we can effectively implement decorators with nested functions.\n\nImplementing a Simple Decorator Example 9-14 is a decorator that clocks every invocation of the decorated function and displays the elapsed time, the arguments passed, and the result of the call.\n\nExample 9-14. clockdeco0.py: simple decorator to show the running time of functions\n\nimport time\n\ndef clock(func): def clocked(*args): t0 = time.perf_counter() result = func(*args) elapsed = time.perf_counter() - t0 name = func.__name__ arg_str = ', '.join(repr(arg) for arg in args) print(f'[{elapsed:0.8f}s] {name}({arg_str}) -> {result!r}') return result return clocked\n\nDefine inner function clocked to accept any number of positional arguments.\n\nThis line only works because the closure for clocked encompasses the func free variable.\n\nReturn the inner function to replace the decorated function.\n\nExample 9-15 demonstrates the use of the clock decorator.\n\nExample 9-15. Using the clock decorator\n\nimport time from clockdeco0 import clock\n\n@clock def snooze(seconds): time.sleep(seconds)\n\n@clock\n\nImplementing a Simple Decorator\n\n|\n\n317",
      "content_length": 1311,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 348,
      "content": "def factorial(n): return 1 if n < 2 else n*factorial(n-1)\n\nif __name__ == '__main__': print('*' * 40, 'Calling snooze(.123)') snooze(.123) print('*' * 40, 'Calling factorial(6)') print('6! =', factorial(6))\n\nThe output of running Example 9-15 looks like this:\n\n$ python3 clockdeco_demo.py **************************************** Calling snooze(.123) [0.12363791s] snooze(0.123) -> None **************************************** Calling factorial(6) [0.00000095s] factorial(1) -> 1 [0.00002408s] factorial(2) -> 2 [0.00003934s] factorial(3) -> 6 [0.00005221s] factorial(4) -> 24 [0.00006390s] factorial(5) -> 120 [0.00008297s] factorial(6) -> 720 6! = 720\n\nHow It Works Remember that this code:\n\n@clock def factorial(n): return 1 if n < 2 else n*factorial(n-1)\n\nactually does this:\n\ndef factorial(n): return 1 if n < 2 else n*factorial(n-1)\n\nfactorial = clock(factorial)\n\nSo, in both examples, clock gets the factorial function as its func argument (see Example 9-14). It then creates and returns the clocked function, which the Python interpreter assigns to factorial (behind the scenes, in the first example). In fact, if you import the clockdeco_demo module and check the __name__ of factorial, this is what you get:\n\n>>> import clockdeco_demo >>> clockdeco_demo.factorial.__name__ 'clocked' >>>\n\nSo factorial now actually holds a reference to the clocked function. From now on, each time factorial(n) is called, clocked(n) gets executed. In essence, clocked does the following:\n\n318\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1524,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 349,
      "content": "1. Records the initial time t0. 2. Calls the original factorial function, saving the result.\n\n3. Computes the elapsed time.\n\n4. Formats and displays the collected data.\n\n5. Returns the result saved in step 2.\n\nThis is the typical behavior of a decorator: it replaces the decorated function with a new function that accepts the same arguments and (usually) returns whatever the decorated function was supposed to return, while also doing some extra processing.\n\nIn Design Patterns by Gamma et al., the short description of the decorator pattern starts with: “Attach additional responsibilities to an object dynamically.” Function decorators fit that description. But at the implementation level, Python decorators bear little resemblance to the classic decorator described in the original Design Patterns work. “Soapbox” on page 338 has more on this subject.\n\nThe clock decorator implemented in Example 9-14 has a few shortcomings: it does not support keyword arguments, and it masks the __name__ and __doc__ of the deco‐ rated function. Example 9-16 uses the functools.wraps decorator to copy the rele‐ vant attributes from func to clocked. Also, in this new version, keyword arguments are correctly handled.\n\nExample 9-16. clockdeco.py: an improved clock decorator\n\nimport time import functools\n\ndef clock(func): @functools.wraps(func) def clocked(*args, **kwargs): t0 = time.perf_counter() result = func(*args, **kwargs) elapsed = time.perf_counter() - t0 name = func.__name__ arg_lst = [repr(arg) for arg in args] arg_lst.extend(f'{k}={v!r}' for k, v in kwargs.items()) arg_str = ', '.join(arg_lst) print(f'[{elapsed:0.8f}s] {name}({arg_str}) -> {result!r}') return result return clocked\n\nImplementing a Simple Decorator\n\n|\n\n319",
      "content_length": 1731,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 350,
      "content": "functools.wraps is just one of the ready-to-use decorators in the standard library. In the next section, we’ll meet the most impressive decorator that functools provides: cache.\n\nDecorators in the Standard Library Python has three built-in functions that are designed to decorate methods: property, classmethod, and staticmethod. We’ll discuss property in “Using a Property for Attribute Validation” on page 857 and the others in “classmethod Versus staticmethod” on page 369.\n\nIn Example 9-16 we saw another important decorator: functools.wraps, a helper for building well-behaved decorators. Some of the most interesting decorators in the standard library are cache, lru_cache, and singledispatch—all from the functools module. We’ll cover them next.\n\nMemoization with functools.cache The functools.cache decorator implements memoization:5 an optimization techni‐ que that works by saving the results of previous invocations of an expensive function, avoiding repeat computations on previously used arguments.\n\nfunctools.cache was added in Python 3.9. If you need to run these examples in Python 3.8, replace @cache with @lru_cache. For prior versions of Python, you must invoke the decorator, writing @lru_cache(), as explained in “Using lru_cache” on page 323.\n\nA good demonstration is to apply @cache to the painfully slow recursive function to generate the nth number in the Fibonacci sequence, as shown in Example 9-17.\n\nExample 9-17. The very costly recursive way to compute the nth number in the Fibonacci series\n\nfrom clockdeco import clock\n\n@clock def fibonacci(n): if n < 2: return n\n\n5 To clarify, this is not a typo: memoization is a computer science term vaguely related to “memorization,” but\n\nnot the same.\n\n320\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1767,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 351,
      "content": "return fibonacci(n - 2) + fibonacci(n - 1)\n\nif __name__ == '__main__': print(fibonacci(6))\n\nHere is the result of running fibo_demo.py. Except for the last line, all output is gen‐ erated by the clock decorator:\n\n$ python3 fibo_demo.py [0.00000042s] fibonacci(0) -> 0 [0.00000049s] fibonacci(1) -> 1 [0.00006115s] fibonacci(2) -> 1 [0.00000031s] fibonacci(1) -> 1 [0.00000035s] fibonacci(0) -> 0 [0.00000030s] fibonacci(1) -> 1 [0.00001084s] fibonacci(2) -> 1 [0.00002074s] fibonacci(3) -> 2 [0.00009189s] fibonacci(4) -> 3 [0.00000029s] fibonacci(1) -> 1 [0.00000027s] fibonacci(0) -> 0 [0.00000029s] fibonacci(1) -> 1 [0.00000959s] fibonacci(2) -> 1 [0.00001905s] fibonacci(3) -> 2 [0.00000026s] fibonacci(0) -> 0 [0.00000029s] fibonacci(1) -> 1 [0.00000997s] fibonacci(2) -> 1 [0.00000028s] fibonacci(1) -> 1 [0.00000030s] fibonacci(0) -> 0 [0.00000031s] fibonacci(1) -> 1 [0.00001019s] fibonacci(2) -> 1 [0.00001967s] fibonacci(3) -> 2 [0.00003876s] fibonacci(4) -> 3 [0.00006670s] fibonacci(5) -> 5 [0.00016852s] fibonacci(6) -> 8 8\n\nThe waste is obvious: fibonacci(1) is called eight times, fibonacci(2) five times, etc. But adding just two lines to use cache, performance is much improved. See Example 9-18.\n\nExample 9-18. Faster implementation using caching\n\nimport functools\n\nfrom clockdeco import clock\n\n@functools.cache @clock def fibonacci(n):\n\nDecorators in the Standard Library\n\n|\n\n321",
      "content_length": 1399,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 352,
      "content": "if n < 2: return n return fibonacci(n - 2) + fibonacci(n - 1)\n\nif __name__ == '__main__': print(fibonacci(6))\n\nThis line works with Python 3.9 or later. See “Using lru_cache” on page 323 for alternatives supporting earlier versions of Python.\n\nThis is an example of stacked decorators: @cache is applied on the function returned by @clock.\n\nStacked Decorators\n\nTo make sense of stacked decorators, recall that the @ is syntax sugar for applying the decorator function to the function below it. If there’s more than one decorator, they behave like nested func‐ tion calls. This:\n\n@alpha @beta def my_fn(): ...\n\nis the same as this:\n\nmy_fn = alpha(beta(my_fn))\n\nIn other words, the beta decorator is applied first, and the function it returns is then passed to alpha.\n\nUsing cache in Example 9-18, the fibonacci function is called only once for each value of n:\n\n$ python3 fibo_demo_lru.py [0.00000043s] fibonacci(0) -> 0 [0.00000054s] fibonacci(1) -> 1 [0.00006179s] fibonacci(2) -> 1 [0.00000070s] fibonacci(3) -> 2 [0.00007366s] fibonacci(4) -> 3 [0.00000057s] fibonacci(5) -> 5 [0.00008479s] fibonacci(6) -> 8 8\n\nIn another test, to compute fibonacci(30), Example 9-18 made the 31 calls needed in 0.00017s (total time), while the uncached Example 9-17 took 12.09s on an Intel Core i7 notebook, because it called fibonacci(1) 832,040 times, in a total of 2,692,537 calls.\n\n322\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1416,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 353,
      "content": "All the arguments taken by the decorated function must be hashable, because the underlying lru_cache uses a dict to store the results, and the keys are made from the positional and keyword arguments used in the calls.\n\nBesides making silly recursive algorithms viable, @cache really shines in applications that need to fetch information from remote APIs.\n\nfunctools.cache can consume all available memory if there is a very large number of cache entries. I consider it more suitable for use in short-lived command-line scripts. In long-running pro‐ cesses, I recommend using functools.lru_cache with a suitable maxsize parameter, as explained in the next section.\n\nUsing lru_cache The functools.cache decorator is actually a simple wrapper around the older func tools.lru_cache function, which is more flexible and compatible with Python 3.8 and earlier versions.\n\nThe main advantage of @lru_cache is that its memory usage is bounded by the maxsize parameter, which has a rather conservative default value of 128—which means the cache will hold at most 128 entries at any time.\n\nThe acronym LRU stands for Least Recently Used, meaning that older entries that have not been read for a while are discarded to make room for new ones.\n\nSince Python 3.8, lru_cache can be applied in two ways. This is how to use it in the simplest way:\n\n@lru_cache def costly_function(a, b): ...\n\nThe other way—available since Python 3.2—is to invoke it as a function, with ():\n\n@lru_cache() def costly_function(a, b): ...\n\nIn both cases, the default parameters would be used. These are:\n\nmaxsize=128\n\nSets the maximum number of entries to be stored. After the cache is full, the least recently used entry is discarded to make room for each new entry. For optimal performance, maxsize should be a power of 2. If you pass maxsize=None, the LRU logic is disabled, so the cache works faster but entries are never discarded, which may consume too much memory. That’s what @functools.cache does.\n\nDecorators in the Standard Library\n\n|\n\n323",
      "content_length": 2012,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 354,
      "content": "typed=False\n\nDetermines whether the results of different argument types are stored separately. For example, in the default setting, float and integer arguments that are consid‐ ered equal are stored only once, so there would be a single entry for the calls f(1) and f(1.0). If typed=True, those arguments would produce different entries, possibly storing distinct results.\n\nHere is an example invoking @lru_cache with nondefault parameters:\n\n@lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ...\n\nNow let’s study another powerful decorator: functools.singledispatch.\n\nSingle Dispatch Generic Functions Imagine we are creating a tool to debug web applications. We want to generate HTML displays for different types of Python objects.\n\nWe could start with a function like this:\n\nimport html\n\ndef htmlize(obj): content = html.escape(repr(obj)) return f'<pre>{content}</pre>'\n\nThat will work for any Python type, but now we want to extend it to generate custom displays for some types. Some examples:\n\nstr\n\nReplace embedded newline characters with '<br/>\\n' and use <p> tags instead of <pre>.\n\nint\n\nShow the number in decimal and hexadecimal (with a special case for bool).\n\nlist\n\nOutput an HTML list, formatting each item according to its type.\n\nfloat and Decimal\n\nOutput the value as usual, but also in the form of a fraction (why not?).\n\nThe behavior we want is shown in Example 9-19.\n\n324\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1442,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 355,
      "content": "Example 9-19. htmlize() generates HTML tailored to different object types\n\n>>> htmlize({1, 2, 3}) '<pre>{1, 2, 3}</pre>' >>> htmlize(abs) '<pre>&lt;built-in function abs&gt;</pre>' >>> htmlize('Heimlich & Co.\\n- a game') '<p>Heimlich &amp; Co.<br/>\\n- a game</p>' >>> htmlize(42) '<pre>42 (0x2a)</pre>' >>> print(htmlize(['alpha', 66, {3, 2, 1}])) <ul> <li><p>alpha</p></li> <li><pre>66 (0x42)</pre></li> <li><pre>{1, 2, 3}</pre></li> </ul> >>> htmlize(True) '<pre>True</pre>' >>> htmlize(fractions.Fraction(2, 3)) '<pre>2/3</pre>' >>> htmlize(2/3) '<pre>0.6666666666666666 (2/3)</pre>' >>> htmlize(decimal.Decimal('0.02380952')) '<pre>0.02380952 (1/42)</pre>'\n\nThe original function is registered for object, so it serves as a catch-all to handle argument types that don’t match the other implementations.\n\nstr objects are also HTML-escaped but wrapped in <p></p>, with <br/> line breaks inserted before each '\\n'.\n\nAn int is shown in decimal and hexadecimal, inside <pre></pre>.\n\nEach list item is formatted according to its type, and the whole sequence is ren‐ dered as an HTML list.\n\nAlthough bool is an int subtype, it gets special treatment.\n\nShow Fraction as a fraction.\n\nShow float and Decimal with an approximate fractional equivalent.\n\nFunction singledispatch\n\nBecause we don’t have Java-style method overloading in Python, we can’t simply cre‐ ate variations of htmlize with different signatures for each data type we want to han‐ dle differently. A possible solution in Python would be to turn htmlize into a\n\nDecorators in the Standard Library\n\n|\n\n325",
      "content_length": 1564,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 356,
      "content": "dispatch function, with a chain of if/elif/… or match/case/… calling specialized functions like htmlize_str, htmlize_int, etc. This is not extensible by users of our module, and is unwieldy: over time, the htmlize dispatcher would become too big, and the coupling between it and the specialized functions would be very tight.\n\nThe functools.singledispatch decorator allows different modules to contribute to the overall solution, and lets you easily provide specialized functions even for types that belong to third-party packages that you can’t edit. If you decorate a plain func‐ tion with @singledispatch, it becomes the entry point for a generic function: a group of functions to perform the same operation in different ways, depending on the type of the first argument. This is what is meant by the term single dispatch. If more argu‐ ments were used to select the specific functions, we’d have multiple dispatch. Example 9-20 shows how.\n\nfunctools.singledispatch exists since Python 3.4, but it only supports type hints since Python 3.7. The last two functions in Example 9-20 illustrate the syntax that works in all versions of Python since 3.4.\n\nExample 9-20. @singledispatch creates a custom @htmlize.register to bundle several functions into a generic function\n\nfrom functools import singledispatch from collections import abc import fractions import decimal import html import numbers\n\n@singledispatch def htmlize(obj: object) -> str: content = html.escape(repr(obj)) return f'<pre>{content}</pre>'\n\n@htmlize.register def _(text: str) -> str: content = html.escape(text).replace('\\n', '<br/>\\n') return f'<p>{content}</p>'\n\n@htmlize.register def _(seq: abc.Sequence) -> str: inner = '</li>\\n<li>'.join(htmlize(item) for item in seq) return '<ul>\\n<li>' + inner + '</li>\\n</ul>'\n\n@htmlize.register def _(n: numbers.Integral) -> str: return f'<pre>{n} (0x{n:x})</pre>'\n\n326\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1921,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 357,
      "content": "@htmlize.register def _(n: bool) -> str: return f'<pre>{n}</pre>'\n\n@htmlize.register(fractions.Fraction) def _(x) -> str: frac = fractions.Fraction(x) return f'<pre>{frac.numerator}/{frac.denominator}</pre>'\n\n@htmlize.register(decimal.Decimal) @htmlize.register(float) def _(x) -> str: frac = fractions.Fraction(x).limit_denominator() return f'<pre>{x} ({frac.numerator}/{frac.denominator})</pre>'\n\n@singledispatch marks the base function that handles the object type.\n\nEach specialized function is decorated with @«base».register.\n\nThe type of the first argument given at runtime determines when this particular function definition will be used. The name of the specialized functions is irrele‐ vant; _ is a good choice to make this clear.6\n\nFor each additional type to get special treatment, register a new function with a matching type hint in the first parameter.\n\nThe numbers ABCs are useful for use with singledispatch.7\n\nbool is a subtype-of numbers.Integral, but the singledispatch logic seeks the implementation with the most specific matching type, regardless of the order they appear in the code.\n\n6 Unfortunately, Mypy 0.770 complains when it sees multiple functions with the same name. 7 Despite the warning in “The fall of the numeric tower” on page 279, the number ABCs are not deprecated and\n\nyou find them in Python 3 code.\n\nDecorators in the Standard Library\n\n|\n\n327",
      "content_length": 1384,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 358,
      "content": "If you don’t want to, or cannot, add type hints to the decorated function, you can pass a type to the @«base».register decorator. This syntax works in Python 3.4 or later.\n\nThe @«base».register decorator returns the undecorated function, so it’s possi‐ ble to stack them to register two or more types on the same implementation.8\n\nWhen possible, register the specialized functions to handle ABCs (abstract classes) such as numbers.Integral and abc.MutableSequence, instead of concrete imple‐ mentations like int and list. This allows your code to support a greater variety of compatible types. For example, a Python extension can provide alternatives to the int type with fixed bit lengths as subclasses of numbers.Integral.9\n\nUsing ABCs or typing.Protocol with @singledispatch allows your code to support existing or future classes that are actual or virtual subclasses of those ABCs, or that implement those proto‐ cols. The use of ABCs and the concept of a virtual subclass are sub‐ jects of Chapter 13.\n\nA notable quality of the singledispatch mechanism is that you can register special‐ ized functions anywhere in the system, in any module. If you later add a module with a new user-defined type, you can easily provide a new custom function to handle that type. And you can write custom functions for classes that you did not write and can’t change.\n\nsingledispatch is a well-thought-out addition to the standard library, and it offers more features than I can describe here. PEP 443—Single-dispatch generic functions is a good reference, but it doesn’t mention the use of type hints, which were added later. The functools module documentation has improved and has more up-to-date cov‐ erage with several examples in its singledispatch entry.\n\n8 Maybe one day you’ll also be able to express this with single unparameterized @htmlize.register and type\n\nhint using Union, but when I tried, Python raised a TypeError with a message saying that Union is not a class. So, although PEP 484 syntax is supported by @singledispatch, the semantics are not there yet.\n\n9 NumPy, for example, implements several machine-oriented integer and floating-point types.\n\n328\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 2199,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 359,
      "content": "@singledispatch is not designed to bring Java-style method over‐ loading to Python. A single class with many overloaded variations of a method is better than a single function with a lengthy stretch of if/elif/elif/elif blocks. But both solutions are flawed because they concentrate too much responsibility in a single code unit—the class or the function. The advantage of @singledispatch is supporting modular extension: each module can register a speci‐ alized function for each type it supports. In a realistic use case, you would not have all the implementations of generic functions in the same module as in Example 9-20.\n\nWe’ve seen some decorators that take arguments, for example, @lru_cache() and htmlize.register(float), created by @singledispatch in Example 9-20. The next section shows how to build decorators that accept parameters.\n\nParameterized Decorators When parsing a decorator in source code, Python takes the decorated function and passes it as the first argument to the decorator function. So how do you make a deco‐ rator accept other arguments? The answer is: make a decorator factory that takes those arguments and returns a decorator, which is then applied to the function to be decorated. Confusing? Sure. Let’s start with an example based on the simplest decora‐ tor we’ve seen: register in Example 9-21.\n\nExample 9-21. Abridged registration.py module from Example 9-2, repeated here for convenience\n\nregistry = []\n\ndef register(func): print(f'running register({func})') registry.append(func) return func\n\n@register def f1(): print('running f1()')\n\nprint('running main()') print('registry ->', registry) f1()\n\nA Parameterized Registration Decorator To make it easy to enable or disable the function registration performed by register, we’ll make it accept an optional active parameter which, if False, skips registering\n\nParameterized Decorators\n\n|\n\n329",
      "content_length": 1881,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 360,
      "content": "the decorated function. Example 9-22 shows how. Conceptually, the new register function is not a decorator but a decorator factory. When called, it returns the actual decorator that will be applied to the target function.\n\nExample 9-22. To accept parameters, the new register decorator must be called as a function\n\nregistry = set()\n\ndef register(active=True): def decorate(func): print('running register' f'(active={active})->decorate({func})') if active: registry.add(func) else: registry.discard(func)\n\nreturn func return decorate\n\n@register(active=False) def f1(): print('running f1()')\n\n@register() def f2(): print('running f2()')\n\ndef f3(): print('running f3()')\n\nregistry is now a set, so adding and removing functions is faster.\n\nregister takes an optional keyword argument.\n\nThe decorate inner function is the actual decorator; note how it takes a function as an argument.\n\nRegister func only if the active argument (retrieved from the closure) is True.\n\nIf not active and func in registry, remove it.\n\nBecause decorate is a decorator, it must return a function.\n\nregister is our decorator factory, so it returns decorate.\n\n330\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1175,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 361,
      "content": "The @register factory must be invoked as a function, with the desired parameters.\n\nIf no parameters are passed, register must still be called as a function—@regis ter()—i.e., to return the actual decorator, decorate.\n\nThe main point is that register() returns decorate, which is then applied to the decorated function.\n\nThe code in Example 9-22 is in a registration_param.py module. If we import it, this is what we get:\n\n>>> import registration_param running register(active=False)->decorate(<function f1 at 0x10063c1e0>) running register(active=True)->decorate(<function f2 at 0x10063c268>) >>> registration_param.registry [<function f2 at 0x10063c268>]\n\nNote how only the f2 function appears in the registry; f1 does not appear because active=False was passed to the register decorator factory, so the decorate that was applied to f1 did not add it to the registry.\n\nIf, instead of using the @ syntax, we used register as a regular function, the syntax needed to decorate a function f would be register()(f) to add f to the registry, or register(active=False)(f) to not add it (or remove it). See Example 9-23 for a demo of adding and removing functions to the registry.\n\nExample 9-23. Using the registration_param module listed in Example 9-22\n\n>>> from registration_param import * running register(active=False)->decorate(<function f1 at 0x10073c1e0>) running register(active=True)->decorate(<function f2 at 0x10073c268>) >>> registry {<function f2 at 0x10073c268>} >>> register()(f3) running register(active=True)->decorate(<function f3 at 0x10073c158>) <function f3 at 0x10073c158> >>> registry {<function f3 at 0x10073c158>, <function f2 at 0x10073c268>} >>> register(active=False)(f2) running register(active=False)->decorate(<function f2 at 0x10073c268>) <function f2 at 0x10073c268> >>> registry {<function f3 at 0x10073c158>}\n\nWhen the module is imported, f2 is in the registry.\n\nThe register() expression returns decorate, which is then applied to f3.\n\nParameterized Decorators\n\n|\n\n331",
      "content_length": 1998,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 362,
      "content": "The previous line added f3 to the registry.\n\nThis call removes f2 from the registry.\n\nConfirm that only f3 remains in the registry.\n\nThe workings of parameterized decorators are fairly involved, and the one we’ve just discussed is simpler than most. Parameterized decorators usually replace the decora‐ ted function, and their construction requires yet another level of nesting. Now we will explore the architecture of one such function pyramid.\n\nThe Parameterized Clock Decorator In this section, we’ll revisit the clock decorator, adding a feature: users may pass a format string to control the output of the clocked function report. See Example 9-24.\n\nFor simplicity, Example 9-24 is based on the initial clock imple‐ mentation from Example 9-14, and not the improved one from Example 9-16 that uses @functools.wraps, adding yet another function layer.\n\nExample 9-24. Module clockdeco_param.py: the parameterized clock decorator\n\nimport time\n\nDEFAULT_FMT = '[{elapsed:0.8f}s] {name}({args}) -> {result}'\n\ndef clock(fmt=DEFAULT_FMT): def decorate(func): def clocked(*_args): t0 = time.perf_counter() _result = func(*_args) elapsed = time.perf_counter() - t0 name = func.__name__ args = ', '.join(repr(arg) for arg in _args) result = repr(_result) print(fmt.format(**locals())) return _result return clocked return decorate\n\nif __name__ == '__main__':\n\n@clock() def snooze(seconds): time.sleep(seconds)\n\n332\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1447,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 363,
      "content": "for i in range(3): snooze(.123)\n\nclock is our parameterized decorator factory.\n\ndecorate is the actual decorator.\n\nclocked wraps the decorated function.\n\n_result is the actual result of the decorated function.\n\n_args holds the actual arguments of clocked, while args is str used for display.\n\nresult is the str representation of _result, for display.\n\nUsing **locals() here allows any local variable of clocked to be referenced in the fmt.10\n\nclocked will replace the decorated function, so it should return whatever that function returns.\n\ndecorate returns clocked.\n\nclock returns decorate.\n\nIn this self test, clock() is called without arguments, so the decorator applied will use the default format str.\n\nIf you run Example 9-24 from the shell, this is what you get:\n\n$ python3 clockdeco_param.py [0.12412500s] snooze(0.123) -> None [0.12411904s] snooze(0.123) -> None [0.12410498s] snooze(0.123) -> None\n\nTo exercise the new functionality, let’s have a look at Examples 9-25 and 9-26, which are two other modules using clockdeco_param, and the outputs they generate.\n\n10 Tech reviewer Miroslav Šedivý noted: “It also means that code linters will complain about unused variables since they tend to ignore uses of locals().” Yes, that’s yet another example of how static checking tools dis‐ courage the use of the dynamic features that attracted me and countless programmers to Python in the first place. To make the linter happy, I could spell out each local variable twice in the call: fmt.format(elapsed= elapsed, name=name, args=args, result=result). I’d rather not. If you use static checking tools, it’s very important to know when to ignore them.\n\nParameterized Decorators\n\n|\n\n333",
      "content_length": 1689,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 364,
      "content": "Example 9-25. clockdeco_param_demo1.py\n\nimport time from clockdeco_param import clock\n\n@clock('{name}: {elapsed}s') def snooze(seconds): time.sleep(seconds)\n\nfor i in range(3): snooze(.123)\n\nOutput of Example 9-25:\n\n$ python3 clockdeco_param_demo1.py snooze: 0.12414693832397461s snooze: 0.1241159439086914s snooze: 0.12412118911743164s\n\nExample 9-26. clockdeco_param_demo2.py\n\nimport time from clockdeco_param import clock\n\n@clock('{name}({args}) dt={elapsed:0.3f}s') def snooze(seconds): time.sleep(seconds)\n\nfor i in range(3): snooze(.123)\n\nOutput of Example 9-26:\n\n$ python3 clockdeco_param_demo2.py snooze(0.123) dt=0.124s snooze(0.123) dt=0.124s snooze(0.123) dt=0.124s\n\nLennart Regebro—a technical reviewer for the first edition—argues that decorators are best coded as classes implementing __call__, and not as functions like the examples in this chapter. I agree that approach is better for nontrivial decorators, but to explain the basic idea of this language feature, functions are easier to understand. See “Further Reading” on page 336, in particular, Graham Dumple‐ ton’s blog and wrapt module for industrial-strength techniques when building decorators.\n\nThe next section shows an example in the style recommended by Regebro and Dumpleton.\n\n334\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1298,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 365,
      "content": "A Class-Based Clock Decorator As a final example, Example 9-27 lists the implementation of a parameterized clock decorator implemented as a class with __call__. Contrast Example 9-24 with Example 9-27. Which one do you prefer?\n\nExample 9-27. Module clockdeco_cls.py: parameterized clock decorator implemented as class\n\nimport time\n\nDEFAULT_FMT = '[{elapsed:0.8f}s] {name}({args}) -> {result}'\n\nclass clock:\n\ndef __init__(self, fmt=DEFAULT_FMT): self.fmt = fmt\n\ndef __call__(self, func): def clocked(*_args): t0 = time.perf_counter() _result = func(*_args) elapsed = time.perf_counter() - t0 name = func.__name__ args = ', '.join(repr(arg) for arg in _args) result = repr(_result) print(self.fmt.format(**locals())) return _result return clocked\n\nInstead of a clock outer function, the clock class is our parameterized decorator factory. I named it with a lowercase c to make clear that this implementation is a drop-in replacement for the one in Example 9-24.\n\nThe argument passed in the clock(my_format) is assigned to the fmt parameter here. The class constructor returns an instance of clock, with my_format stored in self.fmt.\n\n__call__ makes the clock instance callable. When invoked, the instance replaces the decorated function with clocked.\n\nclocked wraps the decorated function.\n\nThis ends our exploration of function decorators. We’ll see class decorators in Chapter 24.\n\nParameterized Decorators\n\n|\n\n335",
      "content_length": 1414,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 366,
      "content": "Chapter Summary We covered some difficult terrain in this chapter. I tried to make the journey as smooth as possible, but we definitely entered the realm of metaprogramming.\n\nWe started with a simple @register decorator without an inner function, and fin‐ ished with a parameterized @clock() involving two levels of nested functions.\n\nRegistration decorators, though simple in essence, have real applications in Python frameworks. We will apply the registration idea in one implementation of the Strat‐ egy design pattern in Chapter 10.\n\nUnderstanding how decorators actually work required covering the difference between import time and runtime, then diving into variable scoping, closures, and the new nonlocal declaration. Mastering closures and nonlocal is valuable not only to build decorators, but also to code event-oriented programs for GUIs or asynchronous I/O with callbacks, and to adopt a functional style when it makes sense.\n\nParameterized decorators almost always involve at least two nested functions, maybe more if you want to use @functools.wraps to produce a decorator that provides bet‐ ter support for more advanced techniques. One such technique is stacked decorators, which we saw in Example 9-18. For more sophisticated decorators, a class-based implementation may be easier to read and maintain.\n\nAs examples of parameterized decorators in the standard library, we visited the pow‐ erful @cache and @singledispatch from the functools module.\n\nFurther Reading Item #26 of Brett Slatkin’s Effective Python, 2nd ed. (Addison-Wesley), covers best practices for function decorators and recommends always using functools.wraps— which we saw in Example 9-16.11\n\nGraham Dumpleton has a series of in-depth blog posts about techniques for imple‐ menting well-behaved decorators, starting with “How you implemented your Python decorator is wrong”. His deep expertise in this matter is also nicely packaged in the wrapt module he wrote to simplify the implementation of decorators and dynamic function wrappers, which support introspection and behave correctly when further decorated, when applied to methods, and when used as attribute descriptors. Chap‐ ter 23 in Part III is about descriptors.\n\nChapter 9, “Metaprogramming”, of the Python Cookbook, 3rd ed. by David Beazley and Brian K. Jones (O’Reilly), has several recipes, from elementary decorators to very\n\n11 I wanted to make the code as simple as possible, so I did not follow Slatkin’s excellent advice in all examples.\n\n336\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 2537,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 367,
      "content": "sophisticated ones, including one that can be called as a regular decorator or as a dec‐ orator factory, e.g., @clock or @clock(). That’s “Recipe 9.6. Defining a Decorator That Takes an Optional Argument” in that cookbook.\n\nMichele Simionato authored a package aiming to “simplify the usage of decorators for the average programmer, and to popularize decorators by showing various nontrivial examples,” according to the docs. It’s available on PyPI as the decorator package.\n\nCreated when decorators were still a new feature in Python, the Python Decorator Library wiki page has dozens of examples. Because that page started years ago, some of the techniques shown have been superseded, but the page is still an excellent source of inspiration.\n\n“Closures in Python” is a short blog post by Fredrik Lundh that explains the termi‐ nology of closures.\n\nPEP 3104—Access to Names in Outer Scopes describes the introduction of the nonlocal declaration to allow rebinding of names that are neither local nor global. It also includes an excellent overview of how this issue is resolved in other dynamic lan‐ guages (Perl, Ruby, JavaScript, etc.) and the pros and cons of the design options avail‐ able to Python.\n\nOn a more theoretical level, PEP 227—Statically Nested Scopes documents the intro‐ duction of lexical scoping as an option in Python 2.1 and as a standard in Python 2.2, explaining the rationale and design choices for the implementation of closures in Python.\n\nPEP 443 provides the rationale and a detailed description of the single-dispatch generic functions’ facility. An old (March 2005) blog post by Guido van Rossum, “Five-Minute Multimethods in Python”, walks through an implementation of generic functions (a.k.a. multimethods) using decorators. His code supports multiple- dispatch (i.e., dispatch based on more than one positional argument). Guido’s multi‐ methods code is interesting, but it’s a didactic example. For a modern, production- ready implementation of multiple dispatch generic functions, check out Reg by Martijn Faassen—author of the model-driven and REST-savvy Morepath web framework.\n\nFurther Reading\n\n|\n\n337",
      "content_length": 2141,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 368,
      "content": "Soapbox\n\nDynamic Scope Versus Lexical Scope\n\nThe designer of any language with first-class functions faces this issue: being a first- class object, a function is defined in a certain scope but may be invoked in other scopes. The question is: how to evaluate the free variables? The first and simplest answer is “dynamic scope.” This means that free variables are evaluated by looking into the environment where the function is invoked.\n\nIf Python had dynamic scope and no closures, we could improvise avg—similar to Example 9-8—like this:\n\n>>> ### this is not a real Python console session! ### >>> avg = make_averager() >>> series = [] >>> avg(10) 10.0 >>> avg(11) 10.5 >>> avg(12) 11.0 >>> series = [1] >>> avg(5) 3.0\n\nBefore using avg, we have to define series = [] ourselves, so we must know that averager (inside make_averager) refers to a list named series.\n\nBehind the scenes, series accumulates the values to be averaged.\n\nWhen series = [1] is executed, the previous list is lost. This could happen by accident, when handling two independent running averages at the same time.\n\nFunctions should be opaque, with their implementation hidden from users. But with dynamic scope, if a function uses free variables, the programmer has to know its internals to set up an environment where it works correctly. After years of struggling with the LaTeX document preparation language, the excellent Practical LaTeX book by George Grätzer (Springer) taught me that LaTeX variables use dynamic scope. That’s why they were so confusing to me!\n\nEmacs Lisp also uses dynamic scope, at least by default. See “Dynamic Binding” in the Emacs Lisp manual for a short explanation.\n\nDynamic scope is easier to implement, which is probably why it was the path taken by John McCarthy when he created Lisp, the first language to have first-class functions. Paul Graham’s article “The Roots of Lisp” is an accessible explanation of John\n\n338\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 1961,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 369,
      "content": "McCarthy’s original paper about the Lisp language, \"Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I”. McCarthy’s paper is a mas‐ terpiece as great as Beethoven’s 9th Symphony. Paul Graham translated it for the rest of us, from mathematics to English and running code.\n\nPaul Graham’s commentary explains how tricky dynamic scoping is. Quoting from “The Roots of Lisp”:\n\nIt’s an eloquent testimony to the dangers of dynamic scope that even the very first example of higher-order Lisp functions was broken because of it. It may be that McCarthy was not fully aware of the implications of dynamic scope in 1960. Dynamic scope remained in Lisp implementations for a surprisingly long time— until Sussman and Steele developed Scheme in 1975. Lexical scope does not compli‐ cate the definition of eval very much, but it may make compilers harder to write.\n\nToday, lexical scope is the norm: free variables are evaluated considering the environ‐ ment where the function is defined. Lexical scope complicates the implementation of languages with first-class functions, because it requires the support of closures. On the other hand, lexical scope makes source code easier to read. Most languages inven‐ ted since Algol have lexical scope. One notable exception is JavaScript, where the spe‐ cial variable this is confusing because it can be lexically or dynamically scoped, depending on how the code is written.\n\nFor many years, Python lambdas did not provide closures, contributing to the bad name of this feature among functional-programming geeks in the blogosphere. This was fixed in Python 2.2 (December 2001), but the blogosphere has a long memory. Since then, lambda is embarrassing only because of its limited syntax.\n\nPython Decorators and the Decorator Design Pattern\n\nPython function decorators fit the general description of decorator given by Gamma et al. in Design Patterns: “Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.”\n\nAt the implementation level, Python decorators do not resemble the classic decorator design pattern, but an analogy can be made.\n\nIn the design pattern, Decorator and Component are abstract classes. An instance of a concrete decorator wraps an instance of a concrete component in order to add behav‐ iors to it. Quoting from Design Patterns:\n\nThe decorator conforms to the interface of the component it decorates so that its presence is transparent to the component’s clients. The decorator forwards requests to the component and may perform additional actions (such as drawing a border) before or after forwarding. Transparency lets you nest decorators recursively, thereby allowing an unlimited number of added responsibilities.” (p. 175)\n\nIn Python, the decorator function plays the role of a concrete Decorator subclass, and the inner function it returns is a decorator instance. The returned function wraps\n\nFurther Reading\n\n|\n\n339",
      "content_length": 3003,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 370,
      "content": "the function to be decorated, which is analogous to the component in the design pat‐ tern. The returned function is transparent because it conforms to the interface of the component by accepting the same arguments. It forwards calls to the component and may perform additional actions either before or after it. Borrowing from the previous citation, we can adapt the last sentence to say that “Transparency lets you stack deco‐ rators, thereby allowing an unlimited number of added behaviors.”\n\nNote that I am not suggesting that function decorators should be used to implement the decorator pattern in Python programs. Although this can be done in specific sit‐ uations, in general the decorator pattern is best implemented with classes to represent the decorator and the components it will wrap.\n\n340\n\n|\n\nChapter 9: Decorators and Closures",
      "content_length": 841,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 371,
      "content": "CHAPTER 10 Design Patterns with First-Class Functions\n\nConformity to patterns is not a measure of goodness.\n\n—Ralph Johnson, coauthor of the Design Patterns classic1\n\nIn software engineering, a design pattern is a general recipe for solving a common design problem. You don’t need to know design patterns to follow this chapter. I will explain the patterns used in the examples.\n\nThe use of design patterns in programming was popularized by the landmark book Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley) by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides—a.k.a. “the Gang of Four.” The book is a catalog of 23 patterns consisting of arrangements of classes exemplified with code in C++, but assumed to be useful in other object-oriented lan‐ guages as well.\n\nAlthough design patterns are language independent, that does not mean every pat‐ tern applies to every language. For example, Chapter 17 will show that it doesn’t make sense to emulate the recipe of the Iterator pattern in Python, because the pat‐ tern is embedded in the language and ready to use in the form of generators—which don’t need classes to work, and require less code than the classic recipe.\n\nThe authors of Design Patterns acknowledge in their introduction that the implemen‐ tation language determines which patterns are relevant:\n\nThe choice of programming language is important because it influences one’s point of view. Our patterns assume Smalltalk/C++-level language features, and that choice determines what can and cannot be implemented easily. If we assumed procedural\n\n1 From a slide in the talk “Root Cause Analysis of Some Faults in Design Patterns,” presented by Ralph Johnson\n\nat IME/CCSL, Universidade de São Paulo, Nov. 15, 2014.\n\n341",
      "content_length": 1771,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 372,
      "content": "languages, we might have included design patterns called “Inheritance,” “Encapsula‐ tion,” and “Polymorphism.” Similarly, some of our patterns are supported directly by the less common object-oriented languages. CLOS has multi-methods, for example, which lessen the need for a pattern such as Visitor.2\n\nIn his 1996 presentation, “Design Patterns in Dynamic Languages”, Peter Norvig states that 16 out of the 23 patterns in the original Design Patterns book become either “invisible or simpler” in a dynamic language (slide 9). He’s talking about the Lisp and Dylan languages, but many of the relevant dynamic features are also present in Python. In particular, in the context of languages with first-class functions, Norvig suggests rethinking the classic patterns known as Strategy, Command, Template Method, and Visitor.\n\nThe goal of this chapter is to show how—in some cases—functions can do the same work as classes, with code that is more readable and concise. We will refactor an implementation of Strategy using functions as objects, removing a lot of boilerplate code. We’ll also discuss a similar approach to simplifying the Command pattern.\n\nWhat’s New in This Chapter I moved this chapter to the end of Part III so I could apply a registration decorator in “Decorator-Enhanced Strategy Pattern” on page 353 and also use type hints in the examples. Most type hints used in this chapter are not complicated, and they do help with readability.\n\nCase Study: Refactoring Strategy Strategy is a good example of a design pattern that can be simpler in Python if you leverage functions as first-class objects. In the following section, we describe and implement Strategy using the “classic” structure described in Design Patterns. If you are familiar with the classic pattern, you can skip to “Function-Oriented Strategy” on page 347 where we refactor the code using functions, significantly reducing the line count.\n\nClassic Strategy The UML class diagram in Figure 10-1 depicts an arrangement of classes that exem‐ plifies the Strategy pattern.\n\n2 Quoted from page 4 of Design Patterns.\n\n342\n\n|\n\nChapter 10: Design Patterns with First-Class Functions",
      "content_length": 2156,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 373,
      "content": "Figure 10-1. UML class diagram for order discount processing implemented with the Strategy design pattern.\n\nThe Strategy pattern is summarized like this in Design Patterns:\n\nDefine a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.\n\nA clear example of Strategy applied in the ecommerce domain is computing dis‐ counts to orders according to the attributes of the customer or inspection of the ordered items.\n\nConsider an online store with these discount rules:\n\nCustomers with 1,000 or more fidelity points get a global 5% discount per order.\n\nA 10% discount is applied to each line item with 20 or more units in the same order.\n\nOrders with at least 10 distinct items get a 7% global discount.\n\nFor brevity, let’s assume that only one discount may be applied to an order.\n\nThe UML class diagram for the Strategy pattern is depicted in Figure 10-1. Its partici‐ pants are:\n\nCase Study: Refactoring Strategy\n\n|\n\n343",
      "content_length": 1013,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 374,
      "content": "Context\n\nProvides a service by delegating some computation to interchangeable compo‐ nents that implement alternative algorithms. In the ecommerce example, the context is an Order, which is configured to apply a promotional discount accord‐ ing to one of several algorithms.\n\nStrategy\n\nThe interface common to the components that implement the different algo‐ rithms. In our example, this role is played by an abstract class called Promotion.\n\nConcrete strategy\n\nOne of the concrete subclasses of Strategy. FidelityPromo, BulkPromo, and LargeOrderPromo are the three concrete strategies implemented.\n\nThe code in Example 10-1 follows the blueprint in Figure 10-1. As described in Design Patterns, the concrete strategy is chosen by the client of the context class. In our example, before instantiating an order, the system would somehow select a pro‐ motional discount strategy and pass it to the Order constructor. The selection of the strategy is outside the scope of the pattern.\n\nExample 10-1. Implementation of the Order class with pluggable discount strategies\n\nfrom abc import ABC, abstractmethod from collections.abc import Sequence from decimal import Decimal from typing import NamedTuple, Optional\n\nclass Customer(NamedTuple): name: str fidelity: int\n\nclass LineItem(NamedTuple): product: str quantity: int price: Decimal\n\ndef total(self) -> Decimal: return self.price * self.quantity\n\nclass Order(NamedTuple): # the Context customer: Customer cart: Sequence[LineItem] promotion: Optional['Promotion'] = None\n\ndef total(self) -> Decimal: totals = (item.total() for item in self.cart)\n\n344\n\n|\n\nChapter 10: Design Patterns with First-Class Functions",
      "content_length": 1658,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 375,
      "content": "return sum(totals, start=Decimal(0))\n\ndef due(self) -> Decimal: if self.promotion is None: discount = Decimal(0) else: discount = self.promotion.discount(self) return self.total() - discount\n\ndef __repr__(self): return f'<Order total: {self.total():.2f} due: {self.due():.2f}>'\n\nclass Promotion(ABC): # the Strategy: an abstract base class @abstractmethod def discount(self, order: Order) -> Decimal: \"\"\"Return discount as a positive dollar amount\"\"\"\n\nclass FidelityPromo(Promotion): # first Concrete Strategy \"\"\"5% discount for customers with 1000 or more fidelity points\"\"\"\n\ndef discount(self, order: Order) -> Decimal: rate = Decimal('0.05') if order.customer.fidelity >= 1000: return order.total() * rate return Decimal(0)\n\nclass BulkItemPromo(Promotion): # second Concrete Strategy \"\"\"10% discount for each LineItem with 20 or more units\"\"\"\n\ndef discount(self, order: Order) -> Decimal: discount = Decimal(0) for item in order.cart: if item.quantity >= 20: discount += item.total() * Decimal('0.1') return discount\n\nclass LargeOrderPromo(Promotion): # third Concrete Strategy \"\"\"7% discount for orders with 10 or more distinct items\"\"\"\n\ndef discount(self, order: Order) -> Decimal: distinct_items = {item.product for item in order.cart} if len(distinct_items) >= 10: return order.total() * Decimal('0.07') return Decimal(0)\n\nNote that in Example 10-1, I coded Promotion as an abstract base class (ABC) to use the @abstractmethod decorator and make the pattern more explicit.\n\nCase Study: Refactoring Strategy\n\n|\n\n345",
      "content_length": 1521,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 376,
      "content": "Example 10-2 shows doctests used to demonstrate and verify the operation of a mod‐ ule implementing the rules described earlier.\n\nExample 10-2. Sample usage of Order class with different promotions applied\n\n>>> joe = Customer('John Doe', 0) >>> ann = Customer('Ann Smith', 1100) >>> cart = (LineItem('banana', 4, Decimal('.5')), ... LineItem('apple', 10, Decimal('1.5')), ... LineItem('watermelon', 5, Decimal(5))) >>> Order(joe, cart, FidelityPromo()) <Order total: 42.00 due: 42.00> >>> Order(ann, cart, FidelityPromo()) <Order total: 42.00 due: 39.90> >>> banana_cart = (LineItem('banana', 30, Decimal('.5')), ... LineItem('apple', 10, Decimal('1.5'))) >>> Order(joe, banana_cart, BulkItemPromo()) <Order total: 30.00 due: 28.50> >>> long_cart = tuple(LineItem(str(sku), 1, Decimal(1)) ... for sku in range(10)) >>> Order(joe, long_cart, LargeOrderPromo()) <Order total: 10.00 due: 9.30> >>> Order(joe, cart, LargeOrderPromo()) <Order total: 42.00 due: 42.00>\n\nTwo customers: joe has 0 fidelity points, ann has 1,100.\n\nOne shopping cart with three line items.\n\nThe FidelityPromo promotion gives no discount to joe.\n\nann gets a 5% discount because she has at least 1,000 points.\n\nThe banana_cart has 30 units of the \"banana\" product and 10 apples.\n\nThanks to the BulkItemPromo, joe gets a $1.50 discount on the bananas.\n\nlong_cart has 10 different items at $1.00 each.\n\njoe gets a 7% discount on the whole order because of LargerOrderPromo.\n\nExample 10-1 works perfectly well, but the same functionality can be implemented with less code in Python by using functions as objects. The next section shows how.\n\n346\n\n|\n\nChapter 10: Design Patterns with First-Class Functions",
      "content_length": 1672,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 377,
      "content": "Function-Oriented Strategy Each concrete strategy in Example 10-1 is a class with a single method, discount. Furthermore, the strategy instances have no state (no instance attributes). You could say they look a lot like plain functions, and you would be right. Example 10-3 is a refactoring of Example 10-1, replacing the concrete strategies with simple functions and removing the Promo abstract class. Only small adjustments are needed in the Order class.3\n\nExample 10-3. Order class with discount strategies implemented as functions\n\nfrom collections.abc import Sequence from dataclasses import dataclass from decimal import Decimal from typing import Optional, Callable, NamedTuple\n\nclass Customer(NamedTuple): name: str fidelity: int\n\nclass LineItem(NamedTuple): product: str quantity: int price: Decimal\n\ndef total(self): return self.price * self.quantity\n\n@dataclass(frozen=True) class Order: # the Context customer: Customer cart: Sequence[LineItem] promotion: Optional[Callable[['Order'], Decimal]] = None\n\ndef total(self) -> Decimal: totals = (item.total() for item in self.cart) return sum(totals, start=Decimal(0))\n\ndef due(self) -> Decimal: if self.promotion is None:\n\n3 I had to reimplement Order with @dataclass due to a bug in Mypy. You may ignore this detail, because this class works with NamedTuple as well, just like in Example 10-1. If Order is a NamedTuple, Mypy 0.910 crashes when checking the type hint for promotion. I tried adding # type ignore to that specific line, but Mypy crashed anyway. Mypy handles the same type hint correctly if Order is built with @dataclass. Issue #9397 is unresolved as of July 19, 2021. Hopefully it will be fixed by the time you read this.\n\nCase Study: Refactoring Strategy\n\n|\n\n347",
      "content_length": 1737,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 378,
      "content": "discount = Decimal(0) else: discount = self.promotion(self) return self.total() - discount\n\ndef __repr__(self): return f'<Order total: {self.total():.2f} due: {self.due():.2f}>'\n\ndef fidelity_promo(order: Order) -> Decimal: \"\"\"5% discount for customers with 1000 or more fidelity points\"\"\" if order.customer.fidelity >= 1000: return order.total() * Decimal('0.05') return Decimal(0)\n\ndef bulk_item_promo(order: Order) -> Decimal: \"\"\"10% discount for each LineItem with 20 or more units\"\"\" discount = Decimal(0) for item in order.cart: if item.quantity >= 20: discount += item.total() * Decimal('0.1') return discount\n\ndef large_order_promo(order: Order) -> Decimal: \"\"\"7% discount for orders with 10 or more distinct items\"\"\" distinct_items = {item.product for item in order.cart} if len(distinct_items) >= 10: return order.total() * Decimal('0.07') return Decimal(0)\n\nThis type hint says: promotion may be None, or it may be a callable that takes an Order argument and returns a Decimal.\n\nTo compute a discount, call the self.promotion callable, passing self as an argument. See the following tip for the reason.\n\nNo abstract class.\n\nEach strategy is a function.\n\n348\n\n|\n\nChapter 10: Design Patterns with First-Class Functions",
      "content_length": 1227,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 379,
      "content": "Why self.promotion(self)?\n\nIn the Order class, promotion is not a method. It’s an instance attribute that happens to be callable. So the first part of the expres‐ sion, self.promotion, retrieves that callable. To invoke it, we must provide an instance of Order, which in this case is self. That’s why self appears twice in that expression.\n\n“Methods Are Descriptors” on page 898 will explain the mechanism that binds methods to instances automatically. It does not apply to promotion because it is not a method.\n\nThe code in Example 10-3 is shorter than Example 10-1. Using the new Order is also a bit simpler, as shown in the Example 10-4 doctests.\n\nExample 10-4. Sample usage of Order class with promotions as functions\n\n>>> joe = Customer('John Doe', 0) >>> ann = Customer('Ann Smith', 1100) >>> cart = [LineItem('banana', 4, Decimal('.5')), ... LineItem('apple', 10, Decimal('1.5')), ... LineItem('watermelon', 5, Decimal(5))] >>> Order(joe, cart, fidelity_promo) <Order total: 42.00 due: 42.00> >>> Order(ann, cart, fidelity_promo) <Order total: 42.00 due: 39.90> >>> banana_cart = [LineItem('banana', 30, Decimal('.5')), ... LineItem('apple', 10, Decimal('1.5'))] >>> Order(joe, banana_cart, bulk_item_promo) <Order total: 30.00 due: 28.50> >>> long_cart = [LineItem(str(item_code), 1, Decimal(1)) ... for item_code in range(10)] >>> Order(joe, long_cart, large_order_promo) <Order total: 10.00 due: 9.30> >>> Order(joe, cart, large_order_promo) <Order total: 42.00 due: 42.00>\n\nSame test fixtures as Example 10-1.\n\nTo apply a discount strategy to an Order, just pass the promotion function as an argument.\n\nA different promotion function is used here and in the next test.\n\nNote the callouts in Example 10-4—there is no need to instantiate a new promotion object with each new order: the functions are ready to use.\n\nCase Study: Refactoring Strategy\n\n|\n\n349",
      "content_length": 1864,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 380,
      "content": "It is interesting to note that in Design Patterns, the authors suggest: “Strategy objects often make good flyweights.”4 A definition of the Flyweight pattern in another part of that work states: “A flyweight is a shared object that can be used in multiple contexts simultaneously.”5 The sharing is recommended to reduce the cost of creating a new concrete strategy object when the same strategy is applied over and over again with every new context—with every new Order instance, in our example. So, to overcome a drawback of the Strategy pattern—its runtime cost—the authors recommend apply‐ ing yet another pattern. Meanwhile, the line count and maintenance cost of your code are piling up.\n\nA thornier use case, with complex concrete strategies holding internal state, may require all the pieces of the Strategy and Flyweight design patterns combined. But often concrete strategies have no internal state; they only deal with data from the context. If that is the case, then by all means use plain old functions instead of coding single-method classes implementing a single-method interface declared in yet another class. A function is more lightweight than an instance of a user-defined class, and there is no need for Flyweight because each strategy function is created just once per Python process when it loads the module. A plain function is also “a shared object that can be used in multiple contexts simultaneously.”\n\nNow that we have implemented the Strategy pattern with functions, other possibili‐ ties emerge. Suppose you want to create a “metastrategy” that selects the best avail‐ able discount for a given Order. In the following sections we study additional refactorings that implement this requirement using a variety of approaches that lev‐ erage functions and modules as objects.\n\nChoosing the Best Strategy: Simple Approach Given the same customers and shopping carts from the tests in Example 10-4, we now add three additional tests in Example 10-5.\n\nExample 10-5. The best_promo function applies all discounts and returns the largest\n\n>>> Order(joe, long_cart, best_promo) <Order total: 10.00 due: 9.30> >>> Order(joe, banana_cart, best_promo) <Order total: 30.00 due: 28.50> >>> Order(ann, cart, best_promo) <Order total: 42.00 due: 39.90>\n\n4 See page 323 of Design Patterns.\n\n5 Ibid., p. 196.\n\n350\n\n|\n\nChapter 10: Design Patterns with First-Class Functions",
      "content_length": 2382,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 381,
      "content": "best_promo selected the larger_order_promo for customer joe.\n\nHere joe got the discount from bulk_item_promo for ordering lots of bananas.\n\nChecking out with a simple cart, best_promo gave loyal customer ann the dis‐ count for the fidelity_promo.\n\nThe implementation of best_promo is very simple. See Example 10-6.\n\nExample 10-6. best_promo finds the maximum discount iterating over a list of functions\n\npromos = [fidelity_promo, bulk_item_promo, large_order_promo]\n\ndef best_promo(order: Order) -> Decimal: \"\"\"Compute the best discount available\"\"\" return max(promo(order) for promo in promos)\n\npromos: list of the strategies implemented as functions.\n\nbest_promo takes an instance of Order as argument, as do the other *_promo functions.\n\nUsing a generator expression, we apply each of the functions from promos to the order, and return the maximum discount computed.\n\nExample 10-6 is straightforward: promos is a list of functions. Once you get used to the idea that functions are first-class objects, it naturally follows that building data structures holding functions often makes sense.\n\nAlthough Example 10-6 works and is easy to read, there is some duplication that could lead to a subtle bug: to add a new promotion strategy, we need to code the function and remember to add it to the promos list, or else the new promotion will work when explicitly passed as an argument to Order, but will not be considered by best_promotion.\n\nRead on for a couple of solutions to this issue.\n\nFinding Strategies in a Module Modules in Python are also first-class objects, and the standard library provides sev‐ eral functions to handle them. The built-in globals is described as follows in the Python docs:\n\nCase Study: Refactoring Strategy\n\n|\n\n351",
      "content_length": 1743,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 382,
      "content": "globals()\n\nReturn a dictionary representing the current global symbol table. This is always the dictionary of the current module (inside a function or method, this is the module where it is defined, not the module from which it is called).\n\nExample 10-7 is a somewhat hackish way of using globals to help best_promo auto‐ matically find the other available *_promo functions.\n\nExample 10-7. The promos list is built by introspection of the module global namespace\n\nfrom decimal import Decimal from strategy import Order from strategy import ( fidelity_promo, bulk_item_promo, large_order_promo )\n\npromos = [promo for name, promo in globals().items() if name.endswith('_promo') and name != 'best_promo' ]\n\ndef best_promo(order: Order) -> Decimal: \"\"\"Compute the best discount available\"\"\" return max(promo(order) for promo in promos)\n\nImport the promotion functions so they are available in the global namespace.6\n\nIterate over each item in the dict returned by globals().\n\nSelect only values where the name ends with the _promo suffix and…\n\n…filter out best_promo itself, to avoid an infinite recursion when best_promo is called.\n\nNo changes in best_promo.\n\nAnother way of collecting the available promotions would be to create a module and put all the strategy functions there, except for best_promo.\n\nIn Example 10-8, the only significant change is that the list of strategy functions is built by introspection of a separate module called promotions. Note that\n\n6 flake8 and VS Code both complain that these names are imported but not used. By definition, static analysis\n\ntools cannot understand the dynamic nature of Python. If we heed every advice from such tools, we’ll soon be writing grim and verbose Java-like code with Python syntax.\n\n352\n\n|\n\nChapter 10: Design Patterns with First-Class Functions",
      "content_length": 1807,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 383,
      "content": "Example 10-8 depends on importing the promotions module as well as inspect, which provides high-level introspection functions.\n\nExample 10-8. The promos list is built by introspection of a new promotions module\n\nfrom decimal import Decimal import inspect\n\nfrom strategy import Order import promotions\n\npromos = [func for _, func in inspect.getmembers(promotions, inspect.isfunction)]\n\ndef best_promo(order: Order) -> Decimal: \"\"\"Compute the best discount available\"\"\" return max(promo(order) for promo in promos)\n\nThe function inspect.getmembers returns the attributes of an object—in this case, the promotions module—optionally filtered by a predicate (a boolean function). We use inspect.isfunction to get only the functions from the module.\n\nExample 10-8 works regardless of the names given to the functions; all that matters is that the promotions module contains only functions that calculate discounts given orders. Of course, this is an implicit assumption of the code. If someone were to cre‐ ate a function with a different signature in the promotions module, then best_promo would break while trying to apply it to an order.\n\nWe could add more stringent tests to filter the functions, by inspecting their argu‐ ments for instance. The point of Example 10-8 is not to offer a complete solution, but to highlight one possible use of module introspection.\n\nA more explicit alternative to dynamically collecting promotional discount functions would be to use a simple decorator. That’s next.\n\nDecorator-Enhanced Strategy Pattern Recall that our main issue with Example 10-6 is the repetition of the function names in their definitions and then in the promos list used by the best_promo function to determine the highest discount applicable. The repetition is problematic because someone may add a new promotional strategy function and forget to manually add it to the promos list—in which case, best_promo will silently ignore the new strategy, introducing a subtle bug in the system. Example 10-9 solves this problem with the technique covered in “Registration Decorators” on page 308.\n\nDecorator-Enhanced Strategy Pattern\n\n|\n\n353",
      "content_length": 2137,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 384,
      "content": "Example 10-9. The promos list is filled by the Promotion decorator\n\nPromotion = Callable[[Order], Decimal]\n\npromos: list[Promotion] = []\n\ndef promotion(promo: Promotion) -> Promotion: promos.append(promo) return promo\n\ndef best_promo(order: Order) -> Decimal: \"\"\"Compute the best discount available\"\"\" return max(promo(order) for promo in promos)\n\n@promotion def fidelity(order: Order) -> Decimal: \"\"\"5% discount for customers with 1000 or more fidelity points\"\"\" if order.customer.fidelity >= 1000: return order.total() * Decimal('0.05') return Decimal(0)\n\n@promotion def bulk_item(order: Order) -> Decimal: \"\"\"10% discount for each LineItem with 20 or more units\"\"\" discount = Decimal(0) for item in order.cart: if item.quantity >= 20: discount += item.total() * Decimal('0.1') return discount\n\n@promotion def large_order(order: Order) -> Decimal: \"\"\"7% discount for orders with 10 or more distinct items\"\"\" distinct_items = {item.product for item in order.cart} if len(distinct_items) >= 10: return order.total() * Decimal('0.07') return Decimal(0)\n\nThe promos list is a module global, and starts empty.\n\nPromotion is a registration decorator: it returns the promo function unchanged, after appending it to the promos list.\n\nNo changes needed to best_promo, because it relies on the promos list.\n\n354\n\n|\n\nChapter 10: Design Patterns with First-Class Functions",
      "content_length": 1362,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 385,
      "content": "Any function decorated by @promotion will be added to promos.\n\nThis solution has several advantages over the others presented before:\n\nThe promotion strategy functions don’t have to use special names—no need for the _promo suffix.\n\nThe @promotion decorator highlights the purpose of the decorated function, and also makes it easy to temporarily disable a promotion: just comment out the decorator.\n\nPromotional discount strategies may be defined in other modules, anywhere in the system, as long as the @promotion decorator is applied to them.\n\nIn the next section, we discuss Command—another design pattern that is sometimes implemented via single-method classes when plain functions would do.\n\nThe Command Pattern Command is another design pattern that can be simplified by the use of functions passed as arguments. Figure 10-2 shows the arrangement of classes in the Command pattern.\n\nFigure 10-2. UML class diagram for menu-driven text editor implemented with the Command design pattern. Each command may have a different receiver: the object that implements the action. For PasteCommand, the receiver is the Document. For OpenCom mand, the receiver is the application.\n\nThe Command Pattern\n\n|\n\n355",
      "content_length": 1202,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 386,
      "content": "The goal of Command is to decouple an object that invokes an operation (the invoker) from the provider object that implements it (the receiver). In the example from Design Patterns, each invoker is a menu item in a graphical application, and the receivers are the document being edited or the application itself.\n\nThe idea is to put a Command object between the two, implementing an interface with a single method, execute, which calls some method in the receiver to perform the desired operation. That way the invoker does not need to know the interface of the receiver, and different receivers can be adapted through different Command subclasses. The invoker is configured with a concrete command and calls its execute method to operate it. Note in Figure 10-2 that MacroCommand may store a sequence of com‐ mands; its execute() method calls the same method in each command stored.\n\nQuoting from Design Patterns, “Commands are an object-oriented replacement for callbacks.” The question is: do we need an object-oriented replacement for callbacks? Sometimes yes, but not always.\n\nInstead of giving the invoker a Command instance, we can simply give it a function. Instead of calling command.execute(), the invoker can just call command(). The Macro Command can be implemented with a class implementing __call__. Instances of MacroCommand would be callables, each holding a list of functions for future invoca‐ tion, as implemented in Example 10-10.\n\nExample 10-10. Each instance of MacroCommand has an internal list of commands\n\nclass MacroCommand: \"\"\"A command that executes a list of commands\"\"\"\n\ndef __init__(self, commands): self.commands = list(commands)\n\ndef __call__(self): for command in self.commands: command()\n\nBuilding a list from the commands arguments ensures that it is iterable and keeps a local copy of the command references in each MacroCommand instance.\n\nWhen an instance of MacroCommand is invoked, each command in self.commands is called in sequence.\n\nMore advanced uses of the Command pattern—to support undo, for example—may require more than a simple callback function. Even then, Python provides a couple of alternatives that deserve consideration:\n\n356\n\n|\n\nChapter 10: Design Patterns with First-Class Functions",
      "content_length": 2240,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 387,
      "content": "A callable instance like MacroCommand in Example 10-10 can keep whatever state is necessary, and provide extra methods in addition to __call__.\n\nA closure can be used to hold the internal state of a function between calls.\n\nThis concludes our rethinking of the Command pattern with first-class functions. At a high level, the approach here was similar to the one we applied to Strategy: replac‐ ing with callables the instances of a participant class that implemented a single- method interface. After all, every Python callable implements a single-method interface, and that method is named __call__.\n\nChapter Summary As Peter Norvig pointed out a couple of years after the classic Design Patterns book appeared, “16 of 23 patterns have qualitatively simpler implementation in Lisp or Dylan than in C++ for at least some uses of each pattern” (slide 9 of Norvig’s “Design Patterns in Dynamic Languages” presentation). Python shares some of the dynamic features of the Lisp and Dylan languages, in particular, first-class functions, our focus in this part of the book.\n\nFrom the same talk quoted at the start of this chapter, in reflecting on the 20th anni‐ versary of Design Patterns: Elements of Reusable Object-Oriented Software, Ralph Johnson has stated that one of the failings of the book is: “Too much emphasis on patterns as end-points instead of steps in the design process.”7 In this chapter, we used the Strategy pattern as a starting point: a working solution that we could sim‐ plify using first-class functions.\n\nIn many cases, functions or callable objects provide a more natural way of imple‐ menting callbacks in Python than mimicking the Strategy or the Command patterns as described by Gamma, Helm, Johnson, and Vlissides in Design Patterns. The refac‐ toring of Strategy and the discussion of Command in this chapter are examples of a more general insight: sometimes you may encounter a design pattern or an API that requires that components implement an interface with a single method, and that method has a generic-sounding name such as “execute,” “run,” or “do_it.” Such pat‐ terns or APIs often can be implemented with less boilerplate code in Python using functions as first-class objects.\n\n7 “Root Cause Analysis of Some Faults in Design Patterns,” presented by Johnson at IME-USP, November 15,\n\n2014.\n\nChapter Summary\n\n|\n\n357",
      "content_length": 2352,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 388,
      "content": "Further Reading “Recipe 8.21. Implementing the Visitor Pattern,” in the Python Cookbook, 3rd ed., presents an elegant implementation of the Visitor pattern in which a NodeVisitor class handles methods as first-class objects.\n\nOn the general topic of design patterns, the choice of readings for the Python pro‐ grammer is not as broad as what is available to other language communities.\n\nLearning Python Design Patterns, by Gennadiy Zlobin (Packt), is the only book that I have seen entirely devoted to patterns in Python. But Zlobin’s work is quite short (100 pages) and covers 8 of the original 23 design patterns.\n\nExpert Python Programming, by Tarek Ziadé (Packt), is one of the best intermediate- level Python books in the market, and its final chapter, “Useful Design Patterns,” presents several of the classic patterns from a Pythonic perspective.\n\nAlex Martelli has given several talks about Python design patterns. There is a video of his EuroPython 2011 presentation and a set of slides on his personal website. I’ve found different slide decks and videos over the years, of varying lengths, so it is worthwhile to do a thorough search for his name with the words “Python Design Pat‐ terns.” A publisher told me Martelli is working on a book about this subject. I will certainly get it when it comes out.\n\nThere are many books about design patterns in the context of Java, but among them the one I like most is Head First Design Patterns, 2nd ed., by Eric Freeman and Elisa‐ beth Robson (O’Reilly). It explains 16 of the 23 classic patterns. If you like the wacky style of the Head First series and need an introduction to this topic, you will love that work. It is Java-centric, but the second edition was updated to reflect the addition of first-class functions in Java, making some of the examples closer to code we’d write in Python.\n\nFor a fresh look at patterns from the point of view of a dynamic language with duck typing and first-class functions, Design Patterns in Ruby by Russ Olsen (Addison- Wesley) has many insights that are also applicable to Python. In spite of their many syntactic differences, at the semantic level Python and Ruby are closer to each other than to Java or C++.\n\nIn “Design Patterns in Dynamic Languages” (slides), Peter Norvig shows how first- class functions (and other dynamic features) make several of the original design pat‐ terns either simpler or unnecessary.\n\nThe introduction of the original Design Patterns book by Gamma et al. is worth the price of the book—more than the catalog of 23 patterns, which includes recipes rang‐ ing from very important to rarely useful. The widely quoted design principles,\n\n358\n\n|\n\nChapter 10: Design Patterns with First-Class Functions",
      "content_length": 2723,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 389,
      "content": "“Program to an interface, not an implementation” and “Favor object composition over class inheritance,” both come from that introduction.\n\nThe application of patterns to design originated with the architect Christopher Alexander et al., presented in the book A Pattern Language (Oxford University Press). Alexander’s idea is to create a standard vocabulary allowing teams to share common design decisions while designing buildings. M. J. Dominus wrote “‘Design Patterns’ Aren’t”, an intriguing slide deck and postscript text arguing that Alexander’s original vision of patterns is more profound, more human, and also applicable to software engineering.\n\nSoapbox Python has first-class functions and first-class types, features that Norvig claims affect 10 of the 23 patterns (slide 10 of “Design Patterns in Dynamic Languages”). In Chap‐ ter 9, we saw that Python also has generic functions (“Single Dispatch Generic Func‐ tions” on page 324), a limited form of the CLOS multimethods that Gamma et al. suggest as a simpler way to implement the classic Visitor pattern. Norvig, on the other hand, says that multimethods simplify the Builder pattern (slide 10). Matching design patterns to language features is not an exact science.\n\nIn classrooms around the world, design patterns are frequently taught using Java examples. I’ve heard more than one student claim that they were led to believe that the original design patterns are useful in any implementation language. It turns out that the “classic” 23 patterns from Design Patterns apply to “classic” Java very well in spite of being originally presented mostly in the context of C++—a few have Small‐ talk examples in the book. But that does not mean every one of those patterns applies equally well in any language. The authors are explicit right at the beginning of their book that “some of our patterns are supported directly by the less common object- oriented languages” (recall full quote on the first page of this chapter).\n\nThe Python bibliography about design patterns is very thin, compared to that of Java, C++, or Ruby. In “Further Reading” on page 358 I mentioned Learning Python Design Patterns by Gennadiy Zlobin, which was published as recently as November 2013. In contrast, Russ Olsen’s Design Patterns in Ruby was published in 2007 and has 384 pages—284 more than Zlobin’s work.\n\nNow that Python is becoming increasingly popular in academia, let’s hope more will be written about design patterns in the context of this language. Also, Java 8 intro‐ duced method references and anonymous functions, and those highly anticipated features are likely to prompt fresh approaches to patterns in Java—recognizing that as languages evolve, so must our understanding of how to apply the classic design patterns.\n\nFurther Reading\n\n|\n\n359",
      "content_length": 2799,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 390,
      "content": "The call of the Wild\n\nAs we collaborated to put the final touches to this book, tech reviewer Leonardo Rochael wondered:\n\nIf functions have a __call__ method, and methods are also callable, do __call__ methods also have a __call__ method?\n\nI don’t know if his discovery is useful, but it is a fun fact:\n\n>>> def turtle(): ... return 'eggs' ... >>> turtle() 'eggs' >>> turtle.__call__() 'eggs' >>> turtle.__call__.__call__() 'eggs' >>> turtle.__call__.__call__.__call__() 'eggs' >>> turtle.__call__.__call__.__call__.__call__() 'eggs' >>> turtle.__call__.__call__.__call__.__call__.__call__() 'eggs' >>> turtle.__call__.__call__.__call__.__call__.__call__.__call__() 'eggs' >>> turtle.__call__.__call__.__call__.__call__.__call__.__call__.__call__() 'eggs'\n\nTurtles all the way down!\n\n360\n\n|\n\nChapter 10: Design Patterns with First-Class Functions",
      "content_length": 846,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 391,
      "content": "PART III Classes and Protocols",
      "content_length": 30,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 393,
      "content": "CHAPTER 11 A Pythonic Object\n\nFor a library or framework to be Pythonic is to make it as easy and natural as possible for a Python programmer to pick up how to perform a task.\n\n—Martijn Faassen, creator of Python and JavaScript frameworks.1\n\nThanks to the Python Data Model, your user-defined types can behave as naturally as the built-in types. And this can be accomplished without inheritance, in the spirit of duck typing: you just implement the methods needed for your objects to behave as expected.\n\nIn previous chapters, we studied the behavior of many built-in objects. We will now build user-defined classes that behave as real Python objects. Your application classes probably don’t need and should not implement as many special methods as the examples in this chapter. But if you are writing a library or a framework, the pro‐ grammers who will use your classes may expect them to behave like the classes that Python provides. Fulfilling that expectation is one way of being “Pythonic.”\n\nThis chapter starts where Chapter 1 ended, by showing how to implement several special methods that are commonly seen in Python objects of many different types.\n\nIn this chapter, we will see how to:\n\nSupport the built-in functions that convert objects to other types (e.g., repr(), bytes(), complex(), etc.)\n\nImplement an alternative constructor as a class method • Extend the format mini-language used by f-strings, the format() built-in, and the str.format() method\n\n1 From Faassen’s blog post, “What is Pythonic?”\n\n363",
      "content_length": 1519,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 394,
      "content": "Provide read-only access to attributes • Make an object hashable for use in sets and as dict keys • Save memory with the use of __slots__\n\nWe’ll do all that as we develop Vector2d, a simple two-dimensional Euclidean vector type. This code will be the foundation of an N-dimensional vector class in Chapter 12.\n\nThe evolution of the example will be paused to discuss two conceptual topics:\n\nHow and when to use the @classmethod and @staticmethod decorators\n\nPrivate and protected attributes in Python: usage, conventions, and limitations\n\nWhat’s New in This Chapter I added a new epigraph and a few words in the second paragraph of the chapter to address the concept of “Pythonic”—which was only discussed at the very end in the first edition.\n\n“Formatted Displays” on page 370 was updated to mention f-strings, introduced in Python 3.6. It’s a small change because f-strings support the same formatting mini- language as the format() built-in and the str.format() method, so any previously implemented __format__ methods simply work with f-strings.\n\nThe rest of the chapter barely changed—the special methods are mostly the same since Python 3.0, and the core ideas appeared in Python 2.2.\n\nLet’s get started with the object representation methods.\n\nObject Representations Every object-oriented language has at least one standard way of getting a string repre‐ sentation from any object. Python has two:\n\nrepr()\n\nReturn a string representing the object as the developer wants to see it. It’s what you get when the Python console or a debugger shows an object.\n\nstr()\n\nReturn a string representing the object as the user wants to see it. It’s what you get when you print() an object.\n\nThe special methods __repr__ and __str__ support repr() and str(), as we saw in Chapter 1.\n\n364\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 1813,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 395,
      "content": "There are two additional special methods to support alternative representations of objects: __bytes__ and __format__. The __bytes__ method is analogous to __str__: it’s called by bytes() to get the object represented as a byte sequence. Regarding __format__, it is used by f-strings, by the built-in function format(), and by the str.format() method. They call obj.__format__(format_spec) to get string dis‐ plays of objects using special formatting codes. We’ll cover __bytes__ in the next example, and __format__ after that.\n\nIf you’re coming from Python 2, remember that in Python 3 __repr__, __str__, and __format__ must always return Unicode strings (type str). Only __bytes__ is supposed to return a byte sequence (type bytes).\n\nVector Class Redux In order to demonstrate the many methods used to generate object representations, we’ll use a Vector2d class similar to the one we saw in Chapter 1. We will build on it in this and future sections. Example 11-1 illustrates the basic behavior we expect from a Vector2d instance.\n\nExample 11-1. Vector2d instances have several representations\n\n>>> v1 = Vector2d(3, 4) >>> print(v1.x, v1.y) 3.0 4.0 >>> x, y = v1 >>> x, y (3.0, 4.0) >>> v1 Vector2d(3.0, 4.0) >>> v1_clone = eval(repr(v1)) >>> v1 == v1_clone True >>> print(v1) (3.0, 4.0) >>> octets = bytes(v1) >>> octets b'd\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x08@\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x10@' >>> abs(v1) 5.0 >>> bool(v1), bool(Vector2d(0, 0)) (True, False)\n\nVector Class Redux\n\n|\n\n365",
      "content_length": 1492,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 396,
      "content": "The components of a Vector2d can be accessed directly as attributes (no getter method calls).\n\nA Vector2d can be unpacked to a tuple of variables.\n\nThe repr of a Vector2d emulates the source code for constructing the instance.\n\nUsing eval here shows that the repr of a Vector2d is a faithful representation of its constructor call.2\n\nVector2d supports comparison with ==; this is useful for testing.\n\nprint calls str, which for Vector2d produces an ordered pair display.\n\nbytes uses the __bytes__ method to produce a binary representation.\n\nabs uses the __abs__ method to return the magnitude of the Vector2d.\n\nbool uses the __bool__ method to return False for a Vector2d of zero magni‐ tude or True otherwise.\n\nVector2d from Example 11-1 is implemented in vector2d_v0.py (Example 11-2). The code is based on Example 1-2, except for the methods for the + and * operations, which we’ll see later in Chapter 16. We’ll add the method for == since it’s useful for testing. At this point, Vector2d uses several special methods to provide operations that a Pythonista expects in a well-designed object.\n\nExample 11-2. vector2d_v0.py: methods so far are all special methods\n\nfrom array import array import math\n\nclass Vector2d: typecode = 'd'\n\ndef __init__(self, x, y): self.x = float(x) self.y = float(y)\n\ndef __iter__(self): return (i for i in (self.x, self.y))\n\n2 I used eval to clone the object here just to make a point about repr; to clone an instance, the copy.copy\n\nfunction is safer and faster.\n\n366\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 1535,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 397,
      "content": "def __repr__(self): class_name = type(self).__name__ return '{}({!r}, {!r})'.format(class_name, *self)\n\ndef __str__(self): return str(tuple(self))\n\ndef __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self)))\n\ndef __eq__(self, other): return tuple(self) == tuple(other)\n\ndef __abs__(self): return math.hypot(self.x, self.y)\n\ndef __bool__(self): return bool(abs(self))\n\ntypecode is a class attribute we’ll use when converting Vector2d instances to/ from bytes.\n\nConverting x and y to float in __init__ catches errors early, which is helpful in case Vector2d is called with unsuitable arguments.\n\n__iter__ makes a Vector2d iterable; this is what makes unpacking work (e.g, x, y = my_vector). We implement it simply by using a generator expression to yield the components one after the other.3\n\n__repr__ builds a string by interpolating the components with {!r} to get their repr; because Vector2d is iterable, *self feeds the x and y components to format.\n\nFrom an iterable Vector2d, it’s easy to build a tuple for display as an ordered pair.\n\nTo generate bytes, we convert the typecode to bytes and concatenate…\n\n…bytes converted from an array built by iterating over the instance.\n\n3 This line could also be written as yield self.x; yield.self.y. I have a lot more to say about the __iter__\n\nspecial method, generator expressions, and the yield keyword in Chapter 17.\n\nVector Class Redux\n\n|\n\n367",
      "content_length": 1428,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 398,
      "content": "To quickly compare all components, build tuples out of the operands. This works for operands that are instances of Vector2d, but has issues. See the following warning.\n\nThe magnitude is the length of the hypotenuse of the right triangle formed by the x and y components.\n\n__bool__ uses abs(self) to compute the magnitude, then converts it to bool, so 0.0 becomes False, nonzero is True.\n\nMethod __eq__ in Example 11-2 works for Vector2d operands but also returns True when comparing Vector2d instances to other iterables holding the same numeric values (e.g., Vector(3, 4) == [3, 4]). This may be considered a feature or a bug. Further discus‐ sion needs to wait until Chapter 16, when we cover operator over‐ loading.\n\nWe have a fairly complete set of basic methods, but we still need a way to rebuild a Vector2d from the binary representation produced by bytes().\n\nAn Alternative Constructor Since we can export a Vector2d as bytes, naturally we need a method that imports a Vector2d from a binary sequence. Looking at the standard library for inspiration, we find that array.array has a class method named .frombytes that suits our purpose —we saw it in “Arrays” on page 59. We adopt its name and use its functionality in a class method for Vector2d in vector2d_v1.py (Example 11-3).\n\nExample 11-3. Part of vector2d_v1.py: this snippet shows only the frombytes class method, added to the Vector2d definition in vector2d_v0.py (Example 11-2)\n\n@classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(*memv)\n\nThe classmethod decorator modifies a method so it can be called directly on a class.\n\nNo self argument; instead, the class itself is passed as the first argument—con‐ ventionally named cls.\n\n368\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 1804,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 399,
      "content": "Read the typecode from the first byte.\n\nCreate a memoryview from the octets binary sequence and use the typecode to cast it.4\n\nUnpack the memoryview resulting from the cast into the pair of arguments needed for the constructor.\n\nI just used a classmethod decorator and it is very Python specific, so let’s have a word about it.\n\nclassmethod Versus staticmethod The classmethod decorator is not mentioned in the Python tutorial, and neither is staticmethod. Anyone who has learned OO in Java may wonder why Python has both of these decorators and not just one of them.\n\nLet’s start with classmethod. Example 11-3 shows its use: to define a method that operates on the class and not on instances. classmethod changes the way the method is called, so it receives the class itself as the first argument, instead of an instance. Its most common use is for alternative constructors, like frombytes in Example 11-3. Note how the last line of frombytes actually uses the cls argument by invoking it to build a new instance: cls(*memv).\n\nIn contrast, the staticmethod decorator changes a method so that it receives no spe‐ cial first argument. In essence, a static method is just like a plain function that hap‐ pens to live in a class body, instead of being defined at the module level. Example 11-4 contrasts the operation of classmethod and staticmethod.\n\nExample 11-4. Comparing behaviors of classmethod and staticmethod\n\n>>> class Demo: ... @classmethod ... def klassmeth(*args): ... return args ... @staticmethod ... def statmeth(*args): ... return args ... >>> Demo.klassmeth() (<class '__main__.Demo'>,) >>> Demo.klassmeth('spam')\n\n4 We had a brief introduction to memoryview, explaining its .cast method, in “Memory Views” on page 62.\n\nclassmethod Versus staticmethod\n\n|\n\n369",
      "content_length": 1775,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 400,
      "content": "(<class '__main__.Demo'>, 'spam') >>> Demo.statmeth() () >>> Demo.statmeth('spam') ('spam',)\n\nklassmeth just returns all positional arguments.\n\nstatmeth does the same.\n\nNo matter how you invoke it, Demo.klassmeth receives the Demo class as the first argument.\n\nDemo.statmeth behaves just like a plain old function.\n\nThe classmethod decorator is clearly useful, but good use cases for staticmethod are very rare in my experience. Maybe the function is closely related even if it never touches the class, so you may want to place it nearby in the code. Even then, defining the function right before or after the class in the same module is close enough most of the time.5\n\nNow that we’ve seen what classmethod is good for (and that staticmethod is not very useful), let’s go back to the issue of object representation and see how to support formatted output.\n\nFormatted Displays The f-strings, the format() built-in function, and the str.format() method delegate the actual formatting to each type by calling their .__format__(format_spec) method. The format_spec is a formatting specifier, which is either:\n\nThe second argument in format(my_obj, format_spec), or • Whatever appears after the colon in a replacement field delimited with {} inside an f-string or the fmt in fmt.str.format()\n\n5 Leonardo Rochael, one of the technical reviewers of this book, disagrees with my low opinion of staticme\n\nthod, and recommends the blog post “The Definitive Guide on How to Use Static, Class or Abstract Methods in Python” by Julien Danjou as a counterargument. Danjou’s post is very good; I do recommend it. But it wasn’t enough to change my mind about staticmethod. You’ll have to decide for yourself.\n\n370\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 1732,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 401,
      "content": "For example:\n\n>>> brl = 1 / 4.82 # BRL to USD currency conversion rate >>> brl 0.20746887966804978 >>> format(brl, '0.4f') '0.2075' >>> '1 BRL = {rate:0.2f} USD'.format(rate=brl) '1 BRL = 0.21 USD' >>> f'1 USD = {1 / brl:0.2f} BRL' '1 USD = 4.82 BRL'\n\nFormatting specifier is '0.4f'.\n\nFormatting specifier is '0.2f'. The rate part in the replacement field is not part of the formatting specifier. It determines which keyword argument of .format() goes into that replacement field.\n\nAgain, the specifier is '0.2f'. The 1 / brl expression is not part of it.\n\nThe second and third callouts make an important point: a format string such as '{0.mass:5.3e}' actually uses two separate notations. The '0.mass' to the left of the colon is the field_name part of the replacement field syntax, and it can be an arbi‐ trary expression in an f-string. The '5.3e' after the colon is the formatting specifier. The notation used in the formatting specifier is called the Format Specification Mini- Language.\n\nIf f-strings, format(), and str.format() are new to you, classroom experience tells me it’s best to study the format() built-in function first, which uses just the Format Specification Mini-Language. After you get the gist of that, read “Formatted string literals” and “Format String Syntax” to learn about the {:} replacement field notation, used in f-strings and the str.format() method (includ‐ ing the !s, !r, and !a conversion flags). F-strings don’t make str.format() obsolete: most of the time f-strings solve the prob‐ lem, but sometimes it’s better to specify the formatting string else‐ where, and not where it will be rendered.\n\nA few built-in types have their own presentation codes in the Format Specification Mini-Language. For example—among several other codes—the int type supports b and x for base 2 and base 16 output, respectively, while float implements f for a fixed-point display and % for a percentage display:\n\n>>> format(42, 'b') '101010'\n\nFormatted Displays\n\n|\n\n371",
      "content_length": 1985,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 402,
      "content": ">>> format(2 / 3, '.1%') '66.7%'\n\nThe Format Specification Mini-Language is extensible because each class gets to interpret the format_spec argument as it likes. For instance, the classes in the date time module use the same format codes in the strftime() functions and in their __format__ methods. Here are a couple of examples using the format() built-in and the str.format() method:\n\n>>> from datetime import datetime >>> now = datetime.now() >>> format(now, '%H:%M:%S') '18:49:05' >>> \"It's now {:%I:%M %p}\".format(now) \"It's now 06:49 PM\"\n\nIf a class has no __format__, the method inherited from object returns str(my_object). Because Vector2d has a __str__, this works:\n\n>>> v1 = Vector2d(3, 4) >>> format(v1) '(3.0, 4.0)'\n\nHowever, if you pass a format specifier, object.__format__ raises TypeError:\n\n>>> format(v1, '.3f') Traceback (most recent call last): ... TypeError: non-empty format string passed to object.__format__\n\nWe will fix that by implementing our own format mini-language. The first step will be to assume the format specifier provided by the user is intended to format each float component of the vector. This is the result we want:\n\n>>> v1 = Vector2d(3, 4) >>> format(v1) '(3.0, 4.0)' >>> format(v1, '.2f') '(3.00, 4.00)' >>> format(v1, '.3e') '(3.000e+00, 4.000e+00)'\n\nExample 11-5 implements __format__ to produce the displays just shown.\n\nExample 11-5. Vector2d.__format__ method, take #1\n\n# inside the Vector2d class\n\ndef __format__(self, fmt_spec=''): components = (format(c, fmt_spec) for c in self) return '({}, {})'.format(*components)\n\n372\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 1607,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 403,
      "content": "Use the format built-in to apply the fmt_spec to each vector component, build‐ ing an iterable of formatted strings.\n\nPlug the formatted strings in the formula '(x, y)'.\n\nNow let’s add a custom formatting code to our mini-language: if the format specifier ends with a 'p', we’ll display the vector in polar coordinates: <r, θ>, where r is the magnitude and θ (theta) is the angle in radians. The rest of the format specifier (whatever comes before the 'p') will be used as before.\n\nWhen choosing the letter for the custom format code, I avoided overlapping with codes used by other types. In Format Specifica‐ tion Mini-Language, we see that integers use the codes 'bcdoxXn', floats use 'eEfFgGn%', and strings use 's'. So I picked 'p' for polar coordinates. Because each class interprets these codes inde‐ pendently, reusing a code letter in a custom format for a new type is not an error, but may be confusing to users.\n\nTo generate polar coordinates, we already have the __abs__ method for the magni‐ tude, and we’ll code a simple angle method using the math.atan2() function to get the angle. This is the code:\n\n# inside the Vector2d class\n\ndef angle(self): return math.atan2(self.y, self.x)\n\nWith that, we can enhance our __format__ to produce polar coordinates. See Example 11-6.\n\nExample 11-6. Vector2d.__format__ method, take #2, now with polar coordinates\n\ndef __format__(self, fmt_spec=''): if fmt_spec.endswith('p'): fmt_spec = fmt_spec[:-1] coords = (abs(self), self.angle()) outer_fmt = '<{}, {}>' else: coords = self outer_fmt = '({}, {})' components = (format(c, fmt_spec) for c in coords) return outer_fmt.format(*components)\n\nFormat ends with 'p': use polar coordinates.\n\nRemove 'p' suffix from fmt_spec.\n\nFormatted Displays\n\n|\n\n373",
      "content_length": 1749,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 404,
      "content": "Build tuple of polar coordinates: (magnitude, angle).\n\nConfigure outer format with angle brackets.\n\nOtherwise, use x, y components of self for rectangular coordinates.\n\nConfigure outer format with parentheses.\n\nGenerate iterable with components as formatted strings.\n\nPlug formatted strings into outer format.\n\nWith Example 11-6, we get results similar to these:\n\n>>> format(Vector2d(1, 1), 'p') '<1.4142135623730951, 0.7853981633974483>' >>> format(Vector2d(1, 1), '.3ep') '<1.414e+00, 7.854e-01>' >>> format(Vector2d(1, 1), '0.5fp') '<1.41421, 0.78540>'\n\nAs this section shows, it’s not hard to extend the Format Specification Mini- Language to support user-defined types.\n\nNow let’s move to a subject that’s not just about appearances: we will make our Vector2d hashable, so we can build sets of vectors, or use them as dict keys.\n\nA Hashable Vector2d As defined, so far our Vector2d instances are unhashable, so we can’t put them in a set:\n\n>>> v1 = Vector2d(3, 4) >>> hash(v1) Traceback (most recent call last): ... TypeError: unhashable type: 'Vector2d' >>> set([v1]) Traceback (most recent call last): ... TypeError: unhashable type: 'Vector2d'\n\nTo make a Vector2d hashable, we must implement __hash__ (__eq__ is also required, and we already have it). We also need to make vector instances immutable, as we’ve seen in “What Is Hashable” on page 84.\n\n374\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 1395,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 405,
      "content": "Right now, anyone can do v1.x = 7, and there is nothing in the code to suggest that changing a Vector2d is forbidden. This is the behavior we want:\n\n>>> v1.x, v1.y (3.0, 4.0) >>> v1.x = 7 Traceback (most recent call last): ... AttributeError: can't set attribute\n\nWe’ll do that by making the x and y components read-only properties in Example 11-7.\n\nExample 11-7. vector2d_v3.py: only the changes needed to make Vector2d immutable are shown here; see full listing in Example 11-11\n\nclass Vector2d: typecode = 'd'\n\ndef __init__(self, x, y): self.__x = float(x) self.__y = float(y)\n\n@property def x(self): return self.__x\n\n@property def y(self): return self.__y\n\ndef __iter__(self): return (i for i in (self.x, self.y))\n\n# remaining methods: same as previous Vector2d\n\nUse exactly two leading underscores (with zero or one trailing underscore) to make an attribute private.6\n\nThe @property decorator marks the getter method of a property.\n\nThe getter method is named after the public property it exposes: x.\n\nJust return self.__x.\n\n6 The pros and cons of private attributes are the subject of the upcoming “Private and ‘Protected’ Attributes in\n\nPython” on page 382.\n\nA Hashable Vector2d\n\n|\n\n375",
      "content_length": 1193,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 406,
      "content": "Repeat the same formula for y property.\n\nEvery method that just reads the x, y components can stay as it was, reading the public properties via self.x and self.y instead of the private attribute, so this listing omits the rest of the code for the class.\n\nVector.x and Vector.y are examples of read-only properties. Read/write properties will be covered in Chapter 22, where we dive deeper into @property.\n\nNow that our vectors are reasonably safe from accidental mutation, we can imple‐ ment the __hash__ method. It should return an int and ideally take into account the hashes of the object attributes that are also used in the __eq__ method, because objects that compare equal should have the same hash. The __hash__ special method documentation suggests computing the hash of a tuple with the components, so that’s what we do in Example 11-8.\n\nExample 11-8. vector2d_v3.py: implementation of hash\n\n# inside class Vector2d:\n\ndef __hash__(self): return hash((self.x, self.y))\n\nWith the addition of the __hash__ method, we now have hashable vectors:\n\n>>> v1 = Vector2d(3, 4) >>> v2 = Vector2d(3.1, 4.2) >>> hash(v1), hash(v2) (1079245023883434373, 1994163070182233067) >>> {v1, v2} {Vector2d(3.1, 4.2), Vector2d(3.0, 4.0)}\n\nIt’s not strictly necessary to implement properties or otherwise protect the instance attributes to create a hashable type. Imple‐ menting __hash__ and __eq__ correctly is all it takes. But the value of a hashable object is never supposed to change, so this provided a good excuse to talk about read-only properties.\n\nIf you are creating a type that has a sensible scalar numeric value, you may also implement the __int__ and __float__ methods, invoked by the int() and float() constructors, which are used for type coercion in some contexts. There is also a\n\n376\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 1821,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 407,
      "content": "__complex__ method to support the complex() built-in constructor. Perhaps Vec tor2d should provide __complex__, but I’ll leave that as an exercise for you.\n\nSupporting Positional Pattern Matching So far, Vector2d instances are compatible with keyword class patterns—covered in “Keyword Class Patterns” on page 193.\n\nIn Example 11-9, all of these keyword patterns work as expected.\n\nExample 11-9. Keyword patterns for Vector2d subjects—requires Python 3.10\n\ndef keyword_pattern_demo(v: Vector2d) -> None: match v: case Vector2d(x=0, y=0): print(f'{v!r} is null') case Vector2d(x=0): print(f'{v!r} is vertical') case Vector2d(y=0): print(f'{v!r} is horizontal') case Vector2d(x=x, y=y) if x==y: print(f'{v!r} is diagonal') case _: print(f'{v!r} is awesome')\n\nHowever, if you try to use a positional pattern like this:\n\ncase Vector2d(_, 0): print(f'{v!r} is horizontal')\n\nyou get:\n\nTypeError: Vector2d() accepts 0 positional sub-patterns (1 given)\n\nTo make Vector2d work with positional patterns, we need to add a class attribute named __match_args__ , listing the instance attributes in the order they will be used for positional pattern matching:\n\nclass Vector2d: __match_args__ = ('x', 'y')\n\n# etc...\n\nNow we can save a few keystrokes when writing patterns to match Vector2d subjects, as you can see in Example 11-10.\n\nExample 11-10. Positional patterns for Vector2d subjects—requires Python 3.10\n\ndef positional_pattern_demo(v: Vector2d) -> None: match v:\n\nSupporting Positional Pattern Matching\n\n|\n\n377",
      "content_length": 1504,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 408,
      "content": "case Vector2d(0, 0): print(f'{v!r} is null') case Vector2d(0): print(f'{v!r} is vertical') case Vector2d(_, 0): print(f'{v!r} is horizontal') case Vector2d(x, y) if x==y: print(f'{v!r} is diagonal') case _: print(f'{v!r} is awesome')\n\nThe __match_args__ class attribute does not need to include all public instance attributes. In particular, if the class __init__ has required and optional arguments that are assigned to instance attributes, it may be reasonable to name the required arguments in __match_args__, but not the optional ones.\n\nLet’s step back and review what we’ve coded so far in Vector2d.\n\nComplete Listing of Vector2d, Version 3 We have been working on Vector2d for a while, showing just snippets, so Example 11-11 is a consolidated, full listing of vector2d_v3.py, including the doctests I used when developing it.\n\nExample 11-11. vector2d_v3.py: the full monty\n\n\"\"\" A two-dimensional vector class\n\n>>> v1 = Vector2d(3, 4) >>> print(v1.x, v1.y) 3.0 4.0 >>> x, y = v1 >>> x, y (3.0, 4.0) >>> v1 Vector2d(3.0, 4.0) >>> v1_clone = eval(repr(v1)) >>> v1 == v1_clone True >>> print(v1) (3.0, 4.0) >>> octets = bytes(v1) >>> octets b'd\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x08@\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x10@' >>> abs(v1) 5.0 >>> bool(v1), bool(Vector2d(0, 0)) (True, False)\n\n378\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 1324,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 409,
      "content": "Test of ``.frombytes()`` class method:\n\n>>> v1_clone = Vector2d.frombytes(bytes(v1)) >>> v1_clone Vector2d(3.0, 4.0) >>> v1 == v1_clone True\n\nTests of ``format()`` with Cartesian coordinates:\n\n>>> format(v1) '(3.0, 4.0)' >>> format(v1, '.2f') '(3.00, 4.00)' >>> format(v1, '.3e') '(3.000e+00, 4.000e+00)'\n\nTests of the ``angle`` method::\n\n>>> Vector2d(0, 0).angle() 0.0 >>> Vector2d(1, 0).angle() 0.0 >>> epsilon = 10**-8 >>> abs(Vector2d(0, 1).angle() - math.pi/2) < epsilon True >>> abs(Vector2d(1, 1).angle() - math.pi/4) < epsilon True\n\nTests of ``format()`` with polar coordinates:\n\n>>> format(Vector2d(1, 1), 'p') # doctest:+ELLIPSIS '<1.414213..., 0.785398...>' >>> format(Vector2d(1, 1), '.3ep') '<1.414e+00, 7.854e-01>' >>> format(Vector2d(1, 1), '0.5fp') '<1.41421, 0.78540>'\n\nTests of `x` and `y` read-only properties:\n\n>>> v1.x, v1.y (3.0, 4.0) >>> v1.x = 123 Traceback (most recent call last): ... AttributeError: can't set attribute 'x'\n\nComplete Listing of Vector2d, Version 3\n\n|\n\n379",
      "content_length": 999,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 410,
      "content": "Tests of hashing:\n\n>>> v1 = Vector2d(3, 4) >>> v2 = Vector2d(3.1, 4.2) >>> len({v1, v2}) 2\n\n\"\"\"\n\nfrom array import array import math\n\nclass Vector2d: __match_args__ = ('x', 'y')\n\ntypecode = 'd'\n\ndef __init__(self, x, y): self.__x = float(x) self.__y = float(y)\n\n@property def x(self): return self.__x\n\n@property def y(self): return self.__y\n\ndef __iter__(self): return (i for i in (self.x, self.y))\n\ndef __repr__(self): class_name = type(self).__name__ return '{}({!r}, {!r})'.format(class_name, *self)\n\ndef __str__(self): return str(tuple(self))\n\ndef __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self)))\n\ndef __eq__(self, other): return tuple(self) == tuple(other)\n\ndef __hash__(self): return hash((self.x, self.y))\n\ndef __abs__(self):\n\n380\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 812,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 411,
      "content": "return math.hypot(self.x, self.y)\n\ndef __bool__(self): return bool(abs(self))\n\ndef angle(self): return math.atan2(self.y, self.x)\n\ndef __format__(self, fmt_spec=''): if fmt_spec.endswith('p'): fmt_spec = fmt_spec[:-1] coords = (abs(self), self.angle()) outer_fmt = '<{}, {}>' else: coords = self outer_fmt = '({}, {})' components = (format(c, fmt_spec) for c in coords) return outer_fmt.format(*components)\n\n@classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(*memv)\n\nTo recap, in this and the previous sections, we saw some essential special methods that you may want to implement to have a full-fledged object.\n\nYou should only implement these special methods if your applica‐ tion needs them. End users don’t care if the objects that make up the application are “Pythonic” or not.\n\nOn the other hand, if your classes are part of a library for other Python programmers to use, you can’t really guess what they will do with your objects, and they may expect more of the “Pythonic” behaviors we are describing.\n\nAs coded in Example 11-11, Vector2d is a didactic example with a laundry list of spe‐ cial methods related to object representation, not a template for every user-defined class.\n\nIn the next section, we’ll take a break from Vector2d to discuss the design and draw‐ backs of the private attribute mechanism in Python—the double-underscore prefix in self.__x.\n\nComplete Listing of Vector2d, Version 3\n\n|\n\n381",
      "content_length": 1489,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 412,
      "content": "Private and “Protected” Attributes in Python In Python, there is no way to create private variables like there is with the private modifier in Java. What we have in Python is a simple mechanism to prevent acciden‐ tal overwriting of a “private” attribute in a subclass.\n\nConsider this scenario: someone wrote a class named Dog that uses a mood instance attribute internally, without exposing it. You need to subclass Dog as Beagle. If you create your own mood instance attribute without being aware of the name clash, you will clobber the mood attribute used by the methods inherited from Dog. This would be a pain to debug.\n\nTo prevent this, if you name an instance attribute in the form __mood (two leading underscores and zero or at most one trailing underscore), Python stores the name in the instance __dict__ prefixed with a leading underscore and the class name, so in the Dog class, __mood becomes _Dog__mood, and in Beagle it’s _Beagle__mood. This language feature goes by the lovely name of name mangling.\n\nExample 11-12 shows the result in the Vector2d class from Example 11-7.\n\nExample 11-12. Private attribute names are “mangled” by prefixing the _ and the class name\n\n>>> v1 = Vector2d(3, 4) >>> v1.__dict__ {'_Vector2d__y': 4.0, '_Vector2d__x': 3.0} >>> v1._Vector2d__x 3.0\n\nName mangling is about safety, not security: it’s designed to prevent accidental access and not malicious prying. Figure 11-1 illustrates another safety device.\n\nAnyone who knows how private names are mangled can read the private attribute directly, as the last line of Example 11-12 shows—that’s actually useful for debugging and serialization. They can also directly assign a value to a private component of a Vector2d by writing v1._Vector2d__x = 7. But if you are doing that in production code, you can’t complain if something blows up.\n\nThe name mangling functionality is not loved by all Pythonistas, and neither is the skewed look of names written as self.__x. Some prefer to avoid this syntax and use just one underscore prefix to “protect” attributes by convention (e.g., self._x). Crit‐ ics of the automatic double-underscore mangling suggest that concerns about acci‐ dental attribute clobbering should be addressed by naming conventions. Ian Bicking —creator of pip, virtualenv, and other projects—wrote:\n\n382\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 2345,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 413,
      "content": "Never, ever use two leading underscores. This is annoyingly private. If name clashes are a concern, use explicit name mangling instead (e.g., _MyThing_blahblah). This is essentially the same thing as double-underscore, only it’s transparent where double underscore obscures.7\n\nFigure 11-1. A cover on a switch is a safety device, not a security one: it prevents acci‐ dents, not sabotage.\n\nThe single underscore prefix has no special meaning to the Python interpreter when used in attribute names, but it’s a very strong convention among Python program‐ mers that you should not access such attributes from outside the class.8 It’s easy to respect the privacy of an object that marks its attributes with a single _, just as it’s easy respect the convention that variables in ALL_CAPS should be treated as constants.\n\nAttributes with a single _ prefix are called “protected” in some corners of the Python documentation.9 The practice of “protecting” attributes by convention with the form self._x is widespread, but calling that a “protected” attribute is not so common. Some even call that a “private” attribute.\n\n7 From the “Paste Style Guide”.\n\n8 In modules, a single _ in front of a top-level name does have an effect: if you write from mymod import *, the names with a _ prefix are not imported from mymod. However, you can still write from mymod import _priva tefunc. This is explained in the Python Tutorial, section 6.1., “More on Modules”.\n\n9 One example is in the gettext module docs.\n\nPrivate and “Protected” Attributes in Python\n\n|\n\n383",
      "content_length": 1547,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 414,
      "content": "To conclude: the Vector2d components are “private” and our Vector2d instances are “immutable”—with scare quotes—because there is no way to make them really pri‐ vate and immutable.10\n\nWe’ll now come back to our Vector2d class. In the next section, we cover a special attribute (not a method) that affects the internal storage of an object, with potentially huge impact on the use of memory but little effect on its public interface: __slots__.\n\nSaving Memory with __slots__ By default, Python stores the attributes of each instance in a dict named __dict__. As we saw in “Practical Consequences of How dict Works” on page 102, a dict has a significant memory overhead—even with the optimizations mentioned in that sec‐ tion. But if you define a class attribute named __slots__ holding a sequence of attribute names, Python uses an alternative storage model for the instance attributes: the attributes named in __slots__ are stored in a hidden array or references that use less memory than a dict. Let’s see how that works through simple examples, starting with Example 11-13.\n\nExample 11-13. The Pixel class uses __slots__\n\n>>> class Pixel: ... __slots__ = ('x', 'y') ... >>> p = Pixel() >>> p.__dict__ Traceback (most recent call last): ... AttributeError: 'Pixel' object has no attribute '__dict__' >>> p.x = 10 >>> p.y = 20 >>> p.color = 'red' Traceback (most recent call last): ... AttributeError: 'Pixel' object has no attribute 'color'\n\n__slots__ must be present when the class is created; adding or changing it later has no effect. The attribute names may be in a tuple or list, but I prefer a tuple to make it clear there’s no point in changing it.\n\n10 If this state of affairs depresses you, and makes you wish Python was more like Java in this regard, don’t read\n\nmy discussion of the relative strength of the Java private modifier in “Soapbox” on page 394.\n\n384\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 1906,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 415,
      "content": "Create an instance of Pixel, because we see the effects of __slots__ on the instances.\n\nFirst effect: instances of Pixel have no __dict__.\n\nSet the p.x and p.y attributes normally.\n\nSecond effect: trying to set an attribute not listed in __slots__ raises AttributeError.\n\nSo far, so good. Now let’s create a subclass of Pixel in Example 11-14 to see the counterintuitive side of __slots__.\n\nExample 11-14. The OpenPixel is a subclass of Pixel\n\n>>> class OpenPixel(Pixel): ... pass ... >>> op = OpenPixel() >>> op.__dict__ {} >>> op.x = 8 >>> op.__dict__ {} >>> op.x 8 >>> op.color = 'green' >>> op.__dict__ {'color': 'green'}\n\nOpenPixel declares no attributes of its own.\n\nSurprise: instances of OpenPixel have a __dict__.\n\nIf you set attribute x (named in the __slots__ of the base class Pixel)…\n\n…it is not stored in the instance __dict__…\n\n…but it is stored in the hidden array of references in the instance.\n\nIf you set an attribute not named in the __slots__…\n\n…it is stored in the instance __dict__.\n\nSaving Memory with __slots__\n\n|\n\n385",
      "content_length": 1043,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 416,
      "content": "Example 11-14 shows that the effect of __slots__ is only partially inherited by a sub‐ class. To make sure that instances of a subclass have no __dict__, you must declare __slots__ again in the subclass.\n\nIf you declare __slots__ = () (an empty tuple), then the instances of the subclass will have no __dict__ and will only accept the attributes named in the __slots__ of the base class.\n\nIf you want a subclass to have additional attributes, name them in __slots__, as shown in Example 11-15.\n\nExample 11-15. The ColorPixel, another subclass of Pixel\n\n>>> class ColorPixel(Pixel): ... __slots__ = ('color',) >>> cp = ColorPixel() >>> cp.__dict__ Traceback (most recent call last): ... AttributeError: 'ColorPixel' object has no attribute '__dict__' >>> cp.x = 2 >>> cp.color = 'blue' >>> cp.flavor = 'banana' Traceback (most recent call last): ... AttributeError: 'ColorPixel' object has no attribute 'flavor'\n\nEssentially, __slots__ of the superclasses are added to the __slots__ of the cur‐ rent class. Don’t forget that single-item tuples must have a trailing comma.\n\nColorPixel instances have no __dict__.\n\nYou can set the attributes declared in the __slots__ of this class and super‐ classes, but no other.\n\nIt’s possible to “save memory and eat it too”: if you add the '__dict__' name to the __slots__ list, your instances will keep attributes named in __slots__ in the per- instance array of references, but will also support dynamically created attributes, which will be stored in the usual __dict__. This is necessary if you want to use the @cached_property decorator (covered in “Step 5: Caching Properties with functools” on page 855).\n\nOf course, having '__dict__' in __slots__ may entirely defeat its purpose, depend‐ ing on the number of static and dynamic attributes in each instance and how they are used. Careless optimization is worse than premature optimization: you add complex‐ ity but may not get any benefit.\n\n386\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 1971,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 417,
      "content": "Another special per-instance attribute that you may want to keep is __weakref__, necessary for an object to support weak references (mentioned briefly in “del and Garbage Collection” on page 219). That attribute exists by default in instances of user-defined classes. However, if the class defines __slots__, and you need the instances to be targets of weak references, then you need to include '__weakref__' among the attributes named in __slots__.\n\nNow let’s see the effect of adding __slots__ to Vector2d.\n\nSimple Measure of __slot__ Savings Example 11-16 shows the implementation of __slots__ in Vector2d.\n\nExample 11-16. vector2d_v3_slots.py: the __slots__ attribute is the only addition to Vector2d\n\nclass Vector2d: __match_args__ = ('x', 'y') __slots__ = ('__x', '__y')\n\ntypecode = 'd' # methods are the same as previous version\n\n__match_args__ lists the public attribute names for positional pattern matching.\n\nIn contrast, __slots__ lists the names of the instance attributes, which in this case are private attributes.\n\nTo measure the memory savings, I wrote the mem_test.py script. It takes the name of a module with a Vector2d class variant as command-line argument, and uses a list comprehension to build a list with 10,000,000 instances of Vector2d. In the first run shown in Example 11-17, I use vector2d_v3.Vector2d (from Example 11-7); in the second run, I use the version with __slots__ from Example 11-16.\n\nExample 11-17. mem_test.py creates 10 million Vector2d instances using the class defined in the named module\n\n$ time python3 mem_test.py vector2d_v3 Selected Vector2d type: vector2d_v3.Vector2d Creating 10,000,000 Vector2d instances Initial RAM usage: 6,983,680 Final RAM usage: 1,666,535,424\n\nreal 0m11.990s user 0m10.861s sys 0m0.978s\n\nSaving Memory with __slots__\n\n|\n\n387",
      "content_length": 1800,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 418,
      "content": "$ time python3 mem_test.py vector2d_v3_slots Selected Vector2d type: vector2d_v3_slots.Vector2d Creating 10,000,000 Vector2d instances Initial RAM usage: 6,995,968 Final RAM usage: 577,839,104\n\nreal 0m8.381s user 0m8.006s sys 0m0.352s\n\nAs Example 11-17 reveals, the RAM footprint of the script grows to 1.55 GiB when instance __dict__ is used in each of the 10 million Vector2d instances, but that is reduced to 551 MiB when Vector2d has a __slots__ attribute. The __slots__ ver‐ sion is also faster. The mem_test.py script in this test basically deals with loading a module, checking memory usage, and formatting results. You can find its source code in the fluentpython/example-code-2e repository.\n\nIf you are handling millions of objects with numeric data, you should really be using NumPy arrays (see “NumPy” on page 64), which are not only memory efficient but have highly optimized functions for numeric processing, many of which operate on the entire array at once. I designed the Vector2d class just to provide context when discussing special methods, because I try to avoid vague foo and bar examples when I can.\n\nSummarizing the Issues with __slots__ The __slots__ class attribute may provide significant memory savings if properly used, but there are a few caveats:\n\nYou must remember to redeclare __slots__ in each subclass to prevent their instances from having __dict__.\n\nInstances will only be able to have the attributes listed in __slots__, unless you include '__dict__' in __slots__ (but doing so may negate the memory savings).\n\nClasses using __slots__ cannot use the @cached_property decorator, unless they explicitly name '__dict__' in __slots__.\n\nInstances cannot be targets of weak references, unless you add '__weakref__' in __slots__.\n\nThe last topic in this chapter has to do with overriding a class attribute in instances and subclasses.\n\n388\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 1903,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 419,
      "content": "Overriding Class Attributes A distinctive feature of Python is how class attributes can be used as default values for instance attributes. In Vector2d there is the typecode class attribute. It’s used twice in the __bytes__ method, but we read it as self.typecode by design. Because Vec tor2d instances are created without a typecode attribute of their own, self.type code will get the Vector2d.typecode class attribute by default.\n\nBut if you write to an instance attribute that does not exist, you create a new instance attribute—e.g., a typecode instance attribute—and the class attribute by the same name is untouched. However, from then on, whenever the code handling that instance reads self.typecode, the instance typecode will be retrieved, effectively shadowing the class attribute by the same name. This opens the possibility of custom‐ izing an individual instance with a different typecode.\n\nThe default Vector2d.typecode is 'd', meaning each vector component will be rep‐ resented as an 8-byte double precision float when exporting to bytes. If we set the typecode of a Vector2d instance to 'f' prior to exporting, each component will be exported as a 4-byte single precision float. Example 11-18 demonstrates.\n\nWe are discussing adding a custom instance attribute, therefore Example 11-18 uses the Vector2d implementation without __slots__, as listed in Example 11-11.\n\nExample 11-18. Customizing an instance by setting the typecode attribute that was formerly inherited from the class\n\n>>> from vector2d_v3 import Vector2d >>> v1 = Vector2d(1.1, 2.2) >>> dumpd = bytes(v1) >>> dumpd b'd\\x9a\\x99\\x99\\x99\\x99\\x99\\xf1?\\x9a\\x99\\x99\\x99\\x99\\x99\\x01@' >>> len(dumpd) 17 >>> v1.typecode = 'f' >>> dumpf = bytes(v1) >>> dumpf b'f\\xcd\\xcc\\x8c?\\xcd\\xcc\\x0c@' >>> len(dumpf) 9 >>> Vector2d.typecode 'd'\n\nOverriding Class Attributes\n\n|\n\n389",
      "content_length": 1842,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 420,
      "content": "Default bytes representation is 17 bytes long.\n\nSet typecode to 'f' in the v1 instance.\n\nNow the bytes dump is 9 bytes long.\n\nVector2d.typecode is unchanged; only the v1 instance uses typecode 'f'.\n\nNow it should be clear why the bytes export of a Vector2d is prefixed by the type code: we wanted to support different export formats.\n\nIf you want to change a class attribute, you must set it on the class directly, not through an instance. You could change the default typecode for all instances (that don’t have their own typecode) by doing this:\n\n>>> Vector2d.typecode = 'f'\n\nHowever, there is an idiomatic Python way of achieving a more permanent effect, and being more explicit about the change. Because class attributes are public, they are inherited by subclasses, so it’s common practice to subclass just to customize a class data attribute. The Django class-based views use this technique extensively. Example 11-19 shows how.\n\nExample 11-19. The ShortVector2d is a subclass of Vector2d, which only overwrites the default typecode\n\n>>> from vector2d_v3 import Vector2d >>> class ShortVector2d(Vector2d): ... typecode = 'f' ... >>> sv = ShortVector2d(1/11, 1/27) >>> sv ShortVector2d(0.09090909090909091, 0.037037037037037035) >>> len(bytes(sv)) 9\n\nCreate ShortVector2d as a Vector2d subclass just to overwrite the typecode class attribute.\n\nBuild ShortVector2d instance sv for demonstration.\n\nInspect the repr of sv.\n\nCheck that the length of the exported bytes is 9, not 17 as before.\n\nThis example also explains why I did not hardcode the class_name in Vector2d. __repr__, but instead got it from type(self).__name__, like this:\n\n390\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 1677,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 421,
      "content": "# inside class Vector2d:\n\ndef __repr__(self): class_name = type(self).__name__ return '{}({!r}, {!r})'.format(class_name, *self)\n\nIf I had hardcoded the class_name, subclasses of Vector2d like ShortVector2d would have to overwrite __repr__ just to change the class_name. By reading the name from the type of the instance, I made __repr__ safer to inherit.\n\nThis ends our coverage of building a simple class that leverages the data model to play well with the rest of Python: offering different object representations, providing a custom formatting code, exposing read-only attributes, and supporting hash() to integrate with sets and mappings.\n\nChapter Summary The aim of this chapter was to demonstrate the use of special methods and conven‐ tions in the construction of a well-behaved Pythonic class.\n\nIs vector2d_v3.py (shown in Example 11-11) more Pythonic than vector2d_v0.py (shown in Example 11-2)? The Vector2d class in vector2d_v3.py certainly exhibits more Python features. But whether the first or the last Vector2d implementation is suitable depends on the context where it would be used. Tim Peter’s “Zen of Python” says:\n\nSimple is better than complex.\n\nAn object should be as simple as the requirements dictate—and not a parade of lan‐ guage features. If the code is for an application, then it should focus on what is needed to support the end users, not more. If the code is for a library for other pro‐ grammers to use, then it’s reasonable to implement special methods supporting behaviors that Pythonistas expect. For example, __eq__ may not be necessary to sup‐ port a business requirement, but it makes the class easier to test.\n\nMy goal in expanding the Vector2d code was to provide context for discussing Python special methods and coding conventions. The examples in this chapter have demonstrated several of the special methods we first saw in Table 1-1 (Chapter 1):\n\nString/bytes representation methods: __repr__, __str__, __format__, and __bytes__\n\nMethods for reducing an object to a number: __abs__, __bool__, and __hash__ • The __eq__ operator, to support testing and hashing (along with __hash__)\n\nChapter Summary\n\n|\n\n391",
      "content_length": 2153,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 422,
      "content": "While supporting conversion to bytes, we also implemented an alternative construc‐ tor, Vector2d.frombytes(), which provided the context for discussing the decora‐ tors @classmethod (very handy) and @staticmethod (not so useful, module-level functions are simpler). The frombytes method was inspired by its namesake in the array.array class.\n\nWe saw that the Format Specification Mini-Language is extensible by implementing a __format__ method that parses a format_spec provided to the format(obj, for mat_spec) built-in or within replacement fields '{:«format_spec»}' in f-strings or strings used with the str.format() method.\n\nIn preparation to make Vector2d instances hashable, we made an effort to make them immutable, at least preventing accidental changes by coding the x and y attributes as private, and exposing them as read-only properties. We then implemented __hash__ using the recommended technique of xor-ing the hashes of the instance attributes.\n\nWe then discussed the memory savings and the caveats of declaring a __slots__ attribute in Vector2d. Because using __slots__ has side effects, it really makes sense only when handling a very large number of instances—think millions of instances, not just thousands. In many such cases, using pandas may be the best option.\n\nThe last topic we covered was the overriding of a class attribute accessed via the instances (e.g., self.typecode). We did that first by creating an instance attribute, and then by subclassing and overwriting at the class level.\n\nThroughout the chapter, I mentioned how design choices in the examples were informed by studying the API of standard Python objects. If this chapter can be sum‐ marized in one sentence, this is it:\n\nTo build Pythonic objects, observe how real Python objects behave.\n\n—Ancient Chinese proverb\n\nFurther Reading This chapter covered several special methods of the data model, so naturally the pri‐ mary references are the same as the ones provided in Chapter 1, which gave a high- level view of the same topic. For convenience, I’ll repeat those four earlier recommendations here, and add a few other ones:\n\nThe “Data Model” chapter of The Python Language Reference\n\nMost of the methods we used in this chapter are documented in “3.3.1. Basic cus‐ tomization”.\n\n392\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 2312,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 423,
      "content": "Python in a Nutshell, 3rd ed., by Alex Martelli, Anna Ravenscroft, and Steve Holden\n\nCovers the special methods in depth.\n\nPython Cookbook, 3rd ed., by David Beazley and Brian K. Jones\n\nModern Python practices demonstrated through recipes. Chapter 8, “Classes and Objects,” in particular has several solutions related to discussions in this chapter.\n\nPython Essential Reference, 4th ed., by David Beazley\n\nCovers the data model in detail, even if only Python 2.6 and 3.0 are covered (in the fourth edition). The fundamental concepts are all the same and most of the Data Model APIs haven’t changed at all since Python 2.2, when built-in types and user-defined classes were unified.\n\nIn 2015—the year I finished the first edition of Fluent Python—Hynek Schlawack started the attrs package. From the attrs documentation:\n\nattrs is the Python package that will bring back the joy of writing classes by relieving you from the drudgery of implementing object protocols (aka dunder methods).\n\nI mentioned attrs as a more powerful alternative to @dataclass in “Further Read‐ ing” on page 196. The data class builders from Chapter 5 as well as attrs automati‐ cally equip your classes with several special methods. But knowing how to code those special methods yourself is still essential to understand what those packages do, to decide whether you really need them, and to override the methods they generate— when necessary.\n\nIn this chapter, we saw every special method related to object representation, except __index__ and __fspath__. We’ll discuss __index__ in Chapter 12, “A Slice-Aware __getitem__” on page 406. I will not cover __fspath__. To learn about it, see PEP 519 —Adding a file system path protocol.\n\nAn early realization of the need for distinct string representations for objects appeared in Smalltalk. The 1996 article “How to Display an Object as a String: print‐ String and displayString” by Bobby Woolf discusses the implementation of the print String and displayString methods in that language. From that article, I borrowed the pithy descriptions “the way the developer wants to see it” and “the way the user wants to see it” when defining repr() and str() in “Object Representations” on page 364.\n\nFurther Reading\n\n|\n\n393",
      "content_length": 2238,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 424,
      "content": "Soapbox\n\nProperties Help Reduce Up-Front Costs\n\nIn the initial versions of Vector2d, the x and y attributes were public, as are all Python instance and class attributes by default. Naturally, users of vectors need to access its components. Although our vectors are iterable and can be unpacked into a pair of variables, it’s also desirable to write my_vector.x and my_vector.y to get each component.\n\nWhen we felt the need to avoid accidental updates to the x and y attributes, we imple‐ mented properties, but nothing changed elsewhere in the code and in the public interface of Vector2d, as verified by the doctests. We are still able to access my_vec tor.x and my_vector.y.\n\nThis shows that we can always start our classes in the simplest possible way, with public attributes, because when (or if) we later need to impose more control with get‐ ters and setters, these can be implemented through properties without changing any of the code that already interacts with our objects through the names (e.g., x and y) that were initially simple public attributes.\n\nThis approach is the opposite of that encouraged by the Java language: a Java pro‐ grammer cannot start with simple public attributes and only later, if needed, implement properties, because they don’t exist in the language. Therefore, writing getters and setters is the norm in Java—even when those methods do nothing useful —because the API cannot evolve from simple public attributes to getters and setters without breaking all code that uses those attributes.\n\nIn addition, as Martelli, Ravenscroft, and Holden point out in Python in a Nutshell, 3rd ed., typing getter/setter calls everywhere is goofy. You have to write stuff like:\n\n>>> my_object.set_foo(my_object.get_foo() + 1)\n\nJust to do this:\n\n>>> my_object.foo += 1\n\nWard Cunningham, inventor of the wiki and an Extreme Programming pioneer, rec‐ ommends asking: “What’s the simplest thing that could possibly work?” The idea is to focus on the goal.11 Implementing setters and getters up-front is a distraction from the goal. In Python, we can simply use public attributes, knowing we can change them to properties later, if the need arises.\n\n11 See the “Simplest Thing that Could Possibly Work: A Conversation with Ward Cunningham, Part V”.\n\n394\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 2305,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 425,
      "content": "Safety Versus Security in Private Attributes\n\nPerl doesn’t have an infatuation with enforced privacy. It would prefer that you stayed out of its living room because you weren’t invited, not because it has a shotgun.\n\n—Larry Wall, creator of Perl\n\nPython and Perl are polar opposites in many regards, but Guido and Larry seem to agree on object privacy.\n\nHaving taught Python to many Java programmers over the years, I’ve found a lot of them put too much faith in the privacy guarantees that Java offers. As it turns out, the Java private and protected modifiers normally provide protection against accidents only (i.e., safety). They only offer security against malicious intent if the application is specially configured and deployed on top of a Java SecurityManager, and that seldom happens in practice, even in security conscious corporate settings.\n\nTo prove my point, I like to show this Java class (Example 11-20).\n\nExample 11-20. Confidential.java: a Java class with a private field named secret\n\npublic class Confidential {\n\nprivate String secret = \"\";\n\npublic Confidential(String text) { this.secret = text.toUpperCase(); } }\n\nIn Example 11-20, I store the text in the secret field after converting it to uppercase, just to make it obvious that whatever is in that field will be in all caps.\n\nThe actual demonstration consists of running expose.py with Jython. That script uses introspection (“reflection” in Java parlance) to get the value of a private field. The code is in Example 11-21.\n\nExample 11-21. expose.py: Jython code to read the content of a private field in another class\n\n#!/usr/bin/env jython # NOTE: Jython is still Python 2.7 in late2020\n\nimport Confidential\n\nmessage = Confidential('top secret text') secret_field = Confidential.getDeclaredField('secret') secret_field.setAccessible(True) # break the lock! print 'message.secret =', secret_field.get(message)\n\nIf you run Example 11-21, this is what you get:\n\nFurther Reading\n\n|\n\n395",
      "content_length": 1960,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 426,
      "content": "$ jython expose.py message.secret = TOP SECRET TEXT\n\nThe string 'TOP SECRET TEXT' was read from the secret private field of the Confi dential class.\n\nThere is no black magic here: expose.py uses the Java reflection API to get a reference to the private field named 'secret', and then calls 'secret_field.setAccessi ble(True)' to make it readable. The same thing can be done with Java code, of course (but it takes more than three times as many lines to do it; see the file Expose.java in the _Fluent Python_ code repository).\n\nThe crucial call .setAccessible(True) will fail only if the Jython script or the Java main program (e.g., Expose.class) is running under the supervision of a Security‐ Manager. But in the real world, Java applications are rarely deployed with a Security‐ Manager—except for Java applets when they were still supported by browsers.\n\nMy point is: in Java too, access control modifiers are mostly about safety and not security, at least in practice. So relax and enjoy the power Python gives you. Use it responsibly.\n\n396\n\n|\n\nChapter 11: A Pythonic Object",
      "content_length": 1079,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 427,
      "content": "CHAPTER 12 Special Methods for Sequences\n\nDon’t check whether it is-a duck: check whether it quacks-like-a duck, walks-like-a duck, etc., etc., depending on exactly what subset of duck-like behavior you need to play your language-games with. (comp.lang.python, Jul. 26, 2000)\n\n—Alex Martelli\n\nIn this chapter, we will create a class to represent a multidimensional Vector class—a significant step up from the two-dimensional Vector2d of Chapter 11. Vector will behave like a standard Python immutable flat sequence. Its elements will be floats, and it will support the following by the end of this chapter:\n\nBasic sequence protocol: __len__ and __getitem__\n\nSafe representation of instances with many items • Proper slicing support, producing new Vector instances\n\nAggregate hashing, taking into account every contained element value\n\nCustom formatting language extension\n\nWe’ll also implement dynamic attribute access with __getattr__ as a way of replac‐ ing the read-only properties we used in Vector2d—although this is not typical of sequence types.\n\nThe code-intensive presentation will be interrupted by a conceptual discussion about the idea of protocols as an informal interface. We’ll talk about how protocols and duck typing are related, and its practical implications when you create your own types.\n\n397",
      "content_length": 1314,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 428,
      "content": "What’s New in This Chapter There are no major changes in this chapter. There is a new, brief discussion of the typing.Protocol in a tip box near the end of “Protocols and Duck Typing” on page 402.\n\nIn “A Slice-Aware __getitem__” on page 406, the implementation of __getitem__ in Example 12-6 is more concise and robust than the example in the first edition, thanks to duck typing and operator.index. This change carried over to later implementa‐ tions of Vector in this chapter and in Chapter 16.\n\nLet’s get started.\n\nVector: A User-Defined Sequence Type Our strategy to implement Vector will be to use composition, not inheritance. We’ll store the components in an array of floats, and will implement the methods needed for our Vector to behave like an immutable flat sequence.\n\nBut before we implement the sequence methods, let’s make sure we have a baseline implementation of Vector that is compatible with our earlier Vector2d class—except where such compatibility would not make sense.\n\nVector Applications Beyond Three Dimensions Who needs a vector with 1,000 dimensions? N-dimensional vectors (with large values of N) are widely used in information retrieval, where documents and text queries are represented as vectors, with one dimension per word. This is called the Vector space model. In this model, a key relevance metric is the cosine similarity (i.e., the cosine of the angle between the vector representing the query and the vector representing the document). As the angle decreases, the cosine approaches the maximum value of 1, and so does the relevance of the document to the query.\n\nHaving said that, the Vector class in this chapter is a didactic example and we’ll not do much math here. Our goal is just to demonstrate some Python special methods in the context of a sequence type.\n\nNumPy and SciPy are the tools you need for real-world vector math. The PyPI pack‐ age gensim, by Radim Řehůřek, implements vector space modeling for natural lan‐ guage processing and information retrieval, using NumPy and SciPy.\n\n398\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 2083,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 429,
      "content": "Vector Take #1: Vector2d Compatible The first version of Vector should be as compatible as possible with our earlier Vec tor2d class.\n\nHowever, by design, the Vector constructor is not compatible with the Vector2d constructor. We could make Vector(3, 4) and Vector(3, 4, 5) work, by taking arbitrary arguments with *args in __init__, but the best practice for a sequence con‐ structor is to take the data as an iterable argument in the constructor, like all built-in sequence types do. Example 12-1 shows some ways of instantiating our new Vector objects.\n\nExample 12-1. Tests of Vector.__init__ and Vector.__repr__\n\n>>> Vector([3.1, 4.2]) Vector([3.1, 4.2]) >>> Vector((3, 4, 5)) Vector([3.0, 4.0, 5.0]) >>> Vector(range(10)) Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])\n\nApart from a new constructor signature, I made sure every test I did with Vector2d (e.g., Vector2d(3, 4)) passed and produced the same result with a two-component Vector([3, 4]).\n\nWhen a Vector has more than six components, the string pro‐ duced by repr() is abbreviated with ... as seen in the last line of Example 12-1. This is crucial in any collection type that may con‐ tain a large number of items, because repr is used for debugging— and you don’t want a single large object to span thousands of lines in your console or log. Use the reprlib module to produce limited-length representations, as in Example 12-2. The reprlib module was named repr in Python 2.7.\n\nExample 12-2 lists the implementation of our first version of Vector (this example builds on the code shown in Examples 11-2 and 11-3).\n\nExample 12-2. vector_v1.py: derived from vector2d_v1.py\n\nfrom array import array import reprlib import math\n\nclass Vector:\n\nVector Take #1: Vector2d Compatible\n\n|\n\n399",
      "content_length": 1740,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 430,
      "content": "typecode = 'd'\n\ndef __init__(self, components): self._components = array(self.typecode, components)\n\ndef __iter__(self): return iter(self._components)\n\ndef __repr__(self): components = reprlib.repr(self._components) components = components[components.find('['):-1] return f'Vector({components})'\n\ndef __str__(self): return str(tuple(self))\n\ndef __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(self._components))\n\ndef __eq__(self, other): return tuple(self) == tuple(other)\n\ndef __abs__(self): return math.hypot(*self)\n\ndef __bool__(self): return bool(abs(self))\n\n@classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(memv)\n\nThe self._components instance “protected” attribute will hold an array with the Vector components.\n\nTo allow iteration, we return an iterator over self._components.1\n\nUse reprlib.repr() to get a limited-length representation of self._components (e.g., array('d', [0.0, 1.0, 2.0, 3.0, 4.0, ...])).\n\nRemove the array('d', prefix, and the trailing ) before plugging the string into a Vector constructor call.\n\n1 The iter() function is covered in Chapter 17, along with the __iter__ method.\n\n400\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 1243,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 431,
      "content": "Build a bytes object directly from self._components.\n\nSince Python 3.8, math.hypot accepts N-dimensional points. I used this expres‐ sion before: math.sqrt(sum(x * x for x in self)).\n\nThe only change needed from the earlier frombytes is in the last line: we pass the memoryview directly to the constructor, without unpacking with * as we did before.\n\nThe way I used reprlib.repr deserves some elaboration. That function produces safe representations of large or recursive structures by limiting the length of the out‐ put string and marking the cut with '...'. I wanted the repr of a Vector to look like Vector([3.0, 4.0, 5.0]) and not Vector(array('d', [3.0, 4.0, 5.0])), because the fact that there is an array inside a Vector is an implementation detail. Because these constructor calls build identical Vector objects, I prefer the simpler syntax using a list argument.\n\nWhen coding __repr__, I could have produced the simplified components display with this expression: reprlib.repr(list(self._components)). However, this would be wasteful, as I’d be copying every item from self._components to a list just to use the list repr. Instead, I decided to apply reprlib.repr to the self._com ponents array directly, and then chop off the characters outside of the []. That’s what the second line of __repr__ does in Example 12-2.\n\nBecause of its role in debugging, calling repr() on an object should never raise an exception. If something goes wrong inside your implementation of __repr__, you must deal with the issue and do your best to produce some serviceable output that gives the user a chance of identifying the receiver (self).\n\nNote that the __str__, __eq__, and __bool__ methods are unchanged from Vec tor2d, and only one character was changed in frombytes (a * was removed in the last line). This is one of the benefits of making the original Vector2d iterable.\n\nBy the way, we could have subclassed Vector from Vector2d, but I chose not to do it for two reasons. First, the incompatible constructors really make subclassing not advisable. I could work around that with some clever parameter handling in __init__, but the second reason is more important: I want Vector to be a standalone example of a class implementing the sequence protocol. That’s what we’ll do next, after a discussion of the term protocol.\n\nVector Take #1: Vector2d Compatible\n\n|\n\n401",
      "content_length": 2365,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 432,
      "content": "Protocols and Duck Typing As early as Chapter 1, we saw that you don’t need to inherit from any special class to create a fully functional sequence type in Python; you just need to implement the methods that fulfill the sequence protocol. But what kind of protocol are we talking about?\n\nIn the context of object-oriented programming, a protocol is an informal interface, defined only in documentation and not in code. For example, the sequence protocol in Python entails just the __len__ and __getitem__ methods. Any class Spam that implements those methods with the standard signature and semantics can be used anywhere a sequence is expected. Whether Spam is a subclass of this or that is irrele‐ vant; all that matters is that it provides the necessary methods. We saw that in Example 1-1, reproduced here in Example 12-3.\n\nExample 12-3. Code from Example 1-1, reproduced here for convenience\n\nimport collections\n\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n\nclass FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split()\n\ndef __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\ndef __len__(self): return len(self._cards)\n\ndef __getitem__(self, position): return self._cards[position]\n\nThe FrenchDeck class in Example 12-3 takes advantage of many Python facilities because it implements the sequence protocol, even if that is not declared anywhere in the code. An experienced Python coder will look at it and understand that it is a sequence, even if it subclasses object. We say it is a sequence because it behaves like one, and that is what matters.\n\nThis became known as duck typing, after Alex Martelli’s post quoted at the beginning of this chapter.\n\nBecause protocols are informal and unenforced, you can often get away with imple‐ menting just part of a protocol, if you know the specific context where a class will be\n\n402\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 1992,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 433,
      "content": "used. For example, to support iteration, only __getitem__ is required; there is no need to provide __len__.\n\nWith PEP 544—Protocols: Structural subtyping (static duck typ‐ ing), Python 3.8 supports protocol classes: typing constructs, which we studied in “Static Protocols” on page 286. This new use of the word protocol in Python has a related but different meaning. When I need to differentiate them, I write static protocol to refer to the protocols formalized in protocol classes, and dynamic protocol for the traditional sense. One key difference is that static protocol implementations must provide all methods defined in the protocol class. “Two Kinds of Protocols” on page 434 in Chapter 13 has more details.\n\nWe’ll now implement the sequence protocol in Vector, initially without proper sup‐ port for slicing, but later adding that.\n\nVector Take #2: A Sliceable Sequence As we saw with the FrenchDeck example, supporting the sequence protocol is really easy if you can delegate to a sequence attribute in your object, like our self._compo nents array. These __len__ and __getitem__ one-liners are a good start:\n\nclass Vector: # many lines omitted # ...\n\ndef __len__(self): return len(self._components)\n\ndef __getitem__(self, index): return self._components[index]\n\nWith these additions, all of these operations now work:\n\n>>> v1 = Vector([3, 4, 5]) >>> len(v1) 3 >>> v1[0], v1[-1] (3.0, 5.0) >>> v7 = Vector(range(7)) >>> v7[1:4] array('d', [1.0, 2.0, 3.0])\n\nAs you can see, even slicing is supported—but not very well. It would be better if a slice of a Vector was also a Vector instance and not an array. The old FrenchDeck class has a similar problem: when you slice it, you get a list. In the case of Vector, a lot of functionality is lost when slicing produces plain arrays.\n\nVector Take #2: A Sliceable Sequence\n\n|\n\n403",
      "content_length": 1834,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 434,
      "content": "Consider the built-in sequence types: every one of them, when sliced, produces a new instance of its own type, and not of some other type.\n\nTo make Vector produce slices as Vector instances, we can’t just delegate the slicing to array. We need to analyze the arguments we get in __getitem__ and do the right thing.\n\nNow, let’s see how Python turns the syntax my_seq[1:3] into arguments for my_seq.__getitem__(...).\n\nHow Slicing Works A demo is worth a thousand words, so take a look at Example 12-4.\n\nExample 12-4. Checking out the behavior of __getitem__ and slices\n\n>>> class MySeq: ... def __getitem__(self, index): ... return index ... >>> s = MySeq() >>> s[1] 1 >>> s[1:4] slice(1, 4, None) >>> s[1:4:2] slice(1, 4, 2) >>> s[1:4:2, 9] (slice(1, 4, 2), 9) >>> s[1:4:2, 7:9] (slice(1, 4, 2), slice(7, 9, None))\n\nFor this demonstration, __getitem__ merely returns whatever is passed to it.\n\nA single index, nothing new.\n\nThe notation 1:4 becomes slice(1, 4, None).\n\nslice(1, 4, 2) means start at 1, stop at 4, step by 2.\n\nSurprise: the presence of commas inside the [] means __getitem__ receives a tuple.\n\nThe tuple may even hold several slice objects.\n\nNow let’s take a closer look at slice itself in Example 12-5.\n\n404\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 1268,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 435,
      "content": "Example 12-5. Inspecting the attributes of the slice class\n\n>>> slice <class 'slice'> >>> dir(slice) ['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'indices', 'start', 'step', 'stop']\n\nslice is a built-in type (we saw it first in “Slice Objects” on page 48).\n\nInspecting a slice, we find the data attributes start, stop, and step, and an indices method.\n\nIn Example 12-5, calling dir(slice) reveals an indices attribute, which turns out to be a very interesting but little-known method. Here is what help(slice.indices) reveals:\n\nS.indices(len) -> (start, stop, stride)\n\nAssuming a sequence of length len, calculate the start and stop indices, and the stride length of the extended slice described by S. Out-of-bounds indices are clipped just like they are in a normal slice.\n\nIn other words, indices exposes the tricky logic that’s implemented in the built-in sequences to gracefully handle missing or negative indices and slices that are longer than the original sequence. This method produces “normalized” tuples of nonnega‐ tive start, stop, and stride integers tailored to a sequence of the given length.\n\nHere are a couple of examples, considering a sequence of len == 5, e.g., 'ABCDE':\n\n>>> slice(None, 10, 2).indices(5) (0, 5, 2) >>> slice(-3, None, None).indices(5) (2, 5, 1)\n\n'ABCDE'[:10:2] is the same as 'ABCDE'[0:5:2].\n\n'ABCDE'[-3:] is the same as 'ABCDE'[2:5:1].\n\nIn our Vector code, we’ll not need the slice.indices() method because when we get a slice argument we’ll delegate its handling to the _components array. But if you can’t count on the services of an underlying sequence, this method can be a huge time saver.\n\nVector Take #2: A Sliceable Sequence\n\n|\n\n405",
      "content_length": 1916,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 436,
      "content": "Now that we know how to handle slices, let’s take a look at the improved Vec tor.__getitem__ implementation.\n\nA Slice-Aware __getitem__ Example 12-6 lists the two methods needed to make Vector behave as a sequence: __len__ and __getitem__ (the latter now implemented to handle slicing correctly).\n\nExample 12-6. Part of vector_v2.py: __len__ and __getitem__ methods added to Vector class from vector_v1.py (see Example 12-2)\n\ndef __len__(self): return len(self._components)\n\ndef __getitem__(self, key): if isinstance(key, slice): cls = type(self) return cls(self._components[key]) index = operator.index(key) return self._components[index]\n\nIf the key argument is a slice…\n\n…get the class of the instance (i.e., Vector) and…\n\n…invoke the class to build another Vector instance from a slice of the _components array.\n\nIf we can get an index from key…\n\n…return the specific item from _components.\n\nThe operator.index() function calls the __index__ special method. The function and the special method were defined in PEP 357—Allowing Any Object to be Used for Slicing, proposed by Travis Oliphant to allow any of the numerous types of inte‐ gers in NumPy to be used as indexes and slice arguments. The key difference between operator.index() and int() is that the former is intended for this specific purpose. For example, int(3.14) returns 3, but operator.index(3.14) raises TypeError because a float should not be used as an index.\n\n406\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 1481,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 437,
      "content": "Excessive use of isinstance may be a sign of bad OO design, but handling slices in __getitem__ is a justified use case. In the first edition, I also used an isinstance test on key to test if it was an integer. Using operator.index avoids this test, and raises Type Error with a very informative message if we can’t get the index from key. See the last error message from Example 12-7.\n\nOnce the code in Example 12-6 is added to the Vector class, we have proper slicing behavior, as Example 12-7 demonstrates.\n\nExample 12-7. Tests of enhanced Vector.__getitem__ from Example 12-6\n\n>>> v7 = Vector(range(7)) >>> v7[-1] 6.0 >>> v7[1:4] Vector([1.0, 2.0, 3.0]) >>> v7[-1:] Vector([6.0]) >>> v7[1,2] Traceback (most recent call last): ... TypeError: 'tuple' object cannot be interpreted as an integer\n\nAn integer index retrieves just one component value as a float.\n\nA slice index creates a new Vector.\n\nA slice of len == 1 also creates a Vector.\n\nVector does not support multidimensional indexing, so a tuple of indices or sli‐ ces raises an error.\n\nVector Take #3: Dynamic Attribute Access In the evolution from Vector2d to Vector, we lost the ability to access vector compo‐ nents by name (e.g., v.x, v.y). We are now dealing with vectors that may have a large number of components. Still, it may be convenient to access the first few components with shortcut letters such as x, y, z instead of v[0], v[1], and v[2].\n\nHere is the alternative syntax we want to provide for reading the first four compo‐ nents of a vector:\n\n>>> v = Vector(range(10)) >>> v.x 0.0\n\nVector Take #3: Dynamic Attribute Access\n\n|\n\n407",
      "content_length": 1607,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 438,
      "content": ">>> v.y, v.z, v.t (1.0, 2.0, 3.0)\n\nIn Vector2d, we provided read-only access to x and y using the @property decorator (Example 11-7). We could write four properties in Vector, but it would be tedious. The __getattr__ special method provides a better way.\n\nThe __getattr__ method is invoked by the interpreter when attribute lookup fails. In simple terms, given the expression my_obj.x, Python checks if the my_obj instance has an attribute named x; if not, the search goes to the class (my_obj.__class__), and then up the inheritance graph.2 If the x attribute is not found, then the __getattr__ method defined in the class of my_obj is called with self and the name of the attribute as a string (e.g., 'x').\n\nExample 12-8 lists our __getattr__ method. Essentially it checks whether the attribute being sought is one of the letters xyzt and if so, returns the corresponding vector component.\n\nExample 12-8. Part of vector_v3.py: __getattr__ method added to the Vector class\n\n__match_args__ = ('x', 'y', 'z', 't')\n\ndef __getattr__(self, name): cls = type(self) try: pos = cls.__match_args__.index(name) except ValueError: pos = -1 if 0 <= pos < len(self._components): return self._components[pos] msg = f'{cls.__name__!r} object has no attribute {name!r}' raise AttributeError(msg)\n\nSet __match_args__ to allow positional pattern matching on the dynamic attributes supported by __getattr__.3\n\nGet the Vector class for later use.\n\n2 Attribute lookup is more complicated than this; we’ll see the gory details in Part V. For now, this simplified\n\nexplanation will do.\n\n3 Although __match_args__ exists to support pattern matching in Python 3.10, setting this attribute is harmless in previous versions of Python. In the first edition of this book, I named it shortcut_names. With the new name it does double duty: it supports positional patterns in case clauses, and it holds the names of the dynamic attributes supported by special logic in __getattr__ and __setattr__.\n\n408\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 2017,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 439,
      "content": "Try to get the position of name in __match_args__.\n\n.index(name) raises ValueError when name is not found; set pos to -1. (I’d rather use a method like str.find here, but tuple doesn’t implement it.)\n\nIf the pos is within range of the available components, return the component.\n\nIf we get this far, raise AttributeError with a standard message text.\n\nIt’s not hard to implement __getattr__, but in this case it’s not enough. Consider the bizarre interaction in Example 12-9.\n\nExample 12-9. Inappropriate behavior: assigning to v.x raises no error, but introduces an inconsistency\n\n>>> v = Vector(range(5)) >>> v Vector([0.0, 1.0, 2.0, 3.0, 4.0]) >>> v.x 0.0 >>> v.x = 10 >>> v.x 10 >>> v Vector([0.0, 1.0, 2.0, 3.0, 4.0])\n\nAccess element v[0] as v.x.\n\nAssign new value to v.x. This should raise an exception.\n\nReading v.x shows the new value, 10.\n\nHowever, the vector components did not change.\n\nCan you explain what is happening? In particular, why does v.x return 10 the second time if that value is not in the vector components array? If you don’t know right off the bat, study the explanation of __getattr__ given right before Example 12-8. It’s a bit subtle, but a very important foundation to understand a lot of what comes later in the book.\n\nAfter you’ve given it some thought, proceed and we’ll explain exactly what happened.\n\nThe inconsistency in Example 12-9 was introduced because of the way __getattr__ works: Python only calls that method as a fallback, when the object does not have the named attribute. However, after we assign v.x = 10, the v object now has an x attribute, so __getattr__ will no longer be called to retrieve v.x: the interpreter will\n\nVector Take #3: Dynamic Attribute Access\n\n|\n\n409",
      "content_length": 1719,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 440,
      "content": "just return the value 10 that is bound to v.x. On the other hand, our implementation of __getattr__ pays no attention to instance attributes other than self._compo nents, from where it retrieves the values of the “virtual attributes” listed in __match_args__.\n\nWe need to customize the logic for setting attributes in our Vector class in order to avoid this inconsistency.\n\nRecall that in the latest Vector2d examples from Chapter 11, trying to assign to the .x or .y instance attributes raised AttributeError. In Vector, we want the same excep‐ tion with any attempt at assigning to all single-letter lowercase attribute names, just to avoid confusion. To do that, we’ll implement __setattr__, as listed in Example 12-10.\n\nExample 12-10. Part of vector_v3.py: __setattr__ method in the Vector class\n\ndef __setattr__(self, name, value): cls = type(self) if len(name) == 1: if name in cls.__match_args__: error = 'readonly attribute {attr_name!r}' elif name.islower(): error = \"can't set attributes 'a' to 'z' in {cls_name!r}\" else: error = '' if error: msg = error.format(cls_name=cls.__name__, attr_name=name) raise AttributeError(msg) super().__setattr__(name, value)\n\nSpecial handling for single-character attribute names.\n\nIf name is one of __match_args__, set specific error message.\n\nIf name is lowercase, set error message about all single-letter names.\n\nOtherwise, set blank error message.\n\nIf there is a nonblank error message, raise AttributeError.\n\nDefault case: call __setattr__ on superclass for standard behavior.\n\n410\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 1578,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 441,
      "content": "The super() function provides a way to access methods of super‐ classes dynamically, a necessity in a dynamic language supporting multiple inheritance like Python. It’s used to delegate some task from a method in a subclass to a suitable method in a superclass, as seen in Example 12-10. There is more about super in “Multiple Inheritance and Method Resolution Order” on page 494.\n\nWhile choosing the error message to display with AttributeError, my first check was the behavior of the built-in complex type, because they are immutable and have a pair of data attributes, real and imag. Trying to change either of those in a complex instance raises AttributeError with the message \"can't set attribute\". On the other hand, trying to set a read-only attribute protected by a property as we did in “A Hashable Vector2d” on page 374 produces the message \"read-only attribute\". I drew inspiration from both wordings to set the error string in __setitem__, but was more explicit about the forbidden attributes.\n\nNote that we are not disallowing setting all attributes, only single-letter, lowercase ones, to avoid confusion with the supported read-only attributes x, y, z, and t.\n\nKnowing that declaring __slots__ at the class level prevents set‐ ting new instance attributes, it’s tempting to use that feature instead of implementing __setattr__ as we did. However, because of all the caveats discussed in “Summarizing the Issues with __slots__” on page 388, using __slots__ just to prevent instance attribute creation is not recommended. __slots__ should be used only to save memory, and only if that is a real issue.\n\nEven without supporting writing to the Vector components, here is an important takeaway from this example: very often when you implement __getattr__, you need to code __setattr__ as well, to avoid inconsistent behavior in your objects.\n\nIf we wanted to allow changing components, we could implement __setitem__ to enable v[0] = 1.1 and/or __setattr__ to make v.x = 1.1 work. But Vector will remain immutable because we want to make it hashable in the coming section.\n\nVector Take #4: Hashing and a Faster == Once more we get to implement a __hash__ method. Together with the existing __eq__, this will make Vector instances hashable.\n\nThe __hash__ in Vector2d (Example 11-8) computed the hash of a tuple built with the two components, self.x and self.y. Now we may be dealing with thousands of components, so building a tuple may be too costly. Instead, I will apply the ^ (xor)\n\nVector Take #4: Hashing and a Faster ==\n\n|\n\n411",
      "content_length": 2543,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 442,
      "content": "operator to the hashes of every component in succession, like this: v[0] ^ v[1] ^ v[2]. That is what the functools.reduce function is for. Previously I said that reduce is not as popular as before,4 but computing the hash of all vector components is a good use case for it. Figure 12-1 depicts the general idea of the reduce function.\n\nFigure 12-1. Reducing functions—reduce, sum, any, all—produce a single aggregate result from a sequence or from any finite iterable object.\n\nSo far we’ve seen that functools.reduce() can be replaced by sum(), but now let’s properly explain how it works. The key idea is to reduce a series of values to a single value. The first argument to reduce() is a two-argument function, and the second argument is an iterable. Let’s say we have a two-argument function fn and a list lst. When you call reduce(fn, lst), fn will be applied to the first pair of elements— fn(lst[0], lst[1])—producing a first result, r1. Then fn is applied to r1 and the next element—fn(r1, lst[2])—producing a second result, r2. Now fn(r2, lst[3]) is called to produce r3 … and so on until the last element, when a single result, rN, is returned.\n\nHere is how you could use reduce to compute 5! (the factorial of 5):\n\n>>> 2 * 3 * 4 * 5 # the result we want: 5! == 120 120 >>> import functools >>> functools.reduce(lambda a,b: a*b, range(1, 6)) 120\n\nBack to our hashing problem, Example 12-11 shows the idea of computing the aggre‐ gate xor by doing it in three ways: with a for loop and two reduce calls.\n\nExample 12-11. Three ways of calculating the accumulated xor of integers from 0 to 5\n\n>>> n = 0 >>> for i in range(1, 6): ... n ^= i ...\n\n4 The sum, any, and all cover the most common uses of reduce. See the discussion in “Modern Replacements\n\nfor map, filter, and reduce” on page 235.\n\n412\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 1849,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 443,
      "content": ">>> n 1 >>> import functools >>> functools.reduce(lambda a, b: a^b, range(6)) 1 >>> import operator >>> functools.reduce(operator.xor, range(6)) 1\n\nAggregate xor with a for loop and an accumulator variable.\n\nfunctools.reduce using an anonymous function.\n\nfunctools.reduce replacing custom lambda with operator.xor.\n\nFrom the alternatives in Example 12-11, the last one is my favorite, and the for loop comes second. What is your preference?\n\nAs seen in “The operator Module” on page 243, operator provides the functionality of all Python infix operators in function form, lessening the need for lambda.\n\nTo code Vector.__hash__ in my preferred style, we need to import the functools and operator modules. Example 12-12 shows the relevant changes.\n\nExample 12-12. Part of vector_v4.py: two imports and __hash__ method added to the Vector class from vector_v3.py\n\nfrom array import array import reprlib import math import functools import operator\n\nclass Vector: typecode = 'd'\n\n# many lines omitted in book listing...\n\ndef __eq__(self, other): return tuple(self) == tuple(other)\n\ndef __hash__(self): hashes = (hash(x) for x in self._components) return functools.reduce(operator.xor, hashes, 0)\n\n# more lines omitted...\n\nVector Take #4: Hashing and a Faster ==\n\n|\n\n413",
      "content_length": 1266,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 444,
      "content": "Import functools to use reduce.\n\nImport operator to use xor.\n\nNo change to __eq__; I listed it here because it’s good practice to keep __eq__ and __hash__ close in source code, because they need to work together.\n\nCreate a generator expression to lazily compute the hash of each component.\n\nFeed hashes to reduce with the xor function to compute the aggregate hash code; the third argument, 0, is the initializer (see the next warning).\n\nWhen using reduce, it’s good practice to provide the third argu‐ ment, reduce(function, iterable, initializer), to prevent this exception: TypeError: reduce() of empty sequence with no initial value (excellent message: explains the problem and how to fix it). The initializer is the value returned if the sequence is empty and is used as the first argument in the reducing loop, so it should be the identity value of the operation. As exam‐ ples, for +, |, ^ the initializer should be 0, but for *, & it should be 1.\n\nAs implemented, the __hash__ method in Example 12-12 is a perfect example of a map-reduce computation (Figure 12-2).\n\nFigure 12-2. Map-reduce: apply function to each item to generate a new series (map), then compute the aggregate (reduce).\n\nThe mapping step produces one hash for each component, and the reduce step aggre‐ gates all hashes with the xor operator. Using map instead of a genexp makes the map‐ ping step even more visible:\n\n414\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 1443,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 445,
      "content": "def __hash__(self): hashes = map(hash, self._components) return functools.reduce(operator.xor, hashes)\n\nThe solution with map would be less efficient in Python 2, where the map function builds a new list with the results. But in Python 3, map is lazy: it creates a generator that yields the results on demand, thus saving memory—just like the generator expression we used in the __hash__ method of Example 12-8.\n\nWhile we are on the topic of reducing functions, we can replace our quick implemen‐ tation of __eq__ with another one that will be cheaper in terms of processing and memory, at least for large vectors. As introduced in Example 11-2, we have this very concise implementation of __eq__:\n\ndef __eq__(self, other): return tuple(self) == tuple(other)\n\nThis works for Vector2d and for Vector—it even considers Vector([1, 2]) equal to (1, 2), which may be a problem, but we’ll overlook that for now.5 But for Vector instances that may have thousands of components, it’s very inefficient. It builds two tuples copying the entire contents of the operands just to use the __eq__ of the tuple type. For Vector2d (with only two components), it’s a good shortcut, but not for the large multidimensional vectors. A better way of comparing one Vector to another Vector or iterable would be Example 12-13.\n\nExample 12-13. The Vector.__eq__ implementation using zip in a for loop for more efficient comparison\n\ndef __eq__(self, other): if len(self) != len(other): return False for a, b in zip(self, other): if a != b: return False return True\n\nIf the len of the objects are different, they are not equal.\n\nzip produces a generator of tuples made from the items in each iterable argu‐ , the len ment. See “The Awesome zip” on page 416 if zip is new to you. In\n\n5 We will seriously consider the matter of Vector([1, 2]) == (1, 2) in “Operator Overloading 101” on page\n\n562.\n\nVector Take #4: Hashing and a Faster ==\n\n|\n\n415",
      "content_length": 1916,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 446,
      "content": "comparison is needed because zip stops producing values without warning as soon as one of the inputs is exhausted.\n\nAs soon as two components are different, exit returning False.\n\nOtherwise, the objects are equal.\n\nThe zip function is named after the zipper fastener because the physical device works by interlocking pairs of teeth taken from both zipper sides, a good visual analogy for what zip(left, right) does. No relation to compressed files.\n\nExample 12-13 is efficient, but the all function can produce the same aggregate com‐ putation of the for loop in one line: if all comparisons between corresponding com‐ ponents in the operands are True, the result is True. As soon as one comparison is False, all returns False. Example 12-14 shows how __eq__ looks using all.\n\nExample 12-14. The Vector.__eq__ implementation using zip and all: same logic as Example 12-13\n\ndef __eq__(self, other): return len(self) == len(other) and all(a == b for a, b in zip(self, other))\n\nNote that we first check that the operands have equal length, because zip will stop at the shortest operand.\n\nExample 12-14 is the implementation we choose for __eq__ in vector_v4.py.\n\nThe Awesome zip Having a for loop that iterates over items without fiddling with index variables is great and prevents lots of bugs, but demands some special utility functions. One of them is the zip built-in, which makes it easy to iterate in parallel over two or more iterables by returning tuples that you can unpack into variables, one for each item in the parallel inputs. See Example 12-15.\n\nExample 12-15. The zip built-in at work\n\n>>> zip(range(3), 'ABC') <zip object at 0x10063ae48> >>> list(zip(range(3), 'ABC')) [(0, 'A'), (1, 'B'), (2, 'C')] >>> list(zip(range(3), 'ABC', [0.0, 1.1, 2.2, 3.3])) [(0, 'A', 0.0), (1, 'B', 1.1), (2, 'C', 2.2)]\n\n416\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 1863,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 447,
      "content": ">>> from itertools import zip_longest >>> list(zip_longest(range(3), 'ABC', [0.0, 1.1, 2.2, 3.3], fillvalue=-1)) [(0, 'A', 0.0), (1, 'B', 1.1), (2, 'C', 2.2), (-1, -1, 3.3)]\n\nzip returns a generator that produces tuples on demand.\n\nBuild a list just for display; usually we iterate over the generator.\n\nzip stops without warning when one of the iterables is exhausted.\n\nThe itertools.zip_longest function behaves differently: it uses an optional fillvalue (None by default) to complete missing values so it can generate tuples until the last iterable is exhausted.\n\nNew zip() Option in Python 3.10\n\nI wrote in the first edition of this book that zip silently stop‐ ping at the shortest iterable was surprising—not a good trait for an API. Silently ignoring part of the input can cause subtle bugs. Instead, zip should raise ValueError if the iterables are not all of the same length, which is what happens when unpacking an iterable to a tuple of variables of different length —in line with Python’s fail fast policy. PEP 618—Add Optional Length-Checking To zip added an optional strict argument to zip to make it behave in that way. It is imple‐ mented in Python 3.10.\n\nThe zip function can also be used to transpose a matrix represented as nested itera‐ bles. For example:\n\n>>> a = [(1, 2, 3), ... (4, 5, 6)] >>> list(zip(*a)) [(1, 4), (2, 5), (3, 6)] >>> b = [(1, 2), ... (3, 4), ... (5, 6)] >>> list(zip(*b)) [(1, 3, 5), (2, 4, 6)]\n\nIf you want to grok zip, spend some time figuring out how these examples work.\n\nThe enumerate built-in is another generator function often used in for loops to avoid direct handling of index variables. If you’re not familiar with enumerate, you should definitely check it out in the “Built-in functions” documentation. The zip and\n\nVector Take #4: Hashing and a Faster ==\n\n|\n\n417",
      "content_length": 1816,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 448,
      "content": "enumerate built-ins, along with several other generator functions in the standard library, are covered in “Generator Functions in the Standard Library” on page 619.\n\nWe wrap up this chapter by bringing back the __format__ method from Vector2d to Vector.\n\nVector Take #5: Formatting The __format__ method of Vector will resemble that of Vector2d, but instead of providing a custom display in polar coordinates, Vector will use spherical coordi‐ nates—also known as “hyperspherical” coordinates, because now we support n dimensions, and spheres are “hyperspheres” in 4D and beyond.6 Accordingly, we’ll change the custom format suffix from 'p' to 'h'.\n\nAs we saw in “Formatted Displays” on page 370, when extending the Format Specification Mini-Language, it’s best to avoid reusing format codes supported by built-in types. In particular, our exten‐ ded mini-language also uses the float formatting codes 'eEfFgGn%' in their original meaning, so we definitely must avoid these. Inte‐ gers use 'bcdoxXn' and strings use 's'. I picked 'p' for Vector2d polar coordinates. Code 'h' for hyperspherical coordinates is a good choice.\n\nFor example, given a Vector object in 4D space (len(v) == 4), the 'h' code will pro‐ duce a display like <r, Φ₁, Φ₂, Φ₃>, where r is the magnitude (abs(v)), and the remaining numbers are the angular components Φ₁, Φ₂, Φ₃.\n\nHere are some samples of the spherical coordinate format in 4D, taken from the doctests of vector_v5.py (see Example 12-16):\n\n>>> format(Vector([-1, -1, -1, -1]), 'h') '<2.0, 2.0943951023931957, 2.186276035465284, 3.9269908169872414>' >>> format(Vector([2, 2, 2, 2]), '.3eh') '<4.000e+00, 1.047e+00, 9.553e-01, 7.854e-01>' >>> format(Vector([0, 1, 0, 0]), '0.5fh') '<1.00000, 1.57080, 0.00000, 0.00000>'\n\nBefore we can implement the minor changes required in __format__, we need to code a pair of support methods: angle(n) to compute one of the angular coordinates (e.g., Φ₁), and angles() to return an iterable of all angular coordinates. I will not\n\n6 The Wolfram Mathworld website has an article on hypersphere; on Wikipedia, “hypersphere” redirects to the\n\n“n-sphere” entry.\n\n418\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 2177,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 449,
      "content": "describe the math here; if you’re curious, Wikipedia’s “n-sphere” entry has the for‐ mulas I used to calculate the spherical coordinates from the Cartesian coordinates in the Vector components array.\n\nExample 12-16 is a full listing of vector_v5.py consolidating all we’ve implemented since “Vector Take #1: Vector2d Compatible” on page 399 and introducing custom formatting.\n\nExample 12-16. vector_v5.py: doctests and all code for the final Vector class; callouts highlight additions needed to support __format__\n\n\"\"\" A multidimensional ``Vector`` class, take 5\n\nA ``Vector`` is built from an iterable of numbers::\n\n>>> Vector([3.1, 4.2]) Vector([3.1, 4.2]) >>> Vector((3, 4, 5)) Vector([3.0, 4.0, 5.0]) >>> Vector(range(10)) Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])\n\nTests with two dimensions (same results as ``vector2d_v1.py``)::\n\n>>> v1 = Vector([3, 4]) >>> x, y = v1 >>> x, y (3.0, 4.0) >>> v1 Vector([3.0, 4.0]) >>> v1_clone = eval(repr(v1)) >>> v1 == v1_clone True >>> print(v1) (3.0, 4.0) >>> octets = bytes(v1) >>> octets b'd\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x08@\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x10@' >>> abs(v1) 5.0 >>> bool(v1), bool(Vector([0, 0])) (True, False)\n\nTest of ``.frombytes()`` class method:\n\n>>> v1_clone = Vector.frombytes(bytes(v1)) >>> v1_clone\n\nVector Take #5: Formatting\n\n|\n\n419",
      "content_length": 1304,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 450,
      "content": "Vector([3.0, 4.0]) >>> v1 == v1_clone True\n\nTests with three dimensions::\n\n>>> v1 = Vector([3, 4, 5]) >>> x, y, z = v1 >>> x, y, z (3.0, 4.0, 5.0) >>> v1 Vector([3.0, 4.0, 5.0]) >>> v1_clone = eval(repr(v1)) >>> v1 == v1_clone True >>> print(v1) (3.0, 4.0, 5.0) >>> abs(v1) # doctest:+ELLIPSIS 7.071067811... >>> bool(v1), bool(Vector([0, 0, 0])) (True, False)\n\nTests with many dimensions::\n\n>>> v7 = Vector(range(7)) >>> v7 Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...]) >>> abs(v7) # doctest:+ELLIPSIS 9.53939201...\n\nTest of ``.__bytes__`` and ``.frombytes()`` methods::\n\n>>> v1 = Vector([3, 4, 5]) >>> v1_clone = Vector.frombytes(bytes(v1)) >>> v1_clone Vector([3.0, 4.0, 5.0]) >>> v1 == v1_clone True\n\nTests of sequence behavior::\n\n>>> v1 = Vector([3, 4, 5]) >>> len(v1) 3 >>> v1[0], v1[len(v1)-1], v1[-1] (3.0, 5.0, 5.0)\n\n420\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 868,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 451,
      "content": "Test of slicing::\n\n>>> v7 = Vector(range(7)) >>> v7[-1] 6.0 >>> v7[1:4] Vector([1.0, 2.0, 3.0]) >>> v7[-1:] Vector([6.0]) >>> v7[1,2] Traceback (most recent call last): ... TypeError: 'tuple' object cannot be interpreted as an integer\n\nTests of dynamic attribute access::\n\n>>> v7 = Vector(range(10)) >>> v7.x 0.0 >>> v7.y, v7.z, v7.t (1.0, 2.0, 3.0)\n\nDynamic attribute lookup failures::\n\n>>> v7.k Traceback (most recent call last): ... AttributeError: 'Vector' object has no attribute 'k' >>> v3 = Vector(range(3)) >>> v3.t Traceback (most recent call last): ... AttributeError: 'Vector' object has no attribute 't' >>> v3.spam Traceback (most recent call last): ... AttributeError: 'Vector' object has no attribute 'spam'\n\nTests of hashing::\n\n>>> v1 = Vector([3, 4]) >>> v2 = Vector([3.1, 4.2]) >>> v3 = Vector([3, 4, 5]) >>> v6 = Vector(range(6)) >>> hash(v1), hash(v3), hash(v6) (7, 2, 1)\n\nMost hash codes of non-integers vary from a 32-bit to 64-bit CPython build::\n\nVector Take #5: Formatting\n\n|\n\n421",
      "content_length": 1005,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 452,
      "content": ">>> import sys >>> hash(v2) == (384307168202284039 if sys.maxsize > 2**32 else 357915986) True\n\nTests of ``format()`` with Cartesian coordinates in 2D::\n\n>>> v1 = Vector([3, 4]) >>> format(v1) '(3.0, 4.0)' >>> format(v1, '.2f') '(3.00, 4.00)' >>> format(v1, '.3e') '(3.000e+00, 4.000e+00)'\n\nTests of ``format()`` with Cartesian coordinates in 3D and 7D::\n\n>>> v3 = Vector([3, 4, 5]) >>> format(v3) '(3.0, 4.0, 5.0)' >>> format(Vector(range(7))) '(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0)'\n\nTests of ``format()`` with spherical coordinates in 2D, 3D and 4D::\n\n>>> format(Vector([1, 1]), 'h') # doctest:+ELLIPSIS '<1.414213..., 0.785398...>' >>> format(Vector([1, 1]), '.3eh') '<1.414e+00, 7.854e-01>' >>> format(Vector([1, 1]), '0.5fh') '<1.41421, 0.78540>' >>> format(Vector([1, 1, 1]), 'h') # doctest:+ELLIPSIS '<1.73205..., 0.95531..., 0.78539...>' >>> format(Vector([2, 2, 2]), '.3eh') '<3.464e+00, 9.553e-01, 7.854e-01>' >>> format(Vector([0, 0, 0]), '0.5fh') '<0.00000, 0.00000, 0.00000>' >>> format(Vector([-1, -1, -1, -1]), 'h') # doctest:+ELLIPSIS '<2.0, 2.09439..., 2.18627..., 3.92699...>' >>> format(Vector([2, 2, 2, 2]), '.3eh') '<4.000e+00, 1.047e+00, 9.553e-01, 7.854e-01>' >>> format(Vector([0, 1, 0, 0]), '0.5fh') '<1.00000, 1.57080, 0.00000, 0.00000>' \"\"\"\n\nfrom array import array import reprlib import math import functools import operator\n\n422\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 1402,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 453,
      "content": "import itertools\n\nclass Vector: typecode = 'd'\n\ndef __init__(self, components): self._components = array(self.typecode, components)\n\ndef __iter__(self): return iter(self._components)\n\ndef __repr__(self): components = reprlib.repr(self._components) components = components[components.find('['):-1] return f'Vector({components})'\n\ndef __str__(self): return str(tuple(self))\n\ndef __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(self._components))\n\ndef __eq__(self, other): return (len(self) == len(other) and all(a == b for a, b in zip(self, other)))\n\ndef __hash__(self): hashes = (hash(x) for x in self) return functools.reduce(operator.xor, hashes, 0)\n\ndef __abs__(self): return math.hypot(*self)\n\ndef __bool__(self): return bool(abs(self))\n\ndef __len__(self): return len(self._components)\n\ndef __getitem__(self, key): if isinstance(key, slice): cls = type(self) return cls(self._components[key]) index = operator.index(key) return self._components[index]\n\n__match_args__ = ('x', 'y', 'z', 't')\n\ndef __getattr__(self, name): cls = type(self)\n\nVector Take #5: Formatting\n\n|\n\n423",
      "content_length": 1089,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 454,
      "content": "try: pos = cls.__match_args__.index(name) except ValueError: pos = -1 if 0 <= pos < len(self._components): return self._components[pos] msg = f'{cls.__name__!r} object has no attribute {name!r}' raise AttributeError(msg)\n\ndef angle(self, n): r = math.hypot(*self[n:]) a = math.atan2(r, self[n-1]) if (n == len(self) - 1) and (self[-1] < 0): return math.pi * 2 - a else: return a\n\ndef angles(self): return (self.angle(n) for n in range(1, len(self)))\n\ndef __format__(self, fmt_spec=''): if fmt_spec.endswith('h'): # hyperspherical coordinates fmt_spec = fmt_spec[:-1] coords = itertools.chain([abs(self)], self.angles()) outer_fmt = '<{}>' else: coords = self outer_fmt = '({})' components = (format(c, fmt_spec) for c in coords) return outer_fmt.format(', '.join(components))\n\n@classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(memv)\n\nImport itertools to use chain function in __format__.\n\nCompute one of the angular coordinates, using formulas adapted from the n-sphere article.\n\nCreate a generator expression to compute all angular coordinates on demand.\n\nUse itertools.chain to produce genexp to iterate seamlessly over the magni‐ tude and the angular coordinates.\n\nConfigure a spherical coordinate display with angular brackets.\n\n424\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 1355,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 455,
      "content": "Configure a Cartesian coordinate display with parentheses.\n\nCreate a generator expression to format each coordinate item on demand.\n\nPlug parentheses.\n\nformatted components separated by commas\n\ninside brackets or\n\nWe are making heavy use of generator expressions in __format__, angle, and angles, but our focus here is in providing __format__ to bring Vector to the same implementation level as Vector2d. When we cover generators in Chapter 17, we’ll use some of the code in Vector as examples, and then the generator tricks will be explained in detail.\n\nThis concludes our mission for this chapter. The Vector class will be enhanced with infix operators in Chapter 16, but our goal here was to explore techniques for coding special methods that are useful in a wide variety of collection classes.\n\nChapter Summary The Vector example in this chapter was designed to be compatible with Vector2d, except for the use of a different constructor signature accepting a single iterable argu‐ ment, just like the built-in sequence types do. The fact that Vector behaves as a sequence just by implementing __getitem__ and __len__ prompted a discussion of protocols, the informal interfaces used in duck-typed languages.\n\nWe then looked at how the my_seq[a:b:c] syntax works behind the scenes, by creat‐ ing a slice(a, b, c) object and handing it to __getitem__. Armed with this knowl‐ edge, we made Vector respond correctly to slicing, by returning new Vector instances, just like a Pythonic sequence is expected to do.\n\nThe next step was to provide read-only access to the first few Vector components using notation such as my_vec.x. We did it by implementing __getattr__. Doing that opened the possibility of tempting the user to assign to those special components by writing my_vec.x = 7, revealing a potential bug. We fixed it by implementing __setattr__ as well, to forbid assigning values to single-letter attributes. Very often, when you code a __getattr__ you need to add __setattr__ too, in order to avoid inconsistent behavior.\n\nImplementing the __hash__ function provided the perfect context for using func tools.reduce, because we needed to apply the xor operator ^ in succession to the hashes of all Vector components to produce an aggregate hash code for the whole\n\nChapter Summary\n\n|\n\n425",
      "content_length": 2294,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 456,
      "content": "Vector. After applying reduce in __hash__, we used the all reducing built-in to cre‐ ate a more efficient __eq__ method.\n\nThe last enhancement to Vector was to reimplement the __format__ method from Vector2d by supporting spherical coordinates as an alternative to the default Carte‐ sian coordinates. We used quite a bit of math and several generators to code __for mat__ and its auxiliary functions, but these are implementation details—and we’ll come back to the generators in Chapter 17. The goal of that last section was to sup‐ port a custom format, thus fulfilling the promise of a Vector that could do everything a Vector2d did, and more.\n\nAs we did in Chapter 11, here we often looked at how standard Python objects behave, to emulate them and provide a “Pythonic” look-and-feel to Vector.\n\nIn Chapter 16, we will implement several infix operators on Vector. The math will be much simpler than in the angle() method here, but exploring how infix operators work in Python is a great lesson in OO design. But before we get to operator over‐ loading, we’ll step back from working on one class and look at organizing multiple classes with interfaces and inheritance, the subjects of Chapters 13 and 14.\n\nFurther Reading Most special methods covered in the Vector example also appear in the Vector2d example from Chapter 11, so the references in “Further Reading” on page 392 are all relevant here.\n\nThe powerful reduce higher-order function is also known as fold, accumulate, aggre‐ gate, compress, and inject. For more information, see Wikipedia’s “Fold (higher- order function)” article, which presents applications of that higher-order function with emphasis on functional programming with recursive data structures. The article also includes a table listing fold-like functions in dozens of programming languages.\n\n“What’s New in Python 2.5” has a short explanation of __index__, designed to sup‐ port __getitem__ methods, as we saw in “A Slice-Aware __getitem__” on page 406. PEP 357—Allowing Any Object to be Used for Slicing details the need for it from the perspective of an implementor of a C-extension—Travis Oliphant, the primary crea‐ tor of NumPy. Oliphant’s many contributions to Python made it a leading scientific computing language, which then positioned it to lead the way in machine learning applications.\n\n426\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 2380,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 457,
      "content": "Soapbox\n\nProtocols as Informal Interfaces\n\nProtocols are not an invention of Python. The Smalltalk team, which also coined the expression “object-oriented,” used “protocol” as a synonym for what we now call interfaces. Some Smalltalk programming environments allowed programmers to tag a group of methods as a protocol, but that was merely a documentation and navigation aid, and not enforced by the language. That’s why I believe “informal interface” is a reasonable short explanation for “protocol” when I speak to an audience that is more familiar with formal (and compiler enforced) interfaces.\n\nEstablished protocols naturally evolve in any language that uses dynamic typing, that is, when type checking is done at runtime because there is no static type information in method signatures and variables. Ruby is another important object-oriented lan‐ guage that has dynamic typing and uses protocols.\n\nIn the Python documentation, you can often tell when a protocol is being discussed when you see language like “a file-like object.” This is a quick way of saying “some‐ thing that behaves sufficiently like a file, by implementing the parts of the file inter‐ face that are relevant in the context.”\n\nYou may think that implementing only part of a protocol is sloppy, but it has the advantage of keeping things simple. Section 3.3 of the “Data Model” chapter suggests:\n\nWhen implementing a class that emulates any built-in type, it is important that the emulation only be implemented to the degree that it makes sense for the object being modeled. For example, some sequences may work well with retrieval of individual elements, but extracting a slice may not make sense.\n\nWhen we don’t need to code nonsense methods just to fulfill some overdesigned interface contract and keep the compiler happy, it becomes easier to follow the KISS principle.\n\nOn the other hand, if you want to use a type checker to verify your protocol imple‐ mentations, then a stricter definition of protocol is required. That’s what typing.Pro tocol provides.\n\nI’ll have more to say about protocols and interfaces in Chapter 13, where they are the main focus.\n\nOrigins of Duck Typing\n\nI believe the Ruby community, more than any other, helped popularize the term “duck typing,” as they preached to the Java masses. But the expression has been used in Python discussions before either Ruby or Python were “popular.” According to Wikipedia, an early example of the duck analogy in object-oriented programming is a message to the Python-list by Alex Martelli from July 26, 2000: “polymorphism (was\n\nFurther Reading\n\n|\n\n427",
      "content_length": 2599,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 458,
      "content": "Re: Type checking in python?)”. That’s where the quote at the beginning of this chap‐ ter comes from. If you are curious about the literary origins of the “duck typing” term, and the applications of this OO concept in many languages, check out Wikipe‐ dia’s “Duck typing” entry.\n\nA Safe__format__, with Enhanced Usability\n\nWhile implementing __format__, I did not take any precautions regarding Vector instances with a very large number of components, as we did in __repr__ using reprlib. The reasoning is that repr() is for debugging and logging, so it must always generate some serviceable output, while __format__ is used to display output to end users who presumably want to see the entire Vector. If you think this is dangerous, then it would be cool to implement a further extension to the Format Specifier Mini- Language.\n\nHere is how I’d do it: by default, any formatted Vector would display a reasonable but limited number of components, say 30. If there are more elements than that, the default behavior would be similar to what the reprlib does: chop the excess and put ... in its place. However, if the format specifier ended with the special * code, meaning “all,” then the size limitation would be disabled. So a user who’s unaware of the problem of very long displays will not be bitten by it by accident. But if the default limitation becomes a nuisance, then the presence of the ... could lead the user to search the documentation and discover the * formatting code.\n\nThe Search for a Pythonic Sum\n\nThere’s no single answer to “What is Pythonic?” just as there’s no single answer to “What is beautiful?” Saying, as I often do, that it means using “idiomatic Python” is not 100% satisfactory, because what may be “idiomatic” for you may not be for me. One thing I know: “idiomatic” does not mean using the most obscure language fea‐ tures.\n\nIn the Python-list, there’s a thread titled “Pythonic Way to Sum n-th List Element?” from April 2003. It’s relevant to our discussion of reduce in this chapter.\n\nThe original poster, Guy Middleton, asked for an improvement on this solution, stat‐ ing he did not like to use lambda:7\n\n>>> my_list = [[1, 2, 3], [40, 50, 60], [9, 8, 7]] >>> import functools >>> functools.reduce(lambda a, b: a+b, [sub[1] for sub in my_list]) 60\n\n7 I adapted the code for this presentation: in 2003, reduce was a built-in, but in Python 3 we need to import it;\n\nalso, I replaced the names x and y with my_list and sub, for sub-list.\n\n428\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 2521,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 459,
      "content": "That code uses lots of idioms: lambda, reduce, and a list comprehension. It would probably come last in a popularity contest, because it offends people who hate lambda and those who despise list comprehensions—pretty much both sides of a divide.\n\nIf you’re going to use lambda, there’s probably no reason to use a list comprehension —except for filtering, which is not the case here.\n\nHere is a solution of my own that will please the lambda lovers:\n\n>>> functools.reduce(lambda a, b: a + b[1], my_list, 0) 60\n\nI did not take part in the original thread, and I wouldn’t use that in real code, because I don’t like lambda too much myself, but I wanted to show an example without a list comprehension.\n\nThe first answer came from Fernando Perez, creator of IPython, highlighting that NumPy supports n-dimensional arrays and n-dimensional slicing:\n\n>>> import numpy as np >>> my_array = np.array(my_list) >>> np.sum(my_array[:, 1]) 60\n\nI think Perez’s solution is cool, but Guy Middleton praised this next solution, by Paul Rubin and Skip Montanaro:\n\n>>> import operator >>> functools.reduce(operator.add, [sub[1] for sub in my_list], 0) 60\n\nThen Evan Simpson asked, “What’s wrong with this?”:\n\n>>> total = 0 >>> for sub in my_list: ... total += sub[1] ... >>> total 60\n\nLots of people agreed that was quite Pythonic. Alex Martelli went as far as saying that’s probably how Guido would code it.\n\nI like Evan Simpson’s code, but I also like David Eppstein’s comment on it:\n\nIf you want the sum of a list of items, you should write it in a way that looks like “the sum of a list of items,” not in a way that looks like “loop over these items, maintain another variable t, perform a sequence of additions.” Why do we have high-level lan‐ guages if not to express our intentions at a higher level and let the language worry about what low-level operations are needed to implement it?\n\nFurther Reading\n\n|\n\n429",
      "content_length": 1901,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 460,
      "content": "Then Alex Martelli comes back to suggest:\n\n“The sum” is so frequently needed that I wouldn’t mind at all if Python singled it out as a built-in. But “reduce(operator.add, …” just isn’t a great way to express it, in my opinion (and yet as an old APL’er, and FP-liker, I should like it—but I don’t).\n\nAlex goes on to suggest a sum() function, which he contributed. It became a built-in in Python 2.3, released only three months after that conversation took place. So Alex’s preferred syntax became the norm:\n\n>>> sum([sub[1] for sub in my_list]) 60\n\nBy the end of the next year (November 2004), Python 2.4 was launched with genera‐ tor expressions, providing what is now in my opinion the most Pythonic answer to Guy Middleton’s original question:\n\n>>> sum(sub[1] for sub in my_list) 60\n\nThis is not only more readable than reduce but also avoids the trap of the empty sequence: sum([]) is 0, simple as that.\n\nIn the same conversation, Alex Martelli suggests the reduce built-in in Python 2 was more trouble than it was worth, because it encouraged coding idioms that were hard to explain. He was most convincing: the function was demoted to the functools module in Python 3.\n\nStill, functools.reduce has its place. It solved the problem of our Vector.__hash__ in a way that I would call Pythonic.\n\n430\n\n|\n\nChapter 12: Special Methods for Sequences",
      "content_length": 1346,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 461,
      "content": "CHAPTER 13 Interfaces, Protocols, and ABCs\n\nProgram to an interface, not an implementation.\n\n—Gamma, Helm, Johnson, Vlissides, First Principle of Object-Oriented Design1\n\nObject-oriented programming is all about interfaces. The best approach to under‐ standing a type in Python is knowing the methods it provides—its interface—as dis‐ cussed in “Types Are Defined by Supported Operations” on page 260 (Chapter 8).\n\nDepending on the programming language, we have one or more ways of defining and using interfaces. Since Python 3.8, we have four ways. They are depicted in the Typing Map (Figure 13-1). We can summarize them like this:\n\nDuck typing\n\nPython’s default approach to typing from the beginning. We’ve been studying duck typing since Chapter 1.\n\nGoose typing\n\nThe approach supported by abstract base classes (ABCs) since Python 2.6, which relies on runtime checks of objects against ABCs. Goose typing is a major subject in this chapter.\n\nStatic typing\n\nThe traditional approach of statically-typed languages like C and Java; supported since Python 3.5 by the typing module, and enforced by external type checkers compliant with PEP 484—Type Hints. This is not the theme of this chapter. Most of Chapter 8 and the upcoming Chapter 15 are about static typing.\n\n1 Design Patterns: Elements of Reusable Object-Oriented Software, “Introduction,” p. 18.\n\n431",
      "content_length": 1361,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 462,
      "content": "Static duck typing\n\nAn approach made popular by the Go language; supported by subclasses of typ ing.Protocol—new in Python 3.8—also enforced by external type checkers. We first saw this in “Static Protocols” on page 286 (Chapter 8).\n\nThe Typing Map The four typing approaches depicted in Figure 13-1 are complementary: they have different pros and cons. It doesn’t make sense to dismiss any of them.\n\nFigure 13-1. The top half describes runtime type checking approaches using just the Python interpreter; the bottom requires an external static type checker such as MyPy or an IDE like PyCharm. The left quadrants cover typing based on the object’s structure— i.e., the methods provided by the object, regardless of the name of its class or super‐ classes; the right quadrants depend on objects having explicitly named types: the name of the object’s class, or the name of its superclasses.\n\nEach of these four approaches rely on interfaces to work, but static typing can be done—poorly—using only concrete types instead of interface abstractions like proto‐ cols and abstract base classes. This chapter is about duck typing, goose typing, and static duck typing—typing disciplines that revolve around interfaces.\n\n432\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1265,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 463,
      "content": "This chapter is split in four main sections, addressing three of the four quadrants in the Typing Map (Figure 13-1):\n\n“Two Kinds of Protocols” on page 434 compares the two forms of structural typing with protocols—i.e., the lefthand side of the Typing Map.\n\n“Programming Ducks” on page 435 dives deeper into Python’s usual duck typing, including how to make it safer while preserving its major strength: flexibility.\n\n“Goose Typing” on page 442 explains the use of ABCs for stricter runtime type checking. This is the longest section, not because it’s more important, but because there are more sections about duck typing, static duck typing, and static typing elsewhere in the book.\n\n“Static Protocols” on page 466 covers usage, implementation, and design of typ ing.Protocol subclasses—useful for static and runtime type checking.\n\nWhat’s New in This Chapter This chapter was heavily edited and is about 24% longer than the corresponding Chapter 11 in the first edition of Fluent Python. Although some sections and many paragraphs are the same, there’s a lot of new content. These are the highlights:\n\nThe chapter introduction and the Typing Map (Figure 13-1) are new. That’s the key to most new content in this chapter—and all other chapters related to typing in Python ≥ 3.8.\n\n“Two Kinds of Protocols” on page 434 explains the similarities and differences between dynamic and static protocols.\n\n“Defensive Programming and ‘Fail Fast’” on page 440 mostly reproduces content from the first edition, but was updated and now has a section title to highlight its importance.\n\n“Static Protocols” on page 466 is all new. It builds on the initial presentation in “Static Protocols” on page 286 (Chapter 8).\n\nUpdated class diagrams of collections.abc in Figures 13-2, 13-3, and 13-4 to include the Collection ABC, from Python 3.6.\n\nThe first edition of Fluent Python had a section encouraging use of the numbers ABCs for goose typing. In “The numbers ABCs and Numeric Protocols” on page 478, I explain why you should use numeric static protocols from the typing module instead, if you plan to use static type checkers as well as runtime checks in the style of goose typing.\n\nWhat’s New in This Chapter\n\n|\n\n433",
      "content_length": 2204,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 464,
      "content": "Two Kinds of Protocols The word protocol has different meanings in computer science depending on context. A network protocol such as HTTP specifies commands that a client can send to a server, such as GET, PUT, and HEAD. We saw in “Protocols and Duck Typing” on page 402 that an object protocol specifies methods which an object must provide to fulfill a role. The FrenchDeck example in Chapter 1 demonstrated one object protocol, the sequence protocol: the methods that allow a Python object to behave as a sequence.\n\nImplementing a full protocol may require several methods, but often it is OK to implement only part of it. Consider the Vowels class in Example 13-1.\n\nExample 13-1. Partial sequence protocol implementation with __getitem__\n\n>>> class Vowels: ... def __getitem__(self, i): ... return 'AEIOU'[i] ... >>> v = Vowels() >>> v[0] 'A' >>> v[-1] 'U' >>> for c in v: print(c) ... A E I O U >>> 'E' in v True >>> 'Z' in v False\n\nImplementing __getitem__ is enough to allow retrieving items by index, and also to support iteration and the in operator. The __getitem__ special method is really the key to the sequence protocol. Take a look at this entry from the Python/C API Refer‐ ence Manual, “Sequence Protocol” section:\n\nint PySequence_Check(PyObject *o)\n\nReturn 1 if the object provides sequence protocol, and 0 otherwise. Note that it returns 1 for Python classes with a __getitem__() method unless they are dict subclasses […].\n\nWe expect a sequence to also support len(), by implementing __len__. Vowels has no __len__ method, but it still behaves as a sequence in some contexts. And that may\n\n434\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1661,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 465,
      "content": "be enough for our purposes. That is why I like to say that a protocol is an “informal interface.” That is also how protocols are understood in Smalltalk, the first object- oriented programming environment to use that term.\n\nExcept in pages about network programming, most uses of the word “protocol” in the Python documentation refer to these informal interfaces.\n\nNow, with the adoption of PEP 544—Protocols: Structural subtyping (static duck typing) in Python 3.8, the word “protocol” has another meaning in Python—closely related, but different. As we saw in “Static Protocols” on page 286 (Chapter 8), PEP 544 allows us to create subclasses of typing.Protocol to define one or more methods that a class must implement (or inherit) to satisfy a static type checker.\n\nWhen I need to be specific, I will adopt these terms:\n\nDynamic protocol\n\nThe informal protocols Python always had. Dynamic protocols are implicit, defined by convention, and described in the documentation. Python’s most important dynamic protocols are supported by the interpreter itself, and are doc‐ umented in the “Data Model” chapter of The Python Language Reference.\n\nStatic protocol\n\nA protocol as defined by PEP 544—Protocols: Structural subtyping (static duck typing), since Python 3.8. A static protocol has an explicit definition: a typ ing.Protocol subclass.\n\nThere are two key differences between them:\n\nAn object may implement only part of a dynamic protocol and still be useful; but to fulfill a static protocol, the object must provide every method declared in the protocol class, even if your program doesn’t need them all.\n\nStatic protocols can be verified by static type checkers, but dynamic protocols can’t.\n\nBoth kinds of protocols share the essential characteristic that a class never needs to declare that it supports a protocol by name, i.e., by inheritance.\n\nIn addition to static protocols, Python provides another way of defining an explicit interface in code: an abstract base class (ABC).\n\nThe rest of this chapter covers dynamic and static protocols, as well as ABCs.\n\nProgramming Ducks Let’s start our discussion of dynamic protocols with two of the most important in Python: the sequence and iterable protocols. The interpreter goes out of its way to\n\nProgramming Ducks\n\n|\n\n435",
      "content_length": 2279,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 466,
      "content": "handle objects that provide even a minimal implementation of those protocols, as the next section explains.\n\nPython Digs Sequences The philosophy of the Python Data Model is to cooperate with essential dynamic protocols as much as possible. When it comes to sequences, Python tries hard to work with even the simplest implementations.\n\nFigure 13-2 shows how the Sequence interface is formalized as an ABC. The Python interpreter and built-in sequences like list, str, etc., do not rely on that ABC at all. I am using it only to describe what a full-fledged Sequence is expected to support.\n\nFigure 13-2. UML class diagram for the Sequence ABC and related abstract classes from collections.abc. Inheritance arrows point from a subclass to its superclasses. Names in italic are abstract methods. Before Python 3.6, there was no Collection ABC—Sequence was a direct subclass of Container, Iterable, and Sized.\n\nMost ABCs in the collections.abc module exist to formalize interfaces that are implemented by built-in objects and are implic‐ itly supported by the interpreter—both of which predate the ABCs themselves. The ABCs are useful as starting points for new classes, and to support explicit type checking at runtime (a.k.a. goose typ‐ ing) as well as type hints for static type checkers.\n\nStudying Figure 13-2, we see that a correct subclass of Sequence must implement __getitem__ and __len__ (from Sized). All the other methods in Sequence are con‐ crete, so subclasses can inherit their implementations—or provide better ones.\n\nNow, recall the Vowels class in Example 13-1. It does not inherit from abc.Sequence and it only implements __getitem__.\n\nThere is no __iter__ method, yet Vowels instances are iterable because—as a fallback —if Python finds a __getitem__ method, it tries to iterate over the object by calling that method with integer indexes starting with 0. Because Python is smart enough to\n\n436\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1959,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 467,
      "content": "iterate over Vowels instances, it can also make the in operator work even when the __contains__ method is missing: it does a sequential scan to check if an item is present.\n\nIn summary, given the importance of sequence-like data structures, Python manages to make iteration and the in operator work by invoking __getitem__ when __iter__ and __contains__ are unavailable.\n\nThe original FrenchDeck from Chapter 1 does not subclass abc.Sequence either, but it does implement both methods of the sequence protocol: __getitem__ and __len__. See Example 13-2.\n\nExample 13-2. A deck as a sequence of cards (same as Example 1-1)\n\nimport collections\n\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n\nclass FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split()\n\ndef __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\ndef __len__(self): return len(self._cards)\n\ndef __getitem__(self, position): return self._cards[position]\n\nSeveral of the examples in Chapter 1 work because of the special treatment Python gives to anything vaguely resembling a sequence. The iterable protocol in Python represents an extreme form of duck typing: the interpreter tries two different meth‐ ods to iterate over objects.\n\nTo be clear, the behaviors I described in this section are implemented in the inter‐ preter itself, mostly in C. They do not depend on methods from the Sequence ABC. For example, the concrete methods __iter__ and __contains__ in the Sequence class emulate the built-in behaviors of the Python interpreter. If you are curious, check the source code of these methods in Lib/_collections_abc.py.\n\nNow let’s study another example emphasizing the dynamic nature of protocols—and why static type checkers have no chance of dealing with them.\n\nProgramming Ducks\n\n|\n\n437",
      "content_length": 1866,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 468,
      "content": "Monkey Patching: Implementing a Protocol at Runtime Monkey patching is dynamically changing a module, class, or function at runtime, to add features or fix bugs. For example, the gevent networking library monkey patches parts of Python’s standard library to allow lightweight concurrency without threads or async/await.2\n\nThe FrenchDeck class from Example 13-2 is missing an essential feature: it cannot be shuffled. Years ago when I first wrote the FrenchDeck example, I did implement a shuffle method. Later I had a Pythonic insight: if a FrenchDeck acts like a sequence, then it doesn’t need its own shuffle method because there is already random.shuf fle, documented as “Shuffle the sequence x in place.”\n\nThe standard random.shuffle function is used like this:\n\n>>> from random import shuffle >>> l = list(range(10)) >>> shuffle(l) >>> l [5, 2, 9, 7, 8, 3, 1, 4, 0, 6]\n\nWhen you follow established protocols, you improve your chances of leveraging existing standard library and third-party code, thanks to duck typing.\n\nHowever, if we try to shuffle a FrenchDeck instance, we get an exception, as in Example 13-3.\n\nExample 13-3. random.shuffle cannot handle FrenchDeck\n\n>>> from random import shuffle >>> from frenchdeck import FrenchDeck >>> deck = FrenchDeck() >>> shuffle(deck) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \".../random.py\", line 265, in shuffle x[i], x[j] = x[j], x[i] TypeError: 'FrenchDeck' object does not support item assignment\n\nThe error message is clear: 'FrenchDeck' object does not support item assign ment. The problem is that shuffle operates in place, by swapping items inside the\n\n2 The “Monkey patch” article on Wikipedia has a funny example in Python.\n\n438\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1774,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 469,
      "content": "collection, and FrenchDeck only implements the immutable sequence protocol. Mutable sequences must also provide a __setitem__ method.\n\nBecause Python is dynamic, we can fix this at runtime, even at the interactive console. Example 13-4 shows how to do it.\n\nExample 13-4. Monkey patching FrenchDeck to make it mutable and compatible with random.shuffle (continuing from Example 13-3)\n\n>>> def set_card(deck, position, card): ... deck._cards[position] = card ... >>> FrenchDeck.__setitem__ = set_card >>> shuffle(deck) >>> deck[:5] [Card(rank='3', suit='hearts'), Card(rank='4', suit='diamonds'), Card(rank='4', suit='clubs'), Card(rank='7', suit='hearts'), Card(rank='9', suit='spades')]\n\nCreate a function that takes deck, position, and card as arguments.\n\nAssign that function to an attribute named __setitem__ in the FrenchDeck class.\n\ndeck can now be shuffled because I added the necessary method of the mutable sequence protocol.\n\nThe signature of the __setitem__ special method is defined in The Python Language Reference in “3.3.6. Emulating container types”. Here I named the arguments deck, position, card—and not self, key, value as in the language reference—to show that every Python method starts life as a plain function, and naming the first argu‐ ment self is merely a convention. This is OK in a console session, but in a Python source file it’s much better to use self, key, and value as documented.\n\nThe trick is that set_card knows that the deck object has an attribute named _cards, and _cards must be a mutable sequence. The set_card function is then attached to the FrenchDeck class as the __setitem__ special method. This is an example of mon‐ key patching: changing a class or module at runtime, without touching the source code. Monkey patching is powerful, but the code that does the actual patching is very tightly coupled with the program to be patched, often handling private and undocu‐ mented attributes.\n\nBesides being an example of monkey patching, Example 13-4 highlights the dynamic nature of protocols in dynamic duck typing: random.shuffle doesn’t care about the class of the argument, it only needs the object to implement methods from the muta‐ ble sequence protocol. It doesn’t even matter if the object was “born” with the neces‐ sary methods or if they were somehow acquired later.\n\nProgramming Ducks\n\n|\n\n439",
      "content_length": 2349,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 470,
      "content": "Duck typing doesn’t need to be wildly unsafe or hard to debug. The next section shows some useful code patterns to detect dynamic protocols without resorting to explicit checks.\n\nDefensive Programming and “Fail Fast” Defensive programming is like defensive driving: a set of practices to enhance safety even when faced with careless programmers—or drivers.\n\nMany bugs cannot be caught except at runtime—even in mainstream statically typed languages.3 In a dynamically typed language, “fail fast” is excellent advice for safer and easier-to-maintain programs. Failing fast means raising runtime errors as soon as possible, for example, rejecting invalid arguments right a the beginning of a func‐ tion body.\n\nHere is one example: when you write code that accepts a sequence of items to process internally as a list, don’t enforce a list argument by type checking. Instead, take the argument and immediately build a list from it. One example of this code pattern is the __init__ method in Example 13-10, later in this chapter:\n\ndef __init__(self, iterable): self._balls = list(iterable)\n\nThat way you make your code more flexible, because the list() constructor handles any iterable that fits in memory. If the argument is not iterable, the call will fail fast with a very clear TypeError exception, right when the object is initialized. If you want to be more explict, you can wrap the list() call with try/except to customize the error message—but I’d use that extra code only on an external API, because the prob‐ lem would be easy to see for maintainers of the codebase. Either way, the offending call will appear near the end of the traceback, making it straightforward to fix. If you don’t catch the invalid argument in the class constructor, the program will blow up later, when some other method of the class needs to operate on self._balls and it is not a list. Then the root cause will be harder to find.\n\nOf course, calling list() on the argument would be bad if the data shouldn’t be copied, either because it’s too large or because the function, by design, needs to change it in place for the benefit of the caller, like random.shuffle does. In that case, a runtime check like isinstance(x, abc.MutableSequence) would be the way to go.\n\nIf you are afraid to get an infinite generator—not a common issue—you can begin by calling len() on the argument. This would reject iterators, while safely dealing with tuples, arrays, and other existing or future classes that fully implement the Sequence\n\n3 That’s why automated testing is necessary.\n\n440\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 2602,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 471,
      "content": "interface. Calling len() is usually very cheap, and an invalid argument will raise an error immediately.\n\nOn the other hand, if any iterable is acceptable, then call iter(x) as soon as possible to obtain an iterator, as we’ll see in “Why Sequences Are Iterable: The iter Function” on page 596. Again, if x is not iterable, this will fail fast with an easy-to-debug exception.\n\nIn the cases I just described, a type hint could catch some problems earlier, but not all problems. Recall that the type Any is consistent-with every other type. Type inference may cause a variable to be tagged with the Any type. When that happens, the type checker is in the dark. In addition, type hints are not enforced at runtime. Fail fast is the last line of defense.\n\nDefensive code leveraging duck types can also include logic to handle different types without using isinstance() or hasattr() tests.\n\nOne example is how we might emulate the handling of the field_names argument in collections.namedtuple: field_names accepts a single string with identifiers sepa‐ rated by spaces or commas, or a sequence of identifiers. Example 13-5 shows how I’d do it using duck typing.\n\nExample 13-5. Duck typing to handle a string or an iterable of strings\n\ntry: field_names = field_names.replace(',', ' ').split() except AttributeError: pass field_names = tuple(field_names) if not all(s.isidentifier() for s in field_names): raise ValueError('field_names must all be valid identifiers')\n\nAssume it’s a string (EAFP = it’s easier to ask forgiveness than permission).\n\nConvert commas to spaces and split the result into a list of names.\n\nSorry, field_names doesn’t quack like a str: it has no .replace, or it returns something we can’t .split.\n\nIf AttributeError was raised, then field_names is not a str and we assume it was already an iterable of names.\n\nTo make sure it’s an iterable and to keep our own copy, create a tuple out of what we have. A tuple is more compact than list, and it also prevents my code from changing the names by mistake.\n\nProgramming Ducks\n\n|\n\n441",
      "content_length": 2048,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 472,
      "content": "Use str.isidentifier to ensure every name is valid.\n\nExample 13-5 shows one situation where duck typing is more expressive than static type hints. There is no way to spell a type hint that says “field_names must be a string of identifiers separated by spaces or commas.” This is the relevant part of the namedtuple signature on typeshed (see the full source at stdlib/3/collections/ __init__.pyi):\n\ndef namedtuple( typename: str, field_names: Union[str, Iterable[str]], *, # rest of signature omitted\n\nAs you can see, field_names is annotated as Union[str, Iterable[str]], which is OK as far as it goes, but is not enough to catch all possible problems.\n\nAfter reviewing dynamic protocols, we move to a more explicit form of runtime type checking: goose typing.\n\nGoose Typing\n\nAn abstract class represents an interface. —Bjarne Stroustrup, creator of C++4\n\nPython doesn’t have an interface keyword. We use abstract base classes (ABCs) to define interfaces for explicit type checking at runtime—also supported by static type checkers.\n\nThe Python Glossary entry for abstract base class has a good explanation of the value they bring to duck-typed languages:\n\nAbstract base classes complement duck typing by providing a way to define interfaces when other techniques like hasattr() would be clumsy or subtly wrong (for example, with magic methods). ABCs introduce virtual subclasses, which are classes that don’t inherit from a class but are still recognized by isinstance() and issubclass(); see the abc module documentation.5\n\nGoose typing is a runtime type checking approach that leverages ABCs. I will let Alex Martelli explain in “Waterfowl and ABCs” on page 443.\n\n4 Bjarne Stroustrup, The Design and Evolution of C++, p. 278 (Addison-Wesley).\n\n5 Retrieved October 18, 2020.\n\n442\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1830,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 473,
      "content": "I am very grateful to my friends Alex Martelli and Anna Raven‐ scroft. I showed them the first outline of Fluent Python at OSCON 2013, and they encouraged me to submit it for publication with O’Reilly. Both later contributed with thorough tech reviews. Alex was already the most cited person in this book, and then he offered to write this essay. Take it away, Alex!\n\nWaterfowl and ABCs\n\nBy Alex Martelli\n\nI’ve been credited on Wikipedia for helping spread the helpful meme and sound-bite “duck typing” (i.e, ignoring an object’s actual type, focusing instead on ensuring that the object implements the method names, signatures, and semantics required for its intended use).\n\nIn Python, this mostly boils down to avoiding the use of isinstance to check the object’s type (not to mention the even worse approach of checking, for example, whether type(foo) is bar—which is rightly anathema as it inhibits even the sim‐ plest forms of inheritance!).\n\nThe overall duck typing approach remains quite useful in many contexts—and yet, in many others, an often preferable one has evolved over time. And herein lies a tale…\n\nIn recent generations, the taxonomy of genus and species (including, but not limited to, the family of waterfowl known as Anatidae) has mostly been driven by phenetics— an approach focused on similarities of morphology and behavior…chiefly, observable traits. The analogy to “duck typing” was strong.\n\nHowever, parallel evolution can often produce similar traits, both morphological and behavioral ones, among species that are actually unrelated, but just happened to evolve in similar, though separate, ecological niches. Similar “accidental similarities” happen in programming, too—for example, consider the classic object-oriented pro‐ gramming example:\n\nclass Artist: def draw(self): ...\n\nclass Gunslinger: def draw(self): ...\n\nclass Lottery: def draw(self): ...\n\nClearly, the mere existence of a method named draw, callable without arguments, is far from sufficient to assure us that two objects x and y, such that x.draw() and y.draw() can be called, are in any way exchangeable or abstractly equivalent—\n\nGoose Typing\n\n|\n\n443",
      "content_length": 2148,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 474,
      "content": "nothing about the similarity of the semantics resulting from such calls can be infer‐ red. Rather, we need a knowledgeable programmer to somehow positively assert that such an equivalence holds at some level!\n\nIn biology (and other disciplines), this issue has led to the emergence (and, on many facets, the dominance) of an approach that’s an alternative to phenetics, known as cladistics—focusing taxonomical choices on characteristics that are inherited from common ancestors, rather than ones that are independently evolved. (Cheap and rapid DNA sequencing can make cladistics highly practical in many more cases in recent years.)\n\nFor example, sheldgeese (once classified as being closer to other geese) and shelducks (once classified as being closer to other ducks) are now grouped together within the subfamily Tadornidae (implying they’re closer to each other than to any other Anatidae, as they share a closer common ancestor). Furthermore, DNA analysis has shown, in particular, that the white-winged wood duck is not as close to the Muscovy duck (the latter being a shelduck) as similarity in looks and behavior had long sug‐ gested—so the wood duck was reclassified into its own genus, and entirely out of the subfamily!\n\nDoes this matter? It depends on the context! For such purposes as deciding how best to cook a waterfowl once you’ve bagged it, for example, specific observable traits (not all of them—plumage, for example, is de minimis in such a context), mostly texture and flavor (old-fashioned phenetics!), may be far more relevant than cladistics. But for other issues, such as susceptibility to different pathogens (whether you’re trying to raise waterfowl in captivity, or preserve them in the wild), DNA closeness can matter much more.\n\nSo, by very loose analogy with these taxonomic revolutions in the world of water‐ fowls, I’m recommending supplementing (not entirely replacing—in certain contexts it shall still serve) good old duck typing with…goose typing!\n\nWhat goose typing means is: isinstance(obj, cls) is now just fine…as long as cls is an abstract base class—in other words, cls’s metaclass is abc.ABCMeta.\n\nYou can find many useful existing abstract classes in collections.abc (and addi‐ tional ones in the numbers module of The Python Standard Library).6\n\nAmong the many conceptual advantages of ABCs over concrete classes (e.g., Scott Meyer’s “all non-leaf classes should be abstract”; see Item 33 in his book, More\n\n6 You can also, of course, define your own ABCs—but I would discourage all but the most advanced Pythonis‐ tas from going that route, just as I would discourage them from defining their own custom metaclasses…and even for said “most advanced Pythonistas,” those of us sporting deep mastery of every fold and crease in the language, these are not tools for frequent use. Such “deep metaprogramming,” if ever appropriate, is intended for authors of broad frameworks meant to be independently extended by vast numbers of separate develop‐ ment teams…less than 1% of “most advanced Pythonistas” may ever need that! — A.M.\n\n444\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 3127,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 475,
      "content": "Effective C++, Addison-Wesley), Python’s ABCs add one major practical advantage: the register class method, which lets end-user code “declare” that a certain class becomes a “virtual” subclass of an ABC (for this purpose, the registered class must meet the ABC’s method name and signature requirements, and more importantly, the underlying semantic contract—but it need not have been developed with any awareness of the ABC, and in particular need not inherit from it!). This goes a long way toward breaking the rigidity and strong coupling that make inheritance some‐ thing to use with much more caution than typically practiced by most object-oriented programmers.\n\nSometimes you don’t even need to register a class for an ABC to recognize it as a subclass!\n\nThat’s the case for the ABCs whose essence boils down to a few special methods. For example:\n\n>>> class Struggle: ... def __len__(self): return 23 ... >>> from collections import abc >>> isinstance(Struggle(), abc.Sized) True\n\nAs you see, abc.Sized recognizes Struggle as “a subclass,” with no need for registra‐ tion, as implementing the special method named __len__ is all it takes (it’s supposed to be implemented with the proper syntax—callable without arguments—and seman‐ tics—returning a nonnegative integer denoting an object’s “length”; any code that implements a specially named method, such as __len__, with arbitrary, non- compliant syntax and semantics has much worse problems anyway).\n\nSo, here’s my valediction: whenever you’re implementing a class embodying any of the concepts represented in the ABCs in numbers, collections.abc, or other frame‐ work you may be using, be sure (if needed) to subclass it from, or register it into, the corresponding ABC. At the start of your programs using some library or framework defining classes which have omitted to do that, perform the registrations yourself; then, when you must check for (most typically) an argument being, e.g, “a sequence,” check whether:\n\nisinstance(the_arg, collections.abc.Sequence)\n\nAnd, don’t define custom ABCs (or metaclasses) in production code. If you feel the urge to do so, I’d bet it’s likely to be a case of the “all problems look like a nail”–syn‐ drome for somebody who just got a shiny new hammer—you (and future maintain‐ ers of your code) will be much happier sticking with straightforward and simple code, eschewing such depths. Valē!\n\nGoose Typing\n\n|\n\n445",
      "content_length": 2414,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 476,
      "content": "To summarize, goose typing entails:\n\nSubclassing from ABCs to make it explict that you are implementing a previously defined interface.\n\nRuntime type checking using ABCs instead of concrete classes as the second argument for isinstance and issubclass.\n\nAlex makes the point that inheriting from an ABC is more than implementing the required methods: it’s also a clear declaration of intent by the developer. That intent can also be made explicit through registering a virtual subclass.\n\nDetails of using register are covered in “A Virtual Subclass of an ABC” on page 460, later in this chapter. For now, here is a brief example: given the FrenchDeck class, if I want it to pass a check like issubclass(FrenchDeck, Sequence), I can make it a virtual sub‐ class of the Sequence ABC with these lines: from collections.abc import Sequence Sequence.register(FrenchDeck)\n\nThe use of isinstance and issubclass becomes more acceptable if you are checking against ABCs instead of concrete classes. If used with concrete classes, type checks limit polymorphism—an essential feature of object-oriented programming. But with ABCs these tests are more flexible. After all, if a component does not implement an ABC by subclassing—but does implement the required methods—it can always be registered after the fact so it passes those explicit type checks.\n\nHowever, even with ABCs, you should beware that excessive use of isinstance checks may be a code smell—a symptom of bad OO design.\n\nIt’s usually not OK to have a chain of if/elif/elif with isinstance checks per‐ forming different actions depending on the type of object: you should be using poly‐ morphism for that—i.e., design your classes so that the interpreter dispatches calls to the proper methods, instead of you hardcoding the dispatch logic in if/elif/elif blocks.\n\nOn the other hand, it’s OK to perform an isinstance check against an ABC if you must enforce an API contract: “Dude, you have to implement this if you want to call me,” as technical reviewer Lennart Regebro put it. That’s particularly useful in sys‐ tems that have a plug-in architecture. Outside of frameworks, duck typing is often simpler and more flexible than type checks.\n\nFinally, in his essay, Alex reinforces more than once the need for restraint in the cre‐ ation of ABCs. Excessive use of ABCs would impose ceremony in a language that\n\n446\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 2413,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 477,
      "content": "became popular because it is practical and pragmatic. During the Fluent Python review process, Alex wrote in an e-mail:\n\nABCs are meant to encapsulate very general concepts, abstractions, introduced by a framework—things like “a sequence” and “an exact number.” [Readers] most likely don’t need to write any new ABCs, just use existing ones correctly, to get 99.9% of the benefits without serious risk of misdesign.\n\nNow let’s see goose typing in practice.\n\nSubclassing an ABC Following Martelli’s advice, we’ll leverage an existing ABC, collections.MutableSe quence, before daring to invent our own. In Example 13-6, FrenchDeck2 is explicitly declared a subclass of collections.MutableSequence.\n\nExample 13-6. frenchdeck2.py: FrenchDeck2, a subclass of collections.MutableSe quence\n\nfrom collections import namedtuple, abc\n\nCard = namedtuple('Card', ['rank', 'suit'])\n\nclass FrenchDeck2(abc.MutableSequence): ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split()\n\ndef __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\ndef __len__(self): return len(self._cards)\n\ndef __getitem__(self, position): return self._cards[position]\n\ndef __setitem__(self, position, value): self._cards[position] = value\n\ndef __delitem__(self, position): del self._cards[position]\n\ndef insert(self, position, value): self._cards.insert(position, value)\n\nGoose Typing\n\n|\n\n447",
      "content_length": 1442,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 478,
      "content": "__setitem__ is all we need to enable shuffling…\n\n…but subclassing MutableSequence forces us to implement __delitem__, an abstract method of that ABC.\n\nWe are also required to implement insert, the third abstract method of MutableSequence.\n\nPython does not check for the implementation of the abstract methods at import time (when the frenchdeck2.py module is loaded and compiled), but only at runtime when we actually try to instantiate FrenchDeck2. Then, if we fail to implement any of the abstract methods, we get a TypeError exception with a message such as \"Can't instantiate abstract class FrenchDeck2 with abstract methods __delitem__, insert\". That’s why we must implement __delitem__ and insert, even if our FrenchDeck2 examples do not need those behaviors: the MutableSequence ABC demands them.\n\nAs Figure 13-3 shows, not all methods of the Sequence and MutableSequence ABCs are abstract.\n\nFigure 13-3. UML class diagram for the MutableSequence ABC and its superclasses from collections.abc (inheritance arrows point from subclasses to ancestors; names in italic are abstract classes and abstract methods).\n\nTo write FrenchDeck2 as a subclass of MutableSequence, I had to pay the price of implementing __delitem__ and insert, which my examples did not require. In return, FrenchDeck2 inherits five concrete methods from Sequence: __contains__, __iter__, __reversed__, index, and count. From MutableSequence, it gets another six methods: append, reverse, extend, pop, remove, and __iadd__—which supports the += operator for in place concatenation.\n\nThe concrete methods in each collections.abc ABC are implemented in terms of the public interface of the class, so they work without any knowledge of the internal structure of instances.\n\n448\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1796,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 479,
      "content": "As the coder of a concrete subclass, you may be able to override methods inherited from ABCs with more efficient implementa‐ tions. For example, __contains__ works by doing a sequential scan of the sequence, but if your concrete sequence keeps its items sor‐ ted, you can write a faster __contains__ that does a binary search using the bisect function from the standard library. See “Manag‐ ing Ordered Sequences with Bisect” at fluentpython.com to learn more about it.\n\nTo use ABCs well, you need to know what’s available. We’ll review the collections ABCs next.\n\nABCs in the Standard Library Since Python 2.6, the standard library provides several ABCs. Most are defined in the collections.abc module, but there are others. You can find ABCs in the io and numbers packages, for example. But the most widely used are in collections.abc.\n\nThere are two modules named abc in the standard library. Here we are talking about collections.abc. To reduce loading time, since Python 3.4 that module is implemented outside of the collections package—in Lib/_collections_abc.py—so it’s imported separately from collections. The other abc module is just abc (i.e., Lib/ abc.py) where the abc.ABC class is defined. Every ABC depends on the abc module, but we don’t need to import it ourselves except to create a brand-new ABC.\n\nFigure 13-4 is a summary UML class diagram (without attribute names) of 17 ABCs defined in collections.abc. The documentation of collections.abc has a nice table summarizing the ABCs, their relationships, and their abstract and concrete methods (called “mixin methods”). There is plenty of multiple inheritance going on in Figure 13-4. We’ll devote most of Chapter 14 to multiple inheritance, but for now it’s enough to say that it is usually not a problem when ABCs are concerned.7\n\n7 Multiple inheritance was considered harmful and excluded from Java, except for interfaces: Java interfaces can\n\nextend multiple interfaces, and Java classes can implement multiple interfaces.\n\nGoose Typing\n\n|\n\n449",
      "content_length": 2016,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 480,
      "content": "Figure 13-4. UML class diagram for ABCs in collections.abc.\n\nLet’s review the clusters in Figure 13-4:\n\nIterable, Container, Sized\n\nEvery collection should either inherit from these ABCs or implement compatible protocols. Iterable supports iteration with __iter__, Container supports the in operator with __contains__, and Sized supports len() with __len__.\n\nCollection\n\nThis ABC has no methods of its own, but was added in Python 3.6 to make it easier to subclass from Iterable, Container, and Sized.\n\nSequence, Mapping, Set\n\nThese are the main immutable collection types, and each has a mutable subclass. A detailed diagram for MutableSequence is in Figure 13-3; for MutableMapping and MutableSet, see Figures 3-1 and 3-2 in Chapter 3.\n\nMappingView\n\nIn Python 3, the objects returned from the mapping methods .items(), .keys(), and .values() implement the interfaces defined in ItemsView, KeysView, and ValuesView, respectively. The first two also implement the rich interface of Set, with all the operators we saw in “Set Operations” on page 107.\n\nIterator\n\nNote that iterator subclasses Iterable. We discuss this further in Chapter 17.\n\n450\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1192,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 481,
      "content": "Callable, Hashable\n\nThese are not collections, but collections.abc was the first package to define ABCs in the standard library, and these two were deemed important enough to be included. They support type checking objects that must be callable or hashable.\n\nFor callable detection, the callable(obj) built-in function is more convenient than insinstance(obj, Callable).\n\nIf insinstance(obj, Hashable) returns False, you can be certain that obj is not hashable. But if the return is True, it may be a false positive. The next box explains.\n\nisinstance with Hashable and Iterable Can Be Misleading It’s easy to misinterpret the results of the isinstance and issubclass tests against the Hashable and Iterable ABCs.\n\nIf isinstance(obj, Hashable) returns True, that only means that the class of obj implements or inherits __hash__. But if obj is a tuple containing unhashable items, then obj is not hashable, despite the positive result of the isinstance check. Tech reviewer Jürgen Gmach pointed out that duck typing provides the most accurate way to determine if an instance is hashable: call hash(obj). That call will raise TypeError if obj is not hashable.\n\nOn the other hand, even when isinstance(obj, Iterable) returns False, Python may still be able to iterate over obj using __getitem__ with 0-based indices, as we saw in Chapter 1 and “Python Digs Sequences” on page 436. The documentation for collections.abc.Iterable states:\n\nThe only reliable way to determine whether an object is iterable is to call iter(obj).\n\nAfter looking at some existing ABCs, let’s practice goose typing by implementing an ABC from scratch and putting it to use. The goal here is not to encourage everyone to start creating ABCs left and right, but to learn how to read the source code of the ABCs you’ll find in the standard library and other packages.\n\nDefining and Using an ABC This warning appeared in the “Interfaces” chapter of the first edition of Fluent Python:\n\nABCs, like descriptors and metaclasses, are tools for building frameworks. Therefore, only a small minority of Python developers can create ABCs without imposing unrea‐ sonable limitations and needless work on fellow programmers.\n\nGoose Typing\n\n|\n\n451",
      "content_length": 2205,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 482,
      "content": "Now ABCs have more potential use cases in type hints to support static typing. As discussed in “Abstract Base Classes” on page 278, using ABCs instead of concrete types in function argument type hints gives more flexibility to the caller.\n\nTo justify creating an ABC, we need to come up with a context for using it as an extension point in a framework. So here is our context: imagine you need to display advertisements on a website or a mobile app in random order, but without repeating an ad before the full inventory of ads is shown. Now let’s assume we are building an ad management framework called ADAM. One of its requirements is to support user- provided nonrepeating random-picking classes.8 To make it clear to ADAM users what is expected of a “nonrepeating random-picking” component, we’ll define an ABC.\n\nIn the literature about data structures, “stack” and “queue” describe abstract inter‐ faces in terms of physical arrangements of objects. I will follow suit and use a real- world metaphor to name our ABC: bingo cages and lottery blowers are machines designed to pick items at random from a finite set, without repeating, until the set is exhausted.\n\nThe ABC will be named Tombola, after the Italian name of bingo and the tumbling container that mixes the numbers.\n\nThe Tombola ABC has four methods. The two abstract methods are:\n\n.load(…)\n\nPut items into the container.\n\n.pick()\n\nRemove one item at random from the container, returning it.\n\nThe concrete methods are:\n\n.loaded()\n\nReturn True if there is at least one item in the container.\n\n.inspect()\n\nReturn a tuple built from the items currently in the container, without changing its contents (the internal ordering is not preserved).\n\nFigure 13-5 shows the Tombola ABC and three concrete implementations.\n\n8 Perhaps the client needs to audit the randomizer; or the agency wants to provide a rigged one. You never\n\nknow…\n\n452\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1943,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 483,
      "content": "Figure 13-5. UML diagram for an ABC and three subclasses. The name of the Tombola ABC and its abstract methods are written in italics, per UML conventions. The dashed arrow is used for interface implementation—here I am using it to show that TomboList not only implements the Tombola interface, but is also registered as virtual subclass of Tombola—as we will see later in this chapter.9\n\nExample 13-7 shows the definition of the Tombola ABC.\n\nExample 13-7. tombola.py: Tombola is an ABC with two abstract methods and two concrete methods\n\nimport abc\n\nclass Tombola(abc.ABC):\n\n@abc.abstractmethod def load(self, iterable): \"\"\"Add items from an iterable.\"\"\"\n\n@abc.abstractmethod def pick(self): \"\"\"Remove item at random, returning it.\n\nThis method should raise `LookupError` when the instance is empty. \"\"\"\n\ndef loaded(self): \"\"\"Return `True` if there's at least 1 item, `False` otherwise.\"\"\"\n\n9 «registered» and «virtual subclass» are not standard UML terms. I am using them to represent a class relation‐\n\nship that is specific to Python.\n\nGoose Typing\n\n|\n\n453",
      "content_length": 1061,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 484,
      "content": "return bool(self.inspect())\n\ndef inspect(self): \"\"\"Return a sorted tuple with the items currently inside.\"\"\" items = [] while True: try: items.append(self.pick()) except LookupError: break self.load(items) return tuple(items)\n\nTo define an ABC, subclass abc.ABC.\n\nAn abstract method is marked with the @abstractmethod decorator, and often its body is empty except for a docstring.10\n\nThe docstring instructs implementers to raise LookupError if there are no items to pick.\n\nAn ABC may include concrete methods.\n\nConcrete methods in an ABC must rely only on the interface defined by the ABC (i.e., other concrete or abstract methods or properties of the ABC).\n\nWe can’t know how concrete subclasses will store the items, but we can build the inspect result by emptying the Tombola with successive calls to .pick()…\n\n…then use .load(…) to put everything back.\n\n10 Before ABCs existed, abstract methods would raise NotImplementedError to signal that subclasses were\n\nresponsible for their implementation. In Smalltalk-80, abstract method bodies would invoke subclassRespon sibility, a method inherited from object that would produce an error with the message, “My subclass should have overridden one of my messages.”\n\n454\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1266,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 485,
      "content": "An abstract method can actually have an implementation. Even if it does, subclasses will still be forced to override it, but they will be able to invoke the abstract method with super(), adding function‐ ality to it instead of implementing from scratch. See the abc mod‐ ule documentation for details on @abstractmethod usage.\n\nThe code for the .inspect() method in Example 13-7 is silly, but it shows that we can rely on .pick() and .load(…) to inspect what’s inside the Tombola by picking all items and loading them back—without knowing how the items are actually stored. The point of this example is to highlight that it’s OK to provide concrete methods in ABCs, as long as they only depend on other methods in the interface. Being aware of their internal data structures, concrete subclasses of Tombola may always over‐ ride .inspect() with a smarter implementation, but they don’t have to.\n\nThe .loaded() method in Example 13-7 has one line, but it’s expensive: it calls .inspect() to build the tuple just to apply bool() on it. This works, but a con‐ crete subclass can do much better, as we’ll see.\n\nNote that our roundabout implementation of .inspect() requires that we catch a LookupError thrown by self.pick(). The fact that self.pick() may raise LookupEr ror is also part of its interface, but there is no way to make this explicit in Python, except in the documentation (see the docstring for the abstract pick method in Example 13-7).\n\nI chose the LookupError exception because of its place in the Python hierarchy of exceptions in relation to IndexError and KeyError, the most likely exceptions to be raised by the data structures used to implement a concrete Tombola. Therefore, implementations can raise LookupError, IndexError, KeyError, or a custom subclass of LookupError to comply. See Figure 13-6.\n\nGoose Typing\n\n|\n\n455",
      "content_length": 1840,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 486,
      "content": "Figure 13-6. Part of the Exception class hierarchy.11\n\nLookupError is the exception we handle in Tombola.inspect.\n\nIndexError is the LookupError subclass raised when we try to get an item from a sequence with an index beyond the last position.\n\nKeyError is raised when we use a nonexistent key to get an item from a mapping.\n\nWe now have our very own Tombola ABC. To witness the interface checking per‐ formed by an ABC, let’s try to fool Tombola with a defective implementation in Example 13-8.\n\nExample 13-8. A fake Tombola doesn’t go undetected\n\n>>> from tombola import Tombola >>> class Fake(Tombola): ... def pick(self): ... return 13 ... >>> Fake <class '__main__.Fake'> >>> f = Fake() Traceback (most recent call last):\n\n11 The complete tree is in section “5.4. Exception hierarchy” of The Python Standard Library docs.\n\n456\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 879,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 487,
      "content": "File \"<stdin>\", line 1, in <module> TypeError: Can't instantiate abstract class Fake with abstract method load\n\nDeclare Fake as a subclass of Tombola.\n\nThe class was created, no errors so far.\n\nTypeError is raised when we try to instantiate Fake. The message is very clear: Fake is considered abstract because it failed to implement load, one of the abstract methods declared in the Tombola ABC.\n\nSo we have our first ABC defined, and we put it to work validating a class. We’ll soon subclass the Tombola ABC, but first we must cover some ABC coding rules.\n\nABC Syntax Details The standard way to declare an ABC is to subclass abc.ABC or any other ABC.\n\nBesides the ABC base class, and the @abstractmethod decorator, the abc module defines the @abstractclassmethod, @abstractstaticmethod, and @abstractprop erty decorators. However, these last three were deprecated in Python 3.3, when it became possible to stack decorators on top of @abstractmethod, making the others redundant. For example, the preferred way to declare an abstract class method is:\n\nclass MyABC(abc.ABC): @classmethod @abc.abstractmethod def an_abstract_classmethod(cls, ...): pass\n\nThe order of stacked function decorators matters, and in the case of @abstractmethod, the documentation is explicit:\n\nWhen abstractmethod() is applied in combination with other method descriptors, it should be applied as the innermost decorator…12\n\nIn other words, no other decorator may appear between @abstract method and the def statement.\n\nNow that we’ve got these ABC syntax issues covered, let’s put Tombola to use by implementing two concrete descendants of it.\n\n12 The @abc.abstractmethod entry in the abc module documentation.\n\nGoose Typing\n\n|\n\n457",
      "content_length": 1710,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 488,
      "content": "Subclassing an ABC Given the Tombola ABC, we’ll now develop two concrete subclasses that satisfy its interface. These classes were pictured in Figure 13-5, along with the virtual subclass to be discussed in the next section.\n\nThe BingoCage class in Example 13-9 is a variation of Example 7-8 using a better ran‐ domizer. This BingoCage implements the required abstract methods load and pick.\n\nExample 13-9. bingo.py: BingoCage is a concrete subclass of Tombola\n\nimport random\n\nfrom tombola import Tombola\n\nclass BingoCage(Tombola):\n\ndef __init__(self, items): self._randomizer = random.SystemRandom() self._items = [] self.load(items)\n\ndef load(self, items): self._items.extend(items) self._randomizer.shuffle(self._items)\n\ndef pick(self): try: return self._items.pop() except IndexError: raise LookupError('pick from empty BingoCage')\n\ndef __call__(self): self.pick()\n\nThis BingoCage class explicitly extends Tombola.\n\nPretend we’ll use this for online gaming. random.SystemRandom implements the random API on top of the os.urandom(…) function, which provides random bytes “suitable for cryptographic use,” according to the os module docs.\n\nDelegate initial loading to the .load(…) method.\n\nInstead of the plain random.shuffle() function, we use the .shuffle() method of our SystemRandom instance.\n\n458\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1351,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 489,
      "content": "pick is implemented as in Example 7-8.\n\n__call__ is also from Example 7-8. It’s not needed to satisfy the Tombola inter‐ face, but there’s no harm in adding extra methods.\n\nBingoCage inherits the expensive loaded and the silly inspect methods from Tom bola. Both could be overridden with much faster one-liners, as in Example 13-10. The point is: we can be lazy and just inherit the suboptimal concrete methods from an ABC. The methods inherited from Tombola are not as fast as they could be for BingoCage, but they do provide correct results for any Tombola subclass that correctly implements pick and load.\n\nExample 13-10 shows a very different but equally valid implementation of the Tom bola interface. Instead of shuffling the “balls” and popping the last, LottoBlower pops from a random position.\n\nExample 13-10. lotto.py: LottoBlower is a concrete subclass that overrides the inspect and loaded methods from Tombola\n\nimport random\n\nfrom tombola import Tombola\n\nclass LottoBlower(Tombola):\n\ndef __init__(self, iterable): self._balls = list(iterable)\n\ndef load(self, iterable): self._balls.extend(iterable)\n\ndef pick(self): try: position = random.randrange(len(self._balls)) except ValueError: raise LookupError('pick from empty LottoBlower') return self._balls.pop(position)\n\ndef loaded(self): return bool(self._balls)\n\ndef inspect(self): return tuple(self._balls)\n\nGoose Typing\n\n|\n\n459",
      "content_length": 1392,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 490,
      "content": "The initializer accepts any iterable: the argument is used to build a list.\n\nThe random.randrange(…) function raises ValueError if the range is empty, so we catch that and throw LookupError instead, to be compatible with Tombola.\n\nOtherwise the randomly selected item is popped from self._balls.\n\nOverride loaded to avoid calling inspect (as Tombola.loaded does in Example 13-7). We can make it faster by working with self._balls directly—no need to build a whole new tuple.\n\nOverride inspect with a one-liner.\n\nExample 13-10 illustrates an idiom worth mentioning: in __init__, self._balls stores list(iterable) and not just a reference to iterable (i.e., we did not merely assign self._balls = iterable, aliasing the argument). As mentioned in “Defen‐ sive Programming and ‘Fail Fast’” on page 440, this makes our LottoBlower flexible because the iterable argument may be any iterable type. At the same time, we make sure to store its items in a list so we can pop items. And even if we always get lists as the iterable argument, list(iterable) produces a copy of the argument, which is a good practice considering we will be removing items from it and the client might not expect that the provided list will be changed.13\n\nWe now come to the crucial dynamic feature of goose typing: declaring virtual sub‐ classes with the register method.\n\nA Virtual Subclass of an ABC An essential characteristic of goose typing—and one reason why it deserves a water‐ fowl name—is the ability to register a class as a virtual subclass of an ABC, even if it does not inherit from it. When doing so, we promise that the class faithfully imple‐ ments the interface defined in the ABC—and Python will believe us without check‐ ing. If we lie, we’ll be caught by the usual runtime exceptions.\n\nThis is done by calling a register class method on the ABC. The registered class then becomes a virtual subclass of the ABC, and will be recognized as such by issub class, but it does not inherit any methods or attributes from the ABC.\n\n13 “Defensive Programming with Mutable Parameters” on page 216 in Chapter 6 was devoted to the aliasing\n\nissue we just avoided here.\n\n460\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 2199,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 491,
      "content": "Virtual subclasses do not inherit from their registered ABCs, and are not checked for conformance to the ABC interface at any time, not even when they are instantiated. Also, static type checkers can’t handle virtual subclasses at this time. For details, see Mypy issue 2922—ABCMeta.register support.\n\nThe register method is usually invoked as a plain function (see “Usage of register in Practice” on page 463), but it can also be used as a decorator. In Example 13-11, we use the decorator syntax and implement TomboList, a virtual subclass of Tombola, depic‐ ted in Figure 13-7.\n\nFigure 13-7. UML class diagram for the TomboList, a real subclass of list and a vir‐ tual subclass of Tombola.\n\nExample 13-11. tombolist.py: class TomboList is a virtual subclass of Tombola\n\nfrom random import randrange\n\nfrom tombola import Tombola\n\n@Tombola.register class TomboList(list):\n\ndef pick(self): if self: position = randrange(len(self)) return self.pop(position)\n\nGoose Typing\n\n|\n\n461",
      "content_length": 978,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 492,
      "content": "else: raise LookupError('pop from empty TomboList')\n\nload = list.extend\n\ndef loaded(self): return bool(self)\n\ndef inspect(self): return tuple(self)\n\n# Tombola.register(TomboList)\n\nTombolist is registered as a virtual subclass of Tombola.\n\nTombolist extends list.\n\nTombolist inherits its boolean behavior from list, and that returns True if the list is not empty.\n\nOur pick calls self.pop, inherited from list, passing a random item index.\n\nTombolist.load is the same as list.extend.\n\nloaded delegates to bool.14\n\nIt’s always possible to call register in this way, and it’s useful to do so when you need to register a class that you do not maintain, but which does fulfill the interface.\n\nNote that because of the registration, the functions issubclass and isinstance act as if TomboList is a subclass of Tombola:\n\n>>> from tombola import Tombola >>> from tombolist import TomboList >>> issubclass(TomboList, Tombola) True >>> t = TomboList(range(100)) >>> isinstance(t, Tombola) True\n\n14 The same trick I used with load() doesn’t work with loaded(), because the list type does not implement\n\n__bool__, the method I’d have to bind to loaded. The bool() built-in doesn’t need __bool__ to work because it can also use __len__. See “4.1. Truth Value Testing” in the “Built-in Types” chapter of the Python documentation.\n\n462\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1368,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 493,
      "content": "However, inheritance is guided by a special class attribute named __mro__—the Method Resolution Order. It basically lists the class and its superclasses in the order Python uses to search for methods.15 If you inspect the __mro__ of TomboList, you’ll see that it lists only the “real” superclasses—list and object:\n\n>>> TomboList.__mro__ (<class 'tombolist.TomboList'>, <class 'list'>, <class 'object'>)\n\nTombola is not in Tombolist.__mro__, so Tombolist does not inherit any methods from Tombola.\n\nThis concludes our Tombola ABC case study. In the next section, we’ll address how the register ABC function is used in the wild.\n\nUsage of register in Practice In Example 13-11, we used Tombola.register as a class decorator. Prior to Python 3.3, register could not be used like that—it had to be called as a plain function after the class definition, as suggested by the comment at the end of Example 13-11. How‐ ever, even now, it’s more widely deployed as a function to register classes defined elsewhere. For example, in the source code for the collections.abc module, the built-in types tuple, str, range, and memoryview are registered as virtual subclasses of Sequence, like this:\n\nSequence.register(tuple) Sequence.register(str) Sequence.register(range) Sequence.register(memoryview)\n\nSeveral other built-in types are registered to ABCs in _collections_abc.py. Those regis‐ trations happen only when that module is imported, which is OK because you’ll have to import it anyway to get the ABCs. For example, you need to import MutableMap ping from collections.abc to perform a check like isinstance(my_dict, Mutable Mapping).\n\nSubclassing an ABC or registering with an ABC are both explicit ways of making our classes pass issubclass checks—as well as isinstance checks, which also rely on issubclass. But some ABCs support structural typing as well. The next section explains.\n\n15 There is a whole section explaining the __mro__ class attribute in “Multiple Inheritance and Method Resolu‐\n\ntion Order” on page 494. Right now, this quick explanation will do.\n\nGoose Typing\n\n|\n\n463",
      "content_length": 2084,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 494,
      "content": "Structural Typing with ABCs ABCs are mostly used with nominal typing. When a class Sub explicitly inherits from AnABC, or is registered with AnABC, the name of AnABC is linked to the Sub class—and that’s how at runtime, issubclass(AnABC, Sub) returns True.\n\nIn contrast, structural typing is about looking at the structure of an object’s public interface to determine its type: an object is consistent-with a type if it implements the methods defined in the type.16 Dynamic and static duck typing are two approaches to structural typing.\n\nIt turns out that some ABCs also support structural typing. In his essay, “Waterfowl and ABCs” on page 443, Alex shows that a class can be recognized as a subclass of an ABC even without registration. Here is his example again, with an added test using issubclass:\n\n>>> class Struggle: ... def __len__(self): return 23 ... >>> from collections import abc >>> isinstance(Struggle(), abc.Sized) True >>> issubclass(Struggle, abc.Sized) True\n\nClass Struggle is considered a subclass of abc.Sized by the issubclass function (and, consequently, by isinstance as well) because abc.Sized implements a special class method named __subclasshook__.\n\nThe __subclasshook__ for Sized checks whether the class argument has an attribute named __len__. If it does, then it is considered a virtual subclass of Sized. See Example 13-12.\n\nExample 13-12. Definition of Sized from the source code of Lib/_collections_abc.py\n\nclass Sized(metaclass=ABCMeta):\n\n__slots__ = ()\n\n@abstractmethod def __len__(self): return 0\n\n@classmethod def __subclasshook__(cls, C):\n\n16 The concept of type consistency was explained in “Subtype-of versus consistent-with” on page 267.\n\n464\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1734,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 495,
      "content": "if cls is Sized: if any(\"__len__\" in B.__dict__ for B in C.__mro__): return True return NotImplemented\n\nIf there is an attribute named __len__ in the __dict__ of any class listed in C.__mro__ (i.e., C and its superclasses)…\n\n…return True, signaling that C is a virtual subclass of Sized.\n\nOtherwise return NotImplemented to let the subclass check proceed.\n\nIf you are interested in the details of the subclass check, see the source code for the ABCMeta.__subclasscheck__ method in Python 3.6: Lib/abc.py. Beware: it has lots of ifs and two recursive calls. In Python 3.7, Ivan Levkivskyi and Inada Naoki rewrote in C most of the logic for the abc module, for better performance. See Python issue #31333. The current implementation of ABC Meta.__subclasscheck__ simply calls _abc_subclasscheck. The relevant C source code is in cpython/Modules/_abc.c#L605.\n\nThat’s how __subclasshook__ allows ABCs to support structural typing. You can formalize an interface with an ABC, you can make isinstance checks against that ABC, and still have a completely unrelated class pass an issubclass check because it implements a certain method (or because it does whatever it takes to convince a __subclasshook__ to vouch for it).\n\nIs it a good idea to implement __subclasshook__ in our own ABCs? Probably not. All the implementations of __subclasshook__ I’ve seen in the Python source code are in ABCs like Sized that declare just one special method, and they simply check for that special method name. Given their “special” status, you can be pretty sure that any method named __len__ does what you expect. But even in the realm of special methods and fundamental ABCs, it can be risky to make such assumptions. For example, mappings implement __len__, __getitem__, and __iter__, but they are rightly not considered subtypes of Sequence, because you can’t retrieve items using integer offsets or slices. That’s why the abc.Sequence class does not implement __subclasshook__.\n\nFor ABCs that you and I may write, a __subclasshook__ would be even less depend‐ able. I am not ready to believe that any class named Spam that implements or inherits load, pick, inspect, and loaded is guaranteed to behave as a Tombola. It’s better to let the programmer affirm it by subclassing Spam from Tombola, or registering it with\n\nGoose Typing\n\n|\n\n465",
      "content_length": 2321,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 496,
      "content": "Tombola.register(Spam). Of course, your __subclasshook__ could also check method signatures and other features, but I just don’t think it’s worthwhile.\n\nStatic Protocols\n\nStatic protocols were introduced in “Static Protocols” on page 286 (Chapter 8). I considered delaying all coverage of protocols until this chapter, but decided that the initial presentation of type hints in functions had to include protocols because duck typing is an essential part of Python, and static type checking without protocols doesn’t handle Pythonic APIs very well.\n\nWe will wrap up this chapter by illustrating static protocols with two simple exam‐ ples, and a discussion of numeric ABCs and protocols. Let’s start by showing how a static protocol makes it possible to annotate and type check the double() function we first saw in “Types Are Defined by Supported Operations” on page 260.\n\nThe Typed double Function When introducing Python to programmers more used to statically typed languages, one of my favorite examples is this simple double function:\n\n>>> def double(x): ... return x * 2 ... >>> double(1.5) 3.0 >>> double('A') 'AA' >>> double([10, 20, 30]) [10, 20, 30, 10, 20, 30] >>> from fractions import Fraction >>> double(Fraction(2, 5)) Fraction(4, 5)\n\nBefore static protocols were introduced, there was no practical way to add type hints to double without limiting its possible uses.17\n\n17 OK, double() is not very useful, except as an example. But the Python standard library has many functions\n\nthat could not be properly annotated before static protocols were added in Python 3.8. I helped fix a couple of bugs in typeshed by adding type hints using protocols. For example, the pull request that fixed “Should Mypy warn about potential invalid arguments to max?” leveraged a _SupportsLessThan protocol, which I used to enhance the annotations for max, min, sorted, and list.sort.\n\n466\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1932,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 497,
      "content": "Thanks to duck typing, double works even with types from the future, such as the enhanced Vector class that we’ll see in “Overloading * for Scalar Multiplication” on page 572 (Chapter 16):\n\n>>> from vector_v7 import Vector >>> double(Vector([11.0, 12.0, 13.0])) Vector([22.0, 24.0, 26.0])\n\nThe initial implementation of type hints in Python was a nominal type system: the name of a type in an annotation had to match the name of the type of the actual argu‐ ments—or the name of one of its superclasses. Since it’s impossible to name all types that implement a protocol by supporting the required operations, duck typing could not be described by type hints before Python 3.8.\n\nNow, with typing.Protocol we can tell Mypy that double takes an argument x that supports x * 2. Example 13-13 shows how.\n\nExample 13-13. double_protocol.py: definition of double using a Protocol\n\nfrom typing import TypeVar, Protocol\n\nT = TypeVar('T')\n\nclass Repeatable(Protocol): def __mul__(self: T, repeat_count: int) -> T: ...\n\nRT = TypeVar('RT', bound=Repeatable)\n\ndef double(x: RT) -> RT: return x * 2\n\nWe’ll use this T in the __mul__ signature.\n\n__mul__ is the essence of the Repeatable protocol. The self parameter is usually not annotated—its type is assumed to be the class. Here we use T to make sure the result type is the same as the type of self. Also, note that repeat_count is limited to int in this protocol.\n\nThe RT type variable is bounded by the Repeatable protocol: the type checker will require that the actual type implements Repeatable.\n\nNow the type checker is able to verify that the x parameter is an object that can be multiplied by an integer, and the return value has the same type as x.\n\nStatic Protocols\n\n|\n\n467",
      "content_length": 1720,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 498,
      "content": "This example shows why PEP 544 is titled “Protocols: Structural subtyping (static duck typing).” The nominal type of the actual argument x given to double is irrele‐ vant as long as it quacks—that is, as long as it implements __mul__.\n\nRuntime Checkable Static Protocols In the Typing Map (Figure 13-1), typing.Protocol appears in the static checking area—the bottom half of the diagram. However, when defining a typing.Protocol subclass, you can use the @runtime_checkable decorator to make that protocol sup‐ port isinstance/issubclass checks at runtime. This works because typing.Proto col is an ABC, therefore it supports the __subclasshook__ we saw in “Structural Typing with ABCs” on page 464.\n\nAs of Python 3.9, the typing module includes seven ready-to-use protocols that are runtime checkable. Here are two of them, quoted directly from the typing documen‐ tation:\n\nclass typing.SupportsComplex\n\nAn ABC with one abstract method, __complex__.\n\nclass typing.SupportsFloat\n\nAn ABC with one abstract method, __float__.\n\nThese protocols are designed to check numeric types for “convertibility”: if an object o implements __complex__, then you should be able to get a complex by invoking complex(o)—because the __complex__ special method exists to support the complex() built-in function.\n\nExample 13-14 shows the source code for the typing.SupportsComplex protocol.\n\nExample 13-14. typing.SupportsComplex protocol source code\n\n@runtime_checkable class SupportsComplex(Protocol): \"\"\"An ABC with one abstract method __complex__.\"\"\" __slots__ = ()\n\n@abstractmethod def __complex__(self) -> complex: pass\n\n468\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1657,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 499,
      "content": "The key is the __complex__ abstract method.18 During static type checking, an object will be considered consistent-with the SupportsComplex protocol if it implements a __complex__ method that takes only self and returns a complex.\n\nThanks to the @runtime_checkable class decorator applied to SupportsComplex, that protocol can also be used with isinstance checks in Example 13-15.\n\nExample 13-15. Using SupportsComplex at runtime\n\n>>> from typing import SupportsComplex >>> import numpy as np >>> c64 = np.complex64(3+4j) >>> isinstance(c64, complex) False >>> isinstance(c64, SupportsComplex) True >>> c = complex(c64) >>> c (3+4j) >>> isinstance(c, SupportsComplex) False >>> complex(c) (3+4j)\n\ncomplex64 is one of five complex number types provided by NumPy.\n\nNone of the NumPy complex types subclass the built-in complex.\n\nBut NumPy’s complex types implement __complex__, so they comply with the SupportsComplex protocol.\n\nTherefore, you can create built-in complex objects from them.\n\nSadly, the complex built-in type does not implement __complex__, although complex(c) works fine if c is a complex.\n\nAs a result of that last point, if you want to test whether an object c is a complex or SupportsComplex, you can provide a tuple of types as the second argument to isinstance, like this:\n\nisinstance(c, (complex, SupportsComplex))\n\n18 The __slots__ attribute is irrelevant to the current discussion—it’s an optimization we covered in “Saving\n\nMemory with __slots__” on page 384.\n\nStatic Protocols\n\n|\n\n469",
      "content_length": 1509,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 500,
      "content": "An alternative would be to use the Complex ABC, defined in the numbers module. The built-in complex type and the NumPy complex64 and complex128 types are all registered as virtual subclasses of numbers.Complex, therefore this works:\n\n>>> import numbers >>> isinstance(c, numbers.Complex) True >>> isinstance(c64, numbers.Complex) True\n\nI recommended using the numbers ABCs in the first edition of Fluent Python, but now that’s no longer good advice, because those ABCs are not recognized by the static type checkers, as we’ll see in “The numbers ABCs and Numeric Protocols” on page 478.\n\nIn this section I wanted to demonstrate that a runtime checkable protocol works with isinstance, but it turns out this is example not a particularly good use case of isin stance, as the sidebar “Duck Typing Is Your Friend” on page 470 explains.\n\nIf you’re using an external type checker, there is one advantage of explict isinstance checks: when you write an if statement where the condition is isinstance(o, MyType), then Mypy can infer that inside the if block, the type of the o object is consistent-with MyType.\n\nDuck Typing Is Your Friend Very often at runtime, duck typing is the best approach for type checking: instead of calling isinstance or hasattr, just try the operations you need to do on the object, and handle exceptions as needed. Here is a concrete example.\n\nContinuing the previous discussion—given an object o that I need to use as a com‐ plex number, this would be one approach:\n\nif isinstance(o, (complex, SupportsComplex)): # do something that requires `o` to be convertible to complex else: raise TypeError('o must be convertible to complex')\n\nThe goose typing approach would be to use the numbers.Complex ABC:\n\nif isinstance(o, numbers.Complex): # do something with `o`, an instance of `Complex` else: raise TypeError('o must be an instance of Complex')\n\nHowever, I prefer to leverage duck typing and do this using the EAFP principle—it’s easier to ask for forgiveness than permission:\n\n470\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 2051,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 501,
      "content": "try: c = complex(o) except TypeError as exc: raise TypeError('o must be convertible to complex') from exc\n\nAnd, if all you’re going to do is raise a TypeError anyway, then I’d omit the try/ except/raise statements and just write this:\n\nc = complex(o)\n\nIn this last case, if o is not an acceptable type, Python will raise an exception with a very clear message. For example, this is what I get if o is a tuple:\n\nTypeError: complex() first argument must be a string or a number, not 'tuple'\n\nI find the duck typing approach much better in this case.\n\nNow that we’ve seen how to use static protocols at runtime with preexisting types like complex and numpy.complex64, we need to discuss the limitations of runtime checka‐ ble protocols.\n\nLimitations of Runtime Protocol Checks We’ve seen that type hints are generally ignored at runtime, and this also affects the use of isinstance or issubclass checks against static protocols.\n\nFor example, any class with a __float__ method is considered—at runtime—a vir‐ tual subclass of SupportsFloat, even if the __float__ method does not return a float.\n\nCheck out this console session:\n\n>>> import sys >>> sys.version '3.9.5 (v3.9.5:0a7dcbdb13, May 3 2021, 13:17:02) \\n[Clang 6.0 (clang-600.0.57)]' >>> c = 3+4j >>> c.__float__ <method-wrapper '__float__' of complex object at 0x10a16c590> >>> c.__float__() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't convert complex to float\n\nIn Python 3.9, the complex type does have a __float__ method, but it exists only to raise a TypeError with an explicit error message. If that __float__ method had annotations, the return type would be NoReturn—which we saw in “NoReturn” on page 294.\n\nStatic Protocols\n\n|\n\n471",
      "content_length": 1736,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 502,
      "content": "But type hinting complex.__float__ on typeshed would not solve this problem because Python’s runtime generally ignores type hints—and can’t access the typeshed stub files anyway.\n\nContinuing from the previous Python 3.9 session:\n\n>>> from typing import SupportsFloat >>> c = 3+4j >>> isinstance(c, SupportsFloat) True >>> issubclass(complex, SupportsFloat) True\n\nSo we have misleading results: the runtime checks against SupportsFloat suggest that you can convert a complex to float, but in fact that raises a type error.\n\nThe specific isssue with the complex type is fixed in Python 3.10.0b4 with the removal of the complex.__float__ method. But the overall issue remains: isinstance/issubclass checks only look at the presence or absence of methods, without checking their signatures, much less their type annotations. And this is not about to change, because such type checks at runtime would have an unacceptable performance cost.19\n\nNow let’s see how to implement a static protocol in a user-defined class.\n\nSupporting a Static Protocol Recall the Vector2d class we built in Chapter 11. Given that a complex number and a Vector2d instance both consist of a pair of floats, it makes sense to support conver‐ sion from Vector2d to complex.\n\nExample 13-16 shows the implementation of the __complex__ method to enhance the last version of Vector2d we saw in Example 11-11. For completeness, we can sup‐ port the inverse operation with a fromcomplex class method to build a Vector2d from a complex.\n\n19 Thanks to Ivan Levkivskyi, coauthor of PEP 544 (on Protocols), for pointing out that type checking is not just a matter of checking whether the type of x is T: it’s about determining that the type of x is consistent-with T, which may be expensive. It’s no wonder that Mypy takes a few seconds to type check even short Python scripts.\n\n472\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1889,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 503,
      "content": "Example 13-16. vector2d_v4.py: methods for converting to and from complex\n\ndef __complex__(self): return complex(self.x, self.y)\n\n@classmethod def fromcomplex(cls, datum): return cls(datum.real, datum.imag)\n\nThis assumes that datum has .real and .imag attributes. We’ll see a better imple‐ mentation in Example 13-17.\n\nGiven the preceding code, and the __abs__ method the Vector2d already had in Example 11-11, we get these features:\n\n>>> from typing import SupportsComplex, SupportsAbs >>> from vector2d_v4 import Vector2d >>> v = Vector2d(3, 4) >>> isinstance(v, SupportsComplex) True >>> isinstance(v, SupportsAbs) True >>> complex(v) (3+4j) >>> abs(v) 5.0 >>> Vector2d.fromcomplex(3+4j) Vector2d(3.0, 4.0)\n\nFor runtime type checking, Example 13-16 is fine, but for better static coverage and error reporting with Mypy, the __abs__, __complex__, and fromcomplex methods should get type hints, as shown in Example 13-17.\n\nExample 13-17. vector2d_v5.py: adding annotations to the methods under study\n\ndef __abs__(self) -> float: return math.hypot(self.x, self.y)\n\ndef __complex__(self) -> complex: return complex(self.x, self.y)\n\n@classmethod def fromcomplex(cls, datum: SupportsComplex) -> Vector2d: c = complex(datum) return cls(c.real, c.imag)\n\nStatic Protocols\n\n|\n\n473",
      "content_length": 1273,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 504,
      "content": "The float return annotation is needed, otherwise Mypy infers Any, and doesn’t check the body of the method.\n\nEven without the annotation, Mypy was able to infer that this returns a complex. The annotation prevents a warning, depending on your Mypy configuration.\n\nHere SupportsComplex ensures the datum is convertible.\n\nThis explicit conversion is necessary, because the SupportsComplex type does not declare .real and .imag attributes, used in the next line. For example, Vector2d doesn’t have those attributes, but implements __complex__.\n\nThe return type of fromcomplex can be Vector2d if from __future__ import anno tations appears at the top of the module. That import causes type hints to be stored as strings, without being evaluated at import time, when function definitions are evaluated. Without the __future__ import of annotations, Vector2d is an invalid reference at this point (the class is not fully defined yet) and should be written as a string: 'Vector2d', as if it were a forward reference. This __future__ import was introduced in PEP 563—Postponed Evaluation of Annotations, implemented in Python 3.7. That behavior was scheduled to become default in 3.10, but the change was delayed to a later version.20 When that happens, the import will be redundant, but harmless.\n\nNext, let’s see how to create—and later, extend—a new static protocol.\n\nDesigning a Static Protocol While studying goose typing, we saw the Tombola ABC in “Defining and Using an ABC” on page 451. Here we’ll see how to define a similar interface using a static protocol.\n\nThe Tombola ABC specifies two methods: pick and load. We could define a static protocol with these two methods as well, but I learned from the Go community that single-method protocols make static duck typing more useful and flexible. The Go standard library has several interfaces like Reader, an interface for I/O that requires just a read method. After a while, if you realize a more complete protocol is required, you can combine two or more protocols to define a new one.\n\nUsing a container that picks items at random may or may not require reloading the container, but it certainly needs a method to do the actual pick, so that’s the method I\n\n20 Read the Python Steering Council decision on python-dev.\n\n474\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 2324,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 505,
      "content": "will choose for the minimal RandomPicker protocol. The code for that protocol is in Example 13-18, and its use is demonstrated by tests in Example 13-19.\n\nExample 13-18. randompick.py: definition of RandomPicker\n\nfrom typing import Protocol, runtime_checkable, Any\n\n@runtime_checkable class RandomPicker(Protocol): def pick(self) -> Any: ...\n\nThe pick method returns Any. In “Implementing a Generic Static Protocol” on page 552, we will see how to make RandomPicker a generic type with a parameter to let users of the protocol specify the return type of the pick method.\n\nExample 13-19. randompick_test.py: RandomPicker in use\n\nimport random from typing import Any, Iterable, TYPE_CHECKING\n\nfrom randompick import RandomPicker\n\nclass SimplePicker: def __init__(self, items: Iterable) -> None: self._items = list(items) random.shuffle(self._items)\n\ndef pick(self) -> Any: return self._items.pop()\n\ndef test_isinstance() -> None: popper: RandomPicker = SimplePicker([1]) assert isinstance(popper, RandomPicker)\n\ndef test_item_type() -> None: items = [1, 2] popper = SimplePicker(items) item = popper.pick() assert item in items if TYPE_CHECKING: reveal_type(item) assert isinstance(item, int)\n\nStatic Protocols\n\n|\n\n475",
      "content_length": 1216,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 506,
      "content": "It’s not necessary to import the static protocol to define a class that implements it. Here I imported RandomPicker only to use it on test_isinstance later.\n\nSimplePicker implements RandomPicker—but it does not subclass it. This is static duck typing in action.\n\nAny is the default return type, so this annotation is not strictly necessary, but it does make it more clear that we are implementing the RandomPicker protocol as defined in Example 13-18.\n\nDon’t forget to add -> None hints to your tests if you want Mypy to look at them.\n\nI added a type hint for the popper variable to show that Mypy understands that SimplePicker is consistent-with.\n\nThis test proves that an instance of SimplePicker is also an instance of Random Picker. This works because of the @runtime_checkable decorator applied to RandomPicker, and because SimplePicker has a pick method as required.\n\nThis test invokes the pick method from a SimplePicker, verifies that it returns one of the items given to SimplePicker, and then does static and runtime checks on the returned item.\n\nThis line generates a note in the Mypy output.\n\nAs we saw in Example 8-22, reveal_type is a “magic” function recognized by Mypy. That’s why it is not imported and we can only call it inside if blocks protected by typing.TYPE_CHECKING, which is only True in the eyes of a static type checker, but is False at runtime.\n\nBoth tests in Example 13-19 pass. Mypy does not see any errors in that code either, and shows the result of the reveal_type on the item returned by pick:\n\n$ mypy randompick_test.py randompick_test.py:24: note: Revealed type is 'Any'\n\nHaving created our first protocol, let’s study some advice on the matter.\n\nBest Practices for Protocol Design After 10 years of experience with static duck typing in Go, it is clear that narrow pro‐ tocols are more useful—often such protocols have a single method, rarely more than a couple of methods. Martin Fowler wrote a post defining role interface, a useful idea to keep in mind when designing protocols.\n\n476\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 2072,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 507,
      "content": "Also, sometimes you see a protocol defined near the function that uses it—that is, defined in “client code” instead of being defined in a library. This is makes it easy to create new types to call that function, which is good for extensibility and testing with mocks.\n\nThe practices of narrow protocols and client-code protocols both avoid unnecessary tight coupling, in line with the Interface Segregation Principle, which we can summa‐ rize as “Clients should not be forced to depend upon interfaces that they do not use.”\n\nThe page “Contributing to typeshed” recommends this naming convention for static protocols (the following three points are quoted verbatim):\n\nUse plain names for protocols that represent a clear concept (e.g., Iterator, Container).\n\nUse SupportsX for protocols that provide callable methods (e.g., SupportsInt, SupportsRead, SupportsReadSeek).21\n\nUse HasX for protocols that have readable and/or writable attributes or getter/ setter methods (e.g., HasItems, HasFileno).\n\nThe Go standard library has a naming convention that I like: for single method pro‐ tocols, if the method name is a verb, append “-er” or “-or” to make it a noun. For example, instead of SupportsRead, have Reader. More examples include Formatter, Animator, and Scanner. For inspiration, see “Go (Golang) Standard Library Inter‐ faces (Selected)” by Asuka Kenji.\n\nOne good reason to create minimalistic protocols is the ability to extend them later, if needed. We’ll now see that it’s not hard to create a derived protocol with an addi‐ tional method.\n\nExtending a Protocol As I mentioned at the start of the previous section, Go developers advocate to err on the side of minimalism when defining interfaces—their name for static protocols. Many of the most widely used Go interfaces have a single method.\n\nWhen practice reveals that a protocol with more methods is useful, instead of adding methods to the original protocol, it’s better to derive a new protocol from it. Extend‐ ing a static protocol in Python has a few caveats, as Example 13-20 shows.\n\n21 Every method is callable, so this guideline doesn’t say much. Perhaps “provide one or two methods”? Any‐\n\nway, it’s a guideline, not a strict rule.\n\nStatic Protocols\n\n|\n\n477",
      "content_length": 2229,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 508,
      "content": "Example 13-20. randompickload.py: extending RandomPicker\n\nfrom typing import Protocol, runtime_checkable from randompick import RandomPicker\n\n@runtime_checkable class LoadableRandomPicker(RandomPicker, Protocol): def load(self, Iterable) -> None: ...\n\nIf you want the derived protocol to be runtime checkable, you must apply the decorator again—its behavior is not inherited.22\n\nEvery protocol must explicitly name typing.Protocol as one of its base classes in addition to the protocol we are extending. This is different from the way inheritance works in Python.23\n\nBack to “regular” object-oriented programming: we only need to declare the method that is new in this derived protocol. The pick method declaration is inherited from RandomPicker.\n\nThis concludes the final example of defining and using a static protocol in this chapter.\n\nTo wrap the chapter, we’ll go over numeric ABCs and their possible replacement with numeric protocols.\n\nThe numbers ABCs and Numeric Protocols As we saw in “The fall of the numeric tower” on page 279, the ABCs in the numbers package of the standard library work fine for runtime type checking.\n\nIf you need to check for an integer, you can use isinstance(x, numbers.Integral) to accept int, bool (which subclasses int) or other integer types that are provided by external libraries that register their types as virtual subclasses of the numbers ABCs. For example, NumPy has 21 integer types—as well as several variations of floating- point types registered as numbers.Real, and complex numbers with various bit widths registered as numbers.Complex.\n\n22 For details and rationale, please see the section about @runtime_checkable in PEP 544—Protocols: Structural\n\nsubtyping (static duck typing).\n\n23 Again, please read “Merging and extending protocols” in PEP 544 for details and rationale.\n\n478\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 1880,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 509,
      "content": "Somewhat surprisingly, decimal.Decimal is not registered as a vir‐ tual subclass of numbers.Real. The reason is that, if you need the precision of Decimal in your program, then you want to be pro‐ tected from accidental mixing of decimals with floating-point numbers that are less precise.\n\nSadly, the numeric tower was not designed for static type checking. The root ABC— numbers.Number—has no methods, so if you declare x: Number, Mypy will not let you do arithmetic or call any methods on x.\n\nIf the numbers ABCs are not supported, what are the options?\n\nA good place to look for typing solutions is the typeshed project. As part of the Python standard library, the statistics module has a corresponding statistics.pyi stub file with type hints for on typeshed. There you’ll find the following definitions, which are used to annotate several functions:\n\n_Number = Union[float, Decimal, Fraction] _NumberT = TypeVar('_NumberT', float, Decimal, Fraction)\n\nThat approach is correct, but limited. It does not support numeric types outside of the standard library, which the numbers ABCs do support at runtime—when the numeric types are registered as virtual subclasses.\n\nThe current trend is to recommend the numeric protocols provided by the typing module, which we discussed in “Runtime Checkable Static Protocols” on page 468.\n\nUnfortunately, at runtime, the numeric protocols may let you down. As mentioned in “Limitations of Runtime Protocol Checks” on page 471, the complex type in Python 3.9 implements __float__, but the method exists only to raise TypeError with an explicit message: “can’t convert complex to float.” It implements __int__ as well, for the same reason. The presence of those methods makes isinstance return mislead‐ ing results in Python 3.9. In Python 3.10, the methods of complex that uncondition‐ ally raised TypeError were removed.24\n\nOn the other hand, NumPy’s complex types implement __float__ and __int__ methods that work, only issuing a warning when each of them is used for the first time:\n\n>>> import numpy as np >>> cd = np.cdouble(3+4j) >>> cd (3+4j) >>> float(cd)\n\n24 See Issue #41974—Remove complex.__float__, complex.__floordiv__, etc.\n\nStatic Protocols\n\n|\n\n479",
      "content_length": 2202,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 510,
      "content": "<stdin>:1: ComplexWarning: Casting complex values to real discards the imaginary part 3.0\n\nThe opposite problem also happens: built-ins complex, float, and int, and also numpy.float16 and numpy.uint8, don’t have a __complex__ method, so isin stance(x, SupportsComplex) returns False for them.25 The NumPy complex types, such as np.complex64, do implement __complex__ to convert to a built-in complex.\n\nHowever, in practice, the complex() built-in constructor handles instances of all these types with no errors or warnings:\n\n>>> import numpy as np >>> from typing import SupportsComplex >>> sample = [1+0j, np.complex64(1+0j), 1.0, np.float16(1.0), 1, np.uint8(1)] >>> [isinstance(x, SupportsComplex) for x in sample] [False, True, False, False, False, False] >>> [complex(x) for x in sample] [(1+0j), (1+0j), (1+0j), (1+0j), (1+0j), (1+0j)]\n\nThis shows that isinstance checks against SupportsComplex suggest that those con‐ versions to complex would fail, but they all succeed. In the typing-sig mailing list, Guido van Rossum pointed out that the built-in complex accepts a single argument, and that’s why those conversions work.\n\nOn the other hand, Mypy accepts arguments of all those six types in a call to a to_complex() function defined like this:\n\ndef to_complex(n: SupportsComplex) -> complex: return complex(n)\n\nAs I write this, NumPy has no type hints, so its number types are all Any.26 On the other hand, Mypy is somehow “aware” that the built-in int and float can be con‐ verted to complex, even though on typeshed only the built-in complex class has a __complex__ method.27\n\nIn conclusion, although numeric types should not be hard to type check, the current situation is this: the type hints PEP 484 eschews the numeric tower and implicitly recommends that type checkers hardcode the subtype relationships among built-in complex, float, and int. Mypy does that, and it also pragmatically accepts that int and float are consistent-with SupportsComplex, even though they don’t implement __complex__.\n\n25 I did not test all the other float and integer variants NumPy offers.\n\n26 The NumPy number types are all registered against the appropriate numbers ABCs, which Mypy ignores.\n\n27 That’s a well-meaning lie on the part of typeshed: as of Python 3.9, the built-in complex type does not actually\n\nhave a __complex__ method.\n\n480\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 2388,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 511,
      "content": "I only found unexpected results when using isinstance checks with numeric Supports* protocols while experimenting with con‐ versions to or from complex. If you don’t use complex numbers, you can rely on those protocols instead of the numbers ABCs.\n\nThe main takeaways for this section are:\n\nThe numbers ABCs are fine for runtime type checking, but unsuitable for static typing.\n\nThe numeric static protocols SupportsComplex, SupportsFloat, etc. work well for static typing, but are unreliable for runtime type checking when complex numbers are involved.\n\nWe are now ready for a quick review of what we saw in this chapter.\n\nChapter Summary The Typing Map (Figure 13-1) is the key to making sense of this chapter. After a brief introduction to the four approaches to typing, we contrasted dynamic and static pro‐ tocols, which respectively support duck typing and static duck typing. Both kinds of protocols share the essential characteristic that a class is never required to explicitly declare support for any specific protocol. A class supports a protocol simply by implementing the necessary methods.\n\nThe next major section was “Programming Ducks” on page 435, where we explored the lengths to which the Python interpreter goes to make the sequence and iterable dynamic protocols work, including partial implementations of both. We then saw how a class can be made to implement a protocol at runtime through the addition of extra methods via monkey patching. The duck typing section ended with hints for defensive programming, including detection of structural types without explicit isin stance or hasattr checks using try/except and failing fast.\n\nAfter Alex Martelli introduced goose typing in “Waterfowl and ABCs” on page 443, we saw how to subclass existing ABCs, surveyed important ABCs in the standard library, and created an ABC from scratch, which we then implemented by traditional subclassing and by registration. To close this section, we saw how the __subclass hook__ special method enables ABCs to support structural typing by recognizing unrelated classes that provide methods fulfilling the interface defined in the ABC.\n\nThe last major section was “Static Protocols” on page 466, where we resumed cover‐ age of static duck typing, which started in Chapter 8, in “Static Protocols” on page 286. We saw how the @runtime_checkable decorator also leverages __subclass hook__ to support structural typing at runtime—even though the best use of static\n\nChapter Summary\n\n|\n\n481",
      "content_length": 2491,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 512,
      "content": "protocols is with static type checkers, which can take into account type hints to make structural typing more reliable. Next we talked about the design and coding of a static protocol and how to extend it. The chapter ended with “The numbers ABCs and Numeric Protocols” on page 478, which tells the sad story of the derelict state of the numeric tower and a few existing shortcomings of the proposed alternative: the numeric static protocols such as SupportsFloat and others added to the typing module in Python 3.8.\n\nThe main message of this chapter is that we have four complementary ways of pro‐ gramming with interfaces in modern Python, each with different advantages and drawbacks. You are likely to find suitable use cases for each typing scheme in any modern Python codebase of significant size. Rejecting any one of these approaches will make your work as a Python programmer harder than it needs to be.\n\nHaving said that, Python achieved widespread popularity while supporting only duck typing. Other popular languages such as JavaScript, PHP, and Ruby, as well as Lisp, Smalltalk, Erlang, and Clojure—not popular but very influential—are all languages that had and still have tremendous impact by leveraging the power and simplicity of duck typing.\n\nFurther Reading For a quick look at typing pros and cons, as well as the importance of typing.Proto col for the health of statically checked codebases, I highly recommend Glyph Lefko‐ witz’s post “I Want A New Duck: typing.Protocol and the future of duck typing”. I also learned a lot from his post “Interfaces and Protocols”, comparing typing.Proto col and zope.interface—an earlier mechanism for defining interfaces in loosely coupled plug-in systems, used by the Plone CMS, the Pyramid web framework, and the Twisted asynchronous programming framework, a project founded by Glyph.28\n\nGreat books about Python have—almost by definition—great coverage of duck typ‐ ing. Two of my favorite Python books had updates released after the first edition of Fluent Python: The Quick Python Book, 3rd ed., (Manning), by Naomi Ceder; and Python in a Nutshell, 3rd ed., by Alex Martelli, Anna Ravenscroft, and Steve Holden (O’Reilly).\n\nFor a discussion of the pros and cons of dynamic typing, see Guido van Rossum’s interview with Bill Venners in “Contracts in Python: A Conversation with Guido van Rossum, Part IV”. An insightful and balanced take on this debate is Martin Fowler’s post “Dynamic Typing”. He also wrote “Role Interface”, which I mentioned in “Best Practices for Protocol Design” on page 476. Although it is not about duck typing, that\n\n28 Thanks to tech reviewer Jürgen Gmach for recommending the “Interfaces and Protocols” post.\n\n482\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 2750,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 513,
      "content": "post is highly relevant for Python protocol design, as he contrasts narrow role inter‐ faces with the broader public interfaces of classes in general.\n\nThe Mypy documentation is often the best source of information for anything related to static typing in Python, including static duck typing, addressed in their “Protocols and structural subtyping” chapter.\n\nThe remaining references are all about goose typing. Beazley and Jones’s Python Cookbook, 3rd ed. (O’Reilly) has a section about defining an ABC (Recipe 8.12). The book was written before Python 3.4, so they don’t use the now preferred syntax of declaring ABCs by subclassing from abc.ABC (instead, they use the metaclass key‐ word, which we’ll only really need in Chapter 24). Apart from this small detail, the recipe covers the major ABC features very well.\n\nThe Python Standard Library by Example by Doug Hellmann (Addison-Wesley), has a chapter about the abc module. It’s also available on the web in Doug’s excellent PyMOTW—Python Module of the Week. Hellmann also uses the old style of ABC declaration: PluginBase(metaclass=abc.ABCMeta) instead of the simpler Plugin Base(abc.ABC) available since Python 3.4.\n\nWhen using ABCs, multiple inheritance is not only common but practically inevita‐ ble, because each of the fundamental collection ABCs—Sequence, Mapping, and Set —extends Collection, which in turn extends multiple ABCs (see Figure 13-4). Therefore, Chapter 14 is an important follow-up to this one.\n\nPEP 3119—Introducing Abstract Base Classes gives the rationale for ABCs. PEP 3141 —A Type Hierarchy for Numbers presents the ABCs of the numbers module, but the discussion in the Mypy issue #3186 “int is not a Number?” includes some arguments about why the numeric tower is unsuitable for static type checking. Alex Waygood wrote a comprehensive answer on StackOverflow, discussing ways to annotate numeric types. I’ll keep watching Mypy issue #3186 for the next chapters of this saga, hoping for a happy ending that will make static typing and goose typing compatible —as they should be.\n\nFurther Reading\n\n|\n\n483",
      "content_length": 2089,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 514,
      "content": "Soapbox\n\nThe MVP Journey of Python Static Typing\n\nI work for Thoughtworks, a worldwide leader in Agile software development. At Thoughtworks, we often recommend that our clients should aim to create and deploy MVPs: minimal viable products: “a simple version of a product that is given to users in order to validate the key business assumptions,” as defined by my colleague Paulo Caroli in “Lean Inception”, a post in Martin Fowler’s collective blog.\n\nGuido van Rossum and the other core developers who designed and implemented static typing have followed an MVP strategy since 2006. First, PEP 3107—Function Annotations was implemented in Python 3.0 with very limited semantics: just syntax to attach annotations to function parameters and returns. This was done explicitly to allow for experimentation and collect feedback—key benefits of an MVP.\n\nEight years later, PEP 484—Type Hints was proposed and approved. Its implementa‐ tion in Python 3.5 required no changes in the language or standard library—except for adding the typing module, on which no other part of the standard library depen‐ ded. PEP 484 supported only nominal types with generics—similar to Java—but with the actual static checking done by external tools. Important features were missing, like variable annotations, generic built-in types, and protocols. Despite those limita‐ tions, this typing MVP was valuable enough to attract investment and adoption by companies with very large Python codebases, like Dropbox, Google, and Facebook; as well as support from professional IDEs, like PyCharm, Wing, and VS Code.\n\nPEP 526—Syntax for Variable Annotations was the first evolutionary step that required changes to the interpreter in Python 3.6. More changes to the Python 3.7 interpreter were made to support PEP 563—Postponed Evaluation of Annotations and PEP 560—Core support for typing module and generic types, which allowed built-in and standard library collections to accept generic type hints out of the box in Python 3.9, thanks to PEP 585—Type Hinting Generics In Standard Collections.\n\nDuring those years, some Python users—including me—were underwhelmed by the typing support. After I learned Go, the lack of static duck typing in Python was incomprehensible, in a language where duck typing had always been a core strength.\n\nBut that is the nature of MVPs: they may not satisfy all potential users, but they can be implemented with less effort, and guide further development with feedback from actual usage in the field.\n\nIf there is one thing we all learned from Python 3, it’s that incremental progress is safer than big-bang releases. I am glad we did not have to wait for Python 4—if it ever comes—to make Python more attractive to large enterprises, where the benefits of static typing outweigh the added complexity.\n\n484\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 2857,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 515,
      "content": "Typing Approaches in Popular Languages\n\nFigure 13-8 is a variation of the Typing Map (Figure 13-1) with the names of a few popular languages that support each of the typing approaches.\n\nFigure 13-8. Four approaches to type checking and some languages that support them.\n\nTypeScript and Python ≥ 3.8 are the only languages in my small and arbitrary sample that support all four approaches.\n\nGo is clearly a statically typed language in the Pascal tradition, but it pioneered static duck typing—at least among languages that are widely used today. I also put Go in the goose typing quadrant because of its type assertions, which allow checking and adapting to different types at runtime.\n\nIf I had to draw a similar diagram in the year 2000, only the duck typing and the static typing quadrants would have languages in them. I am not aware of languages that supported static duck typing or goose typing 20 years ago. The fact that each of the four quadrants has at least three popular languages suggests that a lot of people see value in each of the four approaches to typing.\n\nFurther Reading\n\n|\n\n485",
      "content_length": 1099,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 516,
      "content": "Monkey Patching\n\nMonkey patching has a bad reputation. If abused, it can lead to systems that are hard to understand and maintain. The patch is usually tightly coupled with its target, mak‐ ing it brittle. Another problem is that two libraries that apply monkey patches may step on each other’s toes, with the second library to run destroying patches of the first.\n\nBut monkey patching can also be useful, for example, to make a class implement a protocol at runtime. The Adapter design pattern solves the same problem by imple‐ menting a whole new class.\n\nIt’s easy to monkey patch Python code, but there are limitations. Unlike Ruby and JavaScript, Python does not let you monkey patch the built-in types. I actually con‐ sider this an advantage, because you can be certain that a str object will always have those same methods. This limitation reduces the chance that external libraries apply conflicting patches.\n\nMetaphors and Idioms in Interfaces\n\nA metaphor fosters understanding by making constraints and affordances clear. That’s the value of the words “stack” and “queue” in describing those fundamental data structures: they make clear which operations are allowed, i.e., how items can be added or removed. On the other hand, Alan Cooper et al. write in About Face, the Essentials of Interaction Design, 4th ed. (Wiley):\n\nStrict adherence to metaphors ties interfaces unnecessarily tightly to the workings of the physical world.\n\nHe’s referring to user interfaces, but the admonition applies to APIs as well. But Cooper does grant that when a “truly appropriate” metaphor “falls on our lap,” we can use it (he writes “falls on our lap” because it’s so hard to find fitting metaphors that you should not spend time actively looking for them). I believe the bingo machine imagery I used in this chapter is appropriate and I stand by it.\n\nAbout Face is by far the best book about UI design I’ve read—and I’ve read a few. Letting go of metaphors as a design paradigm, and replacing it with “idiomatic inter‐ faces” was the most valuable thing I learned from Cooper’s work.\n\nIn About Face, Cooper does not deal with APIs, but the more I think about his ideas, the more I see how they apply to Python. The fundamental protocols of the language are what Cooper calls “idioms.” Once we learn what a “sequence” is, we can apply that knowledge in different contexts. This is a main theme of Fluent Python: high‐ lighting the fundamental idioms of the language, so your code is concise, effective, and readable—for a fluent Pythonista.\n\n486\n\n|\n\nChapter 13: Interfaces, Protocols, and ABCs",
      "content_length": 2588,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 517,
      "content": "CHAPTER 14 Inheritance: For Better or for Worse\n\n[...] we needed a better theory about inheritance entirely (and still do). For example, inheritance and instancing (which is a kind of inheritance) muddles both pragmatics (such as factoring code to save space) and semantics (used for way too many tasks such as: specialization, generalization, speciation, etc.). —Alan Kay, “The Early History of Smalltalk”1\n\nThis chapter is about inheritance and subclassing. I will assume a basic understand‐ ing of these concepts, which you may know from reading The Python Tutorial or from experience with another mainstream object-oriented language, such as Java, C#, or C++. Here we’ll focus on four characteristics of Python:\n\nThe super() function\n\nThe pitfalls of subclassing from built-in types\n\nMultiple inheritance and method resolution order\n\nMixin classes\n\nMultiple inheritance is the ability of a class to have more than one base class. C++ supports it; Java and C# don’t. Many consider multiple inheritance more trouble than it’s worth. It was deliberately left out of Java after its perceived abuse in early C++ codebases.\n\nThis chapter introduces multiple inheritance for those who have never used it, and provides some guidance on how to cope with single or multiple inheritance if you must use it.\n\n1 Alan Kay, “The Early History of Smalltalk,” in SIGPLAN Not. 28, 3 (March 1993), 69–95. Also available\n\nonline. Thanks to my friend Christiano Anderson, who shared this reference as I was writing this chapter.\n\n487",
      "content_length": 1516,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 518,
      "content": "As of 2021, there is a significant backlash against overuse of inheritance in general— not only multiple inheritance—because superclasses and subclasses are tightly cou‐ pled. Tight coupling means that changes to one part of the program may have unex‐ pected and far-reaching effects in other parts, making systems brittle and hard to understand.\n\nHowever, we have to maintain existing systems designed with complex class hierar‐ chies, or use frameworks that force us to use inheritance—even multiple inheritance sometimes.\n\nI will illustrate practical uses of multiple inheritance with the standard library, the Django web framework, and the Tkinter GUI toolkit.\n\nWhat’s New in This Chapter There are no new Python features related to the subject of this chapter, but I heavily edited it based on feedback from technical reviewers of the second edition, especially Leonardo Rochael and Caleb Hattingh.\n\nI wrote a new opening section focusing on the super() built-in function, and changed the examples in “Multiple Inheritance and Method Resolution Order” on page 494 for a deeper exploration of how super() works to support cooperative multiple inheritance.\n\n“Mixin Classes” on page 500 is also new. “Multiple Inheritance in the Real World” on page 502 was reorganized and covers simpler mixin examples from the standard library, before the complex Django and the complicated Tkinter hierarchies.\n\nAs the chapter title suggests, the caveats of inheritance have always been one of the main themes of this chapter. But more and more developers consider it so problem‐ atic that I’ve added a couple of paragraphs about avoiding inheritance to the end of “Chapter Summary” on page 514 and “Further Reading” on page 515.\n\nWe’ll start with an overview of the mysterious super() function.\n\nThe super() Function Consistent use the of the super() built-in function is essential for maintainable object-oriented Python programs.\n\nWhen a subclass overrides a method of a superclass, the overriding method usually needs to call the corresponding method of the superclass. Here’s the recommended\n\n488\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 2142,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 519,
      "content": "way to do it, from an example in the collections module documentation, section “OrderedDict Examples and Recipes”:2\n\nclass LastUpdatedOrderedDict(OrderedDict): \"\"\"Store items in the order they were last updated\"\"\"\n\ndef __setitem__(self, key, value): super().__setitem__(key, value) self.move_to_end(key)\n\nTo do its job, LastUpdatedOrderedDict overrides __setitem__ to:\n\n1. Use super().__setitem__ to call that method on the superclass, to let it insert or update the key/value pair.\n\n2. Call self.move_to_end to ensure the updated key is in the last position.\n\nInvoking an overridden __init__ method is particularly important to allow super‐ classes to do their part in initializing the instance.\n\nIf you learned object-oriented programming in Java, you may recall that a Java constructor method automatically calls the no- argument constructor of the superclass. Python doesn’t do this. You must get used to writing this pattern:\n\ndef __init__(self, a, b) : super().__init__(a, b) ... # more initialization code\n\nYou may have seen code that doesn’t use super(), but instead calls the method directly on the superclass, like this:\n\nclass NotRecommended(OrderedDict): \"\"\"This is a counter example!\"\"\"\n\ndef __setitem__(self, key, value): OrderedDict.__setitem__(self, key, value) self.move_to_end(key)\n\nThis alternative works in this particular case, but is not recommended for two rea‐ sons. First, it hardcodes the base class. The name OrderedDict appears in the class statement and also inside __setitem__. If in the future someone changes the class statement to change the base class or add another one, they may forget to update the body of __setitem__, introducing a bug.\n\n2 I only changed the docstring in the example, because the original is misleading. It says: “Store items in the order the keys were last added,” but that is not what the clearly named LastUpdatedOrderedDict does.\n\nThe super() Function\n\n|\n\n489",
      "content_length": 1919,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 520,
      "content": "The second reason is that super implements logic to handle class hierarchies with multiple inheritance. We’ll come back to that in “Multiple Inheritance and Method Resolution Order” on page 494. To conclude this refresher about super, it is useful to review how we had to call it in Python 2, because the old signature with two argu‐ ments is revealing:\n\nclass LastUpdatedOrderedDict(OrderedDict): \"\"\"This code works in Python 2 and Python 3\"\"\"\n\ndef __setitem__(self, key, value): super(LastUpdatedOrderedDict, self).__setitem__(key, value) self.move_to_end(key)\n\nBoth arguments of super are now optional. The Python 3 bytecode compiler auto‐ matically provides them by inspecting the surrounding context when super() is invoked in a method. The arguments are:\n\ntype\n\nThe start of the search path for the superclass implementing the desired method. By default, it is the class that owns the method where the super() call appears.\n\nobject_or_type\n\nThe object (for instance method calls) or class (for class method calls) to be the receiver of the method call. By default, it is self if the super() call happens in an instance method.\n\nWhether you or the compiler provides those arguments, the super() call returns a dynamic proxy object that finds a method (such as __setitem__ in the example) in a superclass of the type parameter, and binds it to the object_or_type, so that we don’t need to pass the receiver (self) explicitly when invoking the method.\n\nIn Python 3, you can still explicitly provide the first and second arguments to super().3 But they are needed only in special cases, such as skipping over part of the MRO for testing or debugging, or for working around undesired behavior in a superclass.\n\nNow let’s discuss the caveats when subclassing built-in types.\n\nSubclassing Built-In Types Is Tricky It was not possible to subclass built-in types such as list or dict in the earliest ver‐ sions of Python. Since Python 2.2, it’s possible, but there is a major caveat: the code of\n\n3 It is also possible to provide only the first argument, but this not useful and may soon be deprecated, with the blessing of Guido van Rossum who created super() in the first place. See the discussion at “Is it time to dep‐ recate unbound super methods?”.\n\n490\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 2309,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 521,
      "content": "the built-ins (written in C) usually does not call methods overridden by user-defined classes. A good short description of the problem is in the documentation for PyPy, in the “Differences between PyPy and CPython” section, “Subclasses of built-in types”:\n\nOfficially, CPython has no rule at all for when exactly overridden method of subclasses of built-in types get implicitly called or not. As an approximation, these methods are never called by other built-in methods of the same object. For example, an overridden __getitem__() in a subclass of dict will not be called by e.g. the built-in get() method.\n\nExample 14-1 illustrates the problem.\n\nExample 14-1. Our __setitem__ override is ignored by the __init__ and __update__ methods of the built-in dict\n\n>>> class DoppelDict(dict): ... def __setitem__(self, key, value): ... super().__setitem__(key, [value] * 2) ... >>> dd = DoppelDict(one=1) >>> dd {'one': 1} >>> dd['two'] = 2 >>> dd {'one': 1, 'two': [2, 2]} >>> dd.update(three=3) >>> dd {'three': 3, 'one': 1, 'two': [2, 2]}\n\nDoppelDict.__setitem__ duplicates values when storing (for no good reason, just to have a visible effect). It works by delegating to the superclass.\n\nThe __init__ method inherited from dict clearly ignored that __setitem__ was overridden: the value of 'one' is not duplicated.\n\nThe [] operator calls our __setitem__ and works as expected: 'two' maps to the duplicated value [2, 2].\n\nThe update method from dict does not use our version of __setitem__ either: the value of 'three' was not duplicated.\n\nThis built-in behavior is a violation of a basic rule of object-oriented programming: the search for methods should always start from the class of the receiver (self), even when the call happens inside a method implemented in a superclass. This is what is called “late binding,” which Alan Kay—of Smalltalk fame—considers a key feature of object-oriented programming: in any call of the form x.method(), the exact method\n\nSubclassing Built-In Types Is Tricky\n\n|\n\n491",
      "content_length": 2004,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 522,
      "content": "to be called must be determined at runtime, based on the class of the receiver x.4 This sad state of affairs contributes to the issues we saw in “Inconsistent Usage of __missing__ in the Standard Library” on page 94.\n\nThe problem is not limited to calls within an instance—whether self.get() calls self.__getitem__()—but also happens with overridden methods of other classes that should be called by the built-in methods. Example 14-2 is adapted from the PyPy documentation.\n\nExample 14-2. The __getitem__ of AnswerDict is bypassed by dict.update\n\n>>> class AnswerDict(dict): ... def __getitem__(self, key): ... return 42 ... >>> ad = AnswerDict(a='foo') >>> ad['a'] 42 >>> d = {} >>> d.update(ad) >>> d['a'] 'foo' >>> d {'a': 'foo'}\n\nAnswerDict.__getitem__ always returns 42, no matter what the key.\n\nad is an AnswerDict loaded with the key-value pair ('a', 'foo').\n\nad['a'] returns 42, as expected.\n\nd is an instance of plain dict, which we update with ad.\n\nThe dict.update method ignored our AnswerDict.__getitem__.\n\nSubclassing built-in types like dict or list or str directly is error- prone because the built-in methods mostly ignore user-defined overrides. Instead of subclassing the built-ins, derive your classes from the collections module using UserDict, UserList, and UserString, which are designed to be easily extended.\n\n4 It is interesting to note that C++ has the notion of virtual and nonvirtual methods. Virtual methods are late bound, but nonvirtual methods are bound at compile time. Although every method that we can write in Python is late bound like a virtual method, built-in objects written in C seem to have nonvirtual methods by default, at least in CPython.\n\n492\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 1743,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 523,
      "content": "If you subclass collections.UserDict instead of dict, the issues exposed in Exam‐ ples 14-1 and 14-2 are both fixed. See Example 14-3.\n\nExample 14-3. DoppelDict2 and AnswerDict2 work as expected because they extend UserDict and not dict\n\n>>> import collections >>> >>> class DoppelDict2(collections.UserDict): ... def __setitem__(self, key, value): ... super().__setitem__(key, [value] * 2) ... >>> dd = DoppelDict2(one=1) >>> dd {'one': [1, 1]} >>> dd['two'] = 2 >>> dd {'two': [2, 2], 'one': [1, 1]} >>> dd.update(three=3) >>> dd {'two': [2, 2], 'three': [3, 3], 'one': [1, 1]} >>> >>> class AnswerDict2(collections.UserDict): ... def __getitem__(self, key): ... return 42 ... >>> ad = AnswerDict2(a='foo') >>> ad['a'] 42 >>> d = {} >>> d.update(ad) >>> d['a'] 42 >>> d {'a': 42}\n\nAs an experiment to measure the extra work required to subclass a built-in, I rewrote the StrKeyDict class from Example 3-9 to subclass dict instead of UserDict. In order to make it pass the same suite of tests, I had to implement __init__, get, and update because the versions inherited from dict refused to cooperate with the over‐ ridden __missing__, __contains__, and __setitem__. The UserDict subclass from Example 3-9 has 16 lines, while the experimental dict subclass ended up with 33 lines.5\n\n5 If you are curious, the experiment is in the 14-inheritance/strkeydict_dictsub.py file in the fluentpython/\n\nexample-code-2e repository.\n\nSubclassing Built-In Types Is Tricky\n\n|\n\n493",
      "content_length": 1468,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 524,
      "content": "To be clear: this section covered an issue that applies only to method delegation within the C language code of the built-in types, and only affects classes derived directly from those types. If you subclass a base class coded in Python, such as UserDict or MutableMapping, you will not be troubled by this.6\n\nNow let’s focus on an issue that arises with multiple inheritance: if a class has two superclasses, how does Python decide which attribute to use when we call super().attr, but both superclasses have an attribute with that name?\n\nMultiple Inheritance and Method Resolution Order Any language implementing multiple inheritance needs to deal with potential nam‐ ing conflicts when superclasses implement a method by the same name. This is called the “diamond problem,” illustrated in Figure 14-1 and Example 14-4.\n\nFigure 14-1. Left: Activation sequence for the leaf1.ping() call. Right: Activation sequence for the leaf1.pong() call.\n\nExample 14-4. diamond.py: classes Leaf, A, B, Root form the graph in Figure 14-1\n\nclass Root: def ping(self): print(f'{self}.ping() in Root')\n\ndef pong(self): print(f'{self}.pong() in Root')\n\ndef __repr__(self):\n\n6 By the way, in this regard, PyPy behaves more “correctly” than CPython, at the expense of introducing a\n\nminor incompatibility. See “Differences between PyPy and CPython” for details.\n\n494\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 1400,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 525,
      "content": "cls_name = type(self).__name__ return f'<instance of {cls_name}>'\n\nclass A(Root): def ping(self): print(f'{self}.ping() in A') super().ping()\n\ndef pong(self): print(f'{self}.pong() in A') super().pong()\n\nclass B(Root): def ping(self): print(f'{self}.ping() in B') super().ping()\n\ndef pong(self): print(f'{self}.pong() in B')\n\nclass Leaf(A, B): def ping(self): print(f'{self}.ping() in Leaf') super().ping()\n\nRoot provides ping, pong, and __repr__ to make the output easier to read.\n\nThe ping and pong methods in class A both call super().\n\nOnly the ping method in class B calls super().\n\nClass Leaf implements only ping, and it calls super().\n\nNow let’s see the effect of calling the ping and pong methods on an instance of Leaf (Example 14-5).\n\nExample 14-5. Doctests for calling ping and pong on a Leaf object\n\n>>> leaf1 = Leaf() >>> leaf1.ping() <instance of Leaf>.ping() in Leaf <instance of Leaf>.ping() in A <instance of Leaf>.ping() in B <instance of Leaf>.ping() in Root\n\n>>> leaf1.pong()\n\nMultiple Inheritance and Method Resolution Order\n\n|\n\n495",
      "content_length": 1054,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 526,
      "content": "<instance of Leaf>.pong() in A <instance of Leaf>.pong() in B\n\nleaf1 is an instance of Leaf.\n\nCalling leaf1.ping() activates the ping methods in Leaf, A, B, and Root, because the ping methods in the first three classes call super().ping().\n\nCalling leaf1.pong() activates pong in A via inheritance, which then calls super.pong(), activating B.pong.\n\nThe activation sequences shown in Example 14-5 and Figure 14-1 are determined by two factors:\n\nThe method resolution order of the Leaf class. • The use of super() in each method.\n\nEvery class has an attribute called __mro__ holding a tuple of references to the super‐ classes in method resolution order, from the current class all the way to the object class.7 For the Leaf class, this is the __mro__:\n\n>>> Leaf.__mro__ # doctest:+NORMALIZE_WHITESPACE (<class 'diamond1.Leaf'>, <class 'diamond1.A'>, <class 'diamond1.B'>, <class 'diamond1.Root'>, <class 'object'>)\n\nLooking at Figure 14-1, you may think the MRO describes a breadth-first search, but that’s just a coincidence for that particular class hierarchy. The MRO is computed by a published algorithm called C3. Its use in Python is detailed in Michele Simionato’s “The Python 2.3 Method Resolution Order”. It’s a challenging read, but Simionato writes: “unless you make strong use of multiple inheri‐ tance and you have non-trivial hierarchies, you don’t need to understand the C3 algorithm, and you can easily skip this paper.”\n\nThe MRO only determines the activation order, but whether a particular method will be activated in each of the classes depends on whether each implementation calls super() or not.\n\nConsider the experiment with the pong method. The Leaf class does not override it, therefore calling leaf1.pong() activates the implementation in the next class of\n\n7 Classes also have a .mro() method, but that’s an advanced feature of metaclass programming, mentioned in “Classes as Objects” on page 908. The content of the __mro__ attribute is what matters during normal usage of a class.\n\n496\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 2067,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 527,
      "content": "Leaf.__mro__: the A class. Method A.pong calls super().pong(). The B class is next in the MRO, therefore B.pong is activated. But that method doesn’t call super().pong(), so the activation sequence ends here.\n\nThe MRO takes into account not only the inheritance graph but also the order in which superclasses are listed in a subclass declaration. In other words, if in dia‐ mond.py (Example 14-4) the Leaf class was declared as Leaf(B, A), then class B would appear before A in Leaf.__mro__. This would affect the activation order of the ping methods, and would also cause leaf1.pong() to activate B.pong via inheritance, but A.pong and Root.pong would never run, because B.pong doesn’t call super().\n\nWhen a method calls super(), it is a cooperative method. Cooperative methods enable cooperative multiple inheritance. These terms are intentional: in order to work, multiple inheritance in Python requires the active cooperation of the methods involved. In the B class, ping cooperates, but pong does not.\n\nA noncooperative method can be the cause of subtle bugs. Many coders reading Example 14-4 may expect that when method A.pong calls super.pong(), that will ultimately activate Root.pong. But if B.pong is activated before, it drops the ball. That’s why it is recommended that every method m of a nonroot class should call super().m().\n\nCooperative methods must have compatible signatures, because you never know whether A.ping will be called before or after B.ping. The activation sequence depends on the order of A and B in the declaration of each subclass that inherits from both.\n\nPython is a dynamic language, so the interaction of super() with the MRO is also dynamic. Example 14-6 shows a surprising result of this dynamic behavior.\n\nExample 14-6. diamond2.py: classes to demonstrate the dynamic nature of super()\n\nfrom diamond import A\n\nclass U(): def ping(self): print(f'{self}.ping() in U') super().ping()\n\nclass LeafUA(U, A): def ping(self): print(f'{self}.ping() in LeafUA') super().ping()\n\nMultiple Inheritance and Method Resolution Order\n\n|\n\n497",
      "content_length": 2064,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 528,
      "content": "Class A comes from diamond.py (Example 14-4).\n\nClass U is unrelated to A or Root from the diamond module.\n\nWhat does super().ping() do? Answer: it depends. Read on.\n\nLeafUA subclasses U and A in this order.\n\nIf you create an instance of U and try to call ping, you get an error:\n\n>>> u = U() >>> u.ping() Traceback (most recent call last): ... AttributeError: 'super' object has no attribute 'ping'\n\nThe 'super' object returned by super() has no attribute 'ping' because the MRO of U has two classes: U and object, and the latter has no attribute named 'ping'.\n\nHowever, the U.ping method is not completely hopeless. Check this out:\n\n>>> leaf2 = LeafUA() >>> leaf2.ping() <instance of LeafUA>.ping() in LeafUA <instance of LeafUA>.ping() in U <instance of LeafUA>.ping() in A <instance of LeafUA>.ping() in Root >>> LeafUA.__mro__ # doctest:+NORMALIZE_WHITESPACE (<class 'diamond2.LeafUA'>, <class 'diamond2.U'>, <class 'diamond.A'>, <class 'diamond.Root'>, <class 'object'>)\n\nThe super().ping() call in LeafUA activates U.ping, which cooperates by calling super().ping() too, activating A.ping, and eventually Root.ping.\n\nNote the base classes of LeafUA are (U, A) in that order. If instead the bases were (A, U), then leaf2.ping() would never reach U.ping, because the super().ping() in A.ping would activate Root.ping, and that method does not call super().\n\nIn a real program, a class like U could be a mixin class: a class intended to be used together with other classes in multiple inheritance, to provide additional functional‐ ity. We’ll study that shortly, in “Mixin Classes” on page 500.\n\nTo wrap up this discussion of the MRO, Figure 14-2 illustrates part of the complex multiple inheritance graph of the Tkinter GUI toolkit from the Python standard library.\n\n498\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 1827,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 529,
      "content": "Figure 14-2. Left: UML diagram of the Tkinter Text widget class and superclasses. Right: The long and winding path of Text.__mro__ is drawn with dashed arrows.\n\nTo study the picture, start at the Text class at the bottom. The Text class implements a full-featured, multiline editable text widget. It provides rich functionality in itself, but also inherits many methods from other classes. The lefthand side shows a plain UML class diagram. On the right, it’s decorated with arrows showing the MRO, as listed in Example 14-7 with the help of a print_mro convenience function.\n\nExample 14-7. MRO of tkinter.Text\n\n>>> def print_mro(cls): ... print(', '.join(c.__name__ for c in cls.__mro__)) >>> import tkinter >>> print_mro(tkinter.Text) Text, Widget, BaseWidget, Misc, Pack, Place, Grid, XView, YView, object\n\nNow let’s talk about mixins.\n\nMultiple Inheritance and Method Resolution Order\n\n|\n\n499",
      "content_length": 896,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 530,
      "content": "Mixin Classes A mixin class is designed to be subclassed together with at least one other class in a multiple inheritance arrangement. A mixin is not supposed to be the only base class of a concrete class, because it does not provide all the functionality for a concrete object, but only adds or customizes the behavior of child or sibling classes.\n\nMixin classes are a convention with no explicit language support in Python and C++. Ruby allows the explicit definition and use of modules that work as mixins—collections of methods that may be included to add functionality to a class. C#, PHP, and Rust imple‐ ment traits, which are also an explicit form of mixin.\n\nLet’s see a simple but handy example of a mixin class.\n\nCase-Insensitive Mappings Example 14-8 shows UpperCaseMixin, a class designed to provide case-insensitive access to mappings with string keys, by uppercasing those keys when they are added or looked up.\n\nExample 14-8. uppermixin.py: UpperCaseMixin supports case-insensitive mappings\n\nimport collections\n\ndef _upper(key): try: return key.upper() except AttributeError: return key\n\nclass UpperCaseMixin: def __setitem__(self, key, item): super().__setitem__(_upper(key), item)\n\ndef __getitem__(self, key): return super().__getitem__(_upper(key))\n\ndef get(self, key, default=None): return super().get(_upper(key), default)\n\ndef __contains__(self, key): return super().__contains__(_upper(key))\n\n500\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 1471,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 531,
      "content": "This helper function takes a key of any type, and tries to return key.upper(); if that fails, it returns the key unchanged.\n\nThe mixin implements four essential methods of mappings, always calling super(), with the key uppercased, if possible.\n\nSince every method ot UpperCaseMixin calls super(), this mixin depends on a sibling class that implements or inherits methods with the same signature. To make its con‐ tribution, a mixin usually needs to appear before other classes in the MRO of a sub‐ class that uses it. In practice, that means mixins must appear first in the tuple of base classes in a class declaration. Example 14-9 shows two examples.\n\nExample 14-9. uppermixin.py: two classes that use UpperCaseMixin\n\nclass UpperDict(UpperCaseMixin, collections.UserDict): pass\n\nclass UpperCounter(UpperCaseMixin, collections.Counter): \"\"\"Specialized 'Counter' that uppercases string keys\"\"\"\n\nUpperDict needs no implementation of its own, but UpperCaseMixin must be the first base class, otherwise the methods from UserDict would be called instead.\n\nUpperCaseMixin also works with Counter.\n\nInstead of pass, it’s better to provide a docstring to satisfy the need for a body in the class statement syntax.\n\nHere are some doctests from uppermixin.py, for UpperDict:\n\n>>> d = UpperDict([('a', 'letter A'), (2, 'digit two')]) >>> list(d.keys()) ['A', 2] >>> d['b'] = 'letter B' >>> 'b' in d True >>> d['a'], d.get('B') ('letter A', 'letter B') >>> list(d.keys()) ['A', 2, 'B']\n\nAnd a quick demonstration of UpperCounter:\n\n>>> c = UpperCounter('BaNanA') >>> c.most_common() [('A', 3), ('N', 2), ('B', 1)]\n\nMixin Classes\n\n|\n\n501",
      "content_length": 1624,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 532,
      "content": "UpperDict and UpperCounter seem almost magical, but I had to carefully study the code of UserDict and Counter to make UpperCaseMixin work with them.\n\nFor example, my first version of UpperCaseMixin did not provide the get method. That version worked with UserDict but not with Counter. The UserDict class inher‐ its get from collections.abc.Mapping, and that get calls __getitem__, which I implemented. But keys were not uppercased when an UpperCounter was loaded upon __init__. That happened because Counter.__init__ uses Counter.update, which in turn relies on the get method inherited from dict. However, the get method in the dict class does not call __getitem__. This is the heart of the issue discussed in “Inconsistent Usage of __missing__ in the Standard Library” on page 94. It is also a stark reminder of the brittle and puzzling nature of programs leveraging inheritance, even at a small scale.\n\nThe next section covers several examples of multiple inheritance, often featuring mixin classes.\n\nMultiple Inheritance in the Real World In the Design Patterns book,8 almost all the code is in C++, but the only example of multiple inheritance is the Adapter pattern. In Python, multiple inheritance is not the norm either, but there are important examples that I will comment on in this section.\n\nABCs Are Mixins Too In the Python standard library, the most visible use of multiple inheritance is the col lections.abc package. That is not controversial: after all, even Java supports multi‐ ple inheritance of interfaces, and ABCs are interface declarations that may optionally provide concrete method implementations.9\n\nPython’s official documentation of collections.abc uses the term mixin method for the concrete methods implemented in many of the collection ABCs. The ABCs that provide mixin methods play two roles: they are interface definitions and also mixin classes. For example, the implementation of collections.UserDict relies on several of the mixin methods provided by collections.abc.MutableMapping.\n\n8 Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, Design Patterns: Elements of Reusable\n\nObject-Oriented Software (Addison-Wesley).\n\n9 As previously mentioned, Java 8 allows interfaces to provide method implementations as well. The new fea‐\n\nture is called “Default Methods” in the official Java Tutorial.\n\n502\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 2399,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 533,
      "content": "ThreadingMixIn and ForkingMixIn The http.server package provides HTTPServer and ThreadingHTTPServer classes. The latter was added in Python 3.7. Its documentation says:\n\nclass http.server.ThreadingHTTPServer(server_address, RequestHandlerClass)\n\nThis class is identical to HTTPServer but uses threads to handle requests by using the ThreadingMixIn. This is useful to handle web browsers pre-opening sockets, on which HTTPServer would wait indefinitely.\n\nThis is the complete source code for the ThreadingHTTPServer class in Python 3.10:\n\nclass ThreadingHTTPServer(socketserver.ThreadingMixIn, HTTPServer): daemon_threads = True\n\nThe source code of socketserver.ThreadingMixIn has 38 lines, including comments and docstrings. Example 14-10 shows a summary of its implementation.\n\nExample 14-10. Part of Lib/socketserver.py in Python 3.10\n\nclass ThreadingMixIn: \"\"\"Mixin class to handle each request in a new thread.\"\"\"\n\n# 8 lines omitted in book listing\n\ndef process_request_thread(self, request, client_address): ... # 6 lines omitted in book listing\n\ndef process_request(self, request, client_address): ... # 8 lines omitted in book listing\n\ndef server_close(self): super().server_close() self._threads.join()\n\nprocess_request_thread does not call super() because it is a new method, not an override. Its implementation calls three instance methods that HTTPServer provides or inherits.\n\nThis overrides the process_request method that HTTPServer inherits from sock etserver.BaseServer, starting a thread and delegating the actual work to pro cess_request_thread running in that thread. It does not call super().\n\nserver_close calls super().server_close() to stop taking requests, then waits for the threads started by process_request to finish their jobs.\n\nThe ThreadingMixIn appears in the socketserver module documentation next to ForkingMixin. The latter is designed to support concurrent servers based on\n\nMultiple Inheritance in the Real World\n\n|\n\n503",
      "content_length": 1957,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 534,
      "content": "os.fork(), an API for launching a child process, available in POSIX-compliant Unix-like systems.\n\nDjango Generic Views Mixins\n\nYou don’t need to know Django to follow this section. I am using a small part of the framework as a practical example of multiple inheritance, and I will try to give all the necessary background, assuming you have some experience with server-side web develop‐ ment in any language or framework.\n\nIn Django, a view is a callable object that takes a request argument—an object repre‐ senting an HTTP request—and returns an object representing an HTTP response. The different responses are what interests us in this discussion. They can be as simple as a redirect response, with no content body, or as complex as a catalog page in an online store, rendered from an HTML template and listing multiple merchandise with buttons for buying, and links to detail pages.\n\nOriginally, Django provided a set of functions, called generic views, that imple‐ mented some common use cases. For example, many sites need to show search results that include information from numerous items, with the listing spanning mul‐ tiple pages, and for each item a link to a page with detailed information about it. In Django, a list view and a detail view are designed to work together to solve this problem: a list view renders search results, and a detail view produces a page for each individual item.\n\nHowever, the original generic views were functions, so they were not extensible. If you needed to do something similar but not exactly like a generic list view, you’d have to start from scratch.\n\nThe concept of class-based views was introduced in Django 1.3, along with a set of generic view classes organized as base classes, mixins, and ready-to-use concrete classes. In Django 3.2, the base classes and mixins are in the base module of the django.views.generic package, pictured in Figure 14-3. At the top of the diagram we see two classes that take care of very distinct responsibilities: View and TemplateResponseMixin.\n\n504\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 2087,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 535,
      "content": "Figure 14-3. UML class diagram for the django.views.generic.base module.\n\nA great resource to study these classes is the Classy Class-Based Views website, where you can easily navigate through them, see all methods in each class (inherited, overridden, and added methods), view diagrams, browse their documentation, and jump to their source code on GitHub.\n\nView is the base class of all views (it could be an ABC), and it provides core function‐ ality like the dispatch method, which delegates to “handler” methods like get, head, post, etc., implemented by concrete subclasses to handle the different HTTP verbs.10 The RedirectView class inherits only from View, and you can see that it implements get, head, post, etc.\n\nConcrete subclasses of View are supposed to implement the handler methods, so why aren’t those methods part of the View interface? The reason: subclasses are free to\n\n10 Django programmers know that the as_view class method is the most visible part of the View interface, but\n\nit’s not relevant to us here.\n\nMultiple Inheritance in the Real World\n\n|\n\n505",
      "content_length": 1077,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 536,
      "content": "implement just the handlers they want to support. A TemplateView is used only to display content, so it only implements get. If an HTTP POST request is sent to a Tem plateView, the inherited View.dispatch method checks that there is no post han‐ dler, and produces an HTTP 405 Method Not Allowed response.11\n\nThe TemplateResponseMixin provides functionality that is of interest only to views that need to use a template. A RedirectView, for example, has no content body, so it has no need of a template and it does not inherit from this mixin. TemplateResponse Mixin provides behaviors to TemplateView and other template-rendering views, such as ListView, DetailView, etc., defined in the django.views.generic subpackages. Figure 14-4 depicts the django.views.generic.list module and part of the base module.\n\nFor Django users, the most important class in Figure 14-4 is ListView, which is an aggregate class, with no code at all (its body is just a docstring). When instantiated, a ListView has an object_list instance attribute through which the template can iter‐ ate to show the page contents, usually the result of a database query returning multi‐ ple objects. All the functionality related to generating this iterable of objects comes from the MultipleObjectMixin. That mixin also provides the complex pagination logic—to display part of the results in one page and links to more pages.\n\nSuppose you want to create a view that will not render a template, but will produce a list of objects in JSON format. That’s why the BaseListView exists. It provides an easy-to-use extension point that brings together View and MultipleObjectMixin functionality, without the overhead of the template machinery.\n\nThe Django class-based views API is a better example of multiple inheritance than Tkinter. In particular, it is easy to make sense of its mixin classes: each has a well- defined purpose, and they are all named with the …Mixin suffix.\n\n11 If you are into design patterns, you’ll notice that the Django dispatch mechanism is a dynamic variation of the Template Method pattern. It’s dynamic because the View class does not force subclasses to implement all han‐ dlers, but dispatch checks at runtime if a concrete handler is available for the specific request.\n\n506\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 2321,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 537,
      "content": "Figure 14-4. UML class diagram for the django.views.generic.list module. Here the three classes of the base module are collapsed (see Figure 14-3). The ListView class has no methods or attributes: it’s an aggregate class.\n\nClass-based views were not universally embraced by Django users. Many do use them in a limited way, as opaque boxes, but when it’s necessary to create something new, a lot of Django coders continue writing monolithic view functions that take care of all those responsibilities, instead of trying to reuse the base views and mixins.\n\nIt does take some time to learn how to leverage class-based views and how to extend them to fulfill specific application needs, but I found that it was worthwhile to study them. They eliminate a lot of boilerplate code, make it easier to reuse solutions, and even improve team communication—for example, by defining standard names to templates, and to the variables passed to template contexts. Class-based views are Django views “on rails.”\n\nMultiple Inheritance in Tkinter An extreme example of multiple inheritance in Python’s standard library is the Tkinter GUI toolkit. I used part of the Tkinter widget hierarchy to illustrate the MRO in Figure 14-2. Figure 14-5 shows all the widget classes in the tkinter base package (there are more widgets in the tkinter.ttk subpackage).\n\nMultiple Inheritance in the Real World\n\n|\n\n507",
      "content_length": 1385,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 538,
      "content": "Figure 14-5. Summary UML diagram for the Tkinter GUI class hierarchy; classes tag‐ ged «mixin» are designed to provide concrete methods to other classes via multiple inheritance.\n\nTkinter is 25 years old as I write this. It is not an example of current best practices. But it shows how multiple inheritance was used when coders did not appreciate its drawbacks. And it will serve as a counterexample when we cover some good practices in the next section.\n\nConsider these classes from Figure 14-5:\n\n➊ Toplevel: The class of a top-level window in a Tkinter application.\n\n➋ Widget: The superclass of every visible object that can be placed on a window.\n\n➌ Button: A plain button widget.\n\n➍ Entry: A single-line editable text field.\n\n➎ Text: A multiline editable text field.\n\nHere are the MROs of those classes, displayed by the print_mro function from Example 14-7:\n\n>>> import tkinter >>> print_mro(tkinter.Toplevel) Toplevel, BaseWidget, Misc, Wm, object\n\n508\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 1011,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 539,
      "content": ">>> print_mro(tkinter.Widget) Widget, BaseWidget, Misc, Pack, Place, Grid, object >>> print_mro(tkinter.Button) Button, Widget, BaseWidget, Misc, Pack, Place, Grid, object >>> print_mro(tkinter.Entry) Entry, Widget, BaseWidget, Misc, Pack, Place, Grid, XView, object >>> print_mro(tkinter.Text) Text, Widget, BaseWidget, Misc, Pack, Place, Grid, XView, YView, object\n\nBy current standards, the class hierarchy of Tkinter is very deep. Few parts of the Python standard library have more than three or four levels of concrete classes, and the same can be said of the Java class library. However, it is interesting to note that the some of the deepest hierarchies in the Java class library are precisely in the packages related to GUI programming: java.awt and javax.swing. Squeak, the modern, free version of Smalltalk, includes the powerful and innovative Morphic GUI toolkit, also with a deep class hierarchy. In my experience, GUI toolkits are where inheritance is most useful.\n\nNote how these classes relate to others:\n\nToplevel is the only graphical class that does not inherit from Widget, because it is the top-level window and does not behave like a widget; for example, it cannot be attached to a window or frame. Toplevel inherits from Wm, which provides direct access functions of the host window manager, like setting the window title and configuring its borders.\n\nWidget inherits directly from BaseWidget and from Pack, Place, and Grid. These last three classes are geometry managers: they are responsible for arranging widgets inside a window or frame. Each encapsulates a different layout strategy and widget placement API.\n\nButton, like most widgets, descends only from Widget, but indirectly from Misc, which provides dozens of methods to every widget.\n\nEntry subclasses Widget and XView, which support horizontal scrolling. • Text subclasses from Widget, XView, and YView for vertical scrolling.\n\nWe’ll now discuss some good practices of multiple inheritance and see whether Tkinter goes along with them.\n\nMultiple Inheritance in the Real World\n\n|\n\n509",
      "content_length": 2068,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 540,
      "content": "Coping with Inheritance What Alan Kay wrote in the epigraph remains true: there’s still no general theory about inheritance that can guide practicing programmers. What we have are rules of thumb, design patterns, “best practices,” clever acronyms, taboos, etc. Some of these provide useful guidelines, but none of them are universally accepted or always applicable.\n\nIt’s easy to create incomprehensible and brittle designs using inheritance, even without multiple inheritance. Because we don’t have a comprehensive theory, here are a few tips to avoid spaghetti class graphs.\n\nFavor Object Composition over Class Inheritance The title of this subsection is the second principle of object-oriented design from the Design Patterns book,12 and is the best advice I can offer here. Once you get comforta‐ ble with inheritance, it’s too easy to overuse it. Placing objects in a neat hierarchy appeals to our sense of order; programmers do it just for fun.\n\nFavoring composition leads to more flexible designs. For example, in the case of the tkinter.Widget class, instead of inheriting the methods from all geometry managers, widget instances could hold a reference to a geometry manager, and invoke its meth‐ ods. After all, a Widget should not “be” a geometry manager, but could use the serv‐ ices of one via delegation. Then you could add a new geometry manager without touching the widget class hierarchy and without worrying about name clashes. Even with single inheritance, this principle enhances flexibility, because subclassing is a form of tight coupling, and tall inheritance trees tend to be brittle.\n\nComposition and delegation can replace the use of mixins to make behaviors avail‐ able to different classes, but cannot replace the use of interface inheritance to define a hierarchy of types.\n\nUnderstand Why Inheritance Is Used in Each Case When dealing with multiple inheritance, it’s useful to keep straight the reasons why subclassing is done in each particular case. The main reasons are:\n\nInheritance of interface creates a subtype, implying an “is-a” relationship. This is best done with ABCs.\n\nInheritance of implementation avoids code duplication by reuse. Mixins can help with this.\n\n12 The principle appears on p. 20 of the introduction to the book.\n\n510\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 2328,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 541,
      "content": "In practice, both uses are often simultaneous, but whenever you can make the intent clear, do it. Inheritance for code reuse is an implementation detail, and it can often be replaced by composition and delegation. On the other hand, interface inheritance is the backbone of a framework. Interface inheritance should use only ABCs as base classes, if possible.\n\nMake Interfaces Explicit with ABCs In modern Python, if a class is intended to define an interface, it should be an explicit ABC or a typing.Protocol subclass. An ABC should subclass only abc.ABC or other ABCs. Multiple inheritance of ABCs is not problematic.\n\nUse Explicit Mixins for Code Reuse If a class is designed to provide method implementations for reuse by multiple unre‐ lated subclasses, without implying an “is-a” relationship, it should be an explicit mixin class. Conceptually, a mixin does not define a new type; it merely bundles methods for reuse. A mixin should never be instantiated, and concrete classes should not inherit only from a mixin. Each mixin should provide a single specific behavior, implementing few and very closely related methods. Mixins should avoid keeping any internal state; i.e., a mixin class should not have instance attributes.\n\nThere is no formal way in Python to state that a class is a mixin, so it is highly recom‐ mended that they are named with a Mixin suffix.\n\nProvide Aggregate Classes to Users\n\nA class that is constructed primarily by inheriting from mixins and does not add its own structure or behavior is called an aggregate class.\n\n—Booch et al.13\n\nIf some combination of ABCs or mixins is particularly useful to client code, provide a class that brings them together in a sensible way.\n\nFor example, here is the complete source code for the Django ListView class on the bottom right of Figure 14-4:\n\nclass ListView(MultipleObjectTemplateResponseMixin, BaseListView): \"\"\" Render some list of objects, set by `self.model` or `self.queryset`. `self.queryset` can actually be any iterable of items, not just a queryset. \"\"\"\n\n13 Grady Booch et al., Object-Oriented Analysis and Design with Applications, 3rd ed. (Addison-Wesley), p. 109.\n\nCoping with Inheritance\n\n|\n\n511",
      "content_length": 2185,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 542,
      "content": "The body of ListView is empty, but the class provides a useful service: it brings together a mixin and a base class that should be used together.\n\nAnother example is tkinter.Widget, which has four base classes and no methods or attributes of its own—just a docstring. Thanks to the Widget aggregate class, we can create new a widget with the required mixins, without having to figure out in which order they should be declared to work as intended.\n\nNote that aggregate classes don’t have to be completely empty, but they often are.\n\nSubclass Only Classes Designed for Subclassing In one comment about this chapter, technical reviewer Leonardo Rochael suggested the following warning.\n\nSubclassing any complex class and overriding its methods is error- prone because the superclass methods may ignore the subclass overrides in unexpected ways. As much as possible, avoid overrid‐ ing methods, or at least restrain yourself to subclassing classes which are designed to be easily extended, and only in the ways in which they were designed to be extended.\n\nThat’s great advice, but how do we know whether or how a class was designed to be extended?\n\nThe first answer is documentation (sometimes in the form of docstrings or even comments in code). For example, Python’s socketserver package is described as “a framework for network servers.” Its BaseServer class is designed for subclassing, as the name suggests. More importantly, the documentation and the docstring in the source code of the class explicitly note which of its methods are intended to be over‐ ridden by subclasses.\n\nIn Python ≥ 3.8, a new way of making those design constraints explicit is provided by PEP 591—Adding a final qualifier to typing. The PEP introduces a @final decorator that can be applied to classes or individual methods, so that IDEs or type checkers can report misguided attempts to subclass those classes or override those methods.14\n\n14 PEP 591 also introduces a Final annotation for variables or attributes that should not be reassigned or over‐\n\nridden.\n\n512\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 2098,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 543,
      "content": "Avoid Subclassing from Concrete Classes Subclassing concrete classes is more dangerous than subclassing ABCs and mixins, because instances of concrete classes usually have internal state that can easily be cor‐ rupted when you override methods that depend on that state. Even if your methods cooperate by calling super(), and the internal state is held in private attributes using the __x syntax, there are still countless ways a method override can introduce bugs.\n\nIn “Waterfowl and ABCs” on page 443, Alex Martelli quotes Scott Meyer’s More Effective C++, which says: “all non-leaf classes should be abstract.” In other words, Meyer recommends that only abstract classes should be subclassed.\n\nIf you must use subclassing for code reuse, then the code intended for reuse should be in mixin methods of ABCs or in explicitly named mixin classes.\n\nWe will now analyze Tkinter from the point of view of these recommendations.\n\nTkinter: The Good, the Bad, and the Ugly Most advice in the previous section is not followed by Tkinter, with the notable exception of “Provide Aggregate Classes to Users” on page 511. Even then, it’s not a great example, because composition would probably work better for integrating the geometry managers into Widget, as discussed in “Favor Object Composition over Class Inheritance” on page 510.\n\nKeep in mind that Tkinter has been part of the standard library since Python 1.1 was released in 1994. Tkinter is a layer on top of the excellent Tk GUI toolkit of the Tcl language. The Tcl/Tk combo is not originally object-oriented, so the Tk API is basi‐ cally a vast catalog of functions. However, the toolkit is object-oriented in its design, if not in its original Tcl implementation.\n\nThe docstring of tkinter.Widget starts with the words “Internal class.” This suggests that Widget should probably be an ABC. Although Widget has no methods of its own, it does define an interface. Its message is: “You can count on every Tkinter widget providing basic widget methods (__init__, destroy, and dozens of Tk API func‐ tions), in addition to the methods of all three geometry managers.” We can agree that this is not a great interface definition (it’s just too broad), but it is an interface, and Widget “defines” it as the union of the interfaces of its superclasses.\n\nThe Tk class, which encapsulates the GUI application logic, inherits from Wm and Misc, neither of which are abstract or mixin (Wm is not a proper mixin because TopLevel subclasses only from it). The name of the Misc class is—by itself—a very strong code smell. Misc has more than 100 methods, and all widgets inherit from it. Why is it necessary that every single widget has methods for clipboard handling, text selection, timer management, and the like? You can’t really paste into a button or\n\nCoping with Inheritance\n\n|\n\n513",
      "content_length": 2825,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 544,
      "content": "select text from a scrollbar. Misc should be split into several specialized mixin classes, and not all widgets should inherit from every one of those mixins.\n\nTo be fair, as a Tkinter user, you don’t need to know or use multiple inheritance at all. It’s an implementation detail hidden behind the widget classes that you will instantiate or subclass in your own code. But you will suffer the consequences of excessive multiple inheritance when you type dir(tkinter.Button) and try to find the method you need among the 214 attributes listed. And you’ll need to face the complexity if you decide to implement a new Tk widget.\n\nDespite the problems, Tkinter is stable, flexible, and provides a modern look-and-feel if you use the tkinter.ttk package and its themed widgets. Also, some of the original widgets, like Canvas and Text, are incredibly powerful. You can turn a Canvas object into a simple drag-and-drop drawing application in a matter of hours. Tkinter and Tcl/Tk are definitely worth a look if you are interested in GUI programming.\n\nThis concludes our tour through the labyrinth of inheritance.\n\nChapter Summary This chapter started with a review of the super() function in the context of single inheritance. We then discussed the problem with subclassing built-in types: their native methods implemented in C do not call overridden methods in subclasses, except in very few special cases. That’s why, when we need a custom list, dict, or str type, it’s easier to subclass UserList, UserDict, or UserString—all defined in the collections module, which actually wrap the corresponding built-in types and dele‐ gate operations to them—three examples of favoring composition over inheritance in the standard library. If the desired behavior is very different from what the built-ins offer, it may be easier to subclass the appropriate ABC from collections.abc and write your own implementation.\n\nThe rest of the chapter was devoted to the double-edged sword of multiple inheri‐ tance. First we saw how the method resolution order, encoded in the __mro__ class attribute, addresses the problem of potential naming conflicts in inherited methods. We also saw how the super() built-in behaves, sometimes unexpectedly, in hierar‐ chies with multiple inheritance. The behavior of super() is designed to support mixin classes, which we then studied through the simple example of the UpperCase Mixin for case-insensitive mappings.\n\nWe saw how multiple inhertance and mixin methods are used in Python’s ABCs, as well as in the socketserver threading and forking mixins. More complex uses of\n\n514\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 2648,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 545,
      "content": "multiple inheritance were exemplified by Django’s class-based views and the Tkinter GUI toolkit. Although Tkinter is not an example of modern best practices, it is an example of overly complex class hierarchies we may find in legacy systems.\n\nTo close the chapter, I presented seven recommendations to cope with inheritance, and applied some of that advice in a commentary of the Tkinter class hierarchy.\n\nRejecting inheritance—even single inheritance—is a modern trend. One of the most successful languages created in the 21st century is Go. It doesn’t have a construct called “class,” but you can build types that are structs of encapsulated fields and you can attach methods to those structs. Go allows the definition of interfaces that are checked by the compiler using structural typing, a.k.a. static duck typing—very simi‐ lar to what we now have with protocol types since Python 3.8. Go has special syntax for building types and interfaces by composition, but it does not support inheritance —not even among interfaces.\n\nSo perhaps the best advice about inheritance is: avoid it if you can. But often, we don’t have a choice: the frameworks we use impose their own design choices.\n\nFurther Reading\n\nWhen it comes to reading clarity, properly-done composition is superior to inheri‐ tance. Since code is much more often read than written, avoid subclassing in general, but especially don’t mix the various types of inheritance, and don’t use subclassing for code sharing.\n\n—Hynek Schlawack, Subclassing in Python Redux\n\nDuring the final review of this book, technical reviewer Jürgen Gmach recommended Hynek Schlawack’s post “Subclassing in Python Redux”—the source of the preceding quote. Schlawack is the author of the popular attrs package, and was a core contribu‐ tor to the Twisted asynchronous programming framework, a project started by Glyph Lefkowitz in 2002. Over time, the core team realized they had overused subclassing in their design, according to Schlawack. His post is long, and cites other important posts and talks. Highly recommended.\n\nIn that same conclusion, Hynek Schlawack wrote: “Don’t forget that more often than not, a function is all you need.” I agree, and that is precisely why Fluent Python covers functions in depth before classes and inheritance. My goal was to show how much you can accomplish with functions leveraging existing classes from the standard library, before creating your own classes.\n\nSubclassing built-ins, the super function, and advanced features like descriptors and metaclasses are all introduced in Guido van Rossum’s paper “Unifying types and classes in Python 2.2”. Nothing really important has changed in these features since then. Python 2.2 was an amazing feat of language evolution, adding several powerful\n\nFurther Reading\n\n|\n\n515",
      "content_length": 2799,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 546,
      "content": "new features in a coherent whole, without breaking backward compatibility. The new features were 100% opt-in. To use them, we just had to explicitly subclass object— directly or indirectly—to create a so-called “new style class.” In Python 3, every class subclasses object.\n\nThe Python Cookbook, 3rd ed. by David Beazley and Brian K. Jones (O’Reilly) has several recipes showing the use of super() and mixin classes. You can start from the illuminating section “8.7. Calling a Method on a Parent Class”, and follow the inter‐ nal references from there.\n\nRaymond Hettinger’s post “Python’s super() considered super!” explains the work‐ ings of super and multiple inheritance in Python from a positive perspective. It was written in response to “Python’s Super is nifty, but you can’t use it (Previously: Python’s Super Considered Harmful)” by James Knight. Martijn Pieters’ response to “How to use super() with one argument?” includes a concise and deep explanation of super, including its relationship with descriptors, a concept we’ll only study in Chap‐ ter 23. That’s the nature of super. It is simple to use in basic use cases, but is a power‐ ful and complex tool that touches some of Python’s most advanced dynamic features, rarely found in other languages.\n\nDespite the titles of those posts, the problem is not really the super built-in—which in Python 3 is not as ugly as it was in Python 2. The real issue is multiple inheritance, which is inherently complicated and tricky. Michele Simionato goes beyond criticiz‐ ing and actually offers a solution in his “Setting Multiple Inheritance Straight”: he implements traits, an explict form of mixins that originated in the Self language. Sim‐ ionato has a long series of blog posts about multiple inheritance in Python, including “The wonders of cooperative inheritance, or using super in Python 3”; “Mixins con‐ sidered harmful,” part 1 and part 2; and “Things to Know About Python Super,” part 1, part 2, and part 3. The oldest posts use the Python 2 super syntax, but are still rele‐ vant.\n\nI read the first edition of Grady Booch et al., Object-Oriented Analysis and Design, 3rd ed., and highly recommend it as a general primer on object-oriented thinking, inde‐ pendent of programming language. It is a rare book that covers multiple inheritance without prejudice.\n\nNow more than ever it’s fashionable to avoid inheritance, so here are two references about how to do that. Brandon Rhodes wrote “The Composition Over Inheritance Principle”, part of his excellent Python Design Patterns guide. Augie Fackler and Nathaniel Manista presented “The End Of Object Inheritance & The Beginning Of A New Modularity” at PyCon 2013. Fackler and Manista talk about organizing systems around interfaces and functions that handle objects implementing those interfaces, avoiding the tight coupling and failure modes of classes and inheritance. That reminds me a lot of the Go way, but they advocate it for Python.\n\n516\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 3016,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 547,
      "content": "Soapbox\n\nThink about the Classes You Really Need\n\n[We] started to push on the inheritance idea as a way to let novices build on frame‐ works that could only be designed by experts.\n\n—Alan Kay, “The Early History of Smalltalk”15\n\nThe vast majority of programmers write applications, not frameworks. Even those who do write frameworks are likely to spend a lot (if not most) of their time writing applications. When we write applications, we normally don’t need to code class hier‐ archies. At most, we write classes that subclass from ABCs or other classes provided by the framework. As application developers, it’s very rare that we need to write a class that will act as the superclass of another. The classes we code are almost always leaf classes (i.e., leaves of the inheritance tree).\n\nIf, while working as an application developer, you find yourself building multilevel class hierarchies, it’s likely that one or more of the following applies:\n\nYou are reinventing the wheel. Go look for a framework or library that provides components you can reuse in your application.\n\nYou are using a badly designed framework. Go look for an alternative.\n\nYou are overengineering. Remember the KISS principle.\n\nYou became bored coding applications and decided to start a new framework. Congratulations and good luck!\n\nIt’s also possible that all of the above apply to your situation: you became bored and decided to reinvent the wheel by building your own overengineered and badly designed framework, which is forcing you to code class after class to solve trivial problems. Hopefully you are having fun, or at least getting paid for it.\n\nMisbehaving Built-Ins: Bug or Feature?\n\nThe built-in dict, list, and str types are essential building blocks of Python itself, so they must be fast—any performance issues in them would severely impact pretty much everything else. That’s why CPython adopted the shortcuts that cause its built- in methods to misbehave by not cooperating with methods overridden by subclasses. A possible way out of this dilemma would be to offer two implementations for each of those types: one “internal,” optimized for use by the interpreter, and an external, easily extensible one.\n\n15 Alan Kay, “The Early History of Smalltalk,” in SIGPLAN Not. 28, 3 (March 1993), 69–95. Also available\n\nonline. Thanks to my friend Christiano Anderson, who shared this reference as I was writing this chapter.\n\nFurther Reading\n\n|\n\n517",
      "content_length": 2436,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 548,
      "content": "But wait, this is what we have already: UserDict, UserList, and UserString are not as fast as the built-ins but are easily extensible. The pragmatic approach taken by CPython means we also get to use, in our own applications, the highly optimized implementations that are hard to subclass. Which makes sense, considering that it’s not so often that we need a custom mapping, list, or string, but we use dict, list, and str every day. We just need to be aware of the trade-offs involved.\n\nInheritance Across Languages\n\nAlan Kay coined the term “object-oriented,” and Smalltalk had only single inheri‐ tance, although there are forks with various forms of multiple inheritance support, including the modern Squeak and Pharo Smalltalk dialects that support traits—a lan‐ guage construct that fulfills the role of a mixin class, while avoiding some of the issues with multiple inheritance.\n\nThe first popular language to implement multiple inheritance was C++, and the fea‐ ture was abused enough that Java—intended as a C++ replacement—was designed without support for multiple inheritance of implementation (i.e., no mixin classes). That is, until Java 8 introduced default methods that make interfaces very similar to the abstract classes used to define interfaces in C++ and in Python. After Java, proba‐ bly the most widely deployed JVM language is Scala, and it implements traits.\n\nOther languages supporting traits are the latest stable versions of PHP and Groovy, as well as Rust and Raku—the language formerly known as Perl 6.16 So it’s fair to say that traits are trendy in 2021.\n\nRuby offers an original take on multiple inheritance: it does not support it, but intro‐ duces mixins as a language feature. A Ruby class can include a module in its body, so the methods defined in the module become part of the class implementation. This is a “pure” form of mixin, with no inheritance involved, and it’s clear that a Ruby mixin has no influence on the type of the class where it’s used. This provides the benefits of mixins, while avoiding many of its usual problems.\n\nTwo new object-oriented languages that are getting a lot of attention severely limit inheritance: Go and Julia. Both are about programming “objects,” and support polymorphism, but they avoid the term “class.”\n\nGo has no inheritance at all. Julia has a type hierarchy but subtypes cannot inherit structure, only behaviors, and only abstract types can be subtyped. In addition, Julia methods are implemented using multiple dispatch—a more advanced form of the mechanism we saw in “Single Dispatch Generic Functions” on page 324.\n\n16 My friend and technical reviewer Leonardo Rochael explains better than I could: “The continued existence, but persistent lack of arrival, of Perl 6 was draining willpower out of the evolution of Perl itself. Now Perl continues to be developed as a separate language (it’s up to version 5.34 as of now) with no shadow of depre‐ cation because of the language formerly known as Perl 6.”\n\n518\n\n|\n\nChapter 14: Inheritance: For Better or for Worse",
      "content_length": 3046,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 549,
      "content": "CHAPTER 15 More About Type Hints\n\nI learned a painful lesson that for small programs, dynamic typing is great. For large programs you need a more disciplined approach. And it helps if the language gives you that discipline rather than telling you “Well, you can do whatever you want”.\n\n—Guido van Rossum, a fan of Monty Python1\n\nThis chapter is a sequel to Chapter 8, covering more of Python’s gradual type system. The main topics are:\n\nOverloaded function signatures • typing.TypedDict for type hinting dicts used as records\n\nType casting\n\nRuntime access to type hints\n\nGeneric types\n\n— Declaring a generic class\n\n— Variance: invariant, covariant, and contravariant types\n\n— Generic static protocols\n\nWhat’s New in This Chapter This chapter is new in the second edition of Fluent Python. Let’s start with overloads.\n\n1 From YouTube video of “A Language Creators’ Conversation: Guido van Rossum, James Gosling, Larry Wall, and Anders Hejlsberg,” streamed live on April 2, 2019. Quote starts at 1:32:05, edited for brevity. Full tran‐ script available at https://github.com/fluentpython/language-creators.\n\n519",
      "content_length": 1109,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 550,
      "content": "Overloaded Signatures Python functions may accept different combinations of arguments. The @typ ing.overload decorator allows annotating those different combinations. This is par‐ ticularly important when the return type of the function depends on the type of two or more parameters.\n\nConsider the sum built-in function. This is the text of help(sum):\n\n>>> help(sum) sum(iterable, /, start=0) Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n\nWhen the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types.\n\nThe sum built-in is written in C, but typeshed has overloaded type hints for it, in builtins.pyi:\n\n@overload def sum(__iterable: Iterable[_T]) -> Union[_T, int]: ... @overload def sum(__iterable: Iterable[_T], start: _S) -> Union[_T, _S]: ...\n\nFirst let’s look at the overall syntax of overloads. That’s all the code about the sum you’ll find in the stub file (.pyi). The implementation would be in a different file. The ellipsis (...) has no function other than to fulfill the syntactic requirement for a function body, similar to pass. So .pyi files are valid Python files.\n\nAs mentioned in “Annotating Positional Only and Variadic Parameters” on page 295, the two leading underscores in __iterable are a PEP 484 convention for positional- only arguments that is enforced by Mypy. It means you can call sum(my_list), but not sum(__iterable = my_list).\n\nThe type checker tries to match the given arguments with each overloaded signature, in order. The call sum(range(100), 1000) doesn’t match the first overload, because that signature has only one parameter. But it matches the second.\n\nYou can also use @overload in a regular Python module, by writing the overloaded signatures right before the function’s actual signature and implementation. Example 15-1 shows how sum would appear annotated and implemented in a Python module.\n\nExample 15-1. mysum.py: definition of the sum function with overloaded signatures\n\nimport functools import operator from collections.abc import Iterable\n\n520\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 2151,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 551,
      "content": "from typing import overload, Union, TypeVar\n\nT = TypeVar('T') S = TypeVar('S')\n\n@overload def sum(it: Iterable[T]) -> Union[T, int]: ... @overload def sum(it: Iterable[T], /, start: S) -> Union[T, S]: ... def sum(it, /, start=0): return functools.reduce(operator.add, it, start)\n\nWe need this second TypeVar in the second overload.\n\nThis signature is for the simple case: sum(my_iterable). The result type may be T —the type of the elements that my_iterable yields—or it may be int if the itera‐ ble is empty, because the default value of the start parameter is 0.\n\nWhen start is given, it can be of any type S, so the result type is Union[T, S]. This is why we need S. If we reused T, then the type of start would have to be the same type as the elements of Iterable[T].\n\nThe signature of the actual function implementation has no type hints.\n\nThat’s a lot of lines to annotate a one-line function. Probably overkill, I know. At least it wasn’t a foo function.\n\nIf you want to learn about @overload by reading code, typeshed has hundreds of examples. On typeshed, the stub file for Python’s built-ins has 186 overloads as I write this—more than any other in the standard library.\n\nTake Advantage of Gradual Typing\n\nAiming for 100% of annotated code may lead to type hints that add lots of noise but little value. Refactoring to simplify type hinting can lead to cumbersome APIs. Sometimes it’s better to be prag‐ matic and leave a piece of code without type hints.\n\nThe handy APIs we call Pythonic are often hard to annotate. In the next section we’ll see an example: six overloads are needed to properly annotate the flexible max built-in function.\n\nMax Overload It is difficult to add type hints to functions that leverage the powerful dynamic fea‐ tures of Python.\n\nOverloaded Signatures\n\n|\n\n521",
      "content_length": 1799,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 552,
      "content": "While studying typeshed, I found bug report #4051: Mypy failed to warn that it is ille‐ gal to pass None as one of the arguments to the built-in max() function, or to pass an iterable that at some point yields None. In either case, you get a runtime exception like this one:\n\nTypeError: '>' not supported between instances of 'int' and 'NoneType'\n\nThe documentation of max starts with this sentence:\n\nReturn the largest item in an iterable or the largest of two or more arguments.\n\nTo me, that’s a very intuitive description.\n\nBut if I must annotate a function described in those terms, I have to ask: which is it? An iterable or two or more arguments?\n\nThe reality is more complicated because max also takes two optional keyword argu‐ ments: key and default.\n\nI coded max in Python to make it easier to see the relationship between how it works and the overloaded annotations (the built-in max is in C); see Example 15-2.\n\nExample 15-2. mymax.py: Python rewrite of max function\n\n# imports and definitions omitted, see next listing\n\nMISSING = object() EMPTY_MSG = 'max() arg is an empty sequence'\n\n# overloaded type hints omitted, see next listing\n\ndef max(first, *args, key=None, default=MISSING): if args: series = args candidate = first else: series = iter(first) try: candidate = next(series) except StopIteration: if default is not MISSING: return default raise ValueError(EMPTY_MSG) from None if key is None: for current in series: if candidate < current: candidate = current else: candidate_key = key(candidate) for current in series: current_key = key(current)\n\n522\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1611,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 553,
      "content": "if candidate_key < current_key: candidate = current candidate_key = current_key return candidate\n\nThe focus of this example is not the logic of max, so I will not spend time with its implementation, other than explaining MISSING. The MISSING constant is a unique object instance used as a sentinel. It is the default value for the default= keyword argument, so that max can accept default=None and still distinguish between these two situations:\n\n1. The user did not provide a value for default=, so it is MISSING, and max raises ValueError if first is an empty iterable.\n\n2. The user provided some value for default=, including None, so max returns that value if first is an empty iterable.\n\nTo fix issue #4051, I wrote the code in Example 15-3.2\n\nExample 15-3. mymax.py: top of the module, with imports, definitions, and overloads\n\nfrom collections.abc import Callable, Iterable from typing import Protocol, Any, TypeVar, overload, Union\n\nclass SupportsLessThan(Protocol): def __lt__(self, other: Any) -> bool: ...\n\nT = TypeVar('T') LT = TypeVar('LT', bound=SupportsLessThan) DT = TypeVar('DT')\n\nMISSING = object() EMPTY_MSG = 'max() arg is an empty sequence'\n\n@overload def max(__arg1: LT, __arg2: LT, *args: LT, key: None = ...) -> LT: ... @overload def max(__arg1: T, __arg2: T, *args: T, key: Callable[[T], LT]) -> T: ... @overload def max(__iterable: Iterable[LT], *, key: None = ...) -> LT: ... @overload def max(__iterable: Iterable[T], *, key: Callable[[T], LT]) -> T:\n\n2 I am grateful to Jelle Zijlstra—a typeshed maintainer—who taught me several things, including how to reduce\n\nmy original nine overloads to six.\n\nOverloaded Signatures\n\n|\n\n523",
      "content_length": 1656,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 554,
      "content": "... @overload def max(__iterable: Iterable[LT], *, key: None = ..., default: DT) -> Union[LT, DT]: ... @overload def max(__iterable: Iterable[T], *, key: Callable[[T], LT], default: DT) -> Union[T, DT]: ...\n\nMy Python implementation of max is about the same length as all those typing imports and declarations. Thanks to duck typing, my code has no isinstance checks, and provides the same error checking as those type hints—but only at run‐ time, of course.\n\nA key benefit of @overload is declaring the return type as precisely as possible, according to the types of the arguments given. We’ll see that benefit next by studying the overloads for max in groups of one or two at a time.\n\nArguments implementing SupportsLessThan, but key and default not provided\n\n@overload def max(__arg1: LT, __arg2: LT, *_args: LT, key: None = ...) -> LT: ... # ... lines omitted ... @overload def max(__iterable: Iterable[LT], *, key: None = ...) -> LT: ...\n\nIn these cases, the inputs are either separate arguments of type LT implementing SupportsLessThan, or an Iterable of such items. The return type of max is the same as the actual arguments or items, as we saw in “Bounded TypeVar” on page 284.\n\nSample calls that match these overloads:\n\nmax(1, 2, -3) # returns 2 max(['Go', 'Python', 'Rust']) # returns 'Rust'\n\nArgument key provided, but no default\n\n@overload def max(__arg1: T, __arg2: T, *_args: T, key: Callable[[T], LT]) -> T: ... # ... lines omitted ... @overload def max(__iterable: Iterable[T], *, key: Callable[[T], LT]) -> T: ...\n\nThe inputs can be separate items of any type T or a single Iterable[T], and key= must be a callable that takes an argument of the same type T, and returns a value that\n\n524\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1742,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 555,
      "content": "implements SupportsLessThan. The return type of max is the same as the actual argu‐ ments.\n\nSample calls that match these overloads:\n\nmax(1, 2, -3, key=abs) # returns -3 max(['Go', 'Python', 'Rust'], key=len) # returns 'Python'\n\nArgument default provided, but no key\n\n@overload def max(__iterable: Iterable[LT], *, key: None = ..., default: DT) -> Union[LT, DT]: ...\n\nThe input is an iterable of items of type LT implementing SupportsLessThan. The default= argument is the return value when the Iterable is empty. Therefore the return type of max must be a Union of type LT and the type of the default argument.\n\nSample calls that match these overloads:\n\nmax([1, 2, -3], default=0) # returns 2 max([], default=None) # returns None\n\nArguments key and default provided\n\n@overload def max(__iterable: Iterable[T], *, key: Callable[[T], LT], default: DT) -> Union[T, DT]: ...\n\nThe inputs are:\n\nAn Iterable of items of any type T • Callable that takes an argument of type T and returns a value of type LT that implements SupportsLessThan\n\nA default value of any type DT\n\nThe return type of max must be a Union of type T or the type of the default argument:\n\nmax([1, 2, -3], key=abs, default=None) # returns -3 max([], key=abs, default=None) # returns None\n\nTakeaways from Overloading max Type hints allow Mypy to flag a call like max([None, None]) with this error message:\n\nmymax_demo.py:109: error: Value of type variable \"_LT\" of \"max\" cannot be \"None\"\n\nOverloaded Signatures\n\n|\n\n525",
      "content_length": 1480,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 556,
      "content": "On the other hand, having to write so many lines to support the type checker may discourage people from writing convenient and flexible functions like max. If I had to reinvent the min function as well, I could refactor and reuse most of the implementa‐ tion of max. But I’d have to copy and paste all overloaded declarations—even though they would be identical for min, except for the function name.\n\nMy friend João S. O. Bueno—one of the smartest Python devs I know—tweeted this:\n\nAlthough it is this hard to express the signature of max—it fits in one’s mind quite easily. My understanding is that the expressiveness of annotation markings is very limited, compared to that of Python.\n\nNow let’s study the TypedDict typing construct. It is not as useful as I imagined at first, but has its uses. Experimenting with TypedDict demonstrates the limitations of static typing for handling dynamic structures, such as JSON data.\n\nTypedDict\n\nIt’s tempting to use TypedDict to protect against errors while han‐ dling dynamic data structures like JSON API responses. But the examples here make clear that correct handling of JSON must be done at runtime, and not with static type checking. For runtime checking of JSON-like structures using type hints, check out the pydantic package on PyPI.\n\nPython dictionaries are sometimes used as records, with the keys used as field names and field values of different types.\n\nFor example, consider a record describing a book in JSON or Python:\n\n{\"isbn\": \"0134757599\", \"title\": \"Refactoring, 2e\", \"authors\": [\"Martin Fowler\", \"Kent Beck\"], \"pagecount\": 478}\n\nBefore Python 3.8, there was no good way to annotate a record like that, because the mapping types we saw in “Generic Mappings” on page 276 limit all values to have the same type.\n\nHere are two lame attempts to annotate a record like the preceding JSON object:\n\nDict[str, Any]\n\nThe values may be of any type.\n\n526\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1944,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 557,
      "content": "Dict[str, Union[str, int, List[str]]]\n\nHard to read, and doesn’t preserve the relationship between field names and their respective field types: title is supposed to be a str, it can’t be an int or a List[str].\n\nPEP 589—TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys addressed that problem. Example 15-4 shows a simple TypedDict.\n\nExample 15-4. books.py: the BookDict definition\n\nfrom typing import TypedDict\n\nclass BookDict(TypedDict): isbn: str title: str authors: list[str] pagecount: int\n\nAt first glance, typing.TypedDict may seem like a data class builder, similar to typing.NamedTuple—covered in Chapter 5.\n\nThe syntactic similarity is misleading. TypedDict is very different. It exists only for the benefit of type checkers, and has no runtime effect.\n\nTypedDict provides two things:\n\nClass-like syntax to annotate a dict with type hints for the value of each “field.” • A constructor that tells the type checker to expect a dict with the keys and values as specified.\n\nAt runtime, a TypedDict constructor such as BookDict is a placebo: it has the same effect as calling the dict constructor with the same arguments.\n\nThe fact that BookDict creates a plain dict also means that:\n\nThe “fields” in the pseudoclass definition don’t create instance attributes.\n\nYou can’t write initializers with default values for the “fields.”\n\nMethod definitions are not allowed.\n\nLet’s explore the behavior of a BookDict at runtime (Example 15-5).\n\nExample 15-5. Using a BookDict, but not quite as intended\n\n>>> from books import BookDict >>> pp = BookDict(title='Programming Pearls', ... authors='Jon Bentley',\n\nTypedDict\n\n|\n\n527",
      "content_length": 1638,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 558,
      "content": "... isbn='0201657880', ... pagecount=256) >>> pp {'title': 'Programming Pearls', 'authors': 'Jon Bentley', 'isbn': '0201657880', 'pagecount': 256} >>> type(pp) <class 'dict'> >>> pp.title Traceback (most recent call last): File \"<stdin>\", line 1, in <module> AttributeError: 'dict' object has no attribute 'title' >>> pp['title'] 'Programming Pearls' >>> BookDict.__annotations__ {'isbn': <class 'str'>, 'title': <class 'str'>, 'authors': typing.List[str], 'pagecount': <class 'int'>}\n\nYou can call BookDict like a dict constructor with keyword arguments, or pass‐ ing a dict argument—including a dict literal.\n\nOops…I forgot authors takes a list. But gradual typing means no type checking at runtime.\n\nThe result of calling BookDict is a plain dict…\n\n…therefore you can’t read the data using object.field notation.\n\nThe type hints are in BookDict.__annotations__, and not in pp.\n\nWithout a type checker, TypedDict is as useful as comments: it may help people read the code, but that’s it. In contrast, the class builders from Chapter 5 are useful even if you don’t use a type checker, because at runtime they generate or enhance a custom class that you can instantiate. They also provide several useful methods or functions listed in Table 5-1.\n\nExample 15-6 builds a valid BookDict and tries some operations on it. This shows how TypedDict enables Mypy to catch errors, shown in Example 15-7.\n\nExample 15-6. demo_books.py: legal and illegal operations on a BookDict\n\nfrom books import BookDict from typing import TYPE_CHECKING\n\ndef demo() -> None: book = BookDict( isbn='0134757599', title='Refactoring, 2e', authors=['Martin Fowler', 'Kent Beck'],\n\n528\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1693,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 559,
      "content": "pagecount=478 ) authors = book['authors'] if TYPE_CHECKING: reveal_type(authors) authors = 'Bob' book['weight'] = 4.2 del book['title']\n\nif __name__ == '__main__': demo()\n\nRemember to add a return type, so that Mypy doesn’t ignore the function.\n\nThis is a valid BookDict: all the keys are present, with values of the correct types.\n\nMypy will infer the type of authors from the annotation for the 'authors' key in BookDict.\n\ntyping.TYPE_CHECKING is only True when the program is being type checked. At runtime, it’s always false.\n\nThe previous if statement prevents reveal_type(authors) from being called at runtime. reveal_type is not a runtime Python function, but a debugging facility provided by Mypy. That’s why there is no import for it. See its output in Example 15-7.\n\nThe last three lines of the demo function are illegal. They will cause error mes‐ sages in Example 15-7.\n\nType checking demo_books.py from Example 15-6, we get Example 15-7.\n\nExample 15-7. Type checking demo_books.py\n\n…/typeddict/ $ mypy demo_books.py demo_books.py:13: note: Revealed type is 'built-ins.list[built-ins.str]' demo_books.py:14: error: Incompatible types in assignment (expression has type \"str\", variable has type \"List[str]\") demo_books.py:15: error: TypedDict \"BookDict\" has no key 'weight' demo_books.py:16: error: Key 'title' of TypedDict \"BookDict\" cannot be deleted Found 3 errors in 1 file (checked 1 source file)\n\nTypedDict\n\n|\n\n529",
      "content_length": 1431,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 560,
      "content": "This note is the result of reveal_type(authors).\n\nThe type of the authors variable was inferred from the type of the book['au thors'] expression that initialized it. You can’t assign a str to a variable of type List[str]. Type checkers usually don’t allow the type of a variable to change.3\n\nCannot assign to a key that is not part of the BookDict definition.\n\nCannot delete a key that is part of the BookDict definition.\n\nNow let’s see BookDict used in function signatures, to type check function calls.\n\nImagine you need to generate XML from book records, similar to this:\n\n<BOOK> <ISBN>0134757599</ISBN> <TITLE>Refactoring, 2e</TITLE> <AUTHOR>Martin Fowler</AUTHOR> <AUTHOR>Kent Beck</AUTHOR> <PAGECOUNT>478</PAGECOUNT> </BOOK>\n\nIf you were writing MicroPython code to be embedded in a tiny microcontroller, you might write a function like what’s shown in Example 15-8.4\n\nExample 15-8. books.py: to_xml function\n\nAUTHOR_ELEMENT = '<AUTHOR>{}</AUTHOR>'\n\ndef to_xml(book: BookDict) -> str: elements: list[str] = [] for key, value in book.items(): if isinstance(value, list): elements.extend( AUTHOR_ELEMENT.format(n) for n in value) else: tag = key.upper() elements.append(f'<{tag}>{value}</{tag}>') xml = '\\n\\t'.join(elements) return f'<BOOK>\\n\\t{xml}\\n</BOOK>'\n\n3 As of May 2020, pytype allows it. But its FAQ says it will be disallowed in the future. See the question, “Why\n\ndidn’t pytype catch that I changed the type of an annotated variable?” in the pytype FAQ.\n\n4 I prefer to use the lxml package to generate and parse XML: it’s easy to get started, full-featured, and fast.\n\nUnfortunately, lxml and Python’s own ElementTree don’t fit the limited RAM of my hypothetical microcon‐ troller.\n\n530\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1739,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 561,
      "content": "The whole point of the example: using BookDict in the function signature.\n\nIt’s often necessary to annotate collections that start empty, otherwise Mypy can’t infer the type of the elements.5\n\nMypy understands isinstance checks, and treats value as a list in this block.\n\nWhen I used key == 'authors' as the condition for the if guarding this block, Mypy found an error in this line: \"object\" has no attribute \"__iter__\", because it inferred the type of value returned from book.items() as object, which doesn’t support the __iter__ method required by the generator expres‐ sion. With the isinstance check, this works because Mypy knows that value is a list in this block.\n\nExample 15-9 shows a function that parses a JSON str and returns a BookDict.\n\nExample 15-9. books_any.py: from_json function\n\ndef from_json(data: str) -> BookDict: whatever = json.loads(data) return whatever\n\nThe return type of json.loads() is Any.6\n\nI can return whatever—of type Any—because Any is consistent-with every type, including the declared return type, BookDict.\n\nThe second point of Example 15-9 is very important to keep in mind: Mypy will not flag any problem in this code, but at runtime the value in whatever may not conform to the BookDict structure—in fact, it may not be a dict at all!\n\nIf you run Mypy with --disallow-any-expr, it will complain about the two lines in the body of from_json:\n\n…/typeddict/ $ mypy books_any.py --disallow-any-expr books_any.py:30: error: Expression has type \"Any\" books_any.py:31: error: Expression has type \"Any\" Found 2 errors in 1 file (checked 1 source file)\n\n5 The Mypy documentation discusses this in its “Common issues and solutions” page, in the section, “Types of\n\nempty collections”.\n\n6 Brett Cannon, Guido van Rossum, and others have been discussing how to type hint json.loads() since\n\n2016 in Mypy issue #182: Define a JSON type.\n\nTypedDict\n\n|\n\n531",
      "content_length": 1886,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 562,
      "content": "Lines 30 and 31 mentioned in the previous snippet are the body of the from_json function. We can silence the type error by adding a type hint to the initialization of the whatever variable, as in Example 15-10.\n\nExample 15-10. books.py: from_json function with variable annotation\n\ndef from_json(data: str) -> BookDict: whatever: BookDict = json.loads(data) return whatever\n\n--disallow-any-expr does not cause errors when an expression of type Any is immediately assigned to a variable with a type hint.\n\nNow whatever is of type BookDict, the declared return type.\n\nDon’t be lulled into a false sense of type safety by Example 15-10! Looking at the code at rest, the type checker cannot predict that json.loads() will return anything that resembles a BookDict. Only runtime validation can guarantee that.\n\nStatic type checking is unable to prevent errors with code that is inherently dynamic, such as json.loads(), which builds Python objects of different types at runtime, as Examples 15-11, 15-12, and 15-13 demonstrate.\n\nExample 15-11. demo_not_book.py: from_json returns an invalid BookDict, and to_xml accepts it\n\nfrom books import to_xml, from_json from typing import TYPE_CHECKING\n\ndef demo() -> None: NOT_BOOK_JSON = \"\"\" {\"title\": \"Andromeda Strain\", \"flavor\": \"pistachio\", \"authors\": true} \"\"\" not_book = from_json(NOT_BOOK_JSON) if TYPE_CHECKING: reveal_type(not_book) reveal_type(not_book['authors'])\n\nprint(not_book) print(not_book['flavor'])\n\nxml = to_xml(not_book) print(xml)\n\n532\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1532,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 563,
      "content": "if __name__ == '__main__': demo()\n\nThis line does not produce a valid BookDict—see the content of NOT_BOOK_JSON.\n\nLet’s have Mypy reveal a couple of types.\n\nThis should not be a problem: print can handle object and every other type.\n\nBookDict has no 'flavor' key, but the JSON source does…what will happen?\n\nRemember the signature: def to_xml(book: BookDict) -> str:.\n\nWhat will the XML output look like?\n\nNow we check demo_not_book.py with Mypy (Example 15-12).\n\nExample 15-12. Mypy report for demo_not_book.py, reformatted for clarity\n\n…/typeddict/ $ mypy demo_not_book.py demo_not_book.py:12: note: Revealed type is 'TypedDict('books.BookDict', {'isbn': built-ins.str, 'title': built-ins.str, 'authors': built-ins.list[built-ins.str], 'pagecount': built-ins.int})' demo_not_book.py:13: note: Revealed type is 'built-ins.list[built-ins.str]' demo_not_book.py:16: error: TypedDict \"BookDict\" has no key 'flavor' Found 1 error in 1 file (checked 1 source file)\n\nThe revealed type is the nominal type, not the runtime content of not_book.\n\nAgain, this is the nominal type of not_book['authors'], as defined in BookDict. Not the runtime type.\n\nThis error is for line print(not_book['flavor']): that key does not exist in the nominal type.\n\nNow let’s run demo_not_book.py, showing the output in Example 15-13.\n\nExample 15-13. Output of running demo_not_book.py\n\n…/typeddict/ $ python3 demo_not_book.py {'title': 'Andromeda Strain', 'flavor': 'pistachio', 'authors': True} pistachio <BOOK>\n\nTypedDict\n\n|\n\n533",
      "content_length": 1504,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 564,
      "content": "<TITLE>Andromeda Strain</TITLE> <FLAVOR>pistachio</FLAVOR> <AUTHORS>True</AUTHORS> </BOOK>\n\nThis is not really a BookDict.\n\nThe value of not_book['flavor'].\n\nto_xml takes a BookDict argument, but there is no runtime checking: garbage in, garbage out.\n\nExample 15-13 shows that demo_not_book.py outputs nonsense, but has no runtime errors. Using a TypedDict while handling JSON data did not provide much type safety.\n\nIf you look at the code for to_xml in Example 15-8 through the lens of duck typing, the argument book must provide an .items() method that returns an iterable of tuples like (key, value) where:\n\nkey must have an .upper() method • value can be anything\n\nThe point of this demonstration: when handling data with a dynamic structure, such as JSON or XML, TypedDict is absolutely not a replacement for data validation at runtime. For that, use pydantic.\n\nTypedDict has more features, including support for optional keys, a limited form of inheritance, and an alternative declaration syntax. If you want to know more about it, please review PEP 589—TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys.\n\nNow let’s turn our attention to a function that is best avoided, but sometimes is unavoidable: typing.cast.\n\nType Casting No type system is perfect, and neither are the static type checkers, the type hints in the typeshed project, or the type hints in the third-party packages that have them.\n\nThe typing.cast() special function provides one way to handle type checking mal‐ functions or incorrect type hints in code we can’t fix. The Mypy 0.930 documentation explains:\n\nCasts are used to silence spurious type checker warnings and give the type checker a little help when it can’t quite understand what is going on.\n\n534\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1786,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 565,
      "content": "At runtime, typing.cast does absolutely nothing. This is its implementation:\n\ndef cast(typ, val): \"\"\"Cast a value to a type. This returns the value unchanged. To the type checker this signals that the return value has the designated type, but at runtime we intentionally don't check anything (we want this to be as fast as possible). \"\"\" return val\n\nPEP 484 requires type checkers to “blindly believe” the type stated in the cast. The “Casts” section of PEP 484 gives an example where the type checker needs the guid‐ ance of cast:\n\nfrom typing import cast\n\ndef find_first_str(a: list[object]) -> str: index = next(i for i, x in enumerate(a) if isinstance(x, str)) # We only get here if there's at least one string return cast(str, a[index])\n\nThe next() call on the generator expression will either return the index of a str item or raise StopIteration. Therefore, find_first_str will always return a str if no exception is raised, and str is the declared return type.\n\nBut if the last line were just return a[index], Mypy would infer the return type as object because the a argument is declared as list[object]. So the cast() is required to guide Mypy.7\n\nHere is another example with cast, this time to correct an outdated type hint for Python’s standard library. In Example 21-12, I create an asyncio Server object and I want to get the address the server is listening to. I coded this line:\n\naddr = server.sockets[0].getsockname()\n\nBut Mypy reported this error:\n\nValue of type \"Optional[List[socket]]\" is not indexable\n\nThe type hint for Server.sockets on typeshed in May 2021 is valid for Python 3.6, where the sockets attribute could be None. But in Python 3.7, sockets became a property with a getter that always returns a list—which may be empty if the server has no sockets. And since Python 3.8, the getter returns a tuple (used as an immuta‐ ble sequence).\n\n7 The use of enumerate in the example is intended to confuse the type checker. A simpler implementation\n\nyielding strings directly instead of going through the enumerate index is correctly analyzed by Mypy, and the cast() is not needed.\n\nType Casting\n\n|\n\n535",
      "content_length": 2126,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 566,
      "content": "Since I can’t fix typeshed right now,8 I added a cast, like this:\n\nfrom asyncio.trsock import TransportSocket from typing import cast\n\n# ... many lines omitted ...\n\nsocket_list = cast(tuple[TransportSocket, ...], server.sockets) addr = socket_list[0].getsockname()\n\nUsing cast in this case required a couple of hours to understand the problem and read asyncio source code to find the correct type of the sockets: the TransportSocket class from the undocumented asyncio.trsock module. I also had to add two import statements and another line of code for readability.9 But the code is safer.\n\nThe careful reader may note that sockets[0] could raise IndexError if sockets is empty. However, as far as I understand asyncio, that cannot happen in Example 21-12 because the server is ready to accept connections by the time I read its sockets attribute, therefore it will not be empty. Anyway, IndexError is a runtime error. Mypy can’t spot the problem even in a trivial case like print([][0]).\n\nDon’t get too comfortable using cast to silence Mypy, because Mypy is usually right when it reports an error. If you are using cast very often, that’s a code smell. Your team may be misusing type hints, or you may have low-quality dependencies in your codebase.\n\nDespite the downsides, there are valid uses for cast. Here is something Guido van Rossum wrote about it:\n\nWhat’s wrong with the occasional cast() call or # type: ignore comment?10\n\n8 I reported typeshed issue #5535, “Wrong type hint for asyncio.base_events.Server sockets attribute.” and it was quickly fixed by Sebastian Rittau. However, I decided to keep the example because it illustrates a com‐ mon use case for cast, and the cast I wrote is harmless.\n\n9 To be honest, I originally appended a # type: ignore comment to the line with server.sockets[0] because after a little research I found similar lines the asyncio documentation and in a test case, so I suspected the problem was not in my code.\n\n10 19 May 2020 message to the typing-sig mailing list.\n\n536\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 2053,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 567,
      "content": "It is unwise to completely ban the use of cast, especially because the other work‐ arounds are worse:\n\n# type: ignore is less informative.11 • Using Any is contagious: since Any is consistent-with all types, abusing it may pro‐ duce cascading effects through type inference, undermining the type checker’s ability to detect errors in other parts of the code.\n\nOf course, not all typing mishaps can be fixed with cast. Sometimes we need # type: ignore, the occasional Any, or even leaving a function without type hints.\n\nNext, let’s talk about using annotations at runtime.\n\nReading Type Hints at Runtime At import time, Python reads the type hints in functions, classes, and modules, and stores them in attributes named __annotations__. For instance, consider the clip function in Example 15-14.12\n\nExample 15-14. clipannot.py: annotated signature of a clip function\n\ndef clip(text: str, max_len: int = 80) -> str:\n\nThe type hints are stored as a dict in the __annotations__ attribute of the function:\n\n>>> from clip_annot import clip >>> clip.__annotations__ {'text': <class 'str'>, 'max_len': <class 'int'>, 'return': <class 'str'>}\n\nThe 'return' key maps to the return type hint after the -> symbol in Example 15-14.\n\nNote that the annotations are evaluated by the interpreter at import time, just as parameter default values are also evaluated. That’s why the values in the annotations are the Python classes str and int, and not the strings 'str' and 'int'. The import time evaluation of annotations is the standard as of Python 3.10, but that may change if PEP 563 or PEP 649 become the standard behavior.\n\n11 The syntax # type: ignore[code] allows you to specify which Mypy error code is being silenced, but the\n\ncodes are not always easy to interpret. See “Error codes” in the Mypy documentation.\n\n12 I will not go into the implementation of clip, but you can read the whole module in clip_annot.py if you’re\n\ncurious.\n\nReading Type Hints at Runtime\n\n|\n\n537",
      "content_length": 1965,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 568,
      "content": "Problems with Annotations at Runtime The increased use of type hints raised two problems:\n\nImporting modules uses more CPU and memory when many type hints are used.\n\nReferring to types not yet defined requires using strings instead of actual types.\n\nBoth issues are relevant. The first is because of what we just saw: annotations are evaluated by the interpreter at import time and stored in the __annotations__ attribute. Let’s focus now on the second issue.\n\nStoring annotations as strings is sometimes required because of the “forward refer‐ ence” problem: when a type hint needs to refer to a class defined below in the same module. However, a common manifestation of the problem in source code doesn’t look like a forward reference at all: that’s when a method returns a new object of the same class. Since the class object is not defined until Python completely evaluates the class body, type hints must use the name of the class as a string. Here is an example:\n\nclass Rectangle: # ... lines omitted ... def stretch(self, factor: float) -> 'Rectangle': return Rectangle(width=self.width * factor)\n\nWriting forward referencing type hints as strings is the standard and required prac‐ tice as of Python 3.10. Static type checkers were designed to deal with that issue from the beginning.\n\nBut at runtime, if you write code to read the return annotation for stretch, you will get a string 'Rectangle' instead of a reference to the actual type, the Rectangle class. Now your code needs to figure out what that string means.\n\nThe typing module includes three functions and a class categorized as Introspection helpers, the most important being typing.get_type_hints. Part of its documenta‐ tion states:\n\nget_type_hints(obj, globals=None, locals=None, include_extras=False)\n\n[…] This is often the same as obj.__annotations__. In addition, forward refer‐ ences encoded as string literals are handled by evaluating them in globals and locals namespaces. […]\n\nSince Python 3.10, the new inspect.get_annotations(…) func‐ tion should be used instead of typing.get_type_hints. However, some readers may not be using Python 3.10 yet, so in the examples I’ll use typing.get_type_hints, which is available since the typ ing module was added in Python 3.5.\n\n538\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 2290,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 569,
      "content": "PEP 563—Postponed Evaluation of Annotations was approved to make it unneces‐ sary to write annotations as strings, and to reduce the runtime costs of type hints. Its main idea is described in these two sentences of the “Abstract”:\n\nThis PEP proposes changing function annotations and variable annotations so that they are no longer evaluated at function definition time. Instead, they are preserved in annotations in string form.\n\nBeginning with Python 3.7, that’s how annotations are handled in any module that starts with this import statement:\n\nfrom __future__ import annotations\n\nTo demonstrate its effect, I put a copy of the same clip function from Example 15-14 in a clip_annot_post.py module with that __future__ import line at the top.\n\nAt the console, here’s what I get when I import that module and read the annotations from clip:\n\n>>> from clip_annot_post import clip >>> clip.__annotations__ {'text': 'str', 'max_len': 'int', 'return': 'str'}\n\nAs you can see, all the type hints are now plain strings, despite the fact they are not written as quoted strings in the definition of clip (Example 15-14).\n\nThe typing.get_type_hints function is able to resolve many type hints, including those in clip:\n\n>>> from clip_annot_post import clip >>> from typing import get_type_hints >>> get_type_hints(clip) {'text': <class 'str'>, 'max_len': <class 'int'>, 'return': <class 'str'>}\n\nCalling get_type_hints gives us the real types—even in some cases where the origi‐ nal type hint is written as a quoted string. That’s the recommended way to read type hints at runtime.\n\nThe PEP 563 behavior was scheduled to become default in Python 3.10, with no __future__ import needed. However, the maintainers of FastAPI and pydantic raised the alarm that the change would break their code which relies on type hints at run‐ time, and cannot use get_type_hints reliably.\n\nIn the ensuing discussion on the python-dev mailing list, Łukasz Langa—the author of PEP 563—described some limitations of that function:\n\n[…] it turned out that typing.get_type_hints() has limits that make its use in gen‐ eral costly at runtime, and more importantly insufficient to resolve all types. The most common example deals with non-global context in which types are generated (e.g., inner classes, classes within functions, etc.). But one of the crown examples of forward references: classes with methods accepting or returning objects of their own type, also\n\nReading Type Hints at Runtime\n\n|\n\n539",
      "content_length": 2473,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 570,
      "content": "isn’t properly handled by typing.get_type_hints() if a class generator is used. There’s some trickery we can do to connect the dots but in general it’s not great.13\n\nPython’s Steering Council decided to postpone making PEP 563 the default behavior until Python 3.11 or later, giving more time to developers to come up with a solution that addresses the issues PEP 563 tried to solve, without breaking widespread uses of type hints at runtime. PEP 649—Deferred Evaluation Of Annotations Using Descrip‐ tors is under consideration as a possible solution, but a different compromise may be reached.\n\nTo summarize: reading type hints at runtime is not 100% reliable as of Python 3.10 and is likely to change in 2022.\n\nCompanies using Python at a very large scale want the benefits of static typing, but they don’t want to pay the price for the evaluation of the type hints at import time. Static checking happens at devel‐ oper workstations and dedicated CI servers, but loading modules happens at a much higher frequency and volume in the production containers, and this cost is not negligible at scale.\n\nThis creates tension in the Python community between those who want type hints to be stored as strings only—to reduce the loading costs—versus those who also want to use type hints at runtime, like the creators and users of pydantic and FastAPI, who would rather have type objects stored instead of having to evaluate those annota‐ tions, a challenging task.\n\nDealing with the Problem Given the unstable situation at present, if you need to read annotations at runtime, I recommend:\n\nAvoid reading __annotations__ directly; instead, use inspect.get_annota tions (from Python 3.10) or typing.get_type_hints (since Python 3.5).\n\nWrite a custom function of your own as a thin wrapper around in spect .get_annotations or typing.get_type_hints, and have the rest of your code‐ base call that custom function, so that future changes are localized to a single function.\n\nTo demonstrate the second point, here are the first lines of the Checked class defined in Example 24-5, which we’ll study in Chapter 24:\n\n13 Message “PEP 563 in light of PEP 649”, posted April 16, 2021.\n\n540\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 2211,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 571,
      "content": "class Checked: @classmethod def _fields(cls) -> dict[str, type]: return get_type_hints(cls) # ... more lines ...\n\nThe Checked._fields class method protects other parts of the module from depend‐ ing directly on typing.get_type_hints. If get_type_hints changes in the future, requiring additional logic, or you want to replace it with inspect.get_annotations, the change is limited to Checked._fields and does not affect the rest of your program.\n\nGiven the ongoing discussions and proposed changes for runtime inspection of type hints, the official “Annotations Best Practices” document is required reading, and is likely to be updated on the road to Python 3.11. That how-to was written by Larry Hastings, the author of PEP 649—Deferred Evaluation Of Annotations Using Descriptors, an alternative proposal to address the runtime issues raised by PEP 563—Postponed Evaluation of Annotations.\n\nThe remaining sections of this chapter cover generics, starting with how to define a generic class that can be parameterized by its users.\n\nImplementing a Generic Class In Example 13-7 we defined the Tombola ABC: an interface for classes that work like a bingo cage. The LottoBlower class from Example 13-10 is a concrete implementa‐ tion. Now we’ll study a generic version of LottoBlower used like in Example 15-15.\n\nExample 15-15. generic_lotto_demo.py: using a generic lottery blower class\n\nfrom generic_lotto import LottoBlower\n\nmachine = LottoBlower[int](range(1, 11))\n\nfirst = machine.pick() remain = machine.inspect()\n\nTo instantiate a generic class, we give it an actual type parameter, like int here.\n\nMypy will correctly infer that first is an int…\n\n… and that remain is a tuple of integers.\n\nImplementing a Generic Class\n\n|\n\n541",
      "content_length": 1732,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 572,
      "content": "In addition, Mypy reports violations of the parameterized type with helpful messages, such as what’s shown in Example 15-16.\n\nExample 15-16. generic_lotto_errors.py: errors reported by Mypy\n\nfrom generic_lotto import LottoBlower\n\nmachine = LottoBlower[int]([1, .2]) ## error: List item 1 has incompatible type \"float\"; ## expected \"int\"\n\nmachine = LottoBlower[int](range(1, 11))\n\nmachine.load('ABC') ## error: Argument 1 to \"load\" of \"LottoBlower\" ## has incompatible type \"str\"; ## expected \"Iterable[int]\" ## note: Following member(s) of \"str\" have conflicts: ## note: Expected: ## note: def __iter__(self) -> Iterator[int] ## note: Got: ## note: def __iter__(self) -> Iterator[str]\n\nUpon instantiation of LottoBlower[int], Mypy flags the float.\n\nWhen calling .load('ABC'), Mypy explains why a str won’t do: str.__iter__ returns an Iterator[str], but LottoBlower[int] requires an Iterator[int].\n\nExample 15-17 is the implementation.\n\nExample 15-17. generic_lotto.py: a generic lottery blower class\n\nimport random\n\nfrom collections.abc import Iterable from typing import TypeVar, Generic\n\nfrom tombola import Tombola\n\nT = TypeVar('T')\n\nclass LottoBlower(Tombola, Generic[T]):\n\ndef __init__(self, items: Iterable[T]) -> None: self._balls = list[T](items)\n\ndef load(self, items: Iterable[T]) -> None: self._balls.extend(items)\n\n542\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1368,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 573,
      "content": "def pick(self) -> T: try: position = random.randrange(len(self._balls)) except ValueError: raise LookupError('pick from empty LottoBlower') return self._balls.pop(position)\n\ndef loaded(self) -> bool: return bool(self._balls)\n\ndef inspect(self) -> tuple[T, ...]: return tuple(self._balls)\n\nGeneric class declarations often use multiple inheritance, because we need to subclass Generic to declare the formal type parameters—in this case, T.\n\nThe items argument in __init__ is of type Iterable[T], which becomes Itera ble[int] when an instance is declared as LottoBlower[int].\n\nThe load method is likewise constrained.\n\nThe return type of T now becomes int in a LottoBlower[int].\n\nNo type variable here.\n\nFinally, T sets the type of the items in the returned tuple.\n\nThe “User-defined generic types” section of the typing module documentation is short, presents good examples, and provides a few more details that I do not cover here.\n\nNow that we’ve seen how to implement a generic class, let’s define the terminology to talk about generics.\n\nImplementing a Generic Class\n\n|\n\n543",
      "content_length": 1077,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 574,
      "content": "Basic Jargon for Generic Types Here are a few definitions that I found useful when studying generics:14\n\nGeneric type\n\nA type declared with one or more type variables. Examples: LottoBlower[T], abc.Mapping[KT, VT]\n\nFormal type parameter\n\nThe type variables that appear in a generic type declaration. Example: KT and VT in the previous example abc.Mapping[KT, VT]\n\nParameterized type\n\nA type declared with actual type parameters. Examples: LottoBlower[int], abc.Mapping[str, float]\n\nActual type parameter\n\nThe actual types given as parameters when a parameterized type is declared. Example: the int in LottoBlower[int]\n\nThe next topic is about how to make generic types more flexible, introducing the concepts of covariance, contravariance, and invariance.\n\nVariance\n\nDepending on your experience with generics in other languages, this may be the most challenging section in the book. The concept of variance is abstract, and a rigorous presentation would make this section look like pages from a math book.\n\nIn practice, variance is mostly relevant to library authors who want to support new generic container types or provide callback-based APIs. Even then, you can avoid much complexity by supporting only invariant containers—which is mostly what we have now in the Python standard library. So, on a first reading, you can skip the whole section or just read the sections about invariant types.\n\nWe first saw the concept of variance in “Variance in Callable types” on page 292, applied to parameterized generic Callable types. Here we’ll expand the concept to cover generic collection types, using a “real world” analogy to make this abstract con‐ cept more concrete.\n\n14 The terms are from Joshua Bloch’s classic book, Effective Java, 3rd ed. (Addison-Wesley). The definitions and\n\nexamples are mine.\n\n544\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1847,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 575,
      "content": "Imagine that a school cafeteria has a rule that only juice dispensers can be installed.15 General beverage dispensers are not allowed because they may serve sodas, which are banned by the school board.16\n\nAn Invariant Dispenser Let’s try to model the cafeteria scenario with a generic BeverageDispenser class that can be parameterized on the type of beverage. See Example 15-18.\n\nExample 15-18. invariant.py: type definitions and install function\n\nfrom typing import TypeVar, Generic\n\nclass Beverage: \"\"\"Any beverage.\"\"\"\n\nclass Juice(Beverage): \"\"\"Any fruit juice.\"\"\"\n\nclass OrangeJuice(Juice): \"\"\"Delicious juice from Brazilian oranges.\"\"\"\n\nT = TypeVar('T')\n\nclass BeverageDispenser(Generic[T]): \"\"\"A dispenser parameterized on the beverage type.\"\"\" def __init__(self, beverage: T) -> None: self.beverage = beverage\n\ndef dispense(self) -> T: return self.beverage\n\ndef install(dispenser: BeverageDispenser[Juice]) -> None: \"\"\"Install a fruit juice dispenser.\"\"\"\n\nBeverage, Juice, and OrangeJuice form a type hierarchy.\n\nSimple TypeVar declaration.\n\nBeverageDispenser is parameterized on the type of beverage.\n\n15 I first saw the cafeteria analogy for variance in Erik Meijer’s Foreword in The Dart Programming Language\n\nbook by Gilad Bracha (Addison-Wesley).\n\n16 Much better than banning books!\n\nVariance\n\n|\n\n545",
      "content_length": 1312,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 576,
      "content": "install is a module-global function. Its type hint enforces the rule that only a juice dispenser is acceptable.\n\nGiven the definitions in Example 15-18, the following code is legal:\n\njuice_dispenser = BeverageDispenser(Juice()) install(juice_dispenser)\n\nHowever, this is not legal:\n\nbeverage_dispenser = BeverageDispenser(Beverage()) install(beverage_dispenser) ## mypy: Argument 1 to \"install\" has ## incompatible type \"BeverageDispenser[Beverage]\" ## expected \"BeverageDispenser[Juice]\"\n\nA dispenser that serves any Beverage is not acceptable because the cafeteria requires a dispenser that is specialized for Juice.\n\nSomewhat surprisingly, this code is also illegal:\n\norange_juice_dispenser = BeverageDispenser(OrangeJuice()) install(orange_juice_dispenser) ## mypy: Argument 1 to \"install\" has ## incompatible type \"BeverageDispenser[OrangeJuice]\" ## expected \"BeverageDispenser[Juice]\"\n\nA dispenser specialized for OrangeJuice is not allowed either. Only BeverageDis penser[Juice] will do. In the typing jargon, we say that BeverageDis penser(Generic[T]) is invariant when BeverageDispenser[OrangeJuice] is not compatible with BeverageDispenser[Juice]—despite the fact that OrangeJuice is a subtype-of Juice.\n\nPython mutable collection types—such as list and set—are invariant. The Lotto Blower class from Example 15-17 is also invariant.\n\nA Covariant Dispenser If we want to be more flexible and model dispensers as a generic class that can accept some beverage type and also its subtypes, we must make it covariant. Example 15-19 shows how we’d declare BeverageDispenser.\n\nExample 15-19. covariant.py: type definitions and install function\n\nT_co = TypeVar('T_co', covariant=True)\n\nclass BeverageDispenser(Generic[T_co]): def __init__(self, beverage: T_co) -> None: self.beverage = beverage\n\n546\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1839,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 577,
      "content": "def dispense(self) -> T_co: return self.beverage\n\ndef install(dispenser: BeverageDispenser[Juice]) -> None: \"\"\"Install a fruit juice dispenser.\"\"\"\n\nSet covariant=True when declaring the type variable; _co is a conventional suf‐ fix for covariant type parameters on typeshed.\n\nUse T_co to parameterize the Generic special class.\n\nType hints for install are the same as in Example 15-18.\n\nThe following code works because now both the Juice dispenser and the Orange Juice dispenser are valid in a covariant BeverageDispenser:\n\njuice_dispenser = BeverageDispenser(Juice()) install(juice_dispenser)\n\norange_juice_dispenser = BeverageDispenser(OrangeJuice()) install(orange_juice_dispenser)\n\nBut a dispenser for an arbitrary Beverage is not acceptable:\n\nbeverage_dispenser = BeverageDispenser(Beverage()) install(beverage_dispenser) ## mypy: Argument 1 to \"install\" has ## incompatible type \"BeverageDispenser[Beverage]\" ## expected \"BeverageDispenser[Juice]\"\n\nThat’s covariance: the subtype relationship of the parameterized dispensers varies in the same direction as the subtype relationship of the type parameters.\n\nA Contravariant Trash Can Now we’ll model the cafeteria rule for deploying a trash can. Let’s assume food and drinks are served in biodegradable packages, and leftovers as well as single-use uten‐ sils are also biodegradable. The trash cans must be suitable for biodegradable refuse.\n\nVariance\n\n|\n\n547",
      "content_length": 1415,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 578,
      "content": "For the sake of this didactic example, let’s make simplifying assumptions to classify trash in a neat hierarchy:\n\nRefuse is the most general type of trash. All trash is refuse. • Biodegradable is a specific type of trash that can be decom‐ posed by organisms over time. Some Refuse is not Biodegrad able.\n\nCompostable is a specific type of Biodegradable trash that can be efficiently turned into organic fertilizer in a compost bin or in a composting facility. Not all Biodegradable trash is Compo stable in our definition.\n\nIn order to model the rule for an acceptable trash can in the cafeteria, we need to introduce the concept of “contravariance” through an example using it, as shown in Example 15-20.\n\nExample 15-20. contravariant.py: type definitions and install function\n\nfrom typing import TypeVar, Generic\n\nclass Refuse: \"\"\"Any refuse.\"\"\"\n\nclass Biodegradable(Refuse): \"\"\"Biodegradable refuse.\"\"\"\n\nclass Compostable(Biodegradable): \"\"\"Compostable refuse.\"\"\"\n\nT_contra = TypeVar('T_contra', contravariant=True)\n\nclass TrashCan(Generic[T_contra]): def put(self, refuse: T_contra) -> None: \"\"\"Store trash until dumped.\"\"\"\n\ndef deploy(trash_can: TrashCan[Biodegradable]): \"\"\"Deploy a trash can for biodegradable refuse.\"\"\"\n\nA type hierarchy for refuse: Refuse is the most general type, Compostable is the most specific.\n\nT_contra is a conventional name for a contravariant type variable.\n\nTrashCan is contravariant on the type of refuse.\n\nGiven those definitions, these types of trash cans are acceptable:\n\n548\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1554,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 579,
      "content": "bio_can: TrashCan[Biodegradable] = TrashCan() deploy(bio_can)\n\ntrash_can: TrashCan[Refuse] = TrashCan() deploy(trash_can)\n\nThe more general TrashCan[Refuse] is acceptable because it can take any kind of refuse, including Biodegradable. However, a TrashCan[Compostable] will not do, because it cannot take Biodegradable:\n\ncompost_can: TrashCan[Compostable] = TrashCan() deploy(compost_can) ## mypy: Argument 1 to \"deploy\" has ## incompatible type \"TrashCan[Compostable]\" ## expected \"TrashCan[Biodegradable]\"\n\nLet’s summarize the concepts we just saw.\n\nVariance Review Variance is a subtle property. The following sections recap the concept of invariant, covariant, and contravariant types, and provide some rules of thumb to reason about them.\n\nInvariant types\n\nA generic type L is invariant when there is no supertype or subtype relationship between two parameterized types, regardless of the relationship that may exist between the actual parameters. In other words, if L is invariant, then L[A] is not a supertype or a subtype of L[B]. They are inconsistent in both ways.\n\nAs mentioned, Python’s mutable collections are invariant by default. The list type is a good example: list[int] is not consistent-with list[float] and vice versa.\n\nIn general, if a formal type parameter appears in type hints of method arguments, and the same parameter appears in method return types, that parameter must be invariant to ensure type safety when updating and reading from the collection.\n\nFor example, here is part of the type hints for the list built-in on typeshed:\n\nclass list(MutableSequence[_T], Generic[_T]): @overload def __init__(self) -> None: ... @overload def __init__(self, iterable: Iterable[_T]) -> None: ... # ... lines omitted ... def append(self, __object: _T) -> None: ... def extend(self, __iterable: Iterable[_T]) -> None: ... def pop(self, __index: int = ...) -> _T: ... # etc...\n\nVariance\n\n|\n\n549",
      "content_length": 1909,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 580,
      "content": "Note that _T appears in the arguments of __init__, append, and extend, and as the return type of pop. There is no way to make such a class type safe if it is covariant or contravariant in _T.\n\nCovariant types\n\nConsider two types A and B, where B is consistent-with A, and neither of them is Any. Some authors use the <: and :> symbols to denote type relationships like this:\n\nA :> B\n\nA is a supertype-of or the same as B.\n\nB <: A\n\nB is a subtype-of or the same as A.\n\nGiven A :> B, a generic type C is covariant when C[A] :> C[B].\n\nNote the direction of the :> symbol is the same in both cases where A is to the left of B. Covariant generic types follow the subtype relationship of the actual type parameters.\n\nImmutable containers can be covariant. For example, this is how the typing.Frozen Set class is documented as a covariant with a type variable using the conventional name T_co:\n\nclass FrozenSet(frozenset, AbstractSet[T_co]):\n\nApplying the :> notation to parameterized types, we have:\n\nfloat :> int frozenset[float] :> frozenset[int]\n\nIterators are another example of covariant generics: they are not read-only collections like a frozenset, but they only produce output. Any code expecting an abc.Itera tor[float] yielding floats can safely use an abc.Iterator[int] yielding integers. Callable types are covariant on the return type for a similar reason.\n\nContravariant types\n\nGiven A :> B, a generic type K is contravariant if K[A] <: K[B].\n\nContravariant generic types reverse the subtype relationship of the actual type parameters.\n\nThe TrashCan class exemplifies this:\n\nRefuse :> Biodegradable TrashCan[Refuse] <: TrashCan[Biodegradable]\n\n550\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1693,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 581,
      "content": "A contravariant container is usually a write-only data structure, also known as a “sink.” There are no examples of such collections in the standard library, but there are a few types with contravariant type parameters.\n\nCallable[[ParamType, …], ReturnType] is contravariant on the parameter types, but covariant on the ReturnType, as we saw in “Variance in Callable types” on page 292. In addition, Generator, Coroutine, and AsyncGenerator have one contravariant type parameter. The Generator type is described in “Generic Type Hints for Classic Coroutines” on page 650; Coroutine and AsyncGenerator are described in Chapter 21.\n\nFor the present discussion about variance, the main point is that the contravariant formal parameter defines the type of the arguments used to invoke or send data to the object, while different covariant formal parameters define the types of outputs produced by the object—the yield type or the return type, depending on the object. The meanings of “send” and “yield” are explained in “Classic Coroutines” on page 641.\n\nWe can derive useful guidelines from these observations of covariant outputs and contravariant inputs.\n\nVariance rules of thumb\n\nFinally, here are a few rules of thumb to reason about when thinking through variance:\n\nIf a formal type parameter defines a type for data that comes out of the object, it can be covariant.\n\nIf a formal type parameter defines a type for data that goes into the object after its initial construction, it can be contravariant.\n\nIf a formal type parameter defines a type for data that comes out of the object and the same parameter defines a type for data that goes into the object, it must be invariant.\n\nTo err on the safe side, make formal type parameters invariant.\n\nCallable[[ParamType, …], ReturnType] demonstrates rules #1 and #2: The Return Type is covariant, and each ParamType is contravariant.\n\nBy default, TypeVar creates formal parameters that are invariant, and that’s how the mutable collections in the standard library are annotated.\n\n“Generic Type Hints for Classic Coroutines” on page 650 continues the present discus‐ sion about variance.\n\nNext, let’s see how to define generic static protocols, applying the idea of covariance to a couple of new examples.\n\nVariance\n\n|\n\n551",
      "content_length": 2269,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 582,
      "content": "Implementing a Generic Static Protocol The Python 3.10 standard library provides a few generic static protocols. One of them is SupportsAbs, implemented like this in the typing module:\n\n@runtime_checkable class SupportsAbs(Protocol[T_co]): \"\"\"An ABC with one abstract method __abs__ that is covariant in its return type.\"\"\" __slots__ = ()\n\n@abstractmethod def __abs__(self) -> T_co: pass\n\nT_co is declared according to the naming convention:\n\nT_co = TypeVar('T_co', covariant=True)\n\nThanks to SupportsAbs, Mypy recognizes this code as valid, as you can see in Example 15-21.\n\nExample 15-21. abs_demo.py: use of the generic SupportsAbs protocol\n\nimport math from typing import NamedTuple, SupportsAbs\n\nclass Vector2d(NamedTuple): x: float y: float\n\ndef __abs__(self) -> float: return math.hypot(self.x, self.y)\n\ndef is_unit(v: SupportsAbs[float]) -> bool: \"\"\"'True' if the magnitude of 'v' is close to 1.\"\"\" return math.isclose(abs(v), 1.0)\n\nassert issubclass(Vector2d, SupportsAbs)\n\nv0 = Vector2d(0, 1) sqrt2 = math.sqrt(2) v1 = Vector2d(sqrt2 / 2, sqrt2 / 2) v2 = Vector2d(1, 1) v3 = complex(.5, math.sqrt(3) / 2) v4 = 1\n\nassert is_unit(v0) assert is_unit(v1) assert not is_unit(v2) assert is_unit(v3)\n\n552\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1245,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 583,
      "content": "assert is_unit(v4)\n\nprint('OK')\n\nDefining __abs__ makes Vector2d consistent-with SupportsAbs.\n\nParameterizing SupportsAbs with float ensures…\n\n…that Mypy accepts abs(v) as the first argument for math.isclose.\n\nThanks to @runtime_checkable in the definition of SupportsAbs, this is a valid runtime assertion.\n\nThe remaining code all passes Mypy checks and runtime assertions.\n\nThe int type is also consistent-with SupportsAbs. According to typeshed, int.__abs__ returns an int, which is consistent-with the float type parameter declared in the is_unit type hint for the v argument.\n\nSimilarly, we can write a generic version of the RandomPicker protocol presented in Example 13-18, which was defined with a single method pick returning Any.\n\nExample 15-22 shows how to make a generic RandomPicker covariant on the return type of pick.\n\nExample 15-22. generic_randompick.py: definition of generic RandomPicker\n\nfrom typing import Protocol, runtime_checkable, TypeVar\n\nT_co = TypeVar('T_co', covariant=True)\n\n@runtime_checkable class RandomPicker(Protocol[T_co]): def pick(self) -> T_co: ...\n\nDeclare T_co as covariant.\n\nThis makes RandomPicker generic with a covariant formal type parameter.\n\nUse T_co as the return type.\n\nImplementing a Generic Static Protocol\n\n|\n\n553",
      "content_length": 1267,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 584,
      "content": "The generic RandomPicker protocol can be covariant because its only formal parame‐ ter is used in a return type.\n\nWith this, we can call it a chapter.\n\nChapter Summary The chapter started with a simple example of using @overload, followed by a much more complex example that we studied in detail: the overloaded signatures required to correctly annotate the max built-in function.\n\nThe typing.TypedDict special construct came next. I chose to cover it here, and not in Chapter 5 where we saw typing.NamedTuple, because TypedDict is not a class builder; it’s merely a way to add type hints to a variable or argument that requires a dict with a specific set of string keys, and specific types for each key—which happens when we use a dict as a record, often in the context of handling with JSON data. That section was a bit long because using TypedDict can give a false sense of security, and I wanted to show how runtime checks and error handling are really inevitable when trying to make statically structured records out of mappings that are dynamic in nature.\n\nNext we talked about typing.cast, a function designed to let us guide the work of the type checker. It’s important to carefully consider when to use cast, because over‐ using it hinders the type checker.\n\nRuntime access to type hints came next. The key point was to use typing. get_type_hints instead of reading the __annotations__ attribute directly. However, that function may be unreliable with some annotations, and we saw that Python core developers are still working on a way to make type hints usable at runtime, while reducing their impact on CPU and memory usage.\n\nThe final sections were about generics, starting with the LottoBlower generic class— which we later learned is an invariant generic class. That example was followed by definitions of four basic terms: generic type, formal type parameter, parameterized type, and actual type parameter.\n\nThe major topic of variance was presented next, using cafeteria beverage dispensers and trash cans as “real life” examples of invariant, covariant, and contravariant generic types. Next we reviewed, formalized, and further applied those concepts to examples in Python’s standard library.\n\nLastly, we saw how a generic static protocol is defined, first considering the typ ing.SupportsAbs protocol, and then applying the same idea to the RandomPicker example, making it more strict than the original protocol from Chapter 13.\n\n554\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 2490,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 585,
      "content": "Python’s type system is a huge and rapidly evolving subject. This chapter is not comprehensive. I chose to focus on topics that are either widely applicable, particularly challenging, or conceptually important and therefore likely to be relevant for a long time.\n\nFurther Reading Python’s static type system was complex as initially designed, and is getting more complex with each passing year. Table 15-1 lists all the PEPs that I am aware of as of May 2021. It would take a whole book to cover everything.\n\nTable 15-1. PEPs about type hints, with links in the titles. PEP with numbers marked with * are important enough to be mentioned in the opening paragraph of the typing documentation. Question marks in the Python column indicate PEPs under discussion or not yet implemented; “n/a” appears in informational PEPs with no specific Python version.\n\nPEP 3107\n\nTitle Function Annotations\n\nPython Year 2006 3.0\n\n483*\n\nThe Theory of Type Hints\n\nn/a\n\n2014\n\n484*\n\nType Hints\n\n3.5\n\n2014\n\n482\n\nLiterature Overview for Type Hints\n\nn/a\n\n2015\n\n526*\n\nSyntax for Variable Annotations\n\n3.6\n\n2016\n\n544*\n\nProtocols: Structural subtyping (static duck typing)\n\n3.8\n\n2017\n\n557\n\nData Classes\n\n3.7\n\n2017\n\n560\n\nCore support for typing module and generic types\n\n3.7\n\n2017\n\n561\n\nDistributing and Packaging Type Information\n\n3.7\n\n2017\n\n563\n\nPostponed Evaluation of Annotations\n\n3.7\n\n2017\n\n586*\n\nLiteral Types\n\n3.8\n\n2018\n\n585\n\nType Hinting Generics In Standard Collections\n\n3.9\n\n2019\n\n589*\n\nTypedDict: Type Hints for Dictionaries with a Fixed Set of Keys\n\n3.8\n\n2019\n\n591* Adding a final qualifier to typing\n\n3.8\n\n2019\n\n593\n\nFlexible function and variable annotations\n\n?\n\n2019\n\n604\n\nAllow writing union types as X | Y\n\n3.10\n\n2019\n\n612\n\nParameter Specification Variables\n\n3.10\n\n2019\n\n613\n\nExplicit Type Aliases\n\n3.10\n\n2020\n\n645\n\nAllow writing optional types as x?\n\n?\n\n2020\n\n646\n\nVariadic Generics\n\n?\n\n2020\n\n647\n\nUser-Defined Type Guards\n\n3.10\n\n2021\n\n649\n\nDeferred Evaluation Of Annotations Using Descriptors\n\n?\n\n2021\n\n655 Marking individual TypedDict items as required or potentially-missing\n\n?\n\n2021\n\nFurther Reading\n\n|\n\n555",
      "content_length": 2101,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 586,
      "content": "Python’s official documentation hardly keeps up with all that, so Mypy’s documenta‐ tion is an essential reference. Robust Python by Patrick Viafore (O’Reilly) is the first book with extensive coverage of Python’s static type system that I know about, pub‐ lished August 2021. You may be reading the second such book right now.\n\nThe subtle topic of variance has its own section in PEP 484, and is also covered in the “Generics” page of Mypy, as well as in its invaluable “Common Issues” page.\n\nPEP 362—Function Signature Object is worth reading if you intend to use the inspect module that complements the typing.get_type_hints function.\n\nIf you are interested in the history of Python, you may like to know that Guido van Rossum posted “Adding Optional Static Typing to Python” on December 23, 2004.\n\n“Python 3 Types in the Wild: A Tale of Two Type Systems” is a research paper by Ingkarat Rak-amnouykit and others from the Rensselaer Polytechnic Institute and IBM TJ Watson Research Center. The paper surveys the use of type hints in open source projects on GitHub, showing that most projects don’t use them, and also that most projects that have type hints apparently don’t use a type checker. I found most interesting the discussion of the different semantics of Mypy and Google’s pytype, which they conclude are “essentially two different type systems.”\n\nTwo seminal papers about gradual typing are Gilad Bracha’s “Pluggable Type Sys‐ tems”, and “Static Typing Where Possible, Dynamic Typing When Needed: The End of the Cold War Between Programming Languages” by Eric Meijer and Peter Dray‐ ton.17\n\nI learned a lot reading the relevant parts of some books about other languages that implement some of the same ideas:\n\nAtomic Kotlin by Bruce Eckel and Svetlana Isakova (Mindview)\n\nEffective Java, 3rd ed., by Joshua Bloch (Addison-Wesley)\n\nProgramming with Types: TypeScript Examples by Vlad Riscutia (Manning)\n\nProgramming TypeScript by Boris Cherny (O’Reilly) • The Dart Programming Language by Gilad Bracha (Addison-Wesley)18\n\nFor some critical views on type systems, I recommend Victor Youdaiken’s posts “Bad ideas in type theory” and “Types considered harmful II”.\n\n17 As a reader of footnotes, you may recall that I credited Erik Meijer for the cafeteria analogy to explain\n\nvariance.\n\n18 That book was written for Dart 1. There are significant changes in Dart 2, including in the type system. Nev‐ ertheless, Bracha is an important researcher in the field of programming language design, and I found the book valuable for his perspective on the design of Dart.\n\n556\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 2614,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 587,
      "content": "Finally, I was surprised to find “Generics Considered Harmful” by Ken Arnold, a core contributor to Java from the beginning, as well as coauthor of the first four edi‐ tions of the official The Java Programming Language book (Addison-Wesley)—in collaboration with James Gosling, the lead designer of Java.\n\nSadly, Arnold’s criticism applies to Python’s static type system as well. While reading the many rules and special cases of the typing PEPs, I was constantly reminded of this passage from Gosling’s post:\n\nWhich brings up the problem that I always cite for C++: I call it the “Nth order excep‐ tion to the exception rule.” It sounds like this: “You can do x, except in case y, unless y does z, in which case you can if …”\n\nFortunately, Python has a key advantage over Java and C++: an optional type system. We can squelch type checkers and omit type hints when they become too cumbersome.\n\nSoapbox\n\nTyping Rabbit Holes\n\nWhen using a type checker, we are sometimes forced to discover and import classes we did not need to know about, and our code has no need to reference—except to write type hints. Such classes are undocumented, probably because they are consid‐ ered implementation details by the authors of the packages. Here are two examples from the standard library.\n\nTo use cast() in the server.sockets example in “Type Casting” on page 534, I had to scour the vast asyncio documentation and then browse the source code of several modules in that package to discover the undocumented TransportSocket class in the equally undocumented asyncio.trsock module. Using socket.socket instead of TransportSocket would be incorrect, because the latter is explicitly not a subtype of the former, according to a docstring in the source code.\n\nI fell into a similar rabbit hole when I added type hints to Example 19-13, a simple demonstration of multiprocessing. That example uses SimpleQueue objects, which you get by calling multiprocessing.SimpleQueue(). However, I could not use that name in a type hint, because it turns out that multiprocessing.SimpleQueue is not a class! It’s a bound method of the undocumented multiprocessing.BaseContext class, which builds and returns an instance of the SimpleQueue class defined in the undocumented multiprocessing.queues module.\n\nIn each of those cases I had to spend a couple of hours to find the right undocumen‐ ted class to import, just to write a single type hint. This kind of research is part of the job when writing a book. But when writing application code, I’d probably avoid such\n\nFurther Reading\n\n|\n\n557",
      "content_length": 2562,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 588,
      "content": "scavenger hunts for a single offending line and just write # type: ignore. Sometimes that’s the only cost-effective solution.\n\nVariance Notation in Other Languages\n\nVariance is a difficult topic, and Python’s type hints syntax is not as good as it could be. This is evidenced by this direct quote from PEP 484:\n\nCovariance or contravariance is not a property of a type variable, but a property of a generic class defined using this variable.19\n\nIf that is the case, why are covariance and contravariance declared with TypeVar and not on the generic class?\n\nThe authors of PEP 484 worked under the severe self-imposed constraint that type hints should be supported without making any change to the interpreter. This required the introduction of TypeVar to define type variables, and also the abuse of [] to provide Klass[T] syntax for generics—instead of the Klass<T> notation used in other popular languages, including C#, Java, Kotlin, and TypeScript. None of these languages require type variables to be declared before use.\n\nIn addition, the syntax of Kotlin and C# makes it clear whether the type parameter is covariant, contravariant, or invariant exactly where it makes sense: in the class or interface declaration.\n\nIn Kotlin, we could declare the BeverageDispenser like this:\n\nclass BeverageDispenser<out T> { // etc... }\n\nThe out modifier in the formal type parameter means T is an “output” type, therefore BeverageDispenser is covariant.\n\n19 See the last paragraph of the section “Covariance and Contravariance” in PEP 484.\n\n558\n\n|\n\nChapter 15: More About Type Hints",
      "content_length": 1576,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 589,
      "content": "You can probably guess how TrashCan would be declared:\n\nclass TrashCan<in T> { // etc... }\n\nGiven T as an “input” formal type parameter, then TrashCan is contravariant.\n\nIf neither in nor out appear, then the class is invariant on the parameter.\n\nIt’s easy to recall the “Variance rules of thumb” on page 551 when out and in are used in the formal type parameters.\n\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be:\n\nT_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True)\n\nThen we could define the classes like this:\n\nclass BeverageDispenser(Generic[T_out]): ...\n\nclass TrashCan(Generic[T_in]): ...\n\nIs it too late to change the naming convention established in PEP 484?\n\nFurther Reading\n\n|\n\n559",
      "content_length": 785,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 591,
      "content": "CHAPTER 16 Operator Overloading\n\nThere are some things that I kind of feel torn about, like operator overloading. I left out operator overloading as a fairly personal choice because I had seen too many people abuse it in C++.\n\n—James Gosling, creator of Java1\n\nIn Python, you can compute compound interest using a formula written like this:\n\ninterest = principal * ((1 + rate) ** periods - 1)\n\nOperators that appear between operands, like 1 + rate, are infix operators. In Python, the infix operators can handle any arbitrary type. Thus, if you are dealing with real money, you can make sure that principal, rate, and periods are exact numbers—instances of the Python decimal.Decimal class—and that formula will work as written, producing an exact result.\n\nBut in Java, if you switch from float to BigDecimal to get exact results, you can’t use infix operators anymore, because they only work with the primitive types. This is the same formula coded to work with BigDecimal numbers in Java:\n\nBigDecimal interest = principal.multiply(BigDecimal.ONE.add(rate) .pow(periods).subtract(BigDecimal.ONE));\n\nIt’s clear that infix operators make formulas more readable. Operator overloading is necessary to support infix operator notation with user-defined or extension types, such as NumPy arrays. Having operator overloading in a high-level, easy-to-use lan‐ guage was probably a key reason for the huge success of Python in data science, including financial and scientific applications.\n\n1 Source: “The C Family of Languages: Interview with Dennis Ritchie, Bjarne Stroustrup, and James Gosling”.\n\n561",
      "content_length": 1594,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 592,
      "content": "In “Emulating Numeric Types” on page 9 (Chapter 1) we saw some trivial implemen‐ tations of operators in a bare-bones Vector class. The __add__ and __mul__ methods in Example 1-2 were written to show how special methods support operator over‐ loading, but there are subtle problems in their implementations that we overlooked. Also, in Example 11-2, we noted that the Vector2d.__eq__ method considers this to be True: Vector(3, 4) == [3, 4]—which may or not make sense. We will address these matters in this chapter, as well as:\n\nHow an infix operator method should signal it cannot handle an operand\n\nUsing duck typing or goose typing to deal with operands of various types • The special behavior of the rich comparison operators (e.g., ==, >, <=, etc.) • The default handling of augmented assignment operators such as +=, and how to overload them\n\nWhat’s New in This Chapter Goose typing is a key part of Python, but the numbers ABCs are not supported in static typing, so I changed Example 16-11 to use duck typing instead of an explicit isinstance check against numbers.Real.2\n\nI covered the @ matrix multiplication operator in the first edition of Fluent Python as an upcoming change when 3.5 was still in alpha. Accordingly, that operator is no longer in a side note, but is integrated in the flow of the chapter in “Using @ as an Infix Operator” on page 574. I leveraged goose typing to make the implementation of __matmul__ safer than the one in the first edition, without compromising on flexibility.\n\n“Further Reading” on page 587 now has a couple of new references—including a blog post by Guido van Rossum. I also added mentions of two libraries that showcase effective use of operator overloading outside the domain of mathematics: pathlib and Scapy.\n\nOperator Overloading 101 Operator overloading allows user-defined objects to interoperate with infix operators such as + and |, or unary operators like - and ~. More generally, function invocation\n\n2 The remaining ABCs in Python’s standard library are still valuable for goose typing and static typing. The issue with the numbers ABCs is explained in “The numbers ABCs and Numeric Protocols” on page 478.\n\n562\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 2211,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 593,
      "content": "(()), attribute access (.), and item access/slicing ([]) are also operators in Python, but this chapter covers unary and infix operators.\n\nOperator overloading has a bad name in some circles. It is a language feature that can be (and has been) abused, resulting in programmer confusion, bugs, and unexpected performance bottlenecks. But if used well, it leads to pleasurable APIs and readable code. Python strikes a good balance among flexibility, usability, and safety by impos‐ ing some limitations:\n\nWe cannot change the meaning of the operators for the built-in types.\n\nWe cannot create new operators, only overload existing ones. • A few operators can’t be overloaded: is, and, or, not (but the bitwise &, |, ~, can).\n\nIn Chapter 12, we already had one infix operator in Vector: ==, supported by the __eq__ method. In this chapter, we’ll improve the implementation of __eq__ to better handle operands of types other than Vector. However, the rich comparison operators (==, !=, >, <, >=, <=) are special cases in operator overloading, so we’ll start by over‐ loading four arithmetic operators in Vector: the unary - and +, followed by the infix + and *.\n\nLet’s start with the easiest topic: unary operators.\n\nUnary Operators The Python Language Reference, “6.5. Unary arithmetic and bitwise operations” lists three unary operators, shown here with their associated special methods:\n\n, implemented by __neg__\n\nArithmetic unary negation. If x is -2 then -x == 2.\n\n+, implemented by __pos__\n\nArithmetic unary plus. Usually x == +x, but there are a few cases when that’s not true. See “When x and +x Are Not Equal” on page 565 if you’re curious.\n\n~, implemented by __invert__\n\nBitwise not, or bitwise inverse of an integer, defined as ~x == -(x+1). If x is 2 then ~x == -3.3\n\nThe “Data Model” chapter of The Python Language Reference also lists the abs() built-in function as a unary operator. The associated special method is __abs__, as we’ve seen before.\n\n3 See https://en.wikipedia.org/wiki/Bitwise_operation#NOT for an explanation of the bitwise not.\n\nUnary Operators\n\n|\n\n563",
      "content_length": 2080,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 594,
      "content": "It’s easy to support the unary operators. Simply implement the appropriate special method, which will take just one argument: self. Use whatever logic makes sense in your class, but stick to the general rule of operators: always return a new object. In other words, do not modify the receiver (self), but create and return a new instance of a suitable type.\n\nIn the case of - and +, the result will probably be an instance of the same class as self. For unary +, if the receiver is immutable you should return self; otherwise, return a copy of self. For abs(), the result should be a scalar number.\n\nAs for ~, it’s difficult to say what would be a sensible result if you’re not dealing with bits in an integer. In the pandas data analysis package, the tilde negates boolean filter‐ ing conditions; see “Boolean indexing” in the pandas documentation for examples.\n\nAs promised before, we’ll implement several new operators on the Vector class from Chapter 12. Example 16-1 shows the __abs__ method we already had in Example 12-16, and the newly added __neg__ and __pos__ unary operator method.\n\nExample 16-1. vector_v6.py: unary operators - and + added to Example 12-16\n\ndef __abs__(self): return math.hypot(*self)\n\ndef __neg__(self): return Vector(-x for x in self)\n\ndef __pos__(self): return Vector(self)\n\nTo compute -v, build a new Vector with every component of self negated.\n\nTo compute +v, build a new Vector with every component of self.\n\nRecall that Vector instances are iterable, and the Vector.__init__ takes an iterable argument, so the implementations of __neg__ and __pos__ are short and sweet.\n\nWe’ll not implement __invert__, so if the user tries ~v on a Vector instance, Python will raise TypeError with a clear message: “bad operand type for unary ~: 'Vector'.”\n\nThe following sidebar covers a curiosity that may help you win a bet about unary + someday.\n\n564\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 1912,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 595,
      "content": "When x and +x Are Not Equal Everybody expects that x == +x, and that is true almost all the time in Python, but I found two cases in the standard library where x != +x.\n\nThe first case involves the decimal.Decimal class. You can have x != +x if x is a Decimal instance created in an arithmetic context and +x is then evaluated in a con‐ text with different settings. For example, x is calculated in a context with a certain precision, but the precision of the context is changed and then +x is evaluated. See Example 16-2 for a demonstration.\n\nExample 16-2. A change in the arithmetic context precision may cause x to differ from +x\n\n>>> import decimal >>> ctx = decimal.getcontext() >>> ctx.prec = 40 >>> one_third = decimal.Decimal('1') / decimal.Decimal('3') >>> one_third Decimal('0.3333333333333333333333333333333333333333') >>> one_third == +one_third True >>> ctx.prec = 28 >>> one_third == +one_third False >>> +one_third Decimal('0.3333333333333333333333333333')\n\nGet a reference to the current global arithmetic context.\n\nSet the precision of the arithmetic context to 40.\n\nCompute 1/3 using the current precision.\n\nInspect the result; there are 40 digits after the decimal point.\n\none_third == +one_third is True.\n\nLower precision to 28—the default for Decimal arithmetic.\n\nNow one_third == +one_third is False.\n\nInspect +one_third; there are 28 digits after the '.' here.\n\nUnary Operators\n\n|\n\n565",
      "content_length": 1408,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 596,
      "content": "The fact is that each occurrence of the expression +one_third produces a new Deci mal instance from the value of one_third, but using the precision of the current arithmetic context.\n\nYou can find the second case where x != +x in the collections.Counter documen‐ tation. The Counter class implements several arithmetic operators, including infix + to add the tallies from two Counter instances. However, for practical reasons, Counter addition discards from the result any item with a negative or zero count. And the prefix + is a shortcut for adding an empty Counter, therefore it produces a new Counter, preserving only the tallies that are greater than zero. See Example 16-3.\n\nExample 16-3. Unary + produces a new Counter without zeroed or negative tallies\n\n>>> ct = Counter('abracadabra') >>> ct Counter({'a': 5, 'r': 2, 'b': 2, 'd': 1, 'c': 1}) >>> ct['r'] = -3 >>> ct['d'] = 0 >>> ct Counter({'a': 5, 'b': 2, 'c': 1, 'd': 0, 'r': -3}) >>> +ct Counter({'a': 5, 'b': 2, 'c': 1})\n\nAs you can see, +ct returns a counter where all tallies are greater than zero.\n\nNow, back to our regularly scheduled programming.\n\nOverloading + for Vector Addition The Vector class is a sequence type, and the section “3.3.6. Emulating container types” in the “Data Model” chapter of the official Python documentation says that sequences should support the + operator for concatenation and * for repetition. However, here we will implement + and * as mathematical vector operations, which are a bit harder but more meaningful for a Vector type.\n\nIf users want to concatenate or repeat Vector instances, they can convert them to tuples or lists, apply the operator, and convert back—thanks to the fact that Vector is iterable and can be con‐ structed from an iterable:\n\n>>> v_concatenated = Vector(list(v1) + list(v2)) >>> v_repeated = Vector(tuple(v1) * 5)\n\nAdding two Euclidean vectors results in a new vector in which the components are the pairwise additions of the components of the operands. To illustrate:\n\n566\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 2038,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 597,
      "content": ">>> v1 = Vector([3, 4, 5]) >>> v2 = Vector([6, 7, 8]) >>> v1 + v2 Vector([9.0, 11.0, 13.0]) >>> v1 + v2 == Vector([3 + 6, 4 + 7, 5 + 8]) True\n\nWhat happens if we try to add two Vector instances of different lengths? We could raise an error, but considering practical applications (such as information retrieval), it’s better to fill out the shortest Vector with zeros. This is the result we want:\n\n>>> v1 = Vector([3, 4, 5, 6]) >>> v3 = Vector([1, 2]) >>> v1 + v3 Vector([4.0, 6.0, 5.0, 6.0])\n\nGiven these basic requirements, we can implement __add__ like in Example 16-4.\n\nExample 16-4. Vector.__add__ method, take #1\n\n# inside the Vector class\n\ndef __add__(self, other): pairs = itertools.zip_longest(self, other, fillvalue=0.0) return Vector(a + b for a, b in pairs)\n\npairs is a generator that produces tuples (a, b), where a is from self, and b is from other. If self and other have different lengths, fillvalue supplies the missing values for the shortest iterable.\n\nA new Vector is built from a generator expression, producing one addition for each (a, b) from pairs.\n\nNote how __add__ returns a new Vector instance, and does not change self or other.\n\nSpecial methods implementing unary or infix operators should never change the value of the operands. Expressions with such operators are expected to produce results by creating new objects. Only augmented assignment operators may change the first operand (self), as discussed in “Augmented Assignment Opera‐ tors” on page 580.\n\nExample 16-4 allows adding Vector to a Vector2d, and Vector to a tuple or to any iterable that produces numbers, as Example 16-5 proves.\n\nOverloading + for Vector Addition\n\n|\n\n567",
      "content_length": 1666,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 598,
      "content": "Example 16-5. Vector.__add__ take #1 supports non-Vector objects, too\n\n>>> v1 = Vector([3, 4, 5]) >>> v1 + (10, 20, 30) Vector([13.0, 24.0, 35.0]) >>> from vector2d_v3 import Vector2d >>> v2d = Vector2d(1, 2) >>> v1 + v2d Vector([4.0, 6.0, 5.0])\n\nBoth uses of + in Example 16-5 work because __add__ uses zip_longest(…), which can consume any iterable, and the generator expression to build the new Vector merely performs a + b with the pairs produced by zip_longest(…), so an iterable producing any number items will do.\n\nHowever, if we swap the operands (Example 16-6), the mixed-type additions fail.\n\nExample 16-6. Vector.__add__ take #1 fails with non-Vector left operands\n\n>>> v1 = Vector([3, 4, 5]) >>> (10, 20, 30) + v1 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can only concatenate tuple (not \"Vector\") to tuple >>> from vector2d_v3 import Vector2d >>> v2d = Vector2d(1, 2) >>> v2d + v1 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: unsupported operand type(s) for +: 'Vector2d' and 'Vector'\n\nTo support operations involving objects of different types, Python implements a spe‐ cial dispatching mechanism for the infix operator special methods. Given an expres‐ sion a + b, the interpreter will perform these steps (also see Figure 16-1):\n\n1. If a has __add__, call a.__add__(b) and return result unless it’s NotImplemented. 2. If a doesn’t have __add__, or calling it returns NotImplemented, check if b has __radd__, then call b.__radd__(a) and return result unless it’s NotImplemented. 3. If b doesn’t have __radd__, or calling it returns NotImplemented, raise TypeError with an unsupported operand types message.\n\n568\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 1740,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 599,
      "content": "The __radd__ method is called the “reflected” or “reversed” ver‐ sion of __add__. I prefer to call them “reversed” special methods.4\n\nFigure 16-1. Flowchart for computing a + b with __add__ and __radd__.\n\nTherefore, to make the mixed-type additions in Example 16-6 work, we need to implement the Vector.__radd__ method, which Python will invoke as a fallback if the left operand does not implement __add__, or if it does but returns NotImplemen ted to signal that it doesn’t know how to handle the right operand.\n\n4 The Python documentation uses both terms. The “Data Model” chapter uses “reflected,” but “9.1.2.2. Imple‐ menting the arithmetic operations” in the numbers module docs mention “forward” and “reverse” methods, and I find this terminology better, because “forward” and “reversed” clearly name each of the directions, while “reflected” doesn’t have an obvious opposite.\n\nOverloading + for Vector Addition\n\n|\n\n569",
      "content_length": 925,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 600,
      "content": "Do not confuse NotImplemented with NotImplementedError. The first, NotImplemented, is a special singleton value that an infix operator special method should return to tell the interpreter it cannot handle a given operand. In contrast, NotImplementedError is an exception that stub methods in abstract classes may raise to warn that subclasses must implement them.\n\nThe simplest implementation of __radd__ that works is shown in Example 16-7.\n\nExample 16-7. The Vector methods __add__ and __radd__\n\n# inside the Vector class\n\ndef __add__(self, other): pairs = itertools.zip_longest(self, other, fillvalue=0.0) return Vector(a + b for a, b in pairs)\n\ndef __radd__(self, other): return self + other\n\nNo changes to __add__ from Example 16-4; listed here because __radd__ uses it.\n\n__radd__ just delegates to __add__.\n\nOften, __radd__ can be as simple as that: just invoke the proper operator, therefore delegating to __add__ in this case. This applies to any commutative operator; + is commutative when dealing with numbers or our vectors, but it’s not commutative when concatenating sequences in Python.\n\nIf __radd__ simply calls __add__, here is another way to achieve the same effect:\n\ndef __add__(self, other): pairs = itertools.zip_longest(self, other, fillvalue=0.0) return Vector(a + b for a, b in pairs)\n\n__radd__ = __add__\n\nThe methods in Example 16-7 work with Vector objects, or any iterable with numeric items, such as a Vector2d, a tuple of integers, or an array of floats. But if provided with a noniterable object, __add__ raises an exception with a message that is not very helpful, as in Example 16-8.\n\nExample 16-8. Vector.__add__ method needs an iterable operand\n\n>>> v1 + 1 Traceback (most recent call last): File \"<stdin>\", line 1, in <module>\n\n570\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 1802,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 601,
      "content": "File \"vector_v6.py\", line 328, in __add__ pairs = itertools.zip_longest(self, other, fillvalue=0.0) TypeError: zip_longest argument #2 must support iteration\n\nEven worse, we get a misleading message if an operand is iterable but its items cannot be added to the float items in the Vector. See Example 16-9.\n\nExample 16-9. Vector.__add__ method needs an iterable with numeric items\n\n>>> v1 + 'ABC' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"vector_v6.py\", line 329, in __add__ return Vector(a + b for a, b in pairs) File \"vector_v6.py\", line 243, in __init__ self._components = array(self.typecode, components) File \"vector_v6.py\", line 329, in <genexpr> return Vector(a + b for a, b in pairs) TypeError: unsupported operand type(s) for +: 'float' and 'str'\n\nI tried to add Vector and a str, but the message complains about float and str.\n\nThe problems in Examples 16-8 and 16-9 actually go deeper than obscure error mes‐ sages: if an operator special method cannot return a valid result because of type incompatibility, it should return NotImplemented and not raise TypeError. By returning NotImplemented, you leave the door open for the implementer of the other operand type to perform the operation when Python tries the reversed method call.\n\nIn the spirit of duck typing, we will refrain from testing the type of the other operand, or the type of its elements. We’ll catch the exceptions and return NotImple mented. If the interpreter has not yet reversed the operands, it will try that. If the reverse method call returns NotImplemented, then Python will raise TypeError with a standard error message like “unsupported operand type(s) for +: Vector and str.”\n\nThe final implementation of the special methods for Vector addition is in Example 16-10.\n\nExample 16-10. vector_v6.py: operator + methods added to vector_v5.py (Example 12-16)\n\ndef __add__(self, other): try: pairs = itertools.zip_longest(self, other, fillvalue=0.0) return Vector(a + b for a, b in pairs) except TypeError: return NotImplemented\n\nOverloading + for Vector Addition\n\n|\n\n571",
      "content_length": 2086,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 602,
      "content": "def __radd__(self, other): return self + other\n\nNote that __add__ now catches a TypeError and returns NotImplemented.\n\nIf an infix operator method raises an exception, it aborts the opera‐ tor dispatch algorithm. In the particular case of TypeError, it is often better to catch it and return NotImplemented. This allows the interpreter to try calling the reversed operator method, which may correctly handle the computation with the swapped operands, if they are of different types.\n\nAt this point, we have safely overloaded the + operator by writing __add__ and __radd__. We will now tackle another infix operator: *.\n\nOverloading * for Scalar Multiplication What does Vector([1, 2, 3]) * x mean? If x is a number, that would be a scalar product, and the result would be a new Vector with each component multiplied by x —also known as an elementwise multiplication:\n\n>>> v1 = Vector([1, 2, 3]) >>> v1 * 10 Vector([10.0, 20.0, 30.0]) >>> 11 * v1 Vector([11.0, 22.0, 33.0])\n\nAnother kind of product involving Vector operands would be the dot product of two vectors—or matrix multiplication, if you take one vector as a 1 × N matrix and the other as an N × 1 matrix. We will implement that operator in our Vector class in “Using @ as an Infix Operator” on page 574.\n\nBack to our scalar product, again we start with the simplest __mul__ and __rmul__ methods that could possibly work:\n\n# inside the Vector class\n\ndef __mul__(self, scalar): return Vector(n * scalar for n in self)\n\ndef __rmul__(self, scalar): return self * scalar\n\nThose methods do work, except when provided with incompatible operands. The scalar argument has to be a number that when multiplied by a float produces\n\n572\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 1720,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 603,
      "content": "another float (because our Vector class uses an array of floats internally). So a com plex number will not do, but the scalar can be an int, a bool (because bool is a sub‐ class of int), or even a fractions.Fraction instance. In Example 16-11, the __mul__ method does not make an explicit type check on scalar, but instead converts it into a float, and returns NotImplemented if that fails. That’s a clear example of duck typing.\n\nExample 16-11. vector_v7.py: operator * methods added\n\nclass Vector: typecode = 'd'\n\ndef __init__(self, components): self._components = array(self.typecode, components)\n\n# many methods omitted in book listing, see vector_v7.py # in https://github.com/fluentpython/example-code-2e\n\ndef __mul__(self, scalar): try: factor = float(scalar) except TypeError: return NotImplemented return Vector(n * factor for n in self)\n\ndef __rmul__(self, scalar): return self * scalar\n\nIf scalar cannot be converted to float…\n\n…we don’t know how to handle it, so we return NotImplemented to let Python try __rmul__ on the scalar operand.\n\nIn this example, __rmul__ works fine by just performing self * scalar, dele‐ gating to the __mul__ method.\n\nWith Example 16-11, we can multiply Vectors by scalar values of the usual, and not so usual, numeric types:\n\n>>> v1 = Vector([1.0, 2.0, 3.0]) >>> 14 * v1 Vector([14.0, 28.0, 42.0]) >>> v1 * True Vector([1.0, 2.0, 3.0]) >>> from fractions import Fraction >>> v1 * Fraction(1, 3) Vector([0.3333333333333333, 0.6666666666666666, 1.0])\n\nOverloading * for Scalar Multiplication\n\n|\n\n573",
      "content_length": 1539,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 604,
      "content": "Now that we can multiply Vector by scalars, let’s see how to implement Vector by Vector products.\n\nIn the first edition of Fluent Python, I used goose typing in Example 16-11: I checked the scalar argument of __mul__ with isinstance(scalar, numbers.Real). Now I avoid using the num bers ABCs because they are not supported by PEP 484, and using types at runtime that cannot also be statically checked seems a bad idea to me. Alternatively, I could have checked against the typing.Supports Float protocol that we saw in “Runtime Checkable Static Proto‐ cols” on page 468. I chose duck typing in that example because I think fluent Pythonistas should be comfortable with that coding pattern. On the other hand, __matmul__ in Example 16-12 is a good exam‐ ple of goose typing, new in this second edition.\n\nUsing @ as an Infix Operator The @ sign is well-known as the prefix of function decorators, but since 2015, it can also be used as an infix operator. For years, the dot product was written as numpy.dot(a, b) in NumPy. The function call notation makes longer formulas harder to translate from mathematical notation to Python,5 so the numerical comput‐ ing community lobbied for PEP 465—A dedicated infix operator for matrix multipli‐ cation, which was implemented in Python 3.5. Today, you can write a @ b to compute the dot product of two NumPy arrays.\n\nThe @ operator is supported by the special methods __matmul__, __rmatmul__, and __imatmul__, named for “matrix multiplication.” These methods are not used any‐ where in the standard library at this time, but are recognized by the interpreter since Python 3.5, so the NumPy team—and the rest of us—can support the @ operator in user-defined types. The parser was also changed to handle the new operator (a @ b was a syntax error in Python 3.4).\n\nThese simple tests show how @ should work with Vector instances:\n\n>>> va = Vector([1, 2, 3]) >>> vz = Vector([5, 6, 7]) >>> va @ vz == 38.0 # 1*5 + 2*6 + 3*7 True >>> [10, 20, 30] @ vz\n\n5 See “Soapbox” on page 588 for a discussion of the problem.\n\n574\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 2090,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 605,
      "content": "380.0 >>> va @ 3 Traceback (most recent call last): ... TypeError: unsupported operand type(s) for @: 'Vector' and 'int'\n\nExample 16-12 shows the code of the relevant special methods.\n\nExample 16-12. vector_v7.py: operator @ methods\n\nclass Vector: # many methods omitted in book listing\n\ndef __matmul__(self, other): if (isinstance(other, abc.Sized) and isinstance(other, abc.Iterable)): if len(self) == len(other): return sum(a * b for a, b in zip(self, other)) else: raise ValueError('@ requires vectors of equal length.') else: return NotImplemented\n\ndef __rmatmul__(self, other): return self @ other\n\nBoth operands must implement __len__ and __iter__…\n\n…and have the same length to allow…\n\n…a beautiful application of sum, zip, and generator expression.\n\nNew zip() Feature in Python 3.10\n\nThe zip built-in accepts a strict keyword-only optional argument since Python 3.10. When strict=True, the function raises ValueEr ror when the iterables have different lengths. The default is False. This new strict behavior is in line with Python’s fail fast philoso‐ phy. In Example 16-12, I’d replace the inner if with a try/except ValueError and add strict=True to the zip call.\n\nExample 16-12 is a good example of goose typing in practice. If we tested the other operand against Vector, we’d deny users the flexibility of using lists or arrays as operands to @. As long as one operand is a Vector, our @ implementation supports other operands that are instances of abc.Sized and abc.Iterable. Both of these ABCs implement the __subclasshook__, therefore any object providing __len__ and __iter__ satisfies our test—no need to actually subclass those ABCs or even register\n\nUsing @ as an Infix Operator\n\n|\n\n575",
      "content_length": 1706,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 606,
      "content": "with them, as explained in “Structural Typing with ABCs” on page 464. In particular, our Vector class does not subclass either abc.Sized or abc.Iterable, but it does pass the isinstance checks against those ABCs because it has the necessary methods.\n\nLet’s review the arithmetic operators supported by Python, before diving into the special category of “Rich Comparison Operators” on page 577.\n\nWrapping-Up Arithmetic Operators Implementing +, *, and @, we saw the most common patterns for coding infix opera‐ tors. The techniques we described are applicable to all operators listed in Table 16-1 (the in-place operators will be covered in “Augmented Assignment Operators” on page 580).\n\nTable 16-1. Infix operator method names (the in-place operators are used for augmented assignment; comparison operators are in Table 16-2)\n\nOperator\n\n+\n\nForward\n\n__add__\n\nReverse\n\n__radd__\n\nIn-place\n\n__iadd__\n\nDescription Addition or concatenation\n\n\n\n__sub__\n\n__rsub__\n\n__isub__\n\nSubtraction\n\n\n\n__mul__\n\n__rmul__\n\n__imul__\n\nMultiplication or repetition\n\n/\n\n__truediv__\n\n__rtruediv__\n\n__itruediv__\n\nTrue division\n\n//\n\n__floordiv__\n\n__rfloordiv__\n\n__ifloordiv__\n\nFloor division\n\n%\n\n__mod__\n\n__rmod__\n\n__imod__\n\nModulo\n\ndivmod()\n\n**, pow()\n\n__divmod__\n\n__pow__\n\n__rdivmod__\n\n__rpow__\n\n__idivmod__\n\n__ipow__\n\nReturns tuple of floor division quotient and modulo Exponentiationa\n\n@\n\n__matmul__\n\n__rmatmul__\n\n__imatmul__\n\nMatrix multiplication\n\n&\n\n__and__\n\n__rand__\n\n__iand__\n\nBitwise and\n\n|\n\n__or__\n\n__ror__\n\n__ior__\n\nBitwise or\n\n^\n\n__xor__\n\n__rxor__\n\n__ixor__\n\nBitwise xor\n\n<<\n\n__lshift__\n\n__rlshift__\n\n__ilshift__\n\nBitwise shift left\n\n>>\n\n__rshift__\n\n__rrshift__\n\n__irshift__\n\nBitwise shift right\n\na pow takes an optional third argument, modulo: pow(a, b, modulo), also supported by the special methods when invoked directly (e.g., a.__pow__(b, modulo)).\n\nThe rich comparison operators use a different set of rules.\n\n576\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 1941,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 607,
      "content": "Rich Comparison Operators The handling of the rich comparison operators ==, !=, >, <, >=, and <= by the Python interpreter is similar to what we just saw, but differs in two important aspects:\n\nThe same set of methods is used in forward and reverse operator calls. The rules are summarized in Table 16-2. For example, in the case of ==, both the forward and reverse calls invoke __eq__, only swapping arguments; and a forward call to __gt__ is followed by a reverse call to __lt__ with the arguments swapped.\n\nIn the case of == and !=, if the reverse method is missing, or returns NotImplemen ted, Python compares the object IDs instead of raising TypeError.\n\nTable 16-2. Rich comparison operators: reverse methods invoked when the initial method call returns NotImplemented\n\nGroup Equality\n\nInfix operator\n\na == b\n\nForward method call Reverse method call\n\na.__eq__(b)\n\nb.__eq__(a)\n\nFallback Return id(a) == id(b)\n\na != b\n\na.__ne__(b)\n\nb.__ne__(a)\n\nReturn not (a == b)\n\nOrdering a > b\n\na.__gt__(b)\n\nb.__lt__(a)\n\nRaise TypeError\n\na < b\n\na.__lt__(b)\n\nb.__gt__(a)\n\nRaise TypeError\n\na >= b\n\na.__ge__(b)\n\nb.__le__(a)\n\nRaise TypeError\n\na <= b\n\na.__le__(b)\n\nb.__ge__(a)\n\nRaise TypeError\n\nGiven these rules, let’s review and improve the behavior of the Vector.__eq__ method, which was coded as follows in vector_v5.py (Example 12-16):\n\nclass Vector: # many lines omitted\n\ndef __eq__(self, other): return (len(self) == len(other) and all(a == b for a, b in zip(self, other)))\n\nThat method produces the results in Example 16-13.\n\nExample 16-13. Comparing a Vector to a Vector, a Vector2d, and a tuple\n\n>>> va = Vector([1.0, 2.0, 3.0]) >>> vb = Vector(range(1, 4)) >>> va == vb True >>> vc = Vector([1, 2]) >>> from vector2d_v3 import Vector2d >>> v2d = Vector2d(1, 2) >>> vc == v2d\n\nRich Comparison Operators\n\n|\n\n577",
      "content_length": 1806,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 608,
      "content": "True >>> t3 = (1, 2, 3) >>> va == t3 True\n\nTwo Vector instances with equal numeric components compare equal.\n\nA Vector and a Vector2d are also equal if their components are equal.\n\nA Vector is also considered equal to a tuple or any iterable with numeric items of equal value.\n\nThe result in Example 16-13 is probably not desirable. Do we really want a Vector to be considered equal to a tuple containing the same numbers? I have no hard rule about this; it depends on the application context. The “Zen of Python” says:\n\nIn the face of ambiguity, refuse the temptation to guess.\n\nExcessive liberality in the evaluation of operands may lead to surprising results, and programmers hate surprises.\n\nTaking a clue from Python itself, we can see that [1,2] == (1, 2) is False. There‐ fore, let’s be conservative and do some type checking. If the second operand is a Vector instance (or an instance of a Vector subclass), then use the same logic as the current __eq__. Otherwise, return NotImplemented and let Python handle that. See Example 16-14.\n\nExample 16-14. vector_v8.py: improved __eq__ in the Vector class\n\ndef __eq__(self, other): if isinstance(other, Vector): return (len(self) == len(other) and all(a == b for a, b in zip(self, other))) else: return NotImplemented\n\nIf the other operand is an instance of Vector (or of a Vector subclass), perform the comparison as before.\n\nOtherwise, return NotImplemented.\n\nIf you run the tests in Example 16-13 with the new Vector.__eq__ from Example 16-14, what you get now is shown in Example 16-15.\n\n578\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 1585,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 609,
      "content": "Example 16-15. Same comparisons as Example 16-13: last result changed\n\n>>> va = Vector([1.0, 2.0, 3.0]) >>> vb = Vector(range(1, 4)) >>> va == vb True >>> vc = Vector([1, 2]) >>> from vector2d_v3 import Vector2d >>> v2d = Vector2d(1, 2) >>> vc == v2d True >>> t3 = (1, 2, 3) >>> va == t3 False\n\nSame result as before, as expected.\n\nSame result as before, but why? Explanation coming up.\n\nDifferent result; this is what we wanted. But why does it work? Read on…\n\nAmong the three results in Example 16-15, the first one is no news, but the last two were caused by __eq__ returning NotImplemented in Example 16-14. Here is what happens in the example with a Vector and a Vector2d, vc == v2d, step-by-step:\n\n1. To evaluate vc == v2d, Python calls Vector.__eq__(vc, v2d). 2. Vector.__eq__(vc, v2d) verifies that v2d is not a Vector and returns NotImplemented.\n\n3. Python gets the NotImplemented result, so it tries Vector2d.__eq__(v2d, vc). 4. Vector2d.__eq__(v2d, vc) turns both operands into tuples and compares them: the result is True (the code for Vector2d.__eq__ is in Example 11-11).\n\nAs for the comparison va == t3, between Vector and tuple in Example 16-15, the actual steps are:\n\n1. To evaluate va == t3, Python calls Vector.__eq__(va, t3). 2. Vector.__eq__(va, t3) verifies that t3 NotImplemented.\n\n1. To evaluate va == t3, Python calls Vector.__eq__(va, t3). 2. Vector.__eq__(va, t3) verifies that t3 NotImplemented.\n\n3. Python gets the NotImplemented result, so it tries tuple.__eq__(t3, va).\n\nRich Comparison Operators\n\n|\n\n579",
      "content_length": 1535,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 610,
      "content": "4. tuple.__eq__(t3, va) has no NotImplemented.\n\n4. tuple.__eq__(t3, va) has no NotImplemented.\n\nidea what a Vector\n\nis, so\n\n5. In the special case of ==, if the reversed call returns NotImplemented, Python compares object IDs as a last resort.\n\nWe don’t need to implement __ne__ for != because the fallback behavior of __ne__ inherited from object suits us: when __eq__ is defined and does not return NotImple mented, __ne__ returns that result negated.\n\nIn other words, given the same objects we used in Example 16-15, the results for != are consistent:\n\n>>> va != vb False >>> vc != v2d False >>> va != (1, 2, 3) True\n\nThe __ne__ inherited from object works like the following code—except that the original is written in C:6\n\ndef __ne__(self, other): eq_result = self == other if eq_result is NotImplemented: return NotImplemented else: return not eq_result\n\nAfter covering the essentials of infix operator overloading, let’s turn to a different class of operators: the augmented assignment operators.\n\nAugmented Assignment Operators Our Vector class already supports the augmented assignment operators += and *=. That’s because augmented assignment works with immutable receivers by creating new instances and rebinding the lefthand variable.\n\nExample 16-16 shows them in action.\n\nExample 16-16. Using += and *= with Vector instances\n\n>>> v1 = Vector([1, 2, 3]) >>> v1_alias = v1\n\n6 The logic for object.__eq__ and object.__ne__ is in function object_richcompare in Objects/typeobject.c\n\nin the CPython source code.\n\n580\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 1560,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 611,
      "content": ">>> id(v1) 4302860128 >>> v1 += Vector([4, 5, 6]) >>> v1 Vector([5.0, 7.0, 9.0]) >>> id(v1) 4302859904 >>> v1_alias Vector([1.0, 2.0, 3.0]) >>> v1 *= 11 >>> v1 Vector([55.0, 77.0, 99.0]) >>> id(v1) 4302858336\n\nCreate an alias so we can inspect the Vector([1, 2, 3]) object later.\n\nRemember the ID of the initial Vector bound to v1.\n\nPerform augmented addition.\n\nThe expected result…\n\n…but a new Vector was created.\n\nInspect v1_alias to confirm the original Vector was not altered.\n\nPerform augmented multiplication.\n\nAgain, the expected result, but a new Vector was created.\n\nIf a class does not implement the in-place operators listed in Table 16-1, the augmen‐ ted assignment operators work as syntactic sugar: a += b is evaluated exactly as a = a + b. That’s the expected behavior for immutable types, and if you have __add__, then += will work with no additional code.\n\nHowever, if you do implement an in-place operator method such as __iadd__, that method is called to compute the result of a += b. As the name says, those operators are expected to change the lefthand operand in place, and not create a new object as the result.\n\nThe in-place special methods should never be implemented for immutable types like our Vector class. This is fairly obvious, but worth stating anyway.\n\nAugmented Assignment Operators\n\n|\n\n581",
      "content_length": 1325,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 612,
      "content": "To show the code of an in-place operator, we will extend the BingoCage class from Example 13-9 to implement __add__ and __iadd__.\n\nWe’ll call the subclass AddableBingoCage. Example 16-17 is the behavior we want for the + operator.\n\nExample 16-17. The + operator creates a new AddableBingoCage instance\n\n>>> vowels = 'AEIOU' >>> globe = AddableBingoCage(vowels) >>> globe.inspect() ('A', 'E', 'I', 'O', 'U') >>> globe.pick() in vowels True >>> len(globe.inspect()) 4 >>> globe2 = AddableBingoCage('XYZ') >>> globe3 = globe + globe2 >>> len(globe3.inspect()) 7 >>> void = globe + [10, 20] Traceback (most recent call last): ... TypeError: unsupported operand type(s) for +: 'AddableBingoCage' and 'list'\n\nCreate a globe instance with five items (each of the vowels).\n\nPop one of the items, and verify it is one of the vowels.\n\nConfirm that the globe is down to four items.\n\nCreate a second instance, with three items.\n\nCreate a third instance by adding the previous two. This instance has seven items.\n\nAttempting to add an AddableBingoCage to a list fails with TypeError. That error message is produced by the Python interpreter when our __add__ method returns NotImplemented.\n\nBecause an AddableBingoCage is mutable, Example 16-18 shows how it will work when we implement __iadd__.\n\n582\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 1323,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 613,
      "content": "Example 16-18. An existing AddableBingoCage can be loaded with += (continuing from Example 16-17)\n\n>>> globe_orig = globe >>> len(globe.inspect()) 4 >>> globe += globe2 >>> len(globe.inspect()) 7 >>> globe += ['M', 'N'] >>> len(globe.inspect()) 9 >>> globe is globe_orig True >>> globe += 1 Traceback (most recent call last): ... TypeError: right operand in += must be 'Tombola' or an iterable\n\nCreate an alias so we can check the identity of the object later.\n\nglobe has four items here.\n\nAn AddableBingoCage instance can receive items from another instance of the same class.\n\nThe righthand operand of += can also be any iterable.\n\nThroughout this example, globe has always referred to the same object as globe_orig.\n\nTrying to add a noniterable to an AddableBingoCage fails with a proper error message.\n\nNote that the += operator is more liberal than + with regard to the second operand. With +, we want both operands to be of the same type (AddableBingoCage, in this case), because if we accepted different types, this might cause confusion as to the type of the result. With the +=, the situation is clearer: the lefthand object is updated in place, so there’s no doubt about the type of the result.\n\nI validated the contrasting behavior of + and += by observing how the list built-in type works. Writing my_list + x, you can only concatenate one list to another list, but if you write my_list += x, you can extend the lefthand list with items from any iterable x on the righthand side. This is how the list.extend() method works: it accepts any iterable argument.\n\nAugmented Assignment Operators\n\n|\n\n583",
      "content_length": 1609,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 614,
      "content": "Now that we are clear on the desired behavior for AddableBingoCage, we can look at its implementation in Example 16-19. Recall that BingoCage, from Example 13-9, is a concrete subclass of the Tombola ABC from Example 13-7.\n\nExample 16-19. bingoaddable.py: AddableBingoCage extends BingoCage to support + and +=\n\nfrom tombola import Tombola from bingo import BingoCage\n\nclass AddableBingoCage(BingoCage):\n\ndef __add__(self, other): if isinstance(other, Tombola): return AddableBingoCage(self.inspect() + other.inspect()) else: return NotImplemented\n\ndef __iadd__(self, other): if isinstance(other, Tombola): other_iterable = other.inspect() else: try: other_iterable = iter(other) except TypeError: msg = ('right operand in += must be ' \"'Tombola' or an iterable\") raise TypeError(msg) self.load(other_iterable) return self\n\nAddableBingoCage extends BingoCage.\n\nOur __add__ will only work with an instance of Tombola as the second operand.\n\nIn __iadd__, retrieve items from other, if it is an instance of Tombola.\n\nOtherwise, try to obtain an iterator over other.7\n\nIf that fails, raise an exception explaining what the user should do. When possi‐ ble, error messages should explicitly guide the user to the solution.\n\n7 The iter built-in function will be covered in the next chapter. Here I could have used tuple(other), and it would work, but at the cost of building a new tuple when all the .load(…) method needs is to iterate over its argument.\n\n584\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 1489,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 615,
      "content": "If we got this far, we can load the other_iterable into self.\n\nVery important: augmented assignment special methods of mutable objects must return self. That’s what users expect.\n\nWe can summarize the whole idea of in-place operators by contrasting the return statements that produce results in __add__ and __iadd__ in Example 16-19:\n\n__add__\n\nThe result is produced by calling the constructor AddableBingoCage to build a new instance.\n\n__iadd__\n\nThe result is produced by returning self, after it has been modified.\n\nTo wrap up this example, a final observation on Example 16-19: by design, no __radd__ was coded in AddableBingoCage, because there is no need for it. The for‐ ward method __add__ will only deal with righthand operands of the same type, so if Python is trying to compute a + b, where a is an AddableBingoCage and b is not, we return NotImplemented—maybe the class of b can make it work. But if the expression is b + a and b is not an AddableBingoCage, and it returns NotImplemented, then it’s better to let Python give up and raise TypeError because we cannot handle b.\n\nIn general, if a forward infix operator method (e.g., __mul__) is designed to work only with operands of the same type as self, it’s useless to implement the corresponding reverse method (e.g., __rmul__) because that, by definition, will only be invoked when dealing with an operand of a different type.\n\nThis concludes our exploration of operator overloading in Python.\n\nChapter Summary We started this chapter by reviewing some restrictions Python imposes on operator overloading: no redefining of operators in the built-in types themselves, overloading limited to existing operators, with a few operators left out (is, and, or, not).\n\nWe got down to business with the unary operators, implementing __neg__ and __pos__. Next came the infix operators, starting with +, supported by the __add__ method. We saw that unary and infix operators are supposed to produce results by creating new objects, and should never change their operands. To support operations with other types, we return the NotImplemented special value—not an exception— allowing the interpreter to try again by swapping the operands and calling the reverse\n\nChapter Summary\n\n|\n\n585",
      "content_length": 2238,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 616,
      "content": "special method for that operator (e.g., __radd__). The algorithm Python uses to han‐ dle infix operators is summarized in the flowchart in Figure 16-1.\n\nMixing operand types requires detecting operands we can’t handle. In this chapter, we did this in two ways: in the duck typing way, we just went ahead and tried the operation, catching a TypeError exception if it happened; later, in __mul__ and __matmul__, we did it with an explicit isinstance test. There are pros and cons to these approaches: duck typing is more flexible, but explicit type checking is more predictable.\n\nIn general, libraries should leverage duck typing—opening the door for objects regardless of their types, as long as they support the necessary operations. However, Python’s operator dispatch algorithm may produce misleading error messages or unexpected results when combined with duck typing. For this reason, the discipline of type checking using isinstance calls against ABCs is often useful when writing special methods for operator overloading. That’s the technique dubbed goose typing by Alex Martelli—which we saw in “Goose Typing” on page 442. Goose typing is a good compromise between flexibility and safety, because existing or future user- defined types can be declared as actual or virtual subclasses of an ABC. In addition, if an ABC implements the __subclasshook__, then objects pass isinstance checks against that ABC by providing the required methods—no subclassing or registration required.\n\nThe next topic we covered was the rich comparison operators. We implemented == with __eq__ and discovered that Python provides a handy implementation of != in the __ne__ inherited from the object base class. The way Python evaluates these operators along with >, <, >=, and <= is slightly different, with special logic for choos‐ ing the reverse method, and fallback handling for == and !=, which never generate errors because Python compares the object IDs as a last resort.\n\nIn the last section, we focused on augmented assignment operators. We saw that Python handles them by default as a combination of plain operator followed by assignment, that is: a += b is evaluated exactly as a = a + b. That always creates a new object, so it works for mutable or immutable types. For mutable objects, we can implement in-place special methods such as __iadd__ for +=, and alter the value of the lefthand operand. To show this at work, we left behind the immutable Vector class and worked on implementing a BingoCage subclass to support += for adding items to the random pool, similar to the way the list built-in supports += as a short‐ cut for the list.extend() method. While doing this, we discussed how + tends to be stricter than += regarding the types it accepts. For sequence types, + usually requires that both operands are of the same type, while += often accepts any iterable as the righthand operand.\n\n586\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 2934,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 617,
      "content": "Further Reading Guido van Rossum wrote a good defense of operator overloading in “Why operators are useful”. Trey Hunner blogged “Tuple ordering and deep comparisons in Python”, arguing that the rich comparison operators in Python are more flexible and powerful than programmers may realize when coming from other languages.\n\nOperator overloading is one area of Python programming where isinstance tests are common. The best practice around such tests is goose typing, covered in “Goose Typ‐ ing” on page 442. If you skipped that, make sure to read it.\n\nThe main reference for the operator special methods is the “Data Model” chapter of the Python documentation. Another relevant reading is “9.1.2.2. Implementing the arithmetic operations” in the numbers module of The Python Standard Library.\n\nA clever example of operator overloading appeared in the pathlib package, added in Python 3.4. Its Path class overloads the / operator to build filesystem paths from strings, as shown in this example from the documentation:\n\n>>> p = Path('/etc') >>> q = p / 'init.d' / 'reboot' >>> q PosixPath('/etc/init.d/reboot')\n\nAnother nonarithmetic example of operator overloading is in the Scapy library, used to “send, sniff, dissect, and forge network packets.” In Scapy, the / operator builds packets by stacking fields from different network layers. See “Stacking layers” for details.\n\nIf you are about to implement comparison operators, study functools.total_order ing. That is a class decorator that automatically generates methods for all rich com‐ parison operators in any class that defines at least a couple of them. See the functools module docs.\n\nIf you are curious about operator method dispatching in languages with dynamic typing, two seminal readings are “A Simple Technique for Handling Multiple Poly‐ morphism” by Dan Ingalls (member of the original Smalltalk team), and “Arithmetic and Double Dispatching in Smalltalk-80” by Kurt J. Hebel and Ralph Johnson (John‐ son became famous as one of the authors of the original Design Patterns book). Both papers provide deep insight into the power of polymorphism in languages with dynamic typing, like Smalltalk, Python, and Ruby. Python does not use double dis‐ patching for handling operators as described in those articles. The Python algorithm using forward and reverse operators is easier for user-defined classes to support than double dispatching, but requires special handling by the interpreter. In contrast, classic double dispatching is a general technique you can use in Python or any\n\nFurther Reading\n\n|\n\n587",
      "content_length": 2571,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 618,
      "content": "object-oriented language beyond the specific context of infix operators, and in fact Ingalls, Hebel, and Johnson use very different examples to describe it.\n\nThe article, “The C Family of Languages: Interview with Dennis Ritchie, Bjarne Stroustrup, and James Gosling”, from which I quoted the epigraph for this chapter, appeared in Java Report, 5(7), July 2000, and C++ Report, 12(7), July/August 2000, along with two other snippets I used in this chapter’s “Soapbox” (next). If you are into programming language design, do yourself a favor and read that interview.\n\nSoapbox\n\nOperator Overloading: Pros and Cons\n\nJames Gosling, quoted at the start of this chapter, made the conscious decision to leave operator overloading out when he designed Java. In that same interview (“The C Family of Languages: Interview with Dennis Ritchie, Bjarne Stroustrup, and James Gosling”) he says:\n\nProbably about 20 to 30 percent of the population think of operator overloading as the spawn of the devil; somebody has done something with operator overloading that has just really ticked them off, because they’ve used like + for list insertion and it makes life really, really confusing. A lot of that problem stems from the fact that there are only about half a dozen operators you can sensibly overload, and yet there are thousands or millions of operators that people would like to define—so you have to pick, and often the choices conflict with your sense of intuition.\n\nGuido van Rossum picked the middle way in supporting operator overloading: he did not leave the door open for users creating new arbitrary operators like <=> or :-), which prevents a Tower of Babel of custom operators, and allows the Python parser to be simple. Python also does not let you overload the operators of the built-in types, another limitation that promotes readability and predictable performance.\n\nGosling goes on to say:\n\nThen there’s a community of about 10 percent that have actually used operator over‐ loading appropriately and who really care about it, and for whom it’s actually really important; this is almost exclusively people who do numerical work, where the nota‐ tion is very important to appealing to people’s intuition, because they come into it with an intuition about what the + means, and the ability to say “a + b” where a and b are complex numbers or matrices or something really does make sense.\n\nOf course, there are benefits to disallowing operator overloading in a language. I’ve seen the argument that C is better than C++ for systems programming because oper‐ ator overloading in C++ can make costly operations seem trivial. Two successful modern languages that compile to binary executables made opposite choices: Go doesn’t have operator overloading, but Rust does.\n\n588\n\n|\n\nChapter 16: Operator Overloading",
      "content_length": 2809,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 619,
      "content": "But overloaded operators, when used sensibly, do make code easier to read and write. It’s a great feature to have in a modern high-level language.\n\nA Glimpse at Lazy Evaluation\n\nIf you look closely at the traceback in Example 16-9, you’ll see evidence of the lazy evaluation of generator expressions. Example 16-20 is that same traceback, now with callouts.\n\nExample 16-20. Same as Example 16-9\n\n>>> v1 + 'ABC' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"vector_v6.py\", line 329, in __add__ return Vector(a + b for a, b in pairs) File \"vector_v6.py\", line 243, in __init__ self._components = array(self.typecode, components) File \"vector_v6.py\", line 329, in <genexpr> return Vector(a + b for a, b in pairs) TypeError: unsupported operand type(s) for +: 'float' and 'str'\n\nThe Vector call gets a generator expression as its components argument. No problem at this stage.\n\nThe components genexp is passed to the array constructor. Within the array constructor, Python tries to iterate over the genexp, causing the evaluation of the first item a + b. That’s when the TypeError occurs.\n\nThe exception propagates to the Vector constructor call, where it is reported.\n\nThis shows how the generator expression is evaluated at the latest possible moment, and not where it is defined in the source code.\n\nIn contrast, if the Vector constructor was invoked as Vector([a + b for a, b in pairs]), then the exception would happen right there, because the list comprehen‐ sion tried to build a list to be passed as the argument to the Vector() call. The body of Vector.__init__ would not be reached at all.\n\nChapter 17 will cover generator expressions in detail, but I did not want to let this accidental demonstration of their lazy nature go unnoticed.\n\nFurther Reading\n\n|\n\n589",
      "content_length": 1798,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 621,
      "content": "PART IV Control Flow",
      "content_length": 20,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 623,
      "content": "CHAPTER 17 Iterators, Generators, and Classic Coroutines\n\nWhen I see patterns in my programs, I consider it a sign of trouble. The shape of a program should reflect only the problem it needs to solve. Any other regularity in the code is a sign, to me at least, that I’m using abstractions that aren’t powerful enough— often that I’m generating by hand the expansions of some macro that I need to write.\n\n—Paul Graham, Lisp hacker and venture capitalist1\n\nIteration is fundamental to data processing: programs apply computations to data series, from pixels to nucleotides. If the data doesn’t fit in memory, we need to fetch the items lazily—one at a time and on demand. That’s what an iterator does. This chapter shows how the Iterator design pattern is built into the Python language so you never need to code it by hand.\n\nEvery standard collection in Python is iterable. An iterable is an object that provides an iterator, which Python uses to support operations like:\n\nfor loops\n\nList, dict, and set comprehensions\n\nUnpacking assignments\n\nConstruction of collection instances\n\n1 From “Revenge of the Nerds”, a blog post.\n\n593",
      "content_length": 1128,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 624,
      "content": "This chapter covers the following topics:\n\nHow Python uses the iter() built-in function to handle iterable objects\n\nHow to implement the classic Iterator pattern in Python\n\nHow the classic Iterator pattern can be replaced by a generator function or gen‐ erator expression\n\nHow a generator function works in detail, with line-by-line descriptions\n\nLeveraging the general-purpose generator functions in the standard library • Using yield from expressions to combine generators\n\nWhy generators and classic coroutines look alike but are used in very different ways and should not be mixed\n\nWhat’s New in This Chapter “Subgenerators with yield from” on page 632 grew from one to six pages. It now includes simpler experiments demonstrating the behavior of generators with yield from, and an example of traversing a tree data structure, developed step-by-step.\n\nNew sections explain the type hints for Iterable, Iterator, and Generator types.\n\nThe last major section of this chapter, “Classic Coroutines” on page 641, is a 9-page introduction to a topic that filled a 40-page chapter in the first edition. I updated and moved the “Classic Coroutines” chapter to a post in the companion website because it was the most challenging chapter for readers, but its subject matter is less relevant after Python 3.5 introduced native coroutines—which we’ll study in Chapter 21.\n\nWe’ll get started studying how the iter() built-in function makes sequences iterable.\n\nA Sequence of Words We’ll start our exploration of iterables by implementing a Sentence class: you give its constructor a string with some text, and then you can iterate word by word. The first version will implement the sequence protocol, and it’s iterable because all sequences are iterable—as we’ve seen since Chapter 1. Now we’ll see exactly why.\n\nExample 17-1 shows a Sentence class that extracts words from a text by index.\n\nExample 17-1. sentence.py: a Sentence as a sequence of words\n\nimport re import reprlib\n\n594\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 2036,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 625,
      "content": "RE_WORD = re.compile(r'\\w+')\n\nclass Sentence:\n\ndef __init__(self, text): self.text = text self.words = RE_WORD.findall(text)\n\ndef __getitem__(self, index): return self.words[index]\n\ndef __len__(self): return len(self.words)\n\ndef __repr__(self): return 'Sentence(%s)' % reprlib.repr(self.text)\n\n.findall returns a list with all nonoverlapping matches of the regular expres‐ sion, as a list of strings.\n\nself.words holds the result of .findall, so we simply return the word at the given index.\n\nTo complete the sequence protocol, we implement __len__ although it is not needed to make an iterable.\n\nreprlib.repr is a utility function to generate abbreviated string representations of data structures that can be very large.2\n\nBy default, reprlib.repr limits the generated string to 30 characters. See the console session in Example 17-2 to see how Sentence is used.\n\nExample 17-2. Testing iteration on a Sentence instance\n\n>>> s = Sentence('\"The time has come,\" the Walrus said,') >>> s Sentence('\"The time ha... Walrus said,') >>> for word in s: ... print(word) The time has come the\n\n2 We first used reprlib in “Vector Take #1: Vector2d Compatible” on page 399.\n\nA Sequence of Words\n\n|\n\n595",
      "content_length": 1190,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 626,
      "content": "Walrus said >>> list(s) ['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n\nA sentence is created from a string.\n\nNote the output of __repr__ using ... generated by reprlib.repr.\n\nSentence instances are iterable; we’ll see why in a moment.\n\nBeing iterable, Sentence objects can be used as input to build lists and other iterable types.\n\nIn the following pages, we’ll develop other Sentence classes that pass the tests in Example 17-2. However, the implementation in Example 17-1 is different from the others because it’s also a sequence, so you can get words by index:\n\n>>> s[0] 'The' >>> s[5] 'Walrus' >>> s[-1] 'said'\n\nPython programmers know that sequences are iterable. Now we’ll see precisely why.\n\nWhy Sequences Are Iterable: The iter Function Whenever Python needs to iterate over an object x, it automatically calls iter(x).\n\nThe iter built-in function:\n\n1. Checks whether the object implements __iter__, and calls that to obtain an iterator.\n\n2. If __iter__ is not implemented, but __getitem__ is, then iter() creates an iter‐ ator that tries to fetch items by index, starting from 0 (zero).\n\n3. If that fails, Python raises TypeError, usually saying 'C' object is not itera ble, where C is the class of the target object.\n\nThat is why all Python sequences are iterable: by definition, they all implement __getitem__. In fact, the standard sequences also implement __iter__, and yours should too, because iteration via __getitem__ exists for backward compatibility and may be gone in the future—although it is not deprecated as of Python 3.10, and I doubt it will ever be removed.\n\n596\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1661,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 627,
      "content": "As mentioned in “Python Digs Sequences” on page 436, this is an extreme form of duck typing: an object is considered iterable not only when it implements the special method __iter__, but also when it implements __getitem__. Take a look:\n\n>>> class Spam: ... def __getitem__(self, i): ... print('->', i) ... raise IndexError() ... >>> spam_can = Spam() >>> iter(spam_can) <iterator object at 0x10a878f70> >>> list(spam_can) -> 0 [] >>> from collections import abc >>> isinstance(spam_can, abc.Iterable) False\n\nIf a class provides __getitem__, the iter() built-in accepts an instance of that class as iterable and builds an iterator from the instance. Python’s iteration machinery will call __getitem__ with indexes starting from 0, and will take an IndexError as a signal that there are no more items.\n\nNote that although spam_can is iterable (its __getitem__ could provide items), it is not recognized as such by an isinstance against abc.Iterable.\n\nIn the goose-typing approach, the definition for an iterable is simpler but not as flexi‐ ble: an object is considered iterable if it implements the __iter__ method. No sub‐ classing or registration implements the __subclasshook__, as seen in “Structural Typing with ABCs” on page 464. Here is a demonstration:\n\nis required, because abc.Iterable\n\n>>> class GooseSpam: ... def __iter__(self): ... pass ... >>> from collections import abc >>> issubclass(GooseSpam, abc.Iterable) True >>> goose_spam_can = GooseSpam() >>> isinstance(goose_spam_can, abc.Iterable) True\n\nAs of Python 3.10, the most accurate way to check whether an object x is iterable is to call iter(x) and handle a TypeError excep‐ tion if it isn’t. This is more accurate than using isinstance(x, abc.Iterable), because iter(x) also considers legacy __getitem__ method, while the Iterable ABC does not.\n\nthe\n\nWhy Sequences Are Iterable: The iter Function\n\n|\n\n597",
      "content_length": 1877,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 628,
      "content": "Explicitly checking whether an object is iterable may not be worthwhile if right after the check you are going to iterate over the object. After all, when the iteration is attempted on a noniterable, the exception Python raises is clear enough: TypeError: 'C' object is not iterable. If you can do better than just raising TypeError, then do so in a try/except block instead of doing an explicit check. The explicit check may make sense if you are holding on to the object to iterate over it later; in this case, catching the error early makes debugging easier.\n\nThe iter() built-in is more often used by Python itself than by our own code. There’s a second way we can use it, but it’s not widely known.\n\nUsing iter with a Callable We can call iter() with two arguments to create an iterator from a function or any callable object. In this usage, the first argument must be a callable to be invoked repeatedly (with no arguments) to produce values, and the second argument is a sen‐ tinel: a marker value which, when returned by the callable, causes the iterator to raise StopIteration instead of yielding the sentinel.\n\nThe following example shows how to use iter to roll a six-sided die until a 1 is rolled:\n\n>>> def d6(): ... return randint(1, 6) ... >>> d6_iter = iter(d6, 1) >>> d6_iter <callable_iterator object at 0x10a245270> >>> for roll in d6_iter: ... print(roll) ... 4 3 6 3\n\nNote that the iter function here returns a callable_iterator. The for loop in the example may run for a very long time, but it will never display 1, because that is the sentinel value. As usual with iterators, the d6_iter object in the example becomes useless once exhausted. To start over, we must rebuild the iterator by invoking iter() again.\n\nThe documentation for iter includes the following explanation and example code:\n\nOne useful application of the second form of iter() is to build a block-reader. For example, reading fixed-width blocks from a binary database file until the end of file is reached:\n\nfrom functools import partial\n\n598\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 2095,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 629,
      "content": "with open('mydata.db', 'rb') as f: read64 = partial(f.read, 64) for block in iter(read64, b''): process_block(block)\n\nFor clarity, I’ve added the read64 assignment, which is not in the original example. The partial() function is necessary because the callable given to iter() must not require arguments. In the example, an empty bytes object is the sentinel, because that’s what f.read returns when there are no more bytes to read.\n\nThe next section details the relationship between iterables and iterators.\n\nIterables Versus Iterators From the explanation in “Why Sequences Are Iterable: The iter Function” on page 596 we can extrapolate a definition:\n\niterable\n\nAny object from which the iter built-in function can obtain an iterator. Objects implementing an __iter__ method returning an iterator are iterable. Sequences are always iterable, as are objects implementing a __getitem__ method that accepts 0-based indexes.\n\nIt’s important to be clear about the relationship between iterables and iterators: Python obtains iterators from iterables.\n\nHere is a simple for loop iterating over a str. The str 'ABC' is the iterable here. You don’t see it, but there is an iterator behind the curtain:\n\n>>> s = 'ABC' >>> for char in s: ... print(char) ... A B C\n\nIf there was no for statement and we had to emulate the for machinery by hand with a while loop, this is what we’d have to write:\n\n>>> s = 'ABC' >>> it = iter(s) >>> while True: ... try: ... print(next(it)) ... except StopIteration: ... del it ... break ... A\n\nIterables Versus Iterators\n\n|\n\n599",
      "content_length": 1552,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 630,
      "content": "B C\n\nBuild an iterator it from the iterable.\n\nRepeatedly call next on the iterator to obtain the next item.\n\nThe iterator raises StopIteration when there are no further items.\n\nRelease reference to it—the iterator object is discarded.\n\nExit the loop.\n\nStopIteration signals that the iterator is exhausted. This exception is handled inter‐ nally by the iter() built-in that is part of the logic of for loops and other iteration contexts like list comprehensions, iterable unpacking, etc.\n\nPython’s standard interface for an iterator has two methods:\n\n__next__\n\nReturns the next item in the series, raising StopIteration if there are no more.\n\n__iter__\n\nReturns self; this allows iterators to be used where an iterable is expected, for example, in a for loop.\n\nThat interface is formalized in the collections.abc.Iterator ABC, which declares the __next__ abstract method, and subclasses Iterable—where the abstract __iter__ method is declared. See Figure 17-1.\n\nFigure 17-1. The Iterable and Iterator ABCs. Methods in italic are abstract. A con‐ crete Iterable.__iter__ should return a new Iterator instance. A concrete Itera tor must implement __next__. The Iterator.__iter__ method just returns the instance itself.\n\nThe source code for collections.abc.Iterator is in Example 17-3.\n\n600\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1348,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 631,
      "content": "Example 17-3. abc.Iterator class; extracted from Lib/_collections_abc.py\n\nclass Iterator(Iterable):\n\n__slots__ = ()\n\n@abstractmethod def __next__(self): 'Return the next item from the iterator. When exhausted, raise StopIteration' raise StopIteration\n\ndef __iter__(self): return self\n\n@classmethod def __subclasshook__(cls, C): if cls is Iterator: return _check_methods(C, '__iter__', '__next__') return NotImplemented\n\n__subclasshook__ supports structural type checks with isinstance and issub class. We saw it in “Structural Typing with ABCs” on page 464.\n\n_check_methods traverses the __mro__ of the class to check whether the methods are implemented in its base classes. It’s defined in that same Lib/_collec‐ tions_abc.py module. If the methods are implemented, the C class will be recog‐ nized as a virtual subclass of Iterator. In other words, issubclass(C, Iterable) will return True.\n\nThe Iterator ABC abstract method is it.__next__() in Python 3 and it.next() in Python 2. As usual, you should avoid calling spe‐ cial methods directly. Just use the next(it): this built-in function does the right thing in Python 2 and 3—which is useful for those migrating codebases from 2 to 3.\n\nThe Lib/types.py module source code in Python 3.9 has a comment that says:\n\n# Iterators in Python aren't a matter of type but of protocol. A large # and changing number of builtin types implement *some* flavor of # iterator. Don't check the type! Use hasattr to check for both # \"__iter__\" and \"__next__\" attributes instead.\n\nIn fact, that’s exactly what the __subclasshook__ method of the abc.Iterator ABC does.\n\nIterables Versus Iterators\n\n|\n\n601",
      "content_length": 1639,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 632,
      "content": "Given the advice from Lib/types.py and the logic implemented in Lib/_collections_abc.py, the best way to check if an object x is an iterator is to call isinstance(x, abc.Iterator). Thanks to Itera tor.__subclasshook__, this test works even if the class of x is not a real or virtual subclass of Iterator.\n\nBack to our Sentence class from Example 17-1, you can clearly see how the iterator is built by iter() and consumed by next() using the Python console:\n\n>>> s3 = Sentence('Life of Brian') >>> it = iter(s3) >>> it # doctest: +ELLIPSIS <iterator object at 0x...> >>> next(it) 'Life' >>> next(it) 'of' >>> next(it) 'Brian' >>> next(it) Traceback (most recent call last): ... StopIteration >>> list(it) [] >>> list(iter(s3)) ['Life', 'of', 'Brian']\n\nCreate a sentence s3 with three words.\n\nObtain an iterator from s3.\n\nnext(it) fetches the next word.\n\nThere are no more words, so the iterator raises a StopIteration exception.\n\nOnce exhausted, an iterator will always raise StopIteration, which makes it look like it’s empty.\n\nTo go over the sentence again, a new iterator must be built.\n\nBecause the only methods required of an iterator are __next__ and __iter__, there is no way to check whether there are remaining items, other than to call next() and catch StopIteration. Also, it’s not possible to “reset” an iterator. If you need to start over, you need to call iter() on the iterable that built the iterator in the first place. Calling iter() on the iterator itself won’t help either, because—as mentioned—\n\n602\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1581,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 633,
      "content": "Iterator.__iter__ is implemented by returning self, so this will not reset a deple‐ ted iterator.\n\nThat minimal interface is sensible, because in reality not all iterators are resettable. For example, if an iterator is reading packets from the network, there’s no way to rewind it.3\n\nThe first version of Sentence from Example 17-1 was iterable thanks to the special treatment the iter() built-in gives to sequences. Next, we will implement Sentence variations that implement __iter__ to return iterators.\n\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nSentence Take #2: A Classic Iterator The next Sentence implementation follows the blueprint of the classic Iterator design pattern from the Design Patterns book. Note that it is not idiomatic Python, as the next refactorings will make very clear. But it is useful to show the distinction between an iterable collection and an iterator that works with it.\n\nThe Sentence class in Example 17-4 is iterable because it implements the __iter__ special method, which builds and returns a SentenceIterator. That’s how an itera‐ ble and an iterator are related.\n\nExample 17-4. sentence_iter.py: Sentence implemented using the Iterator pattern\n\nimport re import reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\nclass Sentence:\n\ndef __init__(self, text): self.text = text self.words = RE_WORD.findall(text)\n\ndef __repr__(self): return f'Sentence({reprlib.repr(self.text)})'\n\n3 Thanks to tech reviewer Leonardo Rochael for this fine example.\n\nSentence Classes with __iter__\n\n|\n\n603",
      "content_length": 1658,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 634,
      "content": "def __iter__(self): return SentenceIterator(self.words)\n\nclass SentenceIterator:\n\ndef __init__(self, words): self.words = words self.index = 0\n\ndef __next__(self): try: word = self.words[self.index] except IndexError: raise StopIteration() self.index += 1 return word\n\ndef __iter__(self): return self\n\nThe __iter__ method is the only addition to the previous Sentence implemen‐ tation. This version has no __getitem__, to make it clear that the class is iterable because it implements __iter__.\n\n__iter__ fulfills the iterable protocol by instantiating and returning an iterator.\n\nSentenceIterator holds a reference to the list of words.\n\nself.index determines the next word to fetch.\n\nGet the word at self.index.\n\nIf there is no word at self.index, raise StopIteration.\n\nIncrement self.index.\n\nReturn the word.\n\nImplement self.__iter__.\n\nThe code in Example 17-4 passes the tests in Example 17-2.\n\nNote that implementing __iter__ in SentenceIterator is not actually needed for this example to work, but it is the right thing to do: iterators are supposed to implement both __next__ and __iter__, and doing so makes our iterator pass the issubclass(SentenceIterator, abc.Iterator) test. If we had subclassed\n\n604\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1274,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 635,
      "content": "SentenceIterator from abc.Iterator, we’d inherit the concrete abc.Itera tor.__iter__ method.\n\nThat is a lot of work (for us spoiled Python programmers, anyway). Note how most code in SentenceIterator deals with managing the internal state of the iterator. Soon we’ll see how to avoid that bookkeeping. But first, a brief detour to address an implementation shortcut that may be tempting, but is just wrong.\n\nDon’t Make the Iterable an Iterator for Itself A common cause of errors in building iterables and iterators is to confuse the two. To be clear: iterables have an __iter__ method that instantiates a new iterator every time. Iterators implement a __next__ method that returns individual items, and an __iter__ method that returns self.\n\nTherefore, iterators are also iterable, but iterables are not iterators.\n\nIt may be tempting to implement __next__ in addition to __iter__ in the Sentence class, making each Sentence instance at the same time an iterable and iterator over itself. But this is rarely a good idea. It’s also a common antipattern, according to Alex Martelli who has a lot of experience reviewing Python code at Google.\n\nThe “Applicability” section about the Iterator design pattern in the Design Patterns book says:\n\nUse the Iterator pattern\n\nto access an aggregate object’s contents without exposing representation.\n\nto support multiple traversals of aggregate objects.\n\nto provide a uniform interface for traversing different aggregate structures (that is, to support polymorphic iteration).\n\nTo “support multiple traversals,” it must be possible to obtain multiple independent iterators from the same iterable instance, and each iterator must keep its own internal state, so a proper implementation of the pattern requires each call to iter(my_itera ble) to create a new, independent, iterator. That is why we need the SentenceItera tor class in this example.\n\nNow that the classic Iterator pattern is properly demonstrated, we can let it go. Python incorporated the yield keyword from Barbara Liskov’s CLU language, so we don’t need to “generate by hand” the code to implement iterators.\n\nThe next sections present more idiomatic versions of Sentence.\n\nSentence Classes with __iter__\n\n|\n\n605",
      "content_length": 2218,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 636,
      "content": "Sentence Take #3: A Generator Function A Pythonic implementation of the same functionality uses a generator, avoiding all the work to implement the SentenceIterator class. A proper explanation of the gen‐ erator comes right after Example 17-5.\n\nExample 17-5. sentence_gen.py: Sentence implemented using a generator\n\nimport re import reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\nclass Sentence:\n\ndef __init__(self, text): self.text = text self.words = RE_WORD.findall(text)\n\ndef __repr__(self): return 'Sentence(%s)' % reprlib.repr(self.text)\n\ndef __iter__(self): for word in self.words: yield word\n\n# done!\n\nIterate over self.words.\n\nYield the current word.\n\nExplicit return is not necessary; the function can just “fall through” and return automatically. Either way, a generator function doesn’t raise StopIteration: it simply exits when it’s done producing values.4\n\nNo need for a separate iterator class!\n\n4 When reviewing this code, Alex Martelli suggested the body of this method could simply be return\n\niter(self.words). He is right: the result of calling self.words.__iter__() would also be an iterator, as it should be. However, I used a for loop with yield here to introduce the syntax of a generator function, which requires the yield keyword, as we’ll see in the next section. During review of the second edition of this book, Leonardo Rochael suggested yet another shortcut for the body of __iter__: yield from self.words. We’ll also cover yield from later in this chapter.\n\n606\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1546,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 637,
      "content": "Here again we have a different implementation of Sentence that passes the tests in Example 17-2.\n\nBack in the Sentence code in Example 17-4, __iter__ called the SentenceIterator constructor to build an iterator and return it. Now the iterator in Example 17-5 is in fact a generator object, built automatically when the __iter__ method is called, because __iter__ here is a generator function.\n\nA full explanation of generators follows.\n\nHow a Generator Works Any Python function that has the yield keyword in its body is a generator function: a function which, when called, returns a generator object. In other words, a generator function is a generator factory.\n\nThe only syntax distinguishing a plain function from a generator function is the fact that the latter has a yield keyword somewhere in its body. Some argued that a new keyword like gen should be used instead of def to declare generator functions, but Guido did not agree. His arguments are in PEP 255 — Simple Generators.5\n\nExample 17-6 shows the behavior of a simple generator function.6\n\nExample 17-6. A generator function that yields three numbers\n\n>>> def gen_123(): ... yield 1 ... yield 2 ... yield 3 ... >>> gen_123 # doctest: +ELLIPSIS <function gen_123 at 0x...> >>> gen_123() # doctest: +ELLIPSIS <generator object gen_123 at 0x...> >>> for i in gen_123(): ... print(i) 1 2\n\n5 Sometimes I add a gen prefix or suffix when naming generator functions, but this is not a common practice. And you can’t do that if you’re implementing an iterable, of course: the necessary special method must be named __iter__.\n\n6 Thanks to David Kwast for suggesting this example.\n\nSentence Classes with __iter__\n\n|\n\n607",
      "content_length": 1673,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 638,
      "content": "3 >>> g = gen_123() >>> next(g) 1 >>> next(g) 2 >>> next(g) 3 >>> next(g) Traceback (most recent call last): ... StopIteration\n\nThe body of a generator function often has yield inside a loop, but not necessar‐ ily; here I just repeat yield three times.\n\nLooking closely, we see gen_123 is a function object.\n\nBut when invoked, gen_123() returns a generator object.\n\nGenerator objects implement the Iterator interface, so they are also iterable.\n\nWe assign this new generator object to g, so we can experiment with it.\n\nBecause g is an iterator, calling next(g) fetches the next item produced by yield.\n\nWhen the generator function returns, the generator object raises StopIteration.\n\nA generator function builds a generator object that wraps the body of the function. When we invoke next() on the generator object, execution advances to the next yield in the function body, and the next() call evaluates to the value yielded when the function body is suspended. Finally, the enclosing generator object created by Python raises StopIteration when the function body returns, in accordance with the Iterator protocol.\n\nI find it helpful to be rigorous when talking about values obtained from a generator. It’s confusing to say a generator “returns” values. Functions return values. Calling a generator function returns a generator. A generator yields values. A generator doesn’t “return” values in the usual way: the return statement in the body of a gen‐ erator function causes StopIteration to be raised by the generator object. If you return x in the generator, the caller can retrieve the value of x from the StopIteration exception, but usually that is done automatically using the yield from syntax, as we’ll see in “Returning a Value from a Coroutine” on page 646.\n\n608\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1835,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 639,
      "content": "Example 17-7 makes the interaction between a for loop and the body of the function more explicit.\n\nExample 17-7. A generator function that prints messages when it runs\n\n>>> def gen_AB(): ... print('start') ... yield 'A' ... print('continue') ... yield 'B' ... print('end.') ... >>> for c in gen_AB(): ... print('-->', c) ... start --> A continue --> B end. >>>\n\nThe first implicit call to next() in the for loop at at the first yield, producing the value 'A'.\n\nwill print 'start' and stop\n\nThe second implicit call to next() in the for loop will print 'continue' and stop at the second yield, producing the value 'B'.\n\nThe third call to next() will print 'end.' and fall through the end of the func‐ tion body, causing the generator object to raise StopIteration.\n\nTo iterate, the for machinery does the equivalent of g = iter(gen_AB()) to get a generator object, and then next(g) at each iteration.\n\nThe loop prints --> and the value returned by next(g). This output will appear only after the output of the print calls inside the generator function.\n\nThe text start comes from print('start') in the generator body.\n\nyield 'A' in the generator body yields the value A consumed by the for loop, which gets assigned to the c variable and results in the output --> A.\n\nIteration continues with a second call to next(g), advancing the generator body from yield 'A' to yield 'B'. The text continue is output by the second print in the generator body.\n\nSentence Classes with __iter__\n\n|\n\n609",
      "content_length": 1486,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 640,
      "content": "yield 'B' yields the value B consumed by the for loop, which gets assigned to the c loop variable, so the loop prints --> B.\n\nIteration continues with a third call to next(it), advancing to the end of the body of the function. The text end. appears in the output because of the third print in the generator body.\n\nWhen the generator function runs to the end, the generator object raises StopIt eration. The for loop machinery catches that exception, and the loop termi‐ nates cleanly.\n\nNow hopefully it’s clear how Sentence.__iter__ in Example 17-5 works: __iter__ is a generator function which, when called, builds a generator object that implements the Iterator interface, so the SentenceIterator class is no longer needed.\n\nThat second version of Sentence is more concise than the first, but it’s not as lazy as it could be. Nowadays, laziness is considered a good trait, at least in programming languages and APIs. A lazy implementation postpones producing values to the last possible moment. This saves memory and may avoid wasting CPU cycles, too.\n\nWe’ll build lazy Sentence classes next.\n\nLazy Sentences The final variations of Sentence are lazy, taking advantage of a lazy function from the re module.\n\nSentence Take #4: Lazy Generator The Iterator interface is designed to be lazy: next(my_iterator) yields one item at a time. The opposite of lazy is eager: lazy evaluation and eager evaluation are techni‐ cal terms in programming language theory.\n\nOur Sentence implementations so far have not been lazy because the __init__ eagerly builds a list of all words in the text, binding it to the self.words attribute. This requires processing the entire text, and the list may use as much memory as the text itself (probably more; it depends on how many nonword characters are in the text). Most of this work will be in vain if the user only iterates over the first couple of words. If you wonder, “Is there a lazy way of doing this in Python?” the answer is often “Yes.”\n\nThe re.finditer function is a lazy version of re.findall. Instead of a list, re.fin diter returns a generator yielding re.MatchObject instances on demand. If there are many matches, re.finditer saves a lot of memory. Using it, our third version of\n\n610\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 2292,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 641,
      "content": "Sentence is now lazy: it only reads the next word from the text when it is needed. The code is in Example 17-8.\n\nExample 17-8. sentence_gen2.py: Sentence implemented using a generator function calling the re.finditer generator function\n\nimport re import reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\nclass Sentence:\n\ndef __init__(self, text): self.text = text\n\ndef __repr__(self): return f'Sentence({reprlib.repr(self.text)})'\n\ndef __iter__(self): for match in RE_WORD.finditer(self.text): yield match.group()\n\nNo need to have a words list.\n\nfinditer builds an iterator over the matches of RE_WORD on self.text, yielding MatchObject instances.\n\nmatch.group() extracts the matched text from the MatchObject instance.\n\nGenerators are a great shortcut, but the code can be made even more concise with a generator expression.\n\nSentence Take #5: Lazy Generator Expression We can replace simple generator functions like the one in the previous Sentence class (Example 17-8) with a generator expression. As a list comprehension builds lists, a generator expression builds generator objects. Example 17-9 contrasts their behavior.\n\nExample 17-9. The gen_AB generator function is used by a list comprehension, then by a generator expression\n\n>>> def gen_AB(): ... print('start') ... yield 'A'\n\nLazy Sentences\n\n|\n\n611",
      "content_length": 1300,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 642,
      "content": "... print('continue') ... yield 'B' ... print('end.') ... >>> res1 = [x*3 for x in gen_AB()] start continue end. >>> for i in res1: ... print('-->', i) ... --> AAA --> BBB >>> res2 = (x*3 for x in gen_AB()) >>> res2 <generator object <genexpr> at 0x10063c240> >>> for i in res2: ... print('-->', i) ... start --> AAA continue --> BBB end.\n\nThis is the same gen_AB function from Example 17-7.\n\nThe list comprehension eagerly iterates over the items yielded by the generator object returned by gen_AB(): 'A' and 'B'. Note the output in the next lines: start, continue, end.\n\nThis for loop iterates over the res1 list built by the list comprehension.\n\nThe generator expression returns res2, a generator object. The generator is not consumed here.\n\nOnly when the for loop iterates over res2, this generator gets items from gen_AB. Each iteration of the for loop implicitly calls next(res2), which in turn calls next() on the generator object returned by gen_AB(), advancing it to the next yield.\n\nNote how the output of gen_AB() interleaves with the output of the print in the for loop.\n\nWe can use a generator expression to further reduce the code in the Sentence class. See Example 17-10.\n\n612\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1253,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 643,
      "content": "Example 17-10. sentence_genexp.py: Sentence implemented using a generator expression\n\nimport re import reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\nclass Sentence:\n\ndef __init__(self, text): self.text = text\n\ndef __repr__(self): return f'Sentence({reprlib.repr(self.text)})'\n\ndef __iter__(self): return (match.group() for match in RE_WORD.finditer(self.text))\n\nThe only difference from Example 17-8 is the __iter__ method, which here is not a generator function (it has no yield) but uses a generator expression to build a gener‐ ator and then returns it. The end result is the same: the caller of __iter__ gets a gen‐ erator object.\n\nGenerator expressions are syntactic sugar: they can always be replaced by generator functions, but sometimes are more convenient. The next section is about generator expression usage.\n\nWhen to Use Generator Expressions I used several generator expressions when implementing the Vector class in Example 12-16. Each of these methods has a generator expression: __eq__, __hash__, __abs__, angle, angles, format, __add__, and __mul__. In all those methods, a list comprehension would also work, at the cost of using more memory to store the inter‐ mediate list values.\n\nIn Example 17-10, we saw that a generator expression is a syntactic shortcut to create a generator without defining and calling a function. On the other hand, generator functions are more flexible: we can code complex logic with multiple statements, and we can even use them as coroutines, as we’ll see in “Classic Coroutines” on page 641.\n\nFor the simpler cases, a generator expression is easier to read at a glance, as the Vector example shows.\n\nMy rule of thumb in choosing the syntax to use is simple: if the generator expression spans more than a couple of lines, I prefer to code a generator function for the sake of readability.\n\nWhen to Use Generator Expressions\n\n|\n\n613",
      "content_length": 1873,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 644,
      "content": "Syntax Tip\n\nWhen a generator expression is passed as the single argument to a function or constructor, you don’t need to write a set of parenthe‐ ses for the function call and another to enclose the generator expression. A single pair will do, like in the Vector call from the __mul__ method in Example 12-16, reproduced here:\n\ndef __mul__(self, scalar): if isinstance(scalar, numbers.Real): return Vector(n * scalar for n in self) else: return NotImplemented\n\nHowever, if there are more function arguments after the generator expression, you need to enclose it in parentheses to avoid a Syntax Error.\n\nThe Sentence examples we’ve seen demonstrate generators playing the role of the classic Iterator pattern: retrieving items from a collection. But we can also use genera‐ tors to yield values independent of a data source. The next section shows an example.\n\nBut first, a short discussion on the overlapping concepts of iterator and generator.\n\nContrasting Iterators and Generators In the official Python documentation and codebase, the terminology around iterators and generators is inconsistent and evolving. I’ve adopted the following definitions:\n\niterator\n\nGeneral term for any object that implements a __next__ method. Iterators are designed to produce data that is consumed by the client code, i.e., the code that drives the iterator via a for loop or other iterative feature, or by explicitly calling next(it) on the iterator—although this explicit usage is much less common. In practice, most iterators we use in Python are generators.\n\ngenerator\n\nAn iterator built by the Python compiler. To create a generator, we don’t imple‐ ment __next__. Instead, we use the yield keyword to make a generator function, which is a factory of generator objects. A generator expression is another way to build a generator object. Generator objects provide __next__, so they are itera‐ tors. Since Python 3.5, we also have asynchronous generators declared with async def. We’ll study them in Chapter 21, “Asynchronous Programming”.\n\nThe Python Glossary recently introduced the term generator iterator to refer to gener‐ ator objects built by generator functions, while the entry for generator expression says it returns an “iterator.”\n\n614\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 2296,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 645,
      "content": "But the objects returned in both cases are generator objects, according to Python:\n\n>>> def g(): ... yield 0 ... >>> g() <generator object g at 0x10e6fb290> >>> ge = (c for c in 'XYZ') >>> ge <generator object <genexpr> at 0x10e936ce0> >>> type(g()), type(ge) (<class 'generator'>, <class 'generator'>)\n\nAn Arithmetic Progression Generator The classic Iterator pattern is all about traversal: navigating some data structure. But a standard interface based on a method to fetch the next item in a series is also useful when the items are produced on the fly, instead of retrieved from a collection. For example, the range built-in generates a bounded arithmetic progression (AP) of inte‐ gers. What if you need to generate an AP of numbers of any type, not only integers?\n\nExample 17-11 shows a few console tests of an ArithmeticProgression class we will see in a moment. The signature of the constructor in Example 17-11 is Arithmetic Progression(begin, step[, end]). The complete signature of the range built-in is range(start, stop[, step]). I chose to implement a different signature because the step is mandatory but end is optional in an arithmetic progression. I also changed the argument names from start/stop to begin/end to make it clear that I opted for a different signature. In each test in Example 17-11, I call list() on the result to inspect the generated values.\n\nExample 17-11. Demonstration of an ArithmeticProgression class\n\n>>> ap = ArithmeticProgression(0, 1, 3) >>> list(ap) [0, 1, 2] >>> ap = ArithmeticProgression(1, .5, 3) >>> list(ap) [1.0, 1.5, 2.0, 2.5] >>> ap = ArithmeticProgression(0, 1/3, 1) >>> list(ap) [0.0, 0.3333333333333333, 0.6666666666666666] >>> from fractions import Fraction >>> ap = ArithmeticProgression(0, Fraction(1, 3), 1) >>> list(ap) [Fraction(0, 1), Fraction(1, 3), Fraction(2, 3)] >>> from decimal import Decimal >>> ap = ArithmeticProgression(0, Decimal('.1'), .3)\n\nAn Arithmetic Progression Generator\n\n|\n\n615",
      "content_length": 1962,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 646,
      "content": ">>> list(ap) [Decimal('0'), Decimal('0.1'), Decimal('0.2')]\n\nNote that the type of the numbers in the resulting arithmetic progression follows the type of begin + step, according to the numeric coercion rules of Python arithmetic. In Example 17-11, you see lists of int, float, Fraction, and Decimal numbers. Example 17-12 lists the implementation of the ArithmeticProgression class.\n\nExample 17-12. The ArithmeticProgression class\n\nclass ArithmeticProgression:\n\ndef __init__(self, begin, step, end=None): self.begin = begin self.step = step self.end = end # None -> \"infinite\" series\n\ndef __iter__(self): result_type = type(self.begin + self.step) result = result_type(self.begin) forever = self.end is None index = 0 while forever or result < self.end: yield result index += 1 result = self.begin + self.step * index\n\n__init__ requires two arguments: begin and step; end is optional, if it’s None, the series will be unbounded.\n\nGet the type of adding self.begin and self.step. For example, if one is int and the other is float, result_type will be float.\n\nThis line makes a result with the same numeric value of self.begin, but coerced to the type of the subsequent additions.7\n\nFor readability, the forever flag will be True if the self.end attribute is None, resulting in an unbounded series.\n\n7 In Python 2, there was a coerce() built-in function, but it’s gone in Python 3. It was deemed unnecessary\n\nbecause the numeric coercion rules are implicit in the arithmetic operator methods. So the best way I could think of to coerce the initial value to be of the same type as the rest of the series was to perform the addition and use its type to convert the result. I asked about this in the Python-list and got an excellent response from Steven D’Aprano.\n\n616\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1826,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 647,
      "content": "This loop runs forever or until the result matches or exceeds self.end. When this loop exits, so does the function.\n\nThe current result is produced.\n\nThe next potential result is calculated. It may never be yielded, because the while loop may terminate.\n\nIn the last line of Example 17-12, instead of adding self.step to the previous result each time around the loop, I opted to ignore the previous result and each new result by adding self.begin to self.step multiplied by index. This avoids the cumulative effect of floating-point errors after successive additions. These simple experiments make the difference clear:\n\n>>> 100 * 1.1 110.00000000000001 >>> sum(1.1 for _ in range(100)) 109.99999999999982 >>> 1000 * 1.1 1100.0 >>> sum(1.1 for _ in range(1000)) 1100.0000000000086\n\nThe ArithmeticProgression class from Example 17-12 works as intended, and is a another example of using a generator function to implement the __iter__ special method. However, if the whole point of a class is to build a generator by implement‐ ing __iter__, we can replace the class with a generator function. A generator function is, after all, a generator factory.\n\nExample 17-13 shows a generator function called aritprog_gen that does the same job as ArithmeticProgression but with less code. The tests in Example 17-11 all pass if you just call aritprog_gen instead of ArithmeticProgression.8\n\nExample 17-13. The aritprog_gen generator function\n\ndef aritprog_gen(begin, step, end=None): result = type(begin + step)(begin) forever = end is None index = 0 while forever or result < end: yield result index += 1 result = begin + step * index\n\n8 The 17-it-generator/ directory in the Fluent Python code repository includes doctests and a script, arit‐\n\nprog_runner.py, which runs the tests against all variations of the aritprog*.py scripts.\n\nAn Arithmetic Progression Generator\n\n|\n\n617",
      "content_length": 1869,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 648,
      "content": "Example 17-13 is elegant, but always remember: there are plenty of ready-to-use gen‐ erators in the standard library, and the next section will show a shorter implementa‐ tion using the itertools module.\n\nArithmetic Progression with itertools The itertools module in Python 3.10 has 20 generator functions that can be com‐ bined in a variety of interesting ways.\n\nFor example, the itertools.count function returns a generator that yields numbers. Without arguments, it yields a series of integers starting with 0. But you can provide optional start and step values to achieve a result similar to our aritprog_gen functions:\n\n>>> import itertools >>> gen = itertools.count(1, .5) >>> next(gen) 1 >>> next(gen) 1.5 >>> next(gen) 2.0 >>> next(gen) 2.5\n\nitertools.count never stops, so if you call list(count()), Python will try to build a list that would fill all the memory chips ever made. In practice, your machine will become very grumpy long before the call fails.\n\nOn the other hand, there is the itertools.takewhile function: it returns a generator that consumes another generator and stops when a given predicate evaluates to False. So we can combine the two and write this:\n\n>>> gen = itertools.takewhile(lambda n: n < 3, itertools.count(1, .5)) >>> list(gen) [1, 1.5, 2.0, 2.5]\n\nLeveraging takewhile and count, Example 17-14 is even more concise.\n\nExample 17-14. aritprog_v3.py: this works like the previous aritprog_gen functions\n\nimport itertools\n\ndef aritprog_gen(begin, step, end=None): first = type(begin + step)(begin) ap_gen = itertools.count(first, step)\n\n618\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1636,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 649,
      "content": "if end is None: return ap_gen return itertools.takewhile(lambda n: n < end, ap_gen)\n\nNote that aritprog_gen in Example 17-14 is not a generator function: it has no yield in its body. But it returns a generator, just as a generator function does.\n\nHowever, recall that itertools.count adds the step repeatedly, so the floating-point series it produces are not as precise as Example 17-13.\n\nThe point of Example 17-14 is: when implementing generators, know what is avail‐ able in the standard library, otherwise there’s a good chance you’ll reinvent the wheel. That’s why the next section covers several ready-to-use generator functions.\n\nGenerator Functions in the Standard Library The standard library provides many generators, from plain-text file objects providing line-by-line iteration, to the awesome os.walk function, which yields filenames while traversing a directory tree, making recursive filesystem searches as simple as a for loop.\n\nThe os.walk generator function is impressive, but in this section I want to focus on general-purpose functions that take arbitrary iterables as arguments and return gen‐ erators that yield selected, computed, or rearranged items. In the following tables, I summarize two dozen of them, from the built-in, itertools, and functools mod‐ ules. For convenience, I grouped them by high-level functionality, regardless of where they are defined.\n\nThe first group contains the filtering generator functions: they yield a subset of items produced by the input iterable, without changing the items themselves. Like take while, most functions listed in Table 17-1 take a predicate, which is a one-argument Boolean function that will be applied to each item in the input to determine whether the item is included in the output.\n\nTable 17-1. Filtering generator functions\n\nModule\n\nFunction\n\nitertools compress(it, selector_it)\n\nDescription Consumes two iterables in parallel; yields items from it whenever the corresponding item in selector_it is truthy\n\nitertools dropwhile(predicate, it)\n\nConsumes it, skipping items while predicate computes truthy, then yields every remaining item (no further checks are made)\n\n(built-in)\n\nfilter(predicate, it)\n\nApplies predicate to each item of iterable, yielding the item if predicate(item) is truthy; if predicate is None, only truthy items are yielded\n\nGenerator Functions in the Standard Library\n\n|\n\n619",
      "content_length": 2379,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 650,
      "content": "Module\n\nFunction\n\nitertools filterfalse(predicate, it)\n\nDescription Same as filter, with the predicate logic negated: yields items whenever predicate computes falsy\n\nitertools islice(it, stop) or\n\nislice(it, start, stop, step=1)\n\nYields items from a slice of it, similar to s[:stop] or s[start:stop:step] except it can be any iterable, and the operation is lazy\n\nitertools takewhile(predicate, it)\n\nYields items while predicate computes truthy, then stops and no further checks are made\n\nThe console listing in Example 17-15 shows the use of all the functions in Table 17-1.\n\nExample 17-15. Filtering generator functions examples\n\n>>> def vowel(c): ... return c.lower() in 'aeiou' ... >>> list(filter(vowel, 'Aardvark')) ['A', 'a', 'a'] >>> import itertools >>> list(itertools.filterfalse(vowel, 'Aardvark')) ['r', 'd', 'v', 'r', 'k'] >>> list(itertools.dropwhile(vowel, 'Aardvark')) ['r', 'd', 'v', 'a', 'r', 'k'] >>> list(itertools.takewhile(vowel, 'Aardvark')) ['A', 'a'] >>> list(itertools.compress('Aardvark', (1, 0, 1, 1, 0, 1))) ['A', 'r', 'd', 'a'] >>> list(itertools.islice('Aardvark', 4)) ['A', 'a', 'r', 'd'] >>> list(itertools.islice('Aardvark', 4, 7)) ['v', 'a', 'r'] >>> list(itertools.islice('Aardvark', 1, 7, 2)) ['a', 'd', 'a']\n\nThe next group contains the mapping generators: they yield items computed from each individual item in the input iterable—or iterables, in the case of map and star map.9 The generators in Table 17-2 yield one result per item in the input iterables. If the input comes from more than one iterable, the output stops as soon as the first input iterable is exhausted.\n\n9 Here, the term “mapping” is unrelated to dictionaries, but has to do with the map built-in.\n\n620\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1771,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 651,
      "content": "Table 17-2. Mapping generator functions\n\nModule\n\nFunction\n\nitertools accumulate(it,\n\n[func])\n\nDescription Yields accumulated sums; if func is provided, yields the result of applying it to the first pair of items, then to the first result and next item, etc.\n\n(built-in)\n\nenumerate(iterable, start=0)\n\nYields 2-tuples of the form (index, item), where index is counted from start, and item is taken from the iterable\n\n(built-in)\n\nmap(func, it1, [it2, …, itN])\n\nApplies func to each item of it, yielding the result; if N iterables are given, func must take N arguments and the iterables will be consumed in parallel\n\nitertools starmap(func, it)\n\nApplies func to each item of it, yielding the result; the input iterable should yield iterable items iit, and func is applied as func(*iit)\n\nExample 17-16 demonstrates some uses of itertools.accumulate.\n\nExample 17-16. itertools.accumulate generator function examples\n\n>>> sample = [5, 4, 2, 8, 7, 6, 3, 0, 9, 1] >>> import itertools >>> list(itertools.accumulate(sample)) [5, 9, 11, 19, 26, 32, 35, 35, 44, 45] >>> list(itertools.accumulate(sample, min)) [5, 4, 2, 2, 2, 2, 2, 0, 0, 0] >>> list(itertools.accumulate(sample, max)) [5, 5, 5, 8, 8, 8, 8, 8, 9, 9] >>> import operator >>> list(itertools.accumulate(sample, operator.mul)) [5, 20, 40, 320, 2240, 13440, 40320, 0, 0, 0] >>> list(itertools.accumulate(range(1, 11), operator.mul)) [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n\nRunning sum.\n\nRunning minimum.\n\nRunning maximum.\n\nRunning product.\n\nFactorials from 1! to 10!.\n\nThe remaining functions of Table 17-2 are shown in Example 17-17.\n\nExample 17-17. Mapping generator function examples\n\n>>> list(enumerate('albatroz', 1)) [(1, 'a'), (2, 'l'), (3, 'b'), (4, 'a'), (5, 't'), (6, 'r'), (7, 'o'), (8, 'z')]\n\nGenerator Functions in the Standard Library\n\n|\n\n621",
      "content_length": 1821,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 652,
      "content": ">>> import operator >>> list(map(operator.mul, range(11), range(11))) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100] >>> list(map(operator.mul, range(11), [2, 4, 8])) [0, 4, 16] >>> list(map(lambda a, b: (a, b), range(11), [2, 4, 8])) [(0, 2), (1, 4), (2, 8)] >>> import itertools >>> list(itertools.starmap(operator.mul, enumerate('albatroz', 1))) ['a', 'll', 'bbb', 'aaaa', 'ttttt', 'rrrrrr', 'ooooooo', 'zzzzzzzz'] >>> sample = [5, 4, 2, 8, 7, 6, 3, 0, 9, 1] >>> list(itertools.starmap(lambda a, b: b / a, ... enumerate(itertools.accumulate(sample), 1))) [5.0, 4.5, 3.6666666666666665, 4.75, 5.2, 5.333333333333333, 5.0, 4.375, 4.888888888888889, 4.5]\n\nNumber the letters in the word, starting from 1.\n\nSquares of integers from 0 to 10.\n\nMultiplying numbers from two iterables in parallel: results stop when the short‐ est iterable ends.\n\nThis is what the zip built-in function does.\n\nRepeat each letter in the word according to its place in it, starting from 1.\n\nRunning average.\n\nNext, we have the group of merging generators—all of these yield items from multi‐ ple input iterables. chain and chain.from_iterable consume the input iterables sequentially (one after the other), while product, zip, and zip_longest consume the input iterables in parallel. See Table 17-3.\n\nTable 17-3. Generator functions that merge multiple input iterables\n\nModule\n\nFunction\n\nitertools chain(it1, …, itN)\n\nDescription Yields all items from it1, then from it2, etc., seamlessly\n\nitertools chain.from_iterable(it)\n\nYields all items from each iterable produced by it, one after the other, seamlessly; it will be an iterable where the items are also iterables, for example, a list of tuples\n\nitertools product(it1, …, itN, repeat=1)\n\nCartesian product: yields N-tuples made by combining items from each input iterable, like nested for loops could produce; repeat allows the input iterables to be consumed more than once\n\n622\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1965,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 653,
      "content": "Module (built-in)\n\nFunction\n\nzip(it1, …, itN, strict=False)\n\nDescription Yields N-tuples built from items taken from the iterables in parallel, silently stopping when the first iterable is exhausted, unless strict=True is givena\n\nitertools zip_longest(it1, …, itN, fillvalue=None)\n\nYields N-tuples built from items taken from the iterables in parallel, stopping only when the last iterable is exhausted, filling the blanks with the fillvalue\n\na The strict keyword-only argument is new in Python 3.10. When strict=True, ValueError is raised if any iterable has a different length. The default is False, for backward compatibility.\n\nExample 17-18 shows the use of the itertools.chain and zip generator functions and their siblings. Recall that the zip function is named after the zip fastener or zip‐ per (no relation to compression). Both zip and itertools.zip_longest were intro‐ duced in “The Awesome zip” on page 416.\n\nExample 17-18. Merging generator function examples\n\n>>> list(itertools.chain('ABC', range(2))) ['A', 'B', 'C', 0, 1] >>> list(itertools.chain(enumerate('ABC'))) [(0, 'A'), (1, 'B'), (2, 'C')] >>> list(itertools.chain.from_iterable(enumerate('ABC'))) [0, 'A', 1, 'B', 2, 'C'] >>> list(zip('ABC', range(5), [10, 20, 30, 40])) [('A', 0, 10), ('B', 1, 20), ('C', 2, 30)] >>> list(itertools.zip_longest('ABC', range(5))) [('A', 0), ('B', 1), ('C', 2), (None, 3), (None, 4)] >>> list(itertools.zip_longest('ABC', range(5), fillvalue='?')) [('A', 0), ('B', 1), ('C', 2), ('?', 3), ('?', 4)]\n\nGenerator Functions in the Standard Library\n\n|\n\n623",
      "content_length": 1557,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 654,
      "content": "chain is usually called with two or more iterables.\n\nchain does nothing useful when called with a single iterable.\n\nBut chain.from_iterable takes each item from the iterable, and chains them in sequence, as long as each item is itself iterable.\n\nAny number of iterables can be consumed by zip in parallel, but the generator always stops as soon as the first iterable ends. In Python ≥ 3.10, if the strict=True argument is given and an iterable ends before the others, ValueEr ror is raised.\n\nitertools.zip_longest works like zip, except it consumes all input iterables to the end, padding output tuples with None, as needed.\n\nThe fillvalue keyword argument specifies a custom padding value.\n\nThe itertools.product generator is a lazy way of computing Cartesian products, which we built using list comprehensions with more than one for clause in “Cartesian Products” on page 27. Generator expressions with multiple for clauses can also be used to produce Cartesian products lazily. Example 17-19 demonstrates itertools.product.\n\nExample 17-19. itertools.product generator function examples\n\n>>> list(itertools.product('ABC', range(2))) [('A', 0), ('A', 1), ('B', 0), ('B', 1), ('C', 0), ('C', 1)] >>> suits = 'spades hearts diamonds clubs'.split() >>> list(itertools.product('AK', suits)) [('A', 'spades'), ('A', 'hearts'), ('A', 'diamonds'), ('A', 'clubs'), ('K', 'spades'), ('K', 'hearts'), ('K', 'diamonds'), ('K', 'clubs')] >>> list(itertools.product('ABC')) [('A',), ('B',), ('C',)] >>> list(itertools.product('ABC', repeat=2)) [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C', 'C')] >>> list(itertools.product(range(2), repeat=3)) [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)] >>> rows = itertools.product('AB', range(2), repeat=2) >>> for row in rows: print(row) ... ('A', 0, 'A', 0) ('A', 0, 'A', 1) ('A', 0, 'B', 0) ('A', 0, 'B', 1) ('A', 1, 'A', 0)\n\n624\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 2020,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 655,
      "content": "('A', 1, 'A', 1) ('A', 1, 'B', 0) ('A', 1, 'B', 1) ('B', 0, 'A', 0) ('B', 0, 'A', 1) ('B', 0, 'B', 0) ('B', 0, 'B', 1) ('B', 1, 'A', 0) ('B', 1, 'A', 1) ('B', 1, 'B', 0) ('B', 1, 'B', 1)\n\nThe Cartesian product of a str with three characters and a range with two inte‐ gers yields six tuples (because 3 * 2 is 6).\n\nThe product of two card ranks ('AK') and four suits is a series of eight tuples.\n\nGiven a single iterable, product yields a series of one-tuples—not very useful.\n\nThe repeat=N keyword argument tells the product to consume each input itera‐ ble N times.\n\nSome generator functions expand the input by yielding more than one value per input item. They are listed in Table 17-4.\n\nTable 17-4. Generator functions that expand each input item into multiple output items\n\nModule\n\nFunction\n\nitertools combinations(it, out_len)\n\nDescription Yields combinations of out_len items from the items yielded by it\n\nitertools combinations_with_replacement(it,\n\nout_len)\n\nYields combinations of out_len items from the items yielded by it, including combinations with repeated items\n\nitertools count(start=0, step=1)\n\nYields numbers starting at start, incremented by step, indefinitely\n\nitertools cycle(it)\n\nYields items from it, storing a copy of each, then yields the entire sequence repeatedly, indefinitely\n\nitertools pairwise(it)\n\nYields successive overlapping pairs taken from the input iterablea\n\nitertools permutations(it, out_len=None)\n\nYields permutations of out_len items from the items yielded by it; by default, out_len is len(list(it))\n\nitertools repeat(item, [times])\n\nYields the given item repeatedly, indefinitely unless a number of times is given\n\na itertools.pairwise was added in Python 3.10.\n\nGenerator Functions in the Standard Library\n\n|\n\n625",
      "content_length": 1759,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 656,
      "content": "The count and repeat functions from itertools return generators that conjure items out of nothing: neither of them takes an iterable as input. We saw iter tools.count in “Arithmetic Progression with itertools” on page 618. The cycle generator makes a backup of the input iterable and yields its items repeatedly. Example 17-20 illustrates the use of count, cycle, pairwise, and repeat.\n\nExample 17-20. count, cycle, pairwise, and repeat\n\n>>> ct = itertools.count() >>> next(ct) 0 >>> next(ct), next(ct), next(ct) (1, 2, 3) >>> list(itertools.islice(itertools.count(1, .3), 3)) [1, 1.3, 1.6] >>> cy = itertools.cycle('ABC') >>> next(cy) 'A' >>> list(itertools.islice(cy, 7)) ['B', 'C', 'A', 'B', 'C', 'A', 'B'] >>> list(itertools.pairwise(range(7))) [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] >>> rp = itertools.repeat(7) >>> next(rp), next(rp) (7, 7) >>> list(itertools.repeat(8, 4)) [8, 8, 8, 8] >>> list(map(operator.mul, range(11), itertools.repeat(5))) [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]\n\nBuild a count generator ct.\n\nRetrieve the first item from ct.\n\nI can’t build a list from ct, because ct never stops, so I fetch the next three items.\n\nI can build a list from a count generator if it is limited by islice or takewhile.\n\nBuild a cycle generator from 'ABC' and fetch its first item, 'A'.\n\nA list can only be built if limited by islice; the next seven items are retrieved here.\n\nFor each item in the input, pairwise yields a 2-tuple with that item and the next —if there is a next item. Available in Python ≥ 3.10.\n\n626\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1600,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 657,
      "content": "Build a repeat generator that will yield the number 7 forever.\n\nA repeat generator can be limited by passing the times argument: here the num‐ ber 8 will be produced 4 times.\n\nA common use of repeat: providing a fixed argument in map; here it provides the 5 multiplier.\n\nThe combinations, combinations_with_replacement, and permutations generator functions—together with product—are called the combinatorics generators in the itertools documentation page. There is a close relationship between iter tools.product and the remaining combinatoric functions as well, as Example 17-21 shows.\n\nExample 17-21. Combinatoric generator functions yield multiple values per input item\n\n>>> list(itertools.combinations('ABC', 2)) [('A', 'B'), ('A', 'C'), ('B', 'C')] >>> list(itertools.combinations_with_replacement('ABC', 2)) [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')] >>> list(itertools.permutations('ABC', 2)) [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')] >>> list(itertools.product('ABC', repeat=2)) [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C', 'C')]\n\nAll combinations of len()==2 from the items in 'ABC'; item ordering in the gen‐ erated tuples is irrelevant (they could be sets).\n\nAll combinations of len()==2 from the items in 'ABC', including combinations with repeated items.\n\nAll permutations of len()==2 from the items in 'ABC'; item ordering in the gen‐ erated tuples is relevant.\n\nCartesian product from 'ABC' and 'ABC' (that’s the effect of repeat=2).\n\nThe last group of generator functions we’ll cover in this section are designed to yield all items in the input iterables, but rearranged in some way. Here are two functions that return multiple generators: itertools.groupby and itertools.tee. The other generator function in this group, the reversed built-in, is the only one covered in this section that does not accept any iterable as input, but only sequences. This makes sense: because reversed will yield the items from last to first, it only works with a sequence with a known length. But it avoids the cost of making a reversed copy of the\n\nGenerator Functions in the Standard Library\n\n|\n\n627",
      "content_length": 2218,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 658,
      "content": "sequence by yielding each item as needed. I put the itertools.product function together with the merging generators in Table 17-3 because they all consume more than one iterable, while the generators in Table 17-5 all accept at most one input iterable.\n\nTable 17-5. Rearranging generator functions\n\nModule\n\nFunction\n\nitertools groupby(it,\n\nkey=None)\n\nDescription Yields 2-tuples of the form (key, group), where key is the grouping criterion and group is a generator yielding the items in the group\n\n(built-in)\n\nreversed(seq)\n\nYields items from seq in reverse order, from last to first; seq must be a sequence or implement the __reversed__ special method\n\nitertools tee(it, n=2)\n\nYields a tuple of n generators, each yielding the items of the input iterable independently\n\nExample 17-22 demonstrates the use of itertools.groupby and the reversed built- in. Note that itertools.groupby assumes that the input iterable is sorted by the grouping criterion, or at least that the items are clustered by that criterion—even if not completely sorted. Tech reviewer Miroslav Šedivý suggested this use case: you can sort the datetime objects chronologically, then groupby weekday to get a group of Monday data, followed by Tuesday data, etc., and then by Monday (of the next week) again, and so on.\n\nExample 17-22. itertools.groupby\n\n>>> list(itertools.groupby('LLLLAAGGG')) [('L', <itertools._grouper object at 0x102227cc0>), ('A', <itertools._grouper object at 0x102227b38>), ('G', <itertools._grouper object at 0x102227b70>)] >>> for char, group in itertools.groupby('LLLLAAAGG'): ... print(char, '->', list(group)) ... L -> ['L', 'L', 'L', 'L'] A -> ['A', 'A',] G -> ['G', 'G', 'G'] >>> animals = ['duck', 'eagle', 'rat', 'giraffe', 'bear', ... 'bat', 'dolphin', 'shark', 'lion'] >>> animals.sort(key=len) >>> animals ['rat', 'bat', 'duck', 'bear', 'lion', 'eagle', 'shark', 'giraffe', 'dolphin'] >>> for length, group in itertools.groupby(animals, len): ... print(length, '->', list(group)) ... 3 -> ['rat', 'bat'] 4 -> ['duck', 'bear', 'lion'] 5 -> ['eagle', 'shark']\n\n628\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 2130,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 659,
      "content": "7 -> ['giraffe', 'dolphin'] >>> for length, group in itertools.groupby(reversed(animals), len): ... print(length, '->', list(group)) ... 7 -> ['dolphin', 'giraffe'] 5 -> ['shark', 'eagle'] 4 -> ['lion', 'bear', 'duck'] 3 -> ['bat', 'rat'] >>>\n\ngroupby yields tuples of (key, group_generator).\n\nHandling groupby generators involves nested iteration: in this case, the outer for loop and the inner list constructor.\n\nSort animals by length.\n\nAgain, loop over the key and group pair, to display the key and expand the group into a list.\n\nHere the reverse generator iterates over animals from right to left.\n\nThe last of the generator functions in this group is iterator.tee, which has a unique behavior: it yields multiple generators from a single input iterable, each yielding every item from the input. Those generators can be consumed independently, as shown in Example 17-23.\n\nExample 17-23. itertools.tee yields multiple generators, each yielding every item of the input generator\n\n>>> list(itertools.tee('ABC')) [<itertools._tee object at 0x10222abc8>, <itertools._tee object at 0x10222ac08>] >>> g1, g2 = itertools.tee('ABC') >>> next(g1) 'A' >>> next(g2) 'A' >>> next(g2) 'B' >>> list(g1) ['B', 'C'] >>> list(g2) ['C'] >>> list(zip(*itertools.tee('ABC'))) [('A', 'A'), ('B', 'B'), ('C', 'C')]\n\nGenerator Functions in the Standard Library\n\n|\n\n629",
      "content_length": 1350,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 660,
      "content": "Note that several examples in this section used combinations of generator functions. This is a great feature of these functions: because they take generators as arguments and return generators, they can be combined in many different ways.\n\nNow we’ll review another group of iterable-savvy functions in the standard library.\n\nIterable Reducing Functions The functions in Table 17-6 all take an iterable and return a single result. They are known as “reducing,” “folding,” or “accumulating” functions. We can implement every one of the built-ins listed here with functools.reduce, but they exist as built- ins because they address some common use cases more easily. A longer explanation about functools.reduce appeared in “Vector Take #4: Hashing and a Faster ==” on page 411.\n\nIn the case of all and any, there is an important optimization functools.reduce does not support: all and any short-circuit—i.e., they stop consuming the iterator as soon as the result is determined. See the last test with any in Example 17-24.\n\nTable 17-6. Built-in functions that read iterables and return single values\n\nModule (built-in)\n\nFunction\n\nall(it)\n\nDescription Returns True if all items in it are truthy, otherwise False; all([]) returns True\n\n(built-in)\n\n(built-in)\n\n(built-in)\n\nany(it)\n\nmax(it, [key=,] [default=])\n\nmin(it, [key=,] [default=])\n\nReturns True if any item in it is truthy, otherwise False; any([]) returns False Returns the maximum value of the items in it;a key is an ordering function, as in sorted; default is returned if the iterable is empty Returns the minimum value of the items in it.b key is an ordering function, as in sorted; default is returned if the iterable is empty\n\nfunctools reduce(func, it, [ini\n\ntial])\n\nReturns the result of applying func to the first pair of items, then to that result and the third item, and so on; if given, initial forms the initial pair with the first item\n\n(built-in)\n\nsum(it, start=0)\n\nThe sum of all items in it, with the optional start value added (use math.fsum for better precision when adding floats)\n\na May also be called as max(arg1, arg2, …, [key=?]), in which case the maximum among the arguments is returned. b May also be called as min(arg1, arg2, …, [key=?]), in which case the minimum among the arguments is returned.\n\nThe operation of all and any is exemplified in Example 17-24.\n\n630\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 2409,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 661,
      "content": "Example 17-24. Results of all and any for some sequences\n\n>>> all([1, 2, 3]) True >>> all([1, 0, 3]) False >>> all([]) True >>> any([1, 2, 3]) True >>> any([1, 0, 3]) True >>> any([0, 0.0]) False >>> any([]) False >>> g = (n for n in [0, 0.0, 7, 8]) >>> any(g) True >>> next(g) 8\n\nany iterated over g until g yielded 7; then any stopped and returned True.\n\nThat’s why 8 was still remaining.\n\nAnother built-in that takes an iterable and returns something else is sorted. Unlike reversed, which is a generator function, sorted builds and returns a new list. After all, every single item of the input iterable must be read so they can be sorted, and the sorting happens in a list, therefore sorted just returns that list after it’s done. I mention sorted here because it does consume an arbitrary iterable.\n\nOf course, sorted and the reducing functions only work with iterables that eventually stop. Otherwise, they will keep on collecting items and never return a result.\n\nIf you’ve gotten this far, you’ve seen the most important and useful content of this chapter. The remaining sections cover advanced generator features that most of us don’t see or need very often, such as the yield from construct and classic coroutines.\n\nThere are also sections about type hinting iterables, iterators, and classic coroutines.\n\nThe yield from syntax provides a new way of combining generators. That’s next.\n\nIterable Reducing Functions\n\n|\n\n631",
      "content_length": 1431,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 662,
      "content": "Subgenerators with yield from The yield from expression syntax was introduced in Python 3.3 to allow a generator to delegate work to a subgenerator.\n\nBefore yield from was introduced, we used a for loop when a generator needed to yield values produced from another generator:\n\n>>> def sub_gen(): ... yield 1.1 ... yield 1.2 ... >>> def gen(): ... yield 1 ... for i in sub_gen(): ... yield i ... yield 2 ... >>> for x in gen(): ... print(x) ... 1 1.1 1.2 2\n\nWe can get the same result using yield from, as you can see in Example 17-25.\n\nExample 17-25. Test-driving yield from\n\n>>> def sub_gen(): ... yield 1.1 ... yield 1.2 ... >>> def gen(): ... yield 1 ... yield from sub_gen() ... yield 2 ... >>> for x in gen(): ... print(x) ... 1 1.1 1.2 2\n\nIn Example 17-25, the for loop is the client code, gen is the delegating generator, and sub_gen is the subgenerator. Note that yield from pauses gen, and sub_gen takes over until it is exhausted. The values yielded by sub_gen pass through gen directly to\n\n632\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1066,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 663,
      "content": "the client for loop. Meanwhile, gen is suspended and cannot see the values passing through it. Only when sub_gen is done, gen resumes.\n\nWhen the subgenerator contains a return statement with a value, that value can be captured in the delegating generator by using yield from as part of an expression. Example 17-26 demonstrates.\n\nExample 17-26. yield from gets the return value of the subgenerator\n\n>>> def sub_gen(): ... yield 1.1 ... yield 1.2 ... return 'Done!' ... >>> def gen(): ... yield 1 ... result = yield from sub_gen() ... print('<--', result) ... yield 2 ... >>> for x in gen(): ... print(x) ... 1 1.1 1.2 <-- Done! 2\n\nNow that we’ve seen the basics of yield from, let’s study a couple of simple but prac‐ tical examples of its use.\n\nReinventing chain We saw in Table 17-3 that itertools provides a chain generator that yields items from several iterables, iterating over the first, then the second, and so on up to the last. This is a homemade implementation of chain with nested for loops in Python:10\n\n>>> def chain(*iterables): ... for it in iterables: ... for i in it: ... yield i ... >>> s = 'ABC' >>> r = range(3)\n\n10 chain and most itertools functions are written in C.\n\nSubgenerators with yield from\n\n|\n\n633",
      "content_length": 1228,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 664,
      "content": ">>> list(chain(s, r)) ['A', 'B', 'C', 0, 1, 2]\n\nThe chain generator in the preceding code is delegating to each iterable it in turn, by driving each it in the inner for loop. That inner loop can be replaced with a yield from expression, as shown in the next console listing:\n\n>>> def chain(*iterables): ... for i in iterables: ... yield from i ... >>> list(chain(s, t)) ['A', 'B', 'C', 0, 1, 2]\n\nThe use of yield from in this example is correct, and the code reads better, but it seems like syntactic sugar with little real gain. Now let’s develop a more interesting example.\n\nTraversing a Tree In this section, we’ll see yield from in a script to traverse a tree structure. I will build it in baby steps.\n\nThe tree structure for this example is Python’s exception hierarchy. But the pattern can be adapted to show a directory tree or any other tree structure.\n\nStarting from BaseException at level zero, the exception hierarchy is five levels deep as of Python 3.10. Our first baby step is to show level zero.\n\nGiven a root class, the tree generator in Example 17-27 yields its name and stops.\n\nExample 17-27. tree/step0/tree.py: yield the name of the root class and stop\n\ndef tree(cls): yield cls.__name__\n\ndef display(cls): for cls_name in tree(cls): print(cls_name)\n\nif __name__ == '__main__': display(BaseException)\n\nThe output of Example 17-27 is just one line:\n\nBaseException\n\n634\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1449,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 665,
      "content": "The next baby step takes us to level 1. The tree generator will yield the name of the root class and the names of each direct subclass. The names of the subclasses are indented to reveal the hierarchy. This is the output we want:\n\n$ python3 tree.py BaseException Exception GeneratorExit SystemExit KeyboardInterrupt\n\nExample 17-28 produces that output.\n\nExample 17-28. tree/step1/tree.py: yield the name of root class and direct subclasses\n\ndef tree(cls): yield cls.__name__, 0 for sub_cls in cls.__subclasses__(): yield sub_cls.__name__, 1\n\ndef display(cls): for cls_name, level in tree(cls): indent = ' ' * 4 * level print(f'{indent}{cls_name}')\n\nif __name__ == '__main__': display(BaseException)\n\nTo support the indented output, yield the name of the class and its level in the hierarchy.\n\nUse the __subclasses__ special method to get a list of subclasses.\n\nYield name of subclass and level 1.\n\nBuild indentation string of 4 spaces times level. At level zero, this will be an empty string.\n\nIn Example 17-29, I refactor tree to separate the special case of the root class from the subclasses, which are now handled in the sub_tree generator. At yield from, the tree generator is suspended, and sub_tree takes over yielding values.\n\nSubgenerators with yield from\n\n|\n\n635",
      "content_length": 1272,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 666,
      "content": "Example 17-29. tree/step2/tree.py: tree yields the root class name, then delegates to sub_tree\n\ndef tree(cls): yield cls.__name__, 0 yield from sub_tree(cls)\n\ndef sub_tree(cls): for sub_cls in cls.__subclasses__(): yield sub_cls.__name__, 1\n\ndef display(cls): for cls_name, level in tree(cls): indent = ' ' * 4 * level print(f'{indent}{cls_name}')\n\nif __name__ == '__main__': display(BaseException)\n\nDelegate to sub_tree to yield the names of the subclasses.\n\nYield the name of each subclass and level 1. Because of the yield from sub_tree(cls) inside tree, these values bypass the tree generator function completely…\n\n… and are received directly here.\n\nIn keeping with the baby steps method, I’ll write the simplest code I can imagine to reach level 2. For depth-first tree traversal, after yielding each node in level 1, I want to yield the children of that node in level 2, before resuming level 1. A nested for loop takes care of that, as in Example 17-30.\n\nExample 17-30. tree/step3/tree.py: sub_tree traverses levels 1 and 2 depth-first\n\ndef tree(cls): yield cls.__name__, 0 yield from sub_tree(cls)\n\ndef sub_tree(cls): for sub_cls in cls.__subclasses__(): yield sub_cls.__name__, 1 for sub_sub_cls in sub_cls.__subclasses__(): yield sub_sub_cls.__name__, 2\n\n636\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1330,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 667,
      "content": "def display(cls): for cls_name, level in tree(cls): indent = ' ' * 4 * level print(f'{indent}{cls_name}')\n\nif __name__ == '__main__': display(BaseException)\n\nThis is the result of running step3/tree.py from Example 17-30:\n\n$ python3 tree.py BaseException Exception TypeError StopAsyncIteration StopIteration ImportError OSError EOFError RuntimeError NameError AttributeError SyntaxError LookupError ValueError AssertionError ArithmeticError SystemError ReferenceError MemoryError BufferError Warning GeneratorExit SystemExit KeyboardInterrupt\n\nYou may already know where this is going, but I will stick to baby steps one more time: let’s reach level 3 by adding yet another nested for loop. The rest of the pro‐ gram is unchanged, so Example 17-31 shows only the sub_tree generator.\n\nExample 17-31. sub_tree generator from tree/step4/tree.py\n\ndef sub_tree(cls): for sub_cls in cls.__subclasses__(): yield sub_cls.__name__, 1 for sub_sub_cls in sub_cls.__subclasses__(): yield sub_sub_cls.__name__, 2 for sub_sub_sub_cls in sub_sub_cls.__subclasses__(): yield sub_sub_sub_cls.__name__, 3\n\nSubgenerators with yield from\n\n|\n\n637",
      "content_length": 1125,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 668,
      "content": "There is a clear pattern in Example 17-31. We do a for loop to get the subclasses of level N. Each time around the loop, we yield a subclass of level N, then start another for loop to visit level N+1.\n\nIn “Reinventing chain” on page 633, we saw how we can replace a nested for loop driving a generator with yield from on the same generator. We can apply that idea here, if we make sub_tree accept a level parameter, and yield from it recursively, passing the current subclass as the new root class with the next level number. See Example 17-32.\n\nExample 17-32. tree/step5/tree.py: recursive sub_tree goes as far as memory allows\n\ndef tree(cls): yield cls.__name__, 0 yield from sub_tree(cls, 1)\n\ndef sub_tree(cls, level): for sub_cls in cls.__subclasses__(): yield sub_cls.__name__, level yield from sub_tree(sub_cls, level+1)\n\ndef display(cls): for cls_name, level in tree(cls): indent = ' ' * 4 * level print(f'{indent}{cls_name}')\n\nif __name__ == '__main__': display(BaseException)\n\nExample 17-32 can traverse trees of any depth, limited only by Python’s recursion limit. The default limit allows 1,000 pending functions.\n\nAny good tutorial about recursion will stress the importance of having a base case to avoid infinite recursion. A base case is a conditional branch that returns without making a recursive call. The base case is often implemented with an if statement. In Example 17-32, sub_tree has no if, but there is an implicit conditional in the for loop: if cls.__subclasses__() returns an empty list, the body of the loop is not exe‐ cuted, therefore no recursive call happens. The base case is when the cls class has no subclasses. In that case, sub_tree yields nothing. It just returns.\n\nExample 17-32 works as intended, but we can make it more concise by recalling the pattern we observed when we reached level 3 (Example 17-31): we yield a subclass with level N, then start a nested for loop to visit level N+1. In Example 17-32 we\n\n638\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 2017,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 669,
      "content": "replaced that nested loop with yield from. Now we can merge tree and sub_tree into a single generator. Example 17-33 is the last step for this example.\n\nExample 17-33. tree/step6/tree.py: recursive calls of tree pass an incremented level argument\n\ndef tree(cls, level=0): yield cls.__name__, level for sub_cls in cls.__subclasses__(): yield from tree(sub_cls, level+1)\n\ndef display(cls): for cls_name, level in tree(cls): indent = ' ' * 4 * level print(f'{indent}{cls_name}')\n\nif __name__ == '__main__': display(BaseException)\n\nAt the start of “Subgenerators with yield from” on page 632, we saw how yield from connects the subgenerator directly to the client code, bypassing the delegating gener‐ ator. That connection becomes really important when generators are used as corou‐ tines and not only produce but also consume values from the client code, as we’ll see in “Classic Coroutines” on page 641.\n\nAfter this first encounter with yield from, let’s turn to type hinting iterables and iterators.\n\nGeneric Iterable Types Python’s standard library has many functions that accept iterable arguments. In your code, such functions can be annotated like the zip_replace function we saw in Example 8-15, using collections.abc.Iterable (or typing.Iterable if you must support Python 3.8 or earlier, as explained in “Legacy Support and Deprecated Col‐ lection Types” on page 272). See Example 17-34.\n\nExample 17-34. replacer.py returns an iterator of tuples of strings\n\nfrom collections.abc import Iterable\n\nFromTo = tuple[str, str]\n\ndef zip_replace(text: str, changes: Iterable[FromTo]) -> str: for from_, to in changes:\n\nGeneric Iterable Types\n\n|\n\n639",
      "content_length": 1648,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 670,
      "content": "text = text.replace(from_, to) return text\n\nDefine type alias; not required, but makes the next type hint more readable. Starting with Python 3.10, FromTo should have a type hint of typing.TypeAlias to clarify the reason for this line: FromTo: TypeAlias = tuple[str, str].\n\nAnnotate changes to accept an Iterable of FromTo tuples.\n\nIterator types don’t appear as often as Iterable types, but they are also simple to write. Example 17-35 shows the familiar Fibonacci generator, annotated.\n\nExample 17-35. fibo_gen.py: fibonacci returns a generator of integers\n\nfrom collections.abc import Iterator\n\ndef fibonacci() -> Iterator[int]: a, b = 0, 1 while True: yield a a, b = b, a + b\n\nNote that the type Iterator is used for generators coded as functions with yield, as well as iterators written “by hand” as classes with __next__. There is also a collec tions.abc.Generator type (and the corresponding deprecated typing.Generator) that we can use to annotate generator objects, but it is needlessly verbose for genera‐ tors used as iterators.\n\nExample 17-36, when checked with Mypy, reveals that the Iterator type is really a simplified special case of the Generator type.\n\nExample 17-36. itergentype.py: two ways to annotate iterators\n\nfrom collections.abc import Iterator from keyword import kwlist from typing import TYPE_CHECKING\n\nshort_kw = (k for k in kwlist if len(k) < 5)\n\nif TYPE_CHECKING: reveal_type(short_kw)\n\nlong_kw: Iterator[str] = (k for k in kwlist if len(k) >= 4)\n\nif TYPE_CHECKING: reveal_type(long_kw)\n\n640\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1585,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 671,
      "content": "Generator expression that yields Python keywords with less than 5 characters.\n\nMypy infers: typing.Generator[builtins.str*, None, None].11\n\nThis also yields strings, but I added an explicit type hint.\n\nRevealed type: typing.Iterator[builtins.str].\n\nabc.Iterator[str] is consistent-with abc.Generator[str, None, None], therefore Mypy issues no errors for type checking in Example 17-36.\n\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nClassic Coroutines\n\nPEP 342—Coroutines via Enhanced Generators introduced the .send() and other features that made it possible to use genera‐ tors as coroutines. PEP 342 uses the word “coroutine” with the same meaning I am using here.\n\nIt is unfortunate that Python’s official documentation and standard library now use inconsistent terminology to refer to generators used as coroutines, forcing me to adopt the “classic coroutine” qualifier to contrast with the newer “native coroutine” objects.\n\nAfter Python 3.5 came out, the trend is to use “coroutine” as a syn‐ onym for “native coroutine.” But PEP 342 is not deprecated, and classic coroutines still work as originally designed, although they are no longer supported by asyncio.\n\nUnderstanding classic coroutines in Python is confusing because they are actually generators used in a different way. So let’s step back and consider another feature of Python that can be used in two ways.\n\nWe saw in “Tuples Are Not Just Immutable Lists” on page 30 that we can use tuple instances as records or as immutable sequences. When used as a record, a tuple is expected to have a specific number of items, and each item may have a different type. When used as immutable lists, a tuple can have any length, and all items are expected to have the same type. That’s why there are two different ways to annotate tuples with type hints:\n\n11 As of version 0.910, Mypy still uses the deprecated typing types.\n\nClassic Coroutines\n\n|\n\n641",
      "content_length": 2104,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 672,
      "content": "# A city record with name, country, and population: city: tuple[str, str, int]\n\n# An immutable sequence of domain names: domains: tuple[str, ...]\n\nSomething similar happens with generators. They are commonly used as iterators, but they can also be used as coroutines. A coroutine is really a generator function, created with the yield keyword in its body. And a coroutine object is physically a generator object. Despite sharing the same underlying implementation in C, the use cases of generators and coroutines in Python are so different that there are two ways to type hint them:\n\n# The `readings` variable can be bound to an iterator # or generator object that yields `float` items: readings: Iterator[float]\n\n# The `sim_taxi` variable can be bound to a coroutine # representing a taxi cab in a discrete event simulation. # It yields events, receives `float` timestamps, and returns # the number of trips made during the simulation: sim_taxi: Generator[Event, float, int]\n\nAdding to the confusion, the typing module authors decided to name that type Gen erator, when in fact it describes the API of a generator object intended to be used as a coroutine, while generators are more often used as simple iterators.\n\nThe typing documentation describes the formal type parameters of Generator like this:\n\nGenerator[YieldType, SendType, ReturnType]\n\nThe SendType is only relevant when the generator is used as a coroutine. That type parameter is the type of x in the call gen.send(x). It is an error to call .send() on a generator that was coded to behave as an iterator instead of a coroutine. Likewise, ReturnType is only meaningful to annotate a coroutine, because iterators don’t return values like regular functions. The only sensible operation on a generator used as an iterator is to call next(it) directly or indirectly via for loops and other forms of iter‐ ation. The YieldType is the type of the value returned by a call to next(it).\n\nThe Generator type has the same type parameters as typing.Coroutine:\n\nCoroutine[YieldType, SendType, ReturnType]\n\nThe typing.Coroutine documentation actually says: “The variance and order of type variables correspond to those of Generator.” But typing.Coroutine (deprecated) and collections.abc.Coroutine (generic since Python 3.9) are intended to anno‐ tate only native coroutines, not classic coroutines. If you want to use type hints with\n\n642\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 2452,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 673,
      "content": "classic coroutines, you’ll suffer through the confusion of annotating them as Genera tor[YieldType, SendType, ReturnType].\n\nDavid Beazley created some of the best talks and most comprehensive workshops about classic coroutines. In his PyCon 2009 course handout, he has a slide titled “Keeping It Straight,” which reads:\n\nGenerators produce data for iteration\n\nCoroutines are consumers of data\n\nTo keep your brain from exploding, don’t mix the two concepts together\n\nCoroutines are not related to iteration\n\nNote: There is a use of having `yield` produce a value in a coroutine, but it’s not tied to iteration.12\n\nNow let’s see how classic coroutines work.\n\nExample: Coroutine to Compute a Running Average While discussing closures in Chapter 9, we studied objects to compute a running average. Example 9-7 shows a class and Example 9-13 presents a higher-order func‐ tion returning a function that keeps the total and count variables across invocations in a closure. Example 17-37 shows how to do the same with a coroutine.13\n\nExample 17-37. coroaverager.py: coroutine to compute a running average\n\nfrom collections.abc import Generator\n\ndef averager() -> Generator[float, float, None]: total = 0.0 count = 0 average = 0.0 while True: term = yield average total += term count += 1 average = total/count\n\n12 Slide 33, “Keeping It Straight,” in “A Curious Course on Coroutines and Concurrency”.\n\n13 This example is inspired by a snippet from Jacob Holm in the Python-ideas list, message titled “Yield-From: Finalization guarantees”. Some variations appear later in the thread, and Holm further explains his thinking in message 003912.\n\nClassic Coroutines\n\n|\n\n643",
      "content_length": 1660,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 674,
      "content": "This function returns a generator that yields float values, accepts float values via .send(), and does not return a useful value.14\n\nThis infinite loop means the coroutine will keep on yielding averages as long as the client code sends values.\n\nThe yield statement here suspends the coroutine, yields a result to the client, and—later—gets a value sent by the caller to the coroutine, starting another iter‐ ation of the infinite loop.\n\nIn a coroutine, total and count can be local variables: no instance attributes or clo‐ sures are needed to keep the context while the coroutine is suspended waiting for the next .send(). That’s why coroutines are attractive replacements for callbacks in asyn‐ chronous programming—they keep local state between activations.\n\nExample 17-38 runs doctests to show the averager coroutine in operation.\n\nExample 17-38. coroaverager.py: doctest for the running average coroutine in Example 17-37\n\n>>> coro_avg = averager() >>> next(coro_avg) 0.0 >>> coro_avg.send(10) 10.0 >>> coro_avg.send(30) 20.0 >>> coro_avg.send(5) 15.0\n\nCreate the coroutine object.\n\nStart the coroutine. This yields the initial value of average: 0.0.\n\nNow we are in business: each call to .send() yields the current average.\n\nIn Example 17-38, the call next(coro_avg) makes the coroutine advance to the yield, yielding the initial value for average. You can also start the coroutine by call‐ ing coro_avg.send(None)—this is actually what the next() built-in does. But you can’t send any value other than None, because the coroutine can only accept a sent\n\n14 In fact, it never returns unless some exception breaks the loop. Mypy 0.910 accepts both None and typing .NoReturn as the generator return type parameter—but it also accepts str in that position, so apparently it can’t fully analyze the coroutine code at this time.\n\n644\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1896,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 675,
      "content": "value when it is suspended at a yield line. Calling next() or .send(None) to advance to the first yield is known as “priming the coroutine.”\n\nAfter each activation, the coroutine is suspended precisely at the yield keyword, waiting for a value to be sent. The line coro_avg.send(10) provides that value, caus‐ ing the coroutine to activate. The yield expression resolves to the value 10, assigning it to the term variable. The rest of the loop updates the total, count, and average variables. The next iteration in the while loop yields the average, and the coroutine is again suspended at the yield keyword.\n\nThe attentive reader may be anxious to know how the execution of an averager instance (e.g., coro_avg) may be terminated, because its body is an infinite loop. We don’t usually need to terminate a generator, because it is garbage collected as soon as there are no more valid references to it. If you need to explicitly terminate it, use the .close() method, as shown in Example 17-39.\n\nExample 17-39. coroaverager.py: continuing from Example 17-38\n\n>>> coro_avg.send(20) 16.25 >>> coro_avg.close() >>> coro_avg.close() >>> coro_avg.send(5) Traceback (most recent call last): ... StopIteration\n\ncoro_avg is the instance created in Example 17-38.\n\nThe .close() method raises GeneratorExit at the suspended yield expression. If not handled in the coroutine function, the exception terminates it. Generator Exit is caught by the generator object that wraps the coroutine—that’s why we don’t see it.\n\nCalling .close() on a previously closed coroutine has no effect.\n\nTrying .send() on a closed coroutine raises StopIteration.\n\nBesides the .send() method, PEP 342—Coroutines via Enhanced Generators also introduced a way for a coroutine to return a value. The next section shows how.\n\nClassic Coroutines\n\n|\n\n645",
      "content_length": 1815,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 676,
      "content": "Returning a Value from a Coroutine We’ll now study another coroutine to compute an average. This version will not yield partial results. Instead, it returns a tuple with the number of terms and the average. I’ve split the listing in two parts: Example 17-40 and Example 17-41.\n\nExample 17-40. coroaverager2.py: top of the file\n\nfrom collections.abc import Generator from typing import Union, NamedTuple\n\nclass Result(NamedTuple): count: int # type: ignore average: float\n\nclass Sentinel: def __repr__(self): return f'<Sentinel>'\n\nSTOP = Sentinel()\n\nSendType = Union[float, Sentinel]\n\nThe averager2 coroutine in Example 17-41 will return an instance of Result.\n\nThe Result is actually a subclass of tuple, which has a .count() method that I don’t need. The # type: ignore comment prevents Mypy from complaining about having a count field.15\n\nA class to make a sentinel value with a readable __repr__.\n\nThe sentinel value that I’ll use to make the coroutine stop collecting data and return a result.\n\nI’ll use this type alias for the second type parameter of the coroutine Generator return type, the SendType parameter.\n\nThe SendType definition also works in Python 3.10, but if you don’t need to support earlier versions, it is better to write it like this, after importing TypeAlias from typing:\n\n15 I considered renaming the field, but count is the best name for the local variable in the coroutine, and is the name I used for this variable in similar examples in the book, so it makes sense to use the same name in the Result field. I don’t hesitate to use # type: ignore to avoid the limitations and annoyances of static type checkers when submission to the tool would make the code worse or needlessly complicated.\n\n646\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1785,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 677,
      "content": "SendType: TypeAlias = float | Sentinel\n\nUsing | instead of typing.Union is so concise and readable that I’d probably not cre‐ ate that type alias, but instead I’d write the signature of averager2 like this:\n\ndef averager2(verbose: bool=False) -> Generator[None, float | Sentinel, Result]:\n\nNow, let’s study the coroutine code itself (Example 17-41).\n\nExample 17-41. coroaverager2.py: a coroutine that returns a result value\n\ndef averager2(verbose: bool = False) -> Generator[None, SendType, Result]: total = 0.0 count = 0 average = 0.0 while True: term = yield if verbose: print('received:', term) if isinstance(term, Sentinel): break total += term count += 1 average = total / count return Result(count, average)\n\nFor this coroutine, the yield type is None because it does not yield data. It receives data of the SendType and returns a Result tuple when done.\n\nUsing yield like this only makes sense in coroutines, which are designed to con‐ sume data. This yields None, but receives a term from .send(term).\n\nIf the term is a Sentinel, break from the loop. Thanks to this isinstance check…\n\n…Mypy allows me to add term to the total without flagging an error that I can’t add a float to an object that may be a float or a Sentinel.\n\nThis line will be reached only if a Sentinel is sent to the coroutine.\n\nNow let’s see how we can use this coroutine, starting with a simple example that doesn’t actually produce a result (Example 17-42).\n\nExample 17-42. coroaverager2.py: doctest showing .cancel()\n\n>>> coro_avg = averager2() >>> next(coro_avg) >>> coro_avg.send(10)\n\nClassic Coroutines\n\n|\n\n647",
      "content_length": 1594,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 678,
      "content": ">>> coro_avg.send(30) >>> coro_avg.send(6.5) >>> coro_avg.close()\n\nRecall that averager2 does not yield partial results. It yields None, which Python’s console omits.\n\nCalling .close() in this coroutine makes it stop but does not return a result, because the GeneratorExit exception is raised at the yield line in the coroutine, so the return statement is never reached.\n\nNow let’s make it work in Example 17-43.\n\nExample 17-43. coroaverager2.py: doctest showing StopIteration with a Result\n\n>>> coro_avg = averager2() >>> next(coro_avg) >>> coro_avg.send(10) >>> coro_avg.send(30) >>> coro_avg.send(6.5) >>> try: ... coro_avg.send(STOP) ... except StopIteration as exc: ... result = exc.value ... >>> result Result(count=3, average=15.5)\n\nSending the STOP sentinel makes the coroutine break from the loop and return a Result. The generator object that wraps the coroutine then raises StopItera tion.\n\nThe StopIteration instance has a value attribute bound to the value of the return statement that terminated the coroutine.\n\nBelieve it or not!\n\nThis idea of “smuggling” the return value out of the coroutine wrapped in a StopIter ation exception is a bizarre hack. Nevertheless, this bizarre hack is part of PEP 342— Coroutines via Enhanced Generators, and is documented with the StopIteration exception, and in the “Yield expressions” section of Chapter 6 of The Python Lan‐ guage Reference.\n\nA delegating generator can get the return value of a coroutine directly using the yield from syntax, as shown in Example 17-44.\n\n648\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1589,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 679,
      "content": "Example 17-44. coroaverager2.py: doctest showing StopIteration with a Result\n\n>>> def compute(): ... res = yield from averager2(True) ... print('computed:', res) ... return res ... >>> comp = compute() >>> for v in [None, 10, 20, 30, STOP]: ... try: ... comp.send(v) ... except StopIteration as exc: ... result = exc.value received: 10 received: 20 received: 30 received: <Sentinel> computed: Result(count=3, average=20.0) >>> result Result(count=3, average=20.0)\n\nres will collect the return value of averager2; the yield from machinery retrieves the return value when it handles the StopIteration exception that marks the termination of the coroutine. When True, the verbose parameter makes the coroutine print the value received, to make its operation visible.\n\nKeep an eye out for the output of this line when this generator runs.\n\nReturn the result. This will also be wrapped in StopIteration.\n\nCreate the delegating coroutine object.\n\nThis loop will drive the delegating coroutine.\n\nFirst value sent is None, to prime the coroutine; last is the sentinel to stop it.\n\nCatch StopIteration to fetch the return value of compute.\n\nAfter the lines output by averager2 and compute, we get the Result instance.\n\nEven though the examples here don’t do much, the code is hard to follow. Driving the coroutine with .send() calls and retrieving results is complicated, except with yield from—but we can only use that syntax inside a delegating generator/corou‐ tine, which must ultimately be driven by some nontrivial code, as shown in Example 17-44.\n\nClassic Coroutines\n\n|\n\n649",
      "content_length": 1572,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 680,
      "content": "The previous examples show that using coroutines directly is cumbersome and con‐ fusing. Add exception handling and the coroutine .throw() method, and examples become even more convoluted. I won’t cover .throw() in this book because— like .send()—it is only useful to drive coroutines “by hand,” but I don’t recommend doing that, unless you are creating a new coroutine-based framework from scratch.\n\nIf you are interested in deeper coverage of classic coroutines— including the .throw() method—please check out “Classic Corou‐ tines” at the fluentpython.com companion website. That post includes Python-like pseudocode detailing how yield from drives generators and coroutines, as well as a a small discrete event simu‐ lation demonstrating a form of concurrency using coroutines without an asynchronous programming framework.\n\nIn practice, productive work with coroutines requires the support of a specialized framework. That is what asyncio provided for classic coroutines way back in Python 3.3. With the advent of native coroutines in Python 3.5, the Python core developers are gradually phasing out support for classic coroutines in asyncio. But the underly‐ ing mechanisms are very similar. The async def syntax makes native coroutines eas‐ ier to spot in code, which is a great benefit. Inside, native coroutines use await instead of yield from to delegate to other coroutines. Chapter 21 is all about that.\n\nNow let’s wrap up the chapter with a mind-bending section about covariance and contravariance in type hints for coroutines.\n\nGeneric Type Hints for Classic Coroutines Back in “Contravariant types” on page 550, I mentioned typing.Generator as one of the few standard library types with a contravariant type parameter. Now that we’ve studied classic coroutines, we are ready to make sense of this generic type.\n\nHere is how typing.Generator was declared in the typing.py module of Python 3.6:16\n\nT_co = TypeVar('T_co', covariant=True) V_co = TypeVar('V_co', covariant=True) T_contra = TypeVar('T_contra', contravariant=True)\n\n# many lines omitted\n\nclass Generator(Iterator[T_co], Generic[T_co, T_contra, V_co], extra=_G_base):\n\n16 Since Python 3.7, typing.Generator and other types that correspond to ABCs in collections.abc were refactored with a wrapper around the corresponding ABC, so their generic parameters aren’t visible in the typing.py source file. That’s why I refer to Python 3.6 source code here.\n\n650\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 2491,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 681,
      "content": "That generic type declaration means that a Generator type hint requires those three type parameters we’ve seen before:\n\nmy_coro : Generator[YieldType, SendType, ReturnType]\n\nFrom the type variables in the formal parameters, we see that YieldType and Return Type are covariant, but SendType is contravariant. To understand why, consider that YieldType and ReturnType are “output” types. Both describe data that comes out of the coroutine object—i.e., the generator object when used as a coroutine object.\n\nIt makes sense that these are covariant, because any code expecting a coroutine that yields floats can use a coroutine that yields integers. That’s why Generator is cova‐ riant on its YieldType parameter. The same reasoning applies to the ReturnType parameter—also covariant.\n\nUsing the notation introduced in “Covariant types” on page 550, the covariance of the first and third parameters is expressed by the :> symbols pointing in the same direction:\n\nfloat :> int Generator[float, Any, float] :> Generator[int, Any, int]\n\nYieldType and ReturnType are examples of the first rule of “Variance rules of thumb” on page 551:\n\n1. If a formal type parameter defines a type for data that comes out of the object, it can be covariant.\n\nOn the other hand, SendType is an “input” parameter: it is the type of the value argu‐ ment for the .send(value) method of the coroutine object. Client code that needs to send floats to a coroutine cannot use a coroutine with int as the SendType because float is not a subtype of int. In other words, float is not consistent-with int. But the client can use a coroutine with complex as the SendType, because float is a sub‐ type of complex, therefore float is consistent-with complex.\n\nThe :> notation makes the contravariance of the second parameter visible:\n\nfloat :> int Generator[Any, float, Any] <: Generator[Any, int, Any]\n\nThis is an example of the second Variance Rule of Thumb:\n\n2. If a formal type parameter defines a type for data that goes into the object after its initial construction, it can be contravariant.\n\nThis merry discussion of variance completes the longest chapter in the book.\n\nClassic Coroutines\n\n|\n\n651",
      "content_length": 2165,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 682,
      "content": "Chapter Summary Iteration is so deeply embedded in the language that I like to say that Python groks iterators.17 The integration of the Iterator pattern in the semantics of Python is a prime example of how design patterns are not equally applicable in all programming languages. In Python, a classic Iterator implemented “by hand” as in Example 17-4 has no practical use, except as a didactic example.\n\nIn this chapter, we built a few versions of a class to iterate over individual words in text files that may be very long. We saw how Python uses the iter() built-in to create iterators from sequence-like objects. We build a classic iterator as a class with __next__(), and then we used generators to make each successive refactoring of the Sentence class more concise and readable.\n\nWe then coded a generator of arithmetic progressions and showed how to leverage the itertools module to make it simpler. An overview of most general-purpose gen‐ erator functions in the standard library followed.\n\nWe then studied yield from expressions in the context of simple generators with the chain and tree examples.\n\nThe last major section was about classic coroutines, a topic of waning importance after native coroutines were added in Python 3.5. Although difficult to use in prac‐ tice, classic coroutines are the foundation of native coroutines, and the yield from expression is the direct precursor of await.\n\nAlso covered were type hints for Iterable, Iterator, and Generator types—with the latter providing a concrete and rare example of a contravariant type parameter.\n\nFurther Reading A detailed technical explanation of generators appears in The Python Language Refer‐ ence in “6.2.9. Yield expressions”. The PEP where generator functions were defined is PEP 255—Simple Generators.\n\nThe itertools module documentation is excellent because of all the examples included. Although the functions in that module are implemented in C, the docu‐ mentation shows how some of them would be written in Python, often by leveraging other functions in the module. The usage examples are also great; for instance, there is a snippet showing how to use the accumulate function to amortize a loan with interest, given a list of payments over time. There is also an “Itertools Recipes”\n\n17 According to the Jargon file, to grok is not merely to learn something, but to absorb it so “it becomes part of\n\nyou, part of your identity.”\n\n652\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 2485,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 683,
      "content": "section with additional high-performance functions that use the itertools functions as building blocks.\n\nBeyond Python’s standard library, I recommend the More Itertools package, which follows the fine itertools tradition in providing powerful generators with plenty of examples and some useful recipes.\n\nChapter 4, “Iterators and Generators,” of Python Cookbook, 3rd ed., by David Beazley and Brian K. Jones (O’Reilly), has 16 recipes covering this subject from many differ‐ ent angles, focusing on practical applications. It includes some illuminating recipes with yield from.\n\nSebastian Rittau—currently a top contributor of typeshed—explains why iterators should be iterable, as he noted in 2006 that, “Java: Iterators are not Iterable”.\n\nThe yield from syntax is explained with examples in the “What’s New in Python 3.3” section of PEP 380—Syntax for Delegating to a Subgenerator. My post “Classic Coroutines” at fluentpython.com explains yield from in depth, including Python pseudocode of its implementation in C.\n\nDavid Beazley is the ultimate authority on Python generators and coroutines. The Python Cookbook, 3rd ed., (O’Reilly) he coauthored with Brian Jones has numerous recipes with coroutines. Beazley’s PyCon tutorials on the subject are famous for their depth and breadth. The first was at PyCon US 2008: “Generator Tricks for Systems Programmers”. PyCon US 2009 saw the legendary “A Curious Course on Coroutines and Concurrency” (hard-to-find video links for all three parts: part 1, part 2, and part 3). His tutorial from PyCon 2014 in Montréal was “Generators: The Final Frontier”, in which he tackles more concurrency examples—so it’s really more about topics in Chapter 21. Dave can’t resist making brains explode in his classes, so in the last part of “The Final Frontier,” coroutines replace the classic Visitor pattern in an arithmetic expression evaluator.\n\nCoroutines allow new ways of organizing code, and just as recursion or polymor‐ phism (dynamic dispatch), it takes some time getting used to their possibilities. An interesting example of classic algorithm rewritten with coroutines is in the post “Greedy algorithm with coroutines”, by James Powell.\n\nBrett Slatkin’s Effective Python, 1st ed. (Addison-Wesley) has an excellent short chap‐ ter titled “Consider Coroutines to Run Many Functions Concurrently.” That chapter is not in the second edition of Effective Python, but it is still available online as a sam‐ ple chapter. Slatkin presents the best example of driving coroutines with yield from that I’ve seen: an implementation of John Conway’s Game of Life in which corou‐ tines manage the state of each cell as the game runs. I refactored the code for the Game of Life example—separating the functions and classes that implement the game from the testing snippets used in Slatkin’s original code. I also rewrote the tests as\n\nFurther Reading\n\n|\n\n653",
      "content_length": 2890,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 684,
      "content": "doctests, so you can see the output of the various coroutines and classes without run‐ ning the script. The refactored example is posted as a GitHub gist.\n\nSoapbox\n\nThe Minimalistic Iterator Interface in Python\n\nIn the “Implementation” section of the Iterator pattern,18 the Gang of Four wrote:\n\nThe minimal interface to Iterator consists of the operations First, Next, IsDone, and CurrentItem.\n\nHowever, that very sentence has a footnote that reads:\n\nWe can make this interface even smaller by merging Next, IsDone, and CurrentItem into a single operation that advances to the next object and returns it. If the traversal is finished, then this operation returns a special value (0, for instance) that marks the end of the iteration.\n\nThis is close to what we have in Python: the single method __next__ does the job. But instead of using a sentinel, which could be overlooked by mistake, the StopIteration exception signals the end of the iteration. Simple and correct: that’s the Python way.\n\nPluggable Generators\n\nAnyone who manages large datasets finds many uses for generators. This is the story of the first time I built a practical solution around generators.\n\nYears ago I worked at BIREME, a digital library run by PAHO/WHO (Pan-American Health Organization/World Health Organization) in São Paulo, Brazil. Among the bibliographic datasets created by BIREME are LILACS (Latin American and Carib‐ bean Health Sciences index) and SciELO (Scientific Electronic Library Online), two comprehensive databases indexing the research literature about health sciences pro‐ duced in the region.\n\nSince the late 1980s, the database system used to manage LILACS is CDS/ISIS, a non- relational document database created by UNESCO. One of my jobs was to research alternatives for a possible migration of LILACS—and eventually the much larger SciELO—to a modern, open source, document database such as CouchDB or Mon‐ goDB. At the time, I wrote a paper explaining the semistructured data model and different ways to represent CDS/ISIS data with JSON-like records: “From ISIS to CouchDB: Databases and Data Models for Bibliographic Records”.\n\nAs part of that research, I wrote a Python script to read a CDS/ISIS file and write a JSON file suitable for importing to CouchDB or MongoDB. Initially, the script read\n\n18 Gamma et. al., Design Patterns: Elements of Reusable Object-Oriented Software, p. 261.\n\n654\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 2460,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 685,
      "content": "files in the ISO-2709 format exported by CDS/ISIS. The reading and writing had to be done incrementally because the full datasets were much bigger than main memory. That was easy enough: each iteration of the main for loop read one record from the .iso file, massaged it, and wrote it to the .json output.\n\nHowever, for operational reasons, it was deemed necessary that isis2json.py supported another CDS/ISIS data format: the binary .mst files used in production at BIREME— to avoid the costly export to ISO-2709. Now I had a problem: the libraries used to read ISO-2709 and .mst files had very different APIs. And the JSON writing loop was already complicated because the script accepted a variety of command-line options to restructure each output record. Reading data using two different APIs in the same for loop where the JSON was produced would be unwieldy.\n\nThe solution was to isolate the reading logic into a pair of generator functions: one for each supported input format. In the end, I split the isis2json.py script into four functions. You can see the Python 2 source code with dependencies in the fluentpy‐ thon/isis2json repository on GitHub.19\n\nHere is a high-level overview of how the script is structured:\n\nmain\n\nThe main function uses argparse to read command-line options that configure the structure of the output records. Based on the input filename extension, a suit‐ able generator function is selected to read the data and yield the records, one by one.\n\niter_iso_records\n\nThis generator function reads .iso files (assumed to be in the ISO-2709 format). It takes two arguments: the filename and isis_json_type, one of the options related to the record structure. Each iteration of its for loop reads one record, creates an empty dict, populates it with field data, and yields the dict.\n\niter_mst_records\n\nThis other generator functions reads .mst files.20 If you look at the source code for isis2json.py, you’ll see that it’s not as simple as iter_iso_records, but its interface and overall structure is the same: it takes a filename and an isis_json_type argument and enters a for loop, which builds and yields one dict per iteration, representing a single record.\n\n19 The code is in Python 2 because one of its optional dependencies is a Java library named Bruma, which we\n\ncan import when we run the script with Jython—which does not yet support Python 3.\n\n20 The library used to read the complex .mst binary is actually written in Java, so this functionality is only avail‐ able when isis2json.py is executed with the Jython interpreter, version 2.5 or newer. For further details, see the README.rst file in the repository. The dependencies are imported inside the generator functions that need them, so the script can run even if only one of the external libraries is available.\n\nFurther Reading\n\n|\n\n655",
      "content_length": 2834,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 686,
      "content": "write_json\n\nThis function performs the actual writing of the JSON records, one at a time. It takes numerous arguments, but the first one—input_gen—is a reference to a generator function: either iter_iso_records or iter_mst_records. The main for loop in write_json iterates over the dictionaries yielded by the selected input_gen generator, restructures it in different ways as determined by the command-line options, and appends the JSON record to the output file.\n\nBy leveraging generator functions, I was able to decouple the reading from the writ‐ ing. Of course, the simplest way to decouple them would be to read all records to memory, then write them to disk. But that was not a viable option because of the size of the datasets. Using generators, the reading and writing is interleaved, so the script can process files of any size. Also, the special logic for reading a record in the differ‐ ent input formats is separated from the logic of restructuring each record for writing.\n\nNow, if we need isis2json.py to support an additional input format—say, MARCXML, a DTD used by the US Library of Congress to represent ISO-2709 data—it will be easy to add a third generator function to implement the reading logic, without chang‐ ing anything in the complicated write_json function.\n\nThis is not rocket science, but it’s a real example where generators enabled an effi‐ cient and flexible solution to process databases as a stream of records, keeping mem‐ ory usage low regardless of the size of the dataset.\n\n656\n\n|\n\nChapter 17: Iterators, Generators, and Classic Coroutines",
      "content_length": 1579,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 687,
      "content": "CHAPTER 18 with, match, and else Blocks\n\nContext managers may end up being almost as important as the subroutine itself. We’ve only scratched the surface with them. […] Basic has a with statement, there are with statements in lots of languages. But they don’t do the same thing, they all do something very shallow, they save you from repeated dotted [attribute] lookups, they don’t do setup and tear down. Just because it’s the same name don’t think it’s the same thing. The with statement is a very big deal.1\n\n—Raymond Hettinger, eloquent Python evangelist\n\nThis chapter is about control flow features that are not so common in other lan‐ guages, and for this reason tend to be overlooked or underused in Python. They are:\n\nThe with statement and context manager protocol • Pattern matching with match/case • The else clause in for, while, and try statements\n\nThe with statement sets up a temporary context and reliably tears it down, under the control of a context manager object. This prevents errors and reduces boilerplate code, making APIs at the same time safer and easier to use. Python programmers are finding lots of uses for with blocks beyond automatic file closing.\n\nWe’ve seen pattern matching in previous chapters, but here we’ll see how the gram‐ mar of a language can be expressed as sequence patterns. That observation explains why match/case is an effective tool to create language processors that are easy to understand and extend. We’ll study a complete interpreter for a small but functional\n\n1 PyCon US 2013 keynote: “What Makes Python Awesome”; the part about with starts at 23:00 and ends at\n\n26:15.\n\n657",
      "content_length": 1630,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 688,
      "content": "subset of the Scheme language. The same ideas could be applied to develop a tem‐ plate language or a DSL (Domain-Specific Language) to encode business rules in a larger system.\n\nThe else clause is not a big deal, but it does help convey intention when properly used together with for, while, and try.\n\nWhat’s New in This Chapter “Pattern Matching in lis.py: A Case Study” on page 669 is a new section.\n\nI updated “The contextlib Utilities” on page 663 to cover a few features of the context lib module added since Python 3.6, and the new parenthesized context managers syntax introduced in Python 3.10.\n\nLet’s start with the powerful with statement.\n\nContext Managers and with Blocks Context manager objects exist to control a with statement, just like iterators exist to control a for statement.\n\nThe with statement was designed to simplify some common uses of try/finally, which guarantees that some operation is performed after a block of code, even if the block is terminated by return, an exception, or a sys.exit() call. The code in the finally clause usually releases a critical resource or restores some previous state that was temporarily changed.\n\nThe Python community is finding new, creative uses for context managers. Some examples from the standard library are:\n\nManaging transactions in the sqlite3 module—see “Using the connection as a context manager”.\n\nSafely handling locks, conditions, and semaphores—as described in the thread ing module documentation.\n\nSetting up custom environments for arithmetic operations with Decimal objects —see the decimal.localcontext documentation.\n\nPatching objects for testing—see the unittest.mock.patch function.\n\nThe context manager interface consists of the __enter__ and __exit__ methods. At the top of the with, Python calls the __enter__ method of the context manager object. When the with block completes or terminates for any reason, Python calls __exit__ on the context manager object.\n\n658\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 1996,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 689,
      "content": "The most common example is making sure a file object is closed. Example 18-1 is a detailed demonstration of using with to close a file.\n\nExample 18-1. Demonstration of a file object as a context manager\n\n>>> with open('mirror.py') as fp: ... src = fp.read(60) ... >>> len(src) 60 >>> fp <_io.TextIOWrapper name='mirror.py' mode='r' encoding='UTF-8'> >>> fp.closed, fp.encoding (True, 'UTF-8') >>> fp.read(60) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: I/O operation on closed file.\n\nfp is bound to the opened text file because the file’s __enter__ method returns self.\n\nRead 60 Unicode characters from fp.\n\nThe fp variable is still available—with blocks don’t define a new scope, as func‐ tions do.\n\nWe can read the attributes of the fp object.\n\nBut we can’t read more text from fp because at the end of the with block, the TextIOWrapper.__exit__ method was called, and it closed the file.\n\nThe first callout in Example 18-1 makes a subtle but crucial point: the context man‐ ager object is the result of evaluating the expression after with, but the value bound to the target variable (in the as clause) is the result returned by the __enter__ method of the context manager object.\n\nIt just happens that the open() function returns an instance of TextIOWrapper, and its __enter__ method returns self. But in a different class, the __enter__ method may also return some other object instead of the context manager instance.\n\nWhen control flow exits the with block in any way, the __exit__ method is invoked on the context manager object, not on whatever was returned by __enter__.\n\nContext Managers and with Blocks\n\n|\n\n659",
      "content_length": 1662,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 690,
      "content": "The as clause of the with statement is optional. In the case of open, we always need it to get a reference to the file, so that we can call methods on it. But some context man‐ agers return None because they have no useful object to give back to the user.\n\nExample 18-2 shows the operation of a perfectly frivolous context manager designed to highlight the distinction between the context manager and the object returned by its __enter__ method.\n\nExample 18-2. Test-driving the LookingGlass context manager class\n\n>>> from mirror import LookingGlass >>> with LookingGlass() as what: ... print('Alice, Kitty and Snowdrop') ... print(what) ... pordwonS dna yttiK ,ecilA YKCOWREBBAJ >>> what 'JABBERWOCKY' >>> print('Back to normal.') Back to normal.\n\nThe context manager is an instance of LookingGlass; Python calls __enter__ on the context manager and the result is bound to what.\n\nPrint a str, then the value of the target variable what. The output of each print will come out reversed.\n\nNow the with block is over. We can see that the value returned by __enter__, held in what, is the string 'JABBERWOCKY'.\n\nProgram output is no longer reversed.\n\nExample 18-3 shows the implementation of LookingGlass.\n\nExample 18-3. mirror.py: code for the LookingGlass context manager class\n\nimport sys\n\nclass LookingGlass:\n\ndef __enter__(self): self.original_write = sys.stdout.write sys.stdout.write = self.reverse_write return 'JABBERWOCKY'\n\ndef reverse_write(self, text):\n\n660\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 1511,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 691,
      "content": "self.original_write(text[::-1])\n\ndef __exit__(self, exc_type, exc_value, traceback): sys.stdout.write = self.original_write if exc_type is ZeroDivisionError: print('Please DO NOT divide by zero!') return True\n\nPython invokes __enter__ with no arguments besides self.\n\nHold the original sys.stdout.write method, so we can restore it later.\n\nMonkey-patch sys.stdout.write, replacing it with our own method.\n\nReturn the 'JABBERWOCKY' string just so we have something to put in the target variable what.\n\nOur replacement to sys.stdout.write reverses the text argument and calls the original implementation.\n\nPython calls __exit__ with None, None, None if all went well; if an exception is raised, the three arguments get the exception data, as described after this example.\n\nRestore the original method to sys.stdout.write.\n\nIf the exception is not None and its type is ZeroDivisionError, print a message…\n\n…and return True to tell the interpreter that the exception was handled.\n\nIf __exit__ returns None or any falsy value, any exception raised in the with block will be propagated.\n\nWhen real applications take over standard output, they often want to replace sys.stdout with another file-like object for a while, then switch back to the original. The contextlib.redirect_stdout context manager does exactly that: just pass it the file-like object that will stand in for sys.stdout.\n\nThe interpreter calls the __enter__ method with no arguments—beyond the implicit self. The three arguments passed to __exit__ are:\n\nContext Managers and with Blocks\n\n|\n\n661",
      "content_length": 1555,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 692,
      "content": "exc_type\n\nThe exception class (e.g., ZeroDivisionError).\n\nexc_value\n\nThe exception instance. Sometimes, parameters passed to the exception con‐ structor—such as the error message—can be found in exc_value.args.\n\ntraceback\n\nA traceback object.2\n\nFor a detailed look at how a context manager works, see Example 18-4, where LookingGlass is used outside of a with block, so we can manually call its __enter__ and __exit__ methods.\n\nExample 18-4. Exercising LookingGlass without a with block\n\n>>> from mirror import LookingGlass >>> manager = LookingGlass() >>> manager # doctest: +ELLIPSIS <mirror.LookingGlass object at 0x...> >>> monster = manager.__enter__() >>> monster == 'JABBERWOCKY' eurT >>> monster 'YKCOWREBBAJ' >>> manager # doctest: +ELLIPSIS >... ta tcejbo ssalGgnikooL.rorrim< >>> manager.__exit__(None, None, None) >>> monster 'JABBERWOCKY'\n\nInstantiate and inspect the manager instance.\n\nCall the manager’s __enter__ method and store result in monster.\n\nmonster is the string 'JABBERWOCKY'. The True identifier appears reversed because all output via stdout goes through the write method we patched in __enter__.\n\nCall manager.__exit__ to restore the previous stdout.write.\n\n2 The three arguments received by self are exactly what you get if you call sys.exc_info() in the finally\n\nblock of a try/finally statement. This makes sense, considering that the with statement is meant to replace most uses of try/finally, and calling sys.exc_info() was often necessary to determine what clean-up action would be required.\n\n662\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 1577,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 693,
      "content": "Parenthesized Context Managers in Python 3.10\n\nPython 3.10 adopted a new, more powerful parser, allowing new syntax beyond what was possible with the older LL(1) parser. One syntax enhancement was to allow parenthesized context managers, like this:\n\nwith ( CtxManager1() as example1, CtxManager2() as example2, CtxManager3() as example3, ): ...\n\nPrior to 3.10, we’d have to write that as nested with blocks.\n\nThe standard library includes the contextlib package with handy functions, classes, and decorators for building, combining, and using context managers.\n\nThe contextlib Utilities Before rolling your own context manager classes, take a look at contextlib—“Utilit‐ ies for with-statement contexts” in the Python documentation. Maybe what you are about to build already exists, or there is a class or some callable that will make your job easier.\n\nBesides the redirect_stdout context manager mentioned right after Example 18-3, redirect_stderr was added in Python 3.5—it does the same as the former, but for output directed to stderr.\n\nThe contextlib package also includes:\n\nclosing\n\nA function to build context managers out of objects that provide a close() method but don’t implement the __enter__/__exit__ interface.\n\nsuppress\n\nA context manager to temporarily ignore exceptions given as arguments.\n\nnullcontext\n\nA context manager that does nothing, to simplify conditional logic around objects that may not implement a suitable context manager. It serves as a stand- in when conditional code before the with block may or may not provide a con‐ text manager for the with statement—added in Python 3.7.\n\nThe contextlib module provides classes and a decorator that are more widely appli‐ cable than the decorators just mentioned:\n\nContext Managers and with Blocks\n\n|\n\n663",
      "content_length": 1777,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 694,
      "content": "@contextmanager\n\nA decorator that lets you build a context manager from a simple generator func‐ tion, instead of creating a class and implementing the interface. See “Using @contextmanager” on page 664.\n\nAbstractContextManager\n\nAn ABC that formalizes the context manager interface, and makes it a bit easier to create context manager classes by subclassing—added in Python 3.6.\n\nContextDecorator\n\nA base class for defining class-based context managers that can also be used as function decorators, running the entire function within a managed context.\n\nExitStack\n\nA context manager that lets you enter a variable number of context managers. When the with block ends, ExitStack calls the stacked context managers’ __exit__ methods in LIFO order (last entered, first exited). Use this class when you don’t know beforehand how many context managers you need to enter in your with block; for example, when opening all files from an arbitrary list of files at the same time.\n\nWith Python 3.7, contextlib added AbstractAsyncContextManager, @asynccontext manager, and AsyncExitStack. They are similar to the equivalent utilities without the async part of the name, but designed for use with the new async with statement, covered in Chapter 21.\n\nThe most widely used of these utilities is the @contextmanager decorator, so it deserves more attention. That decorator is also interesting because it shows a use for the yield statement unrelated to iteration.\n\nUsing @contextmanager The @contextmanager decorator is an elegant and practical tool that brings together three distinctive Python features: a function decorator, a generator, and the with statement.\n\nUsing @contextmanager reduces the boilerplate of creating a context manager: instead of writing a whole class with __enter__/__exit__ methods, you just imple‐ ment a generator with a single yield that should produce whatever you want the __enter__ method to return.\n\nIn a generator decorated with @contextmanager, yield splits the body of the function in two parts: everything before the yield will be executed at the beginning of the with block when the interpreter calls __enter__; the code after yield will run when __exit__ is called at the end of the block.\n\n664\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 2264,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 695,
      "content": "Example 18-5 replaces the LookingGlass class from Example 18-3 with a generator function.\n\nExample 18-5. mirror_gen.py: a context manager implemented with a generator\n\nimport contextlib import sys\n\n@contextlib.contextmanager def looking_glass(): original_write = sys.stdout.write\n\ndef reverse_write(text): original_write(text[::-1])\n\nsys.stdout.write = reverse_write yield 'JABBERWOCKY' sys.stdout.write = original_write\n\nApply the contextmanager decorator.\n\nPreserve the original sys.stdout.write method.\n\nreverse_write can call original_write later because it is available in its closure.\n\nReplace sys.stdout.write with reverse_write.\n\nYield the value that will be bound to the target variable in the as clause of the with statement. The generator pauses at this point while the body of the with executes.\n\nWhen control exits the with block, execution continues after the yield; here the original sys.stdout.write is restored.\n\nExample 18-6 shows the looking_glass function in operation.\n\nExample 18-6. Test-driving the looking_glass context manager function\n\n>>> from mirror_gen import looking_glass >>> with looking_glass() as what: ... print('Alice, Kitty and Snowdrop') ... print(what) ... pordwonS dna yttiK ,ecilA YKCOWREBBAJ >>> what 'JABBERWOCKY'\n\nContext Managers and with Blocks\n\n|\n\n665",
      "content_length": 1298,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 696,
      "content": ">>> print('back to normal') back to normal\n\nThe only difference from Example 18-2 is the name of the context manager: look ing_glass instead of LookingGlass.\n\nThe contextlib.contextmanager decorator wraps the function in a class that imple‐ ments the __enter__ and __exit__ methods.3\n\nThe __enter__ method of that class:\n\n1. Calls the generator function to get a generator object—let’s call it gen. 2. Calls next(gen) to drive it to the yield keyword. 3. Returns the value yielded by next(gen), to allow the user to bind it to a variable in the with/as form.\n\nWhen the with block terminates, the __exit__ method:\n\n1. Checks whether an exception was passed as exc_type; if so, gen.throw(excep tion) is invoked, causing the exception to be raised in the yield line inside the generator function body.\n\n2. Otherwise, next(gen) is called, resuming the execution of the generator function body after the yield.\n\nExample 18-5 has a flaw: if an exception is raised in the body of the with block, the Python interpreter will catch it and raise it again in the yield expression inside look ing_glass. But there is no error handling there, so the looking_glass generator will terminate without ever restoring the original sys.stdout.write method, leaving the system in an invalid state.\n\nExample 18-7 adds special handling of the ZeroDivisionError exception, making it functionally equivalent to the class-based Example 18-3.\n\nExample 18-7. mirror_gen_exc.py: generator-based context manager implementing exception handling—same external behavior as Example 18-3\n\nimport contextlib import sys\n\n@contextlib.contextmanager\n\n3 The actual class is named _GeneratorContextManager. If you want to see exactly how it works, read its source\n\ncode in Lib/contextlib.py in Python 3.10.\n\n666\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 1815,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 697,
      "content": "def looking_glass(): original_write = sys.stdout.write\n\ndef reverse_write(text): original_write(text[::-1])\n\nsys.stdout.write = reverse_write msg = '' try: yield 'JABBERWOCKY' except ZeroDivisionError: msg = 'Please DO NOT divide by zero!' finally: sys.stdout.write = original_write if msg: print(msg)\n\nCreate a variable for a possible error message; this is the first change in relation to Example 18-5.\n\nHandle ZeroDivisionError by setting an error message.\n\nUndo monkey-patching of sys.stdout.write.\n\nDisplay error message, if it was set.\n\nRecall that the __exit__ method tells the interpreter that it has handled the exception by returning a truthy value; in that case, the interpreter suppresses the exception. On the other hand, if __exit__ does not explicitly return a value, the interpreter gets the usual None, and propagates the exception. With @contextmanager, the default behav‐ ior is inverted: the __exit__ method provided by the decorator assumes any excep‐ tion sent into the generator is handled and should be suppressed.\n\nHaving a try/finally (or a with block) around the yield is an unavoidable price of using @contextmanager, because you never know what the users of your context manager are going to do inside the with block.4\n\n4 This tip is quoted literally from a comment by Leonardo Rochael, one of the tech reviewers for this book.\n\nNicely said, Leo!\n\nContext Managers and with Blocks\n\n|\n\n667",
      "content_length": 1417,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 698,
      "content": "A little-known feature of @contextmanager is that the generators decorated with it can also be used as decorators themselves.5 That happens because @contextmanager is implemented with the contextlib.ContextDecorator class.\n\nExample 18-8 shows the looking_glass context manager from Example 18-5 used as decorator.\n\nExample 18-8. The looking_glass context manager also works as a decorator\n\n>>> @looking_glass() ... def verse(): ... print('The time has come') ... >>> verse() emoc sah emit ehT >>> print('back to normal') back to normal\n\nlooking_glass does its job before and after the body of verse runs.\n\nThis confirms that the original sys.write was restored.\n\nContrast Example 18-8 with Example 18-6, where looking_glass is used as a context manager.\n\nAn interesting real-life example of @contextmanager outside of the standard library is Martijn Pieters’ in-place file rewriting using a context manager. Example 18-9 shows how it’s used.\n\nExample 18-9. A context manager for rewriting files in place\n\nimport csv\n\nwith inplace(csvfilename, 'r', newline='') as (infh, outfh): reader = csv.reader(infh) writer = csv.writer(outfh)\n\nfor row in reader: row += ['new', 'columns'] writer.writerow(row)\n\nThe inplace function is a context manager that gives you two handles—infh and outfh in the example—to the same file, allowing your code to read and write to it at\n\n5 At least I and the other technical reviewers didn’t know it until Caleb Hattingh told us. Thanks, Caleb!\n\n668\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 1519,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 699,
      "content": "the same time. It’s easier to use than the standard library’s fileinput.input function (which also provides a context manager, by the way).\n\nIf you want to study Martijn’s inplace source code (listed in the post), find the yield keyword: everything before it deals with setting up the context, which entails creating a backup file, then opening and yielding references to the readable and writable file handles that will be returned by the __enter__ call. The __exit__ processing after the yield closes the file handles and restores the file from the backup if something went wrong.\n\nThis concludes our overview of the with statement and context managers. Let’s turn to match/case in the context of a complete example.\n\nPattern Matching in lis.py: A Case Study In “Pattern Matching Sequences in an Interpreter” on page 43 we saw examples of sequence patterns extracted from the evaluate function of Peter Norvig’s lis.py inter‐ preter, ported to Python 3.10. In this section I want to give a broader overview of how lis.py works, and also explore all the case clauses of evaluate, explaining not only the patterns but also what the interpreter does in each case.\n\nBesides showing more pattern matching, I wrote this section for three reasons:\n\n1. Norvig’s lis.py is a beautiful example of idiomatic Python code.\n\n2. The simplicity of Scheme is a master class of language design.\n\n3. Learning how an interpreter works gave me a deeper understanding of Python and programming languages in general—interpreted or compiled.\n\nBefore looking at the Python code, let’s get a little taste of Scheme so you can make sense of this case study—in case you haven’t seen Scheme or Lisp before.\n\nScheme Syntax In Scheme there is no distinction between expressions and statements, like we have in Python. Also, there are no infix operators. All expressions use prefix notation like (+ x 13) instead of x + 13. The same prefix notation is used for function calls—e.g., (gcd x 13)—and special forms—e.g., (define x 13), which we’d write as the assignment statement x = 13 in Python. The notation used by Scheme and most Lisp dialects is known as S-expression.6\n\n6 People complain about too many parentheses in Lisp, but thoughtful indentation and a good editor mostly take care of that issue. The main readability problem is using the same (f …) notation for function calls and special forms like (define …), (if …), and (quote …) that don’t behave at all like function calls.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n669",
      "content_length": 2508,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 700,
      "content": "Example 18-10 shows a simple example in Scheme.\n\nExample 18-10. Greatest common divisor in Scheme\n\n(define (mod m n) (- m (* n (quotient m n))))\n\n(define (gcd m n) (if (= n 0) m (gcd n (mod m n))))\n\n(display (gcd 18 45))\n\nExample 18-10 shows three Scheme expressions: two function definitions—mod and gcd—and a call to display, which will output 9, the result of (gcd 18 45). Example 18-11 is the same code in Python (shorter than an English explanation of the recursive Euclidean algorithm).\n\nExample 18-11. Same as Example 18-10, written in Python\n\ndef mod(m, n): return m - (m // n * n)\n\ndef gcd(m, n): if n == 0: return m else: return gcd(n, mod(m, n))\n\nprint(gcd(18, 45))\n\nIn idiomatic Python, I’d use the % operator instead of reinventing mod, and it would be more efficient to use a while loop instead of recursion. But I wanted to show two function definitions, and make the examples as similar as possible, to help you read the Scheme code.\n\nScheme has no iterative control flow commands like while or for. Iteration is done with recursion. Note how there are no assignments in the Scheme and Python exam‐ ples. Extensive use of recursion and minimal use of assignment are hallmarks of pro‐ gramming in a functional style.7\n\n7 To make iteration through recursion practical and efficient, Scheme and other functional languages imple‐\n\nment proper tail calls. For more about this, see “Soapbox” on page 691.\n\n670\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 1464,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 701,
      "content": "Now let’s review the code of the Python 3.10 version of lis.py. The complete source code with tests is in the 18-with-match/lispy/py3.10/ directory of the GitHub reposi‐ tory fluentpython/example-code-2e.\n\nImports and Types Example 18-12 shows the first lines of lis.py. The use of TypeAlias and the | type union operator require Python 3.10.\n\nExample 18-12. lis.py: top of the file\n\nimport math import operator as op from collections import ChainMap from itertools import chain from typing import Any, TypeAlias, NoReturn\n\nSymbol: TypeAlias = str Atom: TypeAlias = float | int | Symbol Expression: TypeAlias = Atom | list\n\nThe types defined are:\n\nSymbol\n\nJust an alias for str. In lis.py, Symbol is used for identifiers; there is no string data type with operations such as slicing, splitting, etc.8\n\nAtom\n\nA simple syntactic element, such as a number or a Symbol—as opposed to a com‐ posite structure made of distinct parts, like a list.\n\nExpression\n\nThe building blocks of Scheme programs are expressions made of atoms and lists, possibly nested.\n\nThe Parser Norvig’s parser is 36 lines of code showcasing the power of Python applied to han‐ dling the simple recursive syntax of S-expression—without string data, comments, macros, and other features of standard Scheme that make parsing more complicated (Example 18-13).\n\n8 But Norvig’s second interpreter, lispy.py, supports strings as a data type, as well as advanced features like syn‐ tactic macros, continuations, and proper tail calls. However, lispy.py is almost three times longer than lis.py— and much harder to understand.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n671",
      "content_length": 1635,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 702,
      "content": "Example 18-13. lis.py: the main parsing functions\n\ndef parse(program: str) -> Expression: \"Read a Scheme expression from a string.\" return read_from_tokens(tokenize(program))\n\ndef tokenize(s: str) -> list[str]: \"Convert a string into a list of tokens.\" return s.replace('(', ' ( ').replace(')', ' ) ').split()\n\ndef read_from_tokens(tokens: list[str]) -> Expression: \"Read an expression from a sequence of tokens.\" # more parsing code omitted in book listing\n\nThe main function of that group is parse, which takes an S-expression as a str and returns an Expression object, as defined in Example 18-12: an Atom or a list that may contain more atoms and nested lists.\n\nNorvig uses a smart trick in tokenize: he adds spaces before and after each parenthe‐ sis in the input and then splits it, resulting in a list of syntactic tokens with '(' and ')' as separate tokens. This shortcut works because there is no string type in the little Scheme of lis.py, so every '(' or ')' is an expression delimiter. The recursive parsing code is in read_from_tokens, a 14-line function that you can read in the fluentpy‐ thon/example-code-2e repository. I will skip it because I want to focus on the other parts of the interpreter.\n\nHere are some doctests extracted from lispy/py3.10/examples_test.py:\n\n>>> from lis import parse >>> parse('1.5') 1.5 >>> parse('ni!') 'ni!' >>> parse('(gcd 18 45)') ['gcd', 18, 45] >>> parse(''' ... (define double ... (lambda (n) ... (* n 2))) ... ''') ['define', 'double', ['lambda', ['n'], ['*', 'n', 2]]]\n\nThe parsing rules for this subset of Scheme are simple:\n\n1. A token that looks like a number is parsed as a float or int. 2. Anything else that is not '(' or ')' is parsed as a Symbol—a str to be used as an identifier. This includes source text like +, set!, and make-counter that are valid identifiers in Scheme but not in Python.\n\n672\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 1905,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 703,
      "content": "3. Expressions inside '(' and ')' are recursively parsed as lists containing atoms or as nested lists that may contain atoms and more nested lists.\n\nUsing the terminology of the Python interpreter, the output of parse is an AST (Abstract Syntax Tree): a convenient representation of the Scheme program as nested lists forming a tree-like structure, where the outermost list is the trunk, inner lists are the branches, and atoms are the leaves (Figure 18-1).\n\nFigure 18-1. A Scheme lambda expression represented as source code (concrete syntax), as a tree, and as a sequence of Python objects (abstract syntax).\n\nThe Environment The Environment class extends collections.ChainMap, adding a change method to update a value inside one of the chained dicts, which ChainMap instances hold in a list of mappings: the self.maps attribute. The change method is needed to support the Scheme (set! …) form, described later; see Example 18-14.\n\nExample 18-14. lis.py: the Environment class\n\nclass Environment(ChainMap[Symbol, Any]): \"A ChainMap that allows changing an item in-place.\"\n\ndef change(self, key: Symbol, value: Any) -> None: \"Find where key is defined and change the value there.\" for map in self.maps: if key in map:\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n673",
      "content_length": 1268,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 704,
      "content": "map[key] = value # type: ignore[index] return raise KeyError(key)\n\nNote that the change method only updates existing keys.9 Trying to change a key that is not found raises KeyError.\n\nThis doctest shows how Environment works:\n\n>>> from lis import Environment >>> inner_env = {'a': 2} >>> outer_env = {'a': 0, 'b': 1} >>> env = Environment(inner_env, outer_env) >>> env['a'] 2 >>> env['a'] = 111 >>> env['c'] = 222 >>> env Environment({'a': 111, 'c': 222}, {'a': 0, 'b': 1}) >>> env.change('b', 333) >>> env Environment({'a': 111, 'c': 222}, {'a': 0, 'b': 333})\n\nWhen reading values, Environment works as ChainMap: keys are searched in the nested mappings from left to right. That’s why the value of a in the outer_env is shadowed by the value in inner_env.\n\nAssigning with [] overwrites or inserts new items, but always in the first map‐ ping, inner_env in this example.\n\nenv.change('b', 333) seeks the 'b' key and assigns a new value to it in-place, in the outer_env.\n\nNext is the standard_env() function, which builds and returns an Environment loaded with predefined functions, similar to Python’s __builtins__ module that is always available (Example 18-15).\n\nExample 18-15. lis.py: standard_env() builds and returns the global environment\n\ndef standard_env() -> Environment: \"An environment with some Scheme standard procedures.\" env = Environment() env.update(vars(math)) # sin, cos, sqrt, pi, ...\n\n9 The # type: ignore[index] comment is there because of typeshed issue #6042, which is unresolved as I\n\nreview this chapter. ChainMap is annotated as MutableMapping, but the type hint in the maps attribute says it’s a list of Mapping, indirectly making the whole ChainMap immutable as far as Mypy is concerned.\n\n674\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 1764,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 705,
      "content": "env.update({ '+': op.add, '-': op.sub, '*': op.mul, '/': op.truediv, # omitted here: more operator definitions 'abs': abs, 'append': lambda *args: list(chain(*args)), 'apply': lambda proc, args: proc(*args), 'begin': lambda *x: x[-1], 'car': lambda x: x[0], 'cdr': lambda x: x[1:], # omitted here: more function definitions 'number?': lambda x: isinstance(x, (int, float)), 'procedure?': callable, 'round': round, 'symbol?': lambda x: isinstance(x, Symbol), }) return env\n\nTo summarize, the env mapping is loaded with:\n\nAll functions from Python’s math module • Selected operators from Python’s op module • Simple but powerful functions built with Python’s lambda • Python built-ins renamed, like callable as procedure?, or directly mapped, like round\n\nThe REPL Norvig’s REPL (read-eval-print-loop) is easy to understand but not user-friendly (see Example 18-16). If no command-line arguments are given to lis.py, the repl() func‐ tion is invoked by main()—defined at the end of the module. At the lis.py> prompt, we must enter correct and complete expressions; if we forget to close one parenthesis, lis.py crashes.10\n\n10 As I studied Norvig’s lis.py and lispy.py, I started a fork named mylis that adds some features, including a REPL that accepts partial S-expressions and prompts for the continuation, similar to how Python’s REPL knows we are not finished and presents the secondary prompt (...) until we enter a complete expression or statement that can be evaluated. mylis also handles a few errors gracefully, but it’s still easy to crash. It’s not nearly as robust as Python’s REPL.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n675",
      "content_length": 1641,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 706,
      "content": "Example 18-16. The REPL functions\n\ndef repl(prompt: str = 'lis.py> ') -> NoReturn: \"A prompt-read-eval-print loop.\" global_env = Environment({}, standard_env()) while True: ast = parse(input(prompt)) val = evaluate(ast, global_env) if val is not None: print(lispstr(val))\n\ndef lispstr(exp: object) -> str: \"Convert a Python object back into a Lisp-readable string.\" if isinstance(exp, list): return '(' + ' '.join(map(lispstr, exp)) + ')' else: return str(exp)\n\nHere is a quick explanation about these two functions:\n\nrepl(prompt: str = 'lis.py> ') -> NoReturn\n\nCalls standard_env() to provide built-in functions for the global environment, then enters an infinite loop, reading and parsing each input line, evaluating it in the global environment, and displaying the result—unless it’s None. The global_env may be modified by evaluate. For example, when a user defines a new global variable or named function, it is stored in the first mapping of the environment—the empty dict in the Environment constructor call in the first line of repl.\n\nlispstr(exp: object) -> str\n\nThe inverse function of parse: given a Python object representing an expression, parse returns the Scheme source code for it. For example, given ['+', 2, 3], the result is '(+ 2 3)'.\n\nThe Evaluator Now we can appreciate the beauty of Norvig’s expression evaluator—made a little prettier with match/case. The evaluate function in Example 18-17 takes an Expres sion built by parse and an Environment.\n\nThe body of evaluate is a single match statement with an expression exp as the sub‐ ject. The case patterns express the syntax and semantics of Scheme with amazing clarity.\n\n676\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 1694,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 707,
      "content": "Example 18-17. evaluate takes an expression and computes its value\n\nKEYWORDS = ['quote', 'if', 'lambda', 'define', 'set!']\n\ndef evaluate(exp: Expression, env: Environment) -> Any: \"Evaluate an expression in an environment.\" match exp: case int(x) | float(x): return x case Symbol(var): return env[var] case ['quote', x]: return x case ['if', test, consequence, alternative]: if evaluate(test, env): return evaluate(consequence, env) else: return evaluate(alternative, env) case ['lambda', [*parms], *body] if body: return Procedure(parms, body, env) case ['define', Symbol(name), value_exp]: env[name] = evaluate(value_exp, env) case ['define', [Symbol(name), *parms], *body] if body: env[name] = Procedure(parms, body, env) case ['set!', Symbol(name), value_exp]: env.change(name, evaluate(value_exp, env)) case [func_exp, *args] if func_exp not in KEYWORDS: proc = evaluate(func_exp, env) values = [evaluate(arg, env) for arg in args] return proc(*values) case _: raise SyntaxError(lispstr(exp))\n\nLet’s study each case clause and what it does. In some cases I added comments show‐ ing an S-expression that would match the pattern when parsed into a Python list. Doctests extracted from examples_test.py demonstrate each case.\n\nEvaluating numbers\n\ncase int(x) | float(x): return x\n\nSubject:\n\nInstance of int or float.\n\nAction:\n\nReturn value as is.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n677",
      "content_length": 1398,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 708,
      "content": "Example:\n\n>>> from lis import parse, evaluate, standard_env >>> evaluate(parse('1.5'), {}) 1.5\n\nEvaluating symbols\n\ncase Symbol(var): return env[var]\n\nSubject:\n\nInstance of Symbol, i.e., a str used as an identifier.\n\nAction:\n\nLook up var in env and return its value.\n\nExamples:\n\n>>> evaluate(parse('+'), standard_env()) <built-in function add> >>> evaluate(parse('ni!'), standard_env()) Traceback (most recent call last): ... KeyError: 'ni!'\n\n(quote …)\n\nThe quote special form treats atoms and lists as data instead of expressions to be evaluated.\n\n# (quote (99 bottles of beer)) case ['quote', x]: return x\n\nSubject:\n\nList starting with the symbol 'quote', followed by one expression x.\n\nAction:\n\nReturn x without evaluating it.\n\nExamples:\n\n>>> evaluate(parse('(quote no-such-name)'), standard_env()) 'no-such-name' >>> evaluate(parse('(quote (99 bottles of beer))'), standard_env()) [99, 'bottles', 'of', 'beer'] >>> evaluate(parse('(quote (/ 10 0))'), standard_env()) ['/', 10, 0]\n\nWithout quote, each expression in the test would raise an error:\n\n678\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 1099,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 709,
      "content": "no-such-name would be looked up in the environment, raising KeyError • (99 bottles of beer) cannot be evaluated because the number 99 is not a Symbol naming a special form, operator, or function\n\n(/ 10 0) would raise ZeroDivisionError\n\nWhy Languages Have Reserved Keywords Although simple, quote cannot be implemented as a function in Scheme. Its special power is to prevent the interpreter from evaluating (f 10) in the expression (quote (f 10)): the result is simply a list with a Symbol and an int. In contrast, in a function call like (abs (f 10)), the interpreter evaluates (f 10) before invoking abs. That’s why quote is a reserved keyword: it must be handled as a special form.\n\nIn general, reserved keywords are needed:\n\nTo introduce specialized evaluation rules, as in quote and lambda—which don’t evaluate any of their subexpressions\n\nTo change the control flow, as in if and function calls—which also have special evaluation rules\n\nTo manage the environment, as in define and set\n\nThis is also why Python, and programming languages in general, need reserved key‐ words. Think about Python’s def, if, yield, import, del, and what they do.\n\n(if …)\n\n# (if (< x 0) 0 x) case ['if', test, consequence, alternative]: if evaluate(test, env): return evaluate(consequence, env) else: return evaluate(alternative, env)\n\nSubject:\n\nList starting with 'if' followed by three expressions: test, consequence, and alternative.\n\nAction:\n\nEvaluate test:\n\nIf true, evaluate consequence and return its value. • Otherwise, evaluate alternative and return its value.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n679",
      "content_length": 1605,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 710,
      "content": "Examples:\n\n>>> evaluate(parse('(if (= 3 3) 1 0))'), standard_env()) 1 >>> evaluate(parse('(if (= 3 4) 1 0))'), standard_env()) 0\n\nThe consequence and alternative branches must be single expressions. If more than one expression is needed in a branch, you can combine them with (begin exp1 exp2…), provided as a function in lis.py—see Example 18-15.\n\n(lambda …)\n\nScheme’s lambda form defines anonymous functions. It doesn’t suffer from the limi‐ tations of Python’s lambda: any function that can be written in Scheme can be written using the (lambda …) syntax.\n\n# (lambda (a b) (/ (+ a b) 2)) case ['lambda' [*parms], *body] if body: return Procedure(parms, body, env)\n\nSubject:\n\nList starting with 'lambda', followed by:\n\nList of zero or more parameter names. • One or more expressions collected in body (the guard ensures that body is not empty).\n\nAction:\n\nCreate and return a new Procedure instance with the parameter names, the list of expressions as the body, and the current environment.\n\nExample:\n\n>>> expr = '(lambda (a b) (* (/ a b) 100))' >>> f = evaluate(parse(expr), standard_env()) >>> f # doctest: +ELLIPSIS <lis.Procedure object at 0x...> >>> f(15, 20) 75.0\n\nThe Procedure class implements the concept of a closure: a callable object holding parameter names, a function body, and a reference to the environment in which the function is defined. We’ll study the code for Procedure in a moment.\n\n680\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 1455,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 711,
      "content": "(define …)\n\nThe define keyword is used in two different syntactic forms. The simplest is:\n\n# (define half (/ 1 2)) case ['define', Symbol(name), value_exp]: env[name] = evaluate(value_exp, env)\n\nSubject:\n\nList starting with 'define', followed by a Symbol and an expression.\n\nAction:\n\nEvaluate the expression and put its value into env, using name as key.\n\nExample:\n\n>>> global_env = standard_env() >>> evaluate(parse('(define answer (* 7 6))'), global_env) >>> global_env['answer'] 42\n\nThe doctest for this case creates a global_env so that we can verify that evaluate puts answer into that Environment.\n\nWe can use that simple define form to create variables or to bind names to anony‐ mous functions, using (lambda …) as the value_exp.\n\nStandard Scheme provides a shortcut for defining named functions. That’s the sec‐ ond define form:\n\n# (define (average a b) (/ (+ a b) 2)) case ['define', [Symbol(name), *parms], *body] if body: env[name] = Procedure(parms, body, env)\n\nSubject:\n\nList starting with 'define', followed by:\n\nA list starting with a Symbol(name), followed by zero or more items collected into a list named parms.\n\nOne or more expressions collected in body (the guard ensures that body is not empty).\n\nAction:\n\nCreate a new Procedure instance with the parameter names, the list of expres‐ sions as the body, and the current environment.\n\nPut the Procedure into env, using name as key.\n\nThe doctest in Example 18-18 defines a function named % that computes a percentage and adds it to the global_env.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n681",
      "content_length": 1566,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 712,
      "content": "Example 18-18. Defining a function named % that computes a percentage\n\n>>> global_env = standard_env() >>> percent = '(define (% a b) (* (/ a b) 100))' >>> evaluate(parse(percent), global_env) >>> global_env['%'] # doctest: +ELLIPSIS <lis.Procedure object at 0x...> >>> global_env['%'](170, 200) 85.0\n\nAfter calling evaluate, we check that % is bound to a Procedure that takes two numeric arguments and returns a percentage.\n\nThe pattern for the second define case does not enforce that the items in parms are all Symbol instances. I’d have to check that before building the Procedure, but I didn’t—to keep the code as easy to follow as Norvig’s.\n\n(set! …)\n\nThe set! form changes the value of a previously defined variable.11\n\n# (set! n (+ n 1)) case ['set!', Symbol(name), value_exp]: env.change(name, evaluate(value_exp, env))\n\nSubject:\n\nList starting with 'set!', followed by a Symbol and an expression.\n\nAction:\n\nUpdate the value of name in env with the result of evaluating the expression.\n\nThe Environment.change method traverses the chained environments from local to global, and updates the first occurrence of name with the new value. If we were not implementing the 'set!' keyword, we could use Python’s ChainMap as the Environ ment type everywhere in this interpreter.\n\n11 Assignment is one of the first features taught in many programming tutorials, but set! only appears on page 220 of the best known Scheme book, Structure and Interpretation of Computer Programs, 2nd ed., by Abelson et al. (MIT Press), a.k.a. SICP or the “Wizard Book.” Coding in a functional style can take us very far without the state changes that are typical of imperative and object-oriented programming.\n\n682\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 1741,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 713,
      "content": "Python’s nonlocal and Scheme’s set! Address the Same Issue The use of the set! form is related to the use of the nonlocal keyword in Python: declaring nonlocal x allows x = 10 to update a previously defined x variable outside of the local scope. Without a nonlocal x declaration, x = 10 will always create a local variable in Python, as we saw in “The nonlocal Declaration” on page 315.\n\nSimilarly, (set! x 10) updates a previously defined x that may be outside of the local environment of the function. In contrast, the variable x in (define x 10) is always a local variable, created or updated in the local environment.\n\nBoth nonlocal and (set! …) are needed to update program state held in variables within a closure. Example 9-13 demonstrated the use of nonlocal to implement a function to compute a running average, holding an item count and total in a clo‐ sure. Here is that same idea, written in the Scheme subset of lis.py:\n\n(define (make-averager) (define count 0) (define total 0) (lambda (new-value) (set! count (+ count 1)) (set! total (+ total new-value)) (/ total count) ) ) (define avg (make-averager)) (avg 10) (avg 11) (avg 15)\n\nCreates a new closure with the inner function defined by lambda, and the vari‐ ables count and total initialized to 0; binds the closure to avg.\n\nReturns 10.0.\n\nReturns 10.5.\n\nReturns 12.0.\n\nThe preceding code is one of the tests in lispy/py3.10/examples_test.py.\n\nNow we get to a function call.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n683",
      "content_length": 1492,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 714,
      "content": "Function call\n\n# (gcd (* 2 105) 84) case [func_exp, *args] if func_exp not in KEYWORDS: proc = evaluate(func_exp, env) values = [evaluate(arg, env) for arg in args] return proc(*values)\n\nSubject:\n\nList with one or more items.\n\nThe guard ensures that func_exp is not one of ['quote', 'if', 'define', 'lambda', 'set!']—listed right before evaluate in Example 18-17.\n\nThe pattern matches any list with one or more expressions, binding the first expression to func_exp and the rest to args as a list, which may be empty.\n\nAction:\n\nEvaluate func_exp to obtain a function proc. • Evaluate each item in args to build a list of argument values. • Call proc with the values as separate arguments, returning the result.\n\nExample:\n\n>>> evaluate(parse('(% (* 12 14) (- 500 100))'), global_env) 42.0\n\nThis doctest continues from Example 18-18: it assumes global_env has a function named %. The arguments given to % are arithmetic expressions, to emphasize that the arguments are evaluated before the function is called.\n\nThe guard in this case is needed because [func_exp, *args] matches any sequence subject with one or more items. However, if func_exp is a keyword, and the subject did not match any previous case, then it is really a syntax error.\n\nCatch syntax errors\n\nIf the subject exp does not match any of the previous cases, the catch-all case raises a SyntaxError:\n\ncase _: raise SyntaxError(lispstr(exp))\n\nHere is an example of a malformed (lambda …) reported as a SyntaxError:\n\n>>> evaluate(parse('(lambda is not like this)'), standard_env()) Traceback (most recent call last): ... SyntaxError: (lambda is not like this)\n\n684\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 1669,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 715,
      "content": "If the case for function call did not have that guard rejecting keywords, the (lambda is not like this) expression would be handled as a function call, which would raise KeyError because 'lambda' is not part of the environment—just like lambda is not a Python built-in function.\n\nProcedure: A Class Implementing a Closure The Procedure class could very well be named Closure, because that’s what it repre‐ sents: a function definition together with an environment. The function definition includes the name of the parameters and the expressions that make up the body of the function. The environment is used when the function is called to provide the val‐ ues of the free variables: variables that appear in the body of the function but are not parameters, local variables, or global variables. We saw the concepts of closure and free variable in “Closures” on page 311.\n\nWe learned how to use closures in Python, but now we can dive deeper and see how a closure is implemented in lis.py:\n\nclass Procedure: \"A user-defined Scheme procedure.\"\n\ndef __init__( self, parms: list[Symbol], body: list[Expression], env: Environment ): self.parms = parms self.body = body self.env = env\n\ndef __call__(self, *args: Expression) -> Any: local_env = dict(zip(self.parms, args)) env = Environment(local_env, self.env) for exp in self.body: result = evaluate(exp, env) return result\n\nCalled when a function is defined by the lambda or define forms.\n\nSave the parameter names, body expressions, and environment for later use.\n\nCalled by proc(*values) in the last line of the case [func_exp, *args] clause.\n\nBuild local_env mapping self.parms as local variable names, and the given args as values.\n\nBuild a new combined env, putting local_env first, and then self.env—the environment that was saved when the function was defined.\n\nPattern Matching in lis.py: A Case Study\n\n|\n\n685",
      "content_length": 1863,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 716,
      "content": "Iterate over each expression in self.body, evaluating it in the combined env.\n\nReturn the result of the last expression evaluated.\n\nThere are a couple of simple functions after evaluate in lis.py: run reads a complete Scheme program and executes it, and main calls run or repl, depending on the com‐ mand line—similar to what Python does. I will not describe those functions because there’s nothing new in them. My goals were to share with you the beauty of Norvig’s little interpreter, to give more insight into how closures work, and to show how match/case is a great addition to Python.\n\nTo wrap up this extended section on pattern matching, let’s formalize the concept of an OR-pattern.\n\nUsing OR-patterns A series of patterns separated by | is an OR-pattern: it succeeds if any of the subpat‐ terns succeed. The pattern in “Evaluating numbers” on page 677 is an OR-pattern:\n\ncase int(x) | float(x): return x\n\nAll subpatterns in an OR-pattern must use the same variables. This restriction is nec‐ essary to ensure that the variables are available to the guard expression and the case body, regardless of the subpattern that matched.\n\nIn the context of a case clause, the | operator has a special mean‐ ing. It does not trigger the __or__ special method, which handles expressions like a | b in other contexts, where it is overloaded to perform operations such as set union or integer bitwise-or, depending on the operands.\n\nAn OR-pattern is not restricted to appear at the top level of a pattern. You can also use | in subpatterns. For example, if we wanted lis.py to accept the Greek letter λ (lambda)12 as well as the lambda keyword, we can rewrite the pattern like this:\n\n# (λ (a b) (/ (+ a b) 2) ) case ['lambda' | 'λ', [*parms], *body] if body: return Procedure(parms, body, env)\n\n12 The official Unicode name for λ (U+03BB) is GREEK SMALL LETTER LAMDA. This is not a typo: the char‐ acter is named “lamda” without the “b” in the Unicode database. According to the English Wikipedia article “Lambda”, the Unicode Consortium adopted that spelling because of “preferences expressed by the Greek National Body.”\n\n686\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 2167,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 717,
      "content": "Now we can move to the third and last subject of this chapter: the unusual places where an else clause may appear in Python.\n\nDo This, Then That: else Blocks Beyond if This is no secret, but it is an underappreciated language feature: the else clause can be used not only in if statements but also in for, while, and try statements.\n\nThe semantics of for/else, while/else, and try/else are closely related, but very different from if/else. Initially, the word else actually hindered my understanding of these features, but eventually I got used to it.\n\nHere are the rules:\n\nfor\n\nThe else block will run only if and when the for loop runs to completion (i.e., not if the for is aborted with a break).\n\nwhile\n\nThe else block will run only if and when the while loop exits because the condi‐ tion became falsy (i.e., not if the while is aborted with a break).\n\ntry\n\nThe else block will run only if no exception is raised in the try block. The offi‐ cial docs also state: “Exceptions in the else clause are not handled by the preced‐ ing except clauses.”\n\nIn all cases, the else clause is also skipped if an exception or a return, break, or continue statement causes control to jump out of the main block of the compound statement.\n\nI think else is a very poor choice for the keyword in all cases except if. It implies an excluding alternative, like, “Run this loop, otherwise do that,” but the semantics for else in loops is the oppo‐ site: “Run this loop, then do that.” This suggests then as a better keyword—which would also make sense in the try context: “Try this, then do that.” However, adding a new keyword is a breaking change to the language—not an easy decision to make.\n\nUsing else with these statements often makes the code easier to read and saves the trouble of setting up control flags or coding extra if statements.\n\nThe use of else in loops generally follows the pattern of this snippet:\n\nfor item in my_list: if item.flavor == 'banana':\n\nDo This, Then That: else Blocks Beyond if\n\n|\n\n687",
      "content_length": 2003,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 718,
      "content": "break else: raise ValueError('No banana flavor found!')\n\nIn the case of try/except blocks, else may seem redundant at first. After all, the after_call() in the following snippet will run only if the dangerous_call() does not raise an exception, correct?\n\ntry: dangerous_call() after_call() except OSError: log('OSError...')\n\nHowever, doing so puts the after_call() inside the try block for no good reason. For clarity and correctness, the body of a try block should only have the statements that may generate the expected exceptions. This is better:\n\ntry: dangerous_call() except OSError: log('OSError...') else: after_call()\n\nit’s clear that the try block\n\nNow in dangerous_call() and not in after_call(). It’s also explicit that after_call() will only execute if no exceptions are raised in the try block.\n\nis guarding against possible errors\n\nIn Python, try/except is commonly used for control flow, and not just for error handling. There’s even an acronym/slogan for that documented in the official Python glossary:\n\nEAFP\n\nEasier to ask for forgiveness than permission. This common Python coding style assumes the existence of valid keys or attributes and catches exceptions if the assumption proves false. This clean and fast style is characterized by the presence of many try and except statements. The technique contrasts with the LBYL style common to many other languages such as C.\n\nThe glossary then defines LBYL:\n\nLBYL\n\nLook before you leap. This coding style explicitly tests for pre-conditions before making calls or lookups. This style contrasts with the EAFP approach and is char‐ acterized by the presence of many if statements. In a multi-threaded environment, the LBYL approach can risk introducing a race condition between “the looking” and “the leaping.” For example, the code, if key in mapping: return mapping[key] can fail if another thread removes key from mapping after the test, but before the lookup. This issue can be solved with locks or by using the EAFP approach.\n\n688\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 2044,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 719,
      "content": "Given the EAFP style, it makes even more sense to know and use else blocks well in try/except statements.\n\nWhen the match statement was discussed, some people (including me) thought it should also have an else clause. In the end it was decided that it wasn’t needed because case _: does the same job.13\n\nNow let’s summarize the chapter.\n\nChapter Summary This chapter started with context managers and the meaning of the with statement, quickly moving beyond its common use to automatically close opened files. We implemented a custom context manager: the LookingGlass class with the __enter__/__exit__ methods, and saw how to handle exceptions in the __exit__ method. A key point that Raymond Hettinger made in his PyCon US 2013 keynote is that with is not just for resource management; it’s a tool for factoring out common setup and teardown code, or any pair of operations that need to be done before and after another procedure.14\n\nWe reviewed functions in the contextlib standard library module. One of them, the @contextmanager decorator, makes it possible to implement a context manager using a simple generator with one yield—a leaner solution than coding a class with at least two methods. We reimplemented the LookingGlass as a looking_glass generator function, and discussed how to do exception handling when using @contextmanager.\n\nThen we studied Peter Norvig’s elegant lis.py, a Scheme interpreter written in idiomatic Python, refactored to use match/case in evaluate—the function at the core of any interpreter. Understanding how evaluate works required reviewing a lit‐ tle bit of Scheme, a parser for S-expressions, a simple REPL, and the construction of nested scopes through an Environment subclass of collection.ChainMap. In the end, lis.py became a vehicle to explore much more than pattern matching. It shows how the different parts of an interpreter work together, illuminating core features of Python itself: why reserved keywords are necessary, how scoping rules work, and how closures are built and used.\n\n13 Watching the discussion in the python-dev mailing list I thought one reason why else was rejected was the lack of consensus on how to indent it within match: should else be indented at the same level as match, or at the same level as case?\n\n14 See slide 21 in “Python is Awesome”.\n\nChapter Summary\n\n|\n\n689",
      "content_length": 2339,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 720,
      "content": "Further Reading Chapter 8, “Compound Statements,” in The Python Language Reference says pretty much everything there is to say about else clauses in if, for, while, and try state‐ ments. Regarding Pythonic usage of try/except, with or without else, Raymond Hettinger has a brilliant answer to the question “Is it a good practice to use try- except-else in Python?” in StackOverflow. Python in a Nutshell, 3rd ed., by Martelli et al., has a chapter about exceptions with an excellent discussion of the EAFP style, crediting computing pioneer Grace Hopper for coining the phrase, “It’s easier to ask forgiveness than permission.”\n\nThe Python Standard Library, Chapter 4, “Built-in Types,” has a section devoted to “Context Manager Types”. The __enter__/__exit__ special methods are also docu‐ mented in The Python Language Reference in “With Statement Context Managers”. Context managers were introduced in PEP 343—The “with” Statement.\n\nRaymond Hettinger highlighted the with statement as a “winning language feature” in his PyCon US 2013 keynote. He also showed some interesting applications of con‐ text managers in his talk, “Transforming Code into Beautiful, Idiomatic Python”, at the same conference.\n\nJeff Preshing’s blog post “The Python with Statement by Example” is interesting for the examples using context managers with the pycairo graphics library.\n\nThe contextlib.ExitStack class is based on an original idea by Nikolaus Rath, who wrote a short post explaining why its useful: “On the Beauty of Python’s ExitStack”. In that text, Rath submits that ExitStack is similar but more flexible than the defer statement in Go—which I think is one of the best ideas in that language.\n\nBeazley and Jones devised context managers for very different purposes in their Python Cookbook, 3rd ed. “Recipe 8.3. Making Objects Support the Context- Management Protocol” implements a LazyConnection class whose instances are con‐ text managers that open and close network connections automatically in with blocks. “Recipe 9.22. Defining Context Managers the Easy Way” introduces a context man‐ ager for timing code, and another for making transactional changes to a list object: within the with block, a working copy of the list instance is made, and all changes are applied to that working copy. Only when the with block completes without an exception, the working copy replaces the original list. Simple and ingenious.\n\nPeter Norvig describes his small Scheme interpreters in the posts “(How to Write a (Lisp) Interpreter (in Python))” and “(An ((Even Better) Lisp) Interpreter (in Python))”. The code for lis.py and lispy.py is the norvig/pytudes repository. My repos‐ itory fluentpython/lispy includes the mylis forks of lis.py, updated to Python 3.10, with a nicer REPL, command-line integration, examples, more tests, and references for\n\n690\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 2885,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 721,
      "content": "learning more about Scheme. The best Scheme dialect and environment to learn and experiment is Racket.\n\nSoapbox\n\nFactoring Out the Bread\n\nIn his PyCon US 2013 keynote, “What Makes Python Awesome”, Raymond Het‐ tinger says when he first saw the with statement proposal he thought it was “a little bit arcane.” Initially, I had a similar reaction. PEPs are often hard to read, and PEP 343 is typical in that regard.\n\nThen—Hettinger told us—he had an insight: subroutines are the most important invention in the history of computer languages. If you have sequences of operations like A;B;C and P;B;Q, you can factor out B in a subroutine. It’s like factoring out the filling in a sandwich: using tuna with different breads. But what if you want to factor out the bread, to make sandwiches with wheat bread, using a different filling each time? That’s what the with statement offers. It’s the complement of the subroutine. Hettinger went on to say:\n\nThe with statement is a very big deal. I encourage you to go out and take this tip of the iceberg and drill deeper. You can probably do profound things with the with statement. The best uses of it have not been discovered yet. I expect that if you make good use of it, it will be copied into other languages and all future languages will have it. You can be part of discovering something almost as profound as the invention of the subroutine itself.\n\nHettinger admits he is overselling the with statement. Nevertheless, it is a very useful feature. When he used the sandwich analogy to explain how with is the complement to the subroutine, many possibilities opened up in my mind.\n\nIf you need to convince anyone that Python is awesome, you should watch Het‐ tinger’s keynote. The bit about context managers is from 23:00 to 26:15. But the entire keynote is excellent.\n\nEfficient Recursion with Proper Tail Calls\n\nStandard Scheme implementations are required to provide proper tail calls (PTC), to make iteration through recursion a practical alternative to while loops in imperative languages. Some writers refer to PTC as tail call optimization (TCO); for others, TCO is something different. For more details, see “Tail call” on Wikipedia and “Tail call optimization in ECMAScript 6”.\n\nA tail call is when a function returns the result of a function call, which may be the same function or not. The gcd examples in Example 18-10 and Example 18-11 make (recursive) tail calls in the falsy branch of the if.\n\nOn the other hand, this factorial does not make a tail call:\n\nFurther Reading\n\n|\n\n691",
      "content_length": 2540,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 722,
      "content": "def factorial(n): if n < 2: return 1 return n * factorial(n - 1)\n\nThe call to factorial in the last line is not a tail call because the return value is not the result of the recursive call: the result is multiplied by n before it is returned.\n\nHere is an alternative that uses a tail call, and is therefore tail recursive:\n\ndef factorial_tc(n, product=1): if n < 1: return product return factorial_tc(n - 1, product * n)\n\nPython does not have PTC, so there’s no advantage in writing tail recursive functions. In this case, the first version is shorter and more readable in my opinion. For real-life uses, don’t forget that Python has math.factorial, written in C without recursion. The point is that, even in languages that implement PTC, it does not benefit every recursive function, only those that are carefully written to make tail calls.\n\nIf PTC is supported by the language, when the interpreter sees a tail call, it jumps into the body of the called function without creating a new stack frame, saving memory. There are also compiled languages that implement PTC, sometimes as an optimiza‐ tion that can be toggled.\n\nThere is no universal consensus about the definition of TCO or the value of PTC in languages that were not designed as functional languages from the ground up, like Python or JavaScript. In functional languages, PTC is an expected feature, not merely an optimization that is nice to have. If a language has no iteration mechanism other than recursion, then PTC is necessary for practical usage. Norvig’s lis.py does not implement PTC, but his more elaborate lispy.py interpreter does.\n\nThe Case Against Proper Tail Calls in Python and JavaScript\n\nCPython does not implement PTC, and probably never will. Guido van Rossum wrote “Final Words on Tail Calls” to explain why. To summarize, here is a key pas‐ sage from his post:\n\nPersonally, I think it is a fine feature for some languages, but I don’t think it fits Python: the elimination of stack traces for some calls but not others would certainly confuse many users, who have not been raised with tail call religion but might have learned about call semantics by tracing through a few calls in a debugger.\n\nIn 2015, PTC was included in the ECMAScript 6 standard for JavaScript. As of Octo‐ ber 2021, the interpreter in WebKit implements it. WebKit is used by Safari. The JS interpreters in every other major browser don’t have PTC, and neither does Node.js, as it relies on the V8 engine that Google maintains for Chrome. Transpilers and poly‐ fills targeting JS, like TypeScript, ClojureScript, and Babel, don’t support PTC either, according to this “ECMAScript 6 compatibility table”.\n\n692\n\n|\n\nChapter 18: with, match, and else Blocks",
      "content_length": 2711,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 723,
      "content": "I’ve seen several explanations for the rejection of PTC by the implementers, but the most common is the same that Guido van Rossum mentioned: PTC makes debugging harder for everyone, while benefiting only a minority of people who’d rather use recursion for iteration. For details, see “What happened to proper tail calls in Java‐ Script?” by Graham Marlow.\n\nThere are cases when recursion is the best solution, even in Python without PTC. In a previous post on the subject, Guido wrote:\n\n[…] a typical Python implementation allows 1000 recursions, which is plenty for non-recursively written code and for code that recourses to traverse, for example, a typical parse tree, but not enough for a recursively written loop over a large list.\n\nI agree with Guido and the majority of JS implementers: PTC is not a good fit for Python or JavaScript. The lack of PTC is the main restriction for writing Python pro‐ grams in a functional style—more than the limited lambda syntax.\n\nIf you are curious to see how PTC works in an interpreter with less features (and less code) than Norvig’s lispy.py, check out mylis_2. The trick starts with the infinite loop in evaluate and the code in the case for function calls: that combination makes the intepreter jump into the body of the next Procedure without calling evaluate recur‐ sively during a tail call. Those little interpreters demonstrate the power of abstraction: even though Python does not implement PTC, it’s possible and not very hard to write an interpreter, in Python, that does implement PTC. I learned how to do it reading Peter Norvig’s code. Thanks for sharing it, professor!\n\nNorvig’s Take on evaluate() with Pattern Matching\n\nI shared the code for the Python 3.10 version of lis.py with Peter Norvig. He liked the example using pattern matching, but suggested a different solution: instead of the guards I wrote, he would have exactly one case per keyword, and have tests within each case, to provide more specific SyntaxError messages—for example, when a body is empty. This would also make the guard in case [func_exp, *args] if func_exp not in KEYWORDS: unnecessary, as every keyword would be handled before the case for function calls.\n\nI’ll probably follow Norvig’s advice when I add more functionality to mylis. But the way I structured evaluate in Example 18-17 has some didactic advantages for this book: the example parallels the implementation with if/elif/… (Example 2-11), the case clauses demonstrate more features of pattern matching, and the code is more concise.\n\nFurther Reading\n\n|\n\n693",
      "content_length": 2559,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 725,
      "content": "CHAPTER 19 Concurrency Models in Python\n\nConcurrency is about dealing with lots of things at once.\n\nParallelism is about doing lots of things at once.\n\nNot the same, but related.\n\nOne is about structure, one is about execution.\n\nConcurrency provides a way to structure a solution to solve a problem that may (but not necessarily) be parallelizable.\n\n—Rob Pike, co-inventor of the Go language1\n\nThis chapter is about how to make Python deal with “lots of things at once.” This may involve concurrent or parallel programming—even academics who are keen on jargon disagree on how to use those terms. I will adopt Rob Pike’s informal defini‐ tions in this chapter’s epigraph, but note that I’ve found papers and books that claim to be about parallel computing but are mostly about concurrency.2\n\nParallelism is a special case of concurrency, in Pike’s view. All parallel systems are concurrent, but not all concurrent systems are parallel. In the early 2000s we used single-core machines that handled 100 processes concurrently on GNU Linux. A modern laptop with 4 CPU cores is routinely running more than 200 processes at any given time under normal, casual use. To execute 200 tasks in parallel, you’d need 200 cores. So, in practice, most computing is concurrent and not parallel. The OS\n\n1 Slide 8 of the talk “Concurrency Is Not Parallelism”.\n\n2 I studied and worked with Prof. Imre Simon, who liked to say there are two major sins in science: using dif‐ ferent words to mean the same thing and using one word to mean different things. Imre Simon (1943–2009) was a pioneer of computer science in Brazil who made seminal contributions to Automata Theory and started the field of Tropical Mathematics. He was also an advocate of free software and free culture.\n\n695",
      "content_length": 1764,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 726,
      "content": "manages hundreds of processes, making sure each has an opportunity to make pro‐ gress, even if the CPU itself can’t do more than four things at once.\n\nThis chapter assumes no prior knowledge of concurrent or parallel programming. After a brief conceptual introduction, we will study simple examples to introduce and compare Python’s core packages for concurrent programming: threading, multi processing, and asyncio.\n\nThe last 30% of the chapter is a high-level overview of third-party tools, libraries, application servers, and distributed task queues—all of which can enhance the per‐ formance and scalability of Python applications. These are all important topics, but beyond the scope of a book focused on core Python language features. Nevertheless, I felt it was important to address these themes in this second edition of Fluent Python, because Python’s fitness for concurrent and parallel computing is not limited to what the standard library provides. That’s why YouTube, DropBox, Instagram, Reddit, and others were able to achieve web scale when they started, using Python as their pri‐ mary language—despite persistent claims that “Python doesn’t scale.”\n\nWhat’s New in This Chapter This chapter is new in the second edition of Fluent Python. The spinner examples in “A Concurrent Hello World” on page 701 previously were in the chapter about asyncio. Here they are improved, and provide the first illustration of Python’s three approaches to concurrency: threads, processes, and native coroutines.\n\nThe remaining content is new, except for a few paragraphs that originally appeared in the chapters on concurrent.futures and asyncio.\n\n“Python in the Multicore World” on page 725 is different from the rest of the book: there are no code examples. The goal is to mention important tools that you may want to study to achieve high-performance concurrency and parallelism beyond what’s possible with Python’s standard library.\n\nThe Big Picture There are many factors that make concurrent programming hard, but I want to touch on the most basic factor: starting threads or processes is easy enough, but how do you keep track of them?3\n\nWhen you call a function, the calling code is blocked until the function returns. So you know when the function is done, and you can easily get the value it returned. If\n\n3 This section was suggested by my friend Bruce Eckel—author of books about Kotlin, Scala, Java, and C++.\n\n696\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 2469,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 727,
      "content": "the function raises an exception, the calling code can surround the call site with try/ except to catch the error.\n\nThose familiar options are not available when you start a thread or process: you don’t automatically know when it’s done, and getting back results or errors requires setting up some communication channel, such as a message queue.\n\nAdditionally, starting a thread or a process is not cheap, so you don’t want to start one of them just to perform a single computation and quit. Often you want to amor‐ tize the startup cost by making each thread or process into a “worker” that enters a loop and stands by for inputs to work on. This further complicates communications and introduces more questions. How do you make a worker quit when you don’t need it anymore? And how do you make it quit without interrupting a job partway, leaving half-baked data and unreleased resources—like open files? Again the usual answers involve messages and queues.\n\nA coroutine is cheap to start. If you start a coroutine using the await keyword, it’s easy to get a value returned by it, it can be safely cancelled, and you have a clear site to catch exceptions. But coroutines are often started by the asynchronous framework, and that can make them as hard to monitor as threads or processes.\n\nFinally, Python coroutines and threads are not suitable for CPU-intensive tasks, as we’ll see.\n\nThat’s why concurrent programming requires learning new concepts and coding pat‐ terns. Let’s first make sure we are on the same page regarding some core concepts.\n\nA Bit of Jargon Here are some terms I will use for the rest of this chapter and the next two:\n\nConcurrency\n\nThe ability to handle multiple pending tasks, making progress one at a time or in parallel (if possible) so that each of them eventually succeeds or fails. A single- core CPU is capable of concurrency if it runs an OS scheduler that interleaves the execution of the pending tasks. Also known as multitasking.\n\nParallelism\n\nThe ability to execute multiple computations at the same time. This requires a multicore CPU, multiple CPUs, a GPU, or multiple computers in a cluster.\n\nExecution unit\n\nGeneral term for objects that execute code concurrently, each with independent state and call stack. Python natively supports three kinds of execution units: pro‐ cesses, threads, and coroutines.\n\nA Bit of Jargon\n\n|\n\n697",
      "content_length": 2370,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 728,
      "content": "Process\n\nAn instance of a computer program while it is running, using memory and a slice of the CPU time. Modern desktop operating systems routinely manage hundreds of processes concurrently, with each process isolated in its own private memory space. Processes communicate via pipes, sockets, or memory mapped files—all of which can only carry raw bytes. Python objects must be serialized (converted) into raw bytes to pass from one process to another. This is costly, and not all Python objects are serializable. A process can spawn subprocesses, each called a child process. These are also isolated from each other and from the parent. Pro‐ cesses allow preemptive multitasking: the OS scheduler preempts—i.e., suspends —each running process periodically to allow other processes to run. This means that a frozen process can’t freeze the whole system—in theory.\n\nThread\n\nAn execution unit within a single process. When a process starts, it uses a single thread: the main thread. A process can create more threads to operate concur‐ rently by calling operating system APIs. Threads within a process share the same memory space, which holds live Python objects. This allows easy data sharing between threads, but can also lead to corrupted data when more than one thread updates the same object concurrently. Like processes, threads also enable pre‐ emptive multitasking under the supervision of the OS scheduler. A thread con‐ sumes less resources than a process doing the same job.\n\nCoroutine\n\nA function that can suspend itself and resume later. In Python, classic coroutines are built from generator functions, and native coroutines are defined with async def. “Classic Coroutines” on page 641 introduced the concept, and Chapter 21 covers the use of native coroutines. Python coroutines usually run within a single thread under the supervision of an event loop, also in the same thread. Asynchro‐ nous programming frameworks such as asyncio, Curio, or Trio provide an event loop and supporting libraries for nonblocking, coroutine-based I/O. Coroutines support cooperative multitasking: each coroutine must explicitly cede control with the yield or await keyword, so that another may proceed concurrently (but not in parallel). This means that any blocking code in a coroutine blocks the exe‐ cution of the event loop and all other coroutines—in contrast with the preemp‐ tive multitasking supported by processes and threads. On the other hand, each coroutine consumes less resources than a thread or process doing the same job.\n\nQueue\n\nA data structure that lets us put and get items, usually in FIFO order: first in, first out. Queues allow separate execution units to exchange application data and con‐ trol messages, such as error codes and signals to terminate. The implementation of a queue varies according to the underlying concurrency model: the queue\n\n698\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 2916,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 729,
      "content": "package in Python’s standard library provides queue classes to support threads, while the multiprocessing and asyncio packages implement their own queue classes. The queue and asyncio packages also include queues that are not FIFO: LifoQueue and PriorityQueue.\n\nLock\n\nAn object that execution units can use to synchronize their actions and avoid corrupting data. While updating a shared data structure, the running code should hold an associated lock. This signals other parts of the program to wait until the lock is released before accessing the same data structure. The simplest type of lock is also known as a mutex (for mutual exclusion). The implementa‐ tion of a lock depends on the underlying concurrency model.\n\nContention\n\nDispute over a limited asset. Resource contention happens when multiple execu‐ tion units try to access a shared resource—such as a lock or storage. There’s also CPU contention, when compute-intensive processes or threads must wait for the OS scheduler to give them a share of the CPU time.\n\nNow let’s use some of that jargon to understand concurrency support in Python.\n\nProcesses, Threads, and Python’s Infamous GIL Here is how the concepts we just saw apply to Python programming, in 10 points:\n\n1. Each instance of the Python interpreter is a process. You can start additional Python processes using the multiprocessing or concurrent.futures libraries. Python’s subprocess library is designed to launch processes to run external pro‐ grams, regardless of the languages used to write them.\n\n2. The Python interpreter uses a single thread to run the user’s program and the memory garbage collector. You can start additional Python threads using the threading or concurrent.futures libraries.\n\n3. Access to object reference counts and other internal interpreter state is con‐ trolled by a lock, the Global Interpreter Lock (GIL). Only one Python thread can hold the GIL at any time. This means that only one thread can execute Python code at any time, regardless of the number of CPU cores.\n\n4. To prevent a Python thread from holding the GIL indefinitely, Python’s bytecode interpreter pauses the current Python thread every 5ms by default,4 releasing the GIL. The thread can then try to reacquire the GIL, but if there are other threads waiting for it, the OS scheduler may pick one of them to proceed.\n\n4 Call sys.getswitchinterval() to get the interval; change it with sys.setswitchinterval(s).\n\nA Bit of Jargon\n\n|\n\n699",
      "content_length": 2457,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 730,
      "content": "5. When we write Python code, we have no control over the GIL. But a built-in function or an extension written in C—or any language that interfaces at the Python/C API level—can release the GIL while running time-consuming tasks. 6. Every Python standard library function that makes a syscall5 releases the GIL. This includes all functions that perform disk I/O, network I/O, and time.sleep(). Many CPU-intensive functions in the NumPy/SciPy libraries, as well as the compressing/decompressing functions from the zlib and bz2 mod‐ ules, also release the GIL.6\n\n7. Extensions that integrate at the Python/C API level can also launch other non- Python threads that are not affected by the GIL. Such GIL-free threads generally cannot change Python objects, but they can read from and write to the memory underlying objects that support the buffer protocol, such as bytearray, array.array, and NumPy arrays.\n\n8. The effect of the GIL on network programming with Python threads is relatively small, because the I/O functions release the GIL, and reading or writing to the network always implies high latency—compared to reading and writing to mem‐ ory. Consequently, each individual thread spends a lot of time waiting anyway, so their execution can be interleaved without major impact on the overall throughput. That’s why David Beazley says: “Python threads are great at doing nothing.”7\n\n9. Contention over the GIL slows down compute-intensive Python threads. Sequential, single-threaded code is simpler and faster for such tasks.\n\n10. To run CPU-intensive Python code on multiple cores, you must use multiple Python processes.\n\nHere is a good summary from the threading module documentation:8\n\nCPython implementation detail: In CPython, due to the Global Interpreter Lock, only one thread can execute Python code at once (even though certain performance- oriented libraries might overcome this limitation). If you want your application to make better use of the computational resources of multicore machines, you are advised to use multiprocessing or concurrent.futures.ProcessPoolExecutor. However,\n\n5 A syscall is a call from user code to a function of the operating system kernel. I/O, timers, and locks are some\n\nof the kernel services available through syscalls. To learn more, read the Wikipedia “System call” article.\n\n6 The zlib and bz2 modules are specifically mentioned in a python-dev message by Antoine Pitrou, who con‐\n\ntributed the time-slicing GIL logic to Python 3.2.\n\n7 Source: slide 106 of Beazley’s “Generators: The Final Frontier” tutorial.\n\n8 Source: last paragraph of the “Thread objects” section.\n\n700\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 2668,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 731,
      "content": "threading is still an appropriate model if you want to run multiple I/O-bound tasks simultaneously.\n\nThe previous paragraph starts with “CPython implementation detail” because the GIL is not part of the Python language definition. The Jython and IronPython imple‐ mentations don’t have a GIL. Unfortunately, both are lagging behind—still tracking Python 2.7. The highly performant PyPy interpreter also has a GIL in its 2.7 and 3.7 versions—the latest as of June 2021.\n\nThis section did not mention coroutines, because by default they share the same Python thread among themselves and with the supervising event loop provided by an asynchronous framework, therefore the GIL does not affect them. It is possible to use multiple threads in an asynchronous program, but the best practice is that one thread runs the event loop and all coroutines, while additional threads carry out specific tasks. This will be explained in “Delegat‐ ing Tasks to Executors” on page 797.\n\nEnough concepts for now. Let’s see some code.\n\nA Concurrent Hello World During a discussion about threads and how to avoid the GIL, Python contributor Michele Simionato posted an example that is like a concurrent “Hello World”: the simplest program to show how Python can “walk and chew gum.”\n\nSimionato’s program uses multiprocessing, but I adapted it to introduce threading and asyncio as well. Let’s start with the threading version, which may look familiar if you’ve studied threads in Java or C.\n\nSpinner with Threads The idea of the next few examples is simple: start a function that blocks for 3 seconds while animating characters in the terminal to let the user know that the program is “thinking” and not stalled.\n\nThe script makes an animated spinner displaying each character in the string \"\\|/-\" in the same screen position.9 When the slow computation finishes, the line with the spinner is cleared and the result is shown: Answer: 42.\n\n9 Unicode has lots of characters useful for simple animations, like the Braille patterns for example. I used the\n\nASCII characters \"\\|/-\" to keep the examples simple.\n\nA Concurrent Hello World\n\n|\n\n701",
      "content_length": 2118,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 732,
      "content": "Figure 19-1 shows the output of two versions of the spinning example: first with threads, then with coroutines. If you’re away from the computer, imagine the \\ in the last line is spinning.\n\nFigure 19-1. The scripts spinner_thread.py and spinner_async.py produce similar out‐ put: the repr of a spinner object and the text “Answer: 42”. In the screenshot, spin‐ ner_async.py is still running, and the animated message “/ thinking!” is shown; that line will be replaced by “Answer: 42” after 3 seconds.\n\nLet’s review the spinner_thread.py script first. Example 19-1 lists the first two func‐ tions in the script, and Example 19-2 shows the rest.\n\nExample 19-1. spinner_thread.py: the spin and slow functions\n\nimport itertools import time from threading import Thread, Event\n\ndef spin(msg: str, done: Event) -> None: for char in itertools.cycle(r'\\|/-'): status = f'\\r{char} {msg}' print(status, end='', flush=True) if done.wait(.1): break blanks = ' ' * len(status) print(f'\\r{blanks}\\r', end='')\n\ndef slow() -> int: time.sleep(3) return 42\n\nThis function will run in a separate thread. The done argument is an instance of threading.Event, a simple object to synchronize threads.\n\nThis is an infinite loop because itertools.cycle yields one character at a time, cycling through the string forever.\n\nThe trick for text-mode animation: move the cursor back to the start of the line with the carriage return ASCII control character ('\\r').\n\n702\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 1485,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 733,
      "content": "The Event.wait(timeout=None) method returns True when the event is set by another thread; if the timeout elapses, it returns False. The .1s timeout sets the “frame rate” of the animation to 10 FPS. If you want the spinner to go faster, use a smaller timeout.\n\nExit the infinite loop.\n\nClear the status line by overwriting with spaces and moving the cursor back to the beginning.\n\nslow() will be called by the main thread. Imagine this is a slow API call over the network. Calling sleep blocks the main thread, but the GIL is released so the spinner thread can proceed.\n\nThe first important insight of this example is that time.sleep() blocks the calling thread but releases the GIL, allowing other Python threads to run.\n\nThe spin and slow functions will execute concurrently. The main thread—the only thread when the program starts—will start a new thread to run spin and then call slow. By design, there is no API for terminating a thread in Python. You must send it a message to shut down.\n\nThe threading.Event class is Python’s simplest signalling mechanism to coordinate threads. An Event instance has an internal boolean flag that starts as False. Calling Event.set() sets the flag to True. While the flag is false, if a thread calls Event.wait(), it is blocked until another thread calls Event.set(), at which time Event.wait() returns True. If a timeout in seconds is given to Event.wait(s), this call returns False when the timeout elapses, or returns True as soon as Event.set() is called by another thread.\n\nThe supervisor function, listed in Example 19-2, uses an Event to signal the spin function to exit.\n\nExample 19-2. spinner_thread.py: the supervisor and main functions\n\ndef supervisor() -> int: done = Event() spinner = Thread(target=spin, args=('thinking!', done)) print(f'spinner object: {spinner}') spinner.start() result = slow() done.set()\n\nA Concurrent Hello World\n\n|\n\n703",
      "content_length": 1896,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 734,
      "content": "spinner.join() return result\n\ndef main() -> None: result = supervisor() print(f'Answer: {result}')\n\nif __name__ == '__main__': main()\n\nsupervisor will return the result of slow.\n\nThe threading.Event instance is the key to coordinate the activities of the main thread and the spinner thread, as explained further down.\n\nTo create a new Thread, provide a function as the target keyword argument, and positional arguments to the target as a tuple passed via args.\n\nDisplay the spinner object. The output is <Thread(Thread-1, initial)>, where initial is the state of the thread—meaning it has not started.\n\nStart the spinner thread.\n\nCall slow, which blocks the main thread. Meanwhile, the secondary thread is run‐ ning the spinner animation.\n\nSet the Event flag to True; this will terminate the for loop inside the spin function.\n\nWait until the spinner thread finishes.\n\nRun the supervisor function. I wrote separate main and supervisor functions to make this example look more like the asyncio version in Example 19-4.\n\nWhen the main thread sets the done event, the spinner thread will eventually notice and exit cleanly.\n\nNow let’s take a look at a similar example using the multiprocessing package.\n\nSpinner with Processes The multiprocessing package supports running concurrent tasks in separate Python processes instead of threads. When you create a multiprocessing.Process instance, a whole new Python interpreter is started as a child process in the background. Since each Python process has its own GIL, this allows your program to use all available\n\n704\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 1605,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 735,
      "content": "CPU cores—but that ultimately depends on the operating system scheduler. We’ll see practical effects in “A Homegrown Process Pool” on page 716, but for this simple pro‐ gram it makes no real difference.\n\nThe point of this section is to introduce multiprocessing and show that its API emulates the threading API, making it easy to convert simple programs from threads to processes, as shown in spinner_proc.py (Example 19-3).\n\nExample 19-3. spinner_proc.py: only the changed parts are shown; everything else is the same as spinner_thread.py\n\nimport itertools import time from multiprocessing import Process, Event from multiprocessing import synchronize\n\ndef spin(msg: str, done: synchronize.Event) -> None:\n\n# [snip] the rest of spin and slow functions are unchanged from spinner_thread.py\n\ndef supervisor() -> int: done = Event() spinner = Process(target=spin, args=('thinking!', done)) print(f'spinner object: {spinner}') spinner.start() result = slow() done.set() spinner.join() return result\n\n# [snip] main function is unchanged as well\n\nThe basic multiprocessing API imitates the threading API, but type hints and Mypy expose this difference: multiprocessing.Event is a function (not a class like threading.Event) which returns a synchronize.Event instance…\n\n…forcing us to import multiprocessing.synchronize…\n\n…to write this type hint.\n\nBasic usage of the Process class is similar to Thread.\n\nThe spinner object is displayed as <Process name='Process-1' parent=14868 initial>, where 14868 is the process ID of the Python instance running spinner_proc.py.\n\nA Concurrent Hello World\n\n|\n\n705",
      "content_length": 1594,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 736,
      "content": "The basic API of threading and multiprocessing are similar, but their implementa‐ tion is very different, and multiprocessing has a much larger API to handle the added complexity of multiprocess programming. For example, one challenge when converting from threads to processes is how to communicate between processes that are isolated by the operating system and can’t share Python objects. This means that objects crossing process boundaries have to be serialized and deserialized, which cre‐ ates overhead. In Example 19-3, the only data that crosses the process boundary is the Event state, which is implemented with a low-level OS semaphore in the C code underlying the multiprocessing module.10\n\nSince Python 3.8, there’s a multiprocessing.shared_memory pack‐ age in the standard library, but it does not support instances of user-defined classes. Besides raw bytes, the package allows pro‐ cesses to share a ShareableList, a mutable sequence type that can hold a fixed number of items of types int, float, bool, and None, as well as str and bytes up to 10 MB per item. See the ShareableL ist documentation for more.\n\nNow let’s see how the same behavior can be achieved with coroutines instead of threads or processes.\n\nSpinner with Coroutines\n\nChapter 21 is entirely devoted to asynchronous programming with coroutines. This is just a high-level introduction to contrast this approach with the threads and processes concurrency models. As such, we will overlook many details.\n\nIt is the job of OS schedulers to allocate CPU time to drive threads and processes. In contrast, coroutines are driven by an application-level event loop that manages a queue of pending coroutines, drives them one by one, monitors events triggered by I/O operations initiated by coroutines, and passes control back to the corresponding coroutine when each event happens. The event loop and the library coroutines and the user coroutines all execute in a single thread. Therefore, any time spent in a coroutine slows down the event loop—and all other coroutines.\n\n10 The semaphore is a fundamental building block that can be used to implement other synchronization mecha‐ nisms. Python provides different semaphore classes for use with threads, processes, and coroutines. We’ll see asyncio.Semaphore in “Using asyncio.as_completed and a Thread” on page 788 (Chapter 21).\n\n706\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 2402,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 737,
      "content": "The coroutine version of the spinner program is easier to understand if we start from the main function, then study the supervisor. That’s what Example 19-4 shows.\n\nExample 19-4. spinner_async.py: the main function and supervisor coroutine\n\ndef main() -> None: result = asyncio.run(supervisor()) print(f'Answer: {result}')\n\nasync def supervisor() -> int: spinner = asyncio.create_task(spin('thinking!')) print(f'spinner object: {spinner}') result = await slow() spinner.cancel() return result\n\nif __name__ == '__main__': main()\n\nmain is the only regular function defined in this program—the others are coroutines.\n\nThe asyncio.run function starts the event loop to drive the coroutine that will eventually set the other coroutines in motion. The main function will stay blocked until supervisor returns. The return value of supervisor will be the return value of asyncio.run.\n\nNative coroutines are defined with async def.\n\nasyncio.create_task schedules the eventual execution of spin, immediately returning an instance of asyncio.Task.\n\nThe repr of the spinner object looks like <Task pending name='Task-2' coro=<spin() running at /path/to/spinner_async.py:11>>.\n\nThe await keyword calls slow, blocking supervisor until slow returns. The return value of slow will be assigned to result.\n\nThe Task.cancel method raises a CancelledError exception inside the spin coroutine, as we’ll see in Example 19-5.\n\nExample 19-4 demonstrates the three main ways of running a coroutine:\n\nA Concurrent Hello World\n\n|\n\n707",
      "content_length": 1507,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 738,
      "content": "asyncio.run(coro())\n\nCalled from a regular function to drive a coroutine object that usually is the entry point for all the asynchronous code in the program, like the supervisor in this example. This call blocks until the body of coro returns. The return value of the run() call is whatever the body of coro returns.\n\nasyncio.create_task(coro())\n\nCalled from a coroutine to schedule another coroutine to execute eventually. This call does not suspend the current coroutine. It returns a Task instance, an object that wraps the coroutine object and provides methods to control and query its state.\n\nawait coro()\n\nCalled from a coroutine to transfer control to the coroutine object returned by coro(). This suspends the current coroutine until the body of coro returns. The value of the await expression is whatever the body of coro returns.\n\nRemember: invoking a coroutine as coro() immediately returns a coroutine object, but does not run the body of the coro function. Driving the body of coroutines is the job of the event loop.\n\nNow let’s study the spin and slow coroutines in Example 19-5.\n\nExample 19-5. spinner_async.py: the spin and slow coroutines\n\nimport asyncio import itertools\n\nasync def spin(msg: str) -> None: for char in itertools.cycle(r'\\|/-'): status = f'\\r{char} {msg}' print(status, flush=True, end='') try: await asyncio.sleep(.1) except asyncio.CancelledError: break blanks = ' ' * len(status) print(f'\\r{blanks}\\r', end='')\n\nasync def slow() -> int: await asyncio.sleep(3) return 42\n\n708\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 1555,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 739,
      "content": "We don’t need the Event argument that was used to signal that slow had comple‐ ted its job in spinner_thread.py (Example 19-1).\n\nUse await asyncio.sleep(.1) instead of time.sleep(.1), to pause without blocking other coroutines. See the experiment after this example.\n\nasyncio.CancelledError is raised when the cancel method is called on the Task controlling this coroutine. Time to exit the loop.\n\nThe slow coroutine also uses await asyncio.sleep instead of time.sleep.\n\nExperiment: Break the spinner for an insight\n\nHere is an experiment I recommend to understand how spinner_async.py works. Import the time module, then go to the slow coroutine and replace the line await asyncio.sleep(3) with a call to time.sleep(3), like in Example 19-6.\n\nExample 19-6. spinner_async.py: replacing await asyncio.sleep(3) with time.sleep(3)\n\nasync def slow() -> int: time.sleep(3) return 42\n\nWatching the behavior is more memorable than reading about it. Go ahead, I’ll wait.\n\nWhen you run the experiment, this is what you see:\n\n1. The spinner object is shown, similar to this: <Task pending name='Task-2' coro=<spin() running at /path/to/spinner_async.py:12>>.\n\n2. The spinner never appears. The program hangs for 3 seconds. 3. Answer: 42 is displayed and the program ends.\n\nTo understand what is happening, recall that Python code using asyncio has only one flow of execution, unless you’ve explicitly started additional threads or processes. That means only one coroutine executes at any point in time. Concurrency is achieved by control passing from one coroutine to another. In Example 19-7, let’s focus on what happens in the supervisor and slow coroutines during the proposed experiment.\n\nExample 19-7. spinner_async_experiment.py: the supervisor and slow coroutines\n\nasync def slow() -> int: time.sleep(3)\n\nA Concurrent Hello World\n\n|\n\n709",
      "content_length": 1834,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 740,
      "content": "return 42\n\nasync def supervisor() -> int: spinner = asyncio.create_task(spin('thinking!')) print(f'spinner object: {spinner}') result = await slow() spinner.cancel() return result\n\nThe spinner task is created, to eventually drive the execution of spin.\n\nThe display shows the Task is “pending.”\n\nThe await expression transfers control to the slow coroutine.\n\ntime.sleep(3) blocks for 3 seconds; nothing else can happen in the program, because the main thread is blocked—and it is the only thread. The operating sys‐ tem will continue with other activities. After 3 seconds, sleep unblocks, and slow returns.\n\nRight after slow returns, the spinner task is cancelled. The flow of control never reached the body of the spin coroutine.\n\nThe spinner_async_experiment.py teaches an important lesson, as explained in the following warning.\n\nNever use time.sleep(…) in asyncio coroutines unless you want to pause your whole program. If a coroutine needs to spend some time doing nothing, it should await asyncio.sleep(DELAY). This yields control back to the asyncio event loop, which can drive other pending coroutines.\n\nGreenlet and gevent As we discuss concurrency with coroutines, it’s important to mention the greenlet package, which has been around for many years and is used at scale.11 The package supports cooperative multitasking through lightweight coroutines—named greenlets —that don’t require any special syntax such as yield or await, therefore are easier to integrate into existing, sequential codebases. SQL Alchemy 1.4 ORM uses greenlets internally to implement its new asynchronous API compatible with asyncio.\n\n11 Thanks to tech reviewers Caleb Hattingh and Jürgen Gmach who did not let me overlook greenlet and gevent.\n\n710\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 1780,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 741,
      "content": "The gevent networking library monkey patches Python’s standard socket module making it nonblocking by replacing some of its code with greenlets. To a large extent, gevent is transparent to the surrounding code, making it easier to adapt sequential applications and libraries—such as database drivers—to perform concurrent network I/O. Numerous open source projects use gevent, including the widely deployed Guni‐ corn—mentioned in “WSGI Application Servers” on page 730.\n\nSupervisors Side-by-Side The line count of spinner_thread.py and spinner_async.py is nearly the same. The supervisor functions are the heart of these examples. Let’s compare them in detail. Example 19-8 lists only the supervisor from Example 19-2.\n\nExample 19-8. spinner_thread.py: the threaded supervisor function\n\ndef supervisor() -> int: done = Event() spinner = Thread(target=spin, args=('thinking!', done)) print('spinner object:', spinner) spinner.start() result = slow() done.set() spinner.join() return result\n\nFor comparison, Example 19-9 shows the supervisor coroutine from Example 19-4.\n\nExample 19-9. spinner_async.py: the asynchronous supervisor coroutine\n\nasync def supervisor() -> int: spinner = asyncio.create_task(spin('thinking!')) print('spinner object:', spinner) result = await slow() spinner.cancel() return result\n\nHere is a summary of the differences and similarities to note between the two super visor implementations:\n\nAn asyncio.Task is roughly the equivalent of a threading.Thread. • A Task drives a coroutine object, and a Thread invokes a callable. • A coroutine yields control explicitly with the await keyword.\n\nA Concurrent Hello World\n\n|\n\n711",
      "content_length": 1649,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 742,
      "content": "You don’t instantiate Task objects yourself, you get them by passing a coroutine to asyncio.create_task(…).\n\nWhen asyncio.create_task(…) returns a Task object, it is already scheduled to run, but a Thread instance must be explicitly told to run by calling its start method.\n\nIn the threaded supervisor, slow is a plain function and is directly invoked by the main thread. In the asynchronous supervisor, slow is a coroutine driven by await.\n\nThere’s no API to terminate a thread from the outside; instead, you must send a signal—like setting the done Event object. For tasks, there is the Task.cancel() instance method, which raises CancelledError at the await expression where the coroutine body is currently suspended.\n\nThe supervisor coroutine must be started with asyncio.run in the main function.\n\nThis comparison should help you understand how concurrent jobs are orchestrated with asyncio, in contrast to how it’s done with the Threading module, which may be more familiar to you.\n\nOne final point related to threads versus coroutines: if you’ve done any nontrivial programming with threads, you know how challenging it is to reason about the pro‐ gram because the scheduler can interrupt a thread at any time. You must remember to hold locks to protect the critical sections of your program, to avoid getting inter‐ rupted in the middle of a multistep operation—which could leave data in an invalid state.\n\nWith coroutines, your code is protected against interruption by default. You must explicitly await to let the rest of the program run. Instead of holding locks to syn‐ chronize the operations of multiple threads, coroutines are “synchronized” by defini‐ tion: only one of them is running at any time. When you want to give up control, you use await to yield control back to the scheduler. That’s why it is possible to safely cancel a coroutine: by definition, a coroutine can only be cancelled when it’s sus‐ pended at an await expression, so you can perform cleanup by handling the Cancel ledError exception.\n\nThe time.sleep() call blocks but does nothing. Now we’ll experiment with a CPU- intensive call to get a better understanding of the GIL, as well as the effect of CPU- intensive functions in asynchronous code.\n\n712\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 2284,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 743,
      "content": "The Real Impact of the GIL In the threading code (Example 19-1), you can replace the time.sleep(3) call in the slow function with an HTTP client request from your favorite library, and the spin‐ ner will keep spinning. That’s because a well-designed network library will release the GIL while waiting for the network.\n\nYou can also replace the asyncio.sleep(3) expression in the slow coroutine to await for a response from a well-designed asynchronous network library, because such libraries provide coroutines that yield control back to the event loop while wait‐ ing for the network. Meanwhile, the spinner will keep spinning.\n\nWith CPU-intensive code, the story is different. Consider the function is_prime in Example 19-10, which returns True if the argument is a prime number, False if it’s not.\n\nExample 19-10. primes.py: an easy to read primality check, from Python’s ProcessPool Executor example\n\ndef is_prime(n: int) -> bool: if n < 2: return False if n == 2: return True if n % 2 == 0: return False\n\nroot = math.isqrt(n) for i in range(3, root + 1, 2): if n % i == 0: return False return True\n\nThe call is_prime(5_000_111_000_222_021) takes about 3.3s on the company laptop I am using now.12\n\nQuick Quiz Given what we’ve seen so far, please take the time to consider the following three- part question. One part of the answer is tricky (at least it was for me).\n\nWhat would happen to the spinner animation if you made the following changes, assuming that n = 5_000_111_000_222_021—that prime which my machine takes 3.3s to verify:\n\n12 It’s a 15” MacBook Pro 2018 with a 6-core, 2.2 GHz Intel Core i7 CPU.\n\nThe Real Impact of the GIL\n\n|\n\n713",
      "content_length": 1650,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 744,
      "content": "1. In spinner_proc.py, replace time.sleep(3) with a call to is_prime(n)?\n\n2. In spinner_thread.py, replace time.sleep(3) with a call to is_prime(n)?\n\n3. In\n\nspinner_async.py, replace await asyncio.sleep(3) with a call\n\nis_prime(n)?\n\nBefore you run the code or read on, I recommend figuring out the answers on your own. Then, you may want to copy and modify the spinner_*.py examples as suggested.\n\nNow the answers, from easier to hardest.\n\n1. Answer for multiprocessing\n\nThe spinner is controlled by a child process, so it continues spinning while the pri‐ mality test is computed by the parent process.13\n\n2. Answer for threading\n\nThe spinner is controlled by a secondary thread, so it continues spinning while the primality test is computed by the main thread.\n\nI did not get this answer right at first: I was expecting the spinner to freeze because I overestimated the impact of the GIL.\n\nIn this particular example, the spinner keeps spinning because Python suspends the running thread every 5ms (by default), making the GIL available to other pending threads. Therefore, the main thread running is_prime is interrupted every 5ms, allowing the secondary thread to wake up and iterate once through the for loop, until it calls the wait method of the done event, at which time it will release the GIL. The main thread will then grab the GIL, and the is_prime computation will proceed for another 5ms.\n\nThis does not have a visible impact on the running time of this specific example, because the spin function quickly iterates once and releases the GIL as it waits for the done event, so there is not much contention for the GIL. The main thread running is_prime will have the GIL most of the time.\n\nWe got away with a compute-intensive task using threading in this simple experi‐ ment because there are only two threads: one hogging the CPU, and the other waking up only 10 times per second to update the spinner.\n\n13 This is true today because you are probably using a modern OS with preemptive multitasking. Windows\n\nbefore the NT era and macOS before the OSX era were not “preemptive,” therefore any process could take over 100% of the CPU and freeze the whole system. We are not completely free of this kind of problem today but trust this graybeard: this troubled every user in the 1990s, and a hard reset was the only cure.\n\n714\n\n|\n\nChapter 19: Concurrency Models in Python\n\nto",
      "content_length": 2386,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 745,
      "content": "But if you have two or more threads vying for a lot of CPU time, your program will be slower than sequential code.\n\n3. Answer for asyncio\n\nIf you call is_prime(5_000_111_000_222_021) in the slow coroutine of the spin‐ ner_async.py example, the spinner will never appear. The effect would be the same we had in Example 19-6, when we replaced await asyncio.sleep(3) with time.sleep(3): no spinning at all. The flow of control will pass from supervisor to slow, and then to is_prime. When is_prime returns, slow returns as well, and super visor resumes, cancelling the spinner task before it is executed even once. The pro‐ gram appears frozen for about 3s, then shows the answer.\n\nPower Napping with sleep(0) One way to keep the spinner alive is to rewrite is_prime as a coroutine, and periodi‐ cally call asyncio.sleep(0) in an await expression to yield control back to the event loop, like in Example 19-11.\n\nExample 19-11. spinner_async_nap.py: is_prime is now a coroutine\n\nasync def is_prime(n): if n < 2: return False if n == 2: return True if n % 2 == 0: return False\n\nroot = math.isqrt(n) for i in range(3, root + 1, 2): if n % i == 0: return False if i % 100_000 == 1: await asyncio.sleep(0) return True\n\nSleep once every 50,000 iterations (because the step in the range is 2).\n\nIssue #284 in the asyncio repository has an informative discussion about the use of asyncio.sleep(0).\n\nHowever, be aware this will slow down is_prime, and—more importantly—will still slow down the event loop and your whole program with it. When I used await asyn cio.sleep(0) every 100,000 iterations, the spinner was smooth but the program ran in 4.9s on my machine, almost 50% longer than the original primes.is_prime func‐ tion by itself with the same argument (5_000_111_000_222_021).\n\nThe Real Impact of the GIL\n\n|\n\n715",
      "content_length": 1809,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 746,
      "content": "Using await asyncio.sleep(0) should be considered a stopgap measure before you refactor your asynchronous code to delegate CPU-intensive computations to another process. We’ll see one way of doing that with asyncio.loop.run_in_executor, cov‐ ered in Chapter 21. Another option would be a task queue, which we’ll briefly discuss in “Distributed Task Queues” on page 732.\n\nSo far, we’ve only experimented with a single call to a CPU-intensive function. The next section presents concurrent execution of multiple CPU-intensive calls.\n\nA Homegrown Process Pool\n\nI wrote this section to show the use of multiple processes for CPU- intensive tasks, and the common pattern of using queues to distrib‐ ute tasks and collect results. Chapter 20 will show a simpler way of distributing tasks to processes: a ProcessPoolExecutor from the concurrent.futures package, which uses queues internally.\n\nIn this section we’ll write programs to compute the primality of a sample of 20 inte‐ gers, from 2 to 9,999,999,999,999,999—i.e., 1016 – 1, or more than 253. The sample includes small and large primes, as well as composite numbers with small and large prime factors.\n\nThe sequential.py program provides the performance baseline. Here is a sample run:\n\n$ python3 sequential.py 2 P 0.000001s 142702110479723 P 0.568328s 299593572317531 P 0.796773s 3333333333333301 P 2.648625s 3333333333333333 0.000007s 3333335652092209 2.672323s 4444444444444423 P 3.052667s 4444444444444444 0.000001s 4444444488888889 3.061083s 5555553133149889 3.451833s 5555555555555503 P 3.556867s 5555555555555555 0.000007s 6666666666666666 0.000001s 6666666666666719 P 3.781064s 6666667141414921 3.778166s 7777777536340681 4.120069s 7777777777777753 P 4.141530s 7777777777777777 0.000007s 9999999999999917 P 4.678164s 9999999999999999 0.000007s Total time: 40.31\n\n716\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 1870,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 747,
      "content": "The results are shown in three columns:\n\nThe number to be checked. • P if it’s a prime number, blank if not.\n\nElapsed time for checking the primality for that specific number.\n\nIn this example, the total time is approximately the sum of the times for each check, but it is computed separately, as you can see in Example 19-12.\n\nExample 19-12. sequential.py: sequential primality check for a small dataset\n\n#!/usr/bin/env python3\n\n\"\"\" sequential.py: baseline for comparing sequential, multiprocessing, and threading code for CPU-intensive work. \"\"\"\n\nfrom time import perf_counter from typing import NamedTuple\n\nfrom primes import is_prime, NUMBERS\n\nclass Result(NamedTuple): prime: bool elapsed: float\n\ndef check(n: int) -> Result: t0 = perf_counter() prime = is_prime(n) return Result(prime, perf_counter() - t0)\n\ndef main() -> None: print(f'Checking {len(NUMBERS)} numbers sequentially:') t0 = perf_counter() for n in NUMBERS: prime, elapsed = check(n) label = 'P' if prime else ' ' print(f'{n:16} {label} {elapsed:9.6f}s')\n\nelapsed = perf_counter() - t0 print(f'Total time: {elapsed:.2f}s')\n\nif __name__ == '__main__': main()\n\nA Homegrown Process Pool\n\n|\n\n717",
      "content_length": 1161,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 748,
      "content": "The check function (in the next callout) returns a Result tuple with the boolean value of the is_prime call and the elapsed time.\n\ncheck(n) calls is_prime(n) and computes the elapsed time to return a Result.\n\nFor each number in the sample, we call check and display the result.\n\nCompute and display the total elapsed time.\n\nProcess-Based Solution The next example, procs.py, shows the use of multiple processes to distribute the pri‐ mality checks across multiple CPU cores. These are the times I get with procs.py:\n\n$ python3 procs.py Checking 20 numbers with 12 processes: 2 P 0.000002s 3333333333333333 0.000021s 4444444444444444 0.000002s 5555555555555555 0.000018s 6666666666666666 0.000002s 142702110479723 P 1.350982s 7777777777777777 0.000009s 299593572317531 P 1.981411s 9999999999999999 0.000008s 3333333333333301 P 6.328173s 3333335652092209 6.419249s 4444444488888889 7.051267s 4444444444444423 P 7.122004s 5555553133149889 7.412735s 5555555555555503 P 7.603327s 6666666666666719 P 7.934670s 6666667141414921 8.017599s 7777777536340681 8.339623s 7777777777777753 P 8.388859s 9999999999999917 P 8.117313s 20 checks in 9.58s\n\nThe last line of the output shows that procs.py was 4.2 times faster than sequential.py.\n\nUnderstanding the Elapsed Times Note that the elapsed time in the first column is for checking that specific number. For example, is_prime(7777777777777753) took almost 8.4s to return True. Mean‐ while, other processes were checking other numbers in parallel.\n\nThere were 20 numbers to check. I wrote procs.py to start a number of worker pro‐ cesses equal to the number of CPU cores, as determined by multiprocess ing.cpu_count().\n\n718\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 1706,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 749,
      "content": "The total time in this case is much less than the sum of the elapsed time for the indi‐ vidual checks. There is some overhead in spinning up processes and in inter-process communication, so the end result is that the multiprocess version is only about 4.2 times faster than the sequential. That’s good, but a little disappointing considering the code launches 12 processes to use all cores on this laptop.\n\nThe multiprocessing.cpu_count() function returns 12 on the MacBook Pro I’m using to write this chapter. It’s actually a 6-CPU Core-i7, but the OS reports 12 CPUs because of hyperthreading, an Intel technology which executes 2 threads per core. However, hyperthreading works better when one of the threads is not work‐ ing as hard as the other thread in the same core—perhaps the first is stalled waiting for data after a cache miss, and the other is crunching numbers. Anyway, there’s no free lunch: this laptop per‐ forms like a 6-CPU machine for compute-intensive work that doesn’t use a lot of memory—like that simple primality test.\n\nCode for the Multicore Prime Checker When we delegate computing to threads or processes, our code does not call the worker function directly, so we can’t simply get a return value. Instead, the worker is driven by the thread or process library, and it eventually produces a result that needs to be stored somewhere. Coordinating workers and collecting results are common uses of queues in concurrent programming—and also in distributed systems.\n\nMuch of the new code in procs.py has to do with setting up and using queues. The top of the file is in Example 19-13.\n\nSimpleQueue was added to multiprocessing in Python 3.9. If you’re using an earlier version of Python, you can replace Simple Queue with Queue in Example 19-13.\n\nExample 19-13. procs.py: multiprocess primality check; imports, types, and functions\n\nimport sys from time import perf_counter from typing import NamedTuple from multiprocessing import Process, SimpleQueue, cpu_count from multiprocessing import queues\n\nfrom primes import is_prime, NUMBERS\n\nclass PrimeResult(NamedTuple): n: int\n\nA Homegrown Process Pool\n\n|\n\n719",
      "content_length": 2133,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 750,
      "content": "prime: bool elapsed: float\n\nJobQueue = queues.SimpleQueue[int] ResultQueue = queues.SimpleQueue[PrimeResult]\n\ndef check(n: int) -> PrimeResult: t0 = perf_counter() res = is_prime(n) return PrimeResult(n, res, perf_counter() - t0)\n\ndef worker(jobs: JobQueue, results: ResultQueue) -> None: while n := jobs.get(): results.put(check(n)) results.put(PrimeResult(0, False, 0.0))\n\ndef start_jobs( procs: int, jobs: JobQueue, results: ResultQueue ) -> None: for n in NUMBERS: jobs.put(n) for _ in range(procs): proc = Process(target=worker, args=(jobs, results)) proc.start() jobs.put(0)\n\nTrying to emulate threading, multiprocessing provides multiprocessing.Sim pleQueue, but this is a method bound to a predefined instance of a lower-level BaseContext class. We must call this SimpleQueue to build a queue, we can’t use it in type hints.\n\nmultiprocessing.queues has the SimpleQueue class we need for type hints.\n\nPrimeResult includes the number checked for primality. Keeping n together with the other result fields simplifies displaying results later.\n\nThis is a type alias for a SimpleQueue that the main function (Example 19-14) will use to send numbers to the processes that will do the work.\n\nType alias for a second SimpleQueue that will collect the results in main. The val‐ ues in the queue will be tuples made of the number to be tested for primality, and a Result tuple.\n\nThis is similar to sequential.py.\n\nworker gets a queue with the numbers to be checked, and another to put results.\n\n720\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 1541,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 751,
      "content": "In this code, I use the number 0 as a poison pill: a signal for the worker to finish. If n is not 0, proceed with the loop.14\n\nInvoke the primality check and enqueue PrimeResult.\n\nSend back a PrimeResult(0, False, 0.0) to let the main loop know that this worker is done.\n\nprocs is the number of processes that will compute the prime checks in parallel.\n\nEnqueue the numbers to be checked in jobs.\n\nFork a child process for each worker. Each child will run the loop inside its own instance of the worker function, until it fetches a 0 from the jobs queue.\n\nStart each child process.\n\nEnqueue one 0 for each process, to terminate them.\n\nLoops, Sentinels, and Poison Pills The worker function in Example 19-13 follows a common pattern in concurrent pro‐ gramming: looping indefinitely while taking items from a queue and processing each with a function that does the actual work. The loop ends when the queue produces a sentinel value. In this pattern, the sentinel that shuts down the worker is often called a “poison pill.”\n\nNone is often used as a sentinel value, but it may be unsuitable if it can occur in the data stream. Calling object() is a common way to get a unique value to use as senti‐ nel. However, that does not work across processes because Python objects must be serialized for inter-process communication, and when you pickle.dump and pickle.load an instance of object, the unpickled instance is distinct from the origi‐ nal: it doesn’t compare equal. A good alternative to None is the Ellipsis built-in object (a.k.a. ...), which survives serialization without losing its identity.15\n\nPython’s standard library uses lots of different values as sentinels. PEP 661—Sentinel Values proposes a standard sentinel type. As of September 2021, it’s only a draft.\n\n14 In this example, 0 is a convenient sentinel. None is also commonly used for that. Using 0 simplifies the type\n\nhint for PrimeResult and the code for worker.\n\n15 Surviving serialization without losing our identity is a pretty good life goal.\n\nA Homegrown Process Pool\n\n|\n\n721",
      "content_length": 2050,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 752,
      "content": "Now let’s study the main function of procs.py in Example 19-14.\n\nExample 19-14. procs.py: multiprocess primality check; main function\n\ndef main() -> None: if len(sys.argv) < 2: procs = cpu_count() else: procs = int(sys.argv[1])\n\nprint(f'Checking {len(NUMBERS)} numbers with {procs} processes:') t0 = perf_counter() jobs: JobQueue = SimpleQueue() results: ResultQueue = SimpleQueue() start_jobs(procs, jobs, results) checked = report(procs, results) elapsed = perf_counter() - t0 print(f'{checked} checks in {elapsed:.2f}s')\n\ndef report(procs: int, results: ResultQueue) -> int: checked = 0 procs_done = 0 while procs_done < procs: n, prime, elapsed = results.get() if n == 0: procs_done += 1 else: checked += 1 label = 'P' if prime else ' ' print(f'{n:16} {label} {elapsed:9.6f}s') return checked\n\nif __name__ == '__main__': main()\n\nIf no command-line argument is given, set the number of processes to the num‐ ber of CPU cores; otherwise, create as many processes as given in the first argument.\n\njobs and results are the queues described in Example 19-13.\n\nStart proc processes to consume jobs and post results.\n\nRetrieve the results and display them; report is defined in\n\n.\n\nDisplay how many numbers were checked and the total elapsed time.\n\nThe arguments are the number of procs and the queue to post the results.\n\n722\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 1368,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 753,
      "content": "Loop until all processes are done.\n\nGet one PrimeResult. Calling .get() on a queue block until there is an item in the queue. It’s also possible to make this nonblocking, or set a timeout. See the SimpleQueue.get documentation for details.\n\nIf n is zero, then one process exited; increment the procs_done count.\n\nOtherwise, increment the checked count (to keep track of the numbers checked) and display the results.\n\nThe results will not come back in the same order the jobs were submitted. That’s why I had to put n in each PrimeResult tuple. Otherwise, I’d have no way to know which result belonged to each number.\n\nIf the main process exits before all subprocesses are done, you may see confusing tracebacks on FileNotFoundError exceptions caused by an internal lock in multi processing. Debugging concurrent code is always hard, and debugging multiproc essing is even harder because of all the complexity behind the thread-like façade. Fortunately, the ProcessPoolExecutor we’ll meet in Chapter 20 is easier to use and more robust.\n\nThanks to reader Michael Albert who noticed the code I published during the early release had a race condition in Example 19-14. A race condition is a bug that may or may not occur depending on the order of actions performed by concurrent execution units. If “A” happens before “B,” all is fine; but it “B” happens first, some‐ thing goes wrong. That’s the race.\n\nIf you are curious, this diff shows the bug and how I fixed it: example-code-2e/commit/2c123057—but note that I later refactored the example to delegate parts of main to the start_jobs and report functions. There’s a README.md file in the same directory explaining the problem and the solution.\n\nExperimenting with More or Fewer Processes You may want try running procs.py, passing arguments to set the number of worker processes. For example, this command…\n\n$ python3 procs.py 2\n\n…will launch two worker processes, producing results almost twice as fast as sequen‐ tial.py—if your machine has at least two cores and is not too busy running other programs.\n\nA Homegrown Process Pool\n\n|\n\n723",
      "content_length": 2091,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 754,
      "content": "I ran procs.py 12 times with 1 to 20 processes, totaling 240 runs. Then I computed the median time for all runs with the same number of processes, and plotted Figure 19-2.\n\nFigure 19-2. Median run times for each number of processes from 1 to 20. Highest median time was 40.81s, with 1 process. Lowest median time was 10.39s, with 6 pro‐ cesses, indicated by the dotted line.\n\nIn this 6-core laptop, the lowest median time was with 6 processes: 10.39s—marked by the dotted line in Figure 19-2. I expected the run time to increase after 6 processes due to CPU contention, and it reached a local maximum of 12.51s at 10 processes. I did not expect and I can’t explain why the performance improved at 11 processes and remained almost flat from 13 to 20 processes, with median times only slightly higher than the lowest median time at 6 processes.\n\nThread-Based Nonsolution I also wrote threads.py, a version of procs.py using threading instead of multiproc essing. The code is very similar—as is usually the case when converting simple examples between these two APIs.16 Due to the GIL and the compute-intensive nature of is_prime, the threaded version is slower than the sequential code in Example 19-12, and it gets slower as the number of threads increase, because of CPU contention and the cost of context switching. To switch to a new thread, the OS needs to save CPU registers and update the program counter and stack pointer,\n\n16 See 19-concurrency/primes/threads.py in the Fluent Python code repository.\n\n724\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 1557,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 755,
      "content": "triggering expensive side effects like invalidating CPU caches and possibly even swapping memory pages.17\n\nThe next two chapters will cover more about concurrent programming in Python, using the high-level concurrent.futures library to manage threads and processes (Chapter 20) and the asyncio library for asynchronous programming (Chapter 21).\n\nThe remaining sections in this chapter aim to answer the question:\n\nGiven the limitations discussed so far, how is Python thriving in a multicore world?\n\nPython in the Multicore World Consider this citation from the widely quoted article “The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software” by Herb Sutter:\n\nThe major processor manufacturers and architectures, from Intel and AMD to Sparc and PowerPC, have run out of room with most of their traditional approaches to boosting CPU performance. Instead of driving clock speeds and straight-line instruc‐ tion throughput ever higher, they are instead turning en masse to hyper-threading and multicore architectures. March 2005. [Available online].\n\nWhat Sutter calls the “free lunch” was the trend of software getting faster with no additional developer effort because CPUs were executing sequential code faster, year after year. Since 2004, that is no longer true: clock speeds and execution optimiza‐ tions reached a plateau, and now any significant increase in performance must come from leveraging multiple cores or hyperthreading, advances that only benefit code that is written for concurrent execution.\n\nPython’s story started in the early 1990s, when CPUs were still getting exponentially faster at sequential code execution. There was no talk about multicore CPUs except in supercomputers back then. At the time, the decision to have a GIL was a no- brainer. The GIL makes the interpreter faster when running on a single core, and its implementation simpler.18 The GIL also makes it easier to write simple extensions through the Python/C API.\n\n17 To learn more, see “Context switch” in the English Wikipedia.\n\n18 These are probably the same reasons that prompted the creator of the Ruby language, Yukihiro Matsumoto,\n\nto use a GIL in his interpreter as well.\n\nPython in the Multicore World\n\n|\n\n725",
      "content_length": 2223,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 756,
      "content": "I just wrote “simple extensions” because an extension does not need to deal with the GIL at all. A function written in C or Fortran may be hundreds of times faster than the equivalent in Python.19 Therefore the added complexity of releasing the GIL to leverage multicore CPUs may not be needed in many cases. So we can thank the GIL for many extensions available for Python—and that is certainly one of the key reasons why the language is so popular today.\n\nDespite the GIL, Python is thriving in applications that require concurrent or parallel execution, thanks to libraries and software architectures that work around the limita‐ tions of CPython.\n\nNow let’s discuss how Python is used in system administration, data science, and server-side application development in the multicore, distributed computing world of 2021.\n\nSystem Administration Python is widely used to manage large fleets of servers, routers, load balancers, and network-attached storage (NAS). It’s also a leading option in software-defined net‐ working (SDN) and ethical hacking. Major cloud service providers support Python through libraries and tutorials authored by the providers themselves or by their large communities of Python users.\n\nIn this domain, Python scripts automate configuration tasks by issuing commands to be carried out by the remote machines, so rarely there are CPU-bound operations to be done. Threads or coroutines are well suited for such jobs. In particular, the concur rent.futures package we’ll see in Chapter 20 can be used to perform the same oper‐ ations on many remote machines at the same time without a lot of complexity.\n\nBeyond the standard library, there are popular Python-based projects to manage server clusters: tools like Ansible and Salt, as well as libraries like Fabric.\n\nThere is also a growing number of libraries for system administration supporting coroutines and asyncio. In 2016, Facebook’s Production Engineering team reported: “We are increasingly relying on AsyncIO, which was introduced in Python 3.4, and seeing huge performance gains as we move codebases away from Python 2.”\n\n19 As an exercise in college, I had to implement the LZW compression algorithm in C. But first I wrote it in\n\nPython, to check my understanding of the spec. The C version was about 900× faster.\n\n726\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 2349,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 757,
      "content": "Data Science Data science—including artificial intelligence—and scientific computing are very well served by Python. Applications in these fields are compute-intensive, but Python users benefit from a vast ecosystem of numeric computing libraries written in C, C++, Fortran, Cython, etc.—many of which are able to leverage multicore machines, GPUs, and/or distributed parallel computing in heterogeneous clusters.\n\nAs of 2021, Python’s data science ecosystem includes impressive tools such as:\n\nProject Jupyter\n\nTwo browser-based interfaces—Jupyter Notebook and JupyterLab—that allow users to run and document analytics code potentially running across the network on remote machines. Both are hybrid Python/JavaScript applications, supporting computing kernels written in different languages, all integrated via ZeroMQ—an asynchronous messaging library for distributed applications. The name Jupyter actually comes from Julia, Python, and R, the first three languages supported by the Notebook. The rich ecosystem built on top of the Jupyter tools include Bokeh, a powerful interactive visualization library that lets users navigate and interact with large datasets or continuously updated streaming data, thanks to the performance of modern JavaScript engines and browsers.\n\nTensorFlow and PyTorch\n\nThese are the top two deep learning frameworks, according to O’Reilly’s January 2021 report on usage of their learning resources during 2020. Both projects are written in C++, and are able to leverage multiple cores, GPUs, and clusters. They support other languages as well, but Python is their main focus and is used by the majority of their users. TensorFlow was created and is used internally by Google; PyTorch by Facebook.\n\nDask\n\nA parallel computing library that can farm out work to local processes or clusters of machines, “tested on some of the largest supercomputers in the world”—as their home page states. Dask offers APIs that closely emulate NumPy, pandas, and scikit-learn—the most popular libraries in data science and machine learn‐ ing today. Dask can be used from JupyterLab or Jupyter Notebook, and leverages Bokeh not only for data visualization but also for an interactive dashboard show‐ ing the flow of data and computations across the processes/machines in near real time. Dask is so impressive that I recommend watching a video such as this 15- minute demo in which Matthew Rocklin—a maintainer of the project—shows Dask crunching data on 64 cores distributed in 8 EC2 machines on AWS.\n\nThese are only some examples to illustrate how the data science community is creat‐ ing solutions that leverage the best of Python and overcome the limitations of the CPython runtime.\n\nPython in the Multicore World\n\n|\n\n727",
      "content_length": 2735,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 758,
      "content": "Server-Side Web/Mobile Development Python is widely used in web applications and for the backend APIs supporting mobile applications. How is it that Google, YouTube, Dropbox, Instagram, Quora, and Reddit—among others—managed to build Python server-side applications serv‐ ing hundreds of millions of users 24x7? Again, the answer goes way beyond what Python provides “out of the box.”\n\nBefore we discuss tools to support Python at scale, I must quote an admonition from the Thoughtworks Technology Radar:\n\nHigh performance envy/web scale envy\n\nWe see many teams run into trouble because they have chosen complex tools, frame‐ works or architectures because they “might need to scale.” Companies such as Twitter and Netflix need to support extreme loads and so need these architectures, but they also have extremely skilled development teams able to handle the complexity. Most sit‐ uations do not require these kinds of engineering feats; teams should keep their web scale envy in check in favor of simpler solutions that still get the job done.20\n\nAt web scale, the key is an architecture that allows horizontal scaling. At that point, all systems are distributed systems, and no single programming language is likely to be the right choice for every part of the solution.\n\nDistributed systems is a field of academic research, but fortunately some practitioners have written accessible books anchored on solid research and practical experience. One of them is Martin Kleppmann, the author of Designing Data-Intensive Applica‐ tions (O’Reilly).\n\nConsider Figure 19-3, the first of many architecture diagrams in Kleppmann’s book. Here are some components I’ve seen in Python engagements that I worked on or have firsthand knowledge of:\n\nApplication caches:21 memcached, Redis, Varnish\n\nRelational databases: PostgreSQL, MySQL\n\nDocument databases: Apache CouchDB, MongoDB\n\nFull-text indexes: Elasticsearch, Apache Solr\n\nMessage queues: RabbitMQ, Redis\n\n20 Source: Thoughtworks Technology Advisory Board, Technology Radar—November 2015.\n\n21 Contrast application caches—used directly by your application code—with HTTP caches, which would be placed on the top edge of Figure 19-3 to serve static assets like images, CSS, and JS files. Content Delivery Networks (CDNs) offer another type of HTTP cache, deployed in data centers closer to the end users of your application.\n\n728\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 2417,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 759,
      "content": "Figure 19-3. One possible architecture for a system combining several components.22\n\nThere are other industrial-strength open source products in each of those categories. Major cloud providers also offer their own proprietary alternatives.\n\nKleppmann’s diagram is general and language independent—as is his book. For Python server-side applications, two specific components are often deployed:\n\nAn application server to distribute the load among several instances of the Python application. The application server would appear near the top in Figure 19-3, handling client requests before they reached the application code.\n\nA task queue built around the message queue on the righthand side of Figure 19-3, providing a higher-level, easier-to-use API to distribute tasks to pro‐ cesses running on other machines.\n\n22 Diagram adapted from Figure 1-1, Designing Data-Intensive Applications by Martin Kleppmann (O’Reilly).\n\nPython in the Multicore World\n\n|\n\n729",
      "content_length": 957,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 760,
      "content": "The next two sections explore these components that are recommended best practi‐ ces in Python server-side deployments.\n\nWSGI Application Servers WSGI—the Web Server Gateway Interface—is a standard API for a Python frame‐ work or application to receive requests from an HTTP server and send responses to it.23 WSGI application servers manage one or more processes running your applica‐ tion, maximizing the use of the available CPUs.\n\nFigure 19-4 illustrates a typical WSGI deployment.\n\nIf we wanted to merge the previous pair of diagrams, the content of the dashed rectangle in Figure 19-4 would replace the solid “Appli‐ cation code” rectangle at the top of Figure 19-3.\n\nThe best-known application servers in Python web projects are:\n\nmod_wsgi • uWSGI24\n\nGunicorn\n\nNGINX Unit\n\nFor users of the Apache HTTP server, mod_wsgi is the best option. It’s as old as WSGI itself, but is actively maintained, and now provides a command-line launcher called mod_wsgi-express that makes it easier to configure and more suitable for use in Docker containers.\n\n23 Some speakers spell out the WSGI acronym, while others pronounce it as one word rhyming with “whisky.”\n\n24 uWSGI is spelled with a lowercase “u,” but that is pronounced as the Greek letter “µ,” so the whole name\n\nsounds like “micro-whisky” with a “g” instead of the “k.”\n\n730\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 1373,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 761,
      "content": "Figure 19-4. Clients connect to an HTTP server that delivers static files and routes other requests to the application server, which forks child processes to run the applica‐ tion code, leveraging multiple CPU cores. The WSGI API is the glue between the appli‐ cation server and the Python application code.\n\nuWSGI and Gunicorn are the top choices in recent projects I know about. Both are often used with the NGINX HTTP server. uWSGI offers a lot of extra functionality, including an application cache, a task queue, cron-like periodic tasks, and many other features. On the flip side, uWSGI is much harder to configure properly than Gunicorn.25\n\nReleased in 2018, NGINX Unit is a new product from the makers of the well-known NGINX HTTP server and reverse proxy.\n\n25 Bloomberg engineers Peter Sperl and Ben Green wrote “Configuring uWSGI for Production Deployment”, explaining how many of the default settings in uWSGI are not suitable for many common deployment sce‐ narios. Sperl presented a summary of their recommendations at EuroPython 2019. Highly recommended for users of uWSGI.\n\nPython in the Multicore World\n\n|\n\n731",
      "content_length": 1126,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 762,
      "content": "mod_wsgi and Gunicorn support Python web apps only, while uWSGI and NGINX Unit work with other languages as well. Please browse their docs to learn more.\n\nThe main point: all of these application servers can potentially use all CPU cores on the server by forking multiple Python processes to run traditional web apps written in good old sequential code in Django, Flask, Pyramid, etc. This explains why it’s been possible to earn a living as a Python web developer without ever studying the threading, multiprocessing, or asyncio modules: the application server handles concurrency transparently.\n\nASGI—Asynchronous Server Gateway Interface\n\nWSGI is a synchronous API. It doesn’t support coroutines with async/await—the most efficient way to implement WebSockets or HTTP long polling in Python. The ASGI specification is a succes‐ sor to WSGI, designed for asynchronous Python web frameworks such as aiohttp, Sanic, FastAPI, etc., as well as Django and Flask, which are gradually adding asynchronous functionality.\n\nNow let’s turn to another way of bypassing the GIL to achieve higher performance with server-side Python applications.\n\nDistributed Task Queues When the application server delivers a request to one of the Python processes run‐ ning your code, your app needs to respond quickly: you want the process to be avail‐ able to handle the next request as soon as possible. However, some requests demand actions that may take longer—for example, sending email or generating a PDF. That’s the problem that distributed task queues are designed to solve.\n\nCelery and RQ are the best known open source task queues with Python APIs. Cloud providers also offer their own proprietary task queues.\n\nThese products wrap a message queue and offer a high-level API for delegating tasks to workers, possibly running on different machines.\n\nIn the context of task queues, the words producer and consumer are used instead of traditional client/server terminology. For example, a Django view handler produces job requests, which are put in the queue to be consumed by one or more PDF rendering processes.\n\nQuoting directly from Celery’s FAQ, here are some typical use cases:\n\nRunning something in the background. For example, to finish the web request as soon as possible, then update the users page incrementally. This gives the user the\n\n732\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 2380,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 763,
      "content": "impression of good performance and “snappiness,” even though the real work might actually take some time.\n\nRunning something after the web request has finished.\n\nMaking sure something is done, by executing it asynchronously and using retries.\n\nScheduling periodic work.\n\nBesides solving these immediate problems, task queues support horizontal scalability. Producers and consumers are decoupled: a producer doesn’t call a consumer, it puts a request in a queue. Consumers don’t need to know anything about the producers (but the request may include information about the producer, if an acknowledgment is required). Crucially, you can easily add more workers to consume tasks as demand grows. That’s why Celery and RQ are called distributed task queues.\n\nRecall that our simple procs.py (Example 19-13) used two queues: one for job requests, the other for collecting results. The distributed architecture of Celery and RQ uses a similar pattern. Both support using the Redis NoSQL database as a message queue and result storage. Celery also supports other message queues like RabbitMQ or Amazon SQS, as well other databases for result storage.\n\nThis wraps up our introduction to concurrency in Python. The next two chapters will continue this theme, focusing on the concurrent.futures and asyncio packages of the standard library.\n\nChapter Summary After a bit of theory, this chapter presented the spinner scripts implemented in each of Python’s three native concurrency programming models:\n\nThreads, with the threading package • Processes, with multiprocessing • Asynchronous coroutines with asyncio\n\nWe then explored the real impact of the GIL with an experiment: changing the spin‐ ner examples to compute the primality of a large integer and observe the resulting behavior. This demonstrated graphically that CPU-intensive functions must be avoi‐ ded in asyncio, as they block the event loop. The threaded version of the experiment worked—despite the GIL—because Python periodically interrupts threads, and the example used only two threads: one doing compute-intensive work, and the other driving the animation only 10 times per second. The multiprocessing variant worked around the GIL, starting a new process just for the animation, while the main process did the primality check.\n\nChapter Summary\n\n|\n\n733",
      "content_length": 2312,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 764,
      "content": "The next example, computing several primes, highlighted the difference between mul tiprocessing and threading, proving that only processes allow Python to benefit from multicore CPUs. Python’s GIL makes threads worse than sequential code for heavy computations.\n\nThe GIL dominates discussions about concurrent and parallel computing in Python, but we should not overestimate its impact. That was the point of “Python in the Mul‐ ticore World” on page 725. For example, the GIL doesn’t affect many use cases of Python in system administration. On the other hand, the data science and server-side development communities have worked around the GIL with industrial-strength sol‐ utions tailored to their specific needs. The last two sections mentioned two common elements to support Python server-side applications at scale: WSGI application servers and distributed task queues.\n\nFurther Reading This chapter has an extensive reading list, so I split it into subsections.\n\nConcurrency with Threads and Processes The concurrent.futures library covered in Chapter 20 uses threads, processes, locks, and queues under the hood, but you won’t see individual instances of them; they’re bundled and managed by the higher-level abstractions of a ThreadPoolExecutor and a ProcessPoolExecutor. If you want to learn more about the practice of concurrent programming with those low-level objects, “An Intro to Threading in Python” by Jim Anderson is a good first read. Doug Hellmann has a chapter titled “Concurrency with Processes, Threads, and Coroutines” on his website and book, The Python 3 Standard Library by Example (Addison-Wesley).\n\nBrett Slatkin’s Effective Python, 2nd ed. (Addison-Wesley), David Beazley’s Python Essential Reference, 4th ed. (Addison-Wesley), and Martelli et al., Python in a Nut‐ shell, 3rd ed. (O’Reilly) are other general Python references with significant coverage of threading and multiprocessing. The vast multiprocessing official documenta‐ tion includes useful advice in its “Programming guidelines” section.\n\nJesse Noller and Richard Oudkerk contributed the multiprocessing package, intro‐ duced in PEP 371—Addition of the multiprocessing package to the standard library. The official documentation for the package is a 93 KB .rst file—that’s about 63 pages —making it one of the longest chapters in the Python standard library.\n\nIn High Performance Python, 2nd ed., (O’Reilly), authors Micha Gorelick and Ian Ozsvald include a chapter about multiprocessing with an example about checking for primes with a different strategy than our procs.py example. For each number, they split the range of possible factors—from 2 to sqrt(n)—into subranges, and make\n\n734\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 2727,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 765,
      "content": "each worker iterate over one of the subranges. Their divide-and-conquer approach is typical of scientific computing applications where the datasets are huge, and worksta‐ tions (or clusters) have more CPU cores than users. On a server-side system handling requests from many users, it is simpler and more efficient to let each process work on one computation from start to finish—reducing the overhead of communication and coordination among processes. Besides multiprocessing, Gorelick and Ozsvald present many other ways of developing and deploying high-performance data science applications leveraging multiple cores, GPUs, clusters, profilers, and compilers like Cython and Numba. Their last chapter, “Lessons from the Field,” is a valuable collec‐ tion of short case studies contributed by other practitioners of high-performance computing in Python.\n\nAdvanced Python Development by Matthew Wilkes (Apress), is a rare book that includes short examples to explain concepts, while also showing how to build a realis‐ tic application ready for production: a data aggregator, similar to DevOps monitoring systems or IoT data collectors for distributed sensors. Two chapters in Advanced Python Development cover concurrent programming with threading and asyncio.\n\nJan Palach’s Parallel Programming with Python (Packt, 2014) explains the core con‐ cepts behind concurrency and parallelism, covering Python’s standard library as well as Celery.\n\n“The Truth About Threads” is the title of Chapter 2 in Using Asyncio in Python by Caleb Hattingh (O’Reilly).26 The chapter covers the benefits and drawbacks of thread‐ ing—with compelling quotes from several authoritative sources—making it clear that the fundamental challenges of threads have nothing to do with Python or the GIL. Quoting verbatim from page 14 of Using Asyncio in Python:\n\nThese themes repeat throughout:\n\nThreading makes code hard to reason about.\n\nThreading is an inefficient model for large-scale concurrency (thousands of con‐ current tasks).\n\nIf you want to learn the hard way how difficult it is to reason about threads and locks —without risking your job—try the exercises in Allen Downey’s workbook, The Little Book of Semaphores (Green Tea Press). The exercises in Downey’s book range from easy to very hard to unsolvable, but even the easy ones are eye-opening.\n\n26 Caleb is one of the tech reviewers for this edition of Fluent Python.\n\nFurther Reading\n\n|\n\n735",
      "content_length": 2432,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 766,
      "content": "The GIL If you are intrigued about the GIL, remember we have no control over it from Python code, so the canonical reference is in the C-API documentation: Thread State and the Global Interpreter Lock. The Python Library and Extension FAQ answers: “Can’t we get rid of the Global Interpreter Lock?”. Also worth reading are posts by Guido van Rossum and Jesse Noller (contributor of the multiprocessing package), respectively: “It isn’t Easy to Remove the GIL” and “Python Threads and the Global Interpreter Lock”.\n\nCPython Internals by Anthony Shaw (Real Python) explains the implementation of the CPython 3 interpreter at the C programming level. Shaw’s longest chapter is “Parallelism and Concurrency”: a deep dive into Python’s native support for threads and processes, including managing the GIL from extensions using the C/Python API.\n\nFinally, David Beazley presented a detailed exploration in “Understanding the Python GIL”.27 In slide #54 of the presentation, Beazley reports an increase in pro‐ cessing time for a particular benchmark with the new GIL algorithm introduced in Python 3.2. The issue is not significant with real workloads, according to a comment by Antoine Pitrou—who implemented the new GIL algorithm—in the bug report submitted by Beazley: Python issue #7946.\n\nConcurrency Beyond the Standard Library Fluent Python focuses on core language features and core parts of the standard library. Full Stack Python is a great complement to this book: it’s about Python’s eco‐ system, with sections titled “Development Environments,” “Data,” “Web Develop‐ ment,” and “DevOps,” among others.\n\nI’ve already mentioned two books that cover concurrency using the Python standard library that also include significant content on third-party libraries and tools: High Performance Python, 2nd ed. and Parallel Programming with Python. Francesco Pierfederici’s Distributed Computing with Python (Packt) covers the standard library and also the use of cloud providers and HPC (High-Performance Computing) clus‐ ters.\n\n“Python, Performance, and GPUs” by Matthew Rocklin is “a status update for using GPU accelerators from Python,” posted in June 2019.\n\n“Instagram currently features the world’s largest deployment of the Django web framework, which is written entirely in Python.” That’s the opening sentence of the blog post, “Web Service Efficiency at Instagram with Python”, written by Min Ni—a software engineer at Instagram. The post describes metrics and tools Instagram uses\n\n27 Thanks to Lucas Brunialti for sending me a link to this talk.\n\n736\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 2603,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 767,
      "content": "to optimize the efficiency of its Python codebase, as well as detect and diagnose per‐ formance regressions as it deploys its back end “30-50 times a day.”\n\nArchitecture Patterns with Python: Enabling Test-Driven Development, Domain- Driven Design, and Event-Driven Microservices by Harry Percival and Bob Gregory (O’Reilly) presents architectural patterns for Python server-side applications. The authors also made the book freely available online at cosmicpython.com.\n\nTwo elegant and easy-to-use libraries for parallelizing tasks over processes are lelo by João S. O. Bueno and python-parallelize by Nat Pryce. The lelo package defines a @par allel decorator that you can apply to any function to magically make it unblocking: when you call the decorated function, its execution is started in another process. Nat Pryce’s python-parallelize package provides a parallelize generator that distributes the execution of a for loop over multiple CPUs. Both packages are built on the multi‐ processing library.\n\nPython core developer Eric Snow maintains a Multicore Python wiki, with notes about his and other people’s efforts to improve Python’s support for parallel execu‐ tion. Snow is the author of PEP 554—Multiple Interpreters in the Stdlib. If approved and implemented, PEP 554 lays the groundwork for future enhancements that may eventually allow Python to use multiple cores without the overheads of multiprocess‐ ing. One of the biggest blockers is the complex interaction between multiple active subinterpreters and extensions that assume a single interpreter.\n\nMark Shannon—also a Python maintainer—created a useful table comparing concur‐ rent models in Python, referenced in a discussion about subinterpreters between him, Eric Snow, and other developers on the python-dev mailing list. In Shannon’s table, the “Ideal CSP” column refers to the theoretical Communicating sequential processes model proposed by Tony Hoare in 1978. Go also allows shared objects, violating an essential constraint of CSP: execution units should communicate through message passing through channels.\n\nStackless Python (a.k.a. Stackless) is a fork of CPython implementing microthreads, which are application-level lightweight threads—as opposed to OS threads. The mas‐ sively multiplayer online game EVE Online was built on Stackless, and engineers employed by the game company CCP were maintainers of Stackless for a while. Some features of Stackless were reimplemented in the Pypy interpreter and the greenlet package, the core technology of the gevent networking library, which in turn is the foundation of the Gunicorn application server.\n\nThe actor model of concurrent programming is at the core of the highly scalable Erlang and Elixir languages, and is also the model of the Akka framework for Scala and Java. If you want to try out the actor model in Python, check out the Thespian and Pykka libraries.\n\nFurther Reading\n\n|\n\n737",
      "content_length": 2924,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 768,
      "content": "My remaining recommendations have few or zero mentions of Python, but are nev‐ ertheless relevant to readers interested in the theme of this chapter.\n\nConcurrency and Scalability Beyond Python RabbitMQ in Action by Alvaro Videla and Jason J. W. Williams (Manning) is a very well-written introduction to RabbitMQ and the Advanced Message Queuing Protocol (AMQP) standard, with examples in Python, PHP, and Ruby. Regardless of the rest of your tech stack, and even if you plan to use Celery with RabbitMQ under the hood, I recommend this book for its coverage of concepts, motivation, and patterns for dis‐ tributed message queues, as well as operating and tuning RabbitMQ at scale.\n\nI learned a lot reading Seven Concurrency Models in Seven Weeks, by Paul Butcher (Pragmatic Bookshelf), with the eloquent subtitle When Threads Unravel. Chapter 1 of the book presents the core concepts and challenges of programming with threads and locks in Java.28 The remaining six chapters of the book are devoted to what the author considers better alternatives for concurrent and parallel programming, as sup‐ ported by different languages, tools, and libraries. The examples use Java, Clojure, Elixir, and C (for the chapter about parallel programming with the OpenCL frame‐ work). The CSP model is exemplified with Clojure code, although the Go language deserves credit for popularizing that approach. Elixir is the language of the examples illustrating the actor model. A freely available, alternative bonus chapter about actors uses Scala and the Akka framework. Unless you already know Scala, Elixir is a more accessible language to learn and experiment with the actor model and the Erlang/OTP distributed systems platform.\n\nUnmesh Joshi of Thoughtworks has contributed several pages documenting “Pat‐ terns of Distributed Systems” to Martin Fowler’s blog. The opening page is a great introduction the topic, with links to individual patterns. Joshi is adding patterns incrementally, but what’s already there distills years of hard-earned experience in mission-critical systems.\n\nMartin Kleppmann’s Designing Data-Intensive Applications (O’Reilly) is a rare book written by a practitioner with deep industry experience and advanced academic back‐ ground. The author worked with large-scale data infrastructure at LinkedIn and two startups, before becoming a researcher of distributed systems at the University of Cambridge. Each chapter in Kleppmann’s book ends with an extensive list of refer‐ ences, including recent research results. The book also includes numerous illuminat‐ ing diagrams and beautiful concept maps.\n\nI was fortunate to be in the audience for Francesco Cesarini’s outstanding workshop on the architecture of reliable distributed systems at OSCON 2016: “Designing and\n\n28 Python’s threading and concurrent.futures APIs are heavily influenced by the Java standard library.\n\n738\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 2933,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 769,
      "content": "architecting for scalability with Erlang/OTP” (video at the O’Reilly Learning Plat‐ form). Despite the title, 9:35 into the video, Cesarini explains:\n\nVery little of what I am going to say will be Erlang-specific […]. The fact remains that Erlang will remove a lot of accidental difficulties to making systems which are resilient and which never fail, and are scalable. So it will be much easier if you do use Erlang, or a language running on the Erlang virtual machine.\n\nThat workshop was based on the last four chapters of Designing for Scalability with Erlang/OTP by Francesco Cesarini and Steve Vinoski (O’Reilly).\n\nProgramming distributed systems is challenging and exciting, but beware of web- scale envy. The KISS principle remains solid engineering advice.\n\nCheck out the paper “Scalability! But at what COST?” by Frank McSherry, Michael Isard, and Derek G. Murray. The authors identified parallel graph-processing systems presented in academic symposia that require hundreds of cores to outperform a “competent single-threaded implementation.” They also found systems that “under‐ perform one thread for all of their reported configurations.”\n\nThose findings remind me of a classic hacker quip:\n\nMy Perl script is faster than your Hadoop cluster.\n\nSoapbox\n\nTo Manage Complexity, We Need Constraints\n\nI learned to program on a TI-58 calculator. Its “language” was similar to assembly. At that level, all “variables” are globals, and you don’t have the luxury of structured con‐ trol flow statements. You have conditional jumps: instructions that take the execution directly to an arbitrary location—ahead or behind the current spot—depending on the value of a CPU register or flag.\n\nBasically you can do anything in assembly, and that’s the challenge: there are very few constraints to keep you from making mistakes, and to help maintainers understand the code when changes are needed.\n\nThe second language I learned was the unstructured BASIC that came with 8-bit computers—nothing like Visual Basic, which appeared much later. There were FOR, GOSUB, and RETURN statements, but still no concept of local variables. GOSUB did not support parameter passing: it was just a fancy GOTO that put a return line number in a stack so that RETURN had a target to jump to. Subroutines could help themselves to the global data, and put results there too. We had to improvise other forms of control flow with combinations of IF and GOTO—which, again, allowed you to jump to any line of the program.\n\nFurther Reading\n\n|\n\n739",
      "content_length": 2519,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 770,
      "content": "After a few years of programming with jumps and global variables, I remember the struggle to rewire my brain for “structured programming” when I learned Pascal. Now I had to use control flow statements around blocks of code that have a single entry point. I couldn’t jump to any instruction I liked. Global variables were unavoid‐ able in BASIC, but now they were taboo. I needed to rethink the flow of data and explicitly pass arguments to functions.\n\nThe next challenge for me was learning object-oriented programming. At its core, object-oriented programming is structured programming with more constraints and polymorphism. Information hiding forces yet another rethink of where data lives. I remember being frustrated more than once because I had to refactor my code so that a method I was writing could get information that was encapsulated in an object that my method could not reach.\n\nFunctional programming languages add other constraints, but immutability is the hardest to swallow after decades of imperative programming and object-oriented programming. After we get used to these constraints, we see them as blessings. They make reasoning about the code much easier.\n\nLack of constraints is the main problem with the threads-and-locks model of concur‐ rent programming. When summarizing Chapter 1 of Seven Concurrency Models in Seven Weeks, Paul Butcher wrote:\n\nThe greatest weakness of the approach, however, is that threads-and-locks program‐ ming is hard. It may be easy for a language designer to add them to a language, but they provide us, the poor programmers, with very little help.\n\nSome examples of unconstrained behavior in that model:\n\nThreads can share access to arbitrary, mutable data structures.\n\nThe scheduler can interrupt a thread at almost any point, including in the middle of a simple operation like a += 1. Very few operations are atomic at the level of source code expressions.\n\nLocks are usually advisory. That’s a technical term meaning that you must remember to explicitly hold a lock before updating a shared data structure. If you forget to get the lock, nothing prevents your code from messing up the data while another thread dutifully holds the lock and is updating the same data.\n\nIn contrast, consider some constraints enforced by the actor model, in which the exe‐ cution unit is called an actor:29\n\n29 The Erlang community uses the term “process” for actors. In Erlang, each process is a function in its own\n\nloop, so they are very lightweight and it’s feasible to have millions of them active at once in a single machine —no relation to the heavyweight OS processes we’ve been talking about elsewhere in this chapter. So here we have examples of the two sins described by Prof. Simon: using different words to mean the same thing, and using one word to mean different things.\n\n740\n\n|\n\nChapter 19: Concurrency Models in Python",
      "content_length": 2874,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 771,
      "content": "An actor can have internal state, but cannot share state with other actors.\n\nActors can only communicate by sending and receiving messages.\n\nMessages only hold copies of data, not references to mutable data.\n\nAn actor only handles one message at a time. There is no concurrent execution inside a single actor.\n\nOf course, you can adopt an actor style of coding in any language by following these rules. You can also use object-oriented programming idioms in C, and even struc‐ tured programming patterns in assembly. But doing any of that requires a lot of agreement and discipline among everyone who touches the code.\n\nManaging locks is unnecessary in the actor model, as implemented by Erlang and Elixir, where all data types are immutable.\n\nThreads-and-locks are not going away. I just don’t think dealing with such low-level entities is a good use of my time as I write applications—as opposed to kernel mod‐ ules or databases.\n\nI reserve the right to change my mind, always. But right now, I am convinced that the actor model is the most sensible, general-purpose concurrent programming model available. CSP (Communicating Sequential Processes) is also sensible, but its implementation in Go leaves out some constraints. The idea in CSP is that coroutines (or goroutines in Go) exchange data and synchronize using queues (called channels in Go). But Go also supports memory sharing and locks. I’ve seen a book about Go advocate the use of shared memory and locks instead of channels—in the name of performance. Old habits die hard.\n\nFurther Reading\n\n|\n\n741",
      "content_length": 1561,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 773,
      "content": "CHAPTER 20 Concurrent Executors\n\nThe people bashing threads are typically system programmers which have in mind use cases that the typical application programmer will never encounter in her life. [...] In 99% of the use cases an application programmer is likely to run into, the simple pat‐ tern of spawning a bunch of independent threads and collecting the results in a queue is everything one needs to know.\n\n—Michele Simionato, Python deep thinker1\n\nThis chapter focuses on the concurrent.futures.Executor classes that encapsulate the pattern of “spawning a bunch of independent threads and collecting the results in a queue,” described by Michele Simionato. The concurrent executors make this pat‐ tern almost trivial to use, not only with threads but also with processes—useful for compute-intensive tasks.\n\nHere I also introduce the concept of futures—objects representing the asynchronous execution of an operation, similar to JavaScript promises. This primitive idea is the foundation not only of concurrent.futures but also of the asyncio package, the subject of Chapter 21.\n\nWhat’s New in This Chapter I renamed the chapter from “Concurrency with Futures” to “Concurrent Executors” because the executors are the most important high-level feature covered here. Futures are low-level objects, focused on in “Where Are the Futures?” on page 751, but mostly invisible in the rest of the chapter.\n\n1 From Michele Simionato’s post, “Threads, processes and concurrency in Python: some thoughts”, summar‐ ized as “Removing the hype around the multicore (non) revolution and some (hopefully) sensible comment about threads and other forms of concurrency.”\n\n743",
      "content_length": 1661,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 774,
      "content": "All the HTTP client examples now use the new HTTPX library, which provides syn‐ chronous and asynchronous APIs.\n\nThe setup for the experiments in “Downloads with Progress Display and Error Han‐ dling” on page 762 is now simpler, thanks to the multithreaded server added to the http.server package in Python 3.7. Previously, the standard library only had the single-threaded BaseHttpServer, which was no good for experimenting with concur‐ rent clients, so I had to resort to external tools in the first edition of this book.\n\n“Launching Processes with concurrent.futures” on page 754 now demonstrates how an executor simplifies the code we saw in “Code for the Multicore Prime Checker” on page 719.\n\nFinally, I moved most of the theory to the new Chapter 19, “Concurrency Models in Python”.\n\nConcurrent Web Downloads Concurrency is essential for efficient network I/O: instead of idly waiting for remote machines, the application should do something else until a response comes back.2\n\nTo demonstrate with code, I wrote three simple programs to download images of 20 country flags from the web. The first one, flags.py, runs sequentially: it only requests the next image when the previous one is downloaded and saved locally. The other two scripts make concurrent downloads: they request several images practically at the same time, and save them as they arrive. The flags_threadpool.py script uses the con current.futures package, while flags_asyncio.py uses asyncio.\n\nExample 20-1 shows the result of running the three scripts, three times each. I also posted a 73s video on YouTube so you can watch them running while a macOS Finder window displays the flags as they are saved. The scripts are downloading images from fluentpython.com, which is behind a CDN, so you may see slower results in the first runs. The results in Example 20-1 were obtained after several runs, so the CDN cache was warm.\n\nExample 20-1. Three typical runs of the scripts flags.py, flags_threadpool.py, and flags_asyncio.py\n\n$ python3 flags.py BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN 20 flags downloaded in 7.26s $ python3 flags.py BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN\n\n2 Particularly if your cloud provider rents machines by the second, regardless of how busy the CPUs are.\n\n744\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 2336,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 775,
      "content": "20 flags downloaded in 7.20s $ python3 flags.py BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN 20 flags downloaded in 7.09s $ python3 flags_threadpool.py DE BD CN JP ID EG NG BR RU CD IR MX US PH FR PK VN IN ET TR 20 flags downloaded in 1.37s $ python3 flags_threadpool.py EG BR FR IN BD JP DE RU PK PH CD MX ID US NG TR CN VN ET IR 20 flags downloaded in 1.60s $ python3 flags_threadpool.py BD DE EG CN ID RU IN VN ET MX FR CD NG US JP TR PK BR IR PH 20 flags downloaded in 1.22s $ python3 flags_asyncio.py BD BR IN ID TR DE CN US IR PK PH FR RU NG VN ET MX EG JP CD 20 flags downloaded in 1.36s $ python3 flags_asyncio.py RU CN BR IN FR BD TR EG VN IR PH CD ET ID NG DE JP PK MX US 20 flags downloaded in 1.27s $ python3 flags_asyncio.py RU IN ID DE BR VN PK MX US IR ET EG NG BD FR CN JP PH CD TR 20 flags downloaded in 1.42s\n\nThe output for each run starts with the country codes of the flags as they are downloaded, and ends with a message stating the elapsed time.\n\nIt took flags.py an average 7.18s to download 20 images.\n\nThe average for flags_threadpool.py was 1.40s.\n\nFor flags_asyncio.py, 1.35s was the average time.\n\nNote the order of the country codes: the downloads happened in a different order every time with the concurrent scripts.\n\nThe difference in performance between the concurrent scripts is not significant, but they are both more than five times faster than the sequential script—and this is just for the small task of downloading 20 files of a few kilobytes each. If you scale the task to hundreds of downloads, the concurrent scripts can outpace the sequential code by a factor or 20 or more.\n\nWhile testing concurrent HTTP clients against public web servers, you may inadvertently launch a denial-of-service (DoS) attack, or be suspected of doing so. In the case of Example 20-1, it’s OK to do it because those scripts are hardcoded to make only 20 requests. We’ll use Python’s http.server package to run tests later in this chapter.\n\nConcurrent Web Downloads\n\n|\n\n745",
      "content_length": 2008,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 776,
      "content": "Now let’s study the implementations of two of the scripts tested in Example 20-1: flags.py and flags_threadpool.py. I will leave the third script, flags_asyncio.py, for Chapter 21, but I wanted to demonstrate all three together to make two points:\n\n1. Regardless of the concurrency constructs you use—threads or coroutines—you’ll see vastly improved throughput over sequential code in network I/O operations, if you code it properly.\n\n2. For HTTP clients that can control how many requests they make, there is no sig‐ nificant difference in performance between threads and coroutines.3\n\nOn to the code.\n\nA Sequential Download Script Example 20-2 contains the implementation of flags.py, the first script we ran in Example 20-1. It’s not very interesting, but we’ll reuse most of its code and settings to implement the concurrent scripts, so it deserves some attention.\n\nFor clarity, there is no error handling in Example 20-2. We will deal with exceptions later, but here I want to focus on the basic structure of the code, to make it easier to contrast this script with the concurrent ones.\n\nExample 20-2. flags.py: sequential download script; some functions will be reused by the other scripts\n\nimport time from pathlib import Path from typing import Callable\n\nimport httpx\n\nPOP20_CC = ('CN IN US ID BR PK NG BD RU JP ' 'MX PH VN ET EG DE IR TR CD FR').split()\n\nBASE_URL = 'https://www.fluentpython.com/data/flags' DEST_DIR = Path('downloaded')\n\ndef save_flag(img: bytes, filename: str) -> None: (DEST_DIR / filename).write_bytes(img)\n\n3 For servers that may be hit by many clients, there is a difference: coroutines scale better because they use much less memory than threads, and also reduce the cost of context switching, which I mentioned in “Thread-Based Nonsolution” on page 724.\n\n746\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 1829,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 777,
      "content": "def get_flag(cc: str) -> bytes: url = f'{BASE_URL}/{cc}/{cc}.gif'.lower() resp = httpx.get(url, timeout=6.1, follow_redirects=True) resp.raise_for_status() return resp.content\n\ndef download_many(cc_list: list[str]) -> int: for cc in sorted(cc_list): image = get_flag(cc) save_flag(image, f'{cc}.gif') print(cc, end=' ', flush=True) return len(cc_list)\n\ndef main(downloader: Callable[[list[str]], int]) -> None: DEST_DIR.mkdir(exist_ok=True) t0 = time.perf_counter() count = downloader(POP20_CC) elapsed = time.perf_counter() - t0 print(f'\\n{count} downloads in {elapsed:.2f}s')\n\nif __name__ == '__main__': main(download_many)\n\nImport the httpx library. It’s not part of the standard library, so by convention the import goes after the standard library modules and a blank line.\n\nList of the ISO 3166 country codes for the 20 most populous countries in order of decreasing population.\n\nThe directory with the flag images.4\n\nLocal directory where the images are saved.\n\nSave the img bytes to filename in the DEST_DIR.\n\nGiven a country code, build the URL and download the image, returning the binary contents of the response.\n\nIt’s good practice to add a sensible timeout to network operations, to avoid blocking for several minutes for no good reason.\n\n4 The images are originally from the CIA World Factbook, a public-domain, US government publication. I\n\ncopied them to my site to avoid the risk of launching a DOS attack on cia.gov.\n\nConcurrent Web Downloads\n\n|\n\n747",
      "content_length": 1468,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 778,
      "content": "By default, HTTPX does not follow redirects.5\n\nThere’s no error handling in this script, but this method raises an exception if the HTTP status is not in the 2XX range—highly recommended to avoid silent failures.\n\ndownload_many implementations.\n\nis\n\nthe key\n\nfunction\n\nto compare with\n\nthe concurrent\n\nLoop over the list of country codes in alphabetical order, to make it easy to see that the ordering is preserved in the output; return the number of country codes downloaded.\n\nDisplay one country code at a time in the same line so we can see progress as each download happens. The end=' ' argument replaces the usual line break at the end of each line printed with a space character, so all country codes are dis‐ played progressively in the same line. The flush=True argument is needed because, by default, Python output is line buffered, meaning that Python only displays printed characters after a line break.\n\nmain must be called with the function that will make the downloads; that way, we can use main as a library function with other implementations of download_many in the threadpool and ascyncio examples.\n\nCreate DEST_DIR if needed; don’t raise an error if the directory exists.\n\nRecord and report the elapsed time after running the downloader function.\n\nCall main with the download_many function.\n\nThe HTTPX library is inspired by the Pythonic requests package, but is built on a more modern foundation. Crucially, HTTPX pro‐ vides synchronous and asynchronous APIs, so we can use it in all HTTP client examples in this chapter and the next. Python’s stan‐ dard library provides the urllib.request module, but its API is synchronous only, and is not user friendly.\n\n5 Setting follow_redirects=True is not needed for this example, but I wanted to highlight this important dif‐ ference between HTTPX and requests. Also, setting follow_redirects=True in this example gives me flexibil‐ ity to host the image files elsewhere in the future. I think the HTTPX default setting of follow_redirects =False is sensible because unexpected redirects can mask needless requests and complicate error diagnostics.\n\n748\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 2153,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 779,
      "content": "There’s really nothing new to flags.py. It serves as a baseline for comparing the other scripts, and I used it as a library to avoid redundant code when implementing them. Now let’s see a reimplementation using concurrent.futures.\n\nDownloading with concurrent.futures The main features of the concurrent.futures package are the ThreadPoolExecutor and ProcessPoolExecutor classes, which implement an API to submit callables for execution in different threads or processes, respectively. The classes transparently manage a pool of worker threads or processes, and queues to distribute jobs and col‐ lect results. But the interface is very high-level, and we don’t need to know about any of those details for a simple use case like our flag downloads.\n\nExample 20-3 shows the easiest way to implement the downloads concurrently, using the ThreadPoolExecutor.map method.\n\nExample 20-3. flags_threadpool.py: threaded download script using futures.Thread PoolExecutor\n\nfrom concurrent import futures\n\nfrom flags import save_flag, get_flag, main\n\ndef download_one(cc: str): image = get_flag(cc) save_flag(image, f'{cc}.gif') print(cc, end=' ', flush=True) return cc\n\ndef download_many(cc_list: list[str]) -> int: with futures.ThreadPoolExecutor() as executor: res = executor.map(download_one, sorted(cc_list))\n\nreturn len(list(res))\n\nif __name__ == '__main__': main(download_many)\n\nReuse some functions from the flags module (Example 20-2).\n\nFunction to download a single image; this is what each worker will execute.\n\nInstantiate the ThreadPoolExecutor as a context manager; the executor .__exit__ method will call executor.shutdown(wait=True), which will block until all threads are done.\n\nConcurrent Web Downloads\n\n|\n\n749",
      "content_length": 1717,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 780,
      "content": "The map method is similar to the map built-in, except that the download_one func‐ tion will be called concurrently from multiple threads; it returns a generator that you can iterate to retrieve the value returned by each function call—in this case, each call to download_one will return a country code.\n\nReturn the number of results obtained. If any of the threaded calls raises an exception, that exception is raised here when the implicit next() call inside the list constructor tries to retrieve the corresponding return value from the itera‐ tor returned by executor.map.\n\nCall the main function from the flags module, passing the concurrent version of download_many.\n\nNote that the download_one function from Example 20-3 is essentially the body of the for loop in the download_many function from Example 20-2. This is a common refac‐ toring when writing concurrent code: turning the body of a sequential for loop into a function to be called concurrently.\n\nExample 20-3 is very short because I was able to reuse most func‐ tions from the sequential flags.py script. One of the best features of concurrent.futures is to make it simple to add concurrent execu‐ tion on top of legacy sequential code.\n\nThe ThreadPoolExecutor constructor takes several arguments not shown, but the first and most important one is max_workers, setting the maximum number of worker threads to be executed. When max_workers is None (the default), ThreadPool Executor decides its value using the following expression—since Python 3.8:\n\nmax_workers = min(32, os.cpu_count() + 4)\n\nThe rationale is explained in the ThreadPoolExecutor documentation:\n\nThis default value preserves at least 5 workers for I/O bound tasks. It utilizes at most 32 CPU cores for CPU bound tasks which release the GIL. And it avoids using very large resources implicitly on many-core machines. ThreadPoolExecutor now reuses idle worker threads before starting max_workers worker threads too.\n\nTo conclude: the computed default for max_workers is sensible, and ThreadPoolExe cutor avoids starting new workers unnecessarily. Understanding the logic behind max_workers may help you decide when and how to set it yourself.\n\nThe library is called concurrency.futures, yet there are no futures to be seen in Example 20-3, so you may be wondering where they are. The next section explains.\n\n750\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 2379,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 781,
      "content": "Where Are the Futures? Futures are core components of concurrent.futures and of asyncio, but as users of these libraries we sometimes don’t see them. Example 20-3 depends on futures behind the scenes, but the code I wrote does not touch them directly. This section is an overview of futures, with an example that shows them in action.\n\nSince Python 3.4, there are two classes named Future in the standard library: concur rent.futures.Future and asyncio.Future. They serve the same purpose: an instance of either Future class represents a deferred computation that may or may not have completed. This is somewhat similar to the Deferred class in Twisted, the Future class in Tornado, and Promise in modern JavaScript.\n\nFutures encapsulate pending operations so that we can put them in queues, check whether they are done, and retrieve results (or exceptions) when they become available.\n\nAn important thing to know about futures is that you and I should not create them: they are meant to be instantiated exclusively by the concurrency framework, be it concurrent.futures or asyncio. Here is why: a Future represents something that will eventually run, therefore it must be scheduled to run, and that’s the job of the framework. In particular, concurrent.futures.Future instances are created only as the result of submitting a callable for execution with a concurrent.futures.Execu tor subclass. For example, the Executor.submit() method takes a callable, schedules it to run, and returns a Future.\n\nApplication code is not supposed to change the state of a future: the concurrency framework changes the state of a future when the computation it represents is done, and we can’t control when that happens.\n\nBoth types of Future have a .done() method that is nonblocking and returns a Boolean that tells you whether the callable wrapped by that future has executed or not. However, instead of repeatedly asking whether a future is done, client code usu‐ ally asks to be notified. That’s why both Future classes have an .add_done_call back() method: you give it a callable, and the callable will be invoked with the future as the single argument when the future is done. Be aware that the callback callable will run in the same worker thread or process that ran the function wrapped in the future.\n\nThere is also a .result() method, which works the same in both classes when the future is done: it returns the result of the callable, or re-raises whatever exception might have been thrown when the callable was executed. However, when the future is not done, the behavior of the result method is very different between the two flavors of Future. In a concurrency.futures.Future instance, invoking f.result() will block the caller’s thread until the result is ready. An optional timeout argument can\n\nConcurrent Web Downloads\n\n|\n\n751",
      "content_length": 2829,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 782,
      "content": "be passed, and if the future is not done in the specified time, the result method raises TimeoutError. The asyncio.Future.result method does not support time‐ out, and await is the preferred way to get the result of futures in asyncio—but await doesn’t work with concurrency.futures.Future instances.\n\nSeveral functions in both libraries return futures; others use them in their implemen‐ tation in a way that is transparent to the user. An example of the latter is the Execu tor.map we saw in Example 20-3: it returns an iterator in which __next__ calls the result method of each future, so we get the results of the futures, and not the futures themselves.\n\nTo get a practical look at futures, we can rewrite Example 20-3 to use the concur rent.futures.as_completed function, which takes an iterable of futures and returns an iterator that yields futures as they are done.\n\nUsing futures.as_completed requires changes to the download_many function only. The higher-level executor.map call is replaced by two for loops: one to create and schedule the futures, the other to retrieve their results. While we are at it, we’ll add a few print calls to display each future before and after it’s done. Example 20-4 shows the code for a new download_many function. The code for download_many grew from 5 to 17 lines, but now we get to inspect the mysterious futures. The remaining func‐ tions are the same as in Example 20-3.\n\nExample 20-4. flags_threadpool_futures.py: replacing executor.map with execu tor.submit and futures.as_completed in the download_many function\n\ndef download_many(cc_list: list[str]) -> int: cc_list = cc_list[:5] with futures.ThreadPoolExecutor(max_workers=3) as executor: to_do: list[futures.Future] = [] for cc in sorted(cc_list): future = executor.submit(download_one, cc) to_do.append(future) print(f'Scheduled for {cc}: {future}')\n\nfor count, future in enumerate(futures.as_completed(to_do), 1): res: str = future.result() print(f'{future} result: {res!r}')\n\nreturn count\n\n752\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 2038,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 783,
      "content": "For this demonstration, use only the top five most populous countries.\n\nSet max_workers to 3 so we can see pending futures in the output.\n\nIterate over country codes alphabetically, to make it clear that results will arrive out of order.\n\nexecutor.submit schedules the callable to be executed, and returns a future representing this pending operation.\n\nStore each future so we can later retrieve them with as_completed.\n\nDisplay a message with the country code and the respective future.\n\nas_completed yields futures as they are completed.\n\nGet the result of this future.\n\nDisplay the future and its result.\n\nNote that the future.result() call will never block in this example because the future is coming out of as_completed. Example 20-5 shows the output of one run of Example 20-4.\n\nExample 20-5. Output of flags_threadpool_futures.py\n\n$ python3 flags_threadpool_futures.py Scheduled for BR: <Future at 0x100791518 state=running> Scheduled for CN: <Future at 0x100791710 state=running> Scheduled for ID: <Future at 0x100791a90 state=running> Scheduled for IN: <Future at 0x101807080 state=pending> Scheduled for US: <Future at 0x101807128 state=pending> CN <Future at 0x100791710 state=finished returned str> result: 'CN' BR ID <Future at 0x100791518 state=finished returned str> result: 'BR' <Future at 0x100791a90 state=finished returned str> result: 'ID' IN <Future at 0x101807080 state=finished returned str> result: 'IN' US <Future at 0x101807128 state=finished returned str> result: 'US'\n\n5 downloads in 0.70s\n\nThe futures are scheduled in alphabetical order; the repr() of a future shows its state: the first three are running, because there are three worker threads.\n\nThe last two futures are pending, waiting for worker threads.\n\nConcurrent Web Downloads\n\n|\n\n753",
      "content_length": 1774,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 784,
      "content": "The first CN here is the output of download_one in a worker thread; the rest of the line is the output of download_many.\n\nHere, two threads output codes before download_many in the main thread can display the result of the first thread.\n\nI recommend experimenting with flags_threadpool_futures.py. If you run it several times, you’ll see the order of the results varying. Increasing max_workers to 5 will increase the variation in the order of the results. Decreasing it to 1 will make this script run sequen‐ tially, and the order of the results will always be the order of the submit calls.\n\nWe saw two variants of the download script using concurrent.futures: one in Example 20-3 with ThreadPoolExecutor.map and one in Example 20-4 with futures.as_completed. If you are curious about the code for flags_asyncio.py, you may peek at Example 21-3 in Chapter 21, where it is explained.\n\nNow let’s take a brief look at a simple way to work around the GIL for CPU-bound jobs using concurrent.futures.\n\nLaunching Processes with concurrent.futures The concurrent.futures documentation page is subtitled “Launching parallel tasks.” The package enables parallel computation on multicore machines because it supports distributing work among multiple Python processes using the ProcessPool Executor class.\n\nBoth ProcessPoolExecutor and ThreadPoolExecutor implement the Executor interface, so it’s easy to switch from a thread-based to a process-based solution using concurrent.futures.\n\nThere is no advantage in using a ProcessPoolExecutor for the flags download exam‐ ple or any I/O-bound job. It’s easy to verify this; just change these lines in Example 20-3:\n\ndef download_many(cc_list: list[str]) -> int: with futures.ThreadPoolExecutor() as executor:\n\nTo this:\n\ndef download_many(cc_list: list[str]) -> int: with futures.ProcessPoolExecutor() as executor:\n\n754\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 1893,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 785,
      "content": "The constructor for ProcessPoolExecutor also has a max_workers parameter, which defaults to None. In that case, the executor limits the number of workers to the num‐ ber returned by os.cpu_count().\n\nProcesses use more memory and take longer to start than threads, so the real value of ProcessPoolExecutor is in CPU-intensive jobs. Let’s go back to the primality test example of “A Homegrown Process Pool” on page 716, rewriting it with concurrent.futures.\n\nMulticore Prime Checker Redux In “Code for the Multicore Prime Checker” on page 719 we studied procs.py, a script that checked the primality of some large numbers using multiprocessing. In Example 20-6 we solve the same problem in the proc_pool.py program using a Proc essPoolExecutor. From the first import to the main() call at the end, procs.py has 43 nonblank lines of code, and proc_pool.py has 31—28% shorter.\n\nExample 20-6. proc_pool.py: procs.py rewritten with ProcessPoolExecutor\n\nimport sys from concurrent import futures from time import perf_counter from typing import NamedTuple\n\nfrom primes import is_prime, NUMBERS\n\nclass PrimeResult(NamedTuple): n: int flag: bool elapsed: float\n\ndef check(n: int) -> PrimeResult: t0 = perf_counter() res = is_prime(n) return PrimeResult(n, res, perf_counter() - t0)\n\ndef main() -> None: if len(sys.argv) < 2: workers = None else: workers = int(sys.argv[1])\n\nexecutor = futures.ProcessPoolExecutor(workers) actual_workers = executor._max_workers # type: ignore\n\nprint(f'Checking {len(NUMBERS)} numbers with {actual_workers} processes:')\n\nt0 = perf_counter()\n\nLaunching Processes with concurrent.futures\n\n|\n\n755",
      "content_length": 1616,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 786,
      "content": "numbers = sorted(NUMBERS, reverse=True) with executor: for n, prime, elapsed in executor.map(check, numbers): label = 'P' if prime else ' ' print(f'{n:16} {label} {elapsed:9.6f}s')\n\ntime = perf_counter() - t0 print(f'Total time: {time:.2f}s')\n\nif __name__ == '__main__': main()\n\nNo need to import multiprocessing, SimpleQueue etc.; concurrent.futures hides all that.\n\nThe PrimeResult tuple and the check function are the same as we saw in procs.py, but we don’t need the queues and the worker function anymore.\n\nInstead of deciding ourselves how many workers to use if no command-line argument was given, we set workers to None and let the ProcessPoolExecutor decide.\n\nHere I build the ProcessPoolExecutor before the with block in ➐ so that I can display the actual number of workers in the next line.\n\n_max_workers is an undocumented instance attribute of a ProcessPoolExecutor. I decided to use it to show the number of workers when the workers variable is None. Mypy correctly complains when I access it, so I put the type: ignore com‐ ment to silence it.\n\nSort the numbers to be checked in descending order. This will expose a differ‐ ence in the behavior of proc_pool.py when compared with procs.py. See the explanation after this example.\n\nUse the executor as a context manager.\n\nThe executor.map call returns the PrimeResult instances returned by check in the same order as the numbers arguments.\n\nIf you run Example 20-6, you’ll see the results appearing in strict descending order, as shown in Example 20-7. In contrast, the ordering of the output of procs.py (shown in “Process-Based Solution” on page 718) is heavily influenced by the difficulty in checking whether each number is a prime. For example, procs.py shows the result for\n\n756\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 1785,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 787,
      "content": "7777777777777777 near the top, because it has a low divisor, 7, so is_prime quickly determines it’s not a prime.\n\nIn contrast, 7777777536340681 is 881917092, so is_prime will take much longer to determine that it’s a composite number, and even longer to find out that 7777777777777753 is prime—therefore both of these numbers appear near the end of the output of procs.py.\n\nRunning proc_pool.py, you’ll observe not only the descending order of the results, but also that the program will appear to be stuck after showing the result for 9999999999999999.\n\nExample 20-7. Output of proc_pool.py\n\n$ ./proc_pool.py Checking 20 numbers with 12 processes: 9999999999999999 0.000024s 9999999999999917 P 9.500677s 7777777777777777 0.000022s 7777777777777753 P 8.976933s 7777777536340681 8.896149s 6666667141414921 8.537621s 6666666666666719 P 8.548641s 6666666666666666 0.000002s 5555555555555555 0.000017s 5555555555555503 P 8.214086s 5555553133149889 8.067247s 4444444488888889 7.546234s 4444444444444444 0.000002s 4444444444444423 P 7.622370s 3333335652092209 6.724649s 3333333333333333 0.000018s 3333333333333301 P 6.655039s 299593572317531 P 2.072723s 142702110479723 P 1.461840s 2 P 0.000001s Total time: 9.65s\n\nThis line appears very quickly.\n\nThis line takes more than 9.5s to show up.\n\nAll the remaining lines appear almost immediately.\n\nLaunching Processes with concurrent.futures\n\n|\n\n757",
      "content_length": 1389,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 788,
      "content": "Here is why proc_pool.py behaves in that way:\n\nAs mentioned before, executor.map(check, numbers) returns the result in the same order as the numbers are given.\n\nBy default, proc_pool.py uses as many workers as there are CPUs—it’s what ProcessPoolExecutor does when max_workers is None. That’s 12 processes in this laptop.\n\nBecause we are submitting numbers\n\nin descending order, the first\n\n9999999999999999; with 9 as a divisor, it returns quickly.\n\nThe second number is 9999999999999917, the largest prime in the sample. This will take longer than all the others to check.\n\nMeanwhile, the remaining 11 processes will be checking other numbers, which are either primes or composites with large factors, or composites with very small factors.\n\nWhen the worker in charge of 9999999999999917 finally determines that’s a prime, all the other processes have completed their last jobs, so the results appear immediately after.\n\nAlthough the progress of proc_pool.py is not as visible as that of procs.py, the overall execution time is practically the same as depic‐ ted in Figure 19-2, for the same number of workers and CPU cores.\n\nUnderstanding how concurrent programs behave is not straightforward, so here’s is a second experiment that may help you visualize the operation of Executor.map.\n\nExperimenting with Executor.map Let’s investigate Executor.map, now using a ThreadPoolExecutor with three workers running five callables that output timestamped messages. The code in Example 20-8, the output in Example 20-9.\n\nExample 20-8. demo_executor_map.py: Simple demonstration of the map method of ThreadPoolExecutor\n\nfrom time import sleep, strftime from concurrent import futures\n\ndef display(*args): print(strftime('[%H:%M:%S]'), end=' ') print(*args)\n\n758\n\n|\n\nChapter 20: Concurrent Executors\n\nis\n\nis",
      "content_length": 1799,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 789,
      "content": "def loiter(n): msg = '{}loiter({}): doing nothing for {}s...' display(msg.format('\\t'*n, n, n)) sleep(n) msg = '{}loiter({}): done.' display(msg.format('\\t'*n, n)) return n * 10\n\ndef main(): display('Script starting.') executor = futures.ThreadPoolExecutor(max_workers=3) results = executor.map(loiter, range(5)) display('results:', results) display('Waiting for individual results:') for i, result in enumerate(results): display(f'result {i}: {result}')\n\nif __name__ == '__main__': main()\n\nThis function simply prints whatever arguments it gets, preceded by a timestamp in the format [HH:MM:SS].\n\nloiter does nothing except display a message when it starts, sleep for n seconds, then display a message when it ends; tabs are used to indent the messages accord‐ ing to the value of n.\n\nloiter returns n * 10 so we can see how to collect results.\n\nCreate a ThreadPoolExecutor with three threads.\n\nSubmit five tasks to the executor. Since there are only three threads, only three of those tasks will start immediately: the calls loiter(0), loiter(1), and loi ter(2); this is a nonblocking call.\n\nImmediately display the results of invoking executor.map: it’s a generator, as the output in Example 20-9 shows.\n\nThe enumerate call in the for loop will implicitly invoke next(results), which in turn will invoke _f.result() on the (internal) _f future representing the first call, loiter(0). The result method will block until the future is done, therefore each iteration in this loop will have to wait for the next result to be ready.\n\nExperimenting with Executor.map\n\n|\n\n759",
      "content_length": 1571,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 790,
      "content": "I encourage you to run Example 20-8 and see the display being updated incremen‐ tally. While you’re at it, play with the max_workers argument for the ThreadPoolExec utor and with the range function that produces the arguments for the executor.map call—or replace it with lists of handpicked values to create different delays.\n\nExample 20-9 shows a sample run of Example 20-8.\n\nExample 20-9. Sample run of demo_executor_map.py from Example 20-8\n\n$ python3 demo_executor_map.py [15:56:50] Script starting. [15:56:50] loiter(0): doing nothing for 0s... [15:56:50] loiter(0): done. [15:56:50] loiter(1): doing nothing for 1s... [15:56:50] loiter(2): doing nothing for 2s... [15:56:50] results: <generator object result_iterator at 0x106517168> [15:56:50] loiter(3): doing nothing for 3s... [15:56:50] Waiting for individual results: [15:56:50] result 0: 0 [15:56:51] loiter(1): done. [15:56:51] loiter(4): doing nothing for 4s... [15:56:51] result 1: 10 [15:56:52] loiter(2): done. [15:56:52] result 2: 20 [15:56:53] loiter(3): done. [15:56:53] result 3: 30 [15:56:55] loiter(4): done. [15:56:55] result 4: 40\n\nThis run started at 15:56:50.\n\nThe first thread executes loiter(0), so it will sleep for 0s and return even before the second thread has a chance to start, but YMMV.6\n\nloiter(1) and loiter(2) start immediately (because the thread pool has three workers, it can run three functions concurrently).\n\nThis shows that the results returned by executor.map is a generator; nothing so far would block, regardless of the number of tasks and the max_workers setting.\n\n6 Your mileage may vary: with threads, you never know the exact sequencing of events that should happen\n\nnearly at the same time; it’s possible that, in another machine, you see loiter(1) starting before loiter(0) finishes, particularly because sleep always releases the GIL, so Python may switch to another thread even if you sleep for 0s.\n\n760\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 1947,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 791,
      "content": "Because loiter(0) is done, the first worker is now available to start the fourth thread for loiter(3).\n\nThis is where execution may block, depending on the parameters given to the loiter calls: the __next__ method of the results generator must wait until the first future is complete. In this case, it won’t block because the call to loiter(0) finished before this loop started. Note that everything up to this point happened within the same second: 15:56:50.\n\nloiter(1) is done one second later, at 15:56:51. The thread is freed to start loiter(4).\n\nThe result of loiter(1) is shown: 10. Now the for loop will block waiting for the result of loiter(2).\n\nThe pattern repeats: loiter(2) is done, its result is shown; same with loiter(3).\n\nThere is a 2s delay until loiter(4) is done, because it started at 15:56:51 and did nothing for 4s.\n\nThe Executor.map function is easy to use, but often it’s preferable to get the results as they are ready, regardless of the order they were submitted. To do that, we need a combination of the Executor.submit method and the futures.as_completed func‐ tion, as we saw in Example 20-4. We’ll come back to this technique in “Using futures.as_completed” on page 769.\n\nThe combination of executor.submit and futures.as_completed is more flexible than executor.map because you can submit different callables and arguments, while executor.map is designed to run the same callable on the different arguments. In addition, the set of futures you pass to futures.as_completed may come from more than one executor—perhaps some were created by a ThreadPoolExecutor from a ProcessPoolExecutor.\n\ninstance, while others are\n\nIn the next section, we will resume the flag download examples with new require‐ ments that will force us to iterate over the results of futures.as_completed instead of using executor.map.\n\nExperimenting with Executor.map\n\n|\n\n761",
      "content_length": 1877,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 792,
      "content": "Downloads with Progress Display and Error Handling As mentioned, the scripts in “Concurrent Web Downloads” on page 744 have no error handling to make them easier to read and to contrast the structure of the three approaches: sequential, threaded, and asynchronous.\n\nIn order to test the handling of a variety of error conditions, I created the flags2 examples:\n\nflags2_common.py\n\nThis module contains common functions and settings used by all flags2 exam‐ ples, including a main function, which takes care of command-line parsing, tim‐ ing, and reporting results. That is really support code, not directly relevant to the subject of this chapter, so I will not list the source code here, but you can read it in the fluentpython/example-code-2e repository: 20-executors/getflags/ flags2_common.py.\n\nflags2_sequential.py\n\nA sequential HTTP client with proper error handling and progress bar display. Its download_one function is also used by flags2_threadpool.py.\n\nflags2_threadpool.py\n\nConcurrent HTTP client based on futures.ThreadPoolExecutor to demon‐ strate error handling and integration of the progress bar.\n\nflags2_asyncio.py\n\nSame functionality as the previous example, but implemented with asyncio and httpx. This will be covered in “Enhancing the asyncio Downloader” on page 787, in Chapter 21.\n\nBe Careful when Testing Concurrent Clients\n\nWhen testing concurrent HTTP clients on public web servers, you may generate many requests per second, and that’s how denial-of- service (DoS) attacks are made. Carefully throttle your clients when hitting public servers. For testing, set up a local HTTP server. See “Setting Up Test Servers” on page 765 for instructions.\n\nThe most visible feature of the flags2 examples is that they have an animated, text- mode progress bar implemented with the tqdm package. I posted a 108s video on YouTube to show the progress bar and contrast the speed of the three flags2 scripts. In the video, I start with the sequential download, but I interrupt it after 32s because it was going to take more than 5 minutes to hit on 676 URLs and get 194 flags. I then run the threaded and asyncio scripts three times each, and every time they complete\n\n762\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 2221,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 793,
      "content": "the job in 6s or less (i.e., more than 60 times faster). Figure 20-1 shows two screen‐ shots: during and after running flags2_threadpool.py.\n\nFigure 20-1. Top-left: flags2_threadpool.py running with live progress bar generated by tqdm; bottom-right: same terminal window after the script is finished.\n\nThe simplest tqdm example appears in an animated .gif in the project’s README.md. If you type the following code in the Python console after installing the tqdm pack‐ age, you’ll see an animated progress bar where the comment is:\n\n>>> import time >>> from tqdm import tqdm >>> for i in tqdm(range(1000)): ... time.sleep(.01) ... >>> # -> progress bar will appear here <-\n\nBesides the neat effect, the tqdm function is also interesting conceptually: it consumes any iterable and produces an iterator which, while it’s consumed, displays the pro‐ gress bar and estimates the remaining time to complete all iterations. To compute that estimate, tqdm needs to get an iterable that has a len, or additionally receive the total= argument with the expected number of items. Integrating tqdm with our flags2 examples provides an opportunity to look deeper into how the concurrent scripts actually work, by forcing us to use the futures.as_completed and the asyn cio.as_completed functions so that tqdm can display progress as each future is completed.\n\nThe other feature of the flags2 example is a command-line interface. All three scripts accept the same options, and you can see them by running any of the scripts with the -h option. Example 20-10 shows the help text.\n\nDownloads with Progress Display and Error Handling\n\n|\n\n763",
      "content_length": 1624,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 794,
      "content": "Example 20-10. Help screen for the scripts in the flags2 series\n\n$ python3 flags2_threadpool.py -h usage: flags2_threadpool.py [-h] [-a] [-e] [-l N] [-m CONCURRENT] [-s LABEL] [-v] [CC [CC ...]]\n\nDownload flags for country codes. Default: top 20 countries by population.\n\npositional arguments: CC country code or 1st letter (eg. B for BA...BZ)\n\noptional arguments: -h, --help show this help message and exit -a, --all get all available flags (AD to ZW) -e, --every get flags for every possible code (AA...ZZ) -l N, --limit N limit to N first codes -m CONCURRENT, --max_req CONCURRENT maximum concurrent requests (default=30) -s LABEL, --server LABEL Server to hit; one of DELAY, ERROR, LOCAL, REMOTE (default=LOCAL) -v, --verbose output detailed progress info\n\nAll arguments are optional. But the -s/--server is essential for testing: it lets you choose which HTTP server and port will be used in the test. Pass one of these case- insensitive labels to determine where the script will look for the flags:\n\nLOCAL\n\nUse http://localhost:8000/flags; this is the default. You should configure a local HTTP server to answer at port 8000. See the following note for instructions.\n\nREMOTE\n\nUse http://fluentpython.com/data/flags; that is a public website owned by me, hosted on a shared server. Please do not pound it with too many concurrent requests. The fluentpython.com domain is handled by the Cloudflare CDN (Con‐ tent Delivery Network) so you may notice that the first downloads are slower, but they get faster when the CDN cache warms up.\n\nDELAY\n\nUse http://localhost:8001/flags; a server delaying HTTP responses should be listening to port 8001. I wrote slow_server.py to make it easier to experiment. You’ll find it in the 20-futures/getflags/ directory of the Fluent Python code repos‐ itory. See the following note for instructions.\n\nERROR\n\nUse http://localhost:8002/flags; a server returning some HTTP errors should be listening on port 8002. Instructions are next.\n\n764\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 2012,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 795,
      "content": "Setting Up Test Servers\n\nIf you don’t have a local HTTP server for testing, I wrote setup instructions using only Python ≥ 3.9 (no external libraries) in 20- fluentpython/example- executors/getflags/README.adoc code-2e repository. In short, README.adoc describes how to use:\n\nin\n\nthe\n\npython3 -m http.server\n\nThe LOCAL server on port 8000\n\npython3 slow_server.py\n\nThe DELAY server on port 8001, which adds a random delay of .5s to 5s before each response\n\npython3 slow_server.py 8002 --error-rate .25\n\nThe ERROR server on port 8002, which in addition to the ran‐ dom delay, has a 25% chance of returning a “418 I’m a teapot” error response\n\nBy default, each flags2*.py script will fetch the flags of the 20 most populous countries from the LOCAL server (http://localhost:8000/flags) using a default number of concurrent connections, which varies from script to script. Example 20-11 shows a sample run of the flags2_sequential.py script using all defaults. To run it, you need a local server, as explained in “Be Careful when Testing Concurrent Clients” on page 762.\n\nExample 20-11. Running flags2_sequential.py with all defaults: LOCAL site, top 20 flags, 1 concurrent connection\n\n$ python3 flags2_sequential.py LOCAL site: http://localhost:8000/flags Searching for 20 flags: from BD to VN 1 concurrent connection will be used. -------------------- 20 flags downloaded. Elapsed time: 0.10s\n\nYou can select which flags will be downloaded in several ways. Example 20-12 shows how to download all flags with country codes starting with the letters A, B, or C.\n\nExample 20-12. Run flags2_threadpool.py to fetch all flags with country codes prefixes A, B, or C from the DELAY server\n\n$ python3 flags2_threadpool.py -s DELAY a b c DELAY site: http://localhost:8001/flags Searching for 78 flags: from AA to CZ 30 concurrent connections will be used.\n\nDownloads with Progress Display and Error Handling\n\n|\n\n765",
      "content_length": 1903,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 796,
      "content": "-------------------- 43 flags downloaded. 35 not found. Elapsed time: 1.72s\n\nRegardless of how the country codes are selected, the number of flags to fetch can be limited with the -l/--limit option. Example 20-13 demonstrates how to run exactly 100 requests, combining the -a option to get all flags with -l 100.\n\nExample 20-13. Run flags2_asyncio.py to get 100 flags (-al 100) from the ERROR server, using 100 concurrent requests (-m 100)\n\n$ python3 flags2_asyncio.py -s ERROR -al 100 -m 100 ERROR site: http://localhost:8002/flags Searching for 100 flags: from AD to LK 100 concurrent connections will be used. -------------------- 73 flags downloaded. 27 errors. Elapsed time: 0.64s\n\nThat’s the user interface of the flags2 examples. Let’s see how they are implemented.\n\nError Handling in the flags2 Examples The common strategy in all three examples to deal with HTTP errors is that 404 errors (not found) are handled by the function in charge of downloading a single file (download_one). Any other exception propagates to be handled by the down load_many function or the supervisor coroutine—in the asyncio example.\n\nOnce more, we’ll start by studying the sequential code, which is easier to follow—and mostly reused by the thread pool script. Example 20-14 shows the functions that per‐ form the actual downloads in the flags2_sequential.py and flags2_threadpool.py scripts.\n\nExample 20-14. flags2_sequential.py: basic functions in charge of downloading; both are reused in flags2_threadpool.py\n\nfrom collections import Counter from http import HTTPStatus\n\nimport httpx import tqdm # type: ignore\n\nfrom flags2_common import main, save_flag, DownloadStatus\n\nDEFAULT_CONCUR_REQ = 1 MAX_CONCUR_REQ = 1\n\n766\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 1746,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 797,
      "content": "def get_flag(base_url: str, cc: str) -> bytes: url = f'{base_url}/{cc}/{cc}.gif'.lower() resp = httpx.get(url, timeout=3.1, follow_redirects=True) resp.raise_for_status() return resp.content\n\ndef download_one(cc: str, base_url: str, verbose: bool = False) -> DownloadStatus: try: image = get_flag(base_url, cc) except httpx.HTTPStatusError as exc: res = exc.response if res.status_code == HTTPStatus.NOT_FOUND: status = DownloadStatus.NOT_FOUND msg = f'not found: {res.url}' else: raise else: save_flag(image, f'{cc}.gif') status = DownloadStatus.OK msg = 'OK'\n\nif verbose: print(cc, msg)\n\nreturn status\n\nImport the tqdm progress-bar display library, and tell Mypy to skip checking it.7\n\nImport a couple of functions and an Enum from the flags2_common module.\n\nRaises HTTPStetusError if the HTTP status code is not in range(200, 300).\n\ndownload_one catches HTTPStatusError to handle HTTP code 404 specifically…\n\n…by setting its local status to DownloadStatus.NOT_FOUND; DownloadStatus is an Enum imported from flags2_common.py.\n\nAny other HTTPStatusError exception is re-raised to propagate to the caller.\n\nIf the -v/--verbose command-line option is set, the country code and status message are displayed; this is how you’ll see progress in verbose mode.\n\n7 As of September 2021, there are no type hints in the current release of tdqm. That’s OK. The world will not\n\nend because of that. Thank Guido for optional typing!\n\nDownloads with Progress Display and Error Handling\n\n|\n\n767",
      "content_length": 1480,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 798,
      "content": "Example 20-15 lists the sequential version of the download_many function. This code is straightforward, but it’s worth studying to contrast with the concurrent versions coming up. Focus on how it reports progress, handles errors, and tallies downloads.\n\nExample 20-15. flags2_sequential.py: the sequential implementation of download_many\n\ndef download_many(cc_list: list[str], base_url: str, verbose: bool, _unused_concur_req: int) -> Counter[DownloadStatus]: counter: Counter[DownloadStatus] = Counter() cc_iter = sorted(cc_list) if not verbose: cc_iter = tqdm.tqdm(cc_iter) for cc in cc_iter: try: status = download_one(cc, base_url, verbose) except httpx.HTTPStatusError as exc: error_msg = 'HTTP error {resp.status_code} - {resp.reason_phrase}' error_msg = error_msg.format(resp=exc.response) except httpx.RequestError as exc: error_msg = f'{exc} {type(exc)}'.strip() except KeyboardInterrupt: break else: error_msg = ''\n\nif error_msg: status = DownloadStatus.ERROR counter[status] += 1 if verbose and error_msg: print(f'{cc} error: {error_msg}')\n\nreturn counter\n\nThis Counter will tally the different download outcomes: DownloadStatus.OK, DownloadStatus.NOT_FOUND, or DownloadStatus.ERROR.\n\ncc_iter holds the list of the country codes received as arguments, ordered alphabetically.\n\nIf not running in verbose mode, cc_iter is passed to tqdm, which returns an iter‐ ator yielding the items in cc_iter while also animating the progress bar.\n\nMake successive calls to download_one.\n\n768\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 1525,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 799,
      "content": "HTTP status code exceptions raised by get_flag and not handled by down load_one are handled here.\n\nOther network-related exceptions are handled here. Any other exception will abort the script, because the flags2_common.main function that calls down load_many has no try/except.\n\nExit the loop if the user hits Ctrl-C.\n\nIf no exception escaped download_one, clear the error message.\n\nIf there was an error, set the local status accordingly.\n\nIncrement the counter for that status.\n\nIn verbose mode, display the error message for the current country code, if any.\n\nReturn counter so that main can display the numbers in the final report.\n\nWe’ll now study the refactored thread pool example, flags2_threadpool.py.\n\nUsing futures.as_completed In order to integrate the tqdm progress bar and handle errors on each request, flags2_threadpool.py script uses futures.ThreadPoolExecutor with the the futures.as_completed function we’ve already seen. Example 20-16 is the full listing of flags2_threadpool.py. Only the download_many function is implemented; the other functions are reused from flags2_common.py and flags2_sequential.py.\n\nExample 20-16. flags2_threadpool.py: full listing\n\nfrom collections import Counter from concurrent.futures import ThreadPoolExecutor, as_completed\n\nimport httpx import tqdm # type: ignore\n\nfrom flags2_common import main, DownloadStatus from flags2_sequential import download_one\n\nDEFAULT_CONCUR_REQ = 30 MAX_CONCUR_REQ = 1000\n\ndef download_many(cc_list: list[str], base_url: str,\n\nDownloads with Progress Display and Error Handling\n\n|\n\n769",
      "content_length": 1567,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 800,
      "content": "verbose: bool, concur_req: int) -> Counter[DownloadStatus]: counter: Counter[DownloadStatus] = Counter() with ThreadPoolExecutor(max_workers=concur_req) as executor: to_do_map = {} for cc in sorted(cc_list): future = executor.submit(download_one, cc, base_url, verbose) to_do_map[future] = cc done_iter = as_completed(to_do_map) if not verbose: done_iter = tqdm.tqdm(done_iter, total=len(cc_list)) for future in done_iter: try: status = future.result() except httpx.HTTPStatusError as exc: error_msg = 'HTTP error {resp.status_code} - {resp.reason_phrase}' error_msg = error_msg.format(resp=exc.response) except httpx.RequestError as exc: error_msg = f'{exc} {type(exc)}'.strip() except KeyboardInterrupt: break else: error_msg = ''\n\nif error_msg: status = DownloadStatus.ERROR counter[status] += 1 if verbose and error_msg: cc = to_do_map[future] print(f'{cc} error: {error_msg}')\n\nreturn counter\n\nif __name__ == '__main__': main(download_many, DEFAULT_CONCUR_REQ, MAX_CONCUR_REQ)\n\nReuse download_one from flags2_sequential (Example 20-14).\n\nIf the -m/--max_req command-line option is not given, this will be the maxi‐ mum number of concurrent requests, implemented as the size of the thread pool; the actual number may be smaller if the number of flags to download is smaller.\n\nMAX_CONCUR_REQ caps the maximum number of concurrent requests regardless of the number of flags to download or the -m/--max_req command-line option. It’s a safety precaution to avoid launching too many threads with their significant memory overhead.\n\n770\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 1571,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 801,
      "content": "Create the executor with max_workers set to concur_req, computed by the main function as the smaller of: MAX_CONCUR_REQ, the length of cc_list, or the value of the -m/--max_req command-line option. This avoids creating more threads than necessary.\n\nThis dict will map each Future instance—representing one download—with the respective country code for error reporting.\n\nIterate over the list of country codes in alphabetical order. The order of the results will depend on the timing of the HTTP responses more than anything, but if the size of the thread pool (given by concur_req) is much smaller than len(cc_list), you may notice the downloads batched alphabetically.\n\nEach call to executor.submit schedules the execution of one callable and returns a Future instance. The first argument is the callable, the rest are the arguments it will receive.\n\nStore the future and the country code in the dict.\n\nfutures.as_completed returns an iterator that yields futures as each task is done.\n\nIf not in verbose mode, wrap the result of as_completed with the tqdm function to display the progress bar; because done_iter has no len, we must tell tqdm what is the expected number of items as the total= argument, so tqdm can esti‐ mate the work remaining.\n\nIterate over the futures as they are completed.\n\nCalling the result method on a future either returns the value returned by the callable, or raises whatever exception was caught when the callable was executed. This method may block waiting for a resolution, but not in this example because as_completed only returns futures that are done.\n\nHandle the potential exceptions; the rest of this function is identical to the sequential download_many in Example 20-15), except for the next callout.\n\nTo provide context for the error message, retrieve the country code from the to_do_map using the current future as key. This was not necessary in the sequential version because we were iterating over the list of country codes, so we knew the current cc; here we are iterating over the futures.\n\nDownloads with Progress Display and Error Handling\n\n|\n\n771",
      "content_length": 2095,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 802,
      "content": "Example 20-16 uses an is very useful with idiom futures.as_completed: building a dict to map each future to other data that may be useful when the future is completed. Here the to_do_map maps each future to the country code assigned to it. This makes it easy to do follow-up processing with the result of the futures, despite the fact that they are produced out of order.\n\nthat\n\nPython threads are well suited for I/O-intensive applications, and the concur rent.futures package makes it relatively simple to use for certain use cases. With ProcessPoolExecutor, you can also solve CPU-intensive problems on multiple cores —if the computations are “embarrassingly parallel”. This concludes our basic intro‐ duction to concurrent.futures.\n\nChapter Summary We started the chapter by comparing two concurrent HTTP clients with a sequential one, demonstrating that the concurrent solutions show significant performance gains over the sequential script.\n\nAfter studying the first example based on concurrent.futures, we took a closer look at future objects, either instances of concurrent.futures.Future or asyncio .Future, emphasizing what these classes have in common (their differences will be emphasized in Chapter 21). We saw how to create futures by calling Executor.sub mit, and iterate over completed futures with concurrent.futures.as_completed.\n\nWe then discussed the use of multiple processes with the concurrent.futures.Proc essPoolExecutor class, to go around the GIL and use multiple CPU cores to simplify the multicore prime checker we first saw in Chapter 19.\n\nIn the following section, we saw how the concurrent.futures.ThreadPoolExecutor works with a didactic example, launching tasks that did nothing for a few seconds, except for displaying their status with a timestamp.\n\nNext we went back to the flag downloading examples. Enhancing them with a pro‐ gress bar and proper error handling prompted further exploration of the future.as_completed generator function, showing a common pattern: storing futures in a dict to link further information to them when submitting, so that we can use that information when the future comes out of the as_completed iterator.\n\nFurther Reading The concurrent.futures package was contributed by Brian Quinlan, who presented it in a great talk titled “The Future Is Soon!” at PyCon Australia 2010. Quinlan’s talk has no slides; he shows what the library does by typing code directly in the Python\n\n772\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 2483,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 803,
      "content": "console. As a motivating example, the presentation features a short video with XKCD cartoonist/programmer Randall Munroe making an unintended DoS attack on Goo‐ gle Maps to build a colored map of driving times around his city. The formal intro‐ duction to the library is PEP 3148 - futures - execute computations asynchronously. In the PEP, Quinlan wrote that the concurrent.futures library was “heavily influ‐ enced by the Java java.util.concurrent package.”\n\nFor additional resources covering concurrent.futures, please see Chapter 19. All the references that cover Python’s threading and multiprocessing in “Concurrency with Threads and Processes” on page 734 also cover concurrent.futures.\n\nSoapbox\n\nThread Avoidance\n\nConcurrency: one of the most difficult topics in computer science (usually best avoided).\n\n—David Beazley, Python instructor and mad scientist8\n\nI agree with the apparently contradictory quotes by David Beazley and Michele Sim‐ ionato at the start of this chapter.\n\nI attended an undergraduate course about concurrency. All we did was POSIX threads programming. What I learned: I don’t want to manage threads and locks myself, for the same reason that I don’t want to manage memory allocation and deal‐ location. Those jobs are best carried out by the systems programmers who have the know-how, the inclination, and the time to get them right—hopefully. I am paid to develop applications, not operating systems. I don’t need all the fine-grained control of threads, locks, malloc, and free—see “C dynamic memory allocation”.\n\nThat’s why I think the concurrent.futures package is interesting: it treats threads, processes, and queues as infrastructure at your service, not something you have to deal with directly. Of course, it’s designed with simple jobs in mind, the so-called embarrassingly parallel problems. But that’s a large slice of the concurrency problems we face when writing applications—as opposed to operating systems or database servers, as Simionato points out in that quote.\n\nFor “nonembarrassing” concurrency problems, threads and locks are not the answer either. Threads will never disappear at the OS level, but every programming language I’ve found exciting in the last several years provides higher-level, concurrency abstractions that are easier to use correctly, as the excellent Seven Concurrency Models in Seven Weeks book by Paul Butcher demonstrates. Go, Elixir, and Clojure are\n\n8 Slide #9 from “A Curious Course on Coroutines and Concurrency” tutorial presented at PyCon 2009.\n\nFurther Reading\n\n|\n\n773",
      "content_length": 2553,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 804,
      "content": "among them. Erlang—the implementation language of Elixir—is a prime example of a language designed from the ground up with concurrency in mind. Erlang doesn’t excite me for a simple reason: I find its syntax ugly. Python spoiled me that way.\n\nJosé Valim, previously a Ruby on Rails core contributor, designed Elixir with a pleas‐ ant, modern syntax. Like Lisp and Clojure, Elixir implements syntactic macros. That’s a double-edged sword. Syntactic macros enable powerful DSLs, but the proliferation of sublanguages can lead to incompatible codebases and community fragmentation. Lisp drowned in a flood of macros, with each Lisp shop using its own arcane dialect. Standardizing around Common Lisp resulted in a bloated language. I hope José Valim can inspire the Elixir community to avoid a similar outcome. So far, it’s look‐ ing good. The Ecto database wrapper and query generator is a joy to use: a great example of using macros to create a flexible yet user-friendly DSL—Domain-Specific Language—for interacting with relational and nonrelational databases.\n\nLike Elixir, Go is a modern language with fresh ideas. But, in some regards, it’s a con‐ servative language, compared to Elixir. Go doesn’t have macros, and its syntax is sim‐ pler than Python’s. Go doesn’t support inheritance or operator overloading, and it offers fewer opportunities for metaprogramming than Python. These limitations are considered features. They lead to more predictable behavior and performance. That’s a big plus in the highly concurrent, mission-critical settings where Go aims to replace C++, Java, and Python.\n\nWhile Elixir and Go are direct competitors in the high-concurrency space, their design philosophies appeal to different crowds. Both are likely to thrive. But in the history of programming languages, the conservative ones tend to attract more coders.\n\n774\n\n|\n\nChapter 20: Concurrent Executors",
      "content_length": 1891,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 805,
      "content": "CHAPTER 21 Asynchronous Programming\n\nThe problem with normal approaches to asynchronous programming is that they’re all-or-nothing propositions. You rewrite all your code so none of it blocks or you’re just wasting your time. Alvaro Videla and Jason J. W. Williams, RabbitMQ in Action1\n\nThis chapter addresses three major topics that are closely related:\n\nPython’s async def, await, async with, and async for constructs\n\nObjects supporting those constructs: native coroutines and asynchronous var‐ iants of context managers, iterables, generators, and comprehensions\n\nasyncio and other asynchronous libraries\n\nThis chapter builds on the ideas of iterables and generators (Chapter 17, in particular “Classic Coroutines” on page 641), context managers (Chapter 18), and general con‐ cepts of concurrent programming (Chapter 19).\n\nWe’ll study concurrent HTTP clients similar to the ones we saw in Chapter 20, rewritten with native coroutines and asynchronous context managers, using the same HTTPX library as before, but now through its asynchronous API. We’ll also see how to avoid blocking the event loop by delegating slow operations to a thread or process executor.\n\nAfter the HTTP client examples, we’ll see two simple asynchronous server-side appli‐ cations, one of them using the increasingly popular FastAPI framework. Then we’ll cover other language constructs enabled by the async/await keywords:\n\n1 Videla & Williams, RabbitMQ in Action (Manning), Chapter 4, “Solving Problems with Rabbit: coding and\n\npatterns,” p. 61.\n\n775",
      "content_length": 1532,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 806,
      "content": "asynchronous generator functions, asynchronous comprehensions, and asynchro‐ nous generator expressions. To emphasize the fact that those language features are not tied to asyncio, we’ll see one example rewritten to use Curio—the elegant and innovative asynchronous framework invented by David Beazley.\n\nTo wrap up the chapter, I wrote a brief section on the advantages and pitfalls of asyn‐ chronous programming.\n\nThat’s a lot of ground to cover. We only have space for basic examples, but they will illustrate the most important features of each idea.\n\nThe asyncio documentation is much better after Yury Selivanov2 reorganized it, separating the few functions useful to application developers from the low-level API for creators of packages like web frameworks and database drivers.\n\nFor book-length coverage of asyncio, I recommend Using Asyncio in Python by Caleb Hattingh (O’Reilly). Full disclosure: Caleb is one of the tech reviewers of this book.\n\nWhat’s New in This Chapter When I wrote the first edition of Fluent Python, the asyncio library was provisional and the async/await keywords did not exist. Therefore, I had to update all examples in this chapter. I also created new examples: domain probing scripts, a FastAPI web service, and experiments with Python’s new asynchronous console mode.\n\nNew sections cover language features that did not exist at the time, such as native coroutines, async with, async for, and the objects that support those constructs.\n\nThe ideas in “How Async Works and How It Doesn’t” on page 825 reflect hard- earned lessons that I consider essential reading for anyone using asynchronous pro‐ gramming. They may save you a lot of trouble—whether you’re using Python or Node.js.\n\nFinally, I removed several paragraphs about asyncio.Futures, which is now consid‐ ered part of the low-level asyncio APIs.\n\n2 Selivanov implemented async/await in Python, and wrote the related PEPs 492, 525, and 530.\n\n776\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1983,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 807,
      "content": "A Few Definitions At the start of “Classic Coroutines” on page 641, we saw that Python 3.5 and later offer three kinds of coroutines:\n\nNative coroutine\n\nA coroutine function defined with async def. You can delegate from a native coroutine to another native coroutine using the await keyword, similar to how classic coroutines use yield from. The async def statement always defines a native coroutine, even if the await keyword is not used in its body. The await keyword cannot be used outside of a native coroutine.3\n\nClassic coroutine\n\nA generator function that consumes data sent to it via my_coro.send(data) calls, and reads that data by using yield in an expression. Classic coroutines can dele‐ gate to other classic coroutines using yield from. Classic coroutines cannot be driven by await, and are no longer supported by asyncio.\n\nGenerator-based coroutine\n\nA generator function decorated with @types.coroutine—introduced in Python 3.5. That decorator makes the generator compatible with the new await keyword.\n\nIn this chapter, we focus on native coroutines as well as asynchronous generators:\n\nAsynchronous generator\n\nA generator function defined with async def and using yield in its body. It returns an asynchronous generator object that provides __anext__, a coroutine method to retrieve the next item.\n\n@asyncio.coroutine has No Future4\n\nThe @asyncio.coroutine decorator for classic coroutines and generator-based coroutines was deprecated in Python 3.8 and is scheduled for removal in Python 3.11, according to Issue 43216. In contrast, @types.coroutine should remain, per Issue 36921. It is no longer supported by asyncio, but is used in low-level code in the Curio and Trio asynchronous frameworks.\n\n3 There is one exception to this rule: if you run Python with the -m asyncio option, you can use await directly at the >>> prompt to drive a native coroutine. This is explained in “Experimenting with Python’s async con‐ sole” on page 812.\n\n4 Sorry, I could not resist it.\n\nA Few Definitions\n\n|\n\n777",
      "content_length": 2014,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 808,
      "content": "An asyncio Example: Probing Domains Imagine you are about to start a new blog on Python, and you plan to register a domain using a Python keyword and the .DEV suffix—for example: AWAIT.DEV. Example 21-1 is a script using asyncio to check several domains concurrently. This is the output it produces:\n\n$ python3 blogdom.py with.dev + elif.dev + def.dev from.dev else.dev or.dev if.dev del.dev + as.dev none.dev pass.dev true.dev + in.dev + for.dev + is.dev + and.dev + try.dev + not.dev\n\nNote that the domains appear unordered. If you run the script, you’ll see them dis‐ played one after the other, with varying delays. The + sign indicates your machine was able to resolve the domain via DNS. Otherwise, the domain did not resolve and may be available.5\n\nIn blogdom.py, the DNS probing is done via native coroutine objects. Because the asynchronous operations are interleaved, the time needed to check the 18 domains is much less than checking them sequentially. In fact, the total time is practically the same as the time for the single slowest DNS response, instead of the sum of the times of all responses.\n\nExample 21-1 shows the code for blogdom.py.\n\nExample 21-1. blogdom.py: search for domains for a Python blog\n\n#!/usr/bin/env python3 import asyncio import socket\n\n5 true.dev is available for USD 360/year as I write this. I see that for.dev is registered, but has no DNS config‐\n\nured.\n\n778\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1441,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 809,
      "content": "from keyword import kwlist\n\nMAX_KEYWORD_LEN = 4\n\nasync def probe(domain: str) -> tuple[str, bool]: loop = asyncio.get_running_loop() try: await loop.getaddrinfo(domain, None) except socket.gaierror: return (domain, False) return (domain, True)\n\nasync def main() -> None: names = (kw for kw in kwlist if len(kw) <= MAX_KEYWORD_LEN) domains = (f'{name}.dev'.lower() for name in names) coros = [probe(domain) for domain in domains] for coro in asyncio.as_completed(coros): domain, found = await coro mark = '+' if found else ' ' print(f'{mark} {domain}')\n\nif __name__ == '__main__': asyncio.run(main())\n\nSet maximum length of keyword for domains, because shorter is better.\n\nprobe returns a tuple with the domain name and a boolean; True means the domain resolved. Returning the domain name will make it easier to display the results.\n\nGet a reference to the asyncio event loop, so we can use it next.\n\nThe loop.getaddrinfo(…) coroutine-method returns a five-part tuple of param‐ eters to connect to the given address using a socket. In this example, we don’t need the result. If we got it, the domain resolves; otherwise, it doesn’t.\n\nmain must be a coroutine, so that we can use await in it.\n\nGenerator to yield Python keywords with length up to MAX_KEYWORD_LEN.\n\nGenerator to yield domain names with the .dev suffix.\n\nBuild a list of coroutine objects by invoking the probe coroutine with each domain argument.\n\nAn asyncio Example: Probing Domains\n\n|\n\n779",
      "content_length": 1455,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 810,
      "content": "asyncio.as_completed is a generator that yields coroutines that return the results of the coroutines passed to it in the order they are completed—not the order they were submitted. It’s similar to futures.as_completed, which we saw in Chapter 20, Example 20-4.\n\nAt this point, we know the coroutine is done because that’s how as_completed works. Therefore, the await expression will not block but we need it to get the result from coro. If coro raised an unhandled exception, it would be re-raised here.\n\nasyncio.run starts the event loop and returns only when the event loop exits. This is a common pattern for scripts that use asyncio: implement main as a coroutine, and drive it with asyncio.run inside the if __name__ == '__main__': block.\n\nThe asyncio.get_running_loop function was added in Python 3.7 for use inside coroutines, as shown in probe. If there’s no running loop, asyncio.get_running_loop raises RuntimeError. Its imple‐ mentation is simpler and faster than asyncio.get_event_loop, which may start an event loop if necessary. Since Python 3.10, asyn cio.get_event_loop is deprecated and will eventually become an alias to asyncio.get_running_loop.\n\nGuido’s Trick to Read Asynchronous Code There are a lot of new concepts to grasp in asyncio, but the overall logic of Example 21-1 is easy to follow if you employ a trick suggested by Guido van Rossum himself: squint and pretend the async and await keywords are not there. If you do that, you’ll realize that coroutines read like plain old sequential functions.\n\nFor example, imagine that the body of this coroutine…\n\nasync def probe(domain: str) -> tuple[str, bool]: loop = asyncio.get_running_loop() try: await loop.getaddrinfo(domain, None) except socket.gaierror: return (domain, False) return (domain, True)\n\n…works like the following function, except that it magically never blocks:\n\ndef probe(domain: str) -> tuple[str, bool]: # no async loop = asyncio.get_running_loop() try: loop.getaddrinfo(domain, None) # no await\n\n780\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 2037,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 811,
      "content": "except socket.gaierror: return (domain, False) return (domain, True)\n\nUsing the syntax await loop.getaddrinfo(...) avoids blocking because await sus‐ pends the current coroutine object. For example, during the execution of the probe('if.dev') coroutine, a new coroutine object is created by getad drinfo('if.dev', None). Awaiting it starts the low-level addrinfo query and yields control back to the event loop, not to the probe(‘if.dev’) coroutine, which is sus‐ pended. The event loop can then drive other pending coroutine objects, such as probe('or.dev').\n\nWhen the event loop gets a response for the getaddrinfo('if.dev', None) query, that specific coroutine object resumes and returns control back the probe('if.dev')—which was suspended at await—and can now handle a possible exception and return the result tuple.\n\nSo far, we’ve only seen asyncio.as_completed and await applied to coroutines. But they handle any awaitable object. That concept is explained next.\n\nNew Concept: Awaitable The for keyword works with iterables. The await keyword works with awaitables.\n\nAs an end user of asyncio, these are the awaitables you will see on a daily basis:\n\nA native coroutine object, which you get by calling a native coroutine function • An asyncio.Task, which you usually get by passing a coroutine object to asyn cio.create_task()\n\nHowever, end-user code does not always need to await on a Task. We use asyn cio.create_task(one_coro()) to schedule one_coro for concurrent execution, without waiting for its return. That’s what we did with the spinner coroutine in spin‐ ner_async.py (Example 19-4). If you don’t expect to cancel the task or wait for it, there is no need to keep the Task object returned from create_task. Creating the task is enough to schedule the coroutine to run.\n\nIn contrast, we use await other_coro() to run other_coro right now and wait for its completion because we need its result before we can proceed. In spinner_async.py, the supervisor coroutine did res = await slow() to execute slow and get its result.\n\nWhen implementing asynchronous libraries or contributing to asyncio itself, you may also deal with these lower-level awaitables:\n\nNew Concept: Awaitable\n\nto\n\n|\n\n781",
      "content_length": 2205,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 812,
      "content": "An object with an __await__ method that returns an iterator; for example, an asyncio.Future instance (asyncio.Task is a subclass of asyncio.Future)\n\nObjects written\n\nthe Python/C API with a languages using tp_as_async.am_await function, returning an iterator (similar to __await__ method)\n\nin other\n\nExisting codebases may also have one additional kind of awaitable: generator-based coroutine objects—which are in the process of being deprecated.\n\nPEP 492 states that the await expression “uses the yield from implementation with an extra step of validating its argument” and “await only accepts an awaitable.” The PEP does not explain that implementation in detail, but refers to PEP 380, which introduced yield from. I posted a detailed explanation in “Classic Corou‐ tines”, section “The Meaning of yield from”, at fluentpython.com.\n\nNow let’s study the asyncio version of a script that downloads a fixed set of flag images.\n\nDownloading with asyncio and HTTPX The flags_asyncio.py script downloads a fixed set of 20 flags from fluentpython.com. We first mentioned it in “Concurrent Web Downloads” on page 744, but now we’ll study it in detail, applying the concepts we just saw.\n\nAs of Python 3.10, asyncio only supports TCP and UDP directly, and there are no asynchronous HTTP client or server packages in the standard library. I am using HTTPX in all the HTTP client examples.\n\nWe’ll explore flags_asyncio.py from the bottom up—that is, looking first at the func‐ tions that set up the action in Example 21-2.\n\nTo make the code easier to read, flags_asyncio.py has no error han‐ dling. As we introduce async/await, it’s useful to focus on the “happy path” initially, to understand how regular functions and coroutines are arranged in a program. Starting with “Enhancing the asyncio Downloader” on page 787, the examples include error handling and more features.\n\nThe flags_.py examples from this chapter and Chapter 20 share code and data, so I put them together in the example-code-2e/20- executors/getflags directory.\n\n782\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 2071,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 813,
      "content": "Example 21-2. flags_asyncio.py: startup functions\n\ndef download_many(cc_list: list[str]) -> int: return asyncio.run(supervisor(cc_list))\n\nasync def supervisor(cc_list: list[str]) -> int: async with AsyncClient() as client: to_do = [download_one(client, cc) for cc in sorted(cc_list)] res = await asyncio.gather(*to_do)\n\nreturn len(res)\n\nif __name__ == '__main__': main(download_many)\n\nThis needs to be a plain function—not a coroutine—so it can be passed to and called by the main function from the flags.py module (Example 20-2).\n\nExecute the event loop driving the supervisor(cc_list) coroutine object until it returns. This will block while the event loop runs. The result of this line is whatever supervisor returns.\n\nAsynchronous HTTP client operations in httpx are methods of AsyncClient, which is also an asynchronous context manager: a context manager with asyn‐ chronous setup and teardown methods (more about this in “Asynchronous Con‐ text Managers” on page 786).\n\nBuild a list of coroutine objects by calling the download_one coroutine once for each flag to be retrieved.\n\nWait for the asyncio.gather coroutine, which accepts one or more awaitable arguments and waits for all of them to complete, returning a list of results for the given awaitables in the order they were submitted.\n\nsupervisor returns the length of the list returned by asyncio.gather.\n\nNow let’s review the top of flags_asyncio.py (Example 21-3). I reorganized the corou‐ tines so we can read them in the order they are started by the event loop.\n\nExample 21-3. flags_asyncio.py: imports and download functions\n\nimport asyncio\n\nfrom httpx import AsyncClient\n\nfrom flags import BASE_URL, save_flag, main\n\nDownloading with asyncio and HTTPX\n\n|\n\n783",
      "content_length": 1728,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 814,
      "content": "async def download_one(client: AsyncClient, cc: str): image = await get_flag(client, cc) save_flag(image, f'{cc}.gif') print(cc, end=' ', flush=True) return cc\n\nasync def get_flag(client: AsyncClient, cc: str) -> bytes: url = f'{BASE_URL}/{cc}/{cc}.gif'.lower() resp = await client.get(url, timeout=6.1, follow_redirects=True) return resp.read()\n\nhttpx must be installed—it’s not in the standard library.\n\nReuse code from flags.py (Example 20-2).\n\ndownload_one must be a native coroutine, so it can await on get_flag—which does the HTTP request. Then it displays the code of the downloaded flag, and saves the image.\n\nget_flag needs to receive the AsyncClient to make the request.\n\nThe get method of an httpx.AsyncClient instance returns a ClientResponse object that is also an asynchronous context manager.\n\nNetwork I/O operations are implemented as coroutine methods, so they are driven asynchronously by the asyncio event loop.\n\nFor better performance, the save_flag call inside get_flag should be asynchronous, to avoid blocking the event loop. However, asyn‐ cio does not provide an asynchronous filesystem API at this time— as Node.js does.\n\n“Using asyncio.as_completed and a Thread” on page 788 will show how to delegate save_flag to a thread.\n\nYour code delegates to the httpx coroutines explicitly through await or implicitly through the special methods of the asynchronous context managers, such as Async Client and ClientResponse—as we’ll see in “Asynchronous Context Managers” on page 786.\n\nThe Secret of Native Coroutines: Humble Generators A key difference between the classic coroutine examples we saw in “Classic Corou‐ tines” on page 641 and flags_asyncio.py is that there are no visible .send() calls or\n\n784\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1767,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 815,
      "content": "yield expressions in the latter. Your code sits between the asyncio library and the asynchronous libraries you are using, such as HTTPX. This is illustrated in Figure 21-1.\n\nFigure 21-1. In an asynchronous program, a user’s function starts the event loop, sched‐ uling an initial coroutine with asyncio.run. Each user’s coroutine drives the next with an await expression, forming a channel that enables communication between a library like HTTPX and the event loop.\n\nUnder the hood, the asyncio event loop makes the .send calls that drive your corou‐ tines, and your coroutines await on other coroutines, including library coroutines. As mentioned, await borrows most of its implementation from yield from, which also makes .send calls to drive coroutines.\n\nThe await chain eventually reaches a low-level awaitable, which returns a generator that the event loop can drive in response to events such as timers or network I/O. The low-level awaitables and generators at the end of these await chains are implemented deep into the libraries, are not part of their APIs, and may be Python/C extensions.\n\nUsing functions like asyncio.gather and asyncio.create_task, you can start mul‐ tiple concurrent await channels, enabling concurrent execution of multiple I/O oper‐ ations driven by a single event loop, in a single thread.\n\nThe All-or-Nothing Problem Note that in Example 21-3, I could not reuse the get_flag function from flags.py (Example 20-2). I had to rewrite it as a coroutine to use the asynchronous API of HTTPX. For peak performance with asyncio, we must replace every function that does I/O with an asynchronous version that is activated with await or asyncio.cre ate_task, so that control is given back to the event loop while the function waits for I/O. If you can’t rewrite a blocking function as a coroutine, you should run it in a separate thread or process, as we’ll see in “Delegating Tasks to Executors” on page 797.\n\nDownloading with asyncio and HTTPX\n\n|\n\n785",
      "content_length": 1978,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 816,
      "content": "That’s why I chose the epigraph for this chapter, which includes this advice: “You rewrite all your code so none of it blocks or you’re just wasting your time.”\n\nFor the same reason, I could not reuse the download_one function from flags_thread‐ pool.py (Example 20-3) either. The code in Example 21-3 drives get_flag with await, so download_one must also be a coroutine. For each request, a download_one coroutine object is created in supervisor, and they are all driven by the asyncio.gather coroutine.\n\nlet’s study the async with statement that appeared\n\nNow (Example 21-2) and get_flag (Example 21-3).\n\nin supervisor\n\nAsynchronous Context Managers In “Context Managers and with Blocks” on page 658, we saw how an object can be used to run code before and after the body of a with block, if its class provides the __enter__ and __exit__ methods.\n\nNow, consider Example 21-4, from the asyncpg asyncio-compatible PostgreSQL driver documentation on transactions.\n\nExample 21-4. Sample code from the documentation of the asyncpg PostgreSQL driver\n\ntr = connection.transaction() await tr.start() try: await connection.execute(\"INSERT INTO mytable VALUES (1, 2, 3)\") except: await tr.rollback() raise else: await tr.commit()\n\nA database transaction is a natural fit for the context manager protocol: the transac‐ tion has to be started, data is changed with connection.execute, and then a rollback or commit must happen, depending on the outcome of the changes.\n\nIn an asynchronous driver like asyncpg, the setup and wrap-up need to be coroutines so that other operations can happen concurrently. However, the implementation of the classic with statement doesn’t support coroutines doing the work of __enter__ or __exit__.\n\nThat’s why PEP 492—Coroutines with async and await syntax introduced the async with statement, which works with asynchronous context managers: objects imple‐ menting the __aenter__ and __aexit__ methods as coroutines.\n\n786\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1984,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 817,
      "content": "With async with, Example 21-4 can be written like this other snippet from the asyncpg documentation:\n\nasync with connection.transaction(): await connection.execute(\"INSERT INTO mytable VALUES (1, 2, 3)\")\n\nIn the asyncpg.Transaction class, the __aenter__ coroutine method does await self.start(), and the __aexit__ coroutine awaits on private __rollback or __com mit coroutine methods, depending on whether an exception occurred or not. Using coroutines to implement Transaction as an asynchronous context manager allows asyncpg to handle many transactions concurrently.\n\nCaleb Hattingh on asyncpg\n\nAnother really great thing about asyncpg is that it also works around PostgreSQL’s lack of high-concurrency support (it uses one server-side process per connection) by implementing a connection pool for internal connections to Postgres itself.\n\nThis means you don’t need additional tools like pgbouncer as explained in the asyncpg documentation.6\n\nBack to flags_asyncio.py, the AsyncClient class of httpx is an asynchronous context manager, so it can use awaitables in its __aenter__ and __aexit__ special coroutine methods.\n\n“Asynchronous generators as context managers” on page 817 shows how to use Python’s contextlib to create an asynchronous context manager without having to write a class. That explanation comes later in this chapter because of a prerequisite topic: “Asynchronous Generator Functions” on page 812.\n\nWe’ll now enhance the asyncio flag download example with a progress bar, which will lead us to explore a bit more of the asyncio API.\n\nEnhancing the asyncio Downloader Recall from “Downloads with Progress Display and Error Handling” on page 762 that the flags2 set of examples share the same command-line interface, and they display a progress bar while the downloads are happening. They also include error handling.\n\n6 This tip is quoted verbatim from a comment by tech reviewer Caleb Hattingh. Thanks, Caleb!\n\nEnhancing the asyncio Downloader\n\n|\n\n787",
      "content_length": 1973,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 818,
      "content": "I encourage you to play with the flags2 examples to develop an intuition of how concurrent HTTP clients perform. Use the -h option to see the help screen in Example 20-10. Use the -a, -e, and -l command-line options to control the number of downloads, and the -m option to set the number of concurrent downloads. Run tests against the LOCAL, REMOTE, DELAY, and ERROR servers. Discover the optimum number of concurrent downloads to maximize throughput against each server. Tweak the options for the test servers, as described in “Setting Up Test Servers” on page 765.\n\nFor instance, Example 21-5 shows an attempt to get 100 flags (-al 100) from the ERROR server, using 100 concurrent requests (-m 100). The 48 errors in the result are either HTTP 418 or time-out errors—the expected (mis)behavior of the slow_server.py.\n\nExample 21-5. Running flags2_asyncio.py\n\n$ python3 flags2_asyncio.py -s ERROR -al 100 -m 100 ERROR site: http://localhost:8002/flags Searching for 100 flags: from AD to LK 100 concurrent connections will be used. 100%|█████████████████████████████████████████| 100/100 [00:03<00:00, 30.48it/s] -------------------- 52 flags downloaded. 48 errors. Elapsed time: 3.31s\n\nAct Responsibly When Testing Concurrent Clients\n\nEven if the overall download time is not much different between the threaded and asyncio HTTP clients, asyncio can send requests faster, so it’s more likely that the server will suspect a DoS attack. To really exercise these concurrent clients at full throttle, please use local HTTP servers for testing, as explained in “Setting Up Test Servers” on page 765.\n\nNow let’s see how flags2_asyncio.py is implemented.\n\nUsing asyncio.as_completed and a Thread In Example 21-3, we passed several coroutines to asyncio.gather, which returns a list with results of the coroutines in the order they were submitted. This means that asyncio.gather can only return when all the awaitables are done. However, to update a progress bar, we need to get results as they are done.\n\n788\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 2044,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 819,
      "content": "Fortunately, there is an asyncio equivalent of the as_completed generator function we used in the thread pool example with the progress bar (Example 20-16).\n\nExample 21-6 shows the top of the flags2_asyncio.py script where the get_flag and download_one coroutines are defined. Example 21-7 lists the rest of the source, with supervisor and download_many. This script is longer than flags_asyncio.py because of error handling.\n\nExample 21-6. flags2_asyncio.py: top portion of the script; remaining code is in Example 21-7\n\nimport asyncio from collections import Counter from http import HTTPStatus from pathlib import Path\n\nimport httpx import tqdm # type: ignore\n\nfrom flags2_common import main, DownloadStatus, save_flag\n\n# low concurrency default to avoid errors from remote site, # such as 503 - Service Temporarily Unavailable DEFAULT_CONCUR_REQ = 5 MAX_CONCUR_REQ = 1000\n\nasync def get_flag(client: httpx.AsyncClient, base_url: str, cc: str) -> bytes: url = f'{base_url}/{cc}/{cc}.gif'.lower() resp = await client.get(url, timeout=3.1, follow_redirects=True) resp.raise_for_status() return resp.content\n\nasync def download_one(client: httpx.AsyncClient, cc: str, base_url: str, semaphore: asyncio.Semaphore, verbose: bool) -> DownloadStatus: try: async with semaphore: image = await get_flag(client, base_url, cc) except httpx.HTTPStatusError as exc: res = exc.response if res.status_code == HTTPStatus.NOT_FOUND: status = DownloadStatus.NOT_FOUND msg = f'not found: {res.url}' else: raise else:\n\nEnhancing the asyncio Downloader\n\n|\n\n789",
      "content_length": 1542,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 820,
      "content": "await asyncio.to_thread(save_flag, image, f'{cc}.gif') status = DownloadStatus.OK msg = 'OK' if verbose and msg: print(cc, msg) return status\n\nget_flag is very similar to the sequential version in Example 20-14. First differ‐ ence: it requires the client parameter.\n\nSecond and third differences: .get is an AsyncClient method, and it’s a corou‐ tine, so we need to await it.\n\nUse the semaphore as an asynchronous context manager so that the program as a whole is not blocked; only this coroutine is suspended when the semaphore counter is zero. More about this in “Python’s Semaphores” on page 791.\n\nThe error handling logic is the same as in download_one, from Example 20-14.\n\nSaving the image is an I/O operation. To avoid blocking the event loop, run save_flag in a thread.\n\nAll network I/O is done with coroutines in asyncio, but not file I/O. However, file I/O is also “blocking”—in the sense that reading/writing files takes thousands of times longer than reading/writing to RAM. If you’re using Network-Attached Stor‐ age, it may even involve network I/O under the covers.\n\nSince Python 3.9, the asyncio.to_thread coroutine makes it easy to delegate file I/O to a thread pool provided by asyncio. If you need to support Python 3.7 or 3.8, “Dele‐ gating Tasks to Executors” on page 797 shows how to add a couple of lines to do it. But first, let’s finish our study of the HTTP client code.\n\nThrottling Requests with a Semaphore Network clients like the ones we are studying should be throttled (i.e., limited) to avoid pounding the server with too many concurrent requests.\n\nA semaphore is a synchronization primitive, more flexible than a lock. A semaphore can be held by multiple coroutines, with a configurable maximum number. This makes it ideal to throttle the number of active concurrent coroutines. “Python’s Sem‐ aphores” on page 791 has more information.\n\nIn flags2_threadpool.py (Example 20-16), the throttling was done by instantiating the ThreadPoolExecutor with the required max_workers argument set to concur_req in the download_many function. In flags2_asyncio.py, an asyncio.Semaphore is created\n\n790\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 2164,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 821,
      "content": "by the supervisor function (shown in Example 21-7) and passed as the semaphore argument to download_one in Example 21-6.\n\nPython’s Semaphores Computer scientist Edsger W. Dijkstra invented the semaphore in the early 1960s. It’s a simple idea, but it’s so flexible that most other synchronization objects—such as locks and barriers—can be built on top of semaphores. There are three Semaphore classes in Python’s standard library: one in threading, another in multiprocessing, and a third one in asyncio. Here we’ll describe the latter.\n\nAn asyncio.Semaphore has an internal counter that is decremented whenever we await on the .acquire() coroutine method, and incremented when we call the .release() method—which is not a coroutine because it never blocks. The initial value of the counter is set when the Semaphore is instantiated:\n\nsemaphore = asyncio.Semaphore(concur_req)\n\nAwaiting on .acquire() causes no delay when the counter is greater than zero, but if the counter is zero, .acquire() suspends the awaiting coroutine until some other coroutine calls .release() on the same Semaphore, thus incrementing the counter. Instead of using those methods directly, it’s safer to use the semaphore as an asyn‐ chronous context manager, as I did in Example 21-6, function download_one:\n\nasync with semaphore: image = await get_flag(client, base_url, cc)\n\nThe Semaphore.__aenter__ coroutine method awaits for .acquire(), and its __aexit__ coroutine method calls .release(). That snippet guarantees that no more than concur_req instances of get_flags coroutines will be active at any time.\n\nEach of the Semaphore classes in the standard library has a BoundedSemaphore subclass that enforces an additional constraint: the internal counter can never there are more .release() become the than .acquire() operations.7\n\nlarger\n\nthan\n\ninitial value when\n\nNow let’s take a look at the rest of the script in Example 21-7.\n\nExample 21-7. flags2_asyncio.py: script continued from Example 21-6\n\nasync def supervisor(cc_list: list[str], base_url: str,\n\n7 Thanks to Guto Maia who noted that the concept of a semaphore was not explained when he read the first\n\nedition draft for this chapter.\n\nEnhancing the asyncio Downloader\n\n|\n\n791",
      "content_length": 2216,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 822,
      "content": "verbose: bool, concur_req: int) -> Counter[DownloadStatus]: counter: Counter[DownloadStatus] = Counter() semaphore = asyncio.Semaphore(concur_req) async with httpx.AsyncClient() as client: to_do = [download_one(client, cc, base_url, semaphore, verbose) for cc in sorted(cc_list)] to_do_iter = asyncio.as_completed(to_do) if not verbose: to_do_iter = tqdm.tqdm(to_do_iter, total=len(cc_list)) error: httpx.HTTPError | None = None for coro in to_do_iter: try: status = await coro except httpx.HTTPStatusError as exc: error_msg = 'HTTP error {resp.status_code} - {resp.reason_phrase}' error_msg = error_msg.format(resp=exc.response) error = exc except httpx.RequestError as exc: error_msg = f'{exc} {type(exc)}'.strip() error = exc except KeyboardInterrupt: break\n\nif error: status = DownloadStatus.ERROR if verbose: url = str(error.request.url) cc = Path(url).stem.upper() print(f'{cc} error: {error_msg}') counter[status] += 1\n\nreturn counter\n\ndef download_many(cc_list: list[str], base_url: str, verbose: bool, concur_req: int) -> Counter[DownloadStatus]: coro = supervisor(cc_list, base_url, verbose, concur_req) counts = asyncio.run(coro)\n\nreturn counts\n\nif __name__ == '__main__': main(download_many, DEFAULT_CONCUR_REQ, MAX_CONCUR_REQ)\n\nsupervisor takes the same arguments as the download_many function, but it can‐ not be invoked directly from main because it’s a coroutine and not a plain func‐ tion like download_many.\n\n792\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1471,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 823,
      "content": "Create an asyncio.Semaphore that will not allow more than concur_req active coroutines among those using this semaphore. The value of concur_req is com‐ puted by the main function from flags2_common.py, based on command-line options and constants set in each example.\n\nCreate a list of coroutine objects, one per call to the download_one coroutine.\n\nGet an iterator that will return coroutine objects as they are done. I did not place this call to as_completed directly in the for loop below because I may need to wrap it with the tqdm iterator for the progress bar, depending on the user’s choice for verbosity.\n\nWrap the as_completed iterator with the tqdm generator function to display progress.\n\nDeclare and initialize error with None; this variable will be used to hold an exception beyond the try/except statement, if one is raised.\n\nIterate over the completed coroutine objects; this loop is similar to the one in download_many in Example 20-16.\n\nawait on the coroutine to get its result. This will not block because as_comple ted only produces coroutines that are done.\n\nThis assignment is necessary because the exc variable scope is limited to this except clause, but I need to preserve its value for later.\n\nSame as before.\n\nIf there was an error, set the status.\n\nIn verbose mode, extract the URL from the exception that was raised…\n\n…and extract the name of the file to display the country code next.\n\ndownload_many instantiates the supervisor coroutine object and passes it to the event loop with asyncio.run, collecting the counter supervisor returns when the event loop ends.\n\nIn Example 21-7, we could not use the mapping of futures to country codes we saw in Example 20-16, because the awaitables returned by asyncio.as_completed are the same awaitables we pass into the as_completed call. Internally, the asyncio\n\nEnhancing the asyncio Downloader\n\n|\n\n793",
      "content_length": 1872,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 824,
      "content": "machinery may replace the awaitables we provide with others that will, in the end, produce the same results.8\n\nBecause I could not use the awaitables as keys to retrieve the coun‐ try code from a dict in case of failure, I had to extract the country code from the exception. To do that, I kept the exception in the error variable to retrieve outside of the try/except statement. Python is not a block-scoped language: statements such as loops and try/except don’t create a local scope in the blocks they man‐ age. But if an except clause binds an exception to a variable, like the exc variables we just saw—that binding only exists within the block inside that particular except clause.\n\nThis wraps up the discussion of an asyncio example functionally equivalent to the flags2_threadpool.py we saw earlier.\n\nThe next example demonstrates the simple pattern of executing one asynchronous task after another using coroutines. This deserves our attention because anyone with previous experience with JavaScript knows that running one asynchronous function after the other was the reason for the nested coding pattern known as pyramid of doom. The await keyword makes that curse go away. That’s why await is now part of Python and JavaScript.\n\nMaking Multiple Requests for Each Download Suppose you want to save each country flag with the name of the country and the country code, instead of just the country code. Now you need to make two HTTP requests per flag: one to get the flag image itself, the other to get the metadata.json file in the same directory as the image—that’s where the name of the country is recorded.\n\nCoordinating multiple requests in the same task is easy in the threaded script: just make one request then the other, blocking the thread twice, and keeping both pieces of data (country code and name) in local variables, ready to use when saving the files. If you needed to do the same in an asynchronous script with callbacks, you needed nested functions so that the country code and name were available in their closures until you could save the file, because each callback runs in a different local scope. The await keyword provides relief from that, allowing you to drive the asynchronous requests one after the other, sharing the local scope of the driving coroutine.\n\n8 A detailed discussion about this can be found in a thread I started in the python-tulip group, titled “Which\n\nother futures may come out of asyncio.as_completed?”. Guido responds, and gives insight on the implemen‐ tation of as_completed, as well as the close relationship between futures and coroutines in asyncio.\n\n794\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 2657,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 825,
      "content": "If you are doing asynchronous application programming in modern Python with lots of callbacks, you are probably applying old patterns that don’t make sense in modern Python. That is justi‐ fied if you are writing a library that interfaces with legacy or low- support coroutines. Anyway, level code the StackOverflow Q&A, for the use future.add_done_callback()?” explains why callbacks are needed in low-level code, but are not very useful in Python application-level code these days.\n\nthat does not\n\n“What\n\nis\n\ncase\n\nThe third variation of the asyncio flag downloading script has a few changes:\n\nget_country\n\nThis new coroutine fetches the metadata.json file for the country code, and gets the name of the country from it.\n\ndownload_one\n\nThis coroutine now uses await to delegate to get_flag and the new get_country coroutine, using the result of the latter to build the name of the file to save.\n\nLet’s start with the code for get_country (Example 21-8). Note that it is very similar to get_flag from Example 21-6.\n\nExample 21-8. flags3_asyncio.py: get_country coroutine\n\nasync def get_country(client: httpx.AsyncClient, base_url: str, cc: str) -> str: url = f'{base_url}/{cc}/metadata.json'.lower() resp = await client.get(url, timeout=3.1, follow_redirects=True) resp.raise_for_status() metadata = resp.json() return metadata['country']\n\nThis coroutine returns a string with the country name—if all goes well.\n\nmetadata will get a Python dict built from the JSON contents of the response.\n\nReturn the country name.\n\nNow let’s see the modified download_one in Example 21-9, which has only a few lines changed from the same coroutine in Example 21-6.\n\nEnhancing the asyncio Downloader\n\n|\n\n795",
      "content_length": 1693,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 826,
      "content": "Example 21-9. flags3_asyncio.py: download_one coroutine\n\nasync def download_one(client: httpx.AsyncClient, cc: str, base_url: str, semaphore: asyncio.Semaphore, verbose: bool) -> DownloadStatus: try: async with semaphore: image = await get_flag(client, base_url, cc) async with semaphore: country = await get_country(client, base_url, cc) except httpx.HTTPStatusError as exc: res = exc.response if res.status_code == HTTPStatus.NOT_FOUND: status = DownloadStatus.NOT_FOUND msg = f'not found: {res.url}' else: raise else: filename = country.replace(' ', '_') await asyncio.to_thread(save_flag, image, f'{filename}.gif') status = DownloadStatus.OK msg = 'OK' if verbose and msg: print(cc, msg) return status\n\nHold the semaphore to await for get_flag…\n\n…and again for get_country.\n\nUse the country name to create a filename. As a command-line user, I don’t like to see spaces in filenames.\n\nMuch better than nested callbacks!\n\nI put the calls to get_flag and get_country in separate with blocks controlled by the semaphore because it’s good practice to hold semaphores and locks for the shortest possible time.\n\nI could schedule both get_flag and get_country in parallel using asyncio.gather, but if get_flag raises an exception, there is no image to save, so it’s pointless to run get_country. But there are cases where it makes sense to use asyncio.gather to hit several APIs at the same time instead of waiting for one response before making the next request.\n\nIn flags3_asyncio.py, the await syntax appears six times, and async with three times. Hopefully, you should be getting the hang of asynchronous programming in Python.\n\n796\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1673,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 827,
      "content": "One challenge is to know when you have to use await and when you can’t use it. The answer in principle is easy: you await coroutines and other awaitables, such as asyn cio.Task instances. But some APIs are tricky, mixing coroutines and plain functions in seemingly arbitrary ways, like the StreamWriter class we’ll use in Example 21-14.\n\nExample 21-9 wrapped up the flags set of examples. Now let’s discuss the use of thread or process executors in asynchronous programming.\n\nDelegating Tasks to Executors One important advantage of Node.js over Python for asynchronous programming is the Node.js standard library, which provides async APIs for all I/O—not just for net‐ work I/O. In Python, if you’re not careful, file I/O can seriously degrade the perfor‐ mance of asynchronous applications, because reading and writing to storage in the main thread blocks the event loop.\n\nIn the download_one coroutine of Example 21-6, I used this line to save the downloa‐ ded image to disk:\n\nawait asyncio.to_thread(save_flag, image, f'{cc}.gif')\n\nAs mentioned before, the asyncio.to_thread was added in Python 3.9. If you need to support 3.7 or 3.8, then replace that single line with the lines in Example 21-10.\n\nExample 21-10. Lines to use instead of await asyncio.to_thread\n\nloop = asyncio.get_running_loop() loop.run_in_executor(None, save_flag, image, f'{cc}.gif')\n\nGet a reference to the event loop.\n\nThe first argument is the executor to use; passing None selects the default Thread PoolExecutor that is always available in the asyncio event loop.\n\nYou can pass positional arguments to the function to run, but if you need to pass keyword arguments, then you need to resort to functool.partial, as described in the run_in_executor documentation.\n\nThe newer asyncio.to_thread function is easier to use and more flexible, as it also accepts keyword arguments.\n\nThe implementation of asyncio itself uses run_in_executor under the hood in a few places. For example, the loop.getaddrinfo(…) coroutine we saw in Example 21-1 is implemented by calling the getaddrinfo function from the socket module—\n\nDelegating Tasks to Executors\n\n|\n\n797",
      "content_length": 2129,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 828,
      "content": "which is a blocking function that may take seconds to return, as it depends on DNS resolution.\n\nA common pattern in asynchronous APIs is to wrap blocking calls that are imple‐ mentation details in coroutines using run_in_executor internally. That way, you provide a consistent interface of coroutines to be driven with await, and hide the threads you need to use for pragmatic reasons. The Motor asynchronous driver for MongoDB has an API compatible with async/await that is really a façade around a threaded core that talks to the database server. A. Jesse Jiryu Davis, the lead developer of Motor, explains his reasoning in “Response to ‘Asynchronous Python and Data‐ bases’”. Spoiler: Davis discovered that a thread pool was more performant in the par‐ ticular use case of a database driver—despite the myth that asynchronous approaches are always faster than threads for network I/O.\n\nThe main reason to pass an explict Executor to loop.run_in_executor is to employ a ProcessPoolExecutor if the function to execute is CPU intensive, so that it runs in a different Python process, avoiding contention for the GIL. Because of the high start-up cost, it would be better to start the ProcessPoolExecutor in the supervisor, and pass it to the coroutines that need to use it.\n\nCaleb Hattingh—the author of Using Asyncio in Python (O’ Reilly)—is one of the tech reviewers of this book and suggested I add the following warning about execu‐ tors and asyncio.\n\nCaleb’s Warning about run_in_executors\n\nUsing run_in_executor can produce hard-to-debug problems since cancellation doesn’t work the way one might expect. Corou‐ tines that use executors give merely the pretense of cancellation: the underlying thread (if it’s a ThreadPoolExecutor) has no cancel‐ lation mechanism. For example, a long-lived thread that is created inside a run_in_executor call may prevent your asyncio program from shutting down cleanly: asyncio.run will wait for the executor to fully shut down before returning, and it will wait forever if the executor jobs don’t stop somehow on their own. My greybeard inclination is to want that function to be named run_in_executor_uncancellable.\n\nWe’ll now go from client scripts to writing servers with asyncio.\n\n798\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 2271,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 829,
      "content": "Writing asyncio Servers The classic toy example of a TCP server is an echo server. We’ll build slightly more interesting toys: server-side Unicode character search utilities, first using HTTP with FastAPI, then using plain TCP with asyncio only.\n\nThese servers let users query for Unicode characters based on words in their standard names from the unicodedata module we discussed in “The Unicode Database” on page 150. Figure 21-2 shows a session with web_mojifinder.py, the first server we’ll build.\n\nFigure 21-2. Browser window displaying search results for “mountain” from the web_mojifinder.py service.\n\nThe Unicode search logic in these examples is in the InvertedIndex class in the char‐ index.py module in the Fluent Python code repository. There’s nothing concurrent in that small module, so I’ll only give a brief overview in the optional box that follows. You can skip to the HTTP server implementation in “A FastAPI Web Service” on page 800.\n\nMeet the Inverted Index An inverted index usually maps words to documents in which they occur. In the mojifinder examples, each “document” is one Unicode character. The charin dex.InvertedIndex class indexes each word that appears in each character name in the Unicode database, and creates an inverted index stored in a defaultdict. For example, to index character U+0037—DIGIT SEVEN—the InvertedIndex initializer appends the character '7' to the entries under the keys 'DIGIT' and 'SEVEN'. After indexing the Unicode 13.0.0 data bundled with Python 3.9.1, 'DIGIT' maps to 868 characters, and 'SEVEN' maps to 143, including U+1F556—CLOCK FACE SEVEN\n\nWriting asyncio Servers\n\n|\n\n799",
      "content_length": 1636,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 830,
      "content": "OCLOCK and U+2790—DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT SEVEN (which appears in many code listings in this book).\n\nSee Figure 21-3 for a demonstration using the entries for 'CAT' and 'FACE'.9\n\nFigure 21-3. Python console exploring InvertedIndex attribute entries and search method.\n\nThe InvertedIndex.search method breaks the query into words, and returns the intersection of the entries for each word. That’s why searching for “face” finds 171 results, “cat” finds 14, but “cat face” only 10.\n\nThat’s the beautiful idea behind an inverted index: a fundamental building block in information retrieval—the theory behind search engines. See the English Wikipedia article “Inverted Index” to learn more.\n\nA FastAPI Web Service I wrote the next example—web_mojifinder.py—using FastAPI: one of the Python ASGI Web frameworks mentioned in “ASGI—Asynchronous Server Gateway Inter‐ face” on page 732. Figure 21-2 is a screenshot of the frontend. It’s a super simple SPA (Single Page Application): after the initial HTML download, the UI is updated by client-side JavaScript communicating with the server.\n\nFastAPI is designed to implement backends for SPA and mobile apps, which mostly consist of web API end points returning JSON responses instead of server-rendered HTML. FastAPI leverages decorators, type hints, and code introspection to eliminate a lot of the boilerplate code for web APIs, and also automatically publishes interactive OpenAPI—a.k.a. Swagger—documentation for the APIs we create. Figure 21-4 shows the autogenerated /docs page for web_mojifinder.py.\n\n9 The boxed question mark in the screen shot is not a defect of the book or ebook you are reading. It’s the U\n\n+101EC—PHAISTOS DISC SIGN CAT character, which is missing from the font in the terminal I used. The Phaistos disc is an ancient artifact inscribed with pictograms, discovered in the island of Crete.\n\n800\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1924,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 831,
      "content": "Figure 21-4. Autogenerated OpenAPI schema for the /search endpoint.\n\nExample 21-11 is the code for web_mojifinder.py, but that’s just the backend code. When you hit the root URL /, the server sends the form.html file, which has 81 lines of code, including 54 lines of JavaScript to communicate with the server and fill a table with the results. If you’re interested in reading plain framework-less JavaScript, please find 21-async/mojifinder/static/form.html in the Fluent Python code repository.\n\nTo run web_mojifinder.py, you need to install two packages and their dependencies: FastAPI and uvicorn.10 This is the command to run Example 21-11 with uvicorn in development mode:\n\n$ uvicorn web_mojifinder:app --reload\n\nThe parameters are:\n\nweb_mojifinder:app\n\nThe package name, a colon, and the name of the ASGI application defined in it— app is the conventional name.\n\n--reload\n\nMake uvicorn monitor changes to application source files and automatically reload them. Useful only during development.\n\nNow let’s study the source code for web_mojifinder.py.\n\n10 Instead of uvicorn, you may use another ASGI server, such as hypercorn or Daphne. See the official ASGI doc‐\n\numentation page about implementations for more information.\n\nWriting asyncio Servers\n\n|\n\n801",
      "content_length": 1262,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 832,
      "content": "Example 21-11. web_mojifinder.py: complete source\n\nfrom pathlib import Path from unicodedata import name\n\nfrom fastapi import FastAPI from fastapi.responses import HTMLResponse from pydantic import BaseModel\n\nfrom charindex import InvertedIndex\n\nSTATIC_PATH = Path(__file__).parent.absolute() / 'static'\n\napp = FastAPI( title='Mojifinder Web', description='Search for Unicode characters by name.', )\n\nclass CharName(BaseModel): char: str name: str\n\ndef init(app): app.state.index = InvertedIndex() app.state.form = (STATIC_PATH / 'form.html').read_text()\n\ninit(app)\n\n@app.get('/search', response_model=list[CharName]) async def search(q: str): chars = sorted(app.state.index.search(q)) return ({'char': c, 'name': name(c)} for c in chars)\n\n@app.get('/', response_class=HTMLResponse, include_in_schema=False) def form(): return app.state.form\n\n# no main funcion\n\nUnrelated to the theme of this chapter, but worth noting: the elegant use of the overloaded / operator by pathlib.11\n\nThis line defines the ASGI app. It could be as simple as app = FastAPI(). The parameters shown are metadata for the autogenerated documentation.\n\n11 Thanks to tech reviewer Miroslav Šedivý for highlighting good places to use pathlib in code examples.\n\n802\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1276,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 833,
      "content": "A pydantic schema for a JSON response with char and name fields.12\n\nBuild the index and load the static HTML form, attaching both to the app.state for later use.\n\nRun init when this module is loaded by the ASGI server.\n\nRoute for the /search endpoint; response_model uses that CharName pydantic model to describe the response format.\n\nFastAPI assumes that any parameters that appear in the function or coroutine signature that are not in the route path will be passed in the HTTP query string, e.g., /search?q=cat. Since q has no default, FastAPI will return a 422 (Unpro‐ cessable Entity) status if q is missing from the query string.\n\nReturning an iterable of dicts compatible with the response_model schema allows FastAPI to build the JSON response according to the response_model in the @app.get decorator.\n\nRegular functions (i.e., non-async) can also be used to produce responses.\n\nThis module has no main function. It is loaded and driven by the ASGI server— uvicorn in this example.\n\nExample 21-11 has no direct calls to asyncio. FastAPI is built on the Starlette ASGI toolkit, which in turn uses asyncio.\n\nAlso note that the body of search doesn’t use await, async with, or async for, therefore it could be a plain function. I defined search as a coroutine just to show that FastAPI knows how to handle it. In a real app, most endpoints will query data‐ bases or hit other remote servers, so it is a critical advantage of FastAPI—and ASGI frameworks in general—to support coroutines that can take advantage of asynchro‐ nous libraries for network I/O.\n\n12 As mentioned in Chapter 8, pydantic enforces type hints at runtime, for data validation.\n\nWriting asyncio Servers\n\n|\n\n803",
      "content_length": 1686,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 834,
      "content": "The init and form functions I wrote to load and serve the static HTML form are a hack to make the example short and easy to run. The recommended best practice is to have a proxy/load-balancer in front of the ASGI server to handle all static assets, and also use a CDN (Content Delivery Network) when possible. One such proxy/ load-balancer is Traefik, a self-described “edge router” that “receives requests on behalf of your system and finds out which components are responsible for handling them.” FastAPI has project generation scripts that prepare your code to do that.\n\nThe typing enthusiast may have noticed that there are no return type hints in search and form. Instead, FastAPI relies on the response_model= keyword argument in the route decorators. The “Response Model” page in the FastAPI documentation explains:\n\nThe response model is declared in this parameter instead of as a function return type annotation, because the path function may not actually return that response model but rather return a dict, database object or some other model, and then use the response_model to perform the field limiting and serialization.\n\nFor example, in search, I returned a generator of dict items, not a list of CharName objects, but that’s good enough for FastAPI and pydantic to validate my data and build the appropriate JSON response compatible with response_model=list[Char Name].\n\nWe’ll now focus on the tcp_mojifinder.py script that is answering the queries in Figure 21-5.\n\nAn asyncio TCP Server The tcp_mojifinder.py program uses plain TCP to communicate with a client like Tel‐ net or Netcat, so I could write it using asyncio without external dependencies—and without reinventing HTTP. Figure 21-5 shows text-based UI.\n\n804\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1776,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 835,
      "content": "Figure 21-5. Telnet session with the tcp_mojifinder.py server: querying for “fire.”\n\nThis program is twice as long as web_mojifinder.py, so I split the presentation into three parts: Example 21-12, Example 21-14, and Example 21-15. The top of tcp_moji‐ finder.py—including the import statements—is in Example 21-14, but I will start by describing the supervisor coroutine and the main function that drives the program.\n\nExample 21-12. tcp_mojifinder.py: a simple TCP server; continues in Example 21-14\n\nasync def supervisor(index: InvertedIndex, host: str, port: int) -> None: server = await asyncio.start_server( functools.partial(finder, index), host, port)\n\nsocket_list = cast(tuple[TransportSocket, ...], server.sockets) addr = socket_list[0].getsockname() print(f'Serving on {addr}. Hit CTRL-C to stop.') await server.serve_forever()\n\ndef main(host: str = '127.0.0.1', port_arg: str = '2323'): port = int(port_arg) print('Building index.') index = InvertedIndex() try: asyncio.run(supervisor(index, host, port)) except KeyboardInterrupt: print('\\nServer shut down.')\n\nif __name__ == '__main__': main(*sys.argv[1:])\n\nWriting asyncio Servers\n\n|\n\n805",
      "content_length": 1152,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 836,
      "content": "This await quickly gets an instance of asyncio.Server, a TCP socket server. By default, start_server creates and starts the server, so it’s ready to receive connections.\n\nThe first argument to start_server is client_connected_cb, a callback to run when a new client connection starts. The callback can be a function or a corou‐ tine, but it must accept exactly two arguments: an asyncio.StreamReader and an asyncio.StreamWriter. However, my finder coroutine also needs to get an index, so I used functools.partial to bind that parameter and obtain a callable that takes the reader and writer. Adapting user functions to callback APIs is the most common use case for functools.partial.\n\nhost and port are the second and third arguments to start_server. See the full signature in the asyncio documentation.\n\nThis cast is needed because typeshed has an outdated type hint for the sockets property of the Server class—as of May 2021. See Issue #5535 on typeshed.13\n\nDisplay the address and port of the first socket of the server.\n\nAlthough start_server already started the server as a concurrent task, I need to await on the server_forever method so that my supervisor is suspended here. Without this line, supervisor would return immediately, ending the loop started with asyncio.run(supervisor(…)), and exiting the program. The documenta‐ tion for Server.serve_forever says: “This method can be called if the server is already accepting connections.”\n\nBuild the inverted index.14\n\nStart the event loop running supervisor.\n\nCatch the KeyboardInterrupt to avoid a distracting traceback when I stop the server with Ctrl-C on the terminal running it.\n\nYou may find it easier to understand how control flows in tcp_mojifinder.py if you study the output it generates on the server console, listed in Example 21-13.\n\n13 Issue #5535 is closed as of October 2021, but Mypy did not have a new release since then, so the error persists.\n\n14 Tech reviewer Leonardo Rochael pointed out that building the index could be delegated to another thread\n\nusing loop.run_with_executor() in the supervisor coroutine, so the server would be ready to take requests immediately while the index is built. That’s true, but querying the index is the only thing this server does, so it would not be a big win in this example.\n\n806\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 2340,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 837,
      "content": "Example 21-13. tcp_mojifinder.py: this is the server side of the session depicted in Figure 21-5\n\n$ python3 tcp_mojifinder.py Building index. Serving on ('127.0.0.1', 2323). Hit Ctrl-C to stop. From ('127.0.0.1', 58192): 'cat face' To ('127.0.0.1', 58192): 10 results. From ('127.0.0.1', 58192): 'fire' To ('127.0.0.1', 58192): 11 results. From ('127.0.0.1', 58192): '\\x00' Close ('127.0.0.1', 58192). ^C Server shut down. $\n\nOutput by main. Before the next line appears, I see a 0.6s delay on my machine while the index is built.\n\nOutput by supervisor.\n\nFirst iteration of a while loop in finder. The TCP/IP stack assigned port 58192 to my Telnet client. If you connect several clients to the server, you’ll see their various ports in the output.\n\nSecond iteration of the while loop in finder.\n\nI hit Ctrl-C on the client terminal; the while loop in finder exits.\n\nThe finder coroutine displays this message then exits. Meanwhile the server is still running, ready to service another client.\n\nI hit Ctrl-C on the server terminal; server.serve_forever is cancelled, ending supervisor and the event loop.\n\nOutput by main.\n\nAfter main builds the index and starts the event loop, supervisor quickly displays the Serving on… message and is suspended at the await server.serve_forever() line. At that point, control flows into the event loop and stays there, occasionally coming back to the finder coroutine, which yields control back to the event loop whenever it needs to wait for the network to send or receive data.\n\nWhile the event loop is alive, a new instance of the finder coroutine will be started for each client that connects to the server. In this way, many clients can be handled\n\nWriting asyncio Servers\n\n|\n\n807",
      "content_length": 1720,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 838,
      "content": "concurrently by this simple server. This continues until a KeyboardInterrupt occurs on the server or its process is killed by the OS.\n\nNow let’s see the top of tcp_mojifinder.py, with the finder coroutine.\n\nExample 21-14. tcp_mojifinder.py: continued from Example 21-12\n\nimport asyncio import functools import sys from asyncio.trsock import TransportSocket from typing import cast\n\nfrom charindex import InvertedIndex, format_results\n\nCRLF = b'\\r\\n' PROMPT = b'?> '\n\nasync def finder(index: InvertedIndex, reader: asyncio.StreamReader, writer: asyncio.StreamWriter) -> None: client = writer.get_extra_info('peername') while True: writer.write(PROMPT) # can't await! await writer.drain() # must await! data = await reader.readline() if not data: break try: query = data.decode().strip() except UnicodeDecodeError: query = '\\x00' print(f' From {client}: {query!r}') if query: if ord(query[:1]) < 32: break results = await search(query, index, writer) print(f' To {client}: {results} results.')\n\nwriter.close() await writer.wait_closed() print(f'Close {client}.')\n\n808\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1106,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 839,
      "content": "format_results is useful to display the results of InvertedIndex.search in a text-based UI such as the command line or a Telnet session.\n\nTo pass finder to asyncio.start_server, I wrapped it with functools.par tial, because the server expects a coroutine or function that takes only the reader and writer arguments.\n\nGet the remote client address to which the socket is connected.\n\nThis loop handles a dialog that lasts until a control character is received from the client.\n\nThe StreamWriter.write method is not a coroutine, just a plain function; this line sends the ?> prompt.\n\nStreamWriter.drain flushes the writer buffer; it is a coroutine, so it must be driven with await.\n\nStreamWriter.readline is a coroutine that returns bytes.\n\nIf no bytes were received, the client closed the connection, so exit the loop.\n\nDecode the bytes to str, using the default UTF-8 encoding.\n\nA UnicodeDecodeError may happen when the user hits Ctrl-C and the Telnet cli‐ ent sends control bytes; if that happens, replace the query with a null character, for simplicity.\n\nLog the query to the server console.\n\nExit the loop if a control or null character was received.\n\nDo the actual search; code is presented next.\n\nLog the response to the server console.\n\nClose the StreamWriter.\n\nWait for the StreamWriter to close. This is recommended in the .close() method documentation.\n\nLog the end of this client’s session to the server console.\n\nThe last piece of this example is the search coroutine, shown in Example 21-15.\n\nWriting asyncio Servers\n\n|\n\n809",
      "content_length": 1535,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 840,
      "content": "Example 21-15. tcp_mojifinder.py: search coroutine\n\nasync def search(query: str, index: InvertedIndex, writer: asyncio.StreamWriter) -> int: chars = index.search(query) lines = (line.encode() + CRLF for line in format_results(chars)) writer.writelines(lines) await writer.drain() status_line = f'{\"─\" * 66} {len(chars)} found' writer.write(status_line.encode() + CRLF) await writer.drain() return len(chars)\n\nsearch must be a coroutine because it writes to a StreamWriter and must use its .drain() coroutine method.\n\nQuery the inverted index.\n\nThis generator expression will yield byte strings encoded in UTF-8 with the Uni‐ code codepoint, the actual character, its name, and a CRLF sequence—e.g., b'U+0039\\t9\\tDIGIT NINE\\r\\n').\n\nSend the lines. Surprisingly, writer.writelines is not a coroutine.\n\nBut writer.drain() is a coroutine. Don’t forget the await!\n\nBuild a status line, then send it.\n\nNote that all network I/O in tcp_mojifinder.py is in bytes; we need to decode the bytes received from the network, and encode strings before sending them out. In Python 3, the default encoding is UTF-8, and that’s what I used implicitly in all encode and decode calls in this example.\n\nNote that some of the I/O methods are coroutines and must be driven with await, while others are simple functions. For example, StreamWriter.write is a plain function, because it writes to a buffer. On the other hand, StreamWriter.drain—which flushes the buffer and performs the network I/O—is a coroutine, as is StreamReader.readline—but not StreamWriter.writelines! While I was writing the first edition of this book, the asyncio API docs were improved by clearly labeling coroutines as such.\n\n810\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1722,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 841,
      "content": "The tcp_mojifinder.py code leverages the high-level asyncio Streams API that pro‐ vides a ready-to-use server so you only need to implement a handler function, which can be a plain callback or a coroutine. There is also a lower-level Transports and Pro‐ tocols API, inspired by the transport and protocols abstractions in the Twisted frame‐ work. Refer to the asyncio documentation for more information, including TCP and UDP echo servers and clients implemented with that lower-level API.\n\nOur next topic is async for and the objects that make it work.\n\nAsynchronous Iteration and Asynchronous Iterables We saw in “Asynchronous Context Managers” on page 786 how async with works with objects implementing the __aenter__ and __aexit__ methods returning await‐ ables—usually in the form of coroutine objects.\n\nSimilarly, async for works with asynchronous iterables: objects that implement __aiter__. However, __aiter__ must be a regular method—not a coroutine method —and it must return an asynchronous iterator.\n\nAn asynchronous iterator provides an __anext__ coroutine method that returns an awaitable—often a coroutine object. They are also expected to implement __aiter__, which usually returns self. This mirrors the important distinction of iterables and iterators we discussed in “Don’t Make the Iterable an Iterator for Itself” on page 605.\n\nThe aiopg asynchronous PostgreSQL driver documentation has an example that illus‐ trates the use of async for to iterate over the rows of a database cursor:\n\nasync def go(): pool = await aiopg.create_pool(dsn) async with pool.acquire() as conn: async with conn.cursor() as cur: await cur.execute(\"SELECT 1\") ret = [] async for row in cur: ret.append(row) assert ret == [(1,)]\n\nIn this example the query will return a single row, but in a realistic scenario you may have thousands of rows in response to a SELECT query. For large responses, the cursor will not be loaded with all the rows in a single batch. Therefore it is important that async for row in cur: does not block the event loop while the cursor may be wait‐ ing for additional rows. By implementing the cursor as an asynchronous iterator, aiopg may yield to the event loop at each __anext__ call, and resume later when more rows arrive from PostgreSQL.\n\nAsynchronous Iteration and Asynchronous Iterables\n\n|\n\n811",
      "content_length": 2322,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 842,
      "content": "Asynchronous Generator Functions You can implement an asynchronous iterator by writing a class with __anext__ and __aiter__, but there is a simpler way: write a function declared with async def and use yield in its body. This parallels how generator functions simplify the classic Iter‐ ator pattern.\n\nLet’s study a simple example using async for and implementing an asynchronous generator. In Example 21-1 we saw blogdom.py, a script that probed domain names. Now suppose we find other uses for the probe coroutine we defined there, and decide to put it into a new module—domainlib.py—together with a new multi_probe asyn‐ chronous generator that takes a list of domain names and yields results as they are probed.\n\nWe’ll look at the implementation of domainlib.py soon, but first let’s see how it is used with Python’s new asynchronous console.\n\nExperimenting with Python’s async console\n\nSince Python 3.8, you can run the interpreter with the -m asyncio command-line option to get an “async REPL”: a Python console that imports asyncio, provides a running event loop, and accepts await, async for, and async with at the top-level prompt—which otherwise are syntax errors when used outside of native coroutines.15\n\nTo experiment with domainlib.py, go to the 21-async/domains/asyncio/ directory in your local copy of the Fluent Python code repository. Then run:\n\n$ python -m asyncio\n\nYou’ll see the console start, similar to this:\n\nasyncio REPL 3.9.1 (v3.9.1:1e5d33e9b9, Dec 7 2020, 12:10:52) [Clang 6.0 (clang-600.0.57)] on darwin Use \"await\" directly instead of \"asyncio.run()\". Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import asyncio >>>\n\nNote how the header says you can use await instead of asyncio.run()—to drive coroutines and other awaitables. Also: I did not type import asyncio. The asyncio module is automatically imported and that line makes that fact clear to the user.\n\n15 This is great for experimentation, like the Node.js console. Thanks to Yury Selivanov for yet another excellent\n\ncontribution to asynchronous Python.\n\n812\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 2117,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 843,
      "content": "Now let’s import domainlib.py and play with its two coroutines: probe and multi_probe (Example 21-16).\n\nExample 21-16. Experimenting with domainlib.py after running python3 -m asyncio\n\n>>> await asyncio.sleep(3, 'Rise and shine!') 'Rise and shine!' >>> from domainlib import * >>> await probe('python.org') Result(domain='python.org', found=True) >>> names = 'python.org rust-lang.org golang.org no-lang.invalid'.split() >>> async for result in multi_probe(names): ... print(*result, sep='\\t') ... golang.org True no-lang.invalid False python.org True rust-lang.org True >>>\n\nTry a simple await to see the asynchronous console in action. Tip: asyn cio.sleep() takes an optional second argument that is returned when you await it.\n\nDrive the probe coroutine.\n\nThe domainlib version of probe returns a Result named tuple.\n\nMake a list of domains. The .invalid top-level domain is reserved for testing. DNS queries for such domains always get an NXDOMAIN response from DNS servers, meaning “that domain does not exist.”16\n\nIterate with async for over the multi_probe asynchronous generator to display the results.\n\nNote that the results are not in the order the domains were given to multiprobe. They appear as each DNS response comes back.\n\nExample 21-16 shows that multi_probe is an asynchronous generator because it is compatible with async for. Now let’s do a few more experiments, continuing from that example with Example 21-17.\n\n16 See RFC 6761—Special-Use Domain Names.\n\nAsynchronous Iteration and Asynchronous Iterables\n\n|\n\n813",
      "content_length": 1533,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 844,
      "content": "Example 21-17. More experiments, continuing from Example 21-16\n\n>>> probe('python.org') <coroutine object probe at 0x10e313740> >>> multi_probe(names) <async_generator object multi_probe at 0x10e246b80> >>> for r in multi_probe(names): ... print(r) ... Traceback (most recent call last): ... TypeError: 'async_generator' object is not iterable\n\nCalling a native coroutine gives you a coroutine object.\n\nCalling an asynchronous generator gives you an async_generator object.\n\nWe can’t use a regular for loop with asynchronous generators because they implement __aiter__ instead of __iter__.\n\nAsynchronous generators are driven by async for, which can be a block statement (as seen in Example 21-16), and it also appears in asynchronous comprehensions, which we’ll cover soon.\n\nImplementing an asynchronous generator\n\nNow let’s study the code for domainlib.py, with the multi_probe asynchronous gen‐ erator (Example 21-18).\n\nExample 21-18. domainlib.py: functions for probing domains\n\nimport asyncio import socket from collections.abc import Iterable, AsyncIterator from typing import NamedTuple, Optional\n\nclass Result(NamedTuple): domain: str found: bool\n\nOptionalLoop = Optional[asyncio.AbstractEventLoop]\n\nasync def probe(domain: str, loop: OptionalLoop = None) -> Result: if loop is None: loop = asyncio.get_running_loop() try:\n\n814\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1376,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 845,
      "content": "await loop.getaddrinfo(domain, None) except socket.gaierror: return Result(domain, False) return Result(domain, True)\n\nasync def multi_probe(domains: Iterable[str]) -> AsyncIterator[Result]: loop = asyncio.get_running_loop() coros = [probe(domain, loop) for domain in domains] for coro in asyncio.as_completed(coros): result = await coro yield result\n\nNamedTuple makes the result from probe easier to read and debug.\n\nThis type alias is to avoid making the next line too long for a book listing.\n\nprobe now gets an optional loop argument, to avoid repeated calls to get_run ning_loop when this coroutine is driven by multi_probe.\n\nAn asynchronous generator function produces an asynchronous generator object, which can be annotated as AsyncIterator[SomeType].\n\nBuild list of probe coroutine objects, each with a different domain.\n\nThis is not async for because asyncio.as_completed is a classic generator.\n\nAwait on the coroutine object to retrieve the result.\n\nYield result. This line makes multi_probe an asynchronous generator.\n\nThe for loop in Example 21-18 could be more concise: for coro in asyncio.as_completed(coros): yield await coro\n\nPython parses that as yield (await coro), so it works.\n\nI thought it could be confusing to use that shortcut in the first asynchronous generator example in the book, so I split it into two lines.\n\nGiven domainlib.py, we can demonstrate the use of the multi_probe asynchronous generator in domaincheck.py: a script that takes a domain suffix and searches for domains made from short Python keywords.\n\nHere is a sample output of domaincheck.py:\n\nAsynchronous Iteration and Asynchronous Iterables\n\n|\n\n815",
      "content_length": 1645,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 846,
      "content": "$ ./domaincheck.py net FOUND NOT FOUND ===== ========= in.net del.net true.net for.net is.net none.net try.net from.net and.net or.net else.net with.net if.net as.net elif.net pass.net not.net def.net\n\nThanks to domainlib, the code for domaincheck.py is straightforward, as seen in Example 21-19.\n\nExample 21-19. domaincheck.py: utility for probing domains using domainlib\n\n#!/usr/bin/env python3 import asyncio import sys from keyword import kwlist\n\nfrom domainlib import multi_probe\n\nasync def main(tld: str) -> None: tld = tld.strip('.') names = (kw for kw in kwlist if len(kw) <= 4) domains = (f'{name}.{tld}'.lower() for name in names) print('FOUND\\t\\tNOT FOUND') print('=====\\t\\t=========') async for domain, found in multi_probe(domains): indent = '' if found else '\\t\\t' print(f'{indent}{domain}')\n\nif __name__ == '__main__': if len(sys.argv) == 2: asyncio.run(main(sys.argv[1])) else: print('Please provide a TLD.', f'Example: {sys.argv[0]} COM.BR')\n\n816\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1004,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 847,
      "content": "Generate keywords with length up to 4.\n\nGenerate domain names with the given suffix as TLD.\n\nFormat a header for the tabular output.\n\nAsynchronously iterate over multi_probe(domains).\n\nSet indent to zero or two tabs to put the result in the proper column.\n\nRun the main coroutine with the given command-line argument.\n\nGenerators have one extra use unrelated to iteration: they can be made into context managers. This also applies to asynchronous generators.\n\nAsynchronous generators as context managers\n\nWriting our own asynchronous context managers is not a frequent programming task, but if you need to write one, consider using the @asynccontextmanager decora‐ tor added to the contextlib module in Python 3.7. That’s very similar to the @con textmanager decorator we studied in “Using @contextmanager” on page 664.\n\nAn interesting example combining @asynccontextmanager with loop.run_in_execu tor appears in Caleb Hattingh’s book Using Asyncio in Python. Example 21-20 is Caleb’s code—with a single change and added callouts.\n\nExample 21-20. Example using @asynccontextmanager and loop.run_in_executor\n\nfrom contextlib import asynccontextmanager\n\n@asynccontextmanager async def web_page(url): loop = asyncio.get_running_loop() data = await loop.run_in_executor( None, download_webpage, url) yield data await loop.run_in_executor(None, update_stats, url)\n\nasync with web_page('google.com') as data: process(data)\n\nThe decorated function must be an asynchronous generator.\n\nMinor update to Caleb’s code: use the lightweight get_running_loop instead of get_event_loop.\n\nAsynchronous Iteration and Asynchronous Iterables\n\n|\n\n817",
      "content_length": 1629,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 848,
      "content": "Suppose download_webpage is a blocking function using the requests library; we run it in a separate thread to avoid blocking the event loop.\n\nAll lines before this yield expression will become the __aenter__ coroutine- method of the asynchronous context manager built by the decorator. The value of data will be bound to the data variable after the as clause in the async with statement below.\n\nLines after the yield will become the __aexit__ coroutine method. Here, another blocking call is delegated to the thread executor.\n\nUse web_page with async with.\n\nThis is very similar to the sequential @contextmanager decorator. Please see “Using @contextmanager” on page 664 for more details, including error handling at the yield line. For another example of @asynccontextmanager, see the contextlib doc‐ umentation.\n\nNow let’s wrap up our coverage of asynchronous generator functions by contrasting them with native coroutines.\n\nAsynchronous generators versus native coroutines\n\nHere are some key similarities and differences between a native coroutine and an asynchronous generator function:\n\nBoth are declared with async def. • An asynchronous generator always has a yield expression in its body—that’s what makes it a generator. A native coroutine never contains yield.\n\nA native coroutine may return some value other than None. An asynchronous generator can only use empty return statements.\n\nNative coroutines are awaitable: they can be driven by await expressions or passed to one of the many asyncio functions that take awaitable arguments, such as create_task. Asynchronous generators are not awaitable. They are asynchro‐ nous iterables, driven by async for or by asynchronous comprehensions.\n\nTime to talk about asynchronous comprehensions.\n\nAsync Comprehensions and Async Generator Expressions PEP 530—Asynchronous Comprehensions introduced the use of async for and await in the syntax of comprehensions and generator expressions, starting with Python 3.6.\n\n818\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 2011,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 849,
      "content": "The only construct defined by PEP 530 that can appear outside an async def body is an asynchronous generator expression.\n\nDefining and using an asynchronous generator expression\n\nGiven the multi_probe asynchronous generator from Example 21-18, we could write another asynchronous generator returning only the names of the domains found. Here is how—again using the asynchronous console launched with -m asyncio:\n\n>>> from domainlib import multi_probe >>> names = 'python.org rust-lang.org golang.org no-lang.invalid'.split() >>> gen_found = (name async for name, found in multi_probe(names) if found) >>> gen_found <async_generator object <genexpr> at 0x10a8f9700> >>> async for name in gen_found: ... print(name) ... golang.org python.org rust-lang.org\n\nThe use of async for makes this an asynchronous generator expression. It can be defined anywhere in a Python module.\n\nThe asynchronous generator expression builds an async_generator object— exactly the same type of object returned by an asynchronous generator function like multi_probe.\n\nThe asynchronous generator object is driven by the async for statement, which in turn can only appear inside an async def body or in the magic asynchronous console I used in this example.\n\nTo summarize: an asynchronous generator expression can be defined anywhere in your program, but it can only be consumed inside a native coroutine or asynchro‐ nous generator function.\n\nThe remaining constructs introduced by PEP 530 can only be defined and used inside native coroutines or asynchronous generator functions.\n\nAsynchronous comprehensions\n\nYury Selivanov—the author of PEP 530—justifies the need for asynchronous com‐ prehensions with three short code snippets reproduced next.\n\nWe can all agree that we should be able to rewrite this code:\n\nresult = [] async for i in aiter():\n\nAsynchronous Iteration and Asynchronous Iterables\n\n|\n\n819",
      "content_length": 1881,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 850,
      "content": "if i % 2: result.append(i)\n\nlike this:\n\nresult = [i async for i in aiter() if i % 2]\n\nIn addition, given a native coroutine fun, we should be able to write this:\n\nresult = [await fun() for fun in funcs]\n\nUsing await in a list comprehension is similar to using asyn cio.gather. But gather gives you more control over exception handling, thanks to its optional return_exceptions argument. Caleb Hattingh recommends always setting return_excep tions=True (the default is False). Please see the asyncio.gather documentation for more.\n\nBack to the magic asynchronous console:\n\n>>> names = 'python.org rust-lang.org golang.org no-lang.invalid'.split() >>> names = sorted(names) >>> coros = [probe(name) for name in names] >>> await asyncio.gather(*coros) [Result(domain='golang.org', found=True), Result(domain='no-lang.invalid', found=False), Result(domain='python.org', found=True), Result(domain='rust-lang.org', found=True)] >>> [await probe(name) for name in names] [Result(domain='golang.org', found=True), Result(domain='no-lang.invalid', found=False), Result(domain='python.org', found=True), Result(domain='rust-lang.org', found=True)] >>>\n\nNote that I sorted the list of names to show that the results come out in the order they were submitted, in both cases.\n\nPEP 530 allows the use of async for and await in list comprehensions as well as in dict and set comprehensions. For example, here is a dict comprehension to store the results of multi_probe in the asynchronous console:\n\n>>> {name: found async for name, found in multi_probe(names)} {'golang.org': True, 'python.org': True, 'no-lang.invalid': False, 'rust-lang.org': True}\n\nWe can use the await keyword in the expression before the for or async for clause, and also in the expression after the if clause. Here is a set comprehension in the asynchronous console, collecting only the domains that were found:\n\n>>> {name for name in names if (await probe(name)).found} {'rust-lang.org', 'python.org', 'golang.org'}\n\n820\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 2021,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 851,
      "content": "I had to put extra parentheses around the await expression due to the higher prece‐ dence of the __getattr__ operator . (dot).\n\nAgain, all of these comprehensions can only appear inside an async def body or in the enchanted asynchronous console.\n\nNow let’s talk about a very important feature of the async statements, async expres‐ sions, and the objects they create. Those constructs are often used with asyncio but, they are actually library independent.\n\nasync Beyond asyncio: Curio Python’s async/await language constructs are not tied to any specific event loop or library.17 Thanks to the extensible API provided by special methods, anyone suffi‐ ciently motivated can write their own asynchronous runtime environment and framework to drive native coroutines, asynchronous generators, etc.\n\nThat’s what David Beazley did in his Curio project. He was interested in rethinking how these new language features could be used in a framework built from scratch. Recall that asyncio was released in Python 3.4, and it used yield from instead of await, so its API could not leverage asynchronous context managers, asynchronous iterators, and everything else that the async/await keywords made possible. As a result, Curio has a cleaner API and a simpler implementation, compared to asyncio.\n\nExample 21-21 shows the blogdom.py script (Example 21-1) rewritten to use Curio.\n\nExample 21-21. blogdom.py: Example 21-1, now using Curio\n\n#!/usr/bin/env python3 from curio import run, TaskGroup import curio.socket as socket from keyword import kwlist\n\nMAX_KEYWORD_LEN = 4\n\nasync def probe(domain: str) -> tuple[str, bool]: try: await socket.getaddrinfo(domain, None) except socket.gaierror: return (domain, False) return (domain, True)\n\n17 That’s in contrast with JavaScript, where async/await is hardwired to the built-in event loop and runtime\n\nenvironment, i.e., a browser, Node.js, or Deno.\n\nasync Beyond asyncio: Curio\n\n|\n\n821",
      "content_length": 1923,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 852,
      "content": "async def main() -> None: names = (kw for kw in kwlist if len(kw) <= MAX_KEYWORD_LEN) domains = (f'{name}.dev'.lower() for name in names) async with TaskGroup() as group: for domain in domains: await group.spawn(probe, domain) async for task in group: domain, found = task.result mark = '+' if found else ' ' print(f'{mark} {domain}')\n\nif __name__ == '__main__': run(main())\n\nprobe doesn’t need to get the event loop, because…\n\n…getaddrinfo is a top-level function of curio.socket, not a method of a loop object—as it is in asyncio.\n\nA TaskGroup is a core concept in Curio, to monitor and control several corou‐ tines, and to make sure they are all executed and cleaned up.\n\nTaskGroup.spawn is how you start a coroutine, managed by a specific TaskGroup instance. The coroutine is wrapped by a Task.\n\nIterating with async for over a TaskGroup yields Task instances as each is completed. This corresponds in Example 21-1 using for … as_completed(…):.\n\nto\n\nthe\n\nline\n\nCurio pioneered this sensible way to start an asynchronous program in Python.\n\nTo expand on the last point: if you look at the asyncio code examples for the first edition of Fluent Python, you’ll see lines like these, repeated over and over:\n\nloop = asyncio.get_event_loop() loop.run_until_complete(main()) loop.close()\n\nA Curio TaskGroup is an asynchronous context manager that replaces several ad hoc APIs and coding patterns in asyncio. We just saw how iterating over a TaskGroup makes the asyncio.as_completed(…) function unnecessary. Another example: instead of a special gather function, this snippet from the “Task Groups” docs col‐ lects the results of all tasks in the group:\n\nasync with TaskGroup(wait=all) as g: await g.spawn(coro1) await g.spawn(coro2)\n\n822\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1775,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 853,
      "content": "await g.spawn(coro3) print('Results:', g.results)\n\nTask groups support structured concurrency: a form of concurrent programming that constrains all the activity of a group of asynchronous tasks to a single entry and exit point. This is analogous to structured programming, which eschewed the GOTO com‐ mand and introduced block statements to limit the entry and exit points of loops and subroutines. When used as an asynchronous context manager, a TaskGroup ensures that all tasks spawned inside are completed or cancelled, and any exceptions raised, upon exiting the enclosed block.\n\nStructured concurrency will probably be adopted by asyncio in upcoming Python releases. A strong indication appears in PEP 654–Exception Groups and except*, which was approved for Python 3.11. The “Motivation” section mentions Trio’s “nurseries,” their name for task groups: “Implementing a better task spawning API in asyncio, inspired by Trio nurseries, was the main motiva‐ tion for this PEP.”\n\nAnother important feature of Curio is better support for programming with corou‐ tines and threads in the same codebase—a necessity in most nontrivial asynchronous programs. Starting a thread with await spawn_thread(func, …) returns an Asyn cThread object with a Task-like interface. Threads can call coroutines thanks to a special AWAIT(coro) function—named in all caps because await is now a keyword.\n\nCurio also provides a UniversalQueue that can be used to coordinate the work among threads, Curio coroutines, and asyncio coroutines. That’s right, Curio has features that allow it to run in a thread along with asyncio in another thread, in the same process, communicating via UniversalQueue and UniversalEvent. The API for these “universal” classes is the same inside and outside of coroutines, but in a corou‐ tine, you need to prefix calls with await.\n\nAs I write this in October 2021, HTTPX is the first HTTP client library compatible with Curio, but I don’t know of any asynchronous database libraries that support it yet. In the Curio repository there is an impressive set of network programming exam‐ ples, including one using WebSocket, and another implementing the RFC 8305— Happy Eyeballs concurrent algorithm for connecting to IPv6 endpoints with fast fall‐ back to IPv4 if needed.\n\nThe design of Curio has been influential. The Trio framework started by Nathaniel J. Smith was heavily inspired by Curio. Curio may also have prompted Python contrib‐ utors to improve the usability of the asyncio API. For example, in its earliest releases, asyncio users very often had to get and pass around a loop object because some essential functions were either loop methods or required a loop argument. In recent\n\nasync Beyond asyncio: Curio\n\n|\n\n823",
      "content_length": 2737,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 854,
      "content": "versions of Python, direct access to the loop is not needed as often, and in fact several functions that accepted an optional loop are now deprecating that argument.\n\nType annotations for asynchronous types are our next topic.\n\nType Hinting Asynchronous Objects The return type of a native coroutine describes what you get when you await on that coroutine, which is the type of the object that appears in the return statements in the body of the native coroutine function.18\n\nThis chapter provided many examples of annotated native coroutines, including probe from Example 21-21:\n\nasync def probe(domain: str) -> tuple[str, bool]: try: await socket.getaddrinfo(domain, None) except socket.gaierror: return (domain, False) return (domain, True)\n\nIf you need to annotate a parameter that takes a coroutine object, then the generic type is:\n\nclass typing.Coroutine(Awaitable[V_co], Generic[T_co, T_contra, V_co]): ...\n\nThat type, and the following types were introduced in Python 3.5 and 3.6 to annotate asynchronous objects:\n\nclass typing.AsyncContextManager(Generic[T_co]): ... class typing.AsyncIterable(Generic[T_co]): ... class typing.AsyncIterator(AsyncIterable[T_co]): ... class typing.AsyncGenerator(AsyncIterator[T_co], Generic[T_co, T_contra]): ... class typing.Awaitable(Generic[T_co]): ...\n\nWith Python ≥ 3.9, use the collections.abc equivalents of these.\n\nI want to highlight three aspects of those generic types.\n\nFirst: they are all covariant on the first type parameter, which is the type of the items yielded from these objects. Recall rule #1 of “Variance rules of thumb” on page 551:\n\n18 This differs from the annotations of classic coroutines, as discussed in “Generic Type Hints for Classic\n\nCoroutines” on page 650.\n\n824\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 1780,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 855,
      "content": "If a formal type parameter defines a type for data that comes out of the object, it can be covariant.\n\nSecond: AsyncGenerator and Coroutine are contravariant on the second to last parameter. That’s the type of the argument of the low-level .send() method that the event loop calls to drive asynchronous generators and coroutines. As such, it is an “input” type. Therefore, it can be contravariant, per Variance Rule of Thumb #2:\n\nIf a formal type parameter defines a type for data that goes into the object after its ini‐ tial construction, it can be contravariant.\n\nThird: AsyncGenerator has no return type, in contrast with typing.Generator, which we saw in “Generic Type Hints for Classic Coroutines” on page 650. Returning a value by raising StopIteration(value) was one of the hacks that enabled genera‐ tors to operate as coroutines and support yield from, as we saw in “Classic Corou‐ tines” on page 641. There is no such overlap among the asynchronous objects: AsyncGenerator objects don’t return values, and are completely separate from native coroutine objects, which are annotated with typing.Coroutine.\n\nFinally, let’s briefly discuss the advantages and challenges of asynchronous programming.\n\nHow Async Works and How It Doesn’t The sections closing this chapter discuss high-level ideas around asynchronous pro‐ gramming, regardless of the language or library you are using.\n\nLet’s begin by explaining the #1 reason why asynchronous programming is appealing, followed by a popular myth, and how to deal with it.\n\nRunning Circles Around Blocking Calls Ryan Dahl, the inventor of Node.js, introduces the philosophy of his project by say‐ ing “We’re doing I/O completely wrong.”19 He defines a blocking function as one that does file or network I/O, and argues that we can’t treat them as we treat nonblocking functions. To explain why, he presents the numbers in the second column of Table 21-1.\n\n19 Video: “Introduction to Node.js” at 4:55.\n\nHow Async Works and How It Doesn’t\n\n|\n\n825",
      "content_length": 1997,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 856,
      "content": "Table 21-1. Modern computer latency for reading data from different devices; third column shows proportional times in a scale easier to understand for us slow humans\n\nDevice L1 cache\n\nCPU cycles 3\n\nProportional “human” scale 3 seconds\n\nL2 cache\n\n14\n\n14 seconds\n\nRAM\n\n250\n\n250 seconds\n\ndisk\n\n41,000,000\n\n1.3 years\n\nnetwork\n\n240,000,000\n\n7.6 years\n\nTo make sense of Table 21-1, bear in mind that modern CPUs with GHz clocks run billions of cycles per second. Let’s say that a CPU runs exactly 1 billion cycles per sec‐ ond. That CPU can make more than 333 million L1 cache reads in 1 second, or 4 (four!) network reads in the same time. The third column of Table 21-1 puts those numbers in perspective by multiplying the second column by a constant factor. So, in an alternate universe, if one read from L1 cache took 3 seconds, then a network read would take 7.6 years!\n\nTable 21-1 explains why a disciplined approach to asynchronous programming can lead to high-performance servers. The challenge is achieving that discipline. The first step is to recognize that “I/O bound system” is a fantasy.\n\nThe Myth of I/O-Bound Systems A commonly repeated meme is that asynchronous programming is good for “I/O bound systems.” I learned the hard way that there are no “I/O-bound systems.” You may have I/O-bound functions. Perhaps the vast majority of the functions in your system are I/O bound; i.e., they spend more time waiting for I/O than crunching data. While waiting, they cede control to the event loop, which can then drive some other pending task. But inevitably, any nontrivial system will have some parts that are CPU bound. Even trivial systems reveal that, under stress. In “Soapbox” on page 829, I tell the story of two asynchronous programs that struggled with CPU-bound func‐ tions slowing down the event loop with severe impact on performance.\n\nGiven that any nontrivial system will have CPU-bound functions, dealing with them is the key to success in asynchronous programming.\n\nAvoiding CPU-Bound Traps If you’re using Python at scale, you should have some automated tests designed specifically to detect performance regressions as soon as they appear. This is critically important with asynchronous code, but also relevant to threaded Python code— because of the GIL. If you wait until the slowdown starts bothering the development team, it’s too late. The fix will probably require some major makeover.\n\n826\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 2460,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 857,
      "content": "Here are some options for when you identify a CPU-hogging bottleneck:\n\nDelegate the task to a Python process pool.\n\nDelegate the task to an external task queue.\n\nRewrite the relevant code in Cython, C, Rust, or some other language that com‐ piles to machine code and interfaces with the Python/C API, preferably releasing the GIL.\n\nDecide that you can afford the performance hit and do nothing—but record the decision to make it easier to revert to it later.\n\nThe external task queue should be chosen and integrated as soon as possible at the start of the project, so that nobody in the team hesitates to use it when needed.\n\nThe last option—do nothing—falls in the category of technical debt.\n\nConcurrent programming is a fascinating topic, and I would like to write a lot more about it. But it is not the main focus of this book, and this is already one of the longest chapters, so let’s wrap it up.\n\nChapter Summary\n\nThe problem with normal approaches to asynchronous programming is that they’re all-or-nothing propositions. You rewrite all your code so none of it blocks or you’re just wasting your time.\n\n—Alvaro Videla and Jason J. W. Williams, RabbitMQ in Action\n\nI chose that epigraph for this chapter for two reasons. At a high level, it reminds us to avoid blocking the event loop by delegating slow tasks to a different processing unit, from a simple thread all the way to a distributed task queue. At a lower level, it is also a warning: once you write your first async def, your program is inevitably going to have more and more async def, await, async with, and async for. And using non- asynchronous libraries suddenly becomes a challenge.\n\nAfter the simple spinner examples in Chapter 19, here our main focus was asynchro‐ nous programming with native coroutines, starting with the blogdom.py DNS prob‐ ing example, followed by the concept of awaitables. While reading the source code of flags_asyncio.py, we found the first example of an asynchronous context manager.\n\nThe more advanced variations of the flag downloading program introduced two powerful functions: the asyncio.as_completed generator and the loop.run_in_exec utor coroutine. We also saw the concept and application of a semaphore to limit the number of concurrent downloads—as expected from well-behaved HTTP clients.\n\nChapter Summary\n\n|\n\n827",
      "content_length": 2325,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 858,
      "content": "Server-side asynchronous programming was presented through the mojifinder exam‐ ples: a FastAPI web service and tcp_mojifinder.py—the latter using just asyncio and the TCP protocol.\n\nAsynchronous iteration and asynchronous iterables were the next major topic, with sections on async for, Python’s async console, asynchronous generators, asynchro‐ nous generator expressions, and asynchronous comprehensions.\n\nThe last example in the chapter was blogdom.py rewritten with the Curio framework, to demonstrate how Python’s asynchronous features are not tied to the asyncio package. Curio also showcases the concept of structured concurrency, which may have an industry-wide impact, bringing more clarity to concurrent code.\n\nFinally, the sections under “How Async Works and How It Doesn’t” on page 825 discuss the main appeal of asynchronous programming, the misconception of “I/O- bound systems,” and dealing with the inevitable CPU-bound parts of your program.\n\nFurther Reading David Beazley’s PyOhio 2016 keynote “Fear and Awaiting in Async” is a fantastic, live-coded introduction to the potential of the language features made possible by Yury Selivanov’s contribution of the async/await keywords in Python 3.5. At one point, Beazley complains that await can’t be used in list comprehensions, but that was fixed by Selivanov in PEP 530—Asynchronous Comprehensions, implemented in Python 3.6 later in that same year. Apart from that, everything else in Beazley’s keynote is timeless, as he demonstrates how the asynchronous objects we saw in this chapter work, without the help of any framework—just a simple run function using .send(None) to drive coroutines. Only at the very end Beazley shows Curio, which he started that year as an experiment to see how far can you go doing asyn‐ chronous programming without a foundation of callbacks or futures, just coroutines. As it turns out, you can go very far—as demonstrated by the evolution of Curio and the later creation of Trio by Nathaniel J. Smith. Curio’s documentation has links to more talks by Beazley on the subject.\n\nBesides starting Trio, Nathaniel J. Smith wrote two deep blog posts that I highly rec‐ ommend: “Some thoughts on asynchronous API design in a post-async/await world”, contrasting the design of Curio with that of asyncio,and “Notes on structured concur‐ rency, or: Go statement considered harmful”, about structured concurrency. Smith also gave a long and informative answer to the question: “What is the core difference between asyncio and trio?” on StackOverflow.\n\nTo learn more about the asyncio package, I’ve mentioned the best written resources I know at the start of this chapter: the official documentation after the outstanding overhaul started by Yury Selivanov in 2018, and Caleb Hattingh’s book Using Asyncio in Python (O’Reilly). In the official documentation, make sure to read “Developing\n\n828\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 2924,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 859,
      "content": "with asyncio”: documenting the asyncio debug mode, and also discussing common mistakes and traps and how to avoid them.\n\nFor a very accessible, 30-minute introduction to asynchronous programming in gen‐ eral and also asyncio, watch Miguel Grinberg’s “Asynchronous Python for the Com‐ plete Beginner”, presented at PyCon 2017. Another great is “Demystifying Python’s Async and Await Keywords”, presented by Michael Ken‐ nedy, where among other things I learned about the unsync library that provides a decorator to delegate the execution of coroutines, I/O-bound functions, and CPU- bound functions to asyncio, threading, or multiprocessing as needed.\n\nintroduction\n\nAt EuroPython 2019, Lynn Root—a global leader of PyLadies—presented the excel‐ lent “Advanced asyncio: Solving Real-world Production Problems”, informed by her experience using Python as a staff engineer at Spotify.\n\nIn 2020, Łukasz Langa recorded a series of great videos about asyncio, starting with “Learn Python’s AsyncIO #1—The Async Ecosystem”. Langa also made the super cool video “AsyncIO + Music” for PyCon 2020 that not only shows asyncio applied in a very concrete event-oriented domain, but also explains it from the ground up.\n\nAnother area dominated by event-oriented programming is embedded systems. That’s why Damien George added support for async/await in his MicroPython inter‐ preter for microcontrollers. At PyCon Australia 2018, Matt Trentini demonstrated the uasyncio library, a subset of asyncio that is part of MicroPython’s standard library.\n\nFor higher-level thinking about async programming in Python, read the blog post “Python async frameworks—Beyond developer tribalism” by Tom Christie.\n\nFinally, I recommend “What Color Is Your Function?” by Bob Nystrom, discussing the incompatible execution models of plain functions versus async functions—a.k.a. coroutines—in JavaScript, Python, C#, and other languages. Spoiler alert: Nystrom’s conclusion is that the language that got this right is Go, where all functions are the same color. I like that about Go. But I also think Nathaniel J. Smith has a point when he wrote “Go statement considered harmful”. Nothing is perfect, and concurrent programming is always hard.\n\nSoapbox\n\nHow a Slow Function Almost Spoiled the uvloop Benchmarks\n\nIn 2016, Yury Selivanov released uvloop, “a fast, drop-in replacement of the built-in asyncio event loop.” The benchmarks presented in Selivanov’s blog post announcing the library in 2016 are very impressive. He wrote: “it is at least 2x faster than nodejs, gevent, as well as any other Python asynchronous framework. The performance of uvloop-based asyncio is close to that of Go programs.”\n\nFurther Reading\n\n|\n\n829",
      "content_length": 2696,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 860,
      "content": "However, the post reveals that uvloop is able to match the performance of Go under two conditions:\n\n1. Go is configured to use a single thread. That makes the Go runtime behave simi‐ larly to asyncio: concurrency is achieved via multiple coroutines driven by an event loop, all in the same thread.20\n\n2. The Python 3.5 code uses httptools in addition to uvloop itself.\n\nSelivanov explains that he wrote httptools after benchmarking uvloop with aiohttp— one of the first full-featured HTTP libraries built on asyncio:\n\nHowever, the performance bottleneck in aiohttp turned out to be its HTTP parser, which is so slow, that it matters very little how fast the underlying I/O library is. To make things more interesting, we created a Python binding for http-parser (Node.js HTTP parser C library, originally developed for NGINX). The library is called httptools, and is available on Github and PyPI.\n\nNow think about that: Selivanov’s HTTP performance tests consisted of a simple echo server written in the different languages/libraries, pounded by the wrk bench‐ marking tool. Most developers would consider a simple echo server an “I/O-bound system,” right? But it turned out that parsing HTTP headers is CPU bound, and it had a slow Python implementation in aiohttp in when Selivanov did the benchmarks in 2016. Whenever a function written in Python was parsing headers, the event loop was blocked. The impact was so significant that Selivanov went to the extra trouble of writing httptools. Without optimizing the CPU-bound code, the performance gains of a faster event loop were lost.\n\nDeath by a Thousand Cuts\n\nInstead of a simple echo server, imagine a complex and evolving Python system with tens of thousands of lines of asynchronous code, interfacing with many external libra‐ ries. Years ago I was asked to help diagnose performance problems in a system like that. It was written in Python 2.7 with the Twisted framework—a solid library and in many ways a precursor to asyncio itself.\n\nPython was used to build a façade for the web UI, integrating functionality provided by preexisting libraries and command-line tools written in other languages—but not designed for concurrent execution.\n\n20 Using a single thread was the default setting until Go 1.5 was released. Years before, Go had already earned a well-deserved reputation for enabling highly concurrent networked systems. One more evidence that concur‐ rency doesn’t require multiple threads or CPU cores.\n\n830\n\n|\n\nChapter 21: Asynchronous Programming",
      "content_length": 2516,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 861,
      "content": "The project was ambitious; it had been in development for more than a year already, but it was not in production yet.21 Over time, the developers noticed that the performance of the whole system was decreasing, and they were having a hard time finding the bottlenecks.\n\nWhat was happening: with each added feature, more CPU-bound code was slowing down Twisted’s event loop. Python’s role as a glue language meant there was a lot of data parsing and conversion between formats. There wasn’t a single bottleneck: the problem was spread over countless little functions added over months of develop‐ ment. Fixing that would require rethinking the architecture of the system, rewriting a lot of code, probably leveraging a task queue, and perhaps using microservices or cus‐ tom libraries written in languages better suited for CPU-intensive concurrent pro‐ cessing. The stakeholders were not prepared to make that additional investment, and the project was cancelled shortly afterwards.\n\nWhen I told this story to Glyph Lefkowitz—founder the Twisted project—he said that one of his priorities at the start of an asynchronous programming project is to decide which tools he will use to farm out the CPU-intensive tasks. This conversation with Glyph was the inspiration for “Avoiding CPU-Bound Traps” on page 826.\n\n21 Regardless of technical choices, this was probably the biggest mistake in this project: the stakeholders did not go for an MVP approach—delivering a Minimum Viable Product as soon as possible, and then adding fea‐ tures at a steady pace.\n\nFurther Reading\n\n|\n\n831",
      "content_length": 1574,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 863,
      "content": "PART V Metaprogramming",
      "content_length": 22,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 865,
      "content": "CHAPTER 22 Dynamic Attributes and Properties\n\nThe crucial importance of properties is that their existence makes it perfectly safe and indeed advisable for you to expose public data attributes as part of your class’s public interface.\n\n— Martelli, Ravenscroft, and Holden, “Why properties are important”1\n\nData attributes and methods are collectively known as attributes in Python. A method is an attribute that is callable. Dynamic attributes present the same interface as data attributes—i.e., obj.attr—but are computed on demand. This follows Ber‐ trand Meyer’s Uniform Access Principle:\n\nAll services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation.2\n\nThere are several ways to implement dynamic attributes in Python. This chapter cov‐ ers the simplest ways: the @property decorator and the __getattr__ special method.\n\nA user-defined class implementing __getattr__ can implement a variation of dynamic attributes that I call virtual attributes: attributes that are not explicitly declared anywhere in the source code of the class, and are not present in the instance __dict__, but may be retrieved elsewhere or computed on the fly whenever a user tries to read a nonexistent attribute like obj.no_such_attr.\n\nCoding dynamic and virtual attributes is the kind of metaprogramming that frame‐ work authors do. However, in Python the basic techniques are straightforward, so we can use them in everyday data wrangling tasks. That’s how we’ll start this chapter.\n\n1 Alex Martelli, Anna Ravenscroft, and Steve Holden, Python in a Nutshell, 3rd ed. (O’Reilly), p. 123.\n\n2 Bertrand Meyer, Object-Oriented Software Construction, 2nd ed. (Pearson), p. 57.\n\n835",
      "content_length": 1765,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 866,
      "content": "What’s New in This Chapter Most of the updates to this chapter were motivated by a discussion of @func tools.cached_property (introduced in Python 3.8), as well as the combined use of @property with @functools.cache (new in 3.9). This affected the code for the Record and Event classes that appear in “Computed Properties” on page 845. I also added a refactoring to leverage the PEP 412—Key-Sharing Dictionary optimization.\n\nTo highlight more relevant features while keeping the examples readable, I removed some nonessential code—merging the old DbRecord class into Record, replacing shelve.Shelve with a dict, and deleting the logic to download the OSCON dataset —which the examples now read from a local file included in the Fluent Python code repository.\n\nData Wrangling with Dynamic Attributes In the next few examples, we’ll leverage dynamic attributes to work with a JSON dataset published by O’Reilly for the OSCON 2014 conference. Example 22-1 shows four records from that dataset.3\n\nExample 22-1. Sample records from osconfeed.json; some field contents abbreviated\n\n{ \"Schedule\": { \"conferences\": [{\"serial\": 115 }], \"events\": [ { \"serial\": 34505, \"name\": \"Why Schools Don´t Use Open Source to Teach Programming\", \"event_type\": \"40-minute conference session\", \"time_start\": \"2014-07-23 11:30:00\", \"time_stop\": \"2014-07-23 12:10:00\", \"venue_serial\": 1462, \"description\": \"Aside from the fact that high school programming...\", \"website_url\": \"http://oscon.com/oscon2014/public/schedule/detail/34505\", \"speakers\": [157509], \"categories\": [\"Education\"] } ], \"speakers\": [ { \"serial\": 157509, \"name\": \"Robert Lefkowitz\", \"photo\": null, \"url\": \"http://sharewave.com/\", \"position\": \"CTO\",\n\n3 OSCON—O’Reilly Open Source Conference—was a casualty of the COVID-19 pandemic. The original 744\n\nKB JSON file I used for these examples is no longer online as of January 10, 2021. You’ll find a copy of oscon‐ feed.json in the example code repository.\n\n836\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 2000,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 867,
      "content": "\"affiliation\": \"Sharewave\", \"twitter\": \"sharewaveteam\", \"bio\": \"Robert ´r0ml´ Lefkowitz is the CTO at Sharewave, a startup...\" } ], \"venues\": [ { \"serial\": 1462, \"name\": \"F151\", \"category\": \"Conference Venues\" } ] } }\n\nExample 22-1 shows 4 of the 895 records in the JSON file. The entire dataset is a sin‐ gle JSON object with the key \"Schedule\", and its value is another mapping with four keys: \"conferences\", \"events\", \"speakers\", and \"venues\". Each of those four keys maps to a list of records. In the full dataset, the \"events\", \"speakers\", and \"venues\" lists have dozens or hundreds of records, while \"conferences\" has only that one record shown in Example 22-1. Every record has a \"serial\" field, which is a unique identifier for the record within the list.\n\nI used Python’s console to explore the dataset, as shown in Example 22-2.\n\nExample 22-2. Interactive exploration of osconfeed.json\n\n>>> import json >>> with open('data/osconfeed.json') as fp: ... feed = json.load(fp) >>> sorted(feed['Schedule'].keys()) ['conferences', 'events', 'speakers', 'venues'] >>> for key, value in sorted(feed['Schedule'].items()): ... print(f'{len(value):3} {key}') ... 1 conferences 484 events 357 speakers 53 venues >>> feed['Schedule']['speakers'][-1]['name'] 'Carina C. Zona' >>> feed['Schedule']['speakers'][-1]['serial'] 141590 >>> feed['Schedule']['events'][40]['name'] 'There *Will* Be Bugs' >>> feed['Schedule']['events'][40]['speakers'] [3471, 5199]\n\nfeed is a dict holding nested dicts and lists, with string and integer values.\n\nList the four record collections inside \"Schedule\".\n\nData Wrangling with Dynamic Attributes\n\n|\n\n837",
      "content_length": 1631,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 868,
      "content": "Display record counts for each collection.\n\nNavigate through the nested dicts and lists to get the name of the last speaker.\n\nGet the serial number of that same speaker.\n\nEach event has a 'speakers' list with zero or more speaker serial numbers.\n\nExploring JSON-Like Data with Dynamic Attributes Example 22-2 is simple enough, but the syntax feed['Schedule']['events'][40] ['name'] is cumbersome. In JavaScript, you can get the same value by writing feed.Schedule.events[40].name. It’s easy to implement a dict-like class that does the same in Python—there are plenty of implementations on the web.4 I wrote FrozenJSON, which is simpler than most recipes because it supports reading only: it’s just for exploring the data. FrozenJSON is also recursive, dealing automatically with nested mappings and lists.\n\nExample 22-3 is a demonstration of FrozenJSON, and the source code is shown in Example 22-4.\n\nExample 22-3. FrozenJSON from Example 22-4 allows reading attributes like name, and calling methods like .keys() and .items()\n\n>>> import json >>> raw_feed = json.load(open('data/osconfeed.json')) >>> feed = FrozenJSON(raw_feed) >>> len(feed.Schedule.speakers) 357 >>> feed.keys() dict_keys(['Schedule']) >>> sorted(feed.Schedule.keys()) ['conferences', 'events', 'speakers', 'venues'] >>> for key, value in sorted(feed.Schedule.items()): ... print(f'{len(value):3} {key}') ... 1 conferences 484 events 357 speakers 53 venues >>> feed.Schedule.speakers[-1].name 'Carina C. Zona' >>> talk = feed.Schedule.events[40] >>> type(talk)\n\n4 Two examples are AttrDict and addict.\n\n838\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1627,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 869,
      "content": "<class 'explore0.FrozenJSON'> >>> talk.name 'There *Will* Be Bugs' >>> talk.speakers [3471, 5199] >>> talk.flavor Traceback (most recent call last): ... KeyError: 'flavor'\n\nBuild a FrozenJSON instance from the raw_feed made of nested dicts and lists.\n\nFrozenJSON allows traversing nested dicts by using attribute notation; here we show the length of the list of speakers.\n\nMethods of the underlying dicts can also be accessed, like .keys(), to retrieve the record collection names.\n\nUsing items(), we can retrieve the record collection names and their contents, to display the len() of each of them.\n\nA list, such as feed.Schedule.speakers, remains a list, but the items inside are converted to FrozenJSON if they are mappings.\n\nItem 40 in the events list was a JSON object; now it’s a FrozenJSON instance.\n\nEvent records have a speakers list with speaker serial numbers.\n\nTrying to read a missing attribute raises KeyError, instead of the usual AttributeError.\n\nThe keystone of the FrozenJSON class is the __getattr__ method, which we already used in the Vector example in “Vector Take #3: Dynamic Attribute Access” on page 407, to retrieve Vector components by letter: v.x, v.y, v.z, etc. It’s essential to recall that the __getattr__ special method is only invoked by the interpreter when the usual process fails to retrieve an attribute (i.e., when the named attribute cannot be found in the instance, nor in the class or in its superclasses).\n\nThe last line of Example 22-3 exposes a minor issue with my code: trying to read a missing attribute should raise AttributeError, and not KeyError as shown. When I implemented the error handling to do that, the __getattr__ method became twice as long, distracting from the most important logic I wanted to show. Given that users would know that a FrozenJSON is built from mappings and lists, I think the KeyError is not too confusing.\n\nData Wrangling with Dynamic Attributes\n\n|\n\n839",
      "content_length": 1931,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 870,
      "content": "Example 22-4. explore0.py: turn a JSON dataset into a FrozenJSON holding nested FrozenJSON objects, lists, and simple types\n\nfrom collections import abc\n\nclass FrozenJSON: \"\"\"A read-only façade for navigating a JSON-like object using attribute notation \"\"\"\n\ndef __init__(self, mapping): self.__data = dict(mapping)\n\ndef __getattr__(self, name): try: return getattr(self.__data, name) except AttributeError: return FrozenJSON.build(self.__data[name])\n\ndef __dir__(self): return self.__data.keys()\n\n@classmethod def build(cls, obj): if isinstance(obj, abc.Mapping): return cls(obj) elif isinstance(obj, abc.MutableSequence): return [cls.build(item) for item in obj] else: return obj\n\nBuild a dict from the mapping argument. This ensures we get a mapping or something that can be converted to one. The double-underscore prefix on __data makes it a private attribute.\n\n__getattr__ is called only when there’s no attribute with that name.\n\nIf name matches an attribute of the instance __data dict, return that. This is how calls like feed.keys() are handled: the keys method is an attribute of the __data dict.\n\n840\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1160,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 871,
      "content": "Otherwise, fetch the item with the key name from self.__data, and return the result of calling FrozenJSON.build() on that.5\n\nImplementing __dir__ suports the dir() built-in, which in turns supports auto- completion in the standard Python console as well as IPython, Jupyter Notebook, etc. This simple code will enable recursive auto-completion based on the keys in self.__data, because __getattr__ builds FrozenJSON instances on the fly—use‐ ful for interactive exploration of the data.\n\nThis is an alternate constructor, a common use for the @classmethod decorator.\n\nIf obj is a mapping, build a FrozenJSON with it. This is an example of goose typ‐ ing—see “Goose Typing” on page 442 if you need a refresher.\n\nIf it is a MutableSequence, it must be a list,6 so we build a list by passing each item in obj recursively to .build().\n\nIf it’s not a dict or a list, return the item as it is.\n\nA FrozenJSON instance has the __data private instance attribute stored under the name _FrozenJSON__data, as explained in “Private and ‘Protected’ Attributes in Python” on page 382. Attempts to retrieve attributes by other names will trigger __getattr__. This method will first look if the self.__data dict has an attribute (not a key!) by that name; this allows FrozenJSON instances to handle dict methods such as items, by delegating to self.__data.items(). If self.__data doesn’t have an attribute with the given name, __getattr__ uses name as a key to retrieve an item from self.__data, and passes that item to FrozenJSON.build. This allows navigating through nested structures in the JSON data, as each nested mapping is converted to another FrozenJSON instance by the build class method.\n\nNote that FrozenJSON does not transform or cache the original dataset. As we tra‐ verse the data, __getattr__ creates FrozenJSON instances again and again. That’s OK for a dataset of this size, and for a script that will only be used to explore or convert the data.\n\n5 The expression self.__data[name] is where a KeyError exception may occur. Ideally, it should be handled\n\nand an AttributeError raised instead, because that’s what is expected from __getattr__. The diligent reader is invited to code the error handling as an exercise.\n\n6 The source of the data is JSON, and the only collection types in JSON data are dict and list.\n\nData Wrangling with Dynamic Attributes\n\n|\n\n841",
      "content_length": 2363,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 872,
      "content": "Any script that generates or emulates dynamic attribute names from arbitrary sour‐ ces must deal with one issue: the keys in the original data may not be suitable attribute names. The next section addresses this.\n\nThe Invalid Attribute Name Problem The FrozenJSON code doesn’t handle attribute names that are Python keywords. For example, if you build an object like this:\n\n>>> student = FrozenJSON({'name': 'Jim Bo', 'class': 1982})\n\nYou won’t be able to read student.class because class is a reserved keyword in Python:\n\n>>> student.class File \"<stdin>\", line 1 student.class ^ SyntaxError: invalid syntax\n\nYou can always do this, of course:\n\n>>> getattr(student, 'class') 1982\n\nBut the idea of FrozenJSON is to provide convenient access to the data, so a better solution is checking whether a key in the mapping given to FrozenJSON.__init__ is a keyword, and if so, append an _ to it, so the attribute can be read like this:\n\n>>> student.class_ 1982\n\nThis can be achieved by replacing the one-liner __init__ from Example 22-4 with the version in Example 22-5.\n\nExample 22-5. explore1.py: append an _ to attribute names that are Python keywords\n\ndef __init__(self, mapping): self.__data = {} for key, value in mapping.items(): if keyword.iskeyword(key): key += '_' self.__data[key] = value\n\nThe keyword.iskeyword(…) function is exactly what we need; to use it, the key word module must be imported, which is not shown in this snippet.\n\nA similar problem may arise if a key in a JSON record is not a valid Python identifier:\n\n>>> x = FrozenJSON({'2be':'or not'}) >>> x.2be\n\n842\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1628,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 873,
      "content": "File \"<stdin>\", line 1 x.2be ^ SyntaxError: invalid syntax\n\nSuch problematic keys are easy to detect in Python 3 because the str class provides the s.isidentifier() method, which tells you whether s is a valid Python identifier according to the language grammar. But turning a key that is not a valid identifier into a valid attribute name is not trivial. One solution would be to implement __geti tem__ to allow attribute access using notation like x['2be']. For the sake of simplic‐ ity, I will not worry about this issue.\n\nAfter giving some thought to the dynamic attribute names, let’s turn to another essential feature of FrozenJSON: the logic of the build class method. Fro zen.JSON.build is used by __getattr__ to return a different type of object depend‐ ing on the value of the attribute being accessed: nested structures are converted to FrozenJSON instances or lists of FrozenJSON instances.\n\nInstead of a class method, the same logic could be implemented as the __new__ spe‐ cial method, as we’ll see next.\n\nFlexible Object Creation with __new__ We often refer to __init__ as the constructor method, but that’s because we adopted jargon from other languages. In Python, __init__ gets self as the first argument, therefore the object already exists when __init__ is called by the interpreter. Also, __init__ cannot return anything. So it’s really an initializer, not a constructor.\n\nWhen a class is called to create an instance, the special method that Python calls on that class to construct an instance is __new__. It’s a class method, but gets special treatment, so the @classmethod decorator is not applied to it. Python takes the instance returned by __new__ and then passes it as the first argument self of __init__. We rarely need to code __new__, because the implementation inherited from object suffices for the vast majority of use cases.\n\nIf necessary, the __new__ method can also return an instance of a different class. When that happens, the interpreter does not call __init__. In other words, Python’s logic for building an object is similar to this pseudocode:\n\n# pseudocode for object construction def make(the_class, some_arg): new_object = the_class.__new__(some_arg) if isinstance(new_object, the_class): the_class.__init__(new_object, some_arg) return new_object\n\n# the following statements are roughly equivalent\n\nData Wrangling with Dynamic Attributes\n\n|\n\n843",
      "content_length": 2393,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 874,
      "content": "x = Foo('bar') x = make(Foo, 'bar')\n\nExample 22-6 shows a variation of FrozenJSON where the logic of the former build class method was moved to __new__.\n\nExample 22-6. explore2.py: using __new__ instead of build to construct new objects that may or may not be instances of FrozenJSON\n\nfrom collections import abc import keyword\n\nclass FrozenJSON: \"\"\"A read-only façade for navigating a JSON-like object using attribute notation \"\"\"\n\ndef __new__(cls, arg): if isinstance(arg, abc.Mapping): return super().__new__(cls) elif isinstance(arg, abc.MutableSequence): return [cls(item) for item in arg] else: return arg\n\ndef __init__(self, mapping): self.__data = {} for key, value in mapping.items(): if keyword.iskeyword(key): key += '_' self.__data[key] = value\n\ndef __getattr__(self, name): try: return getattr(self.__data, name) except AttributeError: return FrozenJSON(self.__data[name])\n\ndef __dir__(self): return self.__data.keys()\n\nAs a class method, the first argument __new__ gets is the class itself, and the remaining arguments are the same that __init__ gets, except for self.\n\nThe default behavior is to delegate to the __new__ of a superclass. In this case, we are calling __new__ from the object base class, passing FrozenJSON as the only argument.\n\nThe remaining lines of __new__ are exactly as in the old build method.\n\n844\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1384,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 875,
      "content": "This was where FrozenJSON.build was called before; now we just call the FrozenJSON class, which Python handles by calling FrozenJSON.__new__.\n\nThe __new__ method gets the class as the first argument because, usually, the created object will be an instance of that class. So, in FrozenJSON.__new__, when the expression super().__new__(cls) effectively calls object.__new__(FrozenJSON), the instance built by the object class is actually an instance of FrozenJSON. The __class__ attribute of the new instance will hold a reference to FrozenJSON, even though the actual construction is performed by object.__new__, implemented in C, in the guts of the interpreter.\n\nThe OSCON JSON dataset is structured in a way that is not helpful for interactive exploration. For example, the event at index 40, titled 'There *Will* Be Bugs' has two speakers, 3471 and 5199. Finding the names of the speakers is awkward, because those are serial numbers and the Schedule.speakers list is not indexed by them. To get each speaker, we must iterate over that list until we find a record with a matching serial number. Our next task is restructuring the data to prepare for automatic retrieval of linked records.\n\nComputed Properties We first saw the @property decorator in Chapter 11, in the section, “A Hashable Vec‐ tor2d” on page 374. In Example 11-7, I used two properties in Vector2d just to make the x and y attributes read-only. Here we will see properties that compute values, leading to a discussion of how to cache such values.\n\nThe records in the 'events' list of the OSCON JSON data contain integer serial numbers pointing to records in the 'speakers' and 'venues' lists. For example, this is the record for a conference talk (with an elided description):\n\n{ \"serial\": 33950, \"name\": \"There *Will* Be Bugs\", \"event_type\": \"40-minute conference session\", \"time_start\": \"2014-07-23 14:30:00\", \"time_stop\": \"2014-07-23 15:10:00\", \"venue_serial\": 1449, \"description\": \"If you're pushing the envelope of programming...\", \"website_url\": \"http://oscon.com/oscon2014/public/schedule/detail/33950\", \"speakers\": [3471, 5199], \"categories\": [\"Python\"] }\n\nWe will implement an Event class with venue and speakers properties to return the linked data automatically—in other words, “dereferencing” the serial number. Given an Event instance, Example 22-7 shows the desired behavior.\n\nComputed Properties\n\n|\n\n845",
      "content_length": 2388,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 876,
      "content": "Example 22-7. Reading venue and speakers returns Record objects\n\n>>> event <Event 'There *Will* Be Bugs'> >>> event.venue <Record serial=1449> >>> event.venue.name 'Portland 251' >>> for spkr in event.speakers: ... print(f'{spkr.serial}: {spkr.name}') ... 3471: Anna Martelli Ravenscroft 5199: Alex Martelli\n\nGiven an Event instance…\n\n…reading event.venue returns a Record object instead of a serial number.\n\nNow it’s easy to get the name of the venue.\n\nThe event.speakers property returns a list of Record instances.\n\nAs usual, we will build the code step-by-step, starting with the Record class and a function to read the JSON data and return a dict with Record instances.\n\nStep 1: Data-Driven Attribute Creation Example 22-8 shows the doctest to guide this first step.\n\nExample 22-8. Test-driving schedule_v1.py (from Example 22-9)\n\n>>> records = load(JSON_PATH) >>> speaker = records['speaker.3471'] >>> speaker <Record serial=3471> >>> speaker.name, speaker.twitter ('Anna Martelli Ravenscroft', 'annaraven')\n\nload a dict with the JSON data.\n\nThe keys in records are strings built from the record type and serial number.\n\nspeaker is an instance of the Record class defined in Example 22-9.\n\nFields from the original JSON can be retrieved as Record instance attributes.\n\nThe code for schedule_v1.py is in Example 22-9.\n\n846\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1377,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 877,
      "content": "Example 22-9. schedule_v1.py: reorganizing the OSCON schedule data\n\nimport json\n\nJSON_PATH = 'data/osconfeed.json'\n\nclass Record: def __init__(self, **kwargs): self.__dict__.update(kwargs)\n\ndef __repr__(self): return f'<{self.__class__.__name__} serial={self.serial!r}>'\n\ndef load(path=JSON_PATH): records = {} with open(path) as fp: raw_data = json.load(fp) for collection, raw_records in raw_data['Schedule'].items(): record_type = collection[:-1] for raw_record in raw_records: key = f'{record_type}.{raw_record[\"serial\"]}' records[key] = Record(**raw_record) return records\n\nThis is a common shortcut to build an instance with attributes created from key‐ word arguments (detailed explanation follows).\n\nUse the serial field to build the custom Record representation shown in Example 22-8.\n\nload will ultimately return a dict of Record instances.\n\nParse the JSON, returning native Python objects: lists, dicts, strings, numbers, etc.\n\nIterate over the four top-level lists named 'conferences', 'events', 'speak ers', and 'venues'.\n\nrecord_type is the list name without the last character, so speakers becomes speaker. In Python ≥ 3.9 we can do this more explicitly with collection.remove suffix('s')—see PEP 616—String methods to remove prefixes and suffixes.\n\nBuild the key in the format 'speaker.3471'.\n\nCreate a Record instance and save it in records with the key.\n\nComputed Properties\n\n|\n\n847",
      "content_length": 1400,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 878,
      "content": "The Record.__init__ method illustrates an old Python hack. Recall that the __dict__ of an object is where its attributes are kept—unless __slots__ is declared in the class, as we saw in “Saving Memory with __slots__” on page 384. So, updating an instance __dict__ with a mapping is a quick way to create a bunch of attributes in that instance.7\n\nDepending on the application, the Record class may need to deal with keys that are not valid attribute names, as we saw in “The Invalid Attribute Name Problem” on page 842. Dealing with that issue would distract from the key idea of this example, and is not a problem in the dataset we are reading.\n\nThe definition of Record in Example 22-9 is so simple that you may be wondering why I did not use it before, instead of the more complicated FrozenJSON. There are two reasons. First, FrozenJSON works by recursively converting the nested mappings and lists; Record doesn’t need that because our converted dataset doesn’t have map‐ pings nested in mappings or lists. The records contain only strings, integers, lists of strings, and lists of integers. Second reason: FrozenJSON provides access to the embedded __data dict attributes—which we used to invoke methods like .keys()— and now we don’t need that functionality either.\n\nThe Python standard library provides classes similar to Record, where each instance has an arbitrary set of attributes built from keyword arguments given to __init__: types.SimpleNamespace, argparse.Namespace, and multiprocessing.managers.Name space. I wrote the simpler Record class to highlight the essential idea: __init__ updating the instance __dict__.\n\nAfter reorganizing the schedule dataset, we can enhance the Record class to automat‐ ically retrieve venue and speaker records referenced in an event record. We’ll use properties to do that in the next examples.\n\nStep 2: Property to Retrieve a Linked Record The goal of this next version is: given an event record, reading its venue property will return a Record. This is similar to what the Django ORM does when you access a ForeignKey field: instead of the key, you get the linked model object.\n\n7 By the way, Bunch is the name of the class used by Alex Martelli to share this tip in a recipe from 2001 titled\n\n“The simple but handy ‘collector of a bunch of named stuff’ class”.\n\n848\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 2367,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 879,
      "content": "We’ll start with the venue property. See the partial interaction in Example 22-10 as an example.\n\nExample 22-10. Extract from the doctests of schedule_v2.py\n\n>>> event = Record.fetch('event.33950') >>> event <Event 'There *Will* Be Bugs'> >>> event.venue <Record serial=1449> >>> event.venue.name 'Portland 251' >>> event.venue_serial 1449\n\nThe Record.fetch static method gets a Record or an Event from the dataset.\n\nNote that event is an instance of the Event class.\n\nAccessing event.venue returns a Record instance.\n\nNow it’s easy to find out the name of an event.venue.\n\nThe Event instance also has a venue_serial attribute, from the JSON data.\n\nEvent is a subclass of Record adding a venue to retrieve linked records, and a special‐ ized __repr__ method.\n\nThe code for this section is in the schedule_v2.py module in the Fluent Python code repository. The example has nearly 60 lines, so I’ll present it in parts, starting with the enhanced Record class.\n\nExample 22-11. schedule_v2.py: Record class with a new fetch method\n\nimport inspect import json\n\nJSON_PATH = 'data/osconfeed.json'\n\nclass Record:\n\n__index = None\n\ndef __init__(self, **kwargs): self.__dict__.update(kwargs)\n\ndef __repr__(self): return f'<{self.__class__.__name__} serial={self.serial!r}>'\n\nComputed Properties\n\n|\n\n849",
      "content_length": 1292,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 880,
      "content": "@staticmethod def fetch(key): if Record.__index is None: Record.__index = load() return Record.__index[key]\n\ninspect will be used in load, listed in Example 22-13.\n\nThe __index private class attribute will eventually hold a reference to the dict returned by load.\n\nfetch is a staticmethod to make it explicit that its effect is not influenced by the instance or class on which it is called.\n\nPopulate the Record.__index, if needed.\n\nUse it to retrieve the record with the given key.\n\nThis is one example where the use of staticmethod makes sense. The fetch method always acts on the Record.__index class attribute, even if invoked from a subclass, like Event.fetch()— which we’ll soon explore. It would be misleading to code it as a class method because the cls first argument would not be used.\n\nNow we get to the use of a property in the Event class, listed in Example 22-12.\n\nExample 22-12. schedule_v2.py: the Event class\n\nclass Event(Record):\n\ndef __repr__(self): try: return f'<{self.__class__.__name__} {self.name!r}>' except AttributeError: return super().__repr__()\n\n@property def venue(self): key = f'venue.{self.venue_serial}' return self.__class__.fetch(key)\n\n850\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1225,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 881,
      "content": "Event extends Record.\n\nIf the instance has a name attribute, it is used to produce a custom representation. Otherwise, delegate to the __repr__ from Record.\n\nThe venue property builds a key from the venue_serial attribute, and passes it to the fetch class method, inherited from Record (the reason for using self.__class__ is explained shortly).\n\nthe venue method of Example 22-12 returns self The second .__class__.fetch(key). Why not simply call self.fetch(key)? The simpler form works with the specific OSCON dataset because there is no event record with a 'fetch' key. But, if an event record had a key named 'fetch', then within that spe‐ cific Event instance, the reference self.fetch would retrieve the value of that field, instead of the fetch class method that Event inherits from Record. This is a subtle bug, and it could easily sneak through testing because it depends on the dataset.\n\nline of\n\nWhen creating instance attribute names from data, there is always the risk of bugs due to shadowing of class attributes—such as methods—or data loss through accidental overwriting of existing instance attributes. These problems may explain why Python dicts are not like JavaScript objects in the first place.\n\nIf the Record class behaved more like a mapping, implementing a dynamic __geti tem__ instead of a dynamic __getattr__, there would be no risk of bugs from over‐ writing or shadowing. A custom mapping is probably the Pythonic way to implement Record. But if I took that road, we’d not be studying the tricks and traps of dynamic attribute programming.\n\nThe final piece of this example is the revised load function in Example 22-13.\n\nExample 22-13. schedule_v2.py: the load function\n\ndef load(path=JSON_PATH): records = {} with open(path) as fp: raw_data = json.load(fp) for collection, raw_records in raw_data['Schedule'].items(): record_type = collection[:-1] cls_name = record_type.capitalize() cls = globals().get(cls_name, Record) if inspect.isclass(cls) and issubclass(cls, Record): factory = cls else: factory = Record\n\nComputed Properties\n\n|\n\n851",
      "content_length": 2069,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 882,
      "content": "for raw_record in raw_records: key = f'{record_type}.{raw_record[\"serial\"]}' records[key] = factory(**raw_record) return records\n\nSo far, no changes from the load in schedule_v1.py (Example 22-9).\n\nCapitalize the record_type to get a possible class name; e.g., 'event' becomes 'Event'.\n\nGet an object by that name from the module global scope; get the Record class if there’s no such object.\n\nIf the object just retrieved is a class, and is a subclass of Record…\n\n…bind the factory name to it. This means factory may be any subclass of Record, depending on the record_type.\n\nOtherwise, bind the factory name to Record.\n\nThe for loop that creates the key and saves the records is the same as before, except that…\n\n…the object stored in records is constructed by factory, which may be Record or a subclass like Event, selected according to the record_type.\n\nNote that the only record_type that has a custom class is Event, but if classes named Speaker or Venue are coded, load will automatically use those classes when building and saving records, instead of the default Record class.\n\nWe’ll now apply the same idea to a new speakers property in the Events class.\n\nStep 3: Property Overriding an Existing Attribute The name of the venue property in Example 22-12 does not match a field name in records of the \"events\" collection. Its data comes from a venue_serial field name. In contrast, each record in the events collection has a speakers field with a list of serial numbers. We want to expose that information as a speakers property in Event instances, which returns a list of Record instances. This name clash requires some special attention, as Example 22-14 reveals.\n\nExample 22-14. schedule_v3.py: the speakers property\n\n@property def speakers(self):\n\n852\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1811,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 883,
      "content": "spkr_serials = self.__dict__['speakers'] fetch = self.__class__.fetch return [fetch(f'speaker.{key}') for key in spkr_serials]\n\nThe data we want is in a speakers attribute, but we must retrieve it directly from the instance __dict__ to avoid a recursive call to the speakers property.\n\nReturn a list of all records with keys corresponding to the numbers in spkr_serials.\n\nInside the speakers method, trying to read self.speakers will invoke the property itself, quickly raising a RecursionError. However, if we read the same data via self.__dict__['speakers'], Python’s usual algorithm for retrieving attributes is bypassed, the property is not called, and the recursion is avoided. For this reason, reading or writing data directly to an object’s __dict__ is a common Python meta‐ programming trick.\n\nThe interpreter evaluates obj.my_attr by first looking at the class of obj. If the class has a property with the my_attr name, that property shadows an instance attribute by the same name. Exam‐ ples in “Properties Override Instance Attributes” on page 861 will demonstrate this, and Chapter 23 will reveal that a property is implemented as a descriptor—a more powerful and general abstraction.\n\nAs I coded the list comprehension in Example 22-14, my programmer’s lizard brain thought: “This may be expensive.” Not really, because events in the OSCON dataset have few speakers, so coding anything more complicated would be premature opti‐ mization. However, caching a property is a common need—and there are caveats. So let’s see how to do that in the next examples.\n\nStep 4: Bespoke Property Cache Caching properties is a common need because there is an expectation that an expres‐ sion like event.venue should be inexpensive.8 Some form of caching could become necessary if the Record.fetch method behind the Event properties needed to query a database or a web API.\n\n8 This is actually a downside of Meyer’s Uniform Access Principle, which I mentioned in the opening of this\n\nchapter. Read the optional “Soapbox” on page 875 if you’re interested in this discussion.\n\nComputed Properties\n\n|\n\n853",
      "content_length": 2099,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 884,
      "content": "In the first edition Fluent Python, I coded the custom caching logic for the speakers method, as shown in Example 22-15.\n\nExample 22-15. Custom caching logic using hasattr disables key-sharing optimization\n\n@property def speakers(self): if not hasattr(self, '__speaker_objs'): spkr_serials = self.__dict__['speakers'] fetch = self.__class__.fetch self.__speaker_objs = [fetch(f'speaker.{key}') for key in spkr_serials] return self.__speaker_objs\n\nIf the instance doesn’t have an attribute named __speaker_objs, fetch the speaker objects and store them there.\n\nReturn self.__speaker_objs.\n\nThe handmade caching in Example 22-15 is straightforward, but creating an attribute after the instance is initialized defeats the PEP 412—Key-Sharing Dictionary optimi‐ zation, as explained in “Practical Consequences of How dict Works” on page 102. Depending on the size of the dataset, the difference in memory usage may be impor‐ tant.\n\nA similar hand-rolled solution that works well with the key-sharing optimization requires coding an __init__ for the Event class, to create the necessary __speaker_objs initialized to None, and then checking for that in the speakers method. See Example 22-16.\n\nExample 22-16. Storage defined in __init__ to leverage key-sharing optimization\n\nclass Event(Record):\n\ndef __init__(self, **kwargs): self.__speaker_objs = None super().__init__(**kwargs)\n\n# 15 lines omitted... @property def speakers(self): if self.__speaker_objs is None: spkr_serials = self.__dict__['speakers'] fetch = self.__class__.fetch self.__speaker_objs = [fetch(f'speaker.{key}') for key in spkr_serials] return self.__speaker_objs\n\n854\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1684,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 885,
      "content": "Examples 22-15 and 22-16 illustrate simple caching techniques that are fairly com‐ mon in legacy Python codebases. However, in multithreaded programs, handmade caches like those introduce race conditions that may lead to corrupted data. If two threads are reading a property that was not previously cached, the first thread will need to compute the data for the cache attribute (__speaker_objs in the examples) and the second thread may read a cached value that is not yet complete.\n\nFortunately, Python 3.8 introduced the @functools.cached_property decorator, which is thread safe. Unfortunately, it comes with a couple of caveats, explained next.\n\nStep 5: Caching Properties with functools The functools module provides three decorators for caching. We saw @cache and @lru_cache in “Memoization with functools.cache” on page 320 (Chapter 9). Python 3.8 introduced @cached_property.\n\nThe functools.cached_property decorator caches the result of the method in an instance attribute with the same name. For example, in Example 22-17, the value computed by the venue method is stored in a venue attribute in self. After that, when client code tries to read venue, the newly created venue instance attribute is used instead of the method.\n\nExample 22-17. Simple use of a @cached_property\n\n@cached_property def venue(self): key = f'venue.{self.venue_serial}' return self.__class__.fetch(key)\n\nIn “Step 3: Property Overriding an Existing Attribute” on page 852, we saw that a property shadows an instance attribute by the same name. If that is true, how can @cached_property work? If the property overrides the instance attribute, the venue attribute will be ignored and the venue method will always be called, computing the key and running fetch every time!\n\nThe answer is a bit sad: cached_property is a misnomer. The @cached_property decorator does not create a full-fledged property, it creates a nonoverriding descriptor. A descriptor is an object that manages the access to an attribute in another class. We will dive into descriptors in Chapter 23. The property decorator is a high-level API to create an overriding descriptor. Chapter 23 will include a through explanation about overriding versus nonoverriding descriptors.\n\nFor now, let us set aside the underlying implementation and focus on the differences between cached_property and property from a user’s point of view. Raymond Het‐ tinger explains them very well in the Python docs:\n\nComputed Properties\n\n|\n\n855",
      "content_length": 2471,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 886,
      "content": "The mechanics of cached_property() are somewhat different from property(). A regular property blocks attribute writes unless a setter is defined. In contrast, a cached_property allows writes. The cached_property decorator only runs on lookups and only when an attribute of the same name doesn’t exist. When it does run, the cached_property writes to the attribute with the same name. Subsequent attribute reads and writes take precedence over the cached_property method and it works like a normal attribute. The cached value can be cleared by deleting the attribute. This allows the cached_prop erty method to run again.9\n\nBack to our Event class: the specific behavior of @cached_property makes it unsuita‐ ble to decorate speakers, because that method relies on an existing attribute also named speakers, containing the serial numbers of the event speakers.\n\n@cached_property has some important limitations:\n\nIt cannot be used as a drop-in replacement to @property if the decorated method already depends on an instance attribute with the same name.\n\nIt cannot be used in a class that defines __slots__.\n\nIt defeats the key-sharing optimization of the instance __dict__, because it creates an instance attribute after __init__.\n\nDespite these limitations, @cached_property addresses a common need in a simple way, and it is thread safe. Its Python code is an example of using a reentrant lock.\n\nThe @cached_property documentation recommends an alternative solution that we can use with speakers: stacking @property and @cache decorators, as shown in Example 22-18.\n\nExample 22-18. Stacking @property on @cache\n\n@property @cache def speakers(self): spkr_serials = self.__dict__['speakers'] fetch = self.__class__.fetch\n\n9 Source: @functools.cached_property documentation. I know Raymond Hettinger authored this explanation\n\nbecause he wrote it as a response to an issue I filed: bpo42781—functools.cached_property docs should explain that it is non-overriding. Hettinger is a major contributor to the official Python docs and standard library. He also wrote the excellent “Descriptor HowTo Guide”, a key resource for Chapter 23.\n\n856\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 2184,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 887,
      "content": "return [fetch(f'speaker.{key}') for key in spkr_serials]\n\nThe order is important: @property goes on top…\n\n…of @cache.\n\nRecall from “Stacked Decorators” on page 322 the meaning of that syntax. The top three lines of Example 22-18 are similar to:\n\nspeakers = property(cache(speakers))\n\nThe @cache is applied to speakers, returning a new function. That function then is decorated by @property, which replaces it with a newly constructed property.\n\nThis wraps up our discussion of read-only properties and caching decorators, explor‐ ing the OSCON dataset. In the next section, we start a new series of examples creat‐ ing read/write properties.\n\nUsing a Property for Attribute Validation Besides computing attribute values, properties are also used to enforce business rules by changing a public attribute into an attribute protected by a getter and setter without affecting client code. Let’s work through an extended example.\n\nLineItem Take #1: Class for an Item in an Order Imagine an app for a store that sells organic food in bulk, where customers can order nuts, dried fruit, or cereals by weight. In that system, each order would hold a sequence of line items, and each line item could be represented by an instance of a class, as in Example 22-19.\n\nExample 22-19. bulkfood_v1.py: the simplest LineItem class\n\nclass LineItem:\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\nThat’s nice and simple. Perhaps too simple. Example 22-20 shows a problem.\n\nUsing a Property for Attribute Validation\n\n|\n\n857",
      "content_length": 1629,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 888,
      "content": "Example 22-20. A negative weight results in a negative subtotal\n\n>>> raisins = LineItem('Golden raisins', 10, 6.95) >>> raisins.subtotal() 69.5 >>> raisins.weight = -20 # garbage in... >>> raisins.subtotal() # garbage out... -139.0\n\nThis is a toy example, but not as fanciful as you may think. Here is a story from the early days of Amazon.com:\n\nWe found that customers could order a negative quantity of books! And we would credit their credit card with the price and, I assume, wait around for them to ship the books.\n\n— Jeff Bezos, founder and CEO of Amazon.com10\n\nHow do we fix this? We could change the interface of LineItem to use a getter and a setter for the weight attribute. That would be the Java way, and it’s not wrong.\n\nOn the other hand, it’s natural to be able to set the weight of an item by just assign‐ ing to it; and perhaps the system is in production with other parts already accessing item.weight directly. In this case, the Python way would be to replace the data attribute with a property.\n\nLineItem Take #2: A Validating Property Implementing a property will allow us to use a getter and a setter, but the interface of LineItem will not change (i.e., setting the weight of a LineItem will still be written as raisins.weight = 12).\n\nExample 22-21 lists the code for a read/write weight property.\n\nExample 22-21. bulkfood_v2.py: a LineItem with a weight property\n\nclass LineItem:\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\n10 Direct quote by Jeff Bezos in the Wall Street Journal story, “Birth of a Salesman” (October 15, 2011). Note that\n\nas of 2021, you need a subscription to read the article.\n\n858\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1806,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 889,
      "content": "@property def weight(self): return self.__weight\n\n@weight.setter def weight(self, value): if value > 0: self.__weight = value else: raise ValueError('value must be > 0')\n\nHere the property setter is already in use, making sure that no instances with negative weight can be created.\n\n@property decorates the getter method.\n\nAll the methods that implement a property share the name of the public attribute: weight.\n\nThe actual value is stored in a private attribute __weight.\n\nThe decorated getter has a .setter attribute, which is also a decorator; this ties the getter and setter together.\n\nIf the value is greater than zero, we set the private __weight.\n\nOtherwise, ValueError is raised.\n\nNote how a LineItem with an invalid weight cannot be created now:\n\n>>> walnuts = LineItem('walnuts', 0, 10.00) Traceback (most recent call last): ... ValueError: value must be > 0\n\nNow we have protected weight from users providing negative values. Although buy‐ ers usually can’t set the price of an item, a clerical error or a bug may create a LineI tem with a negative price. To prevent that, we could also turn price into a property, but this would entail some repetition in our code.\n\nRemember the Paul Graham quote from Chapter 17: “When I see patterns in my pro‐ grams, I consider it a sign of trouble.” The cure for repetition is abstraction. There are two ways to abstract away property definitions: using a property factory or a descrip‐ tor class. The descriptor class approach is more flexible, and we’ll devote Chapter 23 to a full discussion of it. Properties are in fact implemented as descriptor classes\n\nUsing a Property for Attribute Validation\n\n|\n\n859",
      "content_length": 1659,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 890,
      "content": "themselves. But here we will continue our exploration of properties by implementing a property factory as a function.\n\nBut before we can implement a property factory, we need to have a deeper under‐ standing of properties.\n\nA Proper Look at Properties Although often used as a decorator, the property built-in is actually a class. In Python, functions and classes are often interchangeable, because both are callable and there is no new operator for object instantiation, so invoking a constructor is no dif‐ ferent from invoking a factory function. And both can be used as decorators, as long as they return a new callable that is a suitable replacement of the decorated callable.\n\nThis is the full signature of the property constructor:\n\nproperty(fget=None, fset=None, fdel=None, doc=None)\n\nAll arguments are optional, and if a function is not provided for one of them, the cor‐ responding operation is not allowed by the resulting property object.\n\nThe property type was added in Python 2.2, but the @ decorator syntax appeared only in Python 2.4, so for a few years, properties were defined by passing the accessor functions as the first two arguments.\n\nThe “classic” syntax for defining properties without decorators is illustrated in Example 22-22.\n\nExample 22-22. bulkfood_v2b.py: same as Example 22-21, but without using decorators\n\nclass LineItem:\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\ndef get_weight(self): return self.__weight\n\ndef set_weight(self, value): if value > 0: self.__weight = value else: raise ValueError('value must be > 0')\n\n860\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1738,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 891,
      "content": "weight = property(get_weight, set_weight)\n\nA plain getter.\n\nA plain setter.\n\nBuild the property and assign it to a public class attribute.\n\nThe classic form is better than the decorator syntax in some situations; the code of the property factory we’ll discuss shortly is one example. On the other hand, in a class body with many methods, the decorators make it explicit which are the getters and setters, without depending on the convention of using get and set prefixes in their names.\n\nThe presence of a property in a class affects how attributes in instances of that class can be found in a way that may be surprising at first. The next section explains.\n\nProperties Override Instance Attributes Properties are always class attributes, but they actually manage attribute access in the instances of the class.\n\nIn “Overriding Class Attributes” on page 389 we saw that when an instance and its class both have a data attribute by the same name, the instance attribute overrides, or instance. the class attribute—at shadows, Example 22-23 illustrates this point.\n\nleast when read\n\nthrough\n\nthat\n\nExample 22-23. Instance attribute shadows the class data attribute\n\n>>> class Class: ... data = 'the class data attr' ... @property ... def prop(self): ... return 'the prop value' ... >>> obj = Class() >>> vars(obj) {} >>> obj.data 'the class data attr' >>> obj.data = 'bar' >>> vars(obj) {'data': 'bar'} >>> obj.data 'bar' >>> Class.data 'the class data attr'\n\nA Proper Look at Properties\n\n|\n\n861",
      "content_length": 1493,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 892,
      "content": "Define Class with two class attributes: the data attribute and the prop property.\n\nvars returns the __dict__ of obj, showing it has no instance attributes.\n\nReading from obj.data retrieves the value of Class.data.\n\nWriting to obj.data creates an instance attribute.\n\nInspect the instance to see the instance attribute.\n\nNow reading from obj.data retrieves the value of the instance attribute. When read from the obj instance, the instance data shadows the class data.\n\nThe Class.data attribute is intact.\n\nNow, let’s try to override the prop attribute on the obj instance. Resuming the previ‐ ous console session, we have Example 22-24.\n\nExample 22-24. Instance attribute does not shadow the class property (continued from Example 22-23)\n\n>>> Class.prop <property object at 0x1072b7408> >>> obj.prop 'the prop value' >>> obj.prop = 'foo' Traceback (most recent call last): ... AttributeError: can't set attribute >>> obj.__dict__['prop'] = 'foo' >>> vars(obj) {'data': 'bar', 'prop': 'foo'} >>> obj.prop 'the prop value' >>> Class.prop = 'baz' >>> obj.prop 'foo'\n\nReading prop directly from Class retrieves the property object itself, without running its getter method.\n\nReading obj.prop executes the property getter.\n\nTrying to set an instance prop attribute fails.\n\nPutting 'prop' directly in the obj.__dict__ works.\n\n862\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1373,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 893,
      "content": "We can see that obj now has two instance attributes: data and prop.\n\nHowever, reading obj.prop still runs the property getter. The property is not shadowed by an instance attribute.\n\nOverwriting Class.prop destroys the property object.\n\nNow obj.prop retrieves the instance attribute. Class.prop is not a property any‐ more, so it no longer overrides obj.prop.\n\nAs a final demonstration, we’ll add a new property to Class, and see it overriding an instance attribute. Example 22-25 picks up where Example 22-24 left off.\n\nExample 22-25. New class property shadows the existing instance attribute (continued from Example 22-24)\n\n>>> obj.data 'bar' >>> Class.data 'the class data attr' >>> Class.data = property(lambda self: 'the \"data\" prop value') >>> obj.data 'the \"data\" prop value' >>> del Class.data >>> obj.data 'bar'\n\nobj.data retrieves the instance data attribute.\n\nClass.data retrieves the class data attribute.\n\nOverwrite Class.data with a new property.\n\nobj.data is now shadowed by the Class.data property.\n\nDelete the property.\n\nobj.data now reads the instance data attribute again.\n\nThe main point of this section is that an expression like obj.data does not start the search for data in obj. The search actually starts at obj.__class__, and only if there is no property named data in the class, Python looks in the obj instance itself. This applies to overriding descriptors in general, of which properties are just one example. Further treatment of descriptors must wait for Chapter 23.\n\nA Proper Look at Properties\n\n|\n\n863",
      "content_length": 1536,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 894,
      "content": "Now back to properties. Every Python code unit—modules, functions, classes, meth‐ ods—can have a docstring. The next topic is how to attach documentation to properties.\n\nProperty Documentation When tools such as the console help() function or IDEs need to display the docu‐ mentation of a property, they extract the information from the __doc__ attribute of the property.\n\nIf used with the classic call syntax, property can get the documentation string as the doc argument:\n\nweight = property(get_weight, set_weight, doc='weight in kilograms')\n\nThe docstring of the getter method—the one with the @property decorator itself—is used as the documentation of the property as a whole. Figure 22-1 shows the help screens generated from the code in Example 22-26.\n\nFigure 22-1. Screenshots of the Python console when issuing the commands help(Foo.bar) and help(Foo). Source code is in Example 22-26.\n\nExample 22-26. Documentation for a property\n\nclass Foo:\n\n@property def bar(self): \"\"\"The bar attribute\"\"\" return self.__dict__['bar']\n\n@bar.setter def bar(self, value): self.__dict__['bar'] = value\n\n864\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1147,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 895,
      "content": "Now that we have these property essentials covered, let’s go back to the issue of pro‐ tecting both the weight and price attributes of LineItem so they only accept values greater than zero—but without implementing two nearly identical pairs of getters/ setters by hand.\n\nCoding a Property Factory We’ll create a factory to create quantity properties—so named because the managed attributes represent quantities that can’t be negative or zero in the application. Example 22-27 shows the clean look of the LineItem class using two instances of quantity properties: one for managing the weight attribute, the other for price.\n\nExample 22-27. bulkfood_v2prop.py: the quantity property factory in use\n\nclass LineItem: weight = quantity('weight') price = quantity('price')\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\nUse the factory to define the first custom property, weight, as a class attribute.\n\nThis second call builds another custom property, price.\n\nHere the property is already active, making sure a negative or 0 weight is rejected.\n\nThe properties are also in use here, retrieving the values stored in the instance.\n\nRecall that properties are class attributes. When building each quantity property, we need to pass the name of the LineItem attribute that will be managed by that specific property. Having to type the word weight twice in this line is unfortunate:\n\nweight = quantity('weight')\n\nBut avoiding that repetition is complicated because the property has no way of know‐ ing which class attribute name will be bound to it. Remember: the righthand side of an assignment is evaluated first, so when quantity() is invoked, the weight class attribute doesn’t even exist.\n\nCoding a Property Factory\n\n|\n\n865",
      "content_length": 1845,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 896,
      "content": "Improving the quantity property so that the user doesn’t need to retype the attribute name is a nontrivial metaprogramming prob‐ lem. We’ll solve that problem in Chapter 23.\n\nExample 22-28 lists the implementation of the quantity property factory.11\n\nExample 22-28. bulkfood_v2prop.py: the quantity property factory\n\ndef quantity(storage_name):\n\ndef qty_getter(instance): return instance.__dict__[storage_name]\n\ndef qty_setter(instance, value): if value > 0: instance.__dict__[storage_name] = value else: raise ValueError('value must be > 0')\n\nreturn property(qty_getter, qty_setter)\n\nThe storage_name argument determines where the data for each property is stored; for the weight, the storage name will be 'weight'.\n\nThe first argument of the qty_getter could be named self, but that would be strange because this is not a class body; instance refers to the LineItem instance where the attribute will be stored.\n\nqty_getter references storage_name, so it will be preserved in the closure of this function; the value is retrieved directly from the instance.__dict__ to bypass the property and avoid an infinite recursion.\n\nqty_setter is defined, also taking instance as first argument.\n\nThe value is stored directly in the instance.__dict__, again bypassing the property.\n\nBuild a custom property object and return it.\n\n11 This code is adapted from “Recipe 9.21. Avoiding Repetitive Property Methods” from Python Cookbook, 3rd\n\ned., by David Beazley and Brian K. Jones (O’Reilly).\n\n866\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1535,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 897,
      "content": "The bits of Example 22-28 that deserve careful study revolve around the stor age_name variable. When you code each property in the traditional way, the name of the attribute where you will store a value is hardcoded in the getter and setter meth‐ ods. But here, the qty_getter and qty_setter functions are generic, and they depend on the storage_name variable to know where to get/set the managed attribute in the instance __dict__. Each time the quantity factory is called to build a property, the storage_name must be set to a unique value.\n\nThe functions qty_getter and qty_setter will be wrapped by the property object created in the last line of the factory function. Later, when called to perform their duties, these functions will read the storage_name from their closures to determine where to retrieve/store the managed attribute values.\n\nIn Example 22-29, I create and inspect a LineItem instance, exposing the storage attributes.\n\nExample 22-29. bulkfood_v2prop.py: exploring properties and storage attributes\n\n>>> nutmeg = LineItem('Moluccan nutmeg', 8, 13.95) >>> nutmeg.weight, nutmeg.price (8, 13.95) >>> nutmeg.__dict__ {'description': 'Moluccan nutmeg', 'weight': 8, 'price': 13.95}\n\nReading the weight and price through the properties shadowing the namesake instance attributes.\n\nUsing vars to inspect the nutmeg instance: here we see the actual instance attributes used to store the values.\n\nNote how the properties built by our factory leverage the behavior described in “Properties Override Instance Attributes” on page 861: the weight property overrides the weight instance attribute so that every reference to self.weight or nut meg.weight is handled by the property functions, and the only way to bypass the property logic is to access the instance __dict__ directly.\n\nThe code in Example 22-28 may be a bit tricky, but it’s concise: it’s identical in length in to Example 22-21. The LineItem definition in Example 22-27 looks much better without the noise of the getter/setters.\n\nthe weight property\n\nthe decorated getter/setter pair defining\n\njust\n\nIn a real system, that same kind of validation may appear in many fields, across sev‐ eral classes, and the quantity factory would be placed in a utility module to be used over and over again. Eventually that simple factory could be refactored into a more\n\nCoding a Property Factory\n\n|\n\n867",
      "content_length": 2365,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 898,
      "content": "extensible descriptor class, with specialized subclasses performing different valida‐ tions. We’ll do that in Chapter 23.\n\nNow let us wrap up the discussion of properties with the issue of attribute deletion.\n\nHandling Attribute Deletion We can use the del statement to delete not only variables, but also attributes:\n\n>>> class Demo: ... pass ... >>> d = Demo() >>> d.color = 'green' >>> d.color 'green' >>> del d.color >>> d.color Traceback (most recent call last): File \"<stdin>\", line 1, in <module> AttributeError: 'Demo' object has no attribute 'color'\n\nIn practice, deleting attributes is not something we do every day in Python, and the requirement to handle it with a property is even more unusual. But it is supported, and I can think of a silly example to demonstrate it.\n\nIn a property definition, the @my_property.deleter decorator wraps the method in charge of deleting the attribute managed by the property. As promised, silly Example 22-30 is inspired by the scene with the Black Knight from Monty Python and the Holy Grail.12\n\nExample 22-30. blackknight.py\n\nclass BlackKnight:\n\ndef __init__(self): self.phrases = [ ('an arm', \"'Tis but a scratch.\"), ('another arm', \"It's just a flesh wound.\"), ('a leg', \"I'm invincible!\"), ('another leg', \"All right, we'll call it a draw.\") ]\n\n@property def member(self): print('next member is:')\n\n12 The bloody scene is available on Youtube as I review this in October 2021.\n\n868\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 1483,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 899,
      "content": "return self.phrases[0][0]\n\n@member.deleter def member(self): member, text = self.phrases.pop(0) print(f'BLACK KNIGHT (loses {member}) -- {text}')\n\nThe doctests in blackknight.py are in Example 22-31.\n\nExample 22-31. blackknight.py: doctests for Example 22-30 (the Black Knight never concedes defeat)\n\n>>> knight = BlackKnight() >>> knight.member next member is: 'an arm' >>> del knight.member BLACK KNIGHT (loses an arm) -- 'Tis but a scratch. >>> del knight.member BLACK KNIGHT (loses another arm) -- It's just a flesh wound. >>> del knight.member BLACK KNIGHT (loses a leg) -- I'm invincible! >>> del knight.member BLACK KNIGHT (loses another leg) -- All right, we'll call it a draw.\n\nUsing the classic call syntax instead of decorators, the fdel argument configures the deleter function. For example, the member property would be coded like this in the body of the BlackKnight class:\n\nmember = property(member_getter, fdel=member_deleter)\n\nIf you are not using a property, attribute deletion can also be handled by implement‐ ing the lower-level __delattr__ special method, presented in “Special Methods for Attribute Handling” on page 871. Coding a silly class with __delattr__ is left as an exercise to the procrastinating reader.\n\nProperties are a powerful feature, but sometimes simpler or lower-level alternatives are preferable. In the final section of this chapter, we’ll review some of the core APIs that Python offers for dynamic attribute programming.\n\nEssential Attributes and Functions for Attribute Handling Throughout this chapter, and even before in the book, we’ve used some of the built- in functions and special methods Python provides for dealing with dynamic attributes. This section gives an overview of them in one place, because their docu‐ mentation is scattered in the official docs.\n\nEssential Attributes and Functions for Attribute Handling\n\n|\n\n869",
      "content_length": 1878,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 900,
      "content": "Special Attributes that Affect Attribute Handling The behavior of many of the functions and special methods listed in the following sections depend on three special attributes:\n\n__class__\n\nA reference to the object’s class (i.e., obj.__class__ is the same as type(obj)). Python looks for special methods such as __getattr__ only in an object’s class, and not in the instances themselves.\n\n__dict__\n\nA mapping that stores the writable attributes of an object or class. An object that has a __dict__ can have arbitrary new attributes set at any time. If a class has a __slots__ attribute, then its instances may not have a __dict__. See __slots__ (next).\n\n__slots__\n\nAn attribute that may be defined in a class to save memory. __slots__ is a tuple of strings naming the allowed attributes.13 If the '__dict__' name is not in __slots__, then the instances of that class will not have a __dict__ of their own, and only the attributes listed in __slots__ will be allowed in those instances. Recall “Saving Memory with __slots__” on page 384 for more.\n\nBuilt-In Functions for Attribute Handling These five built-in functions perform object attribute reading, writing, and introspection:\n\ndir([object])\n\nLists most attributes of the object. The official docs say dir is intended for inter‐ active use so it does not provide a comprehensive list of attributes, but an “inter‐ esting” set of names. dir can inspect objects implemented with or without a __dict__. The __dict__ attribute itself is not listed by dir, but the __dict__ keys are listed. Several special attributes of classes, such as __mro__, __bases__, and __name__, are not listed by dir either. You can customize the output of dir by implementing the __dir__ special method, as we saw in Example 22-4. If the optional object argument is not given, dir lists the names in the current scope.\n\n13 Alex Martelli points out that, although __slots__ can be coded as a list, it’s better to be explicit and always use a tuple, because changing the list in the __slots__ after the class body is processed has no effect, so it would be misleading to use a mutable sequence there.\n\n870\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 2180,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 901,
      "content": "getattr(object, name[, default])\n\nGets the attribute identified by the name string from the object. The main use case is to retrieve attributes (or methods) whose names we don’t know before‐ hand. This may fetch an attribute from the object’s class or from a superclass. If no such attribute exists, getattr raises AttributeError or returns the default value, if given. One great example of using gettatr is in the Cmd.onecmd method in the cmd package of the standard library, where it is used to get and execute a user-defined command.\n\nhasattr(object, name)\n\nReturns True if the named attribute exists in the object, or can be somehow fetched through it (by inheritance, for example). The documentation explains: “This is implemented by calling getattr(object, name) and seeing whether it raises an AttributeError or not.”\n\nsetattr(object, name, value)\n\nAssigns the value to the named attribute of object, if the object allows it. This may create a new attribute or overwrite an existing one.\n\nvars([object])\n\nReturns the __dict__ of object; vars can’t deal with instances of classes that define __slots__ and don’t have a __dict__ (contrast with dir, which handles such instances). Without an argument, vars() does the same as locals(): returns a dict representing the local scope.\n\nSpecial Methods for Attribute Handling When implemented in a user-defined class, the special methods listed here handle attribute retrieval, setting, deletion, and listing.\n\nAttribute access using either dot notation or the built-in functions getattr, hasattr, and setattr triggers the appropriate special methods listed here. Reading and writ‐ ing attributes directly in the instance __dict__ does not trigger these special methods —and that’s the usual way to bypass them if needed.\n\nSection “3.3.11. Special method lookup” of the “Data model” chapter warns:\n\nFor custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary.\n\nIn other words, assume that the special methods will be retrieved on the class itself, even when the target of the action is an instance. For this reason, special methods are not shadowed by instance attributes with the same name.\n\nIn the following examples, assume there is a class named Class, obj is an instance of Class, and attr is an attribute of obj.\n\nEssential Attributes and Functions for Attribute Handling\n\n|\n\n871",
      "content_length": 2444,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 902,
      "content": "For every one of these special methods, it doesn’t matter if the attribute access is done using dot notation or one of the built-in functions listed in “Built-In Functions for Attribute Handling” on page 870. For example, both obj.attr and getattr(obj, 'attr', 42) trigger Class.__getattribute__(obj, 'attr').\n\n__delattr__(self, name)\n\nAlways called when there is an attempt to delete an attribute using the del state‐ ment; e.g., del obj.attr triggers Class.__delattr__(obj, 'attr'). If attr is a property, its deleter method is never called if the class implements __delattr__.\n\n__dir__(self)\n\nCalled when dir is invoked on the object, to provide a listing of attributes; e.g., dir(obj) triggers Class.__dir__(obj). Also used by tab-completion in all modern Python consoles.\n\n__getattr__(self, name)\n\nCalled only when an attempt to retrieve the named attribute fails, after the obj, Class, and its superclasses are searched. The expressions obj.no_such_attr, get attr(obj, 'no_such_attr'), and hasattr(obj, 'no_such_attr') may trigger Class.__getattr__(obj, 'no_such_attr'), but only if an attribute by that name cannot be found in obj or in Class and its superclasses.\n\n__getattribute__(self, name)\n\nAlways called when there is an attempt to retrieve the named attribute directly from Python code (the interpreter may bypass this in some cases, for example, to get the __repr__ method). Dot notation and the getattr and hasattr built-ins trigger this method. __getattr__ is only invoked after __getattribute__, and only when __getattribute__ raises AttributeError. To retrieve attributes of the instance obj without triggering an infinite recursion, implementations of __getattribute__ should use super().__getattribute__(obj, name).\n\n__setattr__(self, name, value)\n\nAlways called when there is an attempt to set the named attribute. Dot notation and the setattr built-in trigger this method; e.g., both obj.attr = 42 and setattr(obj, 'attr', 42) trigger Class.__setattr__(obj, 'attr', 42).\n\nIn practice, because they are unconditionally called and affect prac‐ the __getattribute__ and tically every attribute access, __setattr__ special methods are harder to use correctly than __getattr__, which only handles nonexisting attribute names. Using properties or descriptors is less error prone than defining these special methods.\n\n872\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 2387,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 903,
      "content": "This concludes our dive into properties, special methods, and other techniques for coding dynamic attributes.\n\nChapter Summary We started our coverage of dynamic attributes by showing practical examples of sim‐ ple classes to make it easier to deal with a JSON dataset. The first example was the FrozenJSON class that converted nested dicts and lists into nested FrozenJSON instan‐ ces and lists of them. The FrozenJSON code demonstrated the use of the __getattr__ special method to convert data structures on the fly, whenever their attributes were read. The last version of FrozenJSON showcased the use of the __new__ constructor method to transform a class into a flexible factory of objects, not limited to instances of itself.\n\nWe then converted the JSON dataset to a dict storing instances of a Record class. The first rendition of Record was a few lines long and introduced the “bunch” idiom: using self.__dict__.update(**kwargs) to build arbitrary attributes from keyword arguments passed to __init__. The second iteration added the Event class, imple‐ menting automatic retrieval of linked records through properties. Computed prop‐ erty values sometimes require caching, and we covered a few ways of doing that.\n\nAfter realizing that @functools.cached_property is not always applicable, we learned about an alternative: combining @property on top of @functools.cache, in that order.\n\nCoverage of properties continued with the LineItem class, where a property was deployed to protect a weight attribute from negative or zero values that make no business sense. After a deeper look at property syntax and semantics, we created a property factory to enforce the same validation on weight and price, without coding multiple getters and setters. The property factory leveraged subtle concepts—such as closures, and instance attribute overriding by properties—to provide an elegant generic solution using the same number of lines as a single hand-coded property definition.\n\nFinally, we had a brief look at handling attribute deletion with properties, followed by an overview of the key special attributes, built-in functions, and special methods that support attribute metaprogramming in the core Python language.\n\nFurther Reading The official documentation for the attribute handling and introspection built-in functions is Chapter 2, “Built-in Functions” of The Python Standard Library. The related special methods and the __slots__ special attribute are documented in The Python Language Reference in “3.3.2. Customizing attribute access”. The semantics of\n\nChapter Summary\n\n|\n\n873",
      "content_length": 2589,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 904,
      "content": "how special methods are invoked bypassing instances is explained in “3.3.9. Special method lookup”. In Chapter 4, “Built-in Types,” of The Python Standard Library, “4.13. Special Attributes” covers __class__ and __dict__ attributes.\n\nPython Cookbook, 3rd ed., by David Beazley and Brian K. Jones (O’Reilly) has several recipes covering the topics of this chapter, but I will highlight three that are outstand‐ ing: “Recipe 8.8. Extending a Property in a Subclass” addresses the thorny issue of overriding the methods inside a property inherited from a superclass; “Recipe 8.15. Delegating Attribute Access” implements a proxy class showcasing most special methods from “Special Methods for Attribute Handling” on page 871 in this book; and the awesome “Recipe 9.21. Avoiding Repetitive Property Methods,” which was the basis for the property factory function presented in Example 22-28.\n\nPython in a Nutshell, 3rd ed., by Alex Martelli, Anna Ravenscroft, and Steve Holden (O’Reilly) is rigorous and objective. They devote only three pages to properties, but that’s because the book follows an axiomatic presentation style: the preceding 15 pages or so provide a thorough description of the semantics of Python classes from the ground up, including descriptors, which are how properties are actually imple‐ mented under the hood. So by the time Martelli et al., get to properties, they pack a lot of insights in those three pages—including what I selected to open this chapter.\n\nBertrand Meyer—quoted in the Uniform Access Principle definition in this chapter opening—pioneered the Design by Contract methodology, designed the Eiffel lan‐ guage, and wrote the excellent Object-Oriented Software Construction, 2nd ed. (Pear‐ son). The first six chapters provide one of the best conceptual introductions to OO analysis and design I’ve seen. Chapter 11 presents Design by Contract, and Chapter 35 offers Meyer’s assessments of some influential object-oriented languages: Simula, Smalltalk, CLOS (the Common Lisp Object System), Objective-C, C++, and Java, with brief comments on some others. Only in the last page of the book does he reveal that the highly readable “notation” he uses as pseudocode is Eiffel.\n\n874\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 2260,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 905,
      "content": "Soapbox Meyer’s Uniform Access Principle is aesthetically appealing. As a programmer using an API, I shouldn’t have to care whether product.price simply fetches a data attribute or performs a computation. As a consumer and a citizen, I do care: in e- commerce today the value of product.price often depends on who is asking, so it’s certainly not a mere data attribute. In fact, it’s common practice that the price is lower if the query comes from outside the store—say, from a price-comparison engine. This effectively punishes loyal customers who like to browse within a particu‐ lar store. But I digress.\n\nThe previous digression does raise a relevant point for programming: although the Uniform Access Principle makes perfect sense in an ideal world, in reality, users of an API may need to know whether reading product.price is potentially too expensive or time-consuming. That’s a problem with programming abstractions in general: they make it hard to reason about the runtime cost of evaluating an expression. On the other hand, abstractions let users accomplish more with less code. It’s a trade-off. As usual in matters of software engineering, Ward Cunningham’s original wiki hosts insightful arguments about the merits of the Uniform Access Principle.\n\nIn object-oriented programming languages, application or violations of the Uniform Access Principle often revolve around the syntax of reading public data attributes ver‐ sus invoking getter/setter methods.\n\nSmalltalk and Ruby address this issue in a simple and elegant way: they don’t support public data attributes at all. Every instance attribute in these languages is private, so every access to them must be through methods. But their syntax makes this painless: in Ruby, product.price invokes the price getter; in Smalltalk, it’s simply product price.\n\nAt the other end of the spectrum, the Java language allows the programmer to choose among four access-level modifiers—including the no-name default that the Java Tutorial calls “package-private.”\n\nThe general practice does not agree with the syntax established by the Java designers, though. Everybody in Java-land agrees that attributes should be private, and you must spell it out every time, because it’s not the default. When all attributes are pri‐ vate, all access to them from outside the class must go through accessors. Java IDEs include shortcuts for generating accessor methods automatically. Unfortunately, the IDE is not so helpful when you must read the code six months later. It’s up to you to wade through a sea of do-nothing accessors to find those that add value by imple‐ menting some business logic.\n\nFurther Reading\n\n|\n\n875",
      "content_length": 2667,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 906,
      "content": "Alex Martelli speaks for the majority of the Python community when he calls acces‐ sors “goofy idioms” and then provides these examples that look very different but do the same thing:14\n\nsomeInstance.widgetCounter += 1 # rather than... someInstance.setWidgetCounter(someInstance.getWidgetCounter() + 1)\n\nSometimes when designing APIs, I’ve wondered whether every method that does not take an argument (besides self), returns a value (other than None), and is a pure function (i.e., has no side effects) should be replaced by a read-only property. In this chapter, the LineItem.subtotal method (as in Example 22-27) would be a good can‐ didate to become a read-only property. Of course, this excludes methods that are designed to change the object, such as my_list.clear(). It would be a terrible idea to turn that into a property, so that merely accessing my_list.clear would delete the contents of the list!\n\nIn the Pingo GPIO library, which I coauthored (mentioned in “The __missing__ Method” on page 91), much of the user-level API is based on properties. For example, to read the current value of an analog pin, the user writes pin.value, and setting a digital pin mode is written as pin.mode = OUT. Behind the scenes, reading an analog pin value or setting a digital pin mode may involve a lot of code, depending on the specific board driver. We decided to use properties in Pingo because we want the API to be comfortable to use even in interactive environments like a Jupyter Notebook, and we feel pin.mode = OUT is easier on the eyes and on the fingers than pin.set_mode(OUT).\n\nAlthough I find the Smalltalk and Ruby solution cleaner, I think the Python approach makes more sense than the Java one. We are allowed to start simple, coding data members as public attributes, because we know they can always be wrapped by prop‐ erties (or descriptors, which we’ll talk about in the next chapter).\n\n__new__ Is Better than new\n\nAnother example of the Uniform Access Principle (or a variation of it) is the fact that function calls and object instantiation use the same syntax in Python: my_obj = foo(), where foo may be a class or any other callable.\n\nOther languages influenced by C++ syntax have a new operator that makes instantia‐ tion look different than a call. Most of the time, the user of an API doesn’t care whether foo is a function or a class. For years I was under the impression that property was a function. In normal usage, it makes no difference.\n\n14 Alex Martelli, Python in a Nutshell, 2nd ed. (O’Reilly), p. 101.\n\n876\n\n|\n\nChapter 22: Dynamic Attributes and Properties",
      "content_length": 2590,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 907,
      "content": "There are many good reasons for replacing constructors with factories.15 A popular motive is limiting the number of instances by returning previously built ones (as in the Singleton pattern). A related use is caching expensive object construction. Also, sometimes it’s convenient to return objects of different types, depending on the argu‐ ments given.\n\nCoding a constructor is simpler; providing a factory adds flexibility at the expense of more code. In languages that have a new operator, the designer of an API must decide in advance whether to stick with a simple constructor or invest in a factory. If the ini‐ tial choice is wrong, the correction may be costly—all because new is an operator.\n\nSometimes it may also be convenient to go the other way, and replace a simple func‐ tion with a class.\n\nIn Python, classes and functions are interchangeable in many situations. Not only because there’s no new operator, but also because there is the __new__ special method, which can turn a class into a factory producing objects of different kinds (as we saw in “Flexible Object Creation with __new__” on page 843) or returning prebuilt instances instead of creating a new one every time.\n\nThis function-class duality would be easier to leverage if PEP 8 — Style Guide for Python Code did not recommend CamelCase for class names. On the other hand, dozens of classes in the standard library have lowercase names (e.g., property, str, defaultdict, etc.). So maybe the use of lowercase class names is a feature, and not a bug. But however we look at it, the inconsistent capitalization of classes in the Python standard library poses a usability problem.\n\nAlthough calling a function is not different from calling a class, it’s good to know which is which because of another thing we can do with a class: subclassing. So I per‐ sonally use CamelCase in every class that I code, and I wish all classes in the Python standard library used the same convention. I am looking at you, collections.Order edDict and collections.defaultdict.\n\n15 The reasons I am about to mention are given in the Dr. Dobbs Journal article titled “Java’s new Considered\n\nHarmful”, by Jonathan Amsterdam and in “Consider static factory methods instead of constructors,” which is Item 1 of the award-winning book Effective Java, 3rd ed., by Joshua Bloch (Addison-Wesley).\n\nFurther Reading\n\n|\n\n877",
      "content_length": 2368,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 909,
      "content": "CHAPTER 23 Attribute Descriptors\n\nLearning about descriptors not only provides access to a larger toolset, it creates a deeper understanding of how Python works and an appreciation for the elegance of its design.\n\n— Raymond Hettinger, Python core developer and guru1\n\nDescriptors are a way of reusing the same access logic in multiple attributes. For example, field types in ORMs, such as the Django ORM and SQLAlchemy, are descriptors, managing the flow of data from the fields in a database record to Python object attributes and vice versa.\n\nA descriptor is a class that implements a dynamic protocol consisting of the __get__, __set__, and __delete__ methods. The property class implements the full descrip‐ tor protocol. As usual with dynamic protocols, partial implementations are OK. In fact, most descriptors we see in real code implement only __get__ and __set__, and many implement only one of these methods.\n\nDescriptors are a distinguishing feature of Python, deployed not only at the applica‐ tion level but also in the language infrastructure. User-defined functions are descrip‐ tors. We’ll see how the descriptor protocol allows methods to operate as bound or unbound methods, depending on how they are called.\n\nUnderstanding descriptors is key to Python mastery. This is what this chapter is about.\n\nIn this chapter we’ll refactor the bulk food example we first saw in “Using a Property for Attribute Validation” on page 857, replacing properties with descriptors. This will make it easier to reuse the attribute validation logic across different classes. We’ll\n\n1 Raymond Hettinger, Descriptor HowTo Guide.\n\n879",
      "content_length": 1629,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 910,
      "content": "tackle the concepts of overriding and nonoverriding descriptors, and realize that Python functions are descriptors. Finally we’ll see some tips about implementing descriptors.\n\nWhat’s New in This Chapter The Quantity descriptor example in “LineItem Take #4: Automatic Naming of Stor‐ age Attributes” on page 887 was dramatically simplified thanks to the __set_name__ special method added to the descriptor protocol in Python 3.6.\n\nI removed the property factory example formerly in “LineItem Take #4: Automatic Naming of Storage Attributes” on page 887 because it became irrelevant: the point was to show an alternative way of solving the Quantity problem, but with the addition of __set_name__, the descriptor solution becomes much simpler.\n\nThe AutoStorage class that used to appear in “LineItem Take #5: A New Descriptor Type” on page 889 is also gone because __set_name__ made it obsolete.\n\nDescriptor Example: Attribute Validation As we saw in “Coding a Property Factory” on page 865, a property factory is a way to avoid repetitive coding of getters and setters by applying functional programming patterns. A property factory is a higher-order function that creates a parameterized set of accessor functions and builds a custom property instance from them, with clo‐ sures to hold settings like the storage_name. The object-oriented way of solving the same problem is a descriptor class.\n\nWe’ll continue the series of LineItem examples where we left off, in “Coding a Prop‐ erty Factory” on page 865, by refactoring the quantity property factory into a Quan tity descriptor class. This will make it easier to use.\n\nLineItem Take #3: A Simple Descriptor As we said in the introduction, a class implementing a __get__, a __set__, or a __delete__ method is a descriptor. You use a descriptor by declaring instances of it as class attributes of another class.\n\nWe’ll create a Quantity descriptor, and the LineItem class will use two instances of Quantity: one for managing the weight attribute, the other for price. A diagram helps, so take a look at Figure 23-1.\n\n880\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 2108,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 911,
      "content": "Figure 23-1. UML class diagram for LineItem using a descriptor class named Quan tity. Underlined attributes in UML are class attributes. Note that weight and price are instances of Quantity attached to the LineItem class, but LineItem instances also have their own weight and price attributes where those values are stored.\n\nNote that the word weight appears twice in Figure 23-1, because there are really two distinct attributes named weight: one is a class attribute of LineItem, the other is an instance attribute that will exist in each LineItem object. This also applies to price.\n\nTerms to understand descriptors\n\nImplementing and using descriptors involves several components, and it is useful to be precise when naming those components. I will use the following terms and defini‐ tions as I describe the examples in this chapter. They will be easier to understand once you see the code, but I wanted to put the definitions up front so you can refer back to them when needed.\n\nDescriptor class\n\nA class implementing the descriptor protocol. That’s Quantity in Figure 23-1.\n\nManaged class\n\nThe class where the descriptor instances are declared as class attributes. In Figure 23-1, LineItem is the managed class.\n\nDescriptor instance\n\nEach instance of a descriptor class, declared as a class attribute of the managed class. In Figure 23-1, each descriptor instance is represented by a composition arrow with an underlined name (the underline means class attribute in UML). The black diamonds touch the LineItem class, which contains the descriptor instances.\n\nDescriptor Example: Attribute Validation\n\n|\n\n881",
      "content_length": 1613,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 912,
      "content": "Managed instance\n\nOne instance of the managed class. In this example, LineItem instances are the managed instances (they are not shown in the class diagram).\n\nStorage attribute\n\nAn attribute of the managed instance that holds the value of a managed attribute for that particular instance. In Figure 23-1, the LineItem instance attributes weight and price are the storage attributes. They are distinct from the descriptor instances, which are always class attributes.\n\nManaged attribute\n\nA public attribute in the managed class that is handled by a descriptor instance, with values stored in storage attributes. In other words, a descriptor instance and a storage attribute provide the infrastructure for a managed attribute.\n\nIt’s important to realize that Quantity instances are class attributes of LineItem. This crucial point is highlighted by the mills and gizmos in Figure 23-2.\n\nFigure 23-2. UML class diagram annotated with MGN (Mills & Gizmos Notation): classes are mills that produce gizmos—the instances. The Quantity mill produces two gizmos with round heads, which are attached to the LineItem mill: weight and price. The LineItem mill produces rectangular gizmos that have their own weight and price attributes where those values are stored.\n\n882\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 1297,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 913,
      "content": "Introducing Mills & Gizmos Notation After explaining descriptors many times, I realized UML is not very good at showing relationships involving classes and instances, like the relationship between a managed class and the descriptor instances.2 So I invented my own “language,” the Mills & Giz‐ mos Notation (MGN), which I use to annotate UML diagrams.\n\nMGN is designed to make very clear the distinction between classes and instances. See Figure 23-3. In MGN, a class is drawn as a “mill,” a complicated machine that produces gizmos. Classes/mills are always machines with levers and dials. The gizmos are the instances, and they look much simpler. When this book is rendered in color, gizmos have the same color as the mill that made it.\n\nFigure 23-3. MGN sketch showing the LineItem class making three instances, and Quan tity making two. One instance of Quantity is retrieving a value stored in a LineItem instance.\n\nFor this example, I drew LineItem instances as rows in a tabular invoice, with three cells representing the three attributes (description, weight, and price). Because Quantity instances are descriptors, they have a magnifying glass to __get__ values, and a claw to __set__ values. When we get to metaclasses, you’ll thank me for these doodles.\n\nEnough doodling for now. Here is the code: Example 23-1 shows the Quantity descriptor class, and Example 23-2 lists a new LineItem class using two instances of Quantity.\n\n2 Classes and instances are drawn as rectangles in UML class diagrams. There are visual differences, but instan‐\n\nces are rarely shown in class diagrams, so developers may not recognize them as such.\n\nDescriptor Example: Attribute Validation\n\n|\n\n883",
      "content_length": 1685,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 914,
      "content": "Example 23-1. bulkfood_v3.py: Quantity descriptor does not accept negative values\n\nclass Quantity:\n\ndef __init__(self, storage_name): self.storage_name = storage_name\n\ndef __set__(self, instance, value): if value > 0: instance.__dict__[self.storage_name] = value else: msg = f'{self.storage_name} must be > 0' raise ValueError(msg)\n\ndef __get__(self, instance, owner): return instance.__dict__[self.storage_name]\n\nDescriptor is a protocol-based feature; no subclassing is needed to implement one.\n\nEach Quantity instance will have a storage_name attribute: that’s the name of the storage attribute to hold the value in the managed instances.\n\n__set__ is called when there is an attempt to assign to the managed attribute. Here, self is the descriptor instance (i.e., LineItem.weight or LineItem.price), instance is the managed instance (a LineItem instance), and value is the value being assigned.\n\nWe must store the attribute value directly into __dict__; calling set attr (instance, self.storage_name) would trigger the __set__ method again, leading to infinite recursion.\n\nWe need to implement __get__ because the name of the managed attribute may not be the same as the storage_name. The owner argument will be explained shortly.\n\nImplementing __get__ is necessary because a user could write something like this:\n\nclass House: rooms = Quantity('number_of_rooms')\n\nIn the House class, the managed attribute is rooms, but the storage attribute is number_of_rooms. Given a House instance named chaos_manor, reading and writing chaos_manor.rooms goes through the Quantity descriptor instance attached to rooms, but reading and writing chaos_manor.number_of_rooms bypasses the descriptor.\n\n884\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 1730,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 915,
      "content": "Note that __get__ receives three arguments: self, instance, and owner. The owner argument is a reference to the managed class (e.g., LineItem), and it’s useful if you want the descriptor to support retrieving a class attribute—perhaps to emulate Python’s default behavior of retrieving a class attribute when the name is not found in the instance.\n\nIf a managed attribute, such as weight, is retrieved via the class like Line Item.weight, the descriptor __get__ method receives None as the value for the instance argument.\n\nTo support introspection and other metaprogramming tricks by the user, it’s a good practice to make __get__ return the descriptor instance when the managed attribute is accessed through the class. To do that, we’d code __get__ like this:\n\ndef __get__(self, instance, owner): if instance is None: return self else: return instance.__dict__[self.storage_name]\n\nExample 23-2 demonstrates the use of Quantity in LineItem.\n\nExample 23-2. bulkfood_v3.py: Quantity descriptors manage attributes in LineItem\n\nclass LineItem: weight = Quantity('weight') price = Quantity('price')\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\nThe first descriptor instance will manage the weight attribute.\n\nThe second descriptor instance will manage the price attribute.\n\nThe rest of the class body is as simple and clean as the original code in bulk‐ food_v1.py (Example 22-19).\n\nDescriptor Example: Attribute Validation\n\n|\n\n885",
      "content_length": 1556,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 916,
      "content": "The code in Example 23-2 works as intended, preventing the sale of truffles for $0:3\n\n>>> truffle = LineItem('White truffle', 100, 0) Traceback (most recent call last): ... ValueError: value must be > 0\n\nWhen coding descriptor __get__ and __set__ methods, keep in mind what the self and instance arguments mean: self is the descriptor instance, and instance is the managed instance. Descriptors managing instance attributes should store values in the managed instances. That’s why Python provides the instance argument to the descriptor methods.\n\nIt may be tempting, but wrong, to store the value of each managed attribute in the descriptor instance itself. In other words, in the __set__ method, instead of coding:\n\ninstance.__dict__[self.storage_name] = value\n\nthe tempting, but bad, alternative would be:\n\nself.__dict__[self.storage_name] = value\n\nTo understand why this would be wrong, think about the meaning of the first two arguments to __set__: self and instance. Here, self is the descriptor instance, which is actually a class attribute of the managed class. You may have thousands of LineItem instances in memory at one time, but you’ll only have two instances of the descriptors: the class attributes LineItem.weight and LineItem.price. So anything you store in the descriptor instances themselves is actually part of a LineItem class attribute, and therefore is shared among all LineItem instances.\n\nA drawback of Example 23-2 is the need to repeat the names of the attributes when the descriptors are instantiated in the managed class body. It would be nice if the LineItem class could be declared like this:\n\nclass LineItem: weight = Quantity() price = Quantity()\n\n# remaining methods as before\n\nAs it stands, Example 23-2 requires naming each Quantity explicitly, which is not only inconvenient but dangerous. If a programmer copying and pasting code forgets to edit both names and writes something like price = Quantity('weight'), the\n\n3 White truffles cost thousands of dollars per pound. Disallowing the sale of truffles for $0.01 is left as an exer‐ cise for the enterprising reader. I know a person who actually bought an $1,800 encyclopedia of statistics for $18 because of an error in an online store (not Amazon.com in this case).\n\n886\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 2297,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 917,
      "content": "program will misbehave badly, clobbering the value of weight whenever the price is set.\n\nThe problem is that—as we saw in Chapter 6—the righthand side of an assignment is executed before the variable exists. The expression Quantity() is evaluated to create a descriptor instance, and there is no way the code in the Quantity class can guess the name of the variable to which the descriptor will be bound (e.g., weight or price).\n\nThankfully, the descriptor protocol now supports the aptly named __set_name__ special method. We’ll see how to use it next.\n\nAutomatic naming of a descriptor storage attribute used to be a thorny issue. In the first edition of Fluent Python, I devoted several pages and lines of code in this chapter and the next to presenting different solutions, including the use of a class decorator, and then metaclasses in Chapter 24. This was greatly simplified in Python 3.6.\n\nLineItem Take #4: Automatic Naming of Storage Attributes To avoid retyping the attribute name in the descriptor instances, we’ll implement __set_name__ to set the storage_name of each Quantity instance. The __set_name__ special method was added to the descriptor protocol in Python 3.6. The interpreter calls __set_name__ on each descriptor it finds in a class body—if the descriptor implements it.4\n\nIn Example 23-3, the LineItem descriptor class doesn’t need an __init__. Instead, __set_item__ saves the name of the storage attribute.\n\nExample 23-3. bulkfood_v4.py: __set_name__ sets the name for each Quantity descriptor instance\n\nclass Quantity:\n\ndef __set_name__(self, owner, name): self.storage_name = name\n\ndef __set__(self, instance, value): if value > 0: instance.__dict__[self.storage_name] = value\n\n4 More precisely, __set_name__ is called by type.__new__—the constructor of objects representing classes. The type built-in is actually a metaclass, the default class of user-defined classes. This is hard to grasp at first, but rest assured: Chapter 24 is devoted to the dynamic configuration of classes, including the concept of metaclasses.\n\nDescriptor Example: Attribute Validation\n\n|\n\n887",
      "content_length": 2100,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 918,
      "content": "else: msg = f'{self.storage_name} must be > 0' raise ValueError(msg)\n\n# no __get__ needed\n\nclass LineItem: weight = Quantity() price = Quantity()\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\nself is the descriptor instance (not the managed instance), owner is the managed class, and name is the name of the attribute of owner to which this descriptor instance was assigned in the class body of owner.\n\nThis is what the __init__ did in Example 23-1.\n\nThe __set__ method here is exactly the same as in Example 23-1.\n\nImplementing __get__ is not necessary because the name of the storage attribute matches the name of the managed attribute. The expression product.price gets the price attribute directly from the LineItem instance.\n\nNow we don’t need to pass the managed attribute name to the Quantity con‐ structor. That was the goal for this version.\n\nLooking at Example 23-3, you may think that’s a lot of code just for managing a cou‐ ple of attributes, but it’s important to realize that the descriptor logic is now abstrac‐ ted into a separate code unit: the Quantity class. Usually we do not define a descriptor in the same module where it’s used, but in a separate utility module designed to be used across the application—even in many applications, if you are developing a library or framework.\n\nWith this in mind, Example 23-4 better represents the typical usage of a descriptor.\n\nExample 23-4. bulkfood_v4c.py: LineItem definition uncluttered; the Quantity descriptor class now resides in the imported model_v4c module\n\nimport model_v4c as model\n\n888\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 1725,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 919,
      "content": "class LineItem: weight = model.Quantity() price = model.Quantity()\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\nImport the model_v4c module where Quantity is implemented.\n\nPut model.Quantity to use.\n\nDjango users will notice that Example 23-4 looks a lot like a model definition. It’s no coincidence: Django model fields are descriptors.\n\nBecause descriptors are implemented as classes, we can leverage inheritance to reuse some of the code we have for new descriptors. That’s what we’ll do in the following section.\n\nLineItem Take #5: A New Descriptor Type The imaginary organic food store hits a snag: somehow a line item instance was cre‐ ated with a blank description, and the order could not be fulfilled. To prevent that, we’ll create a new descriptor, NonBlank. As we design NonBlank, we realize it will be very much like the Quantity descriptor, except for the validation logic.\n\nThis prompts a refactoring, producing Validated, an abstract class that overrides the __set__ method, calling a validate method that must be implemented by sub‐ classes.\n\nWe’ll then rewrite Quantity, and implement NonBlank by inheriting from Validated and just coding the validate methods.\n\nThe relationship among Validated, Quantity, and NonBlank is an application of the template method as described in the Design Patterns classic:\n\nA template method defines an algorithm in terms of abstract operations that subclasses override to provide concrete behavior.5\n\n5 Gamma et al., Design Patterns: Elements of Reusable Object-Oriented Software, p. 326.\n\nDescriptor Example: Attribute Validation\n\n|\n\n889",
      "content_length": 1717,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 920,
      "content": "In Example 23-5, Validated.__set__ is the template method and self.validate is the abstract operation.\n\nExample 23-5. model_v5.py: the Validated ABC\n\nimport abc\n\nclass Validated(abc.ABC):\n\ndef __set_name__(self, owner, name): self.storage_name = name\n\ndef __set__(self, instance, value): value = self.validate(self.storage_name, value) instance.__dict__[self.storage_name] = value\n\n@abc.abstractmethod def validate(self, name, value): \"\"\"return validated value or raise ValueError\"\"\"\n\n__set__ delegates validation to the validate method…\n\n…then uses the returned value to update the stored value.\n\nvalidate is an abstract method; this is the template method.\n\nAlex Martelli prefers to call this design pattern Self-Delegation, and I agree it’s a more descriptive name: the first line of __set__ self-delegates to validate.6\n\nThe concrete Validated subclasses in this example are Quantity and NonBlank, shown in Example 23-6.\n\nExample 23-6. model_v5.py: Quantity and NonBlank, concrete Validated subclasses\n\nclass Quantity(Validated): \"\"\"a number greater than zero\"\"\"\n\ndef validate(self, name, value): if value <= 0: raise ValueError(f'{name} must be > 0') return value\n\nclass NonBlank(Validated): \"\"\"a string with at least one non-space character\"\"\"\n\n6 Slide #50 of Alex Martelli’s “Python Design Patterns” talk. Highly recommended.\n\n890\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 1375,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 921,
      "content": "def validate(self, name, value): value = value.strip() if not value: raise ValueError(f'{name} cannot be blank') return value\n\nImplementation of the template method required by the Validated.validate abstract method.\n\nIf nothing is left after leading and trailing blanks are stripped, reject the value.\n\nRequiring the concrete validate methods to return the validated value gives them an opportunity to clean up, convert, or normalize the data received. In this case, value is returned without leading or trailing blanks.\n\nUsers of model_v5.py don’t need to know all these details. What matters is that they get to use Quantity and NonBlank to automate the validation of instance attributes. See the latest LineItem class in Example 23-7.\n\nExample 23-7. bulkfood_v5.py: LineItem using Quantity and NonBlank descriptors\n\nimport model_v5 as model\n\nclass LineItem: description = model.NonBlank() weight = model.Quantity() price = model.Quantity()\n\ndef __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price\n\ndef subtotal(self): return self.weight * self.price\n\nImport the model_v5 module, giving it a friendlier name.\n\nPut model.NonBlank to use. The rest of the code is unchanged.\n\nThe LineItem examples we’ve seen in this chapter demonstrate a typical use of descriptors to manage data attributes. Descriptors like Quantity are called overriding descriptors because its __set__ method overrides (i.e., intercepts and overrules) the setting of an instance attribute by the same name in the managed instance. However, there are also nonoverriding descriptors. We’ll explore this distinction in detail in the next section.\n\nDescriptor Example: Attribute Validation\n\n|\n\n891",
      "content_length": 1727,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 922,
      "content": "Overriding Versus Nonoverriding Descriptors Recall that there is an important asymmetry in the way Python handles attributes. Reading an attribute through an instance normally returns the attribute defined in the instance, but if there is no such attribute in the instance, a class attribute will be retrieved. On the other hand, assigning to an attribute in an instance normally creates the attribute in the instance, without affecting the class at all.\n\nThis asymmetry also affects descriptors, in effect creating two broad categories of descriptors, depending on whether the __set__ method is implemented. If __set__ is present, the class is an overriding descriptor; otherwise, it is a nonoverriding descriptor. These terms will make sense as we study descriptor behaviors in the next examples.\n\nObserving the different descriptor categories requires a few classes, so we’ll use the code in Example 23-8 as our test bed for the following sections.\n\nEvery __get__ and __set__ method in Example 23-8 calls print_args so their invocations are displayed in a readable way. Understanding print_args and the auxiliary functions cls_name and display is not important, so don’t get distracted by them.\n\nExample 23-8. descriptorkinds.py: simple classes for studying descriptor overriding behaviors\n\n### auxiliary functions for display only ###\n\ndef cls_name(obj_or_cls): cls = type(obj_or_cls) if cls is type: cls = obj_or_cls return cls.__name__.split('.')[-1]\n\ndef display(obj): cls = type(obj) if cls is type: return f'<class {obj.__name__}>' elif cls in [type(None), int]: return repr(obj) else: return f'<{cls_name(obj)} object>'\n\ndef print_args(name, *args): pseudo_args = ', '.join(display(x) for x in args) print(f'-> {cls_name(args[0])}.__{name}__({pseudo_args})')\n\n### essential classes for this example ###\n\n892\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 1855,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 923,
      "content": "class Overriding: \"\"\"a.k.a. data descriptor or enforced descriptor\"\"\"\n\ndef __get__(self, instance, owner): print_args('get', self, instance, owner)\n\ndef __set__(self, instance, value): print_args('set', self, instance, value)\n\nclass OverridingNoGet: \"\"\"an overriding descriptor without ``__get__``\"\"\"\n\ndef __set__(self, instance, value): print_args('set', self, instance, value)\n\nclass NonOverriding: \"\"\"a.k.a. non-data or shadowable descriptor\"\"\"\n\ndef __get__(self, instance, owner): print_args('get', self, instance, owner)\n\nclass Managed: over = Overriding() over_no_get = OverridingNoGet() non_over = NonOverriding()\n\ndef spam(self): print(f'-> Managed.spam({display(self)})')\n\nAn overriding descriptor class with __get__ and __set__.\n\nThe print_args function is called by every descriptor method in this example.\n\nAn overriding descriptor without a __get__ method.\n\nNo __set__ method here, so this is a nonoverriding descriptor.\n\nThe managed class, using one instance of each of the descriptor classes.\n\nThe spam method is here for comparison, because methods are also descriptors.\n\nIn the following sections, we will examine the behavior of attribute reads and writes on the Managed class, and one instance of it, going through each of the different descriptors defined.\n\nOverriding Versus Nonoverriding Descriptors\n\n|\n\n893",
      "content_length": 1329,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 924,
      "content": "Overriding Descriptors A descriptor that implements the __set__ method is an overriding descriptor, because although it is a class attribute, a descriptor implementing __set__ will override attempts to assign to instance attributes. This is how Example 23-3 was implemented. Properties are also overriding descriptors: if you don’t provide a setter function, the default __set__ from the property class will raise AttributeError to signal that the attribute is read-only. Given the code in Example 23-8, experiments with an overrid‐ ing descriptor can be seen in Example 23-9.\n\nPython contributors and authors use different terms when discus‐ sing these concepts. I adopted “overriding descriptor” from the book Python in a Nutshell. The official Python documentation uses “data descriptor,” but “overriding descriptor” highlights the special behavior. Overriding descriptors are also called “enforced descrip‐ tors.” Synonyms for nonoverriding descriptors include “nondata descriptors” or “shadowable descriptors.”\n\nExample 23-9. Behavior of an overriding descriptor\n\n>>> obj = Managed() >>> obj.over -> Overriding.__get__(<Overriding object>, <Managed object>, <class Managed>) >>> Managed.over -> Overriding.__get__(<Overriding object>, None, <class Managed>) >>> obj.over = 7 -> Overriding.__set__(<Overriding object>, <Managed object>, 7) >>> obj.over -> Overriding.__get__(<Overriding object>, <Managed object>, <class Managed>) >>> obj.__dict__['over'] = 8 >>> vars(obj) {'over': 8} >>> obj.over -> Overriding.__get__(<Overriding object>, <Managed object>, <class Managed>)\n\nCreate Managed object for testing.\n\nobj.over triggers the descriptor __get__ method, passing the managed instance obj as the second argument.\n\nManaged.over triggers the descriptor __get__ method, passing None as the sec‐ ond argument (instance).\n\nAssigning to obj.over triggers the descriptor __set__ method, passing the value 7 as the last argument.\n\n894\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 1975,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 925,
      "content": "Reading obj.over still invokes the descriptor __get__ method.\n\nBypassing the descriptor, setting a value directly to the obj.__dict__.\n\nVerify that the value is in the obj.__dict__, under the over key.\n\nHowever, even with an instance attribute named over, the Managed.over descriptor still overrides attempts to read obj.over.\n\nOverriding Descriptor Without __get__ Properties and other overriding descriptors, such as Django model fields, implement both __set__ and __get__, but it’s also possible to implement only __set__, as we saw in Example 23-2. In this case, only writing is handled by the descriptor. Reading the descriptor through an instance will return the descriptor object itself because there is no __get__ to handle that access. If a namesake instance attribute is created with a new value via direct access to the instance __dict__, the __set__ method will still override further attempts to set that attribute, but reading that attribute will sim‐ ply return the new value from the instance, instead of returning the descriptor object. In other words, the instance attribute will shadow the descriptor, but only when read‐ ing. See Example 23-10.\n\nExample 23-10. Overriding descriptor without __get__\n\n>>> obj.over_no_get <__main__.OverridingNoGet object at 0x665bcc> >>> Managed.over_no_get <__main__.OverridingNoGet object at 0x665bcc> >>> obj.over_no_get = 7 -> OverridingNoGet.__set__(<OverridingNoGet object>, <Managed object>, 7) >>> obj.over_no_get <__main__.OverridingNoGet object at 0x665bcc> >>> obj.__dict__['over_no_get'] = 9 >>> obj.over_no_get 9 >>> obj.over_no_get = 7 -> OverridingNoGet.__set__(<OverridingNoGet object>, <Managed object>, 7) >>> obj.over_no_get 9\n\nThis overriding descriptor doesn’t have a __get__ method, so reading obj.over_no_get retrieves the descriptor instance from the class.\n\nThe same thing happens if we retrieve the descriptor instance directly from the managed class.\n\nOverriding Versus Nonoverriding Descriptors\n\n|\n\n895",
      "content_length": 1982,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 926,
      "content": "Trying to set a value to obj.over_no_get invokes the __set__ descriptor method.\n\nBecause our __set__ doesn’t make changes, reading obj.over_no_get again retrieves the descriptor instance from the managed class.\n\nGoing through the instance __dict__ to set an instance attribute named over_no_get.\n\nNow that over_no_get instance attribute shadows the descriptor, but only for reading.\n\nTrying to assign a value to obj.over_no_get still goes through the descriptor set.\n\nBut for reading, that descriptor is shadowed as long as there is a namesake instance attribute.\n\nNonoverriding Descriptor A descriptor that does not implement __set__ is a nonoverriding descriptor. Setting an instance attribute with the same name will shadow the descriptor, rendering it ineffective for handling that attribute in that specific instance. Methods and @func tools.cached_property descriptors. implemented Example 23-11 shows the operation of a nonoverriding descriptor.\n\nare\n\nas nonoverriding\n\nExample 23-11. Behavior of a nonoverriding descriptor\n\n>>> obj = Managed() >>> obj.non_over -> NonOverriding.__get__(<NonOverriding object>, <Managed object>, <class Managed>) >>> obj.non_over = 7 >>> obj.non_over 7 >>> Managed.non_over -> NonOverriding.__get__(<NonOverriding object>, None, <class Managed>) >>> del obj.non_over >>> obj.non_over -> NonOverriding.__get__(<NonOverriding object>, <Managed object>, <class Managed>)\n\nobj.non_over triggers the descriptor __get__ method, passing obj as the second argument.\n\nManaged.non_over is a nonoverriding descriptor, so there is no __set__ to inter‐ fere with this assignment.\n\n896\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 1649,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 927,
      "content": "The obj now has an instance attribute named non_over, which shadows the namesake descriptor attribute in the Managed class.\n\nThe Managed.non_over descriptor is still there, and catches this access via the class.\n\nIf the non_over instance attribute is deleted…\n\n…then reading obj.non_over hits the __get__ method of the descriptor in the class, but note that the second argument is the managed instance.\n\nIn the previous examples, we saw several assignments to an instance attribute with the same name as a descriptor, and different results according to the presence of a __set__ method in the descriptor.\n\nThe setting of attributes in the class cannot be controlled by descriptors attached to the same class. In particular, this means that the descriptor attributes themselves can be clobbered by assigning to the class, as the next section explains.\n\nOverwriting a Descriptor in the Class Regardless of whether a descriptor is overriding or not, it can be overwritten by assignment to the class. This is a monkey-patching technique, but in Example 23-12 the descriptors are replaced by integers, which would effectively break any class that depended on the descriptors for proper operation.\n\nExample 23-12. Any descriptor can be overwritten on the class itself\n\n>>> obj = Managed() >>> Managed.over = 1 >>> Managed.over_no_get = 2 >>> Managed.non_over = 3 >>> obj.over, obj.over_no_get, obj.non_over (1, 2, 3)\n\nCreate a new instance for later testing.\n\nOverwrite the descriptor attributes in the class.\n\nThe descriptors are really gone.\n\nExample 23-12 reveals another asymmetry regarding reading and writing attributes: although the reading of a class attribute can be controlled by a descriptor with __get__ attached to the managed class, the writing of a class attribute cannot be han‐ dled by a descriptor with __set__ attached to the same class.\n\nOverriding Versus Nonoverriding Descriptors\n\n|\n\n897",
      "content_length": 1903,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 928,
      "content": "In order to control the setting of attributes in a class, you have to attach descriptors to the class of the class—in other words, the met‐ aclass. By default, the metaclass of user-defined classes is type, and you cannot add attributes to type. But in Chapter 24, we’ll create our own metaclasses.\n\nLet’s now focus on how descriptors are used to implement methods in Python.\n\nMethods Are Descriptors A function within a class becomes a bound method when invoked on an instance because all user-defined functions have a __get__ method, therefore they operate as descriptors when attached to a class. Example 23-13 demonstrates reading the spam method from the Managed class introduced in Example 23-8.\n\nExample 23-13. A method is a nonoverriding descriptor\n\n>>> obj = Managed() >>> obj.spam <bound method Managed.spam of <descriptorkinds.Managed object at 0x74c80c>> >>> Managed.spam <function Managed.spam at 0x734734> >>> obj.spam = 7 >>> obj.spam 7\n\nReading from obj.spam retrieves a bound method object.\n\nBut reading from Managed.spam retrieves a function.\n\nAssigning a value to obj.spam shadows the class attribute, rendering the spam method inaccessible from the obj instance.\n\nFunctions do not implement __set__, therefore they are nonoverriding descriptors, as the last line of Example 23-13 shows.\n\nThe other key takeaway from Example 23-13 is that obj.spam and Managed.spam retrieve different objects. As usual with descriptors, the __get__ of a function returns a reference to itself when the access happens through the managed class. But when the access goes through an instance, the __get__ of the function returns a bound method object: a callable that wraps the function and binds the managed instance (e.g., obj) to the first argument of the function (i.e., self), like the functools.par tial function does (as seen in “Freezing Arguments with functools.partial” on page 247). For a deeper understanding of this mechanism, take a look at Example 23-14.\n\n898\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 2011,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 929,
      "content": "Example 23-14. method_is_descriptor.py: a Text class, derived from UserString\n\nimport collections\n\nclass Text(collections.UserString):\n\ndef __repr__(self): return 'Text({!r})'.format(self.data)\n\ndef reverse(self): return self[::-1]\n\nNow let’s investigate the Text.reverse method. See Example 23-15.\n\nExample 23-15. Experiments with a method\n\n>>> word = Text('forward') >>> word Text('forward') >>> word.reverse() Text('drawrof') >>> Text.reverse(Text('backward')) Text('drawkcab') >>> type(Text.reverse), type(word.reverse) (<class 'function'>, <class 'method'>) >>> list(map(Text.reverse, ['repaid', (10, 20, 30), Text('stressed')])) ['diaper', (30, 20, 10), Text('desserts')] >>> Text.reverse.__get__(word) <bound method Text.reverse of Text('forward')> >>> Text.reverse.__get__(None, Text) <function Text.reverse at 0x101244e18> >>> word.reverse <bound method Text.reverse of Text('forward')> >>> word.reverse.__self__ Text('forward') >>> word.reverse.__func__ is Text.reverse True\n\nThe repr of a Text instance looks like a Text constructor call that would make an equal instance.\n\nThe reverse method returns the text spelled backward.\n\nA method called on the class works as a function.\n\nNote the different types: a function and a method.\n\nMethods Are Descriptors\n\n|\n\n899",
      "content_length": 1274,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 930,
      "content": "Text.reverse operates as a function, even working with objects that are not instances of Text.\n\nAny function is a nonoverriding descriptor. Calling its __get__ with an instance retrieves a method bound to that instance.\n\nCalling the function’s __get__ with None as the instance argument retrieves the function itself.\n\nThe expression word.reverse actually invokes Text.reverse.__get__(word), returning the bound method.\n\nThe bound method object has a __self__ attribute holding a reference to the instance on which the method was called.\n\nThe __func__ attribute of the bound method is a reference to the original func‐ tion attached to the managed class.\n\nThe bound method object also has a __call__ method, which handles the actual invocation. This method calls the original function referenced in __func__, passing the __self__ attribute of the method as the first argument. That’s how the implicit binding of the conventional self argument works.\n\nThe way functions are turned into bound methods is a prime example of how descriptors are used as infrastructure in the language.\n\nAfter this deep dive into how descriptors and methods work, let’s go through some practical advice about their use.\n\nDescriptor Usage Tips The following list addresses some practical consequences of the descriptor character‐ istics just described:\n\nUse property to keep it simple\n\nThe property built-in creates overriding descriptors implementing __set__ and __get__ even if you do not define a setter method.7 The default __set__ of a property raises AttributeError: can't set attribute, so a property is the easiest way to create a read-only attribute, avoiding the issue described next.\n\n7 A __delete__ method is also provided by the property decorator, even if no deleter method is defined by\n\nyou.\n\n900\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 1827,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 931,
      "content": "Read-only descriptors require __set__\n\nIf you use a descriptor class to implement a read-only attribute, you must remember to code both __get__ and __set__, otherwise setting a namesake attribute on an instance will shadow the descriptor. The __set__ method of a read-only attribute should just raise AttributeError with a suitable message.8\n\nValidation descriptors can work with __set__ only\n\nIn a descriptor designed only for validation, the __set__ method should check the value argument it gets, and if valid, set it directly in the instance __dict__ using the descriptor instance name as key. That way, reading the attribute with the same name from the instance will be as fast as possible, because it will not require a __get__. See the code for Example 23-3.\n\nCaching can be done efficiently with __get__ only\n\nIf you code just the __get__ method, you have a nonoverriding descriptor. These are useful to make some expensive computation and then cache the result by set‐ ting an attribute by the same name on the instance.9 The namesake instance attribute will shadow the descriptor, so subsequent access to that attribute will fetch it directly from the instance __dict__ and not trigger the descriptor __get__ anymore. The @functools.cached_property decorator actually pro‐ duces a nonoverriding descriptor.\n\nNonspecial methods can be shadowed by instance attributes\n\nBecause functions and methods only implement __get__, they are nonoverriding descriptors. A simple assignment like my_obj.the_method = 7 means that fur‐ ther access to the_method through that instance will retrieve the number 7— without affecting the class or other instances. However, this issue does not inter‐ fere with special methods. The interpreter only looks for special methods in the class itself, in other words, repr(x) is executed as x.__class__.__repr__(x), so a __repr__ attribute defined in x has no effect on repr(x). For the same reason, the existence of an attribute named __getattr__ in an instance will not subvert the usual attribute access algorithm.\n\nThe fact that nonspecial methods can be overridden so easily in instances may sound fragile and error prone, but I personally have never been bitten by this in more than 20 years of Python coding. On the other hand, if you are doing a lot of dynamic\n\n8 Python is not consistent in such messages. Trying to change the c.real attribute of a complex number gets AttributeError: readonly attribute, but an attempt to change c.conjugate (a method of complex), results in AttributeError: 'complex' object attribute 'conjugate' is read-only. Even the spelling of “read-only” is different.\n\n9 However, recall that creating instance attributes after the __init__ method runs defeats the key-sharing memory optimization, as discussed in from “Practical Consequences of How dict Works” on page 102.\n\nDescriptor Usage Tips\n\n|\n\n901",
      "content_length": 2870,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 932,
      "content": "attribute creation, where the attribute names come from data you don’t control (as we did in the earlier parts of this chapter), then you should be aware of this and per‐ haps implement some filtering or escaping of the dynamic attribute names to pre‐ serve your sanity.\n\nThe FrozenJSON class in Example 22-5 is safe from instance attribute shadowing methods because its only methods are special methods and the build class method. Class methods are safe as long as they are always accessed through the class, as I did with FrozenJSON.build in Example 22-5—later replaced by __new__ in Example 22-6. The Record and Event classes presented in “Com‐ puted Properties” on page 845 are also safe: they implement only special methods, static methods, and properties. Properties are overriding descriptors, so they are not shadowed by instance attributes.\n\nTo close this chapter, we’ll cover two features we saw with properties that we have not addressed in the context of descriptors: documentation and handling attempts to delete a managed attribute.\n\nDescriptor Docstring and Overriding Deletion The docstring of a descriptor class is used to document every instance of the descrip‐ tor in the managed class. Figure 23-4 shows the help displays for the LineItem class with the Quantity and NonBlank descriptors from Examples 23-6 and 23-7.\n\nThat is somewhat unsatisfactory. In the case of LineItem, it would be good to add, for example, the information that weight must be in kilograms. That would be trivial with properties, because each property handles a specific managed attribute. But with descriptors, the same Quantity descriptor class is used for weight and price.10\n\nThe second detail we discussed with properties, but have not addressed with descrip‐ tors, is handling attempts to delete a managed attribute. That can be done by imple‐ menting a __delete__ method alongside or instead of the usual __get__ and/or __set__ in the descriptor class. I deliberately omitted coverage of __delete__ because I believe real-world usage is rare. If you need this, please see the “Implement‐ ing Descriptors” section of the Python Data Model documentation. Coding a silly descriptor class with __delete__ is left as an exercise to the leisurely reader.\n\n10 Customizing the help text for each descriptor instance is surprisingly hard. One solution requires dynamically\n\nbuilding a wrapper class for each descriptor instance.\n\n902\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 2462,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 933,
      "content": "Figure 23-4. Screenshots of the Python console when issuing the commands help(LineI tem.weight) and help(LineItem).\n\nChapter Summary The first example of this chapter was a continuation of the LineItem examples from Chapter 22. In Example 23-2, we replaced properties with descriptors. We saw that a descriptor is a class that provides instances that are deployed as attributes in the man‐ aged class. Discussing this mechanism required special terminology, introducing terms such as managed instance and storage attribute.\n\nIn “LineItem Take #4: Automatic Naming of Storage Attributes” on page 887, we removed the requirement that Quantity descriptors were declared with an explicit storage_name, which was redundant and error prone. The solution was to imple‐ ment the __set_name__ special method in Quantity, to save the name of the man‐ aged property as self.storage_name.\n\n“LineItem Take #5: A New Descriptor Type” on page 889 showed how to subclass an abstract descriptor class to share code while building specialized descriptors with some common functionality.\n\nChapter Summary\n\n|\n\n903",
      "content_length": 1093,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 934,
      "content": "We then looked at the different behaviors of descriptors providing or omitting the __set__ method, making the crucial distinction between overriding and nonoverrid‐ ing descriptors, a.k.a. data and nondata descriptors. Through detailed testing we uncovered when descriptors are in control and when they are shadowed, bypassed, or overwritten.\n\nFollowing that, we studied a particular category of nonoverriding descriptors: meth‐ ods. Console experiments revealed how a function attached to a class becomes a method when accessed through an instance, by leveraging the descriptor protocol.\n\nTo conclude the chapter, “Descriptor Usage Tips” on page 900 presented practical tips, and “Descriptor Docstring and Overriding Deletion” on page 902 provided a brief look at how to document descriptors.\n\nAs noted in “What’s New in This Chapter” on page 880, several examples in this chapter became much simpler thanks to the __set_name__ special method of the descriptor protocol, added in Python 3.6. That’s language evolution!\n\nFurther Reading Besides the obligatory reference to the “Data Model” chapter, Raymond Hettinger’s “Descriptor HowTo Guide” is a valuable resource—part of the HowTo collection in the official Python documentation.\n\nAs usual with Python object model subjects, Martelli, Ravenscroft, and Holden’s Python in a Nutshell, 3rd ed. (O’Reilly) is authoritative and objective. Martelli also has a presentation titled “Python’s Object Model,” which covers properties and descriptors in depth (see the slides and video).\n\nBeware that any coverage of descriptors written or recorded before PEP 487 was adopted in 2016 is likely to contain examples that are needlessly complicated today, because __set_name__ was not sup‐ ported in Python versions prior to 3.6.\n\nFor more practical examples, Python Cookbook, 3rd ed., by David Beazley and Brian K. Jones (O’Reilly), has many recipes illustrating descriptors, of which I want to highlight “6.12. Reading Nested and Variable-Sized Binary Structures,” “8.10. Using Lazily Computed Properties,” “8.13. Implementing a Data Model or Type System,” and “9.9. Defining Decorators As Classes.” The last recipe of which addresses deep issues with the interaction of function decorators, descriptors, and methods, explaining how a function decorator implemented as a class with __call__ also\n\n904\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 2379,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 935,
      "content": "needs to implement __get__ if it wants to work with decorating methods as well as functions.\n\nPEP 487—Simpler customization of class creation introduced the __set_name__ spe‐ cial method, and includes an example of a validating descriptor.\n\nSoapbox\n\nThe Design of self\n\nThe requirement to explicitly declare self as a first argument in methods is a contro‐ versial design decision in Python. After 23 years using the language, I am used to it. I think that decision is an example of “worse is better”: a design philosophy described by computer scientist Richard P. Gabriel in “The Rise of Worse is Better”. The first priority of this philosophy is “simplicity,” which Gabriel presents as:\n\nThe design must be simple, both in implementation and interface. It is more impor‐ tant for the implementation to be simple than the interface. Simplicity is the most important consideration in a design.\n\nPython’s explicit self embodies that design philosophy. The implementation is sim‐ ple—elegant even—at the expense of the user interface: a method signature like def zfill(self, width): doesn’t visually match the invocation label.zfill(8).\n\nModula-3 introduced that convention with the same identifier self. But there is a key difference: in Modula-3, interfaces are declared separately from their implemen‐ tation, and in the interface declaration the self argument is omitted, so from the user’s perspective, a method appears in an interface declaration with the same explicit parameters used to call it.\n\nOver time, Python’s error messages related to method arguments became clearer. For a user-defined method with one argument besides self, if the user invokes obj.meth(), Python 2.7 raised:\n\nTypeError: meth() takes exactly 2 arguments (1 given)\n\nIn Python 3, the confusing argument count is not mentioned, and the missing argu‐ ment is named:\n\nTypeError: meth() missing 1 required positional argument: 'x'\n\nBesides the use of self as an explicit argument, the requirement to qualify every access to instance attributes with self is also criticized. See, for example, A. M. Kuch‐ ling’s famous “Python Warts” post (archived); Kuchling himself is not so bothered by the self qualifier, but he mentions it—probably echoing opinions from the comp.lang.python group. I personally don’t mind typing the self qualifier: it’s good to distinguish local variables from attributes. My issue is with the use of self in the def statement.\n\nFurther Reading\n\n|\n\n905",
      "content_length": 2451,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 936,
      "content": "Anyone who is unhappy about the explicit self in Python can feel a lot better by con‐ sidering the baffling semantics of the implicit this in JavaScript. Guido had some good reasons to make self work as it does, and he wrote about them in “Adding Sup‐ port for User-Defined Classes”, a post on his blog, The History of Python.\n\n906\n\n|\n\nChapter 23: Attribute Descriptors",
      "content_length": 369,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 937,
      "content": "CHAPTER 24 Class Metaprogramming\n\nEveryone knows that debugging is twice as hard as writing a program in the first place. So if you’re as clever as you can be when you write it, how will you ever debug it? —Brian W. Kernighan and P. J. Plauger, The Elements of Programming Style1\n\nClass metaprogramming is the art of creating or customizing classes at runtime. Classes are first-class objects in Python, so a function can be used to create a new class at any time, without using the class keyword. Class decorators are also func‐ tions, but designed to inspect, change, and even replace the decorated class with another class. Finally, metaclasses are the most advanced tool for class metaprogram‐ ming: they let you create whole new categories of classes with special traits, such as the abstract base classes we’ve already seen.\n\nMetaclasses are powerful, but hard to justify and even harder to get right. Class deco‐ rators solve many of the same problems and are easier to understand. Furthermore, Python 3.6 implemented PEP 487—Simpler customization of class creation, provid‐ ing special methods supporting tasks that previously required metaclasses or class decorators.2\n\nThis chapter presents the class metaprogramming techniques in ascending order of complexity.\n\n1 Quote from Chapter 2, “Expression” of The Elements of Programming Style, 2nd ed. (McGraw-Hill), page 10.\n\n2 That doesn’t mean PEP 487 broke code that used those features. It just means that some code that used class decorators or metaclasses prior to Python 3.6 can now be refactored to use plain classes, resulting in simpler and possibly more efficient code.\n\n907",
      "content_length": 1640,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 938,
      "content": "This is an exciting topic, and it’s easy to get carried away. So I must offer this advice.\n\nFor the sake of readability and maintainability, you should proba‐ bly avoid the techniques described in this chapter in application code.\n\nOn the other hand, these are the tools of the trade if you want to write the next great Python framework.\n\nWhat’s New in This Chapter All the code in the “Class Metaprogramming” chapter of the first edition of Fluent Python still runs correctly. However, some of the previous examples no longer repre‐ sent the simplest solutions in light of new features added since Python 3.6.\n\nI replaced those examples with different ones, highlighting Python’s new metaprog‐ ramming features or adding further requirements to justify the use of the more advanced techniques. Some of the new examples leverage type hints to provide class builders similar to the @dataclass decorator and typing.NamedTuple.\n\n“Metaclasses in the Real World” on page 947 is a new section with some high-level con‐ siderations about the applicability of metaclasses.\n\nSome of the best refactorings are removing code made redundant by newer and simpler ways of solving the same problems. This applies to production code as well as books.\n\nWe’ll get started by reviewing attributes and methods defined in the Python Data Model for all classes.\n\nClasses as Objects Like most program entities in Python, classes are also objects. Every class has a num‐ ber of attributes defined in the Python Data Model, documented in “4.13. Special Attributes” of the “Built-in Types” chapter in The Python Standard Library. Three of those attributes appeared several times in this book already: __class__, __name__, and __mro__. Other class standard attributes are:\n\ncls.__bases__\n\nThe tuple of base classes of the class.\n\n908\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1844,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 939,
      "content": "cls.__qualname__\n\nThe qualified name of a class or function, which is a dotted path from the global scope of the module to the class definition. This is relevant when the class is defined inside another class. For example, in a Django model class such as Ox, there is an inner class called Meta. The __qualname__ of Meta is Ox.Meta, but its __name__ is just Meta. The specification for this attribute is PEP 3155—Qualified name for classes and functions.\n\ncls.__subclasses__()\n\nThis method returns a list of the immediate subclasses of the class. The imple‐ mentation uses weak references to avoid circular references between the super‐ class and its subclasses—which hold a strong reference to the superclasses in their __bases__ attribute. The method lists subclasses currently in memory. Sub‐ classes in modules not yet imported will not appear in the result.\n\ncls.mro()\n\nThe interpreter calls this method when building a class to obtain the tuple of superclasses stored in the __mro__ attribute of the class. A metaclass can override this method to customize the method resolution order of the class under construction.\n\nNone of the attributes mentioned in this section are listed by the dir(…) function.\n\nNow, if a class is an object, what is the class of a class?\n\ntype: The Built-In Class Factory We usually think of type as a function that returns the class of an object, because that’s what type(my_object) does: it returns my_object.__class__.\n\nHowever, type is a class that creates a new class when invoked with three arguments.\n\nConsider this simple class:\n\nclass MyClass(MySuperClass, MyMixin): x = 42\n\ndef x2(self): return self.x * 2\n\nUsing the type constructor, you can create MyClass at runtime with this code:\n\ntype: The Built-In Class Factory\n\n|\n\n909",
      "content_length": 1768,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 940,
      "content": "MyClass = type('MyClass', (MySuperClass, MyMixin), {'x': 42, 'x2': lambda self: self.x * 2}, )\n\nThat type call is functionally equivalent to the previous class MyClass… block statement.\n\nWhen Python reads a class statement, it calls type to build the class object with these parameters:\n\nname\n\nThe identifier that appears after the class keyword, e.g., MyClass.\n\nbases\n\nThe tuple of superclasses given in parentheses after the class identifier, or (object,) if superclasses are not mentioned in the class statement.\n\ndict\n\nA mapping of attribute names to values. Callables become methods, as we saw in “Methods Are Descriptors” on page 898. Other values become class attributes.\n\nThe type constructor accepts optional keyword arguments, which are ignored by type itself, but are passed untouched into __init_subclass__, which must consume them. We’ll study that special method in “Introducing __init_subclass__” on page 914, but I won’t cover the use of keyword arguments. For more, please read PEP 487—Simpler customization of class creation.\n\nThe type class is a metaclass: a class that builds classes. In other words, instances of the type class are classes. The standard library provides a few other metaclasses, but type is the default:\n\n>>> type(7) <class 'int'> >>> type(int) <class 'type'> >>> type(OSError) <class 'type'> >>> class Whatever: ... pass ... >>> type(Whatever) <class 'type'>\n\nWe’ll build custom metaclasses in “Metaclasses 101” on page 931.\n\nNext, we’ll use the type built-in to make a function that builds classes.\n\n910\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1581,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 941,
      "content": "A Class Factory Function The standard library has a class factory function that appears several times in this book: collections.namedtuple. In Chapter 5 we also saw typing.NamedTuple and @dataclass. All of these class builders leverage techniques covered in this chapter.\n\nWe’ll start with a super simple factory for classes of mutable objects—the simplest possible replacement for @dataclass.\n\nSuppose I’m writing a pet shop application and I want to store data for dogs as simple records. But I don’t want to write boilerplate like this:\n\nclass Dog: def __init__(self, name, weight, owner): self.name = name self.weight = weight self.owner = owner\n\nBoring…each field name appears three times, and that boilerplate doesn’t even buy us a nice repr:\n\n>>> rex = Dog('Rex', 30, 'Bob') >>> rex <__main__.Dog object at 0x2865bac>\n\nTaking a hint from collections.namedtuple, let’s create a record_factory that cre‐ ates simple classes like Dog on the fly. Example 24-1 shows how it should work.\n\nExample 24-1. Testing record_factory, a simple class factory\n\n>>> Dog = record_factory('Dog', 'name weight owner') >>> rex = Dog('Rex', 30, 'Bob') >>> rex Dog(name='Rex', weight=30, owner='Bob') >>> name, weight, _ = rex >>> name, weight ('Rex', 30) >>> \"{2}'s dog weighs {1}kg\".format(*rex) \"Bob's dog weighs 30kg\" >>> rex.weight = 32 >>> rex Dog(name='Rex', weight=32, owner='Bob') >>> Dog.__mro__ (<class 'factories.Dog'>, <class 'object'>)\n\nFactory can be called like namedtuple: class name, followed by attribute names separated by spaces in a single string.\n\nNice repr.\n\nA Class Factory Function\n\n|\n\n911",
      "content_length": 1599,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 942,
      "content": "Instances are iterable, so they can be conveniently unpacked on assignment…\n\n…or when passing to functions like format.\n\nA record instance is mutable.\n\nThe newly created class inherits from object—no relationship to our factory.\n\nThe code for record_factory is in Example 24-2.3\n\nExample 24-2. record_factory.py: a simple class factory\n\nfrom typing import Union, Any from collections.abc import Iterable, Iterator\n\nFieldNames = Union[str, Iterable[str]]\n\ndef record_factory(cls_name: str, field_names: FieldNames) -> type[tuple]:\n\nslots = parse_identifiers(field_names)\n\ndef __init__(self, *args, **kwargs) -> None: attrs = dict(zip(self.__slots__, args)) attrs.update(kwargs) for name, value in attrs.items(): setattr(self, name, value)\n\ndef __iter__(self) -> Iterator[Any]: for name in self.__slots__: yield getattr(self, name)\n\ndef __repr__(self): values = ', '.join(f'{name}={value!r}' for name, value in zip(self.__slots__, self)) cls_name = self.__class__.__name__ return f'{cls_name}({values})'\n\ncls_attrs = dict( __slots__=slots, __init__=__init__, __iter__=__iter__, __repr__=__repr__, )\n\nreturn type(cls_name, (object,), cls_attrs)\n\n3 Thanks to my friend J. S. O. Bueno for contributing to this example.\n\n912\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1256,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 943,
      "content": "def parse_identifiers(names: FieldNames) -> tuple[str, ...]: if isinstance(names, str): names = names.replace(',', ' ').split() if not all(s.isidentifier() for s in names): raise ValueError('names must all be valid identifiers') return tuple(names)\n\nUser can provide field names as a single string or an iterable of strings.\n\nAccept arguments like the first two of collections.namedtuple; return a type— i.e., a class that behaves like a tuple.\n\nBuild a tuple of attribute names; this will be the __slots__ attribute of the new class.\n\nThis function will become the __init__ method in the new class. It accepts posi‐ tional and/or keyword arguments.4\n\nYield the field values in the order given by __slots__.\n\nProduce the nice repr, iterating over __slots__ and self.\n\nAssemble a dictionary of class attributes.\n\nBuild and return the new class, calling the type constructor.\n\nConvert names separated by spaces or commas to list of str.\n\nExample 24-2 is the first time we’ve seen type in a type hint. If the annotation was just -> type, that would mean that record_factory returns a class—and it would be correct. But the annotation -> type[tuple] is more precise: it says the returned class will be a subclass of tuple.\n\nThe last line of record_factory in Example 24-2 builds a class named by the value of cls_name, with object as its single immediate base class, and with a namespace loaded with __slots__, __init__, __iter__, and __repr__, of which the last three are instance methods.\n\nWe could have named the __slots__ class attribute anything else, but then we’d have to implement __setattr__ to validate the names of attributes being assigned,\n\n4 I did not add type hints to the arguments because the actual types are Any. I put the return type hint because\n\notherwise Mypy will not check inside the method.\n\nA Class Factory Function\n\n|\n\n913",
      "content_length": 1846,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 944,
      "content": "because for our record-like classes we want the set of attributes to be always the same and in the same order. However, recall that the main feature of __slots__ is saving memory when you are dealing with millions of instances, and using __slots__ has some drawbacks, discussed in “Saving Memory with __slots__” on page 384.\n\nInstances of classes created by record_factory are not serializable —that is, they can’t be exported with the dump function from the pickle module. Solving this problem is beyond the scope of this example, which aims to show the type class in action in a simple use case. For the full solution, study the source code for collections.namedtuple; search for the word “pickling.”\n\nNow let’s see how to emulate more modern class builders like typing.NamedTuple, which takes a user-defined class written as a class statement, and automatically enhances it with more functionality.\n\nIntroducing __init_subclass__ Both __init_subclass__ and __set_name__ were proposed in PEP 487—Simpler customization of class creation. We saw the __set_name__ special method for descriptors for the first time in “LineItem Take #4: Automatic Naming of Storage Attributes” on page 887. Now let’s study __init_subclass__.\n\nIn Chapter 5, we saw that typing.NamedTuple and @dataclass let programmers use the class statement to specify attributes for a new class, which is then enhanced by the class builder with the automatic addition of essential methods like __init__, __repr__, __eq__, etc.\n\nBoth of these class builders read type hints in the user’s class statement to enhance the class. Those type hints also allow static type checkers to validate code that sets or gets those attributes. However, NamedTuple and @dataclass do not take advantage of the type hints for attribute validation at runtime. The Checked class in the next example does.\n\nIt is not possible to support every conceivable static type hint for runtime type checking, which is probably why typing.NamedTuple and @dataclass don’t even try it. However, some types that are also concrete classes can be used with Checked. This includes sim‐ ple types often used for field contents, such as str, int, float, and bool, as well as lists of those types.\n\nExample 24-3 shows how to use Checked to build a Movie class.\n\n914\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 2326,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 945,
      "content": "Example 24-3. initsub/checkedlib.py: doctest for creating a Movie subclass of Checked\n\n>>> class Movie(Checked): ... title: str ... year: int ... box_office: float ... >>> movie = Movie(title='The Godfather', year=1972, box_office=137) >>> movie.title 'The Godfather' >>> movie Movie(title='The Godfather', year=1972, box_office=137.0)\n\nMovie inherits from Checked—which we’ll define later in Example 24-5.\n\nEach attribute is annotated with a constructor. Here I used built-in types.\n\nMovie instances must be created using keyword arguments.\n\nIn return, you get a nice __repr__.\n\nThe constructors used as the attribute type hints may be any callable that takes zero or one argument and returns a value suitable for the intended field type, or rejects the argument by raising TypeError or ValueError.\n\nUsing built-in types for the annotations in Example 24-3 means the values must be acceptable by the constructor of the type. For int, this means any x such that int(x) returns an int. For str, anything goes at runtime, because str(x) works with any x in Python.5\n\nWhen called with no arguments, the constructor should return a default value of its type.6\n\nThis is standard behavior for Python’s built-in constructors:\n\n>>> int(), float(), bool(), str(), list(), dict(), set() (0, 0.0, False, '', [], {}, set())\n\n5 That’s true for any object, except when its class overrides the __str__ or __repr__ methods inherited from\n\nobject with broken implementations.\n\n6 This solution avoids using None as a default. Avoiding null values is a good idea. They are hard to avoid in\n\ngeneral, but easy in some cases. In Python as well as SQL, I prefer to represent missing data in a text field with an empty string instead of None or NULL. Learning Go reinforced this idea: variables and struct fields of primi‐ tive types in Go are initialized by default with a “zero value.” See “Zero values” in the online Tour of Go if you are curious.\n\nIntroducing __init_subclass__\n\n|\n\n915",
      "content_length": 1966,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 946,
      "content": "In a Checked subclass like Movie, missing parameters create instances with default values returned by the field constructors. For example:\n\n>>> Movie(title='Life of Brian') Movie(title='Life of Brian', year=0, box_office=0.0)\n\nThe constructors are used for validation during instantiation and when an attribute is set directly on an instance:\n\n>>> blockbuster = Movie(title='Avatar', year=2009, box_office='billions') Traceback (most recent call last): ... TypeError: 'billions' is not compatible with box_office:float >>> movie.year = 'MCMLXXII' Traceback (most recent call last): ... TypeError: 'MCMLXXII' is not compatible with year:int\n\nChecked Subclasses and Static Type Checking\n\nIn a .py source file with a movie instance of Movie, as defined in Example 24-3, Mypy flags this assignment as a type error:\n\nmovie.year = 'MCMLXXII'\n\nHowever, Mypy can’t detect type errors in this constructor call:\n\nblockbuster = Movie(title='Avatar', year='MMIX')\n\nThat’s because Movie inherits Checked.__init__, and the signature of that method must accept any keyword arguments to support arbitrary user-defined classes. On the other hand, if you declare a Checked subclass field with the type hint list[float], Mypy can flag assignments of lists with incompatible contents, but Checked will ignore the type parameter and treat that the same as list.\n\nNow let’s look at the implementation of checkedlib.py. The first class is the Field descriptor, as shown in Example 24-4.\n\nExample 24-4. initsub/checkedlib.py: the Field descriptor class\n\nfrom collections.abc import Callable from typing import Any, NoReturn, get_type_hints\n\nclass Field: def __init__(self, name: str, constructor: Callable) -> None: if not callable(constructor) or constructor is type(None): raise TypeError(f'{name!r} type hint must be callable') self.name = name\n\n916\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1866,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 947,
      "content": "self.constructor = constructor\n\ndef __set__(self, instance: Any, value: Any) -> None: if value is ...: value = self.constructor() else: try: value = self.constructor(value) except (TypeError, ValueError) as e: type_name = self.constructor.__name__ msg = f'{value!r} is not compatible with {self.name}:{type_name}' raise TypeError(msg) from e instance.__dict__[self.name] = value\n\nRecall that since Python 3.9, the Callable type for annotations is the ABC in collections.abc, and not the deprecated typing.Callable.\n\nThis is a minimal Callable type hint; the parameter type and return type for constructor are both implicitly Any.\n\nFor runtime checking, we use the callable built-in.7 The test against type(None) is necessary because Python reads None in a type as NoneType, the class of None (therefore callable), but a useless constructor that only returns None.\n\nIf Checked.__init__ sets the value as ... (the Ellipsis built-in object), we call the constructor with no arguments.\n\nOtherwise, call the constructor with the given value.\n\nIf constructor raises either of these exceptions, we raise TypeError with a help‐ ful message including the names of the field and constructor; e.g., 'MMIX' is not compatible with year:int.\n\nIf no exceptions were raised, the value is stored in the instance.__dict__.\n\nIn __set__, we need to catch TypeError and ValueError because built-in construc‐ tors may raise either of them, depending on the argument. For example, float(None) raises TypeError, but float('A') raises ValueError. On the other hand, float('8') raises no error and returns 8.0. I hereby declare that this is a feature and not a bug of this toy example.\n\n7 I believe that callable should be made suitable for type hinting. As of May 6, 2021, this is an open issue.\n\nIntroducing __init_subclass__\n\n|\n\n917",
      "content_length": 1809,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 948,
      "content": "In “LineItem Take #4: Automatic Naming of Storage Attributes” on page 887, we saw the handy __set_name__ special method for descriptors. We don’t need it in the Field class because the descriptors are not instantiated in client source code; the user declares types that are constructors, as we saw in the Movie class (Example 24-3). Instead, the Field descriptor instances are created at runtime by the Checked.__init_subclass__ method, which we’ll see in Example 24-5.\n\nNow let’s focus on the Checked class. I split it in two listings. Example 24-5 shows the top of the class, which includes the most important methods in this example. The remaining methods are in Example 24-6.\n\nExample 24-5. initsub/checkedlib.py: the most important methods of the Checked class\n\nclass Checked: @classmethod def _fields(cls) -> dict[str, type]: return get_type_hints(cls)\n\ndef __init_subclass__(subclass) -> None: super().__init_subclass__() for name, constructor in subclass._fields().items(): setattr(subclass, name, Field(name, constructor))\n\ndef __init__(self, **kwargs: Any) -> None: for name in self._fields(): value = kwargs.pop(name, ...) setattr(self, name, value) if kwargs: self.__flag_unknown_attrs(*kwargs)\n\nI wrote this class method to hide the call to typing.get_type_hints from the rest of the class. If I need to support Python ≥ 3.10 only, I’d call inspect.get_annotations instead. Review “Problems with Annotations at Run‐ time” on page 538 for the issues with those functions.\n\n__init_subclass__ is called when a subclass of the current class is defined. It gets that new subclass as its first argument—which is why I named the argument subclass instead of the usual cls. For more on this, see “__init_subclass__ Is Not a Typical Class Method” on page 919.\n\nsuper().__init_subclass__() is not strictly necessary, but should be invoked to play nice with other classes that might implement .__init_subclass__() in\n\n918\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1961,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 949,
      "content": "the same inheritance graph. See “Multiple Inheritance and Method Resolution Order” on page 494.\n\nIterate over each field name and constructor…\n\n…creating an attribute on subclass with that name bound to a Field descriptor parameterized with name and constructor.\n\nFor each name in the class fields…\n\n…get the corresponding value from kwargs and remove it from kwargs. Using ... (the Ellipsis object) as default allows us to distinguish between argu‐ ments given the value None from arguments that were not given.8\n\nThis setattr call triggers Checked.__setattr__, shown in Example 24-6.\n\nIf there are remaining items in kwargs, their names do not match any of the declared fields, and __init__ will fail.\n\nThe error is reported by __flag_unknown_attrs, listed in Example 24-6. It takes a *names argument with the unknown attribute names. I used a single asterisk in *kwargs to pass its keys as a sequence of arguments.\n\n__init_subclass__ Is Not a Typical Class Method The @classmethod decorator is never used with __init_subclass__, but that doesn’t mean much, because the __new__ special method behaves as a class method even without @classmethod. The first argument that Python passes to __init_subclass__ is a class. However, it is never the class where __init_subclass__ is implemented: it is a newly defined subclass of that class. That’s unlike __new__ and every other class method that I know about. Therefore, I think __init_subclass__ is not a class method in the usual sense, and it is misleading to name the first argument cls. The __init_suclass__ documentation names the argument cls but explains: “…called whenever the containing class is subclassed. cls is then the new subclass.”\n\nNow let’s see the remaining methods of the Checked class, continuing from Example 24-5. Note that I prepended _ to the _fields and _asdict method names\n\n8 As mentioned in “Loops, Sentinels, and Poison Pills” on page 721, the Ellipsis object is a convenient and\n\nsafe sentinel value. It has been around for a long time, but recently people are finding more uses for it, as we see in type hints and NumPy.\n\nIntroducing __init_subclass__\n\n|\n\n919",
      "content_length": 2138,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 950,
      "content": "for the same reason the collections.namedtuple API does: to reduce the chance of name clashes with user-defined field names.\n\nExample 24-6. initsub/checkedlib.py: remaining methods of the Checked class\n\ndef __setattr__(self, name: str, value: Any) -> None: if name in self._fields(): cls = self.__class__ descriptor = getattr(cls, name) descriptor.__set__(self, value) else: self.__flag_unknown_attrs(name)\n\ndef __flag_unknown_attrs(self, *names: str) -> NoReturn: plural = 's' if len(names) > 1 else '' extra = ', '.join(f'{name!r}' for name in names) cls_name = repr(self.__class__.__name__) raise AttributeError(f'{cls_name} object has no attribute{plural} {extra}')\n\ndef _asdict(self) -> dict[str, Any]: return { name: getattr(self, name) for name, attr in self.__class__.__dict__.items() if isinstance(attr, Field) }\n\ndef __repr__(self) -> str: kwargs = ', '.join( f'{key}={value!r}' for key, value in self._asdict().items() ) return f'{self.__class__.__name__}({kwargs})'\n\nIntercept all attempts to set an instance attribute. This is needed to prevent set‐ ting an unknown attribute.\n\nIf the attribute name is known, fetch the corresponding descriptor.\n\nUsually we don’t need to call the descriptor __set__ explicitly. It was necessary in this case because __setattr__ intercepts all attempts to set an attribute on the instance, including in the presence of an overriding descriptor such as Field.9\n\nOtherwise, the attribute name is unknown, and an exception will be raised by __flag_unknown_attrs.\n\n9 The subtle concept of an overriding descriptor was explained in “Overriding Descriptors” on page 894.\n\n920\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1653,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 951,
      "content": "Build a helpful error message listing all unexpected arguments, and raise Attribu teError. This is a rare example of the NoReturn special type, covered in “NoRe‐ turn” on page 294.\n\nCreate a dict from the attributes of a Movie object. I’d call this method _as_dict, but I followed the convention started by the _asdict method in col lections.namedtuple.\n\nImplementing a nice __repr__ is the main reason for having _asdict in this example.\n\nThe Checked example illustrates how to handle overriding descriptors when imple‐ menting __setattr__ to block arbitrary attribute setting after instantiation. It is debatable whether implementing __setattr__ is worthwhile in this example. Without it, setting movie.director = 'Greta Gerwig' would succeed, but the director attribute would not be checked in any way, and would not appear in the __repr__ nor would it be included in the dict returned by _asdict—both defined in Example 24-6.\n\nIn record_factory.py (Example 24-2) I solved this issue using the __slots__ class attribute. However, this simpler solution is not viable in this case, as explained next.\n\nWhy __init_subclass__ Cannot Configure __slots__ The __slots__ attribute is only effective if it is one of the entries in the class name‐ space passed to type.__new__. Adding __slots__ to an existing class has no effect. Python invokes __init_subclass__ only after the class is built—by then it’s too late to configure __slots__. A class decorator can’t configure __slots__ either, because it is applied even later than __init_subclass__. We’ll explore these timing issues in “What Happens When: Import Time Versus Runtime” on page 925.\n\nTo configure __slots__ at runtime, your own code must build the class namespace passed as the last argument of type.__new__. To do that, you can write a class factory function, like record_factory.py, or you can take the nuclear option and implement a metaclass. We will see how to dynamically configure __slots__ in “Metaclasses 101” on page 931.\n\nBefore PEP 487 simplified the customization of class creation with __init_sub class__ in Python 3.7, similar functionality had to be implemented using a class dec‐ orator. That’s the focus of the next section.\n\nIntroducing __init_subclass__\n\n|\n\n921",
      "content_length": 2238,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 952,
      "content": "Enhancing Classes with a Class Decorator A class decorator is a callable that behaves similarly to a function decorator: it gets the decorated class as an argument, and should return a class to replace the decorated class. Class decorators often return the decorated class itself, after injecting more methods in it via attribute assignment.\n\nProbably the most common reason to choose a class decorator over the simpler __init_subclass__ is to avoid interfering with other class features, such as inheri‐ tance and metaclasses.10\n\nIn this section, we’ll study checkeddeco.py, which provides the same service as check‐ edlib.py, but using a class decorator. As usual, we’ll start by looking at a usage exam‐ ple, extracted from the doctests in checkeddeco.py (Example 24-7).\n\nExample 24-7. checkeddeco.py: creating a Movie class decorated with @checked\n\n>>> @checked ... class Movie: ... title: str ... year: int ... box_office: float ... >>> movie = Movie(title='The Godfather', year=1972, box_office=137) >>> movie.title 'The Godfather' >>> movie Movie(title='The Godfather', year=1972, box_office=137.0)\n\nThe only difference between Example 24-7 and Example 24-3 is the way the Movie class is declared: it is decorated with @checked instead of subclassing Checked. Other‐ wise, the external behavior is the same, including the type validation and default value assignments shown after Example 24-3 in “Introducing __init_subclass__” on page 914.\n\nNow let’s look at the implementation of checkeddeco.py. The imports and Field class are the same as in checkedlib.py, listed in Example 24-4. There is no other class, only functions in checkeddeco.py.\n\nThe logic previously implemented in __init_subclass__ is now part of the checked function—the class decorator listed in Example 24-8.\n\n10 This rationale appears in the abstract of PEP 557–Data Classes to explain why it was implemented as a class\n\ndecorator.\n\n922\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1951,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 953,
      "content": "Example 24-8. checkeddeco.py: the class decorator\n\ndef checked(cls: type) -> type: for name, constructor in _fields(cls).items(): setattr(cls, name, Field(name, constructor))\n\ncls._fields = classmethod(_fields) # type: ignore\n\ninstance_methods = ( __init__, __repr__, __setattr__, _asdict, __flag_unknown_attrs, ) for method in instance_methods: setattr(cls, method.__name__, method)\n\nreturn cls\n\nRecall that classes are instances of type. These type hints strongly suggest this is a class decorator: it takes a class and returns a class.\n\n_fields is a top-level function defined later in the module (in Example 24-9).\n\nReplacing each attribute returned by _fields with a Field descriptor instance is what __init_subclass__ did in Example 24-5. Here there is more work to do…\n\nBuild a class method from _fields, and add it to the decorated class. The type: ignore comment is needed because Mypy complains that type has no _fields attribute.\n\nModule-level functions that will become instance methods of the decorated class.\n\nAdd each of the instance_methods to cls.\n\nReturn the decorated cls, fulfilling the essential contract of a class decorator.\n\nEnhancing Classes with a Class Decorator\n\n|\n\n923",
      "content_length": 1197,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 954,
      "content": "Every top-level function in checkeddeco.py is prefixed with an underscore, except the checked decorator. This naming convention makes sense for a couple of reasons:\n\nchecked is part of the public interface of the checkeddeco.py module, but the other functions are not.\n\nThe functions in Example 24-9 will be injected in the decorated class, and the leading _ reduces the chance of naming conflicts with user-defined attributes and methods of the decorated class.\n\nThe rest of checkeddeco.py is listed in Example 24-9. Those module-level functions have the same code as the corresponding methods of the Checked class of checked‐ lib.py. They were explained in Examples 24-5 and 24-6.\n\nNote that the _fields function does double duty in checkeddeco.py. It is used as a regular function in the first line of the checked decorator, and it will also be injected as a class method of the decorated class.\n\nExample 24-9. checkeddeco.py: the methods to be injected in the decorated class\n\ndef _fields(cls: type) -> dict[str, type]: return get_type_hints(cls)\n\ndef __init__(self: Any, **kwargs: Any) -> None: for name in self._fields(): value = kwargs.pop(name, ...) setattr(self, name, value) if kwargs: self.__flag_unknown_attrs(*kwargs)\n\ndef __setattr__(self: Any, name: str, value: Any) -> None: if name in self._fields(): cls = self.__class__ descriptor = getattr(cls, name) descriptor.__set__(self, value) else: self.__flag_unknown_attrs(name)\n\ndef __flag_unknown_attrs(self: Any, *names: str) -> NoReturn: plural = 's' if len(names) > 1 else '' extra = ', '.join(f'{name!r}' for name in names) cls_name = repr(self.__class__.__name__) raise AttributeError(f'{cls_name} has no attribute{plural} {extra}')\n\ndef _asdict(self: Any) -> dict[str, Any]: return { name: getattr(self, name) for name, attr in self.__class__.__dict__.items() if isinstance(attr, Field)\n\n924\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1899,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 955,
      "content": "}\n\ndef __repr__(self: Any) -> str: kwargs = ', '.join( f'{key}={value!r}' for key, value in self._asdict().items() ) return f'{self.__class__.__name__}({kwargs})'\n\nThe checkeddeco.py module implements a simple but usable class decorator. Python’s @dataclass does a lot more. It supports many configuration options, adds more methods to the decorated class, handles or warns about conflicts with user-defined methods in the decorated class, and even traverses the __mro__ to collect user- defined attributes declared in the superclasses of the decorated class. The source code of the dataclasses package in Python 3.9 is more than 1,200 lines long.\n\nFor metaprogramming classes, we must be aware of when the Python interpreter evaluates each block of code during the construction of a class. This is covered next.\n\nWhat Happens When: Import Time Versus Runtime Python programmers talk about “import time” versus “runtime,” but the terms are not strictly defined and there is a gray area between them.\n\nAt import time, the interpreter:\n\n1. Parses the source code of a .py module in one pass from top to bottom. This is when a SyntaxError may occur.\n\n2. Compiles the bytecode to be executed.\n\n3. Executes the top-level code of the compiled module.\n\nIf there is an up-to-date .pyc file available in the local __pycache__, parsing and compiling are skipped because the bytecode is ready to run.\n\nAlthough parsing and compiling are definitely “import time” activities, other things may happen at that time, because almost every statement in Python is executable in the sense that they can potentially run user code and may change the state of the user program.\n\nIn particular, the import statement is not merely a declaration,11 but it actually runs all the top-level code of a module when it is imported for the first time in the process. Further imports of the same module will use a cache, and then the only effect will be binding the imported objects to names in the client module. That top-level code may\n\n11 Contrast with the import statement in Java, which is just a declaration to let the compiler know that certain\n\npackages are required.\n\nWhat Happens When: Import Time Versus Runtime\n\n|\n\n925",
      "content_length": 2196,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 956,
      "content": "do anything, including actions typical of “runtime,” such as writing to a log or con‐ necting to a database.12 That’s why the border between “import time” and “runtime” is fuzzy: the import statement can trigger all sorts of “runtime” behavior. Conversely, “import time” can also happen deep inside runtime, because the import statement and the __import__() built-in can be used inside any regular function.\n\nThis is all rather abstract and subtle, so let’s do some experiments to see what hap‐ pens when.\n\nEvaluation Time Experiments Consider an evaldemo.py script that uses a class decorator, a descriptor, and a class builder based on __init_subclass__, all defined in a builderlib.py module. The modules have several print calls to show what happens under the covers. Otherwise, they don’t perform anything useful. The goal of these experiments is to observe the order in which these print calls happen.\n\nApplying a class decorator and a class builder with __init_sub class__ together in single class is likely a sign of overengineering or desperation. This unusual combination is useful in these experi‐ ments to show the timing of the changes that a class decorator and __init_subclass__ can apply to a class.\n\nLet’s start by checking out builderlib.py, split into two parts: Example 24-10 and Example 24-11.\n\nExample 24-10. builderlib.py: top of the module\n\nprint('@ builderlib module start')\n\nclass Builder: print('@ Builder body')\n\ndef __init_subclass__(cls): print(f'@ Builder.__init_subclass__({cls!r})')\n\ndef inner_0(self): print(f'@ SuperA.__init_subclass__:inner_0({self!r})')\n\ncls.method_a = inner_0\n\ndef __init__(self):\n\n12 I’m not saying opening a database connection just because a module is imported is a good idea, only pointing\n\nout it can be done.\n\n926\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1812,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 957,
      "content": "super().__init__() print(f'@ Builder.__init__({self!r})')\n\ndef deco(cls): print(f'@ deco({cls!r})')\n\ndef inner_1(self): print(f'@ deco:inner_1({self!r})')\n\ncls.method_b = inner_1 return cls\n\nThis is a class builder to implement…\n\n…an __init_subclass__ method.\n\nDefine a function to be added to the subclass in the assignment below.\n\nA class decorator.\n\nFunction to be added to the decorated class.\n\nReturn the class received as an argument.\n\nContinuing with builderlib.py in Example 24-11…\n\nExample 24-11. builderlib.py: bottom of the module\n\nclass Descriptor: print('@ Descriptor body')\n\ndef __init__(self): print(f'@ Descriptor.__init__({self!r})')\n\ndef __set_name__(self, owner, name): args = (self, owner, name) print(f'@ Descriptor.__set_name__{args!r}')\n\ndef __set__(self, instance, value): args = (self, instance, value) print(f'@ Descriptor.__set__{args!r}')\n\ndef __repr__(self): return '<Descriptor instance>'\n\nprint('@ builderlib module end')\n\nWhat Happens When: Import Time Versus Runtime\n\n|\n\n927",
      "content_length": 1007,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 958,
      "content": "A descriptor class to demonstrate when…\n\n…a descriptor instance is created, and when…\n\n…__set_name__ will be invoked during the owner class construction.\n\nLike the other methods, this __set__ doesn’t do anything except display its argu‐ ments.\n\nIf you import builderlib.py in the Python console, this is what you get:\n\n>>> import builderlib @ builderlib module start @ Builder body @ Descriptor body @ builderlib module end\n\nNote that the lines printed by builderlib.py are prefixed with @.\n\nNow let’s turn to evaldemo.py, which will trigger special methods in builderlib.py (Example 24-12).\n\nExample 24-12. evaldemo.py: script to experiment with builderlib.py\n\n#!/usr/bin/env python3\n\nfrom builderlib import Builder, deco, Descriptor\n\nprint('# evaldemo module start')\n\n@deco class Klass(Builder): print('# Klass body')\n\nattr = Descriptor()\n\ndef __init__(self): super().__init__() print(f'# Klass.__init__({self!r})')\n\ndef __repr__(self): return '<Klass instance>'\n\ndef main(): obj = Klass() obj.method_a() obj.method_b() obj.attr = 999\n\n928\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1079,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 959,
      "content": "if __name__ == '__main__': main()\n\nprint('# evaldemo module end')\n\nApply a decorator.\n\nSubclass Builder to trigger its __init_subclass__.\n\nInstantiate the descriptor.\n\nThis will only be called if the module is run as the main program.\n\nThe print calls in evaldemo.py show a # prefix. If you open the console again and import evaldemo.py, Example 24-13 is the output.\n\nExample 24-13. Console experiment with evaldemo.py\n\n>>> import evaldemo @ builderlib module start @ Builder body @ Descriptor body @ builderlib module end # evaldemo module start # Klass body @ Descriptor.__init__(<Descriptor instance>) @ Descriptor.__set_name__(<Descriptor instance>, <class 'evaldemo.Klass'>, 'attr') @ Builder.__init_subclass__(<class 'evaldemo.Klass'>) @ deco(<class 'evaldemo.Klass'>) # evaldemo module end\n\nThe top four lines are the result of from builderlib import… . They will not appear if you didn’t close the console after the previous experiment, because buil‐ derlib.py is already loaded.\n\nThis signals that Python started reading the body of Klass. At this point, the class object does not exist yet.\n\nThe descriptor instance is created and bound to attr in the namespace that Python will pass to the default class object constructor: type.__new__.\n\nAt this point, Python’s built-in type.__new__ has created the Klass object and calls __set_name__ on each descriptor instance of descriptor classes that provide that method, passing Klass as the owner argument.\n\nWhat Happens When: Import Time Versus Runtime\n\n|\n\n929",
      "content_length": 1515,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 960,
      "content": "type.__new__ then calls __init_subclass__ on the superclass of Klass, passing Klass as the single argument.\n\nWhen type.__new__ returns the class object, Python applies the decorator. In this example, the class returned by deco is bound to Klass in the module namespace.\n\nThe implementation of type.__new__ is written in C. The behavior I just described is documented in the “Creating the class object” section of Python’s “Data Model” ref‐ erence.\n\nNote that the main() function of evaldemo.py (Example 24-12) was not executed in the console session (Example 24-13), therefore no instance of Klass was created. All the action we saw was triggered by “import time” operations: importing builderlib and defining Klass.\n\nIf you run evaldemo.py as a script, you will see the same output as Example 24-13 with extra lines right before the end. The extra lines are the result of running main() (Example 24-14).\n\nExample 24-14. Running evaldemo.py as a program\n\n$ ./evaldemo.py [... 9 lines omitted ...] @ deco(<class '__main__.Klass'>) @ Builder.__init__(<Klass instance>) # Klass.__init__(<Klass instance>) @ SuperA.__init_subclass__:inner_0(<Klass instance>) @ deco:inner_1(<Klass instance>) @ Descriptor.__set__(<Descriptor instance>, <Klass instance>, 999) # evaldemo module end\n\nThe top 10 lines—including this one—are the same as shown in Example 24-13.\n\nTriggered by super().__init__() in Klass.__init__.\n\nTriggered by obj.method_a() SuperA.__init_subclass__.\n\nin main; method_a was\n\ninjected by\n\nTriggered by obj.method_b() in main; method_b was injected by deco.\n\nTriggered by obj.attr = 999 in main.\n\nA base class with __init_subclass__ and a class decorator are powerful tools, but they are limited to working with a class already built by type.__new__ under the\n\n930\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1810,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 961,
      "content": "covers. In the rare occasions when you need to adjust the arguments passed to type.__new__, you need a metaclass. That’s the final destination of this chapter—and this book.\n\nMetaclasses 101\n\n[Metaclasses] are deeper magic than 99% of users should ever worry about. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why).\n\n—Tim Peters, inventor of the Timsort algorithm and prolific Python contributor13\n\nA metaclass is a class factory. In contrast with record_factory from Example 24-2, a metaclass is written as a class. In other words, a metaclass is a class whose instances are classes. Figure 24-1 depicts a metaclass using the Mills & Gizmos Notation: a mill producing another mill.\n\nFigure 24-1. A metaclass is a class that builds classes.\n\nConsider the Python object model: classes are objects, therefore each class must be an instance of some other class. By default, Python classes are instances of type. In other words, type is the metaclass for most built-in and user-defined classes:\n\n>>> str.__class__ <class 'type'> >>> from bulkfood_v5 import LineItem >>> LineItem.__class__ <class 'type'>\n\n13 Message to comp.lang.python, subject: “Acrimony in c.l.p.”. This is another part of the same message from\n\nDecember 23, 2002, quoted in the Preface. The TimBot was inspired that day.\n\nMetaclasses 101\n\n|\n\n931",
      "content_length": 1426,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 962,
      "content": ">>> type.__class__ <class 'type'>\n\nTo avoid infinite regress, the class of type is type, as the last line shows.\n\nNote that I am not saying that str or LineItem are subclasses of type. What I am saying is that str and LineItem are instances of type. They all are subclasses of object. Figure 24-2 may help you confront this strange reality.\n\nFigure 24-2. Both diagrams are true. The left one emphasizes that str, type, and LineI tem are subclasses of object. The right one makes it clear that str, object, and LineI tem are instances type, because they are all classes.\n\nThe classes object and type have a unique relationship: object is an instance of type, and type is a subclass of object. This relation‐ ship is “magic”: it cannot be expressed in Python because either class would have to exist before the other could be defined. The fact that type is an instance of itself is also magical.\n\nThe next snippet shows that the class of collections.Iterable is abc.ABCMeta. Note that Iterable is an abstract class, but ABCMeta is a concrete class—after all, Iterable is an instance of ABCMeta:\n\n>>> from collections.abc import Iterable >>> Iterable.__class__ <class 'abc.ABCMeta'> >>> import abc >>> from abc import ABCMeta >>> ABCMeta.__class__ <class 'type'>\n\nUltimately, the class of ABCMeta is also type. Every class is an instance of type, directly or indirectly, but only metaclasses are also subclasses of type. That’s the most important relationship to understand metaclasses: a metaclass, such as ABCMeta,\n\n932\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1556,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 963,
      "content": "inherits from type the power to construct classes. Figure 24-3 illustrates this crucial relationship.\n\nFigure 24-3. Iterable is a subclass of object and an instance of ABCMeta. Both object and ABCMeta are instances of type, but the key relationship here is that ABCMeta is also a subclass of type, because ABCMeta is a metaclass. In this diagram, Iterable is the only abstract class.\n\nThe important takeaway here is that metaclasses are subclasses of type, and that’s what makes them work as class factories. A metaclass can customize its instances by implementing special methods, as the next sections demonstrate.\n\nHow a Metaclass Customizes a Class To use a metaclass, it’s critical to understand how __new__ works on any class. This was discussed in “Flexible Object Creation with __new__” on page 843.\n\nThe same mechanics happen at a “meta” level when a metaclass is about to create a new instance, which is a class. Consider this declaration:\n\nclass Klass(SuperKlass, metaclass=MetaKlass): x = 42 def __init__(self, y): self.y = y\n\nTo process that class statement, Python calls MetaKlass.__new__ with these arguments:\n\nmeta_cls\n\nThe metaclass itself (MetaKlass), because __new__ works as class method.\n\nMetaclasses 101\n\n|\n\n933",
      "content_length": 1232,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 964,
      "content": "cls_name\n\nThe string Klass.\n\nbases\n\nThe single-element tuple (SuperKlass,), with more elements in the case of mul‐ tiple inheritance.\n\ncls_dict\n\nA mapping like:\n\n{x: 42, `__init__`: <function __init__ at 0x1009c4040>}\n\nWhen you implement MetaKlass.__new__, you can inspect and change those argu‐ ments before passing them to super().__new__, which will eventually call type.__new__ to create the new class object.\n\nAfter super().__new__ returns, you can also apply further processing to the newly created class before returning Klass.__init_subclass__, passing the class you created, and then applies a class decorator to it, if one is present. Finally, Python binds the class object to its name in the surrounding namespace—usually the global namespace of a module, if the class statement was a top-level statement.\n\nthen calls Super\n\nit\n\nto Python. Python\n\nThe most common processing made in a metaclass __new__ is to add or replace items in the cls_dict—the mapping that represents the namespace of the class under con‐ struction. For instance, before calling super().__new__, you can inject methods in the class under construction by adding functions to cls_dict. However, note that adding methods can also be done after the class is built, which is why we were able to do it using __init_subclass__ or a class decorator.\n\nOne attribute that you must add to the cls_dict before type.__new__ runs is __slots__, as discussed in “Why __init_subclass__ Cannot Configure __slots__” on page 921. The __new__ method of a metaclass is the ideal place to configure __slots__. The next section shows how to do that.\n\nA Nice Metaclass Example The MetaBunch metaclass presented here is a variation of the last example in Chapter 4 of Python in a Nutshell, 3rd ed., by Alex Martelli, Anna Ravenscroft, and Steve\n\n934\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1845,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 965,
      "content": "Holden, written to run on Python 2.7 and 3.5.14 Assuming Python 3.6 or later, I was able to further simplify the code.\n\nFirst, let’s see what the Bunch base class provides:\n\n>>> class Point(Bunch): ... x = 0.0 ... y = 0.0 ... color = 'gray' ... >>> Point(x=1.2, y=3, color='green') Point(x=1.2, y=3, color='green') >>> p = Point() >>> p.x, p.y, p.color (0.0, 0.0, 'gray') >>> p Point()\n\nRemember that Checked assigns names to the Field descriptors in subclasses based on class variable type hints, which do not actually become attributes on the class since they don’t have values.\n\nBunch subclasses, on the other hand, use actual class attributes with values, which then become the default values of the instance attributes. The generated __repr__ omits the arguments for attributes that are equal to the defaults.\n\nMetaBunch—the metaclass of Bunch—generates __slots__ for the new class from the class attributes declared in the user’s class. This blocks the instantiation and later assignment of undeclared attributes:\n\n>>> Point(x=1, y=2, z=3) Traceback (most recent call last): ... AttributeError: No slots left for: 'z' >>> p = Point(x=21) >>> p.y = 42 >>> p Point(x=21, y=42) >>> p.flavor = 'banana' Traceback (most recent call last): ... AttributeError: 'Point' object has no attribute 'flavor'\n\n14 The authors kindly gave me permission to use their example. MetaBunch first appeared in a message posted by Martelli in the comp.lang.python group on July 7, 2002, with the subject line “a nice metaclass example (was Re: structs in python)”, following a discussion about record-like data structures in Python. Martelli’s original code for Python 2.2 still runs after a single change: to use a metaclass in Python 3, you must use the metaclass keyword argument in the class declaration, e.g., Bunch(metaclass=MetaBunch), instead of the older conven‐ tion of adding a __metaclass__ class-level attribute.\n\nMetaclasses 101\n\n|\n\n935",
      "content_length": 1932,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 966,
      "content": "Now let’s dive into the elegant code of MetaBunch in Example 24-15.\n\nExample 24-15. metabunch/from3.6/bunch.py: MetaBunch metaclass and Bunch class\n\nclass MetaBunch(type): def __new__(meta_cls, cls_name, bases, cls_dict):\n\ndefaults = {}\n\ndef __init__(self, **kwargs): for name, default in defaults.items(): setattr(self, name, kwargs.pop(name, default)) if kwargs: extra = ', '.join(kwargs) raise AttributeError(f'No slots left for: {extra!r}')\n\ndef __repr__(self): rep = ', '.join(f'{name}={value!r}' for name, default in defaults.items() if (value := getattr(self, name)) != default) return f'{cls_name}({rep})'\n\nnew_dict = dict(__slots__=[], __init__=__init__, __repr__=__repr__)\n\nfor name, value in cls_dict.items(): if name.startswith('__') and name.endswith('__'): if name in new_dict: raise AttributeError(f\"Can't set {name!r} in {cls_name!r}\") new_dict[name] = value else: new_dict['__slots__'].append(name) defaults[name] = value return super().__new__(meta_cls, cls_name, bases, new_dict)\n\nclass Bunch(metaclass=MetaBunch): pass\n\nTo create a new metaclass, inherit from type.\n\n__new__ works as a class method, but the class is a metaclass, so I like to name the first argument meta_cls (mcs is a common alternative). The remaining three arguments are the same as the three-argument signature for calling type() directly to create a class.\n\ndefaults will hold a mapping of attribute names and their default values.\n\nThis will be injected into the new class.\n\n936\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1509,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 967,
      "content": "Read the defaults and set the corresponding instance attribute with a value pop‐ ped from kwargs or a default.\n\nIf there is still any item in kwargs, it means there are no slots left where we can place them. We believe in failing fast as best practice, so we don’t want to silently ignore extra items. A quick and effective solution is to pop one item from kwargs and try to set it on the instance, triggering an AttributeError on purpose.\n\n__repr__ returns a string that looks like a constructor call—e.g., Point(x=3), omitting the keyword arguments with default values.\n\nInitialize namespace for the new class.\n\nIterate over the namespace of the user’s class.\n\nIf a dunder name is found, copy the item to the new class namespace, unless it’s already there. This prevents users from overwriting __init__, __repr__, and other attributes set by Python, such as __qualname__ and __module__.\n\nIf not a dunder name, append to __slots__ and save its value in defaults.\n\nBuild and return the new class.\n\nProvide a base class, so users don’t need to see MetaBunch.\n\nMetaBunch works because it is able to configure __slots__ before calling super().__new__ to build the final class. As usual when metaprogramming, under‐ standing the sequence of actions is key. Let’s do another evaluation time experiment, now with a metaclass.\n\nMetaclass Evaluation Time Experiment This is a variation of “Evaluation Time Experiments” on page 926, adding a metaclass to the mix. The builderlib.py module is the same as before, but the main script is now evaldemo_meta.py, listed in Example 24-16.\n\nExample 24-16. evaldemo_meta.py: experimenting with a metaclass\n\n#!/usr/bin/env python3\n\nfrom builderlib import Builder, deco, Descriptor from metalib import MetaKlass\n\nprint('# evaldemo_meta module start')\n\nMetaclasses 101\n\n|\n\n937",
      "content_length": 1805,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 968,
      "content": "@deco class Klass(Builder, metaclass=MetaKlass): print('# Klass body')\n\nattr = Descriptor()\n\ndef __init__(self): super().__init__() print(f'# Klass.__init__({self!r})')\n\ndef __repr__(self): return '<Klass instance>'\n\ndef main(): obj = Klass() obj.method_a() obj.method_b() obj.method_c() obj.attr = 999\n\nif __name__ == '__main__': main()\n\nprint('# evaldemo_meta module end')\n\nImport MetaKlass from metalib.py, which we’ll see in Example 24-18.\n\nDeclare Klass as a subclass of Builder and an instance of MetaKlass.\n\nThis method is injected by MetaKlass.__new__, as we’ll see.\n\nIn the interest of science, Example 24-16 defies all reason and applies three different metaprogramming techniques together on Klass: a decorator, a base class using __init_subclass__, and a custom metaclass. If you do this in production code, please don’t blame me. Again, the goal is to observe the order in which the three techniques interfere in the class construction process.\n\nAs in the previous evaluation time experiment, this example does nothing but print messages revealing the flow of execution. Example 24-17 shows the code for the top part of metalib.py—the rest is in Example 24-18.\n\nExample 24-17. metalib.py: the NosyDict class\n\nprint('% metalib module start')\n\n938\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1296,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 969,
      "content": "import collections\n\nclass NosyDict(collections.UserDict): def __setitem__(self, key, value): args = (self, key, value) print(f'% NosyDict.__setitem__{args!r}') super().__setitem__(key, value)\n\ndef __repr__(self): return '<NosyDict instance>'\n\nI wrote the NosyDict class to override __setitem__ to display each key and value as they are set. The metaclass will use a NosyDict instance to hold the namespace of the class under construction, revealing more of Python’s inner workings.\n\nThe main attraction of metalib.py is the metaclass in Example 24-18. It implements the __prepare__ special method, a class method that Python only invokes on meta‐ classes. The __prepare__ method provides the earliest opportunity to influence the process of creating a new class.\n\nWhen coding a metaclass, I find it useful to adopt this naming con‐ vention for special method arguments:\n\nUse cls instead of self for instance methods, because the instance is a class.\n\nUse meta_cls instead of cls for class methods, because the class is a metaclass. Recall that __new__ behaves as a class method even without the @classmethod decorator.\n\nExample 24-18. metalib.py: the MetaKlass\n\nclass MetaKlass(type): print('% MetaKlass body')\n\n@classmethod def __prepare__(meta_cls, cls_name, bases): args = (meta_cls, cls_name, bases) print(f'% MetaKlass.__prepare__{args!r}') return NosyDict()\n\ndef __new__(meta_cls, cls_name, bases, cls_dict): args = (meta_cls, cls_name, bases, cls_dict) print(f'% MetaKlass.__new__{args!r}') def inner_2(self): print(f'% MetaKlass.__new__:inner_2({self!r})')\n\ncls = super().__new__(meta_cls, cls_name, bases, cls_dict.data)\n\nMetaclasses 101\n\n|\n\n939",
      "content_length": 1654,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 970,
      "content": "cls.method_c = inner_2\n\nreturn cls\n\ndef __repr__(cls): cls_name = cls.__name__ return f\"<class {cls_name!r} built by MetaKlass>\"\n\nprint('% metalib module end')\n\n__prepare__ should be declared as a class method. It is not an instance method because the class under construction does not exist yet when Python calls __prepare__.\n\nPython calls __prepare__ on a metaclass to obtain a mapping to hold the name‐ space of the class under construction.\n\nReturn NosyDict instance to be used as the namespace.\n\ncls_dict is a NosyDict instance returned by __prepare__.\n\ntype.__new__ requires a real dict as the last argument, so I give it the data attribute of NosyDict, inherited from UserDict.\n\nInject a method in the newly created class.\n\nAs usual, __new__ must return the object just created—in this case, the new class.\n\nDefining __repr__ on a metaclass allows customizing the repr() of class objects.\n\nThe main use case for __prepare__ before Python 3.6 was to provide an OrderedDict to hold the attributes of the class under construction, so that the metaclass __new__ could process those attributes in the order in which they appear in the source code of the user’s class definition. Now that dict preserves the insertion order, __prepare__ is rarely needed. You will see a creative use for it in “A Metaclass Hack with __pre‐ pare__” on page 950.\n\nImporting metalib.py in the Python console is not very exciting. Note the use of % to prefix the lines output by this module:\n\n>>> import metalib % metalib module start % MetaKlass body % metalib module end\n\nLots of things happen if you import evaldemo_meta.py, as you can see in Example 24-19.\n\n940\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1683,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 971,
      "content": "Example 24-19. Console experiment with evaldemo_meta.py\n\n>>> import evaldemo_meta @ builderlib module start @ Builder body @ Descriptor body @ builderlib module end % metalib module start % MetaKlass body % metalib module end # evaldemo_meta module start % MetaKlass.__prepare__(<class 'metalib.MetaKlass'>, 'Klass', (<class 'builderlib.Builder'>,)) % NosyDict.__setitem__(<NosyDict instance>, '__module__', 'evaldemo_meta') % NosyDict.__setitem__(<NosyDict instance>, '__qualname__', 'Klass') # Klass body @ Descriptor.__init__(<Descriptor instance>) % NosyDict.__setitem__(<NosyDict instance>, 'attr', <Descriptor instance>) % NosyDict.__setitem__(<NosyDict instance>, '__init__', <function Klass.__init__ at …>) % NosyDict.__setitem__(<NosyDict instance>, '__repr__', <function Klass.__repr__ at …>) % NosyDict.__setitem__(<NosyDict instance>, '__classcell__', <cell at …: empty>) % MetaKlass.__new__(<class 'metalib.MetaKlass'>, 'Klass', (<class 'builderlib.Builder'>,), <NosyDict instance>) @ Descriptor.__set_name__(<Descriptor instance>, <class 'Klass' built by MetaKlass>, 'attr') @ Builder.__init_subclass__(<class 'Klass' built by MetaKlass>) @ deco(<class 'Klass' built by MetaKlass>) # evaldemo_meta module end\n\nThe lines before this are the result of importing builderlib.py and metalib.py.\n\nPython invokes __prepare__ to start processing a class statement.\n\nBefore parsing the class body, Python adds the __module__ and __qualname__ entries to the namespace of the class under construction.\n\nThe descriptor instance is created…\n\n…and bound to attr in the class namespace.\n\n__init__ and __repr__ methods are defined and added to the namespace.\n\nOnce Python finishes processing the class body, it calls MetaKlass.__new__.\n\n__set_name__, __init_subclass__, and the decorator are invoked in this order, after the __new__ method of the metaclass returns the newly constructed class.\n\nMetaclasses 101\n\n|\n\n941",
      "content_length": 1916,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 972,
      "content": "If you run evaldemo_meta.py as script, main() is called, and a few more things happen (Example 24-20).\n\nExample 24-20. Running evaldemo_meta.py as a program\n\n$ ./evaldemo_meta.py [... 20 lines omitted ...] @ deco(<class 'Klass' built by MetaKlass>) @ Builder.__init__(<Klass instance>) # Klass.__init__(<Klass instance>) @ SuperA.__init_subclass__:inner_0(<Klass instance>) @ deco:inner_1(<Klass instance>) % MetaKlass.__new__:inner_2(<Klass instance>) @ Descriptor.__set__(<Descriptor instance>, <Klass instance>, 999) # evaldemo_meta module end\n\nThe top 21 lines—including this one—are the same shown in Example 24-19.\n\nTriggered by obj.method_c() in main; method_c was injected by Meta Klass.__new__.\n\nLet’s now go back to the idea of the Checked class with the Field descriptors imple‐ menting runtime type validation, and see how it can be done with a metaclass.\n\nA Metaclass Solution for Checked I don’t want to encourage premature optimization and overengineering, so here is a make-believe scenario to justify rewriting checkedlib.py with __slots__, which requires the application of a metaclass. Feel free to skip it.\n\nA Bit of Storytelling Our checkedlib.py using __init_subclass__ is a company-wide success, and our pro‐ duction servers have millions of instances of Checked subclasses in memory at any one time.\n\nProfiling a proof-of-concept, we discover that using __slots__ will reduce the cloud hosting bill for two reasons:\n\nLower memory usage, as Checked instances don’t need their own __dict__ • Higher performance, by removing __setattr__, which was created just to block unexpected attributes, but is triggered at instantiation and for all attribute setting before Field.__set__ is called to do its job\n\n942\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1765,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 973,
      "content": "The metaclass/checkedlib.py module we’ll study next is a drop-in replacement for init‐ sub/checkedlib.py. The doctests embedded in them are identical, as well as the check‐ edlib_test.py files for pytest.\n\nThe complexity in checkedlib.py is abstracted away from the user. Here is the source code of a script using the package:\n\nfrom checkedlib import Checked\n\nclass Movie(Checked): title: str year: int box_office: float\n\nif __name__ == '__main__': movie = Movie(title='The Godfather', year=1972, box_office=137) print(movie) print(movie.title)\n\nThat concise Movie class definition leverages three instances of the Field validating descriptor, a __slots__ configuration, five methods inherited from Checked, and a metaclass to put it all together. The only visible part of checkedlib is the Checked base class.\n\nConsider Figure 24-4. The Mills & Gizmos Notation complements the UML class diagram by making the relationship between classes and instances more visible.\n\nFor example, a Movie class using the new checkedlib.py is an instance of CheckedMeta, and a subclass of Checked. Also, the title, year, and box_office class attributes of Movie are three separate instances of Field. Each Movie instance has its own _title, _year, and _box_office attributes, to store the values of the corresponding fields.\n\nNow let’s study the code, starting with the Field class, shown in Example 24-21.\n\nThe Field descriptor class is now a bit different. In the previous examples, each Field descriptor instance stored its value in the managed instance using an attribute of the same name. For example, in the Movie class, the title descriptor stored the field value in a title attribute in the managed instance. This made it unnecessary for Field to provide a __get__ method.\n\nHowever, when a class like Movie uses __slots__, it cannot have class attributes and instance attributes with the same name. Each descriptor instance is a class attribute, and now we need separate per-instance storage attributes. The code uses the descrip‐ tor name prefixed with a single _. Therefore Field instances have separate name and storage_name attributes, and we implement Field.__get__.\n\nA Metaclass Solution for Checked\n\n|\n\n943",
      "content_length": 2204,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 974,
      "content": "Figure 24-4. UML class diagram annotated with MGN: the CheckedMeta meta-mill builds the Movie mill. The Field mill builds the title, year, and box_office descrip‐ tors, which are class attributes of Movie. The per-instance data for the fields is stored in the _title, _year, and _box_office instance attributes of Movie. Note the package boundary of checkedlib. The developer of Movie doesn’t need to grok all the machi‐ nery inside checkedlib.py.\n\nExample 24-21 shows the source code for Field, with callouts describing only the changes in this version.\n\nExample 24-21. metaclass/checkedlib.py: the Field descriptor with storage_name and __get__\n\nclass Field: def __init__(self, name: str, constructor: Callable) -> None: if not callable(constructor) or constructor is type(None): raise TypeError(f'{name!r} type hint must be callable') self.name = name self.storage_name = '_' + name self.constructor = constructor\n\ndef __get__(self, instance, owner=None): if instance is None: return self return getattr(instance, self.storage_name)\n\ndef __set__(self, instance: Any, value: Any) -> None: if value is ...: value = self.constructor() else:\n\n944\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1183,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 975,
      "content": "try: value = self.constructor(value) except (TypeError, ValueError) as e: type_name = self.constructor.__name__ msg = f'{value!r} is not compatible with {self.name}:{type_name}' raise TypeError(msg) from e setattr(instance, self.storage_name, value)\n\nCompute storage_name from the name argument.\n\nIf __get__ gets None as the instance argument, the descriptor is being read from the managed class itself, not a managed instance. So we return the descriptor.\n\nOtherwise, return the value stored in the attribute named storage_name.\n\n__set__ now uses setattr to set or update the managed attribute.\n\nExample 24-22 shows the code for the metaclass that drives this example.\n\nExample 24-22. metaclass/checkedlib.py: the CheckedMeta metaclass\n\nclass CheckedMeta(type):\n\ndef __new__(meta_cls, cls_name, bases, cls_dict): if '__slots__' not in cls_dict: slots = [] type_hints = cls_dict.get('__annotations__', {}) for name, constructor in type_hints.items(): field = Field(name, constructor) cls_dict[name] = field slots.append(field.storage_name)\n\ncls_dict['__slots__'] = slots\n\nreturn super().__new__( meta_cls, cls_name, bases, cls_dict)\n\n__new__ is the only method implemented in CheckedMeta.\n\nOnly enhance the class if its cls_dict doesn’t include __slots__. If __slots__ is already present, assume it is the Checked base class and not a user-defined sub‐ class, and build the class as is.\n\nTo get the type hints in prior examples, we used typing.get_type_hints, but that requires an existing class as the first argument. At this point, the class we are configuring does not exist yet, so we need to retrieve the __annotations__\n\nA Metaclass Solution for Checked\n\n|\n\n945",
      "content_length": 1667,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 976,
      "content": "directly from the cls_dict—the namespace of the class under construction, which Python passes as the last argument to the metaclass __new__.\n\nIterate over type_hints to…\n\n…build a Field for each annotated attribute…\n\n…overwrite the corresponding entry in cls_dict with the Field instance…\n\n…and append the storage_name of the field in the list we’ll use to…\n\n…populate the __slots__ entry in cls_dict—the namespace of the class under construction.\n\nFinally, we call super().__new__.\n\nThe last part of metaclass/checkedlib.py is the Checked base class that users of this library will subclass to enhance their classes, like Movie.\n\nThe code for this version of Checked is the same as Checked in initsub/checkedlib.py (listed in Example 24-5 and Example 24-6), with three changes:\n\n1. Added an empty __slots__ to signal to CheckedMeta.__new__ that this class doesn’t require special processing.\n\n2. Removed __init_subclass__. Its job is now done by CheckedMeta.__new__. 3. Removed __setattr__. It became redundant because adding __slots__ to the user-defined class prevents setting undeclared attributes.\n\nExample 24-23 is a complete listing of the final version of Checked.\n\nExample 24-23. metaclass/checkedlib.py: the Checked base class\n\nclass Checked(metaclass=CheckedMeta): __slots__ = () # skip CheckedMeta.__new__ processing\n\n@classmethod def _fields(cls) -> dict[str, type]: return get_type_hints(cls)\n\ndef __init__(self, **kwargs: Any) -> None: for name in self._fields(): value = kwargs.pop(name, ...) setattr(self, name, value) if kwargs: self.__flag_unknown_attrs(*kwargs)\n\n946\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1624,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 977,
      "content": "def __flag_unknown_attrs(self, *names: str) -> NoReturn: plural = 's' if len(names) > 1 else '' extra = ', '.join(f'{name!r}' for name in names) cls_name = repr(self.__class__.__name__) raise AttributeError(f'{cls_name} object has no attribute{plural} {extra}')\n\ndef _asdict(self) -> dict[str, Any]: return { name: getattr(self, name) for name, attr in self.__class__.__dict__.items() if isinstance(attr, Field) }\n\ndef __repr__(self) -> str: kwargs = ', '.join( f'{key}={value!r}' for key, value in self._asdict().items() ) return f'{self.__class__.__name__}({kwargs})'\n\nThis concludes the third rendering of a class builder with validated descriptors.\n\nThe next section covers some general issues related to metaclasses.\n\nMetaclasses in the Real World Metaclasses are powerful, but tricky. Before deciding to implement a metaclass, con‐ sider the following points.\n\nModern Features Simplify or Replace Metaclasses Over time, several common use cases of metaclasses were made redundant by new language features:\n\nClass decorators\n\nSimpler to understand than metaclasses, and less likely to cause conflicts with base classes and metaclasses.\n\n__set_name__\n\nAvoids the need for custom metaclass logic to automatically set the name of a descriptor.15\n\n15 In the first edition of Fluent Python, the more advanced versions of the LineItem class used a metaclass just to set the storage name of the attributes. See the code in the metaclasses of bulkfood in the first edition code repository.\n\nMetaclasses in the Real World\n\n|\n\n947",
      "content_length": 1525,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 978,
      "content": "__init_subclass__\n\nProvides a way to customize class creation that is transparent to the end user and even simpler than a decorator—but may introduce conflicts in a complex class hierarchy.\n\nBuilt-in dict preserving key insertion order\n\nEliminated the #1 reason to use __prepare__: to provide an OrderedDict to store the namespace of the class under construction. Python only calls __prepare__ on metaclasses, so if you needed to process the class namespace in the order it appears in the source code, you had to use a metaclass before Python 3.6.\n\nAs of 2021, every actively maintained version of CPython supports all the features just listed.\n\nI keep advocating these features because I see too much unnecessary complexity in our profession, and metaclasses are a gateway to complexity.\n\nMetaclasses Are Stable Language Features Metaclasses were introduced in Python 2.2 in 2002, together with so-called “new- style classes,” descriptors, and properties.\n\nIt is remarkable that the MetaBunch example, first posted by Alex Martelli in July 2002, still works in Python 3.9—the only change being the way to specify the meta‐ class to use, which in Python 3 is done with the syntax class Bunch(metaclass=Meta Bunch):.\n\nNone of the additions I mentioned in “Modern Features Simplify or Replace Meta‐ classes” on page 947 broke existing code using metaclasses. But legacy code using metaclasses can often be simplified by leveraging those features, especially if you can drop support to Python versions before 3.6—which are no longer maintained.\n\nA Class Can Only Have One Metaclass If your class declaration involves two or more metaclasses, you will see this puzzling error message:\n\nTypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases\n\nThis may happen even without multiple inheritance. For example, a declaration like this could trigger that TypeError:\n\nclass Record(abc.ABC, metaclass=PersistentMeta): pass\n\nWe saw that abc.ABC is an instance of the abc.ABCMeta metaclass. If that Persistent metaclass is not itself a subclass of abc.ABCMeta, you get a metaclass conflict.\n\n948\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 2196,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 979,
      "content": "There are two ways of dealing with that error:\n\nFind some other way of doing what you need to do, while avoiding at least one of the metaclasses involved.\n\nWrite your own PersistentABCMeta metaclass as a subclass of both abc.ABCMeta and PersistentMeta, using multiple inheritance, and use that as the only meta‐ class for Record.16\n\nI can imagine the solution of the metaclass with two base meta‐ classes implemented to meet a deadline. In my experience, meta‐ class programming always takes longer than anticipated, which makes this approach risky before a hard deadline. If you do it and make the deadline, the code may contain subtle bugs. Even in the absence of known bugs, you should consider this approach as tech‐ nical debt simply because it is hard to understand and maintain.\n\nMetaclasses Should Be Implementation Details Besides type, there are only six metaclasses in the entire Python 3.9 standard library. The better known metaclasses are probably abc.ABCMeta, typing.NamedTupleMeta, and enum.EnumMeta. None of them are intended to appear explicitly in user code. We may consider them implementation details.\n\nAlthough you can do some really wacky metaprogramming with metaclasses, it’s best to heed the principle of least astonishment so that most users can indeed regard met‐ aclasses as implementation details.17\n\nIn recent years, some metaclasses in the Python standard library were replaced by other mechanisms, without breaking the public API of their packages. The simplest way to future-proof such APIs is to offer a regular class that users subclass to access the functionality provided by the metaclass, as we’ve done in our examples.\n\nTo wrap up our coverage of class metaprogramming, I will share with you the cool‐ est, small example of metaclass I found as I researched this chapter.\n\n16 If you just got dizzy considering the implications of multiple inheritance with metaclasses, good for you. I’d\n\nstay way from this solution as well.\n\n17 I made a living writing Django code for a few years before I decided to study how Django’s model fields were\n\nimplemented. Only then I learned about descriptors and metaclasses.\n\nMetaclasses in the Real World\n\n|\n\n949",
      "content_length": 2185,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 980,
      "content": "A Metaclass Hack with __prepare__ When I updated this chapter for the second edition, I needed to find simple but illu‐ minating examples to replace the bulkfood LineItem code that no longer require met‐ aclasses since Python 3.6.\n\nThe simplest and most interesting metaclass idea was given to me by João S. O. Bueno—better known as JS in the Brazilian Python community. One application of his idea is to create a class that autogenerates numeric constants:\n\n>>> class Flavor(AutoConst): ... banana ... coconut ... vanilla ... >>> Flavor.vanilla 2 >>> Flavor.banana, Flavor.coconut (0, 1)\n\nYes, that code works as shown! That’s actually a doctest in autoconst_demo.py.\n\nHere is the user-friendly AutoConst base class and the metaclass behind it, imple‐ mented in autoconst.py:\n\nclass AutoConstMeta(type): def __prepare__(name, bases, **kwargs): return WilyDict()\n\nclass AutoConst(metaclass=AutoConstMeta): pass\n\nThat’s it.\n\nClearly the trick is in WilyDict.\n\nWhen Python processes the namespace of the user’s class and reads banana, it looks up that name in the mapping provided by __prepare__: an instance of WilyDict. WilyDict implements __missing__, covered in “The __missing__ Method” on page 91. The WilyDict instance initially has no 'banana' key, so the __missing__ method is triggered. It makes an item on the fly with the key 'banana' and the value 0, returning that value. Python is happy with that, then tries to retrieve 'coconut'. Wily Dict promptly adds that entry with the value 1, returning it. The same happens with 'vanilla', which is then mapped to 2.\n\n950\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 1613,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 981,
      "content": "We’ve seen __prepare__ and __missing__ before. The real innovation is how JS put them together.\n\nHere is the source code for WilyDict, also from autoconst.py:\n\nclass WilyDict(dict): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.__next_value = 0\n\ndef __missing__(self, key): if key.startswith('__') and key.endswith('__'): raise KeyError(key) self[key] = value = self.__next_value self.__next_value += 1 return value\n\nWhile experimenting, I found that Python looked up __name__ in the namespace of the class under construction, causing WilyDict to add a __name__ entry, and incre‐ ment __next_value. So I added that if statement in __missing__ to raise KeyError for keys that look like dunder attributes.\n\nThe autoconst.py package both requires and illustrates mastery of Python’s dynamic class building machinery.\n\nI had a great time adding more functionality to AutoConstMeta and AutoConst, but instead of sharing my experiments, I will let you have fun playing with JS’s ingenious hack.\n\nHere are some ideas:\n\nMake it possible to retrieve the constant name if you have the value. For example, Flavor[2] could return 'vanilla'. You can to this by implementing __geti tem__ in AutoConstMeta. Since Python 3.9, you can implement __class_geti tem__ in AutoConst itself.\n\nSupport iteration over the class, by implementing __iter__ on the metaclass. I would make the __iter__ yield the constants as (name, value) pairs.\n\nImplement a new Enum variant. This would be a major undertaking, because the enum package is full of tricks, including the EnumMeta metaclass with hundreds of lines of code and a nontrivial __prepare__ method.\n\nEnjoy!\n\nA Metaclass Hack with __prepare__\n\n|\n\n951",
      "content_length": 1707,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 982,
      "content": "The __class_getitem__ special method was added in Python 3.9 to support generic types, as part of PEP 585—Type Hinting Gener‐ ics In Standard Collections. Thanks to __class_getitem__, Python’s core developers did not have to write a new metaclass for the built-in types to implement __getitem__ so that we could write generic type hints like list[int]. This is a narrow feature, but rep‐ resentative of a wider use case for metaclasses: implementing oper‐ ators and other special methods to work at the class level, such as making the class itself iterable, just like Enum subclasses.\n\nWrapping Up Metaclasses, as well as class decorators and __init_subclass__ are useful for:\n\nSubclass registration\n\nSubclass structural validation\n\nApplying decorators to many methods at once\n\nObject serialization\n\nObject-relational mapping\n\nObject-based persistence\n\nImplementing special methods at the class level\n\nImplementing class features found in other languages, such as traits and aspect- oriented programming\n\nClass metaprogramming can also help with performance issues in some cases, by per‐ forming tasks at import time that otherwise would execute repeatedly at runtime.\n\nTo wrap up, let’s recall Alex Martelli’s final advice from his essay “Waterfowl and ABCs” on page 443:\n\nAnd, don’t define custom ABCs (or metaclasses) in production code… if you feel the urge to do so, I’d bet it’s likely to be a case of “all problems look like a nail”-syndrome for somebody who just got a shiny new hammer—you (and future maintainers of your code) will be much happier sticking with straightforward and simple code, eschewing such depths.\n\nI believe Martelli’s advice applies not only to ABCs and metaclasses, but also to class hierarchies, operator overloading, function decorators, descriptors, class decorators, and class builders using __init_subclass__.\n\nThose powerful tools exist primarily to support library and framework development. Applications naturally should use those tools, as provided by the Python standard\n\n952\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 2055,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 983,
      "content": "library or external packages. But implementing them in application code is often pre‐ mature abstraction.\n\nGood frameworks are extracted, not invented.18\n\n—David Heinemeier Hansson, creator of Ruby on Rails\n\nChapter Summary This chapter started with an overview of attributes found in class objects, such as __qualname__ and the __subclasses__() method. Next, we saw how the type built- in can be used to construct classes at runtime.\n\nThe __init_subclass__ special method was introduced, with the first iteration of a Checked base class designed to replace attribute type hints in user-defined subclasses with Field instances that apply constructors to enforce the type of those attributes at runtime.\n\nThe same idea was implemented with a @checked class decorator that adds features to user-defined classes, similar to what __init_subclass__ allows. We saw that neither __init_subclass__ nor a class decorator can dynamically configure __slots__, because they operate only after a class is created.\n\nThe concepts of “import time” and “runtime” were clarified with experiments show‐ ing the order in which Python code is executed when modules, descriptors, class dec‐ orators, and __init_subclass__ is involved.\n\nOur coverage of metaclasses began with an overall explanation of type as a metaclass, and how user-defined metaclasses can implement __new__ to customize the classes it builds. We then saw our first custom metaclass, the classic MetaBunch example using __slots__. Next, another evaluation time experiment demonstrated how the __pre pare__ and __new__ methods of a metaclass are invoked earlier than __init_sub class__ and class decorators, providing opportunities for deeper class customization.\n\nThe third iteration of a Checked class builder with Field descriptors and custom __slots__ configuration was presented, followed by some general considerations about metaclass usage in practice.\n\nFinally, we saw the AutoConst hack invented by João S. O. Bueno, based on the cun‐ ning idea of a metaclass with __prepare__ returning a mapping that implements __missing__. In less than 20 lines of code, autoconst.py showcases the power of com‐ bining Python metaprogramming techniques\n\n18 The phrase is widely quoted. I found an early direct quote in a post in DHH’s blog from 2005.\n\nChapter Summary\n\n|\n\n953",
      "content_length": 2316,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 984,
      "content": "I haven’t yet found a language that manages to be easy for beginners, practical for professionals, and exciting for hackers in the way that Python is. Thanks, Guido van Rossum and everybody else who makes it so.\n\nFurther Reading Caleb Hattingh—a technical reviewer of this book—wrote the autoslot package, pro‐ viding a metaclass to automatically create a __slots__ attribute in a user-defined class by inspecting the bytecode of __init__ and finding all assignments to attributes of self. It’s useful and also an excellent example to study: only 74 lines of code in autoslot.py, including 20 lines of comments explaining the most difficult parts.\n\nThe essential references for this chapter in the Python documentation are “3.3.3. Cus‐ tomizing class creation” in the “Data Model” chapter of The Python Language Refer‐ ence, which covers __init_subclass__ and metaclasses. The type class documentation in the “Built-in Functions” page, and “4.13. Special Attributes” of the “Built-in Types” chapter in the The Python Standard Library are also essential read‐ ing.\n\nIn the The Python Standard Library, the types module documentation covers two class metaprogramming: that functions added types.new_class and types.prepare_class.\n\nin Python 3.3\n\nsimplify\n\nClass decorators were formalized in PEP 3129—Class Decorators, written by Collin Winter, with the reference implementation authored by Jack Diederich. The PyCon 2009 talk “Class Decorators: Radically Simple” (video), also by Jack Diederich, is a quick introduction to the feature. Besides @dataclass, an interesting—and much simpler—example of a class decorator in Python’s standard library is func tools.total_ordering that generates special methods for object comparison.\n\nFor metaclasses, the main reference in Python’s documentation is PEP 3115—Meta‐ classes in Python 3000, in which the __prepare__ special method was introduced.\n\nPython in a Nutshell, 3rd ed., by Alex Martelli, Anna Ravenscroft, and Steve Holden, is authoritative, but was written before PEP 487—Simpler customization of class cre‐ ation came out. The main metaclass example in that book—MetaBunch—is still valid, because it can’t be written with simpler mechanisms. Brett Slatkin’s Effective Python, 2nd ed. (Addison-Wesley) has several up-to-date examples of class building techni‐ ques, including metaclasses.\n\n954\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 2383,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 985,
      "content": "To learn about the origins of class metaprogramming in Python, I recommend Guido van Rossum’s paper from 2003, “Unifying types and classes in Python 2.2”. The text applies to modern Python as well, as it covers what were then called the “new-style” class semantics—the default semantics in Python 3—including descriptors and meta‐ classes. One of the references cited by Guido is Putting Metaclasses to Work: a New Dimension in Object-Oriented Programming, by Ira R. Forman and Scott H. Danforth (Addison-Wesley), a book to which he gave five stars on Amazon.com, adding the following review:\n\nThis book contributed to the design for metaclasses in Python 2.2\n\nToo bad this is out of print; I keep referring to it as the best tutorial I know for the difficult subject of cooperative multiple inheritance, supported by Python via the super() function.19\n\nIf you are keen on metaprogramming, you may wish Python had the ultimate meta‐ programming feature: syntactic macros, as offered in the Lisp family of languages and —more recently—by Elixir and Rust. Syntactic macros are more powerful and less error prone than the primitive code substitution macros in the C language. They are special functions that rewrite source code using custom syntax into standard code before the compilation step, enabling developers to introduce new language con‐ structs without changing the compiler. Like operator overloading, syntactic macros can be abused. But as long as the community understands and manages the down‐ sides, they support powerful and user-friendly abstractions, like DSLs (Domain- Specific Languages). In September 2020, Python core developer Mark Shannon posted PEP 638—Syntactic Macros, advocating just that. A year after it was initially published, PEP 638 was still in draft and there were no ongoing discussions about it. Clearly it’s not a top priority for the Python core developers. I would like to see PEP 638 further discussed and eventually approved. Syntactic macros would allow the Python community to experiment with controversial new features, such as the walrus operator (PEP 572), pattern matching (PEP 634), and alternative rules for evaluating type hints (PEPs 563 and 649) before making permanent changes to the core lan‐ guage. Meanwhile, you can get a taste of syntactic macros with the MacroPy package.\n\n19 I bought a used copy and found it a very challenging read.\n\nFurther Reading\n\n|\n\n955",
      "content_length": 2417,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 986,
      "content": "Soapbox I will start the last soapbox in the book with a long quote from Brian Harvey and Matthew Wright, two computer science professors from the University of California (Berkeley and Santa Barbara). In their book, Simply Scheme: Introducing Computer Science (MIT Press), Harvey and Wright wrote:\n\nThere are two schools of thought about teaching computer science. We might carica‐ ture the two views this way:\n\n1. The conservative view: Computer programs have become too large and com‐ plex to encompass in a human mind. Therefore, the job of computer science education is to teach people how to discipline their work in such a way that 500 mediocre programmers can join together and produce a program that correctly meets its specification.\n\n2. The radical view: Computer programs have become too large and complex to encompass in a human mind. Therefore, the job of computer science education is to teach people how to expand their minds so that the programs can fit, by learning to think in a vocabulary of larger, more powerful, more flexible ideas than the obvious ones. Each unit of programming thought must have a big pay‐ off in the capabilities of the program. —Brian Harvey and Matthew Wright, preface to Simply Scheme20\n\nHarvey and Wright’s exaggerated descriptions are about teaching computer science, but they also apply to programming language design. By now, you should have guessed that I subscribe to the “radical” view, and I believe Python was designed in that spirit.\n\nThe property idea is a great step forward compared to the accessors-from-the-start approach practically demanded by Java and supported by Java IDEs generating get‐ ters/setters with a keyboard shortcut. The main advantage of properties is to let us start our programs simply exposing attributes as public—in the spirit of KISS—know‐ ing a public attribute can become a property at any time without much pain. But the descriptor idea goes way beyond that, providing a framework for abstracting away repetitive accessor logic. That framework is so effective that essential Python con‐ structs use it behind the scenes.\n\nAnother powerful idea is functions as first-class objects, paving the way to higher- order functions. Turns out the combination of descriptors and higher-order func‐ tions enable the unification of functions and methods. A function’s __get__ produces\n\n20 See p. xvii. Full text available at Berkeley.edu.\n\n956\n\n|\n\nChapter 24: Class Metaprogramming",
      "content_length": 2456,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 987,
      "content": "a method object on the fly by binding the instance to the self argument. This is elegant.21\n\nFinally, we have the idea of classes as first-class objects. It’s an outstanding feat of design that a beginner-friendly language provides powerful abstractions such as class builders, class decorators, and full-fledged, user-defined metaclasses. Best of all, the advanced features are integrated in a way that does not complicate Python’s suitabil‐ ity for casual programming (they actually help it, under the covers). The convenience and success of frameworks such as Django and SQLAlchemy owe much to meta‐ classes. Over the years, class metaprogramming in Python is becoming simpler and simpler, at least for common use cases. The best language features are those that ben‐ efit everyone, even if some Python users are not aware of them. But they can always learn and create the next great library.\n\nI look forward to learning about your contributions to the Python community and ecosystem!\n\n21 Machine Beauty: Elegance and the Heart of Technology by David Gelernter (Basic Books) opens with an intri‐ guing discussion of elegance and aesthetics in works of engineering, from bridges to software. The later chap‐ ters are not great, but the opening is worth the price.\n\nFurther Reading\n\n|\n\n957",
      "content_length": 1290,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 989,
      "content": "Afterword\n\nPython is a language for consenting adults.\n\n—Alan Runyan, cofounder of Plone\n\nAlan’s pithy definition expresses one of the best qualities of Python: it gets out of the way and lets you do what you must. This also means it doesn’t give you tools to restrict what others can do with your code and the objects it builds.\n\nAt age 30, Python is still growing in popularity. But of course, it is not perfect. Among the top irritants to me is the inconsistent use of CamelCase, snake_case, and joinedwords in the standard library. But the language definition and the standard library are only part of an ecosystem. The community of users and contributors is the best part of the Python ecosystem.\n\nHere is one example of the community at its best: while writing about asyncio in the first edition, I was frustrated because the API has many functions, dozens of which are coroutines, and you had to call the coroutines with yield from—now with await —but you can’t do that with regular functions. This was documented in the asyncio pages, but sometimes you had to read a few paragraphs to find out whether a particu‐ lar function was a coroutine. So I sent a message to python-tulip titled “Proposal: make coroutines stand out in the asyncio docs”. Victor Stinner, an asyncio core devel‐ oper; Andrew Svetlov, main author of aiohttp; Ben Darnell, lead developer of Tor‐ nado; and Glyph Lefkowitz, inventor of Twisted, joined the conversation. Darnell suggested a solution, Alexander Shorin explained how to implement it in Sphinx, and Stinner added the necessary configuration and markup. Less than 12 hours after I raised the issue, the entire asyncio documentation set online was updated with the coroutine tags you can see today.\n\nThat story did not happen in an exclusive club. Anybody can join the python-tulip list, and I had posted only a few times when I wrote the proposal. The story illustrates a community that is really open to new ideas and new members. Guido van Rossum used to hang out in python-tulip and often answered basic questions.\n\n959",
      "content_length": 2061,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 990,
      "content": "Another example of openness: the Python Software Foundation (PSF) has been working to increase diversity in the Python community. Some encouraging results are already in. The 2013–2014 PSF board saw the first women elected directors: Jes‐ sica McKellar and Lynn Root. In 2015, Diana Clarke chaired PyCon North America in Montréal, where about one-third of the speakers were women. PyLadies became a truly global movement, and I am proud that we have so many PyLadies chapters in Brazil.\n\nIf you are a Pythonista but you have not engaged with the community, I encourage you to do so. Seek the PyLadies or Python Users Group (PUG) in your area. If there isn’t one, create it. Python is everywhere, so you will not be alone. Travel to events if you can. Join live events too. During the Covid-19 pandemic I learned a lot in the “hallway tracks” of online conferences. Come to a PythonBrasil conference—we’ve had international speakers regularly for many years now. Hanging out with fellow Pythonistas brings real benefits besides all the knowledge sharing. Like real jobs and real friendships.\n\nI know I could not have written this book without the help of many friends I made over the years in the Python community.\n\nMy father, Jairo Ramalho, used to say “Só erra quem trabalha,” Portuguese for “Only those who work make mistakes,” great advice to avoid being paralyzed by the fear of making errors. I certainly made my share of mistakes while writing this book. The reviewers, editors, and early release readers caught many of them. Within hours of the first edition early release, a reader was reporting typos in the errata page for the book. Other readers contributed more reports, and friends contacted me directly to offer suggestions and corrections. The O’Reilly copyeditors will catch other errors during the production process, which will start as soon as I manage to stop writing. I take responsibility and apologize for any errors and suboptimal prose that remains.\n\nI am very happy to bring this second edition to conclusion, mistakes and all, and I am very grateful to everybody who helped along the way.\n\nI hope to see you soon at some live event. Please come say hi if you see me around!\n\nFurther Reading I will wrap up the book with references regarding what it its to be “Pythonic”—the main question this book tried to address.\n\nBrandon Rhodes is an awesome Python teacher, and his talk “A Python Æsthetic: Beauty and Why I Python” is beautiful, starting with the use of Unicode U+00C6 (LATIN CAPITAL LETTER AE) in the title. Another awesome teacher, Raymond Het‐ tinger, spoke of beauty in Python at PyCon US 2013: “Transforming Code into Beau‐ tiful, Idiomatic Python”.\n\n960\n\n| Afterword",
      "content_length": 2704,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 991,
      "content": "The “Evolution of Style Guides” thread that Ian Lee started on Python-ideas is worth reading. Lee is the maintainer of the pep8 package that checks Python source code for PEP 8 compliance. To check the code in this book, I used flake8, which wraps pep8, pyflakes, and Ned Batchelder’s McCabe complexity plug-in.\n\nBesides PEP 8, other influential style guides are the Google Python Style Guide and the Pocoo Styleguide, from the team that brought us Flake, Sphinx, Jinja 2, and other great Python libraries.\n\nThe Hitchhiker’s Guide to Python! is a collective work about writing Pythonic code. Its most prolific contributor is Kenneth Reitz, a community hero thanks to his beau‐ tifully Pythonic requests package. David Goodger presented a tutorial at PyCon US 2008 titled “Code Like a Pythonista: Idiomatic Python”. If printed, the tutorial notes are 30 pages long. Goodger created both reStructuredText and docutils—the foun‐ dations of Sphinx, Python’s excellent documentation system (which, by the way, is also the official documentation system for MongoDB and many other projects).\n\nMartijn Faassen tackles the question head-on in “What is Pythonic?” In the python- list, there is a thread with that same title. Martijn’s post is from 2005, and the thread from 2003, but the Pythonic ideal hasn’t changed much—neither has the language, for that matter. A great thread with “Pythonic” in the title is “Pythonic way to sum n- th list element?”, from which I quoted extensively in the “Soapbox” on page 427.\n\nPEP 3099 — Things that will Not Change in Python 3000 explains why many things are the way they are, even after the major overhaul that was Python 3. For a long time, Python 3 was nicknamed Python 3000, but it arrived a few centuries sooner—to the dismay of some. PEP 3099 was written by Georg Brandl, compiling many opin‐ ions expressed by the BDFL, Guido van Rossum. The “Python Essays” page lists sev‐ eral texts by Guido himself.\n\nAfterword\n\n|\n\n961",
      "content_length": 1961,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 993,
      "content": "Symbols != (not equal to) operator, 577 !r conversion field, 12 % (modulo) operator, 5, 12 %r placeholder, 12 * (star) operator, 10, 36-37, 50-56, 240, 572-574 ** (double star) operator, 80, 240 *= (star equals) operator, 53-56, 580-585 *_ symbol, 42 *_new*_, 843-845 + operator, 10, 50-56, 566-572 += (addition assignment) operator, 53-56,\n\n580-585\n\n+ELLIPSIS directive, 7 := (Walrus operator), 26 < (less than) operator, 577 <= (less than or equal to) operator, 577 == (equality) operator, 206, 225, 577 > (greater than) operator, 577 >= (greater than or equal to) operator, 577 @ sign, 574-576 @asyncio.coroutine decorator, 777 @cached_property, 856 @contextmanager decorator, 664-669 @dataclass\n\ndefault settings, 180 example using, 187-189 field options, 180-183 init-only variables, 186 keyword parameters accepted by, 179 post-init processing, 183-185 typed class attributes, 185 __hash__ method, 180\n\n@typing.overload decorator, 520-526\n\nIndex\n\n[] (square brackets), 6, 26, 35, 49 \\ (backslash), 26 \\ line continuation escape, 26 \\N{} (Unicode literals escape notation), 136 _ symbol, 41 __ (double underscore), 3 __abs__, 11 __add__, 11 __bool__, 13 __bytes__, 365 __call__, 360 __class__, 870, 908 __contains__, 7, 93 __delattr__, 872 __delete__, 879 __del__, 219 __dict__, 870 __dir__, 872 __enter__, 658 __eq__, 411-416 __exit__, 658 __format__, 365, 370, 418-425, 428 __getattribute__, 872 __getattr__, 407-411, 872 __getitem__, 5-8, 49, 403-407 __get__, 879 __hash__, 180, 411-416 __iadd__, 53 __init_subclass__, 914-921 __init__, 9, 183, 399 __invert__, 563 __iter__, 603-610 __len__, 5-8, 17, 403-407 __missing__, 91-95\n\n963",
      "content_length": 1640,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 994,
      "content": "__mro__, 908 __mul__, 11 __name__, 908 __neg__, 563 __post_init__, 183 __pos__, 563 __prepare__, 950-952 __repr__, 11-13, 364, 399 __setattr__, 872 __setitem__, 49 __set__, 879 __slots__, 384-388, 411, 870, 921 __str__, 13, 364 {} (curly brackets), 26 ǀ (pipe) operator, 80, 686 ǀ= (pipe equals) operator, 80 … (ellipsis), 7, 49\n\nA abc.ABC class, 449 abc.Iterable, 281 abc.Sequence, 281 ABCs (abstract base classes) ABC syntax details, 457 defining and using ABCs, 451-457 further reading on, 482 goose typing and, 442-445 overview of, 481 in Python standard library, 449-451 Soapbox discussion, 484-486 structural typing with, 464-466 subclassing ABCs, 447-449, 458-460 type hints (type annotations), 278-280 UML class diagrams, 14-15 usage of register, 463 virtual subclasses of ABCs, 460-463\n\nabs built-in function, 10 actual type parameters, 544 addition assignment (+=) operator, 53-56,\n\n580-585 aliasing, 204-208 anonymous functions, 236, 251, 311 Any type, 266-269 AnyStr, 286 .append method, 67 apply function, 234-236 arguments\n\nfreezing with functools.partial, 247 key argument, 74\n\n964\n\n|\n\nIndex\n\nkeyword-only arguments, 242\n\narrays, 23, 59-62 as keyword, 41 assignment expression (:=), 26 asynchronous generators, 238, 777 asynchronous programming\n\nasynchronous context managers, 786-787 asyncio script example, 778-781 avoiding CPU-bound traps, 826 awaitables, 781 benefits of, 825 Curio project, 821-824 delegating tasks to executors, 797-798 enhancing asyncio downloader, 787-797 further reading on, 828 iteration and iterables, 811-821 myth of I/O-bound systems, 826 overview of, 827 relevant terminology, 777 significant changes to, 776 Soapbox discussion, 829 topics covered, 775 type hinting asynchronous objects, 824 writing asyncio servers, 799-811 Asynchronous Server Gateway Interface\n\n(ASGI), 732 asyncio package\n\nachieving peak performance with, 785 documentation, 776 downloading with, 782-786 enhancing asyncio downloader, 787-797 example script, 778-781 queue implementation by, 69 writing asyncio servers, 799-811\n\nasyncpg, 786 attribute descriptors (see also attributes; dynamic attributes and properties) attribute validation, 880-891 descriptor docstring and overriding dele‐\n\ntion, 902\n\ndescriptor usage tips, 900-902 further reading on, 904 methods as descriptors, 898-900 overriding versus nonoverriding, 855,\n\n892-898 overview of, 903 purpose of, 879 relevant terminology, 881 significant changes to, 880",
      "content_length": 2440,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 995,
      "content": "Soapbox discussion, 905 topics covered, 879\n\nattributes (see also attribute descriptors; dynamic attributes and properties) dynamic attribute access, 407-411 handling attribute deletion, 868 overriding class attributes, 389-391 private and protected, 382-384 properties and up-front costs, 394 safety versus security in private, 395 using attribute descriptors for validation,\n\n880-891\n\nusing properties for attribute validation,\n\n857-860\n\nvirtual attributes, 835\n\naugmented assignment operators, 53-56,\n\n580-585\n\naverages, computing, 643-645 await keyword, 781\n\nB backslash (\\), 26 behavioral subtyping, 268 binary records, parsing with struct, 118 binary sequences, 120 (see also Unicode text\n\nversus bytes) bisect module, 58 blue tool, 259 BOMs (byte-order marks), 129 bool type, 13 Boolean values, custom types and, 13 built-in functions, 238 byte sequences, 128 (see also Unicode text ver‐\n\nsus bytes)\n\nbytecode, disassembling, 310\n\nC call by sharing, 213 callable objects\n\nnine types of, 237-239 user-defined, 239 using iter() with, 598-599\n\nCallable type, 291 card deck example, 5-8 Cartesian products, 27-29 case folding, 142 chain generator, 633 ChainMap, 95 characters\n\nfinding Unicode by name, 151-153 numeric meaning of, 153-155\n\nChardet library, 129 cladistics, 444 class metaprogramming\n\nbenefits and drawbacks of, 907 built-in class factory, 909 class factory function, 911-914 classes as objects, 908 enhancing classes with class decorators,\n\n922-925\n\nfurther reading on, 954 import time versus runtime, 925-931 __init_subclass__, 914-921 metaclass basics, 931-942 metaclass issues, 947-949 metaclass solution for checkedlib.py,\n\n942-947 overview of, 953 __prepare__ method, 950-952 significant changes to, 908 Soapbox discussion, 956 useful applications of metaclasses, 952\n\nclasses (see also protocols) as callable objects, 238 implementing generic classes, 541-544 topics covered, xxi undocumented classes, 557 classic refactoring strategy, 342-346 classmethod decorator, 369 client codes, 632 clock decorators\n\nclass-based, 335 parameterized, 332-334\n\nclosures (see decorators and closures) cls.mro(), 909 cls.__bases__, 908 cls.__qualname__, 909 cls.__subclasses__(), 909 code examples, obtaining and using, xxiv code points, 119, 161 code smells, 163, 190-192, 446 codecs, 123 Collection API, 14-15 collections.abc module\n\nabstract base classes defined in, 449 ChainMap, 95 Counter, 96 defaultdict and OrderedDict, 85, 95\n\nIndex\n\n|\n\n965",
      "content_length": 2458,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 996,
      "content": "Mapping and MutableMapping ABCs, 83 multiple inheritance in, 502 UserDict, 97\n\ncollections.deque class, 67-70 collections.namedtuple, 5, 169-172 Command pattern, 355-357 comments and questions, xxv comparison operators, 206, 577-580 computed properties\n\ncaching properties with functools, 855-857 data-driven attribute creation, 846-848 properties that compute values, 845 property caching, 853-855 property overriding existing attributes, 852 property to retrieve linked records, 848-852\n\nconcatenation, 50-56 concurrency models\n\nbasics of concurrency, 696 benefits of concurrency, 695 further reading on, 734-739 Global Interpreter Lock impact, 713-715 Hello World example, 701-712 indefinite loops and sentinels, 721 multicore processors and, 725-733 overview of, 733 process pools, 716-725 Python programming concepts, 699-701 relevant terminology, 697-699 significant changes to, 696 Soapbox discussion, 739-741 structured concurrency, 823 topics covered, 696\n\nconcurrent executors\n\nconcurrent web downloads, 744-754 downloads with progress display and error\n\nhandling, 762-772 Executor.map, 758-761 further reading on, 772 launching processes with concur‐\n\nrent.futures, 754-758\n\noverview of, 772 purpose of, 743 significant changes to, 743 Soapbox discussion, 773\n\nconcurrent.futures\n\ndownloading with, 749-750 launching processes with, 754-758\n\nconsistent-with relationships, 268 Container interface, 15\n\n966\n\n|\n\nIndex\n\ncontainer sequences, 22, 73 contention, 699 context managers\n\n@contextmanager decorator, 664-669 asynchronous, 786-787 asynchronous generators as, 817 contextlib utilities, 663 creative uses for, 658 demonstrations of, 659-662 methods included in interface, 658 parenthesized in Python 3.10, 663 purpose of, 658\n\ncontravariance (see variance) control flow, xxi (see also asynchronous pro‐ gramming; concurrent executors; concur‐ rency models; iterators; generators; with, match, and else blocks)\n\ncooperative multiple inheritance, 497 copies\n\ndeep, 211-213 shallow, 208-211 coroutine objects, 642 coroutines\n\ncomputing running averages, 643-645 definition of term, 698 further reading on, 652 generator-based, 777 generic type hints for, 650 Global Interpreter Lock impact, 715 overview of, 652 returning values from, 646-650 significant changes to, 594 Soapbox discussion, 654 spinners (loading indicators) using, 706-710 topics covered, 594 types of, 777 understanding classic, 641\n\nCounter, 96 covariance (see variance) CPU-bound systems, 826 Curio project, 821-824 curly brackets ({}), 26\n\nD Dask, 727 data attributes (see attributes) data class builders\n\n@dataclass, 179-189 classic named tuples, 169-172",
      "content_length": 2637,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 997,
      "content": "data class as code smell, 190-192 further reading on, 196 main features, 167-169 overview of, 164-167, 195 pattern matching class instances, 192-195 significant changes to, 164 Soapbox discussion, 197 topics covered, 163 type hints, 173-179 typed named tuples, 172\n\ndata descriptors (see overriding descriptors) data model (see Python Data Model) data science, 727 data structures, xxi (see also data class builders; dictionaries and sets; object references; sequences; Unicode text versus bytes)\n\ndata wrangling\n\nwith dynamic attributes, 836-838 flexible object creation, 843-845 invalid attribute name problem, 842 JSON-like data, 838-842 decimal.Decimal class, 565 decoding (see also Unicode text versus bytes)\n\nbasics of, 123-124 definition of, 119 understanding encode/decode problems,\n\n125-131\n\ndecorator-enhanced strategy pattern, 353-355 decorators and closures\n\nclassmethod versus staticmethod, 369 closure basics, 311-314 closures in lis.py, 685 decorator basics, 304-306 decorator execution, 306 decorator implementation, 317-320 decorators in Python standard library,\n\n320-323\n\nenhancing classes with class decorators,\n\n922-925\n\nfurther reading on, 336 nonlocal declarations, 315-317 overview of, 336 parameterized decorators, 329-335 purpose of, 303 registration decorators, 308 significant changes to, 304 Soapbox discussion, 338-340 topics covered, 303 variable scope rules, 308-310\n\ndeep copies, 211-213 defaultdict, 85, 90 defensive programming, 87, 440-442 del statement, 219-221, 868 delegating generators, 632 deprecated collection types, 272 deque (double-ended queue), 59, 67-70 descriptor classes, 881 descriptor instances, 881 descriptors, 177, 879 (see also attribute descrip‐\n\ntors)\n\ndesign patterns (see functions, design patterns\n\nwith first-class)\n\ndestructuring, 40 diacritics, normalization and, 144-148 dictcomps (dict comprehensions), 79 dictionaries and sets\n\nautomatic handling of missing keys, 90-95 consequences of how dict works, 102 consequences of how set works, 107 dictionary views, 101-102 further reading on, 113 immutable mappings, 99 internals of, 78 modern dict syntax, 78-81 overview of, 112 pattern matching with mappings, 81-83 set operations, 107-110 set operations on dict views, 110 set theory, 103-106 significant changes to, 78 Soapbox discussion, 114 standard API of mapping types, 83-90 topics covered, 77 variations of dict, 95-99 dir([object]) function, 870 dis module, 310 displays, formatting, 370-374 distributed task queues, 732 Django generic views mixins, 504-507 doctest package\n\ndocumentation, xxii ellipsis in, 7\n\ndouble star (**) operator, 80, 240 double underscore (__), 3 double() function, 466-468 Dublin Core Schema, 187 duck typing, 87, 261, 302, 402, 427, 431, 470 dunder methods, 4\n\nIndex\n\n|\n\n967",
      "content_length": 2772,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 998,
      "content": "dynamic attributes and properties\n\ncoding property factories, 865-868 computed properties, 845-857 data wrangling with dynamic attributes,\n\n836-845\n\ndynamic versus virtual attributes, 835 essential attributes and functions for attribute handling, 869-873\n\nfurther reading on, 873 handling attribute deletion, 868 overview of, 873 property class, 860-865 significant changes to, 836 Soapbox discussion, 875-877 using properties for attribute validation,\n\n857-860\n\ndynamic protocols, 403, 435 dynamic type, 266-269\n\nE ellipsis (…), 7, 49 else blocks, 687-689 emojis\n\nbuilding, 118 console font and, 136 finding characters by name, 151-153 in the Museum of Modern Art, 160 increasing issues with, 162 UCS-2 versus UTF-16 encoding, 124 varied support for, 152\n\nencoding (see also Unicode text versus bytes)\n\nbasics of, 123-124 definition of, 119 encoding defaults, 134-139 understanding encode/decode problems,\n\n125-131\n\nequality (==) operator, 206, 225, 577 error handling, in network I/O, 762-772 execution units, 697 Executor.map, 758-761 executors, delegating tasks to, 797-798 (see also\n\nconcurrent executors) explicit self argument, 905\n\nF f-string syntax\n\nbenefits of, 5 delegation of formatting by, 370\n\n968\n\n|\n\nIndex\n\nstring representation using special methods,\n\n12\n\nfail-fast philosophy, 87, 417, 440-442 FastAPI framework, 800-804 FIFO (first in, first out), 59, 67 filter function, 27, 234-236 filtering generator functions, 619 first-class functions (see functions, as first-class\n\nobjects)\n\nfirst-class objects, 231 flake8 tool, 259 flat sequences, 22, 73 flawed typing, 296 fluentpython.com, xxiii ForkingMixIn, 503 formal type parameters, 544 format() function, 370 forward reference problem, 538 free variables, 313, 685 frozenset, 103 (see also dictionaries and sets) function decorators (see decorators and clo‐\n\nsures)\n\nfunction parameters, introspection of, 232 function-class duality, 876 function-oriented refactoring strategy, 347-350 functional programming packages for, 243-249 with Python, 250\n\nfunctions\n\nabs built-in function, 10 dir([object]) function, 870 disassembling bytecode of, 310 double() function, 466 filter, map, and reduce functions, 27, 234 format() function, 370 getattr function, 871 getattr(object, name[, default]) function,\n\n871\n\nglobals() function, 351 hasattr function, 871 higher-order functions, 234-236 id() function, 206 iter() function, 596 len() function, 6 map function, 27 max() function, 521 repr() function, 364 setattr funcion, 871",
      "content_length": 2489,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 999,
      "content": "setattr(object, name, value) function, 871,\n\n871\n\nsingle dispatch generic functions, 324-329 str() function, 13, 364 super() function, 411, 488 zip() function, 416\n\nfunctions, as first-class objects (see also decora‐\n\ntors and closures) anonymous functions, 236 callable objects, 237-239 definition of term, 231 flexible parameter handling and, 240-243 further reading on, 250 higher-order functions, 234-236 overview of, 249 packages for functional programming,\n\n243-249\n\nsignificant changes to, 232 Soapbox discussion, 250 topics covered, xxi treating functions like objects, 232-234 user-defined callable types, 239\n\nfunctions, design patterns with first-class\n\nCommand pattern, 355-357 decorator-enhanced strategy pattern,\n\n353-355\n\ndynamic languages and, 341 further reading on, 358 overview of, 357 refactoring strategies, 342-353 significant changes to, 342 Soapbox discussion, 359\n\nfunctions, type hints in\n\nannotating positional only and variadic\n\nparameters, 295\n\nbenefits and drawbacks of, 253 flawed typing and strong testing, 296 further reading on, 298 gradual typing, 254-260 overview of, 297 significant changes to, 254 Soapbox discussion, 299-302 supported operations and, 261-265 topics covered, 254 types usable in annotations, 266-295\n\nfunctools module\n\ncaching properties with, 855-857 freezing arguments with, 247-249 functools.cache decorator, 320-323\n\nfunctools.lru_cache function, 323 functools.singledispatch decorator, 326-329\n\nfutures\n\nbasics of, 751-754 definition of term, 743 futures.as_completed, 769-772\n\nG garbage collection, 219-221, 226 generator expressions (genexps), 26, 29, 235,\n\n613, 818-821\n\ngenerators\n\narithmetic progression generators, 615-619 asynchronous generator functions, 812-818 examples of, 607-610 further reading on, 652 generator functions in Python standard\n\nlibrary, 238, 619-630\n\ngenerator-based coroutines, 777 generic iterable types, 639 humble generators, 784 iterable reducing functions, 630-631 versus iterators, 614 lazy generators, 610-613 overview of, 652 Sentence classes with, 606 significant changes to, 594 Soapbox discussion, 654 subgenerators with yield from expression,\n\n632-639\n\ntopics covered, 594 when to use generator expressions, 613 yield keyword, 607\n\ngeneric classes, implementing, 541-544 generic collections\n\nparameterized generics and TypeVar,\n\n282-286\n\nSoapbox discussion, 302 type annotations and, 271-272\n\ngeneric functions, single dispatch, 324-329 generic mapping types, 276 generic static protocols, 552-554 getattr function, 871 getattr(object, name[, default]) function, 871 gevent library, 711 Global Interpreter Lock (GIL), 66, 699,\n\n713-715, 725, 736 globals() function, 351 goose typing\n\nIndex\n\n|\n\n969",
      "content_length": 2698,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 1000,
      "content": "ABC syntax details, 457 ABCs in Python standard library, 449-451 abstract base classes (ABCs), 442-445 defining and using ABCs, 451-457 definition of term, 431 overview of, 446 structural typing with ABCs, 464-466 subclassing ABCs, 447-449, 458-460 usage of register, 463 virtual subclasses of ABCs, 460-463\n\ngradual type system (see also type hints (type\n\nannotations)) abstract base classes, 278-280 Any type, 266-267 basics of, 254 Callable type, 291 further reading on, 555 generic collections, 271-272 generic mappings, 276 implementing generic classes, 541-544 implementing generic static protocols,\n\n552-554\n\nin practice, 255-260 Iterable, 280-282 legacy support and deprecated collection\n\ntypes, 272\n\nNoReturn type, 294 Optional and Union types, 270 overloaded signatures, 520-526 overview of, 554 parameterized generics and TypeVar,\n\n282-286\n\nreading hints at runtime, 537-541 significant changes to, 519 simple types and classes, 269 Soapbox discussion, 557 static protocols, 286-291 subtype-of versus consistent-with relation‐\n\nships, 267-269 topics covered, 519 tuple types, 274-276 type casting, 534-537 TypedDict, 526 variance and, 544-551 greater than (>) operator, 577 greater than or equal to (>=) operator, 577 greenlet package, 710\n\n970\n\n|\n\nIndex\n\nH hasattr function, 871 hash code, versus hash value, 84 hash tables, 77 hashable, definition of, 84 heapq package, 69 higher-order functions, 234-236 HTTPServer class, 503 HTTPX library, 782-786 humble generators, 784\n\nI I/O (input/output) (see network I/O) id() function, 206 immutable mappings, 99 immutable sequences, 24 implicit conversion, 117 import time versus runtime, 306, 925 indefinite loops, 721 infix operators, 561, 574-576 inheritance and subclassing best practices, 510-514 further reading on, 515 mixin classes, 500-502 multiple inheritance and method resolution\n\norder, 494-499\n\noverview of, 514 real-world examples of, 502-509 significant changes to, 488 Soapbox discussion, 517-518 subclassing ABCs, 447-449, 458-460 subclassing built-in types, 490-494 super() function, 488-490 topics covered, 487 virtual subclasses of ABCs, 460-463 input expanding generator functions, 625 interfaces (see also goose typing; protocols)\n\nContainer interface, 15 further reading on, 482 Iterable interface, 15, 280, 435 overview of, 481 protocols as informal, 427 role in object-oriented programming, 431 significant changes to, 433 Sized interface, 15 Soapbox discussion, 484-486 topics covered, 433 typing map, 432 ways of defining and using, 431",
      "content_length": 2520,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 1001,
      "content": "interning, 222 invalid attribute name problem, 842 inverted indexes, 799 is operator, 206, 221 .items method, 110 iter() function, 596-599 Iterable interface, 15, 280-282, 435-437 iterables\n\nasynchronous, 811-821 iterable reducing functions, 630-631 versus iterators, 599-603 unpacking, 35-38\n\niterators\n\nasynchronous, 811-821 further reading on, 652 versus generators, 614 generic iterable types, 639 iter() function, 596-599 versus iterables, 599-603 lazy sentences, 610-613 overview of, 652 role of, 593 Sentence classes with __iter__, 603-610 sequence protocol, 594-596 significant changes to, 594 Soapbox discussion, 654 topics covered, 594\n\nitertools module, 618\n\nJ JSON-like data, 838-842\n\nK key argument, 74 keys\n\nautomatic handling of missing, 90-95 converting nonstring keys to str, 98 hashability, 84 persistent storage for mapping, 97 practical consequences of using dict, 102 preserving key insertion order, 15, 948 sorting multiple, 244\n\n.keys method, 110 keyword class patterns, 193 keyword-only arguments, 242 keywords\n\nas keyword, 41 await keyword, 781 lambda keyword, 236\n\nnonlocal keyword, 315-317, 683 reserved keywords, 679 yield keyword, 238, 605-610, 614, 642, 645,\n\n669\n\nKISS principle, 427, 517, 739\n\nL lambda keyword, 236 lazy sentences, 610-613 Least Recently Used (LRU), 323 len() function, 6 less than (<) operator, 577 less than or equal to (<=) operator, 577 line breaks, 26 lis.py interpreter\n\nEnvironment class, 673 evaluate function, 676-685 imports and types, 671 OR-patterns, 686 parser, 671-673 pattern matching in, 43-47 Procedure class, 685-686 REPL (read-eval-print-loop), 675 Scheme syntax, 669-671 topics covered, 669\n\nlist comprehensions (listcomps) asynchronous, 818-821 building lists from cartesian products, 27 building sequences with, 25 versus generator expressions, 29 local scope within, 26 readability and, 25 syntax tip, 26 versus map and filter functions, 27, 235\n\nlists\n\nalternatives to, 59-70 building lists of lists, 51 list.sort versus sorted built-in, 56-58 mixed-bag, 74 multiline, 26 shallow copies of, 208-211 versus tuples, 34 using tuples as immutable, 32-34\n\nlocks, definition of term, 699 LRU (see Least Recently Used)\n\nM magic methods, 4, 19 managed attributes, 882\n\nIndex\n\n|\n\n971",
      "content_length": 2247,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 1002,
      "content": "managed classes, 881 managed instances, 882 map function, 27, 234-236 mappings\n\nautomatic handling of missing keys, 90-95 case-insensitive, 500-502 immutable mappings, 99 mapping generator functions, 620 merging, 80 pattern matching with, 81-83 standard API of mapping types, 83-90 unpacking, 80\n\nmatch blocks (see with, match, and else blocks) match/case statement, 38, 81 mathematical vector operations, 566 max() function, 521-526 memoization, 320-323 memory, saving with __slots__, 384-388 memoryview class, 62-64 metaclasses\n\nbasics of, 931-933 considerations for use, 947-949 customizing classes, 933 definition of term, 910 example metaclass, 934-937 metaclass evaluation time experiment,\n\n937-942\n\nmetaclass solution for checkedlib.py,\n\n942-947\n\nuseful applications of, 952\n\nmetaobjects, 19 metaprogramming, xxii (see also attribute descriptors; class metaprogramming; dynamic attributes and properties) method resolution order (MRO), 494-499 methods, as callable objects, 238 (see also sequences, special methods for; special methods)\n\nMeyer's Uniform Access Principle, 875-876 Mills & Gizmos Notation (MGN), 883 mixin classes, 500-502 mixin methods, 502 modulo (%) operator, 5, 12 monkey-patching, 438-440, 486, 897 MRO (see method resolution order) multicore processing data science, 727 distributed task queues, 732 increased availability of, 725\n\n972\n\n|\n\nIndex\n\nserver-side web/mobile development, 728 system administration, 726 WSGI application servers, 730\n\nmultiline lists, 26 multiple inheritance (see also inheritance and\n\nsubclassing) method resolution order and, 494-499 real-world examples of, 502-509\n\nmultiplication, scalar, 10, 572-574 multiprocessing package, 69, 704 mutable objects, 225 (see also object references) mutable parameters, 214-218 mutable sequences, 24 mutable values, inserting or updating, 87-90 MutableMapping ABC, 83 Mypy type checker, 255-260 my_fmt.format() method, 5\n\nN name mangling, 382 namedtuple, 169-172 native coroutines\n\nversus asynchronous generators, 818 definition of term, 777 functions defined with async def, 238 humble generators and, 784\n\nnetwork I/O\n\ndownloading with asyncio, 782-786 downloading with concurrent.futures,\n\n749-750\n\ndownloads with progress display and error\n\nhandling, 762-772\n\nenhancing asyncio downloader, 787-797 essential role of concurrency in, 744-746 myth of I/O-bound systems, 826 role of futures, 751-754 sequential download script, 746-749\n\nNFC (see Normalization Form C) nominal typing, 262 nonlocal keyword, 315-317, 683 nonoverriding descriptors, 855, 892-898 NoReturn type, 294 Normalization Form C (NFC), 140 normalized text matching, 143-148 not equal to (!=) operator, 577 numbers ABCs, 478-481 numbers package, 279 numeric protocols, 478-481 numeric tower, 279",
      "content_length": 2757,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 1003,
      "content": "numeric types\n\nchecking for convertibility, 468, 480 emulating using special methods, 9-12 hashability of, 84 support for, 479\n\nNumPy, 64-67\n\nO object references\n\naliasing, 204-208 deep copies, 211-213 del and garbage collection, 219-221 distinction between objects and their\n\nnames, 201\n\nfunction parameters as references, 213-218 further reading on, 224 immutability and, 221 overview of, 223 shallow copies, 208-211 Soapbox discussion, 225 variables as labels versus boxes, 202-204\n\nobjects\n\ncallable objects, 237-239, 598-599 first-class, 231 flexible object creation, 843-845 mutable, 225 treating functions like, 232-234 user-defined callable objects, 239\n\noperator module, 243-247 operator overloading\n\naugmented assignment operators, 580-585 basics of, 562 further reading on, 587 infix operator method names, 576 infix operators, 561 overloading * for scalar multiplication,\n\n572-574\n\noverloading + for vector addition, 566-572 overview of, 585 rich comparison operators, 577-580 significant changes to, 562 Soapbox discussion, 588 topics covered, 562 unary operators, 563-566 using @ as infix operator, 574-576\n\nOptional type, 270 OR-patterns, 686 OrderedDict, 85, 95 os functions, str versus bytes in, 156\n\noverloaded signatures, 520-526 overriding descriptors, 855, 863, 892-898\n\nP parallelism, 695, 697 parameterized decorators, 329-335 parameterized types, 544 parameters\n\nannotating positional only and variadic\n\nparameters, 295\n\nintrospection of function parameters, 232 keyword-only, 242 mutable, 214-218 parameter passing, 213 positional, 240-243\n\npattern matching *_ symbol, 42 destructuring, 40 in lis.py interpreter, 43-47, 669-687 with mappings, 81-83 match/case statement, 38 pattern matching class instances, 192-195 tuples and lists, 41 type information, 42 _ symbol, 41\n\npatterns (see functions, design patterns with\n\nfirst-class; pattern matching)\n\npickle module, 97 Pingo library, 99 pipe (ǀ) operator, 80, 686 pipe equals (ǀ=) operator, 80 plain text, 129, 161 .pop method, 67 positional class patterns, 194 positional parameters, 240-243 positional patterns, 377 process pools\n\ncode for multicore prime checker, 719-723 example problem, 716 process-based solution, 718 thread-based nonsolution, 724 understanding elapsed times, 718 varying process numbers, 723\n\nprocesses\n\ndefinition of term, 698 launching with concurrent.futures, 754-758\n\nprogress displays, 762-772 Project Jupyter, 727 proper tail calls (PTC), 691-693\n\nIndex\n\n|\n\n973",
      "content_length": 2466,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 1004,
      "content": "properties (see computed properties; dynamic\n\nattributes and properties)\n\nproperty class, 860-865 protocol classes, 403 Protocol type, 286-291 protocols (see also interfaces)\n\ndefensive programming, 440-442 duck typing and, 402 further reading on, 482 implementing at runtime, 438-440 implementing generic static protocols,\n\n552-554\n\nas informal interfaces, 427 meanings of protocol, 434 numeric, 478-481 overview of, 481 sequence and iterable protocols, 435-437 significant changes to, 433 Soapbox discussion, 484-486 static protocols, 403, 466-481 topics covered, 433\n\nPSF (see Python Software Foundation) PUG (see Python Users Group) PyICU, 150 PyLadies, 960 pytest package, xxii Python\n\nappreciating language-specific features, xix approach to learning, xx-xxii community support for, 959 fluentpython.com, xxiii functional programming with, 250 functioning with multicore processors,\n\n725-733\n\nfurther reading on, 960 prerequisites to learning, xx target audience, xx versions featured, xx\n\nPython Data Model\n\nfurther reading on, 18 __getitem__ and __len__, 5-8 making len work with custom objects, 17 overview of, 3, 18 significant changes to, 4 Soapbox discussion, 19 special methods overview, 15-17 using special methods, 8-15\n\nPython Software Foundation (PSF), 960 Python type checkers, 255\n\n974\n\n|\n\nIndex\n\nPython Users Group (PUG), 960 python-tulip list, 959 Pythonic Card Deck example, 5-8 Pythonic objects (see also objects) alternative constructor for, 368 building user-defined classes, 363 classmethod versus staticmethod, 369 formatted displays, 370-374 further reading on, 392 hashable Vector2d, 374-377 object representations, 364 overriding class attributes, 389-391 overview of, 391 private and protected attributes, 382-384 saving memory with __slots__, 384-388 significant changes to, 364 Soapbox discussion, 394-396 supporting positional patterns, 377 topics covered, 363 Vector2d class example, 365-368 Vector2d full listing, 378-381\n\nPythonic sums, 428-430 pyuca library, 150, 158\n\nQ quantity properties, 865-868 questions and comments, xxv queues\n\ndefinition of term, 698 deque (double-ended queue), 59, 67 distributed task queues, 732 implementing, 69\n\nR race conditions, 723 random.choice function, 6 recycling (see garbage collection) reduce function, 234-236 reducing functions, 412, 630-631 refactoring strategies\n\nchoosing the best, 350 classic, 342-346 Command pattern, 355-357 decorator-enhanced pattern, 353-355 finding strategies in modules, 351-353 function-oriented, 347-350\n\nreference counting, 219 registration decorators, 308, 329-332 regular expressions, str versus bytes in, 155",
      "content_length": 2621,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 1005,
      "content": "repr() function, 364 reserved keywords, 679 rich comparison operators, 577-580 running averages, computing, 643-645\n\nS S-expression, 669 salts, 85 Scheme language, 43-47, 669-671 SciPy, 64-67 scope\n\ndynamic scope versus lexical scope, 338-339 function local scope, 310 module global scope, 310 variable scope rules, 308-310 within comprehensions and generator\n\nexpressions, 26 semaphores, 790-794 Sentence classes, 603-610 sentinels, 721 sequence protocol, 435-437, 594-596 sequences\n\nalternatives to lists, 59-70 further reading on, 71 list comprehensions and generator expres‐\n\nsions, 25-30\n\nlist.sort versus sorted built-in, 56-58 overview of, 70 overview of built-in, 22-24 pattern matching with, 38-47 significant changes to, 22 slicing, 47-50 Soapbox discussion, 73-75 topics covered, 22 tuples, 30-35 uniform handling of, 21 unpacking sequences and iterables, 35-38 using + and * with, 50-56 sequences, special methods for\n\napplications beyond three dimensions, 398 dynamic attribute access, 407-411 __format__, 418-425 further reading on, 426 __hash__ and __eq__, 411-416 overview of, 425 protocols and duck typing, 402 significant changes to, 398 sliceable sequences, 403-407 Soapbox discussion, 427-430\n\ntopics covered, 397 Vector implementation strategy, 398 Vector2d compatibility, 399-401\n\nsequential.py program, 716 server-side web/mobile development, 728 servers\n\nAsynchronous Server Gateway Interface\n\n(ASGI), 732\n\nHTTPServer class, 503 TCP servers, 804-811 test servers, 765 ThreadingHTTPServer class, 503 Web Server Gateway Interface (WSGI), 730 writing asyncio servers, 799-811\n\nsetattr function, 871 sets (see also dictionaries and sets)\n\nconsequences of how set works, 107 set comprehensions, 106 set literals, 105 set operations, 107-110 set operations on dict views, 110 set theory, 103-105 shallow copies, 208-211 shelve module, 97 simple class patterns, 192 single dispatch generic functions, 324-329 Sized interface, 15 slicing\n\nassigning to slices, 50 excluding last item in, 47 multidimensional slicing and ellipses, 49 slice objects, 48 sliceable sequences, 403-407\n\nSoapbox sidebars\n\n@dataclass, 197 anonymous functions, 251 __call__, 360 code points, 161 data model versus object model, 19 design patterns, 359 duck typing, 302, 427 dynamic scope versus lexical scope, 338-339 equality (==) operator, 225 explicit self argument, 905 flat versus container sequences, 73 __format__, 428 function-class duality, 876 functional programming with Python, 250 generic collections, 302\n\nIndex\n\n|\n\n975",
      "content_length": 2523,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 1006,
      "content": "inheritance across languages, 518 interfaces, 486 key argument, 74 lis.py and evaluate function, 693 magic methods, 19 metaobjects, 19 minimalistic iterator interface, 654 mixed-bag lists, 74 monkey-patching, 486 multilevel class hierarchies, 517 mutability, 225 non-ASCII names in source code, 160 object destruction and garbage collection,\n\n226\n\noperator overloading, 588 Oracle, Google, and the Timbot, 74 plain text, 161 pluggable generators, 654-656 programming language design, 956 proper tail calls (PTC), 691-693 properties and up-front costs, 394 protocols as informal interfaces, 427 Python decorators and decorator design\n\npattern, 339\n\nPythonic sums, 428-430 safety versus security in private attributes,\n\n395\n\nstatic typing, 484 syntactic sugar, 114 thread avoidance, 773 threads-and-locks versus actor-style pro‐\n\ngramming, 739-741 trade-offs of built-ins, 517 tuples, 73 Twisted library, 830 type hints (type annotations), 299-302 typing map, 485 undocumented classes, 557 Uniform Access Principle, 875-876 uvloop, 829 variance notation in other classes, 558 with statements, 691\n\nsorted function, 56-58 special methods (see also sequences, special\n\nmethods for) advantages of using, 6 Boolean values of custom types, 13 calling, 8 Collection API, 14-15\n\n976\n\n|\n\nIndex\n\nemulating numeric types, 9-12 __getitem__ and __len__, 5-8 naming conventions, 3 purpose of, 3 special method names (operators excluded),\n\n15\n\nspecial method names and symbols for\n\noperators, 16\n\nstring representation, 12\n\nspinners (loading indicators) (see also network\n\nI/O) comparing supervisor functions, 711 created using coroutines, 706-710 created with multiprocessing package, 704 created with threading, 701-704 Global Interpreter Lock impact, 713-715 keeping alive, 715\n\nsquare brackets ([]), 6, 26, 35, 49 stacked decorators, 322 star (*) operator, 10, 36-37, 50-56, 240, 572-574 star equals (*=) operator, 580-585 static duck typing, 291, 432, 515 static protocols\n\nbest practices for protocol design, 476 definition of, 435 designing, 474-476 versus dynamic protocols, 403 extending, 477 implementing generic static protocols,\n\n552-554\n\nlimitations of runtime protocol checks, 471 numbers ABCS and numeric protocols,\n\n478-481\n\nruntime checkable, 468-471 Soapbox discussion, 484 supporting, 472-474 type hints (type annotations), 286-291 typed double function, 466-468\n\nstatic typing, 431 staticmethod decorator, 369 storage attributes, 882 str() function, 13, 364 str.format() method, 5, 370 Strategy pattern, 342-346 strings\n\ndefault sorting of, 58 dual-mode str and bytes APIs, 155-157 normalizing Unicode for reliable compari‐\n\nsons, 140-148",
      "content_length": 2642,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 1007,
      "content": "representation using special methods, 12\n\nstrong testing, 296 struct module, 118 structural typing, 464-466 structured concurrency, 823 subclassing (see inheritance and subclassing) subgenerators, 632 subtype-of relationships, 267 super() function, 411, 488-490 syntactic sugar, 114 SyntaxError, 128 system administration, 726\n\nT tail call optimization (TCO), 691-693 TCP servers, 804-811 TensorFlow, 727 test servers, 765 text files, handling, 131-139 (see also Unicode\n\ntext versus bytes)\n\nThreadingHTTPServer class, 503 ThreadingMixIn class, 503 threads\n\ndefinition of term, 698 enhancing asyncio downloader, 788-797 further reading on, 734 Global Interpreter Lock impact, 714 spinners (loading indicators) using, 701-704 thread avoidance, 773 thread-based process pools, 724\n\nthrottling, 790-794 Timsort algorithm, 74 Tkinter GUI toolkit\n\nbenefits and drawbacks of, 513 multiple inheritance in, 507-509 tree structures, traversing, 634-639 tuples\n\nclassic named tuples, 169-172 immutability and, 221 as immutable lists, 32-34 versus lists, 34 nature of, 73 as records, 30-32 relative immutability of, 207 simplified memory diagram for, 23 tuple unpacking, 32 type hints (type annotations), 274-276 typing.NamedTuple, 172\n\nTwisted library, 830\n\ntype casting, 534-537 type hints (type annotations)\n\nannotating positional only and variadic\n\nparameters, 295\n\nfor asynchronous objects, 824 basics of, 173-179 benefits and drawbacks of, 253 flawed typing and strong testing, 296 further reading on, 298 generic type hints for coroutines, 650 gradual typing, 254-260 (see also gradual\n\ntype system) overview of, 297 significant changes to, 254 Soapbox discussion, 299-302 supported operations and, 261-265 topics covered, 254 types usable in, 266-295 typed double function, 466-468 TypedDict, 164, 526-534 Typeshed project, 280 TypeVar, 282-286 typing map, 432, 485 (see also type hints (type\n\nannotations)) typing module, 266 typing.NamedTuple, 172\n\nU UCA (see Unicode Collation Algorithm) UCS-2 encoding, 124 UML class diagrams\n\nABCs in collections.abc, 449 annotated with MGN, 882, 943 Command design pattern, 355 django.views.generic.base module, 504 django.views.generic.list module, 506 fundamental collection types, 14 managed and descriptor classes, 880 MutableSequence ABC and superclasses,\n\n448\n\nSequence ABC and abstract classes, 436 simplified for collections.abc, 24 simplified for MutableMapping and super‐\n\nclasses, 83\n\nsimplified for MutableSet and superclasses,\n\n107\n\nStrategy design pattern, 342 Tkinter Text widget class and superclasses,\n\n498\n\nIndex\n\n|\n\n977",
      "content_length": 2574,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 1008,
      "content": "TomboList, 461\n\nunary operators, 563-566 undocumented classes, 557 Unicode Collation Algorithm (UCA), 150 Unicode literals escape notation (\\N{}), 136 Unicode sandwich, 131 Unicode text versus bytes\n\nbasic encoders/decoders, 123-124 byte essentials, 120-123 characters and Unicode standard, 118-120 dual-mode str and bytes APIs, 155-157 further reading on, 158 handling text files, 131-139 normalizing Unicode for reliable compari‐\n\nsons, 140-148 overview of, 157 significant changes to, 118 Soapbox discussion, 160 sorting Unicode text, 148-150 topics covered, 117 understanding encode/decode problems,\n\n125-131\n\nUnicode database, 150-155\n\nUnicodeDecodeError, 126 UnicodeEncodeError, 125 Uniform Access Principle, 875-876 Union type, 270 unittest module, xxii unpacking\n\niterables and mappings, 240 mapping unpackings, 80 nested, 37 sequences and iterables, 35 using * to grab excess items, 36 with * in function calls and sequence liter‐\n\nals, 37\n\nuser-defined functions, 238 UserDict, 97-99 UTF-8 decoding, 129 UTF-8-SIG encoding, 130 uvloop, 829\n\nV variable annotations\n\nmeaning of, 175-179 syntax of, 174\n\nvariable scope rules, 308-310 variables\n\nfree, 313\n\n978\n\n|\n\nIndex\n\ninit-only variables, 186 as labels versus boxes, 202-204 lookup logic, 316 variadic parameters, 295 variance\n\ncontravariant types, 547 covariant types, 546 in callable types, 292 invariant types, 545 overview of, 549 relevance of, 544 rules of thumb, 551 variance notation in other classes, 558\n\nvars([object]) function, 871 Vector class, multidimensional\n\napplications beyond three dimensions, 398 dynamic attribute access, 407-411 __format__, 418-425 further reading on, 426 __hash__ and __eq__, 411-416 implementation strategy, 398 overview of, 425 protocols and duck typing, 402 sliceable sequences, 403-407 topics covered, 397 Vector2d compatibility, 399-401\n\nVector2d\n\nclass example, 365-368 full listing, 378-381 hashable, 374\n\nvectors\n\noverloading + for vector addition, 566-572 representing two-dimensional, 9-12\n\nvirtual attributes, 835 virtual subclasses, 460-463\n\nW Walrus operator (:=), 26 weak references, 221 Web Server Gateway Interface (WSGI), 730 web/mobile development, 728 with, match, and else blocks\n\ncontext managers and with blocks, 658-669 else clause, 687-689 further reading on, 690 overview of, 689 pattern matching in lis.py, 669-687 purpose of with statements, 658 significant changes to, 658",
      "content_length": 2400,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 1009,
      "content": "Soapbox discussion, 691-693 topics covered, 657\n\nY yield from expression, 632-639\n\nyield keyword, 238, 605-610, 614, 642, 645, 669\n\nZ zero-based indexing, 47 zip() function, 416\n\nIndex\n\n|\n\n979",
      "content_length": 192,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 1010,
      "content": "About the Author\n\nLuciano Ramalho was a web developer before the Netscape IPO in 1995, and switched from Perl to Java to Python in 1998. He joined Thoughtworks in 2015, where he is a Principal Consultant in the São Paulo office. He has delivered keynotes, talks, and tutorials at Python events in the Americas, Europe, and Asia, and also pre‐ sented at Go and Elixir conferences, focusing on language design topics. Ramalho is a fellow of the Python Software Foundation and cofounder of Garoa Hacker Clube, the first hackerspace in Brazil.\n\nColophon\n\nThe animal on the cover of Fluent Python is a Namaqua sand lizard (Pedioplanis namaquensis), found throughout Namibia in arid savannah and semi-desert regions.\n\nThe Namaqua sand lizard has a black body with four white stripes running down its back, brown legs with white spots, a white belly, and a long, pinkish-brown tail. It is one of the fastest of the lizards active during the day and feeds on small insects. It inhabits sparsely vegetated sand gravel flats. Female Namaqua sand lizards lay between three to five eggs in November, and these lizards spends the rest of winter dormant in burrows that they dig near the base of bushes.\n\nThe current conservation status of the Namaqua sand lizard is of “Least Concern.” Many of the animals on O’Reilly covers are endangered; all of them are important to the world.\n\nThe cover illustration is by Karen Montgomery, based on a black and white engrav‐ ing from Wood’s Natural History. The cover fonts are Gilroy Semibold and Guardian Sans. The text font is Adobe Minion Pro; the heading font is Adobe Myriad Con‐ densed; and the code font is Dalton Maag’s Ubuntu Mono.",
      "content_length": 1667,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 1011,
      "content": "Learn from experts. Become one yourself.\n\nBooks | Live online courses Instant Answers | Virtual events Videos | Interactive learning\n\nGet started at oreilly.com.\n\n5 7 1\n\nc n\n\na d e M y\n\ni\n\nl l i\n\ne R O\n\n’\n\nf o k r a m e d a r t d e r e t s g e r\n\ni\n\na\n\nl l i\n\ne R O\n\n’\n\n.\n\nc n\n\na d e M y\n\ni\n\nl l i\n\ne R O 2 2 0 2 ©\n\n’",
      "content_length": 317,
      "extraction_method": "Unstructured"
    }
  ]
}