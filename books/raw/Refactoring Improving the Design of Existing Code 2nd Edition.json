{
  "metadata": {
    "title": "Refactoring Improving the Design of Existing Code 2nd Edition",
    "author": "Unknown Author",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 455,
    "conversion_date": "2025-12-25T18:17:51.931454",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "Refactoring Improving the Design of Existing Code 2nd Edition.pdf",
    "extraction_method": "Unstructured"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 1-8)",
      "start_page": 1,
      "end_page": 8,
      "detection_method": "topic_boundary",
      "content": "www.EBooksWorld.ir\n\nHistory\n\nRefactoring\n\nTopics\n\nImproving the Design of Existing Code\n\nSecond Edition\n\nTutorials\n\nMartin Fowler\n\nOffers & Deals\n\nwith contributions by\n\nHighlights\n\nKent Beck\n\nSettings\n\nSupport\n\nBoston • Columbus • New York • San Francisco • Amsterdam • Cape Town\n\nDubai • London • Madrid • Milan • Munich • Paris • Montreal • Toronto • Delhi •\n\nSign Out\n\nMexico City\n\nSão Paulo • Sydney • Hong Kong • Seoul • Singapore • Taipei • Tokyo\n\nwww.EBooksWorld.ir\n\nPlaylists\n\nHistory\n\nMany of the designations used by manufacturers and sellers to distinguish their\n\nproducts are claimed as trademarks. Where those designations appear in this book, and\n\nTopics\n\nthe publisher was aware of a trademark claim, the designations have been printed with\n\ninitial capital letters or in all capitals.\n\nTutorials\n\nThe author and publisher have taken care in the preparation of this book, but make no\n\nOffers & Deals\n\nexpressed or implied warranty of any kind and assume no responsibility for errors or\n\nomissions. No liability is assumed for incidental or consequential damages in\n\nHighlights\n\nconnection with or arising out of the use of the information or programs contained\n\nherein.\n\nSettings\n\nFor information about buying this title in bulk quantities, or for special sales\n\nSupport\n\nopportunities (which may include electronic versions; custom cover designs; and\n\ncontent particular to your business, training goals, marketing focus, or branding\n\nSign Out\n\ninterests), please contact our corporate sales department at corpsales@pearsoned.com\n\nor (800) 382–3419.\n\nFor government sales inquiries, please contact governmentsales@pearsoned.com.\n\nFor questions about sales outside the U.S., please contact intlcs@pearson.com.\n\nVisit us on the Web: informit.com/aw\n\nLibrary of Congress Control Number: 2018950015\n\nCopyright © 2019 Pearson Education, Inc.\n\nCover photo: Waldo­Hancock Bridge & Penobscot Narrows Bridge by Martin Fowler\n\nLightbulb graphic: Irina Adamovich/Shutterstock\n\nAll rights reserved. Printed in the United States of America. This publication is\n\ni\n\nprotected by copyright, and permission must be obtained from the publisher prior to\n\nany prohibited reproduction, storage in a retrieval system, or transmission in any form\n\nor by any means, electronic, mechanical, photocopying, recording, or likewise. For\n\nwww.EBooksWorld.ir\n\ninformation regarding permissions, request forms and the appropriate contacts within\n\nthe Pearson Education Global Rights & Permissions Department, please visit\n\nwww.pearsoned.com/permissions/.\n\nISBN­13: 978­0­13­475759­9\n\nISBN­10: 0­13­475759­9\n\n1 18\n\nwww.EBooksWorld.ir\n\nChapter 1 Refactoring: A First Example\n\nHistory\n\nTopics\n\nHow do I begin to talk about refactoring? The traditional way is by introducing the\n\nhistory of the subject, broad principles, and the like. When somebody does that at a\n\nTutorials\n\nconference, I get slightly sleepy. My mind starts wandering, with a low­priority\n\nbackground process polling the speaker until they give an example.\n\nOffers & Deals\n\nThe examples wake me up because I can see what is going on. With principles, it is too\n\nHighlights\n\neasy to make broad generalizations—and too hard to figure out how to apply things. An\n\nexample helps make things clear.\n\nSettings\n\nSo I’m going to start this book with an example of refactoring. I’ll talk about how\n\nSupport\n\nrefactoring works and will give you a sense of the refactoring process. I can then do the\n\nSign Out\n\nusual principles­style introduction in the next chapter.\n\nWith any introductory example, however, I run into a problem. If I pick a large\n\nprogram, describing it and how it is refactored is too complicated for a mortal reader to\n\nwork through. (I tried this with the original book—and ended up throwing away two\n\nexamples, which were still pretty small but took over a hundred pages each to describe.)\n\nHowever, if I pick a program that is small enough to be comprehensible, refactoring\n\ndoes not look like it is worthwhile.\n\nI’m thus in the classic bind of anyone who wants to describe techniques that are useful\n\nfor real­world programs. Frankly, it is not worth the effort to do all the refactoring that\n\nI’m going to show you on the small program I will be using. But if the code I’m showing\n\nyou is part of a larger system, then the refactoring becomes important. Just look at my\n\nexample and imagine it in the context of a much larger system.\n\nTHE STARTING POINT\n\nIn the first edition of this book, my starting program printed a bill from a video rental\n\nstore, which may now lead many of you to ask: “What’s a video rental store?” Rather\n\nthan answer that question, I’ve reskinned the example to something that is both older\n\nwww.EBooksWorld.ir\n\nand still current.\n\nImage a company of theatrical players who go out to various events performing plays.\n\nTypically, a customer will request a few plays and the company charges them based on\n\nthe size of the audience and the kind of play they perform. There are currently two\n\nkinds of plays that the company performs: tragedies and comedies. As well as providing\n\na bill for the performance, the company gives its customers “volume credits” which they\n\ncan use for discounts on future performances—think of it as a customer loyalty\n\nmechanism.\n\nThe performers store data about their plays in a simple JSON file that looks something\n\nlike this:\n\nplays.json…\n\nClick here to view code image\n\n{ \"hamlet\": {\"name\": \"Hamlet\", \"type\": \"tragedy\"}, \"as­like\": {\"name\": \"As You Like It\", \"type\": \"comedy\"}, \"othello\": {\"name\": \"Othello\", \"type\": \"tragedy\"} }\n\nThe data for their bills also comes in a JSON file:\n\ninvoices.json…\n\nClick here to view code image\n\n[ { \"customer\": \"BigCo\", \"performances\": [ { \"playID\": \"hamlet\", \"audience\": 55 }, { \"playID\": \"as­like\", \"audience\": 35 }, { \"playID\": \"othello\", \"audience\": 40 }\n\nwww.EBooksWorld.ir\n\n] } ]\n\nThe code that prints the bill is this simple function:\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { const play = plays[perf.playID]; let thisAmount = 0;\n\nswitch (play.type) { case \"tragedy\": thisAmount = 40000; if (perf.audience > 30) { thisAmount += 1000 * (perf.audience ­ 30); } break; case \"comedy\": thisAmount = 30000; if (perf.audience > 20) { thisAmount += 10000 + 500 * (perf.audience ­ 20); } thisAmount += 300 * perf.audience; break; default: throw new Error(`unknown type: ${play.type}`); }\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === play.type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience} seats)\\n`; totalAmount += thisAmount; } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result; }\n\nwww.EBooksWorld.ir\n\nRunning that code on the test data files above results in the following output:\n\nClick here to view code image\n\nStatement for BigCo Hamlet: $650.00 (55 seats) As You Like It: $580.00 (35 seats) Othello: $500.00 (40 seats) Amount owed is $1,730.00 You earned 47 credits\n\nCOMMENTS ON THE STARTING PROGRAM\n\nWhat are your thoughts on the design of this program? The first thing I’d say is that it’s\n\ntolerable as it is—a program so short doesn’t require any deep structure to be\n\ncomprehensible. But remember my earlier point that I have to keep examples small.\n\nImagine this program on a larger scale—perhaps hundreds of lines long. At that size, a\n\nsingle inline function is hard to understand.\n\nGiven that the program works, isn’t any statement about its structure merely an\n\naesthetic judgment, a dislike of “ugly” code? After all, the compiler doesn’t care whether\n\nthe code is ugly or clean. But when I change the system, there is a human involved, and\n\nhumans do care. A poorly designed system is hard to change—because it is difficult to\n\nfigure out what to change and how these changes will interact with the existing code to\n\nget the behavior I want. And if it is hard to figure out what to change, there is a good\n\nchance that I will make mistakes and introduce bugs.\n\nThus, if I’m faced with modifying a program with hundreds of lines of code, I’d rather it\n\nbe structured into a set of functions and other program elements that allow me to\n\nunderstand more easily what the program is doing. If the program lacks structure, it’s\n\nusually easier for me to add structure to the program first, and then make the change I\n\nneed.\n\nWhen you have to add a feature to a program but the code is not structured in\n\na convenient way, first refactor the program to make it easy to add the feature, then\n\nadd the feature.\n\nIn this case, I have a couple of changes that the users would like to make. First, they\n\nwant a statement printed in HTML. Consider what impact this change would have. I’m\n\nfaced with adding conditional statements around every statement that adds a string to\n\nwww.EBooksWorld.ir",
      "page_number": 1
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 9-19)",
      "start_page": 9,
      "end_page": 19,
      "detection_method": "topic_boundary",
      "content": "the result. That will add a host of complexity to the function. Faced with that, most\n\npeople prefer to copy the method and change it to emit HTML. Making a copy may not\n\nseem too onerous a task, but it sets up all sorts of problems for the future. Any changes\n\nto the charging logic would force me to update both methods—and to ensure they are\n\nupdated consistently. If I’m writing a program that will never change again, this kind of\n\ncopy­and­paste is fine. But if it’s a long­lived program, then duplication is a menace.\n\nThis brings me to a second change. The players are looking to perform more kinds of\n\nplays: they hope to add history, pastoral, pastoral­comical, historical­pastoral, tragical­\n\nhistorical, tragical­comical­historical­pastoral, scene individable, and poem unlimited\n\nto their repertoire. They haven’t exactly decided yet what they want to do and when.\n\nThis change will affect both the way their plays are charged for and the way volume\n\ncredits are calculated. As an experienced developer I can be sure that whatever scheme\n\nthey come up with, they will change it again within six months. After all, when feature\n\nrequests come, they come not as single spies but in battalions.\n\nAgain, that statement method is where the changes need to be made to deal with\n\nchanges in classification and charging rules. But if I copy statement to\n\nhtmlStatement, I’d need to ensure that any changes are consistent. Furthermore, as\n\nthe rules grow in complexity, it’s going to be harder to figure out where to make the\n\nchanges and harder to do them without making a mistake.\n\nLet me stress that it’s these changes that drive the need to perform refactoring. If the\n\ncode works and doesn’t ever need to change, it’s perfectly fine to leave it alone. It would\n\nbe nice to improve it, but unless someone needs to understand it, it isn’t causing any\n\nreal harm. Yet as soon as someone does need to understand how that code works, and\n\nstruggles to follow it, then you have to do something about it.\n\nTHE FIRST STEP IN REFACTORING\n\nWhenever I do refactoring, the first step is always the same. I need to ensure I have a\n\nsolid set of tests for that section of code. The tests are essential because even though I\n\nwill follow refactorings structured to avoid most of the opportunities for introducing\n\nbugs, I’m still human and still make mistakes. The larger a program, the more likely it\n\nis that my changes will cause something to break inadvertently—in the digital age,\n\nfrailty’s name is software.\n\nSince the statement returns a string, what I do is create a few invoices, give each\n\ninvoice a few performances of various kinds of plays, and generate the statement\n\nstrings. I then do a string comparison between the new string and some reference\n\nwww.EBooksWorld.ir\n\nstrings that I have hand­checked. I set up all of these tests using a testing framework so\n\nI can run them with just a simple keystroke in my development environment. The tests\n\ntake only a few seconds to run, and as you will see, I run them often.\n\nAn important part of the tests is the way they report their results. They either go green,\n\nmeaning that all the strings are identical to the reference strings, or red, showing a list\n\nof failures—the lines that turned out differently. The tests are thus self­checking. It is\n\nvital to make tests self­checking. If I don’t, I’d end up spending time hand­checking\n\nvalues from the test against values on a desk pad, and that would slow me down.\n\nModern testing frameworks provide all the features needed to write and run self­\n\nchecking tests.\n\nBefore you start refactoring, make sure you have a solid suite of tests. These\n\ntests must be self­checking.\n\nAs I do the refactoring, I’ll lean on the tests. I think of them as a bug detector to protect\n\nme against my own mistakes. By writing what I want twice, in the code and in the test, I\n\nhave to make the mistake consistently in both places to fool the detector. By double­\n\nchecking my work, I reduce the chance of doing something wrong. Although it takes\n\ntime to build the tests, I end up saving that time, with considerable interest, by\n\nspending less time debugging. This is such an important part of refactoring that I\n\ndevote a full chapter to it (Building Tests (85)).\n\nDECOMPOSING THE STATEMENT FUNCTION\n\nWhen refactoring a long function like this, I mentally try to identify points that separate\n\ndifferent parts of the overall behavior. The first chunk that leaps to my eye is the switch\n\nstatement in the middle.\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { const play = plays[perf.playID]; let thisAmount = 0;\n\nwww.EBooksWorld.ir\n\nswitch (play.type) { case \"tragedy\": thisAmount = 40000; if (perf.audience > 30) { thisAmount += 1000 * (perf.audience ­ 30); } break; case \"comedy\": thisAmount = 30000; if (perf.audience > 20) { thisAmount += 10000 + 500 * (perf.audience ­ 20); } thisAmount += 300 * perf.audience; break; default: throw new Error(`unknown type: ${play.type}`); }\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === play.type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience} seats)\\n`; totalAmount += thisAmount; } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result; }\n\nAs I look at this chunk, I conclude that it’s calculating the charge for one performance.\n\nThat conclusion is a piece of insight about the code. But as Ward Cunningham puts it,\n\nthis understanding is in my head—a notoriously volatile form of storage. I need to\n\npersist it by moving it from my head back into the code itself. That way, should I come\n\nback to it later, the code will tell me what it’s doing—I don’t have to figure it out again.\n\nThe way to put that understanding into code is to turn that chunk of code into its own\n\nfunction, naming it after what it does—something like amountFor(aPerformance).\n\nWhen I want to turn a chunk of code into a function like this, I have a procedure for\n\ndoing it that minimizes my chances of getting it wrong. I wrote down this procedure\n\nand, to make it easy to reference, named it Extract Function (106).\n\nFirst, I need to look in the fragment for any variables that will no longer be in scope\n\nonce I’ve extracted the code into its own function. In this case, I have three: perf,\n\nwww.EBooksWorld.ir\n\nplay, and thisAmount. The first two are used by the extracted code, but not modified,\n\nso I can pass them in as parameters. Modified variables need more care. Here, there is\n\nonly one, so I can return it. I can also bring its initialization inside the extracted code.\n\nAll of which yields this:\n\nfunction statement…\n\nClick here to view code image\n\nfunction amountFor(perf, play) { let thisAmount = 0; switch (play.type) { case \"tragedy\": thisAmount = 40000; if (perf.audience > 30) { thisAmount += 1000 * (perf.audience ­ 30); } break; case \"comedy\": thisAmount = 30000; if (perf.audience > 20) { thisAmount += 10000 + 500 * (perf.audience ­ 20); } thisAmount += 300 * perf.audience; break; default: throw new Error(`unknown type: ${play.type}`); } return thisAmount; }\n\nWhen I use a header like “function someName…” in italics for some code, that means\n\nthat the following code is within the scope of the function, file, or class named in the\n\nheader. There is usually other code within that scope that I won’t show, as I’m not\n\ndiscussing it at the moment.\n\nThe original statement code now calls this function to populate thisAmount:\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`;\n\nwww.EBooksWorld.ir\n\nconst format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { const play = plays[perf.playID]; let thisAmount = amountFor(perf, play);\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === play.type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience} seats)\\n`; totalAmount += thisAmount; } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nOnce I’ve made this change, I immediately compile and test to see if I’ve broken\n\nanything. It’s an important habit to test after every refactoring, however simple.\n\nMistakes are easy to make—at least, I find them easy to make. Testing after each change\n\nmeans that when I make a mistake, I only have a small change to consider in order to\n\nspot the error, which makes it far easier to find and fix. This is the essence of the\n\nrefactoring process: small changes and testing after each change. If I try to do too\n\nmuch, making a mistake will force me into a tricky debugging episode that can take a\n\nlong time. Small changes, enabling a tight feedback loop, are the key to avoiding that\n\nmess.\n\nI use compile here to mean doing whatever is needed to make the JavaScript\n\nexecutable. Since JavaScript is directly executable, that may mean nothing, but in other\n\ncases it may mean moving code to an output directory and/or using a processor such as\n\nBabel [babel].\n\nRefactoring changes the programs in small steps, so if you make a mistake, it\n\nis easy to find where the bug is.\n\nThis being JavaScript, I can extract amountFor into a nested function of statement.\n\nThis is helpful as it means I don’t have to pass data that’s inside the scope of the\n\ncontaining function to the newly extracted function. That doesn’t make a difference in\n\nthis case, but it’s one less issue to deal with.\n\nwww.EBooksWorld.ir\n\nIn this case the tests passed, so my next step is to commit the change to my local\n\nversion control system. I use a version control system, such as git or mercurial, that\n\nallows me to make private commits. I commit after each successful refactoring, so I can\n\neasily get back to a working state should I mess up later. I then squash changes into\n\nmore significant commits before I push the changes to a shared repository.\n\nExtract Function (106) is a common refactoring to automate. If I was programming in\n\nJava, I would have instinctively reached for the key sequence for my IDE to perform\n\nthis refactoring. As I write this, there is no such robust support for this refactoring in\n\nJavaScript tools, so I have to do this manually. It’s not hard, although I have to be\n\ncareful with those locally scoped variables.\n\nOnce I’ve used Extract Function (106), I take a look at what I’ve extracted to see if there\n\nare any quick and easy things I can do to clarify the extracted function. The first thing I\n\ndo is rename some of the variables to make them clearer, such as changing\n\nthisAmount to result.\n\nfunction statement…\n\nClick here to view code image\n\nfunction amountFor(perf, play) { let result = 0; switch (play.type) { case \"tragedy\": result = 40000; if (perf.audience > 30) { result += 1000 * (perf.audience ­ 30); } break; case \"comedy\": result = 30000; if (perf.audience > 20) { result += 10000 + 500 * (perf.audience ­ 20); } result += 300 * perf.audience; break; default: throw new Error(`unknown type: ${play.type}`); } return result; }\n\nIt’s my coding standard to always call the return value from a function “result”. That\n\nway I always know its role. Again, I compile, test, and commit. Then I move onto the\n\nwww.EBooksWorld.ir\n\nfirst argument.\n\nfunction statement…\n\nClick here to view code image\n\nfunction amountFor(aPerformance, play) { let result = 0; switch (play.type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${play.type}`); } return result; }\n\nAgain, this is following my coding style. With a dynamically typed language such as\n\nJavaScript, it’s useful to keep track of types—hence, my default name for a parameter\n\nincludes the type name. I use an indefinite article with it unless there is some specific\n\nrole information to capture in the name. I learned this convention from Kent Beck\n\n[Beck SBPP] and continue to find it helpful.\n\nAny fool can write code that a computer can understand. Good programmers\n\nwrite code that humans can understand.\n\nIs this renaming worth the effort? Absolutely. Good code should clearly communicate\n\nwhat it is doing, and variable names are a key to clear code. Never be afraid to change\n\nnames to improve clarity. With good find­and­replace tools, it is usually not difficult;\n\ntesting, and static typing in a language that supports it, will highlight any occurrences\n\nyou miss. And with automated refactoring tools, it’s trivial to rename even widely used\n\nfunctions.\n\nwww.EBooksWorld.ir\n\nThe next item to consider for renaming is the play parameter, but I have a different\n\nfate for that.\n\nRemoving the play Variable\n\nAs I consider the parameters to amountFor, I look to see where they come from.\n\naPerformance comes from the loop variable, so naturally changes with each iteration\n\nthrough the loop. But play is computed from the performance, so there’s no need to\n\npass it in as a parameter at all—I can just recalculate it within amountFor. When I’m\n\nbreaking down a long function, I like to get rid of variables like play, because\n\ntemporary variables create a lot of locally scoped names that complicate extractions.\n\nThe refactoring I will use here is Replace Temp with Query (178).\n\nI begin by extracting the right­hand side of the assignment into a function.\n\nfunction statement…\n\nClick here to view code image\n\nfunction playFor(aPerformance) { return plays[aPerformance.playID]; }\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { const play = playFor(perf); let thisAmount = amountFor(perf, play);\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === play.type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience} seats)\\n`;\n\nwww.EBooksWorld.ir\n\ntotalAmount += thisAmount; } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nI compile­test­commit, and then use Inline Variable (123).\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { const play = playFor(perf); let thisAmount = amountFor(perf, playFor(perf));\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(thisAmount/100)} (${perf.audience} seats)\\n`; totalAmount += thisAmount; } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nI compile­test­commit. With that inlined, I can then apply Change Function\n\nDeclaration (124) to amountFor to remove the play parameter. I do this in two steps.\n\nFirst, I use the new function inside amountFor.\n\nfunction statement…\n\nClick here to view code image\n\nfunction amountFor(aPerformance, play) { let result = 0;\n\nwww.EBooksWorld.ir\n\nswitch (playFor(aPerformance).type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${playFor(aPerformance).type}`); } return result; }\n\nI compile­test­commit, and then delete the parameter.\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { let thisAmount = amountFor(perf, playFor(perf));\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(thisAmount/100)} (${perf.audience} seats)\\n`; totalAmount += thisAmount; } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nwww.EBooksWorld.ir\n\nfunction statement…\n\nClick here to view code image\n\nfunction amountFor(aPerformance, play) { let result = 0; switch (playFor(aPerformance).type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${playFor(aPerformance).type}`); } return result; }\n\nAnd compile­test­commit again.\n\nThis refactoring alarms some programmers. Previously, the code to look up the play\n\nwas executed once in each loop iteration; now, it’s executed thrice. I’ll talk about the\n\ninterplay of refactoring and performance later, but for the moment I’ll just observe that\n\nthis change is unlikely to significantly affect performance, and even if it were, it is much\n\neasier to improve the performance of a well­factored code base.\n\nThe great benefit of removing local variables is that it makes it much easier to do\n\nextractions, since there is less local scope to deal with. Indeed, usually I’ll take out local\n\nvariables before I do any extractions.\n\nNow that I’m done with the arguments to amountFor, I look back at where it’s called.\n\nIt’s being used to set a temporary variable that’s not updated again, so I apply Inline\n\nVariable (123).\n\ntop level…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "page_number": 9
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 20-42)",
      "start_page": 20,
      "end_page": 42,
      "detection_method": "topic_boundary",
      "content": "function statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) {\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nExtracting Volume Credits\n\nHere’s the current state of the statement function body:\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) {\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } result += `Amount owed is ${format(totalAmount/100)}\\n`;\n\nwww.EBooksWorld.ir\n\nresult += `You earned ${volumeCredits} credits\\n`; return result;\n\nNow I get the benefit from removing the play variable as it makes it easier to extract\n\nthe volume credits calculation by removing one of the locally scoped variables.\n\nI still have to deal with the other two. Again, perf is easy to pass in, but\n\nvolumeCredits is a bit more tricky as it is an accumulator updated in each pass of the\n\nloop. So my best bet is to initialize a shadow of it inside the extracted function and\n\nreturn it.\n\nfunction statement…\n\nClick here to view code image\n\nfunction volumeCreditsFor(perf) { let volumeCredits = 0; volumeCredits += Math.max(perf.audience ­ 30, 0); if (\"comedy\" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5); return volumeCredits; }\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { volumeCredits += volumeCreditsFor(perf);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nwww.EBooksWorld.ir\n\nI remove the unnecessary (and, in this case, downright misleading) comment.\n\nI compile­test­commit that, and then rename the variables inside the new function.\n\nfunction statement…\n\nClick here to view code image\n\nfunction volumeCreditsFor(aPerformance) { let result = 0; result += Math.max(aPerformance.audience ­ 30, 0); if (\"comedy\" === playFor(aPerformance).type) result += Math.floor(aPerformance.audience / 5); return result; }\n\nI’ve shown it in one step, but as before I did the renames one at a time, with a compile­\n\ntest­commit after each.\n\nRemoving the format Variable\n\nLet’s look at the main statement method again:\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { volumeCredits += volumeCreditsFor(perf);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nwww.EBooksWorld.ir\n\nAs I suggested before, temporary variables can be a problem. They are only useful\n\nwithin their own routine, and therefore they encourage long, complex routines. My next\n\nmove, then, is to replace some of them. The easiest one is format. This is a case of\n\nassigning a function to a temp, which I prefer to replace with a declared function.\n\nfunction statement…\n\nClick here to view code image\n\nfunction format(aNumber) { return new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format(aNumber); }\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { volumeCredits += volumeCreditsFor(perf);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nAlthough changing a function variable to a declared function is a refactoring, I haven’t\n\nnamed it and included it in the catalog. There are many refactorings that I didn’t feel\n\nimportant enough for that. This one is both simple to do and relatively rare, so I didn’t\n\nthink it was worthwhile.\n\nI’m not keen on the name—“format” doesn’t really convey enough of what it’s doing.\n\n“formatAsUSD” would be a bit too long­winded since it’s being used in a string\n\ntemplate, particularly within this small scope. I think the fact that it’s formatting a\n\ncurrency amount is the thing to highlight here, so I pick a name that suggests that and\n\nwww.EBooksWorld.ir\n\napply Change Function Declaration (124).\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { volumeCredits += volumeCreditsFor(perf);\n\n// print line for this order result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } result += `Amount owed is ${usd(totalAmount)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nfunction statement…\n\nClick here to view code image\n\nfunction usd(aNumber) { return new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format(aNumber/100); }\n\nNaming is both important and tricky. Breaking a large function into smaller ones only\n\nadds value if the names are good. With good names, I don’t have to read the body of the\n\nfunction to see what it does. But it’s hard to get names right the first time, so I use the\n\nbest name I can think of for the moment, and don’t hesitate to rename it later. Often, it\n\ntakes a second pass through some code to realize what the best name really is.\n\nAs I’m changing the name, I also move the duplicated division by 100 into the function.\n\nStoring money as integer cents is a common approach—it avoids the dangers of storing\n\nfractional monetary values as floats but allows me to use arithmetic operators.\n\nWhenever I want to display such a penny­integer number, however, I need a decimal,\n\nso my formatting function should take care of the division.\n\nwww.EBooksWorld.ir\n\nRemoving Total Volume Credits\n\nRemoving Total Volume Credits\n\nMy next target variable is volumeCredits. This is a trickier case, as it’s built up\n\nduring the iterations of the loop. My first move, then, is to use Split Loop (227) to\n\nseparate the accumulation of volumeCredits.\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`;\n\nfor (let perf of invoice.performances) {\n\n// print line for this order result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } for (let perf of invoice.performances) { volumeCredits += volumeCreditsFor(perf); }\n\nresult += `Amount owed is ${usd(totalAmount)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nWith that done, I can use Slide Statements (223) to move the declaration of the variable\n\nnext to the loop.\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) {\n\n// print line for this order result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } let volumeCredits = 0; for (let perf of invoice.performances) {\n\nwww.EBooksWorld.ir\n\nvolumeCredits += volumeCreditsFor(perf); } result += `Amount owed is ${usd(totalAmount)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nGathering together everything that updates the volumeCredits variable makes it\n\neasier to do Replace Temp with Query (178). As before, the first step is to apply Extract\n\nFunction (106) to the overall calculation of the variable.\n\nfunction statement…\n\nClick here to view code image\n\nfunction totalVolumeCredits() { let volumeCredits = 0; for (let perf of invoice.performances) { volumeCredits += volumeCreditsFor(perf); } return volumeCredits; }\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) {\n\n// print line for this order result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } let volumeCredits = totalVolumeCredits(); result += `Amount owed is ${usd(totalAmount)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nOnce everything is extracted, I can apply Inline Variable (123):\n\ntop level…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) {\n\n// print line for this order result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); }\n\nresult += `Amount owed is ${usd(totalAmount)}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nLet me pause for a bit to talk about what I’ve just done here. Firstly, I know readers will\n\nagain be worrying about performance with this change, as many people are wary of\n\nrepeating a loop. But most of the time, rerunning a loop like this has a negligible effect\n\non performance. If you timed the code before and after this refactoring, you would\n\nprobably not notice any significant change in speed—and that’s usually the case. Most\n\nprogrammers, even experienced ones, are poor judges of how code actually performs.\n\nMany of our intuitions are broken by clever compilers, modern caching techniques, and\n\nthe like. The performance of software usually depends on just a few parts of the code,\n\nand changes anywhere else don’t make an appreciable difference.\n\nBut “mostly” isn’t the same as “alwaysly.” Sometimes a refactoring will have a\n\nsignificant performance implication. Even then, I usually go ahead and do it, because\n\nit’s much easier to tune the performance of well­factored code. If I introduce a\n\nsignificant performance issue during refactoring, I spend time on performance tuning\n\nafterwards. It may be that this leads to reversing some of the refactoring I did earlier—\n\nbut most of the time, due to the refactoring, I can apply a more effective performance­\n\ntuning enhancement instead. I end up with code that’s both clearer and faster.\n\nSo, my overall advice on performance with refactoring is: Most of the time you should\n\nignore it. If your refactoring introduces performance slow­downs, finish refactoring\n\nfirst and do performance tuning afterwards.\n\nThe second aspect I want to call your attention to is how small the steps were to remove\n\nvolumeCredits. Here are the four steps, each followed by compiling, testing, and\n\ncommitting to my local source code repository:\n\nwww.EBooksWorld.ir\n\nSplit Loop (227) to isolate the accumulation\n\nSlide Statements (223) to bring the initializing code next to the accumulation\n\nExtract Function (106) to create a function for calculating the total\n\nInline Variable (123) to remove the variable completely\n\nI confess I don’t always take quite as short steps as these—but whenever things get\n\ndifficult, my first reaction is to take shorter steps. In particular, should a test fail during\n\na refactoring, if I can’t immediately see and fix the problem, I’ll revert to my last good\n\ncommit and redo what I just did with smaller steps. That works because I commit so\n\nfrequently and because small steps are the key to moving quickly, particularly when\n\nworking with difficult code.\n\nI then repeat that sequence to remove totalAmount. I start by splitting the loop\n\n(compile­test­commit), then I slide the variable initialization (compile­test­commit),\n\nand then I extract the function. There is a wrinkle here: The best name for the function\n\nis “totalAmount”, but that’s the name of the variable, and I can’t have both at the same\n\ntime. So I give the new function a random name when I extract it (and compile­test­\n\ncommit).\n\nfunction statement…\n\nClick here to view code image\n\nfunction appleSauce() { let totalAmount = 0; for (let perf of invoice.performances) { totalAmount += amountFor(perf); } return totalAmount; }\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; }\n\nwww.EBooksWorld.ir\n\nlet totalAmount = appleSauce();\n\nresult += `Amount owed is ${usd(totalAmount)}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nThen I inline the variable (compile­test­commit) and rename the function to something\n\nmore sensible (compile­test­commit).\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction statement…\n\nClick here to view code image\n\nfunction totalAmount() { let totalAmount = 0; for (let perf of invoice.performances) { totalAmount += amountFor(perf); } return totalAmount; }\n\nI also take the opportunity to change the names inside my extracted functions to adhere\n\nto my convention.\n\nfunction statement…\n\nClick here to view code image\n\nfunction totalAmount() { let result = 0;\n\nwww.EBooksWorld.ir\n\nfor (let perf of invoice.performances) { result += amountFor(perf); } return result; } function totalVolumeCredits() { let result = 0; for (let perf of invoice.performances) { result += volumeCreditsFor(perf); } return result; }\n\nSTATUS: LOTS OF NESTED FUNCTIONS\n\nNow is a good time to pause and take a look at the overall state of the code:\n\nClick here to view code image\n\nfunction statement (invoice, plays) {\n\nlet result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction totalAmount() {\n\nlet result = 0; for (let perf of invoice.performances) { result += amountFor(perf); } return result; }\n\nfunction totalVolumeCredits() {\n\nlet result = 0; for (let perf of invoice.performances) { result += volumeCreditsFor(perf); } return result; } function usd(aNumber) {\n\nreturn new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format(aNumber/100); } function volumeCreditsFor(aPerformance) {\n\nlet result = 0; result += Math.max(aPerformance.audience ­ 30, 0);\n\nwww.EBooksWorld.ir\n\nif (\"comedy\" === playFor(aPerformance).type) result += Math.floor(aPerformance.audience / 5); return result; } function playFor(aPerformance) {\n\nreturn plays[aPerformance.playID]; } function amountFor(aPerformance) {\n\nlet result = 0; switch (playFor(aPerformance).type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${playFor(aPerformance).type}`); } return result; } }\n\nThe structure of the code is much better now. The top­level statement function is now\n\njust seven lines of code, and all it does is laying out the printing of the statement. All the\n\ncalculation logic has been moved out to a handful of supporting functions. This makes\n\nit easier to understand each individual calculation as well as the overall flow of the\n\nreport.\n\nSPLITTING THE PHASES OF CALCULATION AND FORMATTING\n\nSo far, my refactoring has focused on adding enough structure to the function so that I\n\ncan understand it and see it in terms of its logical parts. This is often the case early in\n\nrefactoring. Breaking down complicated chunks into small pieces is important, as is\n\nnaming things well. Now, I can begin to focus more on the functionality change I want\n\nto make—specifically, providing an HTML version of this statement. In many ways, it’s\n\nnow much easier to do. With all the calculation code split out, all I have to do is write an\n\nHTML version of the seven lines of code at the top. The problem is that these broken­\n\nout functions are nested within the textual statement method, and I don’t want to copy\n\nwww.EBooksWorld.ir\n\nand paste them into a new function, however well organized. I want the same\n\ncalculation functions to be used by the text and HTML versions of the statement.\n\nThere are various ways to do this, but one of my favorite techniques is Split Phase (154).\n\nMy aim here is to divide the logic into two parts: one that calculates the data required\n\nfor the statement, the other that renders it into text or HTML. The first phase creates\n\nan intermediate data structure that it passes to the second.\n\nI start a Split Phase (154) by applying Extract Function (106) to the code that makes up\n\nthe second phase. In this case, that’s the statement printing code, which is in fact the\n\nentire content of statement. This, together with all the nested functions, goes into its\n\nown top­level function which I call renderPlainText.\n\nClick here to view code image\n\nfunction statement (invoice, plays) {\n\nreturn renderPlainText(invoice, plays); }\n\nfunction renderPlainText(invoice, plays) {\n\nlet result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction totalAmount() {...} function totalVolumeCredits() {...} function usd(aNumber) {...} function volumeCreditsFor(aPerformance) {...} function playFor(aPerformance) {...} function amountFor(aPerformance) {...}\n\nI do my usual compile­test­commit, then create an object that will act as my\n\nintermediate data structure between the two phases. I pass this data object in as an\n\nargument to renderPlainText (compile­test­commit).\n\nClick here to view code image\n\nfunction statement (invoice, plays) { const statementData = {}; return renderPlainText(statementData, invoice, plays); }\n\nwww.EBooksWorld.ir\n\nfunction renderPlainText(data, invoice, plays) { let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction totalAmount() {...} function totalVolumeCredits() {...} function usd(aNumber) {...} function volumeCreditsFor(aPerformance) {...} function playFor(aPerformance) {...} function amountFor(aPerformance) {...}\n\nI now examine the other arguments used by renderPlainText. I want to move the\n\ndata that comes from them into the intermediate data structure, so that all the\n\ncalculation code moves into the statement function and renderPlainText operates\n\nsolely on data passed to it through the data parameter.\n\nMy first move is to take the customer and add it to the intermediate object (compile­\n\ntest­commit).\n\nClick here to view code image\n\nfunction statement (invoice, plays) { const statementData = {}; statementData.customer = invoice.customer; return renderPlainText(statementData, invoice, plays); }\n\nfunction renderPlainText(data, invoice, plays) { let result = `Statement for ${data.customer}\\n`; for (let perf of invoice.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nSimilarly, I add the performances, which allows me to delete the invoice parameter to\n\nrenderPlainText (compile­test­commit).\n\nwww.EBooksWorld.ir\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { const statementData = {}; statementData.customer = invoice.customer; statementData.performances = invoice.performances; return renderPlainText(statementData, invoice, plays); }\n\nfunction renderPlainText(data, plays) { let result = `Statement for ${data.customer}\\n`; for (let perf of data.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction renderPlainText…\n\nClick here to view code image\n\nfunction totalAmount() { let result = 0; for (let perf of data.performances) { result += amountFor(perf); } return result; } function totalVolumeCredits() { let result = 0; for (let perf of data.performances) { result += volumeCreditsFor(perf); } return result; }\n\nNow I’d like the play name to come from the intermediate data. To do this, I need to\n\nenrich the performance record with data from the play (compile­test­commit).\n\nClick here to view code image\n\nfunction statement (invoice, plays) { const statementData = {};\n\nwww.EBooksWorld.ir\n\nstatementData.customer = invoice.customer; statementData.performances = invoice.performances.map(enrichPerformance); return renderPlainText(statementData, plays);\n\nfunction enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); return result; }\n\nAt the moment, I’m just making a copy of the performance object, but I’ll shortly add\n\ndata to this new record. I take a copy because I don’t want to modify the data passed\n\ninto the function. I prefer to treat data as immutable as much as I can—mutable state\n\nquickly becomes something rotten.\n\nThe idiom result = Object.assign({}, aPerformance) looks very odd to\n\npeople unfamiliar to JavaScript. It performs a shallow copy. I’d prefer to have a\n\nfunction for this, but it’s one of those cases where the idiom is so baked into JavaScript\n\nusage that writing my own function would look out of place for JavaScript\n\nprogrammers.\n\nNow I have a spot for the play, I need to add it. To do that, I need to apply Move\n\nFunction (198) to playFor and statement (compile­test­commit).\n\nfunction statement…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); result.play = playFor(result); return result; }\n\nfunction playFor(aPerformance) { return plays[aPerformance.playID]; }\n\nI then replace all the references to playFor in renderPlainText to use the data\n\ninstead (compile­test­commit).\n\nfunction renderPlainText…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nlet result = `Statement for ${data.customer}\\n`; for (let perf of data.performances) { result += ` ${perf.play.name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction volumeCreditsFor(aPerformance) { let result = 0; result += Math.max(aPerformance.audience ­ 30, 0); if (\"comedy\" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5); return result; }\n\nfunction amountFor(aPerformance) { let result = 0; switch (aPerformance.play.type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${aPerformance.play.type}`); } return result; }\n\nI then move amountFor in a similar way (compile­test­commit).\n\nfunction statement…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); result.play = playFor(result); result.amount = amountFor(result); return result; }\n\nwww.EBooksWorld.ir\n\nfunction amountFor(aPerformance) {...}\n\nfunction renderPlainText…\n\nClick here to view code image\n\nlet result = `Statement for ${data.customer}\\n`; for (let perf of data.performances) { result += ` ${perf.play.name}: ${usd(perf.amount)} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction totalAmount() { let result = 0; for (let perf of data.performances) { result += perf.amount; } return result; }\n\nNext, I move the volume credits calculation (compile­test­commit).\n\nfunction statement…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); result.play = playFor(result); result.amount = amountFor(result); result.volumeCredits = volumeCreditsFor(result); return result; }\n\nfunction volumeCreditsFor(aPerformance) {...}\n\nfunction renderPlainText…\n\nClick here to view code image\n\nfunction totalVolumeCredits() { let result = 0;\n\nwww.EBooksWorld.ir\n\nfor (let perf of data.performances) { result += perf.volumeCredits; } return result; }\n\nFinally, I move the two calculations of the totals.\n\nfunction statement…\n\nClick here to view code image\n\nconst statementData = {}; statementData.customer = invoice.customer; statementData.performances = invoice.performances.map(enrichPerformance); statementData.totalAmount = totalAmount(statementData); statementData.totalVolumeCredits = totalVolumeCredits(statementData); return renderPlainText(statementData, plays);\n\nfunction totalAmount(data) {...} function totalVolumeCredits(data) {...}\n\nfunction renderPlainText…\n\nClick here to view code image\n\nlet result = `Statement for ${data.customer}\\n`; for (let perf of data.performances) { result += ` ${perf.play.name}: ${usd(perf.amount)} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(data.totalAmount)}\\n`; result += `You earned ${data.totalVolumeCredits} credits\\n`; return result;\n\nAlthough I could have modified the bodies of these totals functions to use the\n\nstatementData variable (as it’s within scope), I prefer to pass the explicit parameter.\n\nAnd, once I’m done with compile­test­commit after the move, I can’t resist a couple\n\nquick shots of Replace Loop with Pipeline (231).\n\nfunction renderPlainText…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nfunction totalAmount(data) { return data.performances .reduce((total, p) => total + p.amount, 0); } function totalVolumeCredits(data) { return data.performances .reduce((total, p) => total + p.volumeCredits, 0); }\n\nI now extract all the first­phase code into its own function (compile­test­commit).\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { return renderPlainText(createStatementData(invoice, plays)); }\n\nfunction createStatementData(invoice, plays) { const statementData = {}; statementData.customer = invoice.customer; statementData.performances = invoice.performances.map(enrichPerformance); statementData.totalAmount = totalAmount(statementData); statementData.totalVolumeCredits = totalVolumeCredits(statementData); return statementData;\n\nSince it’s clearly separate now, I move it to its own file (and alter the name of the\n\nreturned result to match my usual convention).\n\nstatement.js…\n\nClick here to view code image\n\nimport createStatementData from './createStatementData.js';\n\ncreateStatementData.js…\n\nClick here to view code image\n\nexport default function createStatementData(invoice, plays) { const result = {}; result.customer = invoice.customer; result.performances = invoice.performances.map(enrichPerformance);\n\nwww.EBooksWorld.ir\n\nresult.totalAmount = totalAmount(result); result.totalVolumeCredits = totalVolumeCredits(result); return result;\n\nfunction enrichPerformance(aPerformance) {...} function playFor(aPerformance) {...} function amountFor(aPerformance) {...} function volumeCreditsFor(aPerformance) {...} function totalAmount(data) {...} function totalVolumeCredits(data) {...}\n\nOne final swing of compile­test­commit—and now it’s easy to write an HTML version.\n\nstatement.js…\n\nClick here to view code image\n\nfunction htmlStatement (invoice, plays) { return renderHtml(createStatementData(invoice, plays)); } function renderHtml (data) { let result = `<h1>Statement for ${data.customer}</h1>\\n`; result += \"<table>\\n\"; result += \"<tr><th>play</th><th>seats</th><th>cost</th></tr>\"; for (let perf of data.performances) { result += ` <tr><td>${perf.play.name}</td><td>${perf.audience}</td>`; result += `<td>${usd(perf.amount)}</td></tr>\\n`; } result += \"</table>\\n\"; result += `<p>Amount owed is <em>${usd(data.totalAmount)}</em></p>\\n`; result += `<p>You earned <em>${data.totalVolumeCredits}</em> credits</p>\\n`; return result; }\n\nfunction usd(aNumber) {...}\n\n(I moved usd to the top level, so that renderHtml could use it.)\n\nSTATUS: SEPARATED INTO TWO FILES (AND PHASES)\n\nThis is a good moment to take stock again and think about where the code is now. I\n\nhave two files of code.\n\nstatement.js\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nimport createStatementData from './createStatementData.js'; function statement (invoice, plays) { return renderPlainText(createStatementData(invoice, plays)); } function renderPlainText(data, plays) { let result = `Statement for ${data.customer}\\n`; for (let perf of data.performances) { result += ` ${perf.play.name}: ${usd(perf.amount)} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(data.totalAmount)}\\n`; result += `You earned ${data.totalVolumeCredits} credits\\n`; return result; } function htmlStatement (invoice, plays) { return renderHtml(createStatementData(invoice, plays)); } function renderHtml (data) { let result = `<h1>Statement for ${data.customer}</h1>\\n`; result += \"<table>\\n\"; result += \"<tr><th>play</th><th>seats</th><th>cost</th></tr>\"; for (let perf of data.performances) { result += ` <tr><td>${perf.play.name}</td><td>${perf.audience}</td>`; result += `<td>${usd(perf.amount)}</td></tr>\\n`; } result += \"</table>\\n\"; result += `<p>Amount owed is <em>${usd(data.totalAmount)}</em></p>\\n`; result += `<p>You earned <em>${data.totalVolumeCredits}</em> credits</p>\\n`; return result; } function usd(aNumber) { return new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format(aNumber/100); }\n\ncreateStatementData.js\n\nClick here to view code image\n\nexport default function createStatementData(invoice, plays) { const result = {}; result.customer = invoice.customer; result.performances = invoice.performances.map(enrichPerformance); result.totalAmount = totalAmount(result); result.totalVolumeCredits = totalVolumeCredits(result); return result;\n\nfunction enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); result.play = playFor(result);\n\nwww.EBooksWorld.ir\n\nresult.amount = amountFor(result); result.volumeCredits = volumeCreditsFor(result); return result; } function playFor(aPerformance) { return plays[aPerformance.playID] } function amountFor(aPerformance) { let result = 0; switch (aPerformance.play.type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${aPerformance.play.type}`); } return result; } function volumeCreditsFor(aPerformance) { let result = 0; result += Math.max(aPerformance.audience ­ 30, 0); if (\"comedy\" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5); return result; } function totalAmount(data) { return data.performances .reduce((total, p) => total + p.amount, 0); } function totalVolumeCredits(data) { return data.performances .reduce((total, p) => total + p.volumeCredits, 0); }\n\nI have more code than I did when I started: 70 lines (not counting htmlStatement) as\n\nopposed to 44, mostly due to the extra wrapping involved in putting things in functions.\n\nIf all else is equal, more code is bad—but rarely is all else equal. The extra code breaks\n\nup the logic into identifiable parts, separating the calculations of the statements from\n\nthe layout. This modularity makes it easier for me to understand the parts of the code\n\nand how they fit together. Brevity is the soul of wit, but clarity is the soul of evolvable\n\nwww.EBooksWorld.ir",
      "page_number": 20
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 43-51)",
      "start_page": 43,
      "end_page": 51,
      "detection_method": "topic_boundary",
      "content": "software. Adding this modularity allows to me to support the HTML version of the code\n\nwithout any duplication of the calculations.\n\nWhen programming, follow the camping rule: Always leave the code base\n\nhealthier than when you found it.\n\nThere are more things I could do to simplify the printing logic, but this will do for the\n\nmoment. I always have to strike a balance between all the refactorings I could do and\n\nadding new features. At the moment, most people under­prioritize refactoring—but\n\nthere still is a balance. My rule is a variation on the camping rule: Always leave the code\n\nbase healthier than when you found it. It will never be perfect, but it should be better.\n\nREORGANIZING THE CALCULATIONS BY TYPE\n\nNow I’ll turn my attention to the next feature change: supporting more categories of\n\nplays, each with its own charging and volume credits calculations. At the moment, to\n\nmake changes here I have to go into the calculation functions and edit the conditions in\n\nthere. The amountFor function highlights the central role the type of play has in the\n\nchoice of calculations—but conditional logic like this tends to decay as further\n\nmodifications are made unless it’s reinforced by more structural elements of the\n\nprogramming language.\n\nThere are various ways to introduce structure to make this explicit, but in this case a\n\nnatural approach is type polymorphism—a prominent feature of classical object­\n\norientation. Classical OO has long been a controversial feature in the JavaScript world,\n\nbut the ECMAScript 2015 version provides a sound syntax and structure for it. So it\n\nmakes sense to use it in a right situation—like this one.\n\nMy overall plan is to set up an inheritance hierarchy with comedy and tragedy\n\nsubclasses that contain the calculation logic for those cases. Callers call a polymorphic\n\namount function that the language will dispatch to the different calculations for the\n\ncomedies and tragedies. I’ll make a similar structure for the volume credits calculation.\n\nTo do this, I utilize a couple of refactorings. The core refactoring is Replace Conditional\n\nwith Polymorphism (272), which changes a hunk of conditional code with\n\npolymorphism. But before I can do Replace Conditional with Polymorphism (272), I\n\nneed to create an inheritance structure of some kind. I need to create a class to host the\n\namount and volume credit functions.\n\nI begin by reviewing the calculation code. (One of the pleasant consequences of the\n\nwww.EBooksWorld.ir\n\nprevious refactoring is that I can now ignore the formatting code, so long as I produce\n\nthe same output data structure. I can further support this by adding tests that probe the\n\nintermediate data structure.)\n\ncreateStatementData.js…\n\nClick here to view code image\n\nexport default function createStatementData(invoice, plays) { const result = {}; result.customer = invoice.customer; result.performances = invoice.performances.map(enrichPerformance); result.totalAmount = totalAmount(result); result.totalVolumeCredits = totalVolumeCredits(result); return result;\n\nfunction enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); result.play = playFor(result); result.amount = amountFor(result); result.volumeCredits = volumeCreditsFor(result); return result; } function playFor(aPerformance) { return plays[aPerformance.playID] } function amountFor(aPerformance) { let result = 0; switch (aPerformance.play.type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${aPerformance.play.type}`); } return result; } function volumeCreditsFor(aPerformance) { let result = 0; result += Math.max(aPerformance.audience ­ 30, 0); if (\"comedy\" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);\n\nwww.EBooksWorld.ir\n\nreturn result; } function totalAmount(data) { return data.performances .reduce((total, p) => total + p.amount, 0); } function totalVolumeCredits(data) { return data.performances .reduce((total, p) => total + p.volumeCredits, 0); }\n\nCreating a Performance Calculator\n\nThe enrichPerformance function is the key, since it populates the intermediate data\n\nstructure with the data for each performance. Currently, it calls the conditional\n\nfunctions for amount and volume credits. What I need it to do is call those functions on\n\na host class. Since that class hosts functions for calculating data about performances,\n\nI’ll call it a performance calculator.\n\nfunction createStatementData…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const calculator = new PerformanceCalculator(aPerformance); const result = Object.assign({}, aPerformance); result.play = playFor(result); result.amount = amountFor(result); result.volumeCredits = volumeCreditsFor(result); return result; }\n\ntop level…\n\nClick here to view code image\n\nclass PerformanceCalculator { constructor(aPerformance) { this.performance = aPerformance; } }\n\nSo far, this new object isn’t doing anything. I want to move behavior into it—and I’d like\n\nto start with the simplest thing to move, which is the play record. Strictly, I don’t need\n\nwww.EBooksWorld.ir\n\nto do this, as it’s not varying polymorphically, but this way I’ll keep all the data\n\ntransforms in one place, and that consistency will make the code clearer.\n\nTo make this work, I will use Change Function Declaration (124) to pass the\n\nperformance’s play into the calculator.\n\nfunction createStatementData…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance) const result = Object.assign({}, aPerformance); result.play = calculator.play; result.amount = amountFor(result); result.volumeCredits = volumeCreditsFor(result); return result; }\n\nclass PerformanceCalculator…\n\nClick here to view code image\n\nclass PerformanceCalculator { constructor(aPerformance, aPlay) { this.performance = aPerformance; this.play = aPlay; } }\n\n(I’m not saying compile­test­commit all the time any more, as I suspect you’re getting\n\ntired of reading it. But I still do it at every opportunity. I do sometimes get tired of\n\ndoing it—and give mistakes the chance to bite me. Then I learn and get back into the\n\nrhythm.)\n\nMoving Functions into the Calculator\n\nThe next bit of logic I move is rather more substantial for calculating the amount for a\n\nperformance. I’ve moved functions around casually while rearranging nested functions\n\n—but this is a deeper change in the context of the function, so I’ll step through the Move\n\nFunction (198) refactoring. The first part of this refactoring is to copy the logic over to\n\nits new context—the calculator class. Then, I adjust the code to fit into its new home,\n\nwww.EBooksWorld.ir\n\nchanging aPerformance to this.performance and playFor(aPerformance) to\n\nthis.play.\n\nclass PerformanceCalculator…\n\nClick here to view code image\n\nget amount() { let result = 0; switch (this.play.type) { case \"tragedy\": result = 40000; if (this.performance.audience > 30) { result += 1000 * (this.performance.audience ­ 30); } break; case \"comedy\": result = 30000; if (this.performance.audience > 20) { result += 10000 + 500 * (this.performance.audience ­ 20); } result += 300 * this.performance.audience; break; default: throw new Error(`unknown type: ${this.play.type}`); } return result; }\n\nI can compile at this point to check for any compile­time errors. “Compiling” in my\n\ndevelopment environment occurs as I execute the code, so what I actually do is run\n\nBabel [babel]. That will be enough to catch any syntax errors in the new function—but\n\nlittle more than that. Even so, that can be a useful step.\n\nOnce the new function fits its home, I take the original function and turn it into a\n\ndelegating function so it calls the new function.\n\nfunction createStatementData…\n\nClick here to view code image\n\nfunction amountFor(aPerformance) { return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount; }\n\nwww.EBooksWorld.ir\n\nNow I can compile­test­commit to ensure the code is working properly in its new home.\n\nWith that done, I use Inline Function (115) to call the new function directly (compile­\n\ntest­commit).\n\nfunction createStatementData…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance)); const result = Object.assign({}, aPerformance); result.play = calculator.play; result.amount = calculator.amount; result.volumeCredits = volumeCreditsFor(result); return result; }\n\nI repeat the same process to move the volume credits calculation.\n\nfunction createStatementData…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance)); const result = Object.assign({}, aPerformance); result.play = calculator.play; result.amount = calculator.amount; result.volumeCredits = calculator.volumeCredits; return result; }\n\nclass PerformanceCalculator…\n\nClick here to view code image\n\nget volumeCredits() { let result = 0; result += Math.max(this.performance.audience ­ 30, 0); if (\"comedy\" === this.play.type) result += Math.floor(this.performance.audience / 5); return result; }\n\nwww.EBooksWorld.ir\n\nMaking the Performance Calculator Polymorphic\n\nMaking the Performance Calculator Polymorphic\n\nNow that I have the logic in a class, it’s time to apply the polymorphism. The first step is\n\nto use Replace Type Code with Subclasses (362) to introduce subclasses instead of the\n\ntype code. For this, I need to create subclasses of the performance calculator and use\n\nthe appropriate subclass in createPerformanceData. In order to get the right\n\nsubclass, I need to replace the constructor call with a function, since JavaScript\n\nconstructors can’t return subclasses. So I use Replace Constructor with Factory\n\nFunction (334).\n\nfunction createStatementData…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const calculator = createPerformanceCalculator(aPerformance, playFor(aPerformance)); const result = Object.assign({}, aPerformance); result.play = calculator.play; result.amount = calculator.amount; result.volumeCredits = calculator.volumeCredits; return result; }\n\ntop level…\n\nClick here to view code image\n\nfunction createPerformanceCalculator(aPerformance, aPlay) { return new PerformanceCalculator(aPerformance, aPlay); }\n\nWith that now a function, I can create subclasses of the performance calculator and get\n\nthe creation function to select which one to return.\n\ntop level…\n\nClick here to view code image\n\nfunction createPerformanceCalculator(aPerformance, aPlay) { switch(aPlay.type) { case \"tragedy\": return new TragedyCalculator(aPerformance, aPlay); case \"comedy\" : return new ComedyCalculator(aPerformance, aPlay); default:\n\nwww.EBooksWorld.ir\n\nthrow new Error(`unknown type: ${aPlay.type}`); } }\n\nclass TragedyCalculator extends PerformanceCalculator { } class ComedyCalculator extends PerformanceCalculator { }\n\nThis sets up the structure for the polymorphism, so I can now move on to Replace\n\nConditional with Polymorphism (272).\n\nI start with the calculation of the amount for tragedies.\n\nclass TragedyCalculator…\n\nClick here to view code image\n\nget amount() { let result = 40000; if (this.performance.audience > 30) { result += 1000 * (this.performance.audience ­ 30); } return result; }\n\nJust having this method in the subclass is enough to override the superclass\n\nconditional. But if you’re as paranoid as I am, you might do this:\n\nclass PerformanceCalculator…\n\nClick here to view code image\n\nget amount() { let result = 0; switch (this.play.type) { case \"tragedy\": throw 'bad thing'; case \"comedy\": result = 30000; if (this.performance.audience > 20) { result += 10000 + 500 * (this.performance.audience ­ 20); } result += 300 * this.performance.audience; break; default: throw new Error(`unknown type: ${this.play.type}`);\n\nwww.EBooksWorld.ir\n\n} return result; }\n\nI could have removed the case for tragedy and let the default branch throw an error. But\n\nI like the explicit throw—and it will only be there for a couple more minutes (which is\n\nwhy I threw a string, not a better error object).\n\nAfter a compile­test­commit of that, I move the comedy case down too.\n\nclass ComedyCalculator…\n\nClick here to view code image\n\nget amount() { let result = 30000; if (this.performance.audience > 20) { result += 10000 + 500 * (this.performance.audience ­ 20); } result += 300 * this.performance.audience; return result; }\n\nI can now remove the superclass amount method, as it should never be called. But it’s\n\nkinder to my future self to leave a tombstone.\n\nclass PerformanceCalculator…\n\nClick here to view code image\n\nget amount() { throw new Error('subclass responsibility'); }\n\nThe next conditional to replace is the volume credits calculation. Looking at the\n\ndiscussion of future categories of plays, I notice that most plays expect to check if\n\naudience is above 30, with only some categories introducing a variation. So it makes\n\nsense to leave the more common case on the superclass as a default, and let the\n\nvariations override it as necessary. So I just push down the case for comedies:\n\nclass PerformanceCalculator…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "page_number": 43
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 52-59)",
      "start_page": 52,
      "end_page": 59,
      "detection_method": "topic_boundary",
      "content": "get volumeCredits() { return Math.max(this.performance.audience ­ 30, 0); }\n\nclass ComedyCalculator…\n\nClick here to view code image\n\nget volumeCredits() { return super.volumeCredits + Math.floor(this.performance.audience / 5); }\n\nSTATUS: CREATING THE DATA WITH THE POLYMORPHIC CALCULATOR\n\nTime to reflect on what introducing the polymorphic calculator did to the code.\n\ncreateStatementData.js\n\nClick here to view code image\n\nexport default function createStatementData(invoice, plays) { const result = {}; result.customer = invoice.customer; result.performances = invoice.performances.map(enrichPerformance); result.totalAmount = totalAmount(result); result.totalVolumeCredits = totalVolumeCredits(result); return result;\n\nfunction enrichPerformance(aPerformance) { const calculator = createPerformanceCalculator(aPerformance, playFor(aPerformance)); const result = Object.assign({}, aPerformance); result.play = calculator.play; result.amount = calculator.amount; result.volumeCredits = calculator.volumeCredits; return result; } function playFor(aPerformance) { return plays[aPerformance.playID] } function totalAmount(data) { return data.performances .reduce((total, p) => total + p.amount, 0); } function totalVolumeCredits(data) { return data.performances\n\nwww.EBooksWorld.ir\n\n.reduce((total, p) => total + p.volumeCredits, 0); } }\n\nfunction createPerformanceCalculator(aPerformance, aPlay) { switch(aPlay.type) { case \"tragedy\": return new TragedyCalculator(aPerformance, aPlay); case \"comedy\" : return new ComedyCalculator(aPerformance, aPlay); default: throw new Error(`unknown type: ${aPlay.type}`); } } class PerformanceCalculator { constructor(aPerformance, aPlay) { this.performance = aPerformance; this.play = aPlay; } get amount() { throw new Error('subclass responsibility');} get volumeCredits() { return Math.max(this.performance.audience ­ 30, 0); } } class TragedyCalculator extends PerformanceCalculator { get amount() { let result = 40000; if (this.performance.audience > 30) { result += 1000 * (this.performance.audience ­ 30); } return result; } } class ComedyCalculator extends PerformanceCalculator { get amount() { let result = 30000; if (this.performance.audience > 20) { result += 10000 + 500 * (this.performance.audience ­ 20); } result += 300 * this.performance.audience; return result; } get volumeCredits() { return super.volumeCredits + Math.floor(this.performance.audience / 5); } }\n\nAgain, the code has increased in size as I’ve introduced structure. The benefit here is\n\nthat the calculations for each kind of play are grouped together. If most of the changes\n\nwill be to this code, it will be helpful to have it clearly separated like this. Adding a new\n\nkind of play requires writing a new subclass and adding it to the creation function.\n\nwww.EBooksWorld.ir\n\nThe example gives some insight as to when using subclasses like this is useful. Here,\n\nI’ve moved the conditional lookup from two functions (amountFor and\n\nvolumeCreditsFor) to a single constructor function\n\ncreatePerformanceCalculator. The more functions there are that depend on the\n\nsame type of polymorphism, the more useful this approach becomes.\n\nAn alternative to what I’ve done here would be to have createPerformanceData\n\nreturn the calculator itself, instead of the calculator populating the intermediate data\n\nstructure. One of the nice features of JavaScript’s class system is that with it, using\n\ngetters looks like regular data access. My choice on whether to return the instance or\n\ncalculate separate output data depends on who is using the downstream data structure.\n\nIn this case, I preferred to show how to use the intermediate data structure to hide the\n\ndecision to use a polymorphic calculator.\n\nFINAL THOUGHTS\n\nThis is a simple example, but I hope it will give you a feeling for what refactoring is like.\n\nI’ve used several refactorings, including Extract Function (106), Inline Variable (123),\n\nMove Function (198), and Replace Conditional with Polymorphism (272).\n\nThere were three major stages to this refactoring episode: decomposing the original\n\nfunction into a set of nested functions, using Split Phase (154) to separate the\n\ncalculation and printing code, and finally introducing a polymorphic calculator for the\n\ncalculation logic. Each of these added structure to the code, enabling me to better\n\ncommunicate what the code was doing.\n\nAs is often the case with refactoring, the early stages were mostly driven by trying to\n\nunderstand what was going on. A common sequence is: Read the code, gain some\n\ninsight, and use refactoring to move that insight from your head back into the code. The\n\nclearer code then makes it easier to understand it, leading to deeper insights and a\n\nbeneficial positive feedback loop. There are still some improvements I could make, but\n\nI feel I’ve done enough to pass my test of leaving the code significantly better than how\n\nI found it.\n\nThe true test of good code is how easy it is to change it.\n\nI’m talking about improving the code—but programmers love to argue about what good\n\ncode looks like. I know some people object to my preference for small, well­named\n\nfunctions. If we consider this to be a matter of aesthetics, where nothing is either good\n\nwww.EBooksWorld.ir\n\nor bad but thinking makes it so, we lack any guide but personal taste. I believe,\n\nhowever, that we can go beyond taste and say that the true test of good code is how easy\n\nit is to change it. Code should be obvious: When someone needs to make a change, they\n\nshould be able to find the code to be changed easily and to make the change quickly\n\nwithout introducing any errors. A healthy code base maximizes our productivity,\n\nallowing us to build more features for our users both faster and more cheaply. To keep\n\ncode healthy, pay attention to what is getting between the programming team and that\n\nideal, then refactor to get closer to the ideal.\n\nBut the most important thing to learn from this example is the rhythm of refactoring.\n\nWhenever I’ve shown people how I refactor, they are surprised by how small my steps\n\nare, each step leaving the code in a working state that compiles and passes its tests. I\n\nwas just as surprised myself when Kent Beck showed me how to do this in a hotel room\n\nin Detroit two decades ago. The key to effective refactoring is recognizing that you go\n\nfaster when you take tiny steps, the code is never broken, and you can compose those\n\nsmall steps into substantial changes. Remember that—and the rest is silence.\n\nwww.EBooksWorld.ir\n\nChapter 2 Principles in Refactoring\n\nHistory\n\nTopics\n\nThe example in the previous chapter should have given you a decent feel of what\n\nrefactoring is. Now you have that, it’s a good time to step back and talk about some of\n\nTutorials\n\nthe broader principles in refactoring.\n\nOffers & Deals\n\nDEFINING REFACTORING\n\nHighlights\n\nLike many terms in software development, “refactoring” is often used very loosely by\n\npractitioners. I use the term more precisely, and find it useful to use it in that more\n\nSettings\n\nprecise form. (These definitions are the same as those I gave in the first edition of this\n\nbook.) The term “refactoring” can be used either as a noun or a verb. The noun’s\n\nSupport\n\ndefinition is:\n\nSign Out\n\nRefactoring (noun): a change made to the internal structure of software to make it\n\neasier to understand and cheaper to modify without changing its observable behavior.\n\nThis definition corresponds to the named refactorings I’ve mentioned in the earlier\n\nexamples, such as Extract Function (106) and Replace Conditional with Polymorphism\n\n(272).\n\nThe verb’s definition is:\n\nRefactoring (verb): to restructure software by applying a series of refactorings\n\nwithout changing its observable behavior.\n\nSo I might spend a couple of hours refactoring, during which I would apply a few dozen\n\nindividual refactorings.\n\nOver the years, many people in the industry have taken to use “refactoring” to mean any\n\nkind of code cleanup—but the definitions above point to a particular approach to\n\ncleaning up code. Refactoring is all about applying small behavior­preserving steps and\n\nmaking a big change by stringing together a sequence of these behavior­preserving\n\nwww.EBooksWorld.ir\n\nsteps. Each individual refactoring is either pretty small itself or a combination of small\n\nsteps. As a result, when I’m refactoring, my code doesn’t spend much time in a broken\n\nstate, allowing me to stop at any moment even if I haven’t finished.\n\nIf someone says their code was broken for a couple of days while they are\n\nrefactoring, you can be pretty sure they were not refactoring.\n\nI use “restructuring” as a general term to mean any kind of reorganizing or cleaning up\n\nof a code base, and see refactoring as a particular kind of restructuring. Refactoring\n\nmay seem inefficient to people who first come across it and watch me making lots of\n\ntiny steps, when a single bigger step would do. But the tiny steps allow me to go faster\n\nbecause they compose so well—and, crucially, because I don’t spend any time\n\ndebugging.\n\nIn my definitions, I use the phrase “observable behavior.” This is a deliberately loose\n\nterm, indicating that the code should, overall, do just the same things it did before I\n\nstarted. It doesn’t mean it will work exactly the same—for example, Extract Function\n\n(106) will alter the call stack, so performance characteristics might change—but nothing\n\nshould change that the user should care about. In particular, interfaces to modules\n\noften change due to such refactorings as Change Function Declaration (124) and Move\n\nFunction (198). Any bugs that I notice during refactoring should still be present after\n\nrefactoring (though I can fix latent bugs that nobody has observed yet).\n\nRefactoring is very similar to performance optimization, as both involve carrying out\n\ncode manipulations that don’t change the overall functionality of the program. The\n\ndifference is the purpose: Refactoring is always done to make the code “easier to\n\nunderstand and cheaper to modify.” This might speed things up or slow things down.\n\nWith performance optimization, I only care about speeding up the program, and am\n\nprepared to end up with code that is harder to work with if I really need that improved\n\nperformance.\n\nTHE TWO HATS\n\nKent Beck came up with a metaphor of the two hats. When I use refactoring to develop\n\nsoftware, I divide my time between two distinct activities: adding functionality and\n\nrefactoring. When I add functionality, I shouldn’t be changing existing code; I’m just\n\nadding new capabilities. I measure my progress by adding tests and getting the tests to\n\nwork. When I refactor, I make a point of not adding functionality; I only restructure the\n\ncode. I don’t add any tests (unless I find a case I missed earlier); I only change tests www.EBooksWorld.ir\n\nwhen I have to accommodate a change in an interface.\n\nAs I develop software, I find myself swapping hats frequently. I start by trying to add a\n\nnew capability, then I realize this would be much easier if the code were structured\n\ndifferently. So I swap hats and refactor for a while. Once the code is better structured, I\n\nswap hats back and add the new capability. Once I get the new capability working, I\n\nrealize I coded it in a way that’s awkward to understand, so I swap hats again and\n\nrefactor. All this might take only ten minutes, but during this time I’m always aware of\n\nwhich hat I’m wearing and the subtle difference that makes to how I program.\n\nWHY SHOULD WE REFACTOR?\n\nI don’t want to claim refactoring is the cure for all software ills. It is no “silver bullet.”\n\nYet it is a valuable tool—a pair of silver pliers that helps you keep a good grip on your\n\ncode. Refactoring is a tool that can—and should—be used for several purposes.\n\nRefactoring Improves the Design of Software\n\nWithout refactoring, the internal design—the architecture—of software tends to decay.\n\nAs people change code to achieve short­term goals, often without a full comprehension\n\nof the architecture, the code loses its structure. It becomes harder for me to see the\n\ndesign by reading the code. Loss of the structure of code has a cumulative effect. The\n\nharder it is to see the design in the code, the harder it is for me to preserve it, and the\n\nmore rapidly it decays. Regular refactoring helps keep the code in shape.\n\nPoorly designed code usually takes more code to do the same things, often because the\n\ncode quite literally does the same thing in several places. Thus an important aspect of\n\nimproving design is to eliminate duplicated code. It’s not that reducing the amount of\n\ncode will make the system run any faster—the effect on the footprint of the programs\n\nrarely is significant. Reducing the amount of code does, however, make a big difference\n\nin modification of the code. The more code there is, the harder it is to modify correctly.\n\nThere’s more code for me to understand. I change this bit of code here, but the system\n\ndoesn’t do what I expect because I didn’t change that bit over there that does much the\n\nsame thing in a slightly different context. By eliminating duplication, I ensure that the\n\ncode says everything once and only once, which is the essence of good design.\n\nRefactoring Makes Software Easier to Understand\n\nProgramming is in many ways a conversation with a computer. I write code that tells\n\nthe computer what to do, and it responds by doing exactly what I tell it. In time, I close\n\nthe gap between what I want it to do and what I tell it to do. Programming is all about\n\nwww.EBooksWorld.ir\n\nsaying exactly what I want. But there are likely to be other users of my source code. In a\n\nfew months, a human will try to read my code to make some changes. That user, who\n\nwe often forget, is actually the most important. Who cares if the computer takes a few\n\nmore cycles to compile something? Yet it does matter if it takes a programmer a week to\n\nmake a change that would have taken only an hour with proper understanding of my\n\ncode.\n\nThe trouble is that when I’m trying to get the program to work, I’m not thinking about\n\nthat future developer. It takes a change of rhythm to make the code easier to\n\nunderstand. Refactoring helps me make my code more readable. Before refactoring, I\n\nhave code that works but is not ideally structured. A little time spent on refactoring can\n\nmake the code better communicate its purpose—say more clearly what I want.\n\nI’m not necessarily being altruistic about this. Often, this future developer is myself.\n\nThis makes refactoring even more important. I’m a very lazy programmer. One of my\n\nforms of laziness is that I never remember things about the code I write. Indeed, I\n\ndeliberately try not remember anything I can look up, because I’m afraid my brain will\n\nget full. I make a point of trying to put everything I should remember into the code so I\n\ndon’t have to remember it. That way I’m less worried about Maudite [maudite] killing\n\noff my brain cells.\n\nRefactoring Helps Me Find Bugs\n\nHelp in understanding the code also means help in spotting bugs. I admit I’m not\n\nterribly good at finding bugs. Some people can read a lump of code and see bugs; I\n\ncannot. However, I find that if I refactor code, I work deeply on understanding what the\n\ncode does, and I put that new understanding right back into the code. By clarifying the\n\nstructure of the program, I clarify certain assumptions I’ve made—to a point where\n\neven I can’t avoid spotting the bugs.\n\nIt reminds me of a statement Kent Beck often makes about himself: “I’m not a great\n\nprogrammer; I’m just a good programmer with great habits.” Refactoring helps me be\n\nmuch more effective at writing robust code.\n\nRefactoring Helps Me Program Faster\n\nIn the end, all the earlier points come down to this: Refactoring helps me develop code\n\nmore quickly.\n\nThis sounds counterintuitive. When I talk about refactoring, people can easily see that\n\nit improves quality. Better internal design, readability, reducing bugs—all these\n\nwww.EBooksWorld.ir",
      "page_number": 52
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 60-68)",
      "start_page": 60,
      "end_page": 68,
      "detection_method": "topic_boundary",
      "content": "improve quality. But doesn’t the time I spend on refactoring reduce the speed of\n\ndevelopment?\n\nWhen I talk to software developers who have been working on a system for a while, I\n\noften hear that they were able to make progress rapidly at first, but now it takes much\n\nlonger to add new features. Every new feature requires more and more time to\n\nunderstand how to fit it into the existing code base, and once it’s added, bugs often crop\n\nup that take even longer to fix. The code base starts looking like a series of patches\n\ncovering patches, and it takes an exercise in archaeology to figure out how things work.\n\nThis burden slows down adding new features—to the point that developers wish they\n\ncould start again from a blank slate.\n\nI can visualize this state of affairs with the following pseudograph:\n\nBut some teams report a different experience. They find they can add new features\n\nfaster because they can leverage the existing things by quickly building on what’s\n\nalready there.\n\nwww.EBooksWorld.ir\n\nThe difference between these two is the internal quality of the software. Software with a\n\ngood internal design allows me to easily find how and where I need to make changes to\n\nadd a new feature. Good modularity allows me to only have to understand a small\n\nsubset of the code base to make a change. If the code is clear, I’m less likely to introduce\n\na bug, and if I do, the debugging effort is much easier. Done well, my code base turns\n\ninto a platform for building new features for its domain.\n\nI refer to this effect as the Design Stamina Hypothesis [mf­dsh]: By putting our effort\n\ninto a good internal design, we increase the stamina of the software effort, allowing us\n\nto go faster for longer. I can’t prove that this is the case, which is why I refer to it as a\n\nhypothesis. But it explains my experience, together with the experience of hundreds of\n\ngreat programmers that I’ve got to know over my career.\n\nTwenty years ago, the conventional wisdom was that to get this kind of good design, it\n\nhad to be completed before starting to program—because once we wrote the code, we\n\ncould only face decay. Refactoring changes this picture. We now know we can improve\n\nthe design of existing code—so we can form and improve a design over time, even as the\n\nneeds of the program change. Since it is very difficult to do a good design up front,\n\nrefactoring becomes vital to achieving that virtuous path of rapid functionality.\n\nWHEN SHOULD WE REFACTOR?\n\nRefactoring is something I do every hour I program. I have noticed a number of ways it\n\nfits into my workflow.\n\nwww.EBooksWorld.ir\n\nThe Rule of Three\n\nHere’s a guideline Don Roberts gave me: The first time you do something,\n\nyou just do it. The second time you do something similar, you wince at the\n\nduplication, but you do the duplicate thing anyway. The third time you do\n\nsomething similar, you refactor.\n\nOr for those who like baseball: Three strikes, then you refactor.\n\nPreparatory Refactoring—Making It Easier to Add a Feature\n\nThe best time to refactor is just before I need to add a new feature to the code base. As I\n\ndo this, I look at the existing code and, often, see that if it were structured a little\n\ndifferently, my work would be much easier. Perhaps there’s function that does almost\n\nall that I need, but has some literal values that conflict with my needs. Without\n\nrefactoring I might copy the function and change those values. But that leads to\n\nduplicated code—if I need to change it in the future, I’ll have to change both spots (and,\n\nworse, find them). And copy­paste won’t help me if I need to make a similar variation\n\nfor a new feature in the future. So with my refactoring hat on, I use Parameterize\n\nFunction (310). Once I’ve done that, all I have to do is call the function with the\n\nparameters I need.\n\n“It’s like I want to go 100 miles east but instead of just traipsing through the woods,\n\nI’m going to drive 20 miles north to the highway and then I’m going to go 100 miles\n\neast at three times the speed I could have if I just went straight there. When people are\n\npushing you to just go straight there, sometimes you need to say, ‘Wait, I need to\n\ncheck the map and find the quickest route.’ The preparatory refactoring does that for\n\nme.”\n\n— Jessica Kerr,\n\nhttps://martinfowler.com/articles/preparatory­refactoring­\n\nexample.html\n\nThe same happens when fixing a bug. Once I’ve found the cause of the problem, I see\n\nthat it would be much easier to fix should I unify the three bits of copied code causing\n\nthe error into one. Or perhaps separating some update logic from queries will make it\n\neasier to avoid the tangling that’s causing the error. By refactoring to improve the\n\nsituation, I also increase the chances that the bug will stay fixed, and reduce the\n\nchances that others will appear in the same crevices of the code.\n\nwww.EBooksWorld.ir Comprehension Refactoring: Making Code Easier to Understand\n\nComprehension Refactoring: Making Code Easier to Understand\n\nBefore I can change some code, I need to understand what it does. This code may have\n\nbeen written by me or by someone else. Whenever I have to think to understand what\n\nthe code is doing, I ask myself if I can refactor the code to make that understanding\n\nmore immediately apparent. I may be looking at some conditional logic that’s\n\nstructured awkwardly. I may have wanted to use some existing functions but spent\n\nseveral minutes figuring out what they did because they were named badly.\n\nAt that point I have some understanding in my head, but my head isn’t a very good\n\nrecord of such details. As Ward Cunningham puts it, by refactoring I move the\n\nunderstanding from my head into the code itself. I then test that understanding by\n\nrunning the software to see if it still works. If I move my understanding into the code, it\n\nwill be preserved longer and be visible to my colleagues.\n\nThat doesn’t just help me in the future—it often helps me right now. Early on, I do\n\ncomprehension refactoring on little details. I rename a couple variables now that I\n\nunderstand what they are, or I chop a long function into smaller parts. Then, as the\n\ncode gets clearer, I find I can see things about the design that I could not see before.\n\nHad I not changed the code, I probably never would have seen these things, because I’m\n\njust not clever enough to visualize all these changes in my head. Ralph Johnson\n\ndescribes these early refactorings as wiping the dirt off a window so you can see\n\nbeyond. When I’m studying code, refactoring leads me to higher levels of\n\nunderstanding that I would otherwise miss. Those who dismiss comprehension\n\nrefactoring as useless fiddling with the code don’t realize that by foregoing it they never\n\nsee the opportunities hidden behind the confusion.\n\nLitter-Pickup Refactoring\n\nA variation of comprehension refactoring is when I understand what the code is doing,\n\nbut realize that it’s doing it badly. The logic is unnecessarily convoluted, or I see\n\nfunctions that are nearly identical and can be replaced by a single parameterized\n\nfunction. There’s a bit of a tradeoff here. I don’t want to spend a lot of time distracted\n\nfrom the task I’m currently doing, but I also don’t want to leave the trash lying around\n\nand getting in the way of future changes. If it’s easy to change, I’ll do it right away. If it’s\n\na bit more effort to fix, I might make a note of it and fix it when I’m done with my\n\nimmediate task.\n\nSometimes, of course, it’s going to take a few hours to fix, and I have more urgent\n\nthings to do. Even then, however, it’s usually worthwhile to make it a little bit better. As\n\nthe old camping adage says, always leave the camp site cleaner than when you found it.\n\nwww.EBooksWorld.ir\n\nIf I make it a little better each time I pass through the code, over time it will get fixed.\n\nThe nice thing about refactoring is that I don’t break the code with each small step—so,\n\nsometimes, it takes months to complete the job but the code is never broken even when\n\nI’m part way through it.\n\nPlanned and Opportunistic Refactoring\n\nThe examples above—preparatory, comprehension, litter­pickup refactoring—are all\n\nopportunistic. I don’t set aside time at the beginning to spend on refactoring—instead, I\n\ndo refactoring as part of adding a feature or fixing a bug. It’s part of my natural flow of\n\nprogramming. Whether I’m adding a feature or fixing a bug, refactoring helps me do\n\nthe immediate task and also sets me up to make future work easier. This is an\n\nimportant point that’s frequently missed. Refactoring isn’t an activity that’s separated\n\nfrom programming—any more than you set aside time to write if statements. I don’t\n\nput time on my plans to do refactoring; most refactoring happens while I’m doing other\n\nthings.\n\nYou have to refactor when you run into ugly code—but excellent code needs\n\nplenty of refactoring too.\n\nIt’s also a common error to see refactoring as something people do to fix past mistakes\n\nor clean up ugly code. Certainly you have to refactor when you run into ugly code, but\n\nexcellent code needs plenty of refactoring too. Whenever I write code, I’m making\n\ntradeoffs—how much do I need to parameterize, where to draw the lines between\n\nfunctions? The tradeoffs I made correctly for yesterday’s feature set may no longer be\n\nthe right ones for the new features I’m adding today. The advantage is that clean code is\n\neasier to refactor when I need to change those tradeoffs to reflect the new reality.\n\n“for each desired change, make the change easy (warning: this may be hard), then\n\nmake the easy change”\n\n— Kent Beck,\n\nhttps://twitter.com/kentbeck/status/250733358307500032\n\nFor a long time, people thought of writing software as a process of accretion: To add\n\nnew features, we should be mostly adding new code. But good developers know that,\n\noften, the fastest way to add a new feature is to change the code to make it easy to add.\n\nSoftware should thus be never thought of as “done.” As new capabilities are needed, the\n\nsoftware changes to reflect that. Those changes can often be greater in the existing code\n\nwww.EBooksWorld.ir\n\nthan in the new code.\n\nAll this doesn’t mean that planned refactoring is always wrong. If a team has neglected\n\nrefactoring, it often needs dedicated time to get their code base into a better state for\n\nnew features, and a week spent refactoring now can repay itself over the next couple of\n\nmonths. Sometimes, even with regular refactoring I’ll see a problem area grow to the\n\npoint when it needs some concerted effort to fix. But such planned refactoring episodes\n\nshould be rare. Most refactoring effort should be the unremarkable, opportunistic kind.\n\nOne bit of advice I’ve heard is to separate refactoring work and new feature additions\n\ninto different version­control commits. The big advantage of this is that they can be\n\nreviewed and approved independently. I’m not convinced of this, however. Too often,\n\nthe refactorings are closely interwoven with adding new features, and it’s not worth the\n\ntime to separate them out. This can also remove the context for the refactoring, making\n\nthe refactoring commits hard to justify. Each team should experiment to find what\n\nworks for them; just remember that separating refactoring commits is not a self­evident\n\nprinciple—it’s only worthwhile if it makes life easier.\n\nLong-Term Refactoring\n\nMost refactoring can be completed within a few minutes—hours at most. But there are\n\nsome larger refactoring efforts that can take a team weeks to complete. Perhaps they\n\nneed to replace an existing library with a new one. Or pull some section of code out into\n\na component that they can share with another team. Or fix some nasty mess of\n\ndependencies that they had allowed to build up.\n\nEven in such cases, I’m reluctant to have a team do dedicated refactoring. Often, a\n\nuseful strategy is to agree to gradually work on the problem over the course of the next\n\nfew weeks. Whenever anyone goes near any code that’s in the refactoring zone, they\n\nmove it a little way in the direction they want to improve. This takes advantage of the\n\nfact that refactoring doesn’t break the code—each small change leaves everything in a\n\nstill­working state. To change from one library to another, start by introducing a new\n\nabstraction that can act as an interface to either library. Once the calling code uses this\n\nabstraction, it’s much easier to switch one library for another. (This tactic is called\n\nBranch By Abstraction [mf­bba].)\n\nRefactoring in a Code Review\n\nSome organizations do regular code reviews; those that don’t would do better if they\n\ndid. Code reviews help spread knowledge through a development team. Reviews help\n\nmore experienced developers pass knowledge to those less experienced. They help more\n\nwww.EBooksWorld.ir\n\npeople understand more aspects of a large software system. They are also very\n\nimportant in writing clear code. My code may look clear to me but not to my team.\n\nThat’s inevitable—it’s hard for people to put themselves in the shoes of someone\n\nunfamiliar with whatever they are working on. Reviews also give the opportunity for\n\nmore people to suggest useful ideas. I can only think of so many good ideas in a week.\n\nHaving other people contribute makes my life easier, so I always look for reviews.\n\nI’ve found that refactoring helps me review someone else’s code. Before I started using\n\nrefactoring, I could read the code, understand it to some degree, and make suggestions.\n\nNow, when I come up with ideas, I consider whether they can be easily implemented\n\nthen and there with refactoring. If so, I refactor. When I do it a few times, I can see\n\nmore clearly what the code looks like with the suggestions in place. I don’t have to\n\nimagine what it would be like—I can see it. As a result, I can come up with a second\n\nlevel of ideas that I would never have realized had I not refactored.\n\nRefactoring also helps get more concrete results from the code review. Not only are\n\nthere suggestions; many suggestions are implemented there and then. You end up with\n\nmuch more of a sense of accomplishment from the exercise.\n\nHow I’d embed refactoring into a code review depends on the nature of the review. The\n\ncommon pull request model, where a reviewer looks at code without the original\n\nauthor, doesn’t work too well. It’s better to have the original author of the code present\n\nbecause the author can provide context on the code and fully appreciate the reviewers’\n\nintentions for their changes. I’ve had my best experiences with this by sitting one­on­\n\none with the original author, going through the code and refactoring as we go. The\n\nlogical conclusion of this style is pair programming: continuous code review embedded\n\nwithin the process of programming.\n\nWhat Do I Tell My Manager?\n\nOne of the most common questions I’ve been asked is, “How to tell a manager about\n\nrefactoring?” I’ve certainly seen places were refactoring has become a dirty word—with\n\nmanagers (and customers) believing that refactoring is either correcting errors made\n\nearlier, or work that doesn’t yield valuable features. This is exacerbated by teams\n\nscheduling weeks of pure refactoring—especially if what they are really doing is not\n\nrefactoring but less careful restructuring that causes breakages in the code base.\n\nTo a manager who is genuinely savvy about technology and understands the design\n\nstamina hypothesis, refactoring isn’t hard to justify. Such managers should be\n\nencouraging refactoring on a regular basis and be looking for signs that indicate a team\n\nisn’t doing enough. While it does happen that teams do too much refactoring, it’s much\n\nwww.EBooksWorld.ir\n\nrarer than teams not doing enough.\n\nOf course, many managers and customer don’t have the technical awareness to know\n\nhow code base health impacts productivity. In these cases I give my more controversial\n\nadvice: Don’t tell!\n\nSubversive? I don’t think so. Software developers are professionals. Our job is to build\n\neffective software as rapidly as we can. My experience is that refactoring is a big aid to\n\nbuilding software quickly. If I need to add a new function and the design does not suit\n\nthe change, I find it’s quicker to refactor first and then add the function. If I need to fix\n\na bug, I need to understand how the software works—and I find refactoring is the\n\nfastest way to do this. A schedule­driven manager wants me to do things the fastest way\n\nI can; how I do it is my responsibility. I’m being paid for my expertise in programming\n\nnew capabilities fast, and the fastest way is by refactoring—therefore I refactor.\n\nWhen Should I Not Refactor?\n\nIt may sound like I always recommend refactoring—but there are cases when it’s not\n\nworthwhile.\n\nIf I run across code that is a mess, but I don’t need to modify it, then I don’t need to\n\nrefactor it. Some ugly code that I can treat as an API may remain ugly. It’s only when I\n\nneed to understand how it works that refactoring gives me any benefit.\n\nAnother case is when it’s easier to rewrite it than to refactor it. This is a tricky decision.\n\nOften, I can’t tell how easy it is to refactor some code unless I spend some time trying\n\nand thus get a sense of how difficult it is. The decision to refactor or rewrite requires\n\ngood judgment and experience, and I can’t really boil it down into a piece of simple\n\nadvice.\n\nPROBLEMS WITH REFACTORING\n\nWhenever anyone advocates for some technique, tool, or architecture, I always look for\n\nproblems. Few things in life are all sunshine and clear skies. You need to understand\n\nthe tradeoffs to decide when and where to apply something. I do think refactoring is a\n\nvaluable technique—one that should be used more by most teams. But there are\n\nproblems associated with it, and it’s important to understand how they manifest\n\nthemselves and how we can react to them.\n\nSlowing Down New Features\n\nwww.EBooksWorld.ir\n\nIf you read the previous section, you should already know my response. Although many\n\npeople see time spent refactoring as slowing down the development of new features, the\n\nwhole purpose of refactoring is to speed things up. But while this is true, it’s also true\n\nthat the perception of refactoring as slowing things down is still common—and perhaps\n\nthe biggest barrier to people doing enough refactoring.\n\nThe whole purpose of refactoring is to make us program faster, producing\n\nmore value with less effort.\n\nThere is a genuine tradeoff here. I do run into situations where I see a (large­scale)\n\nrefactoring that really needs to be done, but the new feature I want to add is so small\n\nthat I prefer to add it and leave the larger refactoring alone. That’s a judgment call—\n\npart of my professional skills as a programmer. I can’t easily describe, let alone\n\nquantify, how I make that tradeoff.\n\nI’m very conscious that preparatory refactoring often makes a change easier, so I\n\ncertainly will do it if I see that it makes my new feature easier to implement. I’m also\n\nmore inclined to refactor if this is a problem I’ve seen before—sometimes it takes me a\n\ncouple of times seeing some particular ugliness before I decide to refactor it away.\n\nConversely, I’m more likely to not refactor if it’s part of the code I rarely touch and the\n\ncost of the inconvenience isn’t something I feel very often. Sometimes, I delay a\n\nrefactoring because I’m not sure what improvement to do, although at other times I’ll\n\ntry something as an experiment to see if it makes things better.\n\nStill, the evidence I hear from my colleagues in the industry is that too little refactoring\n\nis far more prevalent than too much. In other words, most people should try to refactor\n\nmore often. You may have trouble telling the difference in productivity between a\n\nhealthy and a sickly code base because you haven’t had enough experience of a healthy\n\ncode base—of the power that comes from easily combining existing parts into new\n\nconfigurations to quickly enable complicated new features.\n\nAlthough it’s often managers that are criticized for the counter­productive habit of\n\nsquelching refactoring in the name of speed, I’ve often seen developers do it to\n\nthemselves. Sometimes, they think they shouldn’t be refactoring even though their\n\nleadership is actually in favor. If you’re a tech lead in a team, it’s important to show\n\nteam members that you value improving the health of a code base. That judgment I\n\nmentioned earlier on whether to refactor or not is something that takes years of\n\nexperience to build up. Those with less experience in refactoring need lots of mentoring\n\nto accelerate them through the process.\n\nwww.EBooksWorld.ir",
      "page_number": 60
    },
    {
      "number": 7,
      "title": "Segment 7 (pages 69-76)",
      "start_page": 69,
      "end_page": 76,
      "detection_method": "topic_boundary",
      "content": "But I think the most dangerous way that people get trapped is when they try to justify\n\nrefactoring in terms of “clean code,” “good engineering practice,” or similar moral\n\nreasons. The point of refactoring isn’t to show how sparkly a code base is—it is purely\n\neconomic. We refactor because it makes us faster—faster to add features, faster to fix\n\nbugs. It’s important to keep that in front of your mind and in front of communication\n\nwith others. The economic benefits of refactoring should always be the driving factor,\n\nand the more that is understood by developers, managers, and customers, the more of\n\nthe “good design” curve we’ll see.\n\nCode Ownership\n\nMany refactorings involve making changes that affect not just the internals of a module\n\nbut its relationships with other parts of a system. If I want to rename a function, and I\n\ncan find all the callers to a function, I simply apply Change Function Declaration (124)\n\nand change the declaration and the callers in one change. But sometimes this simple\n\nrefactoring isn’t possible. Perhaps the calling code is owned by a different team and I\n\ndon’t have write access to their repository. Perhaps the function is a declared API used\n\nby my customers—so I can’t even tell if it’s being used, let alone by who and how much.\n\nSuch functions are part of a published interface—an interface that is used by clients\n\nindependent of those who declare the interface.\n\nCode ownership boundaries get in the way of refactoring because I cannot make the\n\nkinds of changes I want without breaking my clients. This doesn’t prevent refactoring—\n\nI can still do a great deal—but it does impose limitations. When renaming a function, I\n\nneed to use Rename Function (124) and to retain the old declaration as a pass­through\n\nto the new one. This complicates the interface—but it is the price I must pay to avoid\n\nbreaking my clients. I may be able to mark the old interface as deprecated and, in time,\n\nretire it, but sometimes I have to retain that interface forever.\n\nDue to these complexities, I recommend against fine­grained strong code ownership.\n\nSome organizations like any piece of code to have a single programmer as an owner,\n\nand only allow that programmer to change it. I’ve seen a team of three people operate\n\nin such a way that each one published interfaces to the other two. This led to all sorts of\n\ngyrations to maintain interfaces when it would have been much easier to go into the\n\ncode base and make the edits. My preference is to allow team ownership of code—so\n\nthat anyone in the same team can modify the team’s code, even if originally written by\n\nsomeone else. Programmers may have individual responsibility for areas of a system,\n\nbut that should imply that they monitor changes to their area of responsibility, not\n\nblock them by default.\n\nwww.EBooksWorld.ir\n\nSuch a more permissive ownership scheme can even exist across teams. Some teams\n\nencourage an open­source­like model where people from other teams can change a\n\nbranch of their code and send the commit in to be approved. This allows one team to\n\nchange the clients of their functions—they can delete the old declarations once their\n\ncommits to their clients have been accepted. This can often be a good compromise\n\nbetween strong code ownership and chaotic changes in large systems.\n\nBranches\n\nAs I write this, a common approach in teams is for each team member to work on a\n\nbranch of the code base using a version control system, and do considerable work on\n\nthat branch before integrating with a mainline (often called master or trunk) shared\n\nacross the team. Often, this involves building a whole feature on a branch, not\n\nintegrating into the mainline until the feature is ready to be released into production.\n\nFans of this approach claim that it keeps the mainline clear of any in­process code,\n\nprovides a clear version history of feature additions, and allows features to be reverted\n\neasily should they cause problems.\n\nThere are downsides to feature branches like this. The longer I work on an isolated\n\nbranch, the harder the job of integrating my work with mainline is going to be when I’m\n\ndone. Most people reduce this pain by frequently merging or re­basing from mainline\n\nto my branch. But this doesn’t really solve the problem when several people are\n\nworking on individual feature branches. I distinguish between merging and integration.\n\nIf I merge mainline into my code, this is a oneway movement—my branch changes but\n\nthe mainline doesn’t. I use “integrate” to mean a two­way process that pulls changes\n\nfrom mainline into my branch and then pushes the result back into mainline, changing\n\nboth. If Rachel is working on her branch I don’t see her changes until she integrates\n\nwith mainline; at that point, I have to merge her changes into my feature branch, which\n\nmay mean considerable work. The hard part of this work is dealing with semantic\n\nchanges. Modern version control systems can do wonders with merging complex\n\nchanges to the program text, but they are blind to the semantics of the code. If I’ve\n\nchanged the name of a function, my version control tool may easily integrate my\n\nchanges with Rachel’s. But if, in her branch, she added a call to a function that I’ve\n\nrenamed in mine, the code will fail.\n\nThe problem of complicated merges gets exponentially worse as the length of feature\n\nbranches increases. Integrating branches that are four weeks old is more than twice as\n\nhard as those that are a couple of weeks old. Many people, therefore, argue for keeping\n\nfeature branches short—perhaps just a couple of days. Others, such as me, want them\n\neven shorter than that. This is an approach called Continuous Integration (CI), also\n\nwww.EBooksWorld.ir\n\nknown as Trunk­Based Development. With CI, each team member integrates with\n\nmainline at least once per day. This prevents any branches diverting too far from each\n\nother and thus greatly reduces the complexity of merges. CI doesn’t come for free: It\n\nmeans you use practices to ensure the mainline is healthy, learn to break large features\n\ninto smaller chunks, and use feature toggles (aka feature flags) to switch off any in­\n\nprocess features that can’t be broken down.\n\nFans of CI like it partly because it reduces the complexity of merges, but the dominant\n\nreason to favor CI is that it’s far more compatible with refactoring. Refactorings often\n\ninvolve making lots of little changes all over the code base—which are particularly\n\nprone to semantic merge conflicts (such as renaming a widely used function). Many of\n\nus have seen feature­branching teams that find refactorings so exacerbate merge\n\nproblems that they stop refactoring. CI and re­factoring work well together, which is\n\nwhy Kent Beck combined them in Extreme Programming.\n\nI’m not saying that you should never use feature branches. If they are sufficiently short,\n\ntheir problems are much reduced. (Indeed, users of CI usually also use branches, but\n\nintegrate them with mainline each day.) Feature branches may be the right technique\n\nfor open source projects where you have infrequent commits from programmers who\n\nyou don’t know well (and thus don’t trust). But in a full­time development team, the\n\ncost that feature branches impose on refactoring is excessive. Even if you don’t go to full\n\nCI, I certainly urge you to integrate as frequently as possible. You should also consider\n\nthe objective evidence [Forsgren et al.] that teams that use CI are more effective in\n\nsoftware delivery.\n\nTesting\n\nOne of the key characteristics of refactoring is that it doesn’t change the observable\n\nbehavior of the program. If I follow the refactorings carefully, I shouldn’t break\n\nanything—but what if I make a mistake? (Or, knowing me, s/if/when.) Mistakes\n\nhappen, but they aren’t a problem provided I catch them quickly. Since each refactoring\n\nis a small change, if I break anything, I only have a small change to look at to find the\n\nfault—and if I still can’t spot it, I can revert my version control to the last working\n\nversion.\n\nThe key here is being able to catch an error quickly. To do this, realistically, I need to be\n\nable to run a comprehensive test suite on the code—and run it quickly, so that I’m not\n\ndeterred from running it frequently. This means that in most cases, if I want to refactor,\n\nI need to have self­testing code [mf­stc].\n\nwww.EBooksWorld.ir\n\nTo some readers, self­testing code sounds like a requirement so steep as to be\n\nunrealizable. But over the last couple of decades, I’ve seen many teams build software\n\nthis way. It takes attention and dedication to testing, but the benefits make it really\n\nworthwhile. Self­testing code not only enables refactoring—it also makes it much safer\n\nto add new features, since I can quickly find and kill any bugs I introduce. The key point\n\nhere is that when a test fails, I can look at the change I’ve made between when the tests\n\nwere last running correctly and the current code. With frequent test runs, that will be\n\nonly a few lines of code. By knowing it was those few lines that caused the failure, I can\n\nmuch more easily find the bug.\n\nThis also answers those who are concerned that refactoring carries too much risk of\n\nintroducing bugs. Without self­testing code, that’s a reasonable worry—which is why I\n\nput so much emphasis on having solid tests.\n\nThere is another way to deal with the testing problem. If I use an environment that has\n\ngood automated refactorings, I can trust those refactorings even without running tests.\n\nI can then refactor, providing I only use those refactorings that are safely automated.\n\nThis removes a lot of nice refactorings from my menu, but still leaves me enough to\n\ndeliver some useful benefits. I’d still rather have self­testing code, but it’s an option that\n\nis useful to have in the toolkit.\n\nThis also inspires a style of refactoring that only uses a limited set of refactorings that\n\ncan be proven safe. Such refactorings require carefully following the steps, and are\n\nlanguage­specific. But teams using them have found they can do useful refactoring on\n\nlarge code bases with poor test coverage. I don’t focus on that in this book, as it’s a\n\nnewer, less described and understood technique that involves detailed, language­\n\nspecific activity. (It is, however, something I hope talk about more on my web site in the\n\nfuture. For a taste of it, see Jay Bazuzi’s description [Bazuzi] of a safer way to do\n\nExtract Method (106) in C++.)\n\nSelf­testing code is, unsurprisingly, closely associated with Continuous Integration—it\n\nis the mechanism that we use to catch semantic integration conflicts. Such testing\n\npractices are another component of Extreme Programming and a key part of\n\nContinuous Delivery.\n\nLegacy Code\n\nMost people would regard a big legacy as a Good Thing—but that’s one of the cases\n\nwhere programmers’ view is different. Legacy code is often complex, frequently comes\n\nwith poor tests, and, above all, is written by Someone Else (shudder).\n\nwww.EBooksWorld.ir\n\nRefactoring can be a fantastic tool to help understand a legacy system. Functions with\n\nmisleading names can be renamed so they make sense, awkward programming\n\nconstructs smoothed out, and the program turned from a rough rock to a polished gem.\n\nBut the dragon guarding this happy tale is the common lack of tests. If you have a big\n\nlegacy system with no tests, you can’t safely refactor it into clarity.\n\nThe obvious answer to this problem is that you add tests. But while this sounds a\n\nsimple, if laborious, procedure, it’s often much more tricky in practice. Usually, a\n\nsystem is only easy to put under test if it was designed with testing in mind—in which\n\ncase it would have the tests and I wouldn’t be worrying about it.\n\nThere’s no simple route to dealing with this. The best advice I can give is to get a copy of\n\nWorking Effectively with Legacy Code [Feathers] and follow its guidance. Don’t be\n\nworried by the age of the book—its advice is just as true more than a decade later. To\n\nsummarize crudely, it advises you to get the system under test by finding seams in the\n\nprogram where you can insert tests. Creating these seams involves refactoring—which\n\nis much more dangerous since it’s done without tests, but is a necessary risk to make\n\nprogress. This is a situation where safe, automated refactorings can be a godsend. If all\n\nthis sounds difficult, that’s because it is. Sadly, there’s no shortcut to getting out of a\n\nhole this deep—which is why I’m such a strong proponent of writing self­testing code\n\nfrom the start.\n\nEven when I do have tests, I don’t advocate trying to refactor a complicated legacy mess\n\ninto beautiful code all at once. What I prefer to do is tackle it in relevant pieces. Each\n\ntime I pass through a section of the code, I try to make it a little bit better—again, like\n\nleaving a camp site cleaner than when I found it. If this is a large system, I’ll do more\n\nrefactoring in areas I visit frequently—which is the right thing to do because, if I need to\n\nvisit code frequently, I’ll get a bigger payoff by making it easier to understand.\n\nDatabases\n\nWhen I wrote the first edition of this book, I said that refactoring databases was a\n\nproblem area. But, within a year of the book’s publication, that was no longer the case.\n\nMy colleague Pramod Sadalage developed an approach to evolutionary database design\n\n[mf­evodb] and database refactoring [Ambler & Sadalage] that is now widely used. The\n\nessence of the technique is to combine the structural changes to a database’s schema\n\nand access code with data migration scripts that can easily compose to handle large\n\nchanges.\n\nConsider a simple example of renaming a field (column). As in Change Function\n\nDeclaration (124), I need to find the original declaration of the structure and all the\n\nwww.EBooksWorld.ir\n\ncallers of this structure and change them in a single change. The complication,\n\nhowever, is that I also have to transform any data that uses the old field to use the new\n\none. I write a small hunk of code that carries out this transform and store it in version\n\ncontrol, together with the code that changes any declared structure and access routines.\n\nThen, whenever I need to migrate between two versions of the database, I run all the\n\nmigration scripts that exist between my current copy of the database and my desired\n\nversion.\n\nAs with regular refactoring, the key here is that each individual change is small yet\n\ncaptures a complete change, so the system still runs after applying the migration.\n\nKeeping them small means they are easy to write, but I can string many of them into a\n\nsequence that can make a significant change to the database’s structure and the data\n\nstored in it.\n\nOne difference from regular refactorings is that database changes often are best\n\nseparated over multiple releases to production. This makes it easy to reverse any\n\nchange that causes a problem in production. So, when renaming a field, my first\n\ncommit would add the new database field but not use it. I may then set up the updates\n\nso they update both old and new fields at once. I can then gradually move the readers\n\nover to the new field. Only once they have all moved to the new field, and I’ve given a\n\nlittle time for any bugs to show themselves, would I remove the now­unused old field.\n\nThis approach to database changes is an example of a general approach of parallel\n\nchange [mf­pc] (also called expand­contract).\n\nREFACTORING, ARCHITECTURE, AND YAGNI\n\nRefactoring has profoundly changed how people think about software architecture.\n\nEarly in my career, I was taught that software design and architecture was something to\n\nbe worked on, and mostly completed, before anyone started writing code. Once the\n\ncode was written, its architecture was fixed and could only decay due to carelessness.\n\nRefactoring changes this perspective. It allows me to significantly alter the architecture\n\nof software that’s been running in production for years. Refactoring can improve the\n\ndesign of existing code, as this book’s subtitle implies. But as I indicated earlier,\n\nchanging legacy code is often challenging, especially when it lacks decent tests.\n\nThe real impact of refactoring on architecture is in how it can be used to form a well­\n\ndesigned code base that can respond gracefully to changing needs. The biggest issue\n\nwith finishing architecture before coding is that such an approach assumes the\n\nrequirements for the software can be understood early on. But experience shows that\n\nwww.EBooksWorld.ir\n\nthis is often, even usually, an unachievable goal. Repeatedly, I saw people only\n\nunderstand what they really needed from software once they’d had a chance to use it,\n\nand saw the impact it made to their work.\n\nOne way of dealing with future changes is to put flexibility mechanisms into the\n\nsoftware. As I write some function, I can see that it has a general applicability. To\n\nhandle the different circumstances that I anticipate it to be used in, I can see a dozen\n\nparameters I could add to that function. These parameters are flexibility mechanisms—\n\nand, like most mechanisms, they are not a free lunch. Adding all those parameters\n\ncomplicates the function for the one case it’s used right now. If I miss a parameter, all\n\nthe parameterization I have added makes it harder for me to add more. I find I often get\n\nmy flexibility mechanisms wrong—either because the changing needs didn’t work out\n\nthe way I expected or my mechanism design was faulty. Once I take all that into\n\naccount, most of the time my flexibility mechanisms actually slow down my ability to\n\nreact to change.\n\nWith refactoring, I can use a different strategy. Instead of speculating on what\n\nflexibility I will need in the future and what mechanisms will best enable that, I build\n\nsoftware that solves only the currently understood needs, but I make this software\n\nexcellently designed for those needs. As my understanding of the users’ needs changes,\n\nI use refactoring to adapt the architecture to those new demands. I can happily include\n\nmechanisms that don’t increase complexity (such as small, well­named functions) but\n\nany flexibility that complicates the software has to prove itself before I include it. If I\n\ndon’t have different values for a parameter from the callers, I don’t add it to the\n\nparameter list. Should the time come that I need to add it, then Parameterize Function\n\n(310) is an easy refactoring to apply. I often find it useful to estimate how hard it would\n\nbe to use refactoring later to support an anticipated change. Only if I can see that it\n\nwould be substantially harder to refactor later do I consider adding a flexibility\n\nmechanism now.\n\nThis approach to design goes under various names: simple design, incremental design,\n\nor yagni [mf­yagni] (originally an acronym for “you aren’t going to need it”). Yagni\n\ndoesn’t imply that architectural thinking disappears, although it is sometimes naively\n\napplied that way. I think of yagni as a different style of incorporating architecture and\n\ndesign into the development process—a style that isn’t credible without the foundation\n\nof refactoring.\n\nAdopting yagni doesn’t mean I neglect all upfront architectural thinking. There are still\n\ncases where refactoring changes are difficult and some preparatory thinking can save\n\ntime. But the balance has shifted a long way—I’m much more inclined to deal with www.EBooksWorld.ir\n\nissues later when I understand them better. All this has led to a growing discipline of\n\nevolutionary architecture [Ford et al.] where architects explore the patterns and\n\npractices that take advantage of our ability to iterate over architectural decisions.\n\nREFACTORING AND THE WIDER SOFTWARE DEVELOPMENT PROCESS\n\nIf you’ve read the earlier section on problems, one lesson you’ve probably drawn is that\n\nthe effectiveness of refactoring is tied to other software practices that a team uses.\n\nIndeed, refactoring’s early adoption was as part of Extreme Programming [mf­xp] (XP),\n\na process which was notable for putting together a set of relatively unusual and\n\ninterdependent practices—such as continuous integration, self­testing code, and\n\nrefactoring (the latter two woven into test­driven development).\n\nExtreme Programming was one of the first agile software methods [mf­nm] and, for\n\nseveral years, led the rise of agile techniques. Enough projects now use agile methods\n\nthat agile thinking is generally regarded as mainstream—but in reality most “agile”\n\nprojects only use the name. To really operate in an agile way, a team has to be capable\n\nand enthusiastic refactorers—and for that, many aspects of their process have to align\n\nwith making refactoring a regular part of their work.\n\nThe first foundation for refactoring is self­testing code. By this, I mean that there is a\n\nsuite of automated tests that I can run and be confident that, if I made an error in my\n\nprogramming, some test will fail. This is such an important foundation for refactoring\n\nthat I’ll spend a chapter talking more about this.\n\nTo refactor on a team, it’s important that each member can refactor when they need to\n\nwithout interfering with others’ work. This is why I encourage Continuous Integration.\n\nWith CI, each member’s refactoring efforts are quickly shared with their colleagues. No\n\none ends up building new work on interfaces that are being removed, and if the\n\nrefactoring is going to cause a problem with someone else’s work, we know about this\n\nquickly. Self­testing code is also a key element of Continuous Integration, so there is a\n\nstrong synergy between the three practices of self­testing code, continuous integration,\n\nand refactoring.\n\nWith this trio of practices in place, we enable the Yagni design approach that I talked\n\nabout in the previous section. Refactoring and yagni positively reinforce each other:\n\nNot just is refactoring (and its prerequisites) a foundation for yagni—yagni makes it\n\neasier to do refactoring. This is because it’s easier to change a simple system than one\n\nthat has lots of speculative flexibility included. Balance these practices, and you can get\n\nwww.EBooksWorld.ir",
      "page_number": 69
    },
    {
      "number": 8,
      "title": "Segment 8 (pages 77-84)",
      "start_page": 77,
      "end_page": 84,
      "detection_method": "topic_boundary",
      "content": "into a virtuous circle with a code base that responds rapidly to changing needs and is\n\nreliable.\n\nWith these core practices in place, we have the foundation to take advantage of the\n\nother elements of the agile mindset. Continuous Delivery keeps our software in an\n\nalways­releasable state. This is what allows many web organizations to release updates\n\nmany times a day—but even if we don’t need that, it reduces risk and allows us to\n\nschedule our releases to satisfy business needs rather than technological constraints.\n\nWith a firm technical foundation, we can drastically reduce the time it takes to get a\n\ngood idea into production code, allowing us to better serve our customers.\n\nFurthermore, these practices increase the reliability of our software, with less bugs to\n\nspend time fixing.\n\nStated like this, it all sounds rather simple—but in practice it isn’t. Software\n\ndevelopment, whatever the approach, is a tricky business, with complex interactions\n\nbetween people and machines. The approach I describe here is a proven way to handle\n\nthis complexity, but like any approach, it requires practice and skill.\n\nREFACTORING AND PERFORMANCE\n\nA common concern with refactoring is the effect it has on the performance of a\n\nprogram. To make the software easier to understand, I often make changes that will\n\ncause the program to run slower. This is an important issue. I don’t belong to the school\n\nof thought that ignores performance in favor of design purity or in hopes of faster\n\nhardware. Software has been rejected for being too slow, and faster machines merely\n\nmove the goalposts. Refactoring can certainly make software go more slowly—but it\n\nalso makes the software more amenable to performance tuning. The secret to fast\n\nsoftware, in all but hard real­time contexts, is to write tunable software first and then\n\ntune it for sufficient speed.\n\nI’ve seen three general approaches to writing fast software. The most serious of these is\n\ntime budgeting, often used in hard real­time systems. As you decompose the design,\n\nyou give each component a budget for resources—time and footprint. That component\n\nmust not exceed its budget, although a mechanism for exchanging budgeted resources\n\nis allowed. Time budgeting focuses attention on hard performance times. It is essential\n\nfor systems, such as heart pacemakers, in which late data is always bad data. This\n\ntechnique is inappropriate for other kinds of systems, such as the corporate\n\ninformation systems with which I usually work.\n\nThe second approach is the constant attention approach. Here, every programmer, all\n\nwww.EBooksWorld.ir\n\nthe time, does whatever she can to keep performance high. This is a common approach\n\nthat is intuitively attractive—but it does not work very well. Changes that improve\n\nperformance usually make the program harder to work with. This slows development.\n\nThis would be a cost worth paying if the resulting software were quicker—but usually it\n\nis not. The performance improvements are spread all around the program; each\n\nimprovement is made with a narrow perspective of the program’s behavior, and often\n\nwith a misunderstanding of how a compiler, runtime, and hardware behaves.\n\nIt Takes Awhile to Create Nothing\n\nThe Chrysler Comprehensive Compensation pay process was running too\n\nslowly. Although we were still in development, it began to bother us, because\n\nit was slowing down the tests.\n\nKent Beck, Martin Fowler, and I decided we’d fix it up. While I waited for us\n\nto get together, I was speculating, on the basis of my extensive knowledge of\n\nthe system, about what was probably slowing it down. I thought of several\n\npossibilities and chatted with folks about the changes that were probably\n\nnecessary. We came up with some really good ideas about what would make\n\nthe system go faster.\n\nThen we measured performance using Kent’s profiler. None of the\n\npossibilities I had thought of had anything to do with the problem. Instead, we\n\nfound that the system was spending half its time creating instances of date.\n\nEven more interesting was that all the instances had the same couple of\n\nvalues.\n\nWhen we looked at the date­creation logic, we saw some opportunities for\n\noptimizing how these dates were created. They were all going through a\n\nstring conversion even though no external inputs were involved. The code\n\nwas just using string conversion for convenience of typing. Maybe we could\n\noptimize that.\n\nThen we looked at how these dates were being used. It turned out that the\n\nhuge bulk of them were all creating instances of date range, an object with a\n\nfrom date and a to date. Looking around little more, we realized that most of\n\nthese date ranges were empty!\n\nAs we worked with date range, we used the convention that any date range\n\nthat ended before it started was empty. It’s a good convention and fits in well\n\nwith how the class works. Soon after we started using this convention, we\n\nrealized that just creating a date range that starts after it ends wasn’t clear\n\ncode, so we extracted that behavior into a factory method for empty date\n\nwww.EBooksWorld.ir\n\nranges.\n\nWe had made that change to make the code clearer, but we received an\n\nunexpected payoff. We created a constant empty date range and adjusted\n\nthe factory method to return that object instead of creating it every time. That\n\nchange doubled the speed of the system, enough for the tests to be\n\nbearable. It took us about five minutes.\n\nI had speculated with various members of the team (Kent and Martin deny\n\nparticipating in the speculation) on what was likely wrong with code we knew\n\nvery well. We had even sketched some designs for improvements without\n\nfirst measuring what was going on.\n\nWe were completely wrong. Aside from having a really interesting\n\nconversation, we were doing no good at all.\n\nThe lesson is: Even if you know exactly what is going on in your system,\n\nmeasure performance, don’t speculate. You’ll learn something, and nine\n\ntimes out of ten, it won’t be that you were right!\n\n— Ron Jeffries\n\nThe interesting thing about performance is that in most\n\nprograms, most of their time is spent in a small fraction of the code. If I optimize all the\n\ncode equally, I’ll end up with 90 percent of my work wasted because it’s optimizing\n\ncode that isn’t run much. The time spent making the program fast—the time lost\n\nbecause of lack of clarity—is all wasted time.\n\nThe third approach to performance improvement takes advantage of this 90­percent\n\nstatistic. In this approach, I build my program in a well­factored manner without\n\npaying attention to performance until I begin a deliberate performance optimization\n\nexercise. During this performance optimization, I follow a specific process to tune the\n\nprogram.\n\nI begin by running the program under a profiler that monitors the program and tells me\n\nwhere it is consuming time and space. This way I can find that small part of the\n\nprogram where the performance hot spots lie. I then focus on those performance hot\n\nspots using the same optimizations I would use in the constant­attention approach. But\n\nsince I’m focusing my attention on a hot spot, I’m getting much more effect with less\n\nwork. Even so, I remain cautious. As in refactoring, I make the changes in small steps.\n\nAfter each step I compile, test, and rerun the profiler. If I haven’t improved\n\nperformance, I back out the change. I continue the process of finding and removing hot\n\nspots until I get the performance that satisfies my users.\n\nwww.EBooksWorld.ir\n\nHaving a well­factored program helps with this style of optimization in two ways. First,\n\nit gives me time to spend on performance tuning. With well­factored code, I can add\n\nfunctionality more quickly. This gives me more time to focus on performance. (Profiling\n\nensures I spend that time on the right place.) Second, with a well­factored program I\n\nhave finer granularity for my performance analysis. My profiler leads me to smaller\n\nparts of the code, which are easier to tune. With clearer code, I have a better\n\nunderstanding of my options and of what kind of tuning will work.\n\nI’ve found that refactoring helps me write fast software. It slows the software in the\n\nshort term while I’m refactoring, but makes it easier to tune during optimization. I end\n\nup well ahead.\n\nWHERE DID REFACTORING COME FROM?\n\nI’ve not succeeded in pinning down the birth of the term “refactoring.” Good\n\nprogrammers have always spent at least some time cleaning up their code. They do this\n\nbecause they have learned that clean code is easier to change than complex and messy\n\ncode, and good programmers know that they rarely write clean code the first time\n\naround.\n\nRefactoring goes beyond this. In this book, I’m advocating refactoring as a key element\n\nin the whole process of software development. Two of the first people to recognize the\n\nimportance of refactoring were Ward Cunningham and Kent Beck, who worked with\n\nSmalltalk from the 1980s onward. Smalltalk is an environment that even then was\n\nparticularly hospitable to refactoring. It is a very dynamic environment that allows you\n\nto quickly write highly functional software. Smalltalk had a very short compile­link­\n\nexecute cycle for its time, which made it easy to change things quickly at a time where\n\novernight compile cycles were not unknown. It is also object­oriented and thus provides\n\npowerful tools for minimizing the impact of change behind well­defined interfaces.\n\nWard and Kent explored software development approaches geared to this kind of\n\nenvironment, and their work developed into Extreme Programming. They realized that\n\nrefactoring was important in improving their productivity and, ever since, have been\n\nworking with refactoring, applying it to serious software projects and refining it.\n\nWard and Kent’s ideas were a strong influence on the Smalltalk community, and the\n\nnotion of refactoring became an important element in the Smalltalk culture. Another\n\nleading figure in the Smalltalk community is Ralph Johnson, a professor at the\n\nUniversity of Illinois at Urbana­Champaign, who is famous as one of the authors of the\n\n“Gang of Four” [gof] book on design patterns. One of Ralph’s biggest interests is in\n\ndeveloping software frameworks. He explored how refactoring can help develop an\n\nwww.EBooksWorld.ir\n\nefficient and flexible framework.\n\nBill Opdyke was one of Ralph’s doctoral students and was particularly interested in\n\nframeworks. He saw the potential value of refactoring and saw that it could be applied\n\nto much more than Smalltalk. His background was in telephone switch development, in\n\nwhich a great deal of complexity accrues over time and changes are difficult to make.\n\nBill’s doctoral research looked at refactoring from a tool builder’s perspective. Bill was\n\ninterested in refactorings that would be useful for C++ framework development; he\n\nresearched the necessary semantics­preserving refactorings and showed how to prove\n\nthey were semantics­preserving and how a tool could implement these ideas. Bill’s\n\ndoctoral thesis [Opdyke] was the first substantial work on refactoring.\n\nI remember meeting Bill at the OOPSLA conference in 1992. We sat in a café and he\n\ntold me about his research. I remember thinking, “Interesting, but not really that\n\nimportant.” Boy, was I wrong!\n\nJohn Brant and Don Roberts took the refactoring tool ideas much further to produce\n\nthe Refactoring Browser, the first refactoring tool, appropriately for the Smalltalk\n\nenvironment.\n\nAnd me? I’d always been inclined to clean code, but I’d never considered it to be that\n\nimportant. Then, I worked on a project with Kent and saw the way he used refactoring.\n\nI saw the difference it made in productivity and quality. That experience convinced me\n\nthat refactoring was a very important technique. I was frustrated, however, because\n\nthere was no book that I could give to a working programmer, and none of the experts\n\nabove had any plans to write such a book. So, with their help, I did—which led to the\n\nfirst edition of this book.\n\nFortunately, the concept of refactoring caught on in the industry. The book sold well,\n\nand refactoring entered the vocabulary of most programmers. More tools appeared,\n\nespecially for Java. One downside of this popularity has been people using “refactoring”\n\nloosely, to mean any kind of restructuring. Despite this, however, it has become a\n\nmainstream practice.\n\nAUTOMATED REFACTORINGS\n\nPerhaps the biggest change to refactoring in the last decade or so is the availability of\n\ntools that support automated refactoring. If I want to rename a method in Java and I’m\n\nusing IntelliJ IDEA [intellij] or Eclipse [eclipse] (to mention just two), I can do it by\n\npicking an item off the menu. The tool completes the refactoring for me—and I’m\n\nusually sufficiently confident in its work that I don’t bother running the test suite. www.EBooksWorld.ir\n\nThe first tool that did this was the Smalltalk Refactoring Browser, written by John\n\nBrandt and Don Roberts. The idea took off in the Java community very rapidly at the\n\nbeginning of the century. When JetBrains launched their IntelliJ IDEA IDE, automated\n\nrefactoring was one of the compelling features. IBM followed suit shortly afterwards\n\nwith refactoring tools in Visual Age for Java. Visual Age didn’t have a big impact, but\n\nmuch of its capabilities were reimplemented in Eclipse, including the refactoring\n\nsupport.\n\nRefactoring also came to C#, initially via JetBrains’s Resharper, a plug­in for Visual\n\nStudio. Later on, the Visual Studio team added some refactoring capabilities.\n\nIt’s now pretty common to find some kind of refactoring support in editors and tools,\n\nalthough the actual capabilities vary a fair bit. Some of this variation is due to the tool,\n\nsome is caused by the limitations of what you can do with automated refactoring in\n\ndifferent languages. I’m not going to analyze the capabilities of different tools here, but\n\nI think it is worth talking a bit about some of the underlying principles.\n\nA crude way to automate a refactoring is to do text manipulation, such as a\n\nsearch/replace to change a name, or some simple reorganizing of code for Extract\n\nVariable (119). This is a very crude approach that certainly can’t be trusted without\n\nrerunning tests. It can, however, be a handy first step. I’ll use such macros in Emacs to\n\nspeed up my refactoring work when I don’t have more sophisticated refactorings\n\navailable to me.\n\nTo do refactoring properly, the tool has to operate on the syntax tree of the code, not on\n\nthe text. Manipulating the syntax tree is much more reliable to preserve what the code\n\nis doing. This is why at the moment, most refactoring capabilities are part of powerful\n\nIDEs—they use the syntax tree not just for refactoring but also for code navigation,\n\nlinting, and the like. This collaboration between text and syntax tree is what takes them\n\nbeyond text editors.\n\nRefactoring isn’t just understanding and updating the syntax tree. The tool also needs\n\nto figure out how to rerender the code into text back in the editor view. All in all,\n\nimplementing decent refactoring is a challenging programming exercise—one that I’m\n\nmostly unaware of as I gaily use the tools.\n\nMany refactorings are made much safer when applied in a language with static typing.\n\nConsider the simple Rename Function (124). I might have addClient methods on my\n\nSalesman class and on my Server class. I want to rename the one on my salesman,\n\nbut it is different in intent from the one on my server, which I don’t want to rename.\n\nwww.EBooksWorld.ir\n\nWithout static typing, the tool will find it difficult to tell whether any call to addClient\n\nis intended for the salesman. In the refactoring browser, it would generate a list of call\n\nsites and I would manually decide which ones to change. This makes it a nonsafe\n\nrefactoring that forces me to rerun the tests. Such a tool is still helpful—but the\n\nequivalent operation in Java can be completely safe and automatic. Since the tool can\n\nresolve the method to the correct class with static typing, I can be confident that the\n\ntool changes only the methods it ought to.\n\nTools often go further. If I rename a variable, I can be prompted for changes to\n\ncomments that use that name. If I use Extract Function (106), the tool spots some code\n\nthat duplicates the new function’s body and offers to replace it with a call.\n\nProgramming with powerful refactorings like this is a compelling reason to use an IDE\n\nrather than stick with a familiar text editor. Personally I’m a big user of Emacs, but\n\nwhen working in Java I prefer IntelliJ IDEA or Eclipse—in large part due to the\n\nrefactoring support.\n\nWhile sophisticated refactoring tools are almost magical in their ability to safely\n\nrefactor code, there are some edge cases where they slip up. Less mature tools struggle\n\nwith reflective calls, such as Method.invoke in Java (although more mature tools\n\nhandle this quite well). So even with mostly safe refactorings, it’s wise to run the test\n\nsuite every so often to ensure nothing has gone pear­shaped. Usually I’m refactoring\n\nwith a mix of automated and manual refactorings, so I run my tests often enough.\n\nThe power of using the syntax tree to analyze and refactor programs is a compelling\n\nadvantage for IDEs over simple text editors, but many programmers prefer the\n\nflexibility of their favorite text editor and would like to have both. A technology that’s\n\ncurrently gaining momentum is Language Servers [langserver]: software that will form\n\na syntax tree and present an API to text editors. Such language servers can support\n\nmany text editors and provide commands to do sophisticated code analysis and\n\nrefactoring operations.\n\nGOING FURTHER\n\nIt seems a little strange to be talking about further reading in only the second chapter,\n\nbut this is as good a spot as any to point out there is more material out there on\n\nrefactoring that goes beyond the basics in this book.\n\nThis book has taught refactoring to many people, but I have focused more on a\n\nrefactoring reference than on taking readers through the learning process. If you are\n\nlooking for such a book, I suggest Bill Wake’s Refactoring Workbook [Wake] that\n\nwww.EBooksWorld.ir\n\ncontains many exercises to practice refactoring.\n\nMany of those who pioneered refactoring were also active in the software patterns\n\ncommunity. Josh Kerievsky tied these two worlds closely together with Refactoring to\n\nPatterns [Kerievsky], which looks at the most valuable patterns from the hugely\n\ninfluential “Gang of Four” book [gof] and shows how to use refactoring to evolve\n\ntowards them.\n\nThis book concentrates on refactoring in general­purpose programming, but\n\nrefactoring also applies in specialized areas. Two that have got useful attention are\n\nRefactoring Databases [Ambler & Sadalage] (by Scott Ambler and Pramod Sadalage)\n\nand Refactoring HTML [Harold] (by Elliotte Rusty Harold).\n\nAlthough it doesn’t have refactoring in the title, also worth including is Michael\n\nFeathers’s Working Effectively with Legacy Code [Feathers], which is primarily a book\n\nabout how to think about refactoring an older codebase with poor test coverage.\n\nAlthough this book (and its predecessor) are intended for programmers with any\n\nlanguage, there is a place for language­specific refactoring books. Two of my former\n\ncolleagues, Jay Fields and Shane Harvey, did this for the Ruby programming language\n\n[Fields et al.].\n\nFor more up­to­date material, look up the web representation of this book, as well as\n\nthe main refactoring web site: refactoring.com [ref.com].\n\nwww.EBooksWorld.ir",
      "page_number": 77
    },
    {
      "number": 9,
      "title": "Segment 9 (pages 85-92)",
      "start_page": 85,
      "end_page": 92,
      "detection_method": "topic_boundary",
      "content": "Chapter 3 Bad Smells in Code\n\nHistory\n\nTopics\n\nby Kent Beck and Martin Fowler\n\nTutorials\n\n“If it stinks, change it.”\n\n— Grandma Beck, discussing child­rearing philosophy\n\nOffers & Deals\n\nBy now you have a good idea of how refactoring works. But just because you know how\n\nHighlights\n\ndoesn’t mean you know when. Deciding when to start refactoring—and when to stop—is\n\njust as important to refactoring as knowing how to operate the mechanics of it.\n\nSettings\n\nNow comes the dilemma. It is easy to explain how to delete an instance variable or\n\nSupport\n\ncreate a hierarchy. These are simple matters. Trying to explain when you should do\n\nthese things is not so cut­and­dried. Instead of appealing to some vague notion of\n\nSign Out\n\nprogramming aesthetics (which, frankly, is what we consultants usually do), I wanted\n\nsomething a bit more solid.\n\nWhen I was writing the first edition of this book, I was mulling over this issue as I\n\nvisited Kent Beck in Zurich. Perhaps he was under the influence of the odors of his\n\nnewborn daughter at the time, but he had come up with the notion of describing the\n\n“when” of refactoring in terms of smells.\n\n“Smells,” you say, “and that is supposed to be better than vague aesthetics?” Well, yes.\n\nWe have looked at lots of code, written for projects that span the gamut from wildly\n\nsuccessful to nearly dead. In doing so, we have learned to look for certain structures in\n\nthe code that suggest—sometimes, scream for—the possibility of refactoring. (We are\n\nswitching over to “we” in this chapter to reflect the fact that Kent and I wrote this\n\nchapter jointly. You can tell the difference because the funny jokes are mine and the\n\nothers are his.)\n\nOne thing we won’t try to give you is precise criteria for when a refactoring is overdue.\n\nIn our experience, no set of metrics rivals informed human intuition. What we will do is\n\ngive you indications that there is trouble that can be solved by a refactoring. You will\n\nwww.EBooksWorld.ir\n\nhave to develop your own sense of how many instance variables or how many lines of\n\ncode in a method are too many.\n\nUse this chapter and the table on the inside back cover as a way to give you inspiration\n\nwhen you’re not sure what refactorings to do. Read the chapter (or skim the table) and\n\ntry to identify what it is you’re smelling, then go to the refactorings we suggest to see\n\nwhether they will help you. You may not find the exact smell you can detect, but\n\nhopefully it should point you in the right direction.\n\nMYSTERIOUS NAME\n\nPuzzling over some text to understand what’s going on is a great thing if you’re reading\n\na detective novel, but not when you’re reading code. We may fantasize about being\n\nInternational Men of Mystery, but our code needs to be mundane and clear. One of the\n\nmost important parts of clear code is good names, so we put a lot of thought into\n\nnaming functions, modules, variables, classes, so they clearly communicate what they\n\ndo and how to use them.\n\nSadly, however, naming is one of the two hard things [mf­2h] in programming. So,\n\nperhaps the most common refactorings we do are the renames: Change Function\n\nDeclaration (124) (to rename a function), Rename Variable (137), and Rename Field\n\n(244). People are often afraid to rename things, thinking it’s not worth the trouble, but\n\na good name can save hours of puzzled incomprehension in the future.\n\nRenaming is not just an exercise in changing names. When you can’t think of a good\n\nname for something, it’s often a sign of a deeper design malaise. Puzzling over a tricky\n\nname has often led us to significant simplifications to our code.\n\nDUPLICATED CODE\n\nIf you see the same code structure in more than one place, you can be sure that your\n\nprogram will be better if you find a way to unify them. Duplication means that every\n\ntime you read these copies, you need to read them carefully to see if there’s any\n\ndifference. If you need to change the duplicated code, you have to find and catch each\n\nduplication.\n\nThe simplest duplicated code problem is when you have the same expression in two\n\nmethods of the same class. Then all you have to do is Extract Function (106) and invoke\n\nthe code from both places. If you have code that’s similar, but not quite identical, see if\n\nyou can use Slide Statements (223) to arrange the code so the similar items are all\n\ntogether for easy extraction. If the duplicate fragments are in subclasses of a common\n\nwww.EBooksWorld.ir\n\nbase class, you can use Pull Up Method (350) to avoid calling one from another.\n\nLONG FUNCTION\n\nIn our experience, the programs that live best and longest are those with short\n\nfunctions. Programmers new to such a code base often feel that no computation ever\n\ntakes place—that the program is an endless sequence of delegation. When you have\n\nlived with such a program for a few years, however, you learn just how valuable all\n\nthose little functions are. All of the payoffs of indirection—explanation, sharing, and\n\nchoosing—are supported by small functions.\n\nSince the early days of programming, people have realized that the longer a function is,\n\nthe more difficult it is to understand. Older languages carried an overhead in\n\nsubroutine calls, which deterred people from small functions. Modern languages have\n\npretty much eliminated that overhead for in­process calls. There is still overhead for the\n\nreader of the code because you have to switch context to see what the function does.\n\nDevelopment environments that allow you to quickly jump between a function call and\n\nits declaration, or to see both functions at once, help eliminate this step, but the real\n\nkey to making it easy to understand small functions is good naming. If you have a good\n\nname for a function, you mostly don’t need to look at its body.\n\nThe net effect is that you should be much more aggressive about decomposing\n\nfunctions. A heuristic we follow is that whenever we feel the need to comment\n\nsomething, we write a function instead. Such a function contains the code that we\n\nwanted to comment but is named after the intention of the code rather than the way it\n\nworks. We may do this on a group of lines or even on a single line of code. We do this\n\neven if the method call is longer than the code it replaces—provided the method name\n\nexplains the purpose of the code. The key here is not function length but the semantic\n\ndistance between what the method does and how it does it.\n\nNinety­nine percent of the time, all you have to do to shorten a function is Extract\n\nFunction (106). Find parts of the function that seem to go nicely together and make a\n\nnew one.\n\nIf you have a function with lots of parameters and temporary variables, they get in the\n\nway of extracting. If you try to use Extract Function (106), you end up passing so many\n\nparameters to the extracted method that the result is scarcely more readable than the\n\noriginal. You can often use Replace Temp with Query (178) to eliminate the temps.\n\nLong lists of parameters can be slimmed down with Introduce Parameter Object (140)\n\nand Preserve Whole Object (319).\n\nwww.EBooksWorld.ir\n\nIf you’ve tried that and you still have too many temps and parameters, it’s time to get\n\nout the heavy artillery: Replace Function with Command (337).\n\nHow do you identify the clumps of code to extract? A good technique is to look for\n\ncomments. They often signal this kind of semantic distance. A block of code with a\n\ncomment that tells you what it is doing can be replaced by a method whose name is\n\nbased on the comment. Even a single line is worth extracting if it needs explanation.\n\nConditionals and loops also give signs for extractions. Use Decompose Conditional\n\n(260) to deal with conditional expressions. A big switch statement should have its legs\n\nturned into single function calls with Extract Function (106). If there’s more than one\n\nswitch statement switching on the same condition, you should apply Replace\n\nConditional with Polymorphism (272).\n\nWith loops, extract the loop and the code within the loop into its own method. If you\n\nfind it hard to give an extracted loop a name, that may be because it’s doing two\n\ndifferent things—in which case don’t be afraid to use Split Loop (227) to break out the\n\nseparate tasks.\n\nLONG PARAMETER LIST\n\nIn our early programming days, we were taught to pass in as parameters everything\n\nneeded by a function. This was understandable because the alternative was global data,\n\nand global data quickly becomes evil. But long parameter lists are often confusing in\n\ntheir own right.\n\nIf you can obtain one parameter by asking another parameter for it, you can use\n\nReplace Parameter with Query (324) to remove the second parameter. Rather than\n\npulling lots of data out of an existing data structure, you can use Preserve Whole Object\n\n(319) to pass the original data structure instead. If several parameters always fit\n\ntogether, combine them with Introduce Parameter Object (140). If a parameter is used\n\nas a flag to dispatch different behavior, use Remove Flag Argument (314).\n\nClasses are a great way to reduce parameter list sizes. They are particularly useful when\n\nmultiple functions share several parameter values. Then, you can use Combine\n\nFunctions into Class (144) to capture those common values as fields. If we put on our\n\nfunctional programming hats, we’d say this creates a set of partially applied functions.\n\nGLOBAL DATA\n\nSince our earliest days of writing software, we were warned of the perils of global data—\n\nwww.EBooksWorld.ir\n\nhow it was invented by demons from the fourth plane of hell, which is the resting place\n\nof any programmer who dares to use it. And, although we are somewhat skeptical about\n\nfire and brimstone, it’s still one of the most pungent odors we are likely to run into. The\n\nproblem with global data is that it can be modified from anywhere in the code base, and\n\nthere’s no mechanism to discover which bit of code touched it. Time and again, this\n\nleads to bugs that breed from a form of spooky action from a distance—and it’s very\n\nhard to find out where the errant bit of program is. The most obvious form of global\n\ndata is global variables, but we also see this problem with class variables and singletons.\n\nOur key defense here is Encapsulate Variable (132), which is always our first move\n\nwhen confronted with data that is open to contamination by any part of a program. At\n\nleast when you have it wrapped by a function, you can start seeing where it’s modified\n\nand start to control its access. Then, it’s good to limit its scope as much as possible by\n\nmoving it within a class or module where only that module’s code can see it.\n\nGlobal data is especially nasty when it’s mutable. Global data that you can guarantee\n\nnever changes after the program starts is relatively safe—if you have a language that can\n\nenforce that guarantee.\n\nGlobal data illustrates Paracelsus’s maxim: The difference between a poison and\n\nsomething benign is the dose. You can get away with small doses of global data, but it\n\ngets exponentially harder to deal with the more you have. Even with little bits, we like\n\nto keep it encapsulated—that’s the key to coping with changes as the software evolves.\n\nMUTABLE DATA\n\nChanges to data can often lead to unexpected consequences and tricky bugs. I can\n\nupdate some data here, not realizing that another part of the software expects\n\nsomething different and now fails—a failure that’s particularly hard to spot if it only\n\nhappens under rare conditions. For this reason, an entire school of software\n\ndevelopment—functional programming—is based on the notion that data should never\n\nchange and that updating a data structure should always return a new copy of the\n\nstructure with the change, leaving the old data pristine.\n\nThese kinds of languages, however, are still a relatively small part of programming;\n\nmany of us work in languages that allow variables to vary. But this doesn’t mean we\n\nshould ignore the advantages of immutability—there are still many things we can do to\n\nlimit the risks on unrestricted data updates.\n\nYou can use Encapsulate Variable (132) to ensure that all updates occur through\n\nnarrow functions that can be easier to monitor and evolve. If a variable is being updated\n\nwww.EBooksWorld.ir\n\nto store different things, use Split Variable (240) both to keep them separate and avoid\n\nthe risky update. Try as much as possible to move logic out of code that processes the\n\nupdate by using Slide Statements (223) and Extract Function (106) to separate the\n\nside­effect­free code from anything that performs the update. In APIs, use Separate\n\nQuery from Modifier (306) to ensure callers don’t need to call code that has side effects\n\nunless they really need to. We like to use Remove Setting Method (331) as soon as we\n\ncan—sometimes, just trying to find clients of a setter helps spot opportunities to reduce\n\nthe scope of a variable.\n\nMutable data that can be calculated elsewhere is particularly pungent. It’s not just a\n\nrich source of confusion, bugs, and missed dinners at home—it’s also unnecessary. We\n\nspray it with a concentrated solution of vinegar and Replace Derived Variable with\n\nQuery (248).\n\nMutable data isn’t a big problem when it’s a variable whose scope is just a couple of\n\nlines—but its risk increases as its scope grows. Use Combine Functions into Class (144)\n\nor Combine Functions into Transform (149) to limit how much code needs to update a\n\nvariable. If a variable contains some data with internal structure, it’s usually better to\n\nreplace the entire structure rather than modify it in place, using Change Reference to\n\nValue (252).\n\nDIVERGENT CHANGE\n\nWe structure our software to make change easier; after all, software is meant to be soft.\n\nWhen we make a change, we want to be able to jump to a single clear point in the\n\nsystem and make the change. When you can’t do this, you are smelling one of two\n\nclosely related pungencies.\n\nDivergent change occurs when one module is often changed in different ways for\n\ndifferent reasons. If you look at a module and say, “Well, I will have to change these\n\nthree functions every time I get a new database; I have to change these four functions\n\nevery time there is a new financial instrument,” this is an indication of divergent\n\nchange. The database interaction and financial processing problems are separate\n\ncontexts, and we can make our programming life better by moving such contexts into\n\nseparate modules. That way, when we have a change to one context, we only have to\n\nunderstand that one context and ignore the other. We always found this to be\n\nimportant, but now, with our brains shrinking with age, it becomes all the more\n\nimperative. Of course, you often discover this only after you’ve added a few databases\n\nor financial instruments; context boundaries are usually unclear in the early days of a\n\nprogram and continue to shift as a software system’s capabilities change.\n\nwww.EBooksWorld.ir\n\nIf the two aspects naturally form a sequence—for example, you get data from the\n\ndatabase and then apply your financial processing on it—then Split Phase (154)\n\nseparates the two with a clear data structure between them. If there’s more back­and­\n\nforth in the calls, then create appropriate modules and use Move Function (198) to\n\ndivide the processing up. If functions mix the two types of processing within\n\nthemselves, use Extract Function (106) to separate them before moving. If the modules\n\nare classes, then Extract Class (182) helps formalize how to do the split.\n\nSHOTGUN SURGERY\n\nShotgun surgery is similar to divergent change but is the opposite. You whiff this when,\n\nevery time you make a change, you have to make a lot of little edits to a lot of different\n\nclasses. When the changes are all over the place, they are hard to find, and it’s easy to\n\nmiss an important change.\n\nIn this case, you want to use Move Function (198) and Move Field (207) to put all the\n\nchanges into a single module. If you have a bunch of functions operating on similar\n\ndata, use Combine Functions into Class (144). If you have functions that are\n\ntransforming or enriching a data structure, use Combine Functions into Transform\n\n(149). Split Phase (154) is often useful here if the common functions can combine their\n\noutput for a consuming phase of logic.\n\nA useful tactic for shotgun surgery is to use inlining refactorings, such as Inline\n\nFunction (115) or Inline Class (186), to pull together poorly separated logic. You’ll end\n\nup with a Long Method or a Large Class, but can then use extractions to break it up into\n\nmore sensible pieces. Even though we are inordinately fond of small functions and\n\nclasses in our code, we aren’t afraid of creating something large as an intermediate step\n\nto reorganization.\n\nFEATURE ENVY\n\nWhen we modularize a program, we are trying to separate the code into zones to\n\nmaximize the interaction inside a zone and minimize interaction between zones. A\n\nclassic case of Feature Envy occurs when a function in one module spends more time\n\ncommunicating with functions or data inside another module than it does within its\n\nown module. We’ve lost count of the times we’ve seen a function invoking half­a­dozen\n\ngetter methods on another object to calculate some value. Fortunately, the cure for that\n\ncase is obvious: The function clearly wants to be with the data, so use Move Function\n\n(198) to get it there. Sometimes, only a part of a function suffers from envy, in which\n\ncase use Extract Function (106) on the jealous bit, and Move Function (198) to give it a\n\nwww.EBooksWorld.ir\n\ndream home.\n\nOf course not all cases are cut­and­dried. Often, a function uses features of several\n\nmodules, so which one should it live with? The heuristic we use is to determine which\n\nmodule has most of the data and put the function with that data. This step is often\n\nmade easier if you use Extract Function (106) to break the function into pieces that go\n\ninto different places.\n\nOf course, there are several sophisticated patterns that break this rule. From the Gang\n\nof Four [gof], Strategy and Visitor immediately leap to mind. Kent Beck’s Self\n\nDelegation [Beck SBPP] is another. Use these to combat the divergent change smell.\n\nThe fundamental rule of thumb is to put things together that change together. Data and\n\nthe behavior that references that data usually change together—but there are\n\nexceptions. When the exceptions occur, we move the behavior to keep changes in one\n\nplace. Strategy and Visitor allow you to change behavior easily because they isolate the\n\nsmall amount of behavior that needs to be overridden, at the cost of further indirection.\n\nDATA CLUMPS\n\nData items tend to be like children: They enjoy hanging around together. Often, you’ll\n\nsee the same three or four data items together in lots of places: as fields in a couple of\n\nclasses, as parameters in many method signatures. Bunches of data that hang around\n\ntogether really ought to find a home together. The first step is to look for where the\n\nclumps appear as fields. Use Extract Class (182) on the fields to turn the clumps into an\n\nobject. Then turn your attention to method signatures using Introduce Parameter\n\nObject (140) or Preserve Whole Object (319) to slim them down. The immediate benefit\n\nis that you can shrink a lot of parameter lists and simplify method calling. Don’t worry\n\nabout data clumps that use only some of the fields of the new object. As long as you are\n\nreplacing two or more fields with the new object, you’ll come out ahead.\n\nA good test is to consider deleting one of the data values. If you did this, would the\n\nothers make any sense? If they don’t, it’s a sure sign that you have an object that’s dying\n\nto be born.\n\nYou’ll notice that we advocate creating a class here, not a simple record structure. We\n\ndo this because using a class gives you the opportunity to make a nice perfume. You can\n\nnow look for cases of feature envy, which will suggest behavior that can be moved into\n\nyour new classes. We’ve often seen this as a powerful dynamic that creates useful\n\nclasses and can remove a lot of duplication and accelerate future development, allowing\n\nthe data to become productive members of society.\n\nwww.EBooksWorld.ir\n\nPRIMITIVE OBSESSION",
      "page_number": 85
    },
    {
      "number": 10,
      "title": "Segment 10 (pages 93-102)",
      "start_page": 93,
      "end_page": 102,
      "detection_method": "topic_boundary",
      "content": "PRIMITIVE OBSESSION\n\nMost programming environments are built on a widely used set of primitive types:\n\nintegers, floating point numbers, and strings. Libraries may add some additional small\n\nobjects such as dates. We find many programmers are curiously reluctant to create\n\ntheir own fundamental types which are useful for their domain—such as money,\n\ncoordinates, or ranges. We thus see calculations that treat monetary amounts as plain\n\nnumbers, or calculations of physical quantities that ignore units (adding inches to\n\nmillimeters), or lots of code doing if (a < upper && a > lower).\n\nStrings are particularly common petri dishes for this kind of odor: A telephone number\n\nis more than just a collection of characters. If nothing else, a proper type can often\n\ninclude consistent display logic for when it needs to be displayed in a user interface.\n\nRepresenting such types as strings is such a common stench that people call them\n\n“stringly typed” variables.\n\nYou can move out of the primitive cave into the centrally heated world of meaningful\n\ntypes by using Replace Primitive with Object (174). If the primitive is a type code\n\ncontrolling conditional behavior, use Replace Type Code with Subclasses (362)\n\nfollowed by Replace Conditional with Polymorphism (272).\n\nGroups of primitives that commonly appear together are data clumps and should be\n\ncivilized with Extract Class (182) and Introduce Parameter Object (140).\n\nREPEATED SWITCHES\n\nTalk to a true object­oriented evangelist and they’ll soon get onto the evils of switch\n\nstatements. They’ll argue that any switch statement you see is begging for Replace\n\nConditional with Polymorphism (272). We’ve even heard some people argue that all\n\nconditional logic should be replaced with polymorphism, tossing most ifs into the\n\ndustbin of history.\n\nEven in our more wild­eyed youth, we were never unconditionally opposed to the\n\nconditional. Indeed, the first edition of this book had a smell entitled “switch\n\nstatements.” The smell was there because in the late 90’s we found polymorphism sadly\n\nunderappreciated, and saw benefit in getting people to switch over.\n\nThese days there is more polymorphism about, and it isn’t the simple red flag that it\n\noften was fifteen years ago. Furthermore, many languages support more sophisticated\n\nforms of switch statements that use more than some primitive code as their base. So we\n\nnow focus on the repeated switch, where the same conditional switching logic (either in\n\nwww.EBooksWorld.ir\n\na switch/case statement or in a cascade of if/else statements) pops up in different\n\nplaces. The problem with such duplicate switches is that, whenever you add a clause,\n\nyou have to find all the switches and update them. Against the dark forces of such\n\nrepetition, polymorphism provides an elegant weapon for a more civilized codebase.\n\nLOOPS\n\nLoops have been a core part of programming since the earliest languages. But we feel\n\nthey are no more relevant today than bell­bottoms and flock wallpaper. We disdained\n\nthem at the time of the first edition—but Java, like most other languages at the time,\n\ndidn’t provide a better alternative. These days, however, first­class functions are widely\n\nsupported, so we can use Replace Loop with Pipeline (231) to retire those\n\nanachronisms. We find that pipeline operations, such as filter and map, help us quickly\n\nsee the elements that are included in the processing and what is done with them.\n\nLAZY ELEMENT\n\nWe like using program elements to add structure—providing opportunities for\n\nvariation, reuse, or just having more helpful names. But sometimes the structure isn’t\n\nneeded. It may be a function that’s named the same as its body code reads, or a class\n\nthat is essentially one simple function. Sometimes, this reflects a function that was\n\nexpected to grow and be popular later, but never realized its dreams. Sometimes, it’s a\n\nclass that used to pay its way, but has been downsized with refactoring. Either way,\n\nsuch program elements need to die with dignity. Usually this means using Inline\n\nFunction (115) or Inline Class (186). With inheritance, you can use Collapse Hierarchy\n\n(380).\n\nSPECULATIVE GENERALITY\n\nBrian Foote suggested this name for a smell to which we are very sensitive. You get it\n\nwhen people say, “Oh, I think we’ll need the ability to do this kind of thing someday”\n\nand thus add all sorts of hooks and special cases to handle things that aren’t required.\n\nThe result is often harder to understand and maintain. If all this machinery were being\n\nused, it would be worth it. But if it isn’t, it isn’t. The machinery just gets in the way, so\n\nget rid of it.\n\nIf you have abstract classes that aren’t doing much, use Collapse Hierarchy (380).\n\nUnnecessary delegation can be removed with Inline Function (115) and Inline Class\n\n(186). Functions with unused parameters should be subject to Change Function\n\nDeclaration (124) to remove those parameters. You should also apply Change Function\n\nwww.EBooksWorld.ir\n\nDeclaration (124) to remove any unneeded parameters, which often get tossed in for\n\nfuture variations that never come to pass.\n\nSpeculative generality can be spotted when the only users of a function or class are test\n\ncases. If you find such an animal, delete the test case and apply Remove Dead Code\n\n(237).\n\nTEMPORARY FIELD\n\nSometimes you see a class in which a field is set only in certain circumstances. Such\n\ncode is difficult to understand, because you expect an object to need all of its fields.\n\nTrying to understand why a field is there when it doesn’t seem to be used can drive you\n\nnuts.\n\nUse Extract Class (182) to create a home for the poor orphan variables. Use Move\n\nFunction (198) to put all the code that concerns the fields into this new class. You may\n\nalso be able to eliminate conditional code by using Introduce Special Case (289) to\n\ncreate an alternative class for when the variables aren’t valid.\n\nMESSAGE CHAINS\n\nYou see message chains when a client asks one object for another object, which the\n\nclient then asks for yet another object, which the client then asks for yet another\n\nanother object, and so on. You may see these as a long line of getThis methods, or as\n\na sequence of temps. Navigating this way means the client is coupled to the structure of\n\nthe navigation. Any change to the intermediate relationships causes the client to have to\n\nchange.\n\nThe move to use here is Hide Delegate (189). You can do this at various points in the\n\nchain. In principle, you can do this to every object in the chain, but doing this often\n\nturns every intermediate object into a middle man. Often, a better alternative is to see\n\nwhat the resulting object is used for. See whether you can use Extract Function (106) to\n\ntake a piece of the code that uses it and then Move Function (198) to push it down the\n\nchain. If several clients of one of the objects in the chain want to navigate the rest of the\n\nway, add a method to do that.\n\nSome people consider any method chain to be a terrible thing. We are known for our\n\ncalm, reasoned moderation. Well, at least in this case we are.\n\nMIDDLE MAN\n\nwww.EBooksWorld.ir\n\nOne of the prime features of objects is encapsulation—hiding internal details from the\n\nrest of the world. Encapsulation often comes with delegation. You ask a director\n\nwhether she is free for a meeting; she delegates the message to her diary and gives you\n\nan answer. All well and good. There is no need to know whether the director uses a\n\ndiary, an electronic gizmo, or a secretary to keep track of her appointments.\n\nc However, this can go too far. You look at a class’s interface and find half the methods\n\nare delegating to this other class. After a while, it is time to use Remove Middle Man\n\n(192) and talk to the object that really knows what’s going on. If only a few methods\n\naren’t doing much, use Inline Function (115) to inline them into the caller. If there is\n\nadditional behavior, you can use Replace Superclass with Delegate (399) or Replace\n\nSubclass with Delegate (381) to fold the middle man into the real object. That allows\n\nyou to extend behavior without chasing all that delegation.\n\nINSIDER TRADING\n\nSoftware people like strong walls between their modules and complain bitterly about\n\nhow trading data around too much increases coupling. To make things work, some\n\ntrade has to occur, but we need to reduce it to a minimum and keep it all above board.\n\nModules that whisper to each other by the coffee machine need to be separated by using\n\nMove Function (198) and Move Field (207) to reduce the need to chat. If modules have\n\ncommon interests, try to create a third module to keep that commonality in a well­\n\nregulated vehicle, or use Hide Delegate (189) to make another module act as an\n\nintermediary.\n\nInheritance can often lead to collusion. Subclasses are always going to know more\n\nabout their parents than their parents would like them to know. If it’s time to leave\n\nhome, apply Replace Subclass with Delegate (381) or Replace Superclass with\n\nDelegate (399).\n\nLARGE CLASS\n\nWhen a class is trying to do too much, it often shows up as too many fields. When a\n\nclass has too many fields, duplicated code cannot be far behind.\n\nYou can Extract Class (182) to bundle a number of the variables. Choose variables to go\n\ntogether in the component that makes sense for each. For example, “depositAmount”\n\nand “depositCurrency” are likely to belong together in a component. More generally,\n\ncommon prefixes or suffixes for some subset of the variables in a class suggest the\n\nopportunity for a component. If the component makes sense with inheritance, you’ll\n\nwww.EBooksWorld.ir\n\nfind Extract Superclass (375) or Replace Type Code with Subclasses (362) (which\n\nessentially is extracting a subclass) are often easier.\n\nSometimes a class does not use all of its fields all of the time. If so, you may be able to\n\ndo these extractions many times.\n\nAs with a class with too many instance variables, a class with too much code is a prime\n\nbreeding ground for duplicated code, chaos, and death. The simplest solution (have we\n\nmentioned that we like simple solutions?) is to eliminate redundancy in the class itself.\n\nIf you have five hundred­line methods with lots of code in common, you may be able to\n\nturn them into five ten­line methods with another ten two­line methods extracted from\n\nthe original.\n\nThe clients of such a class are often the best clue for splitting up the class. Look at\n\nwhether clients use a subset of the features of the class. Each subset is a possible\n\nseparate class. Once you’ve identified a useful subset, use Extract Class (182), Extract\n\nSuperclass (375), or Replace Type Code with Subclasses (362) to break it out.\n\nALTERNATIVE CLASSES WITH DIFFERENT INTERFACES\n\nOne of the great benefits of using classes is the support for substitution, allowing one\n\nclass to swap in for another in times of need. But this only works if their interfaces are\n\nthe same. Use Change Function Declaration (124) to make functions match up. Often,\n\nthis doesn’t go far enough; keep using Move Function (198) to move behavior into\n\nclasses until the protocols match. If this leads to duplication, you may be able to use\n\nExtract Superclass (375) to atone.\n\nDATA CLASS\n\nThese are classes that have fields, getting and setting methods for the fields, and\n\nnothing else. Such classes are dumb data holders and are often being manipulated in\n\nfar too much detail by other classes. In some stages, these classes may have public\n\nfields. If so, you should immediately apply Encapsulate Record (162) before anyone\n\nnotices. Use Remove Setting Method (331) on any field that should not be changed.\n\nLook for where these getting and setting methods are used by other classes. Try to use\n\nMove Function (198) to move behavior into the data class. If you can’t move a whole\n\nfunction, use Extract Function (106) to create a function that can be moved.\n\nData classes are often a sign of behavior in the wrong place, which means you can make\n\nbig progress by moving it from the client into the data class itself. But there are\n\nwww.EBooksWorld.ir\n\nexceptions, and one of the best exceptions is a record that’s being used as a result\n\nrecord from a distinct function invocation. A good example of this is the intermediate\n\ndata structure after you’ve applied Split Phase (154). A key characteristic of such a\n\nresult record is that it’s immutable (at least in practice). Immutable fields don’t need to\n\nbe encapsulated and information derived from immutable data can be represented as\n\nfields rather than getting methods.\n\nREFUSED BEQUEST\n\nSubclasses get to inherit the methods and data of their parents. But what if they don’t\n\nwant or need what they are given? They are given all these great gifts and pick just a few\n\nto play with.\n\nThe traditional story is that this means the hierarchy is wrong. You need to create a new\n\nsibling class and use Push Down Method (359) and Push Down Field (361) to push all\n\nthe unused code to the sibling. That way the parent holds only what is common. Often,\n\nyou’ll hear advice that all superclasses should be abstract.\n\nYou’ll guess from our snide use of “traditional” that we aren’t going to advise this—at\n\nleast not all the time. We do subclassing to reuse a bit of behavior all the time, and we\n\nfind it a perfectly good way of doing business. There is a smell—we can’t deny it—but\n\nusually it isn’t a strong smell. So, we say that if the refused bequest is causing confusion\n\nand problems, follow the traditional advice. However, don’t feel you have to do it all the\n\ntime. Nine times out of ten this smell is too faint to be worth cleaning.\n\nThe smell of refused bequest is much stronger if the subclass is reusing behavior but\n\ndoes not want to support the interface of the superclass. We don’t mind refusing\n\nimplementations—but refusing interface gets us on our high horses. In this case,\n\nhowever, don’t fiddle with the hierarchy; you want to gut it by applying Replace\n\nSubclass with Delegate (381) or Replace Superclass with Delegate (399).\n\nCOMMENTS\n\nDon’t worry, we aren’t saying that people shouldn’t write comments. In our olfac­tory\n\nanalogy, comments aren’t a bad smell; indeed they are a sweet smell. The reason we\n\nmention comments here is that comments are often used as a deodorant. It’s surprising\n\nhow often you look at thickly commented code and notice that the comments are there\n\nbecause the code is bad.\n\nComments lead us to bad code that has all the rotten whiffs we’ve discussed in the rest\n\nof this chapter. Our first action is to remove the bad smells by refactoring. When we’re\n\nwww.EBooksWorld.ir\n\nfinished, we often find that the comments are superfluous.\n\nIf you need a comment to explain what a block of code does, try Extract Function (106).\n\nIf the method is already extracted but you still need a comment to explain what it does,\n\nuse Change Function Declaration (124) to rename it. If you need to state some rules\n\nabout the required state of the system, use Introduce Assertion (302).\n\nWhen you feel the need to write a comment, first try to refactor the code so\n\nthat any comment becomes superfluous.\n\nA good time to use a comment is when you don’t know what to do. In addition to\n\ndescribing what is going on, comments can indicate areas in which you aren’t sure. A\n\ncomment can also explain why you did something. This kind of information helps\n\nfuture modifiers, especially forgetful ones.\n\nwww.EBooksWorld.ir\n\nChapter 4 Building Tests\n\nHistory\n\nTopics\n\nRefactoring is a valuable tool, but it can’t come alone. To do refactoring properly, I need\n\na solid suite of tests to spot my inevitable mistakes. Even with automated refactoring\n\nTutorials\n\ntools, many of my refactorings will still need checking via a test suite.\n\nOffers & Deals\n\nI don’t find this to be a disadvantage. Even without refactoring, writing good tests\n\nincreases my effectiveness as a programmer. This was a surprise for me and is\n\nHighlights\n\ncounterintuitive for most programmers—so it’s worth explaining why.\n\nSettings\n\nTHE VALUE OF SELF-TESTING CODE\n\nSupport\n\nIf you look at how most programmers spend their time, you’ll find that writing code is\n\nSign Out\n\nactually quite a small fraction. Some time is spent figuring out what ought to be going\n\non, some time is spent designing, but most time is spent debugging. I’m sure every\n\nreader can remember long hours of debugging—often, well into the night. Every\n\nprogrammer can tell a story of a bug that took a whole day (or more) to find. Fixing the\n\nbug is usually pretty quick, but finding it is a nightmare. And then, when you do fix a\n\nbug, there’s always a chance that another one will appear and that you might not even\n\nnotice it till much later. And you’ll spend ages finding that bug.\n\nThe event that started me on the road to self­testing code was a talk at OOPSLA in\n\n1992. Someone (I think it was “Bedarra” Dave Thomas) said offhandedly, “Classes\n\nshould contain their own tests.” So I decided to incorporate tests into the code base\n\ntogether with the production code. As I was also doing iterative development, I tried\n\nadding tests as I completed each iteration. The project on which I was working at that\n\ntime was quite small, so we put out iterations every week or so. Running the tests\n\nbecame fairly straightforward—but although it was easy, it was still pretty boring. This\n\nwas because every test produced output to the console that I had to check. Now I’m a\n\npretty lazy person and am prepared to work quite hard in order to avoid work. I\n\nrealized that, instead of looking at the screen to see if it printed out some information\n\nfrom the model, I could get the computer to make that test. All I had to do was put the\n\nwww.EBooksWorld.ir\n\noutput I expected in the test code and do a comparison. Now I could run the tests and\n\nthey would just print “OK” to the screen if all was well. The software was now self­\n\ntesting.\n\nMake sure all tests are fully automatic and that they check their own results.\n\nNow it was easy to run tests—as easy as compiling. So I started to run tests every time I\n\ncompiled. Soon, I began to notice my productivity had shot upward. I realized that I\n\nwasn’t spending so much time debugging. If I added a bug that was caught by a\n\nprevious test, it would show up as soon as I ran that test. The test had worked before, so\n\nI would know that the bug was in the work I had done since I last tested. And I ran the\n\ntests frequently—which means only a few minutes had elapsed. I thus knew that the\n\nsource of the bug was the code I had just written. As it was a small amount of code that\n\nwas still fresh in my mind, the bug was easy to find. Bugs that would have otherwise\n\ntaken an hour or more to find now took a couple of minutes at most. Not only was my\n\nsoftware self­testing, but by running the tests frequently I had a powerful bug detector.\n\nAs I noticed this, I became more aggressive about doing the tests. Instead of waiting for\n\nthe end of an increment, I would add the tests immediately after writing a bit of\n\nfunction. Every day I would add a couple of new features and the tests to test them. I\n\nhardly ever spent more than a few minutes hunting for a regression bug.\n\nA suite of tests is a powerful bug detector that decapitates the time it takes to\n\nfind bugs.\n\nTools for writing and organizing these tests have developed a great deal since my\n\nexperiments. While flying from Switzerland to Atlanta for OOPSLA 1997, Kent Beck\n\npaired with Erich Gamma to port his unit testing framework from Smalltalk to Java.\n\nThe resulting framework, called JUnit, has been enormously influential for program\n\ntesting, inspiring a huge variety of similar tools [mf­xunit] in lots of different languages.\n\nAdmittedly, it is not so easy to persuade others to follow this route. Writing the tests\n\nmeans a lot of extra code to write. Unless you have actually experienced how it speeds\n\nprogramming, self­testing does not seem to make sense. This is not helped by the fact\n\nthat many people have never learned to write tests or even to think about tests. When\n\ntests are manual, they are gut­wrenchingly boring. But when they are automatic, tests\n\ncan actually be quite fun to write.\n\nwww.EBooksWorld.ir\n\nIn fact, one of the most useful times to write tests is before I start programming. When\n\nI need to add a feature, I begin by writing the test. This isn’t as backward as it sounds.\n\nBy writing the test, I’m asking myself what needs to be done to add the function.\n\nWriting the test also concentrates me on the interface rather than the implementation\n\n(always a good thing). It also means I have a clear point at which I’m done coding—\n\nwhen the test works.\n\nKent Beck baked this habit of writing the test first into a technique called Test­Driven\n\nDevelopment (TDD) [mf­tdd]. The Test­Driven Development approach to\n\nprogramming relies on short cycles of writing a (failing) test, writing the code to make\n\nthat test work, and refactoring to ensure the result is as clean as possible. This test­\n\ncode­refactor cycle should occur many times per hour, and can be a very productive and\n\ncalming way to write code. I’m not going to discuss it further here, but I do use and\n\nwarmly recommend it.\n\nThat’s enough of the polemic. Although I believe everyone would benefit by writing self­\n\ntesting code, it is not the point of this book. This book is about refactoring. Refactoring\n\nrequires tests. If you want to refactor, you have to write tests. This chapter gives you a\n\nstart in doing this for JavaScript. This is not a testing book, so I’m not going to go into\n\nmuch detail. I’ve found, however, that with testing a remarkably small amount of work\n\ncan have surprisingly big benefits.\n\nAs with everything else in this book, I describe the testing approach using examples.\n\nWhen I develop code, I write the tests as I go. But sometimes, I need to refactor some\n\ncode without tests—then I have to make the code self­testing before I begin.\n\nSAMPLE CODE TO TEST\n\nHere’s some code to look at and test. The code supports a simple application that allows\n\na user to examine and manipulate a production plan. The (crude) UI looks like this:\n\nwww.EBooksWorld.ir",
      "page_number": 93
    },
    {
      "number": 11,
      "title": "Segment 11 (pages 103-112)",
      "start_page": 103,
      "end_page": 112,
      "detection_method": "topic_boundary",
      "content": "The production plan has a demand and price for each province. Each province has\n\nproducers, each of which can produce a certain number of units at a particular price.\n\nThe UI also shows how much revenue each producer would earn if they sell all their\n\nproduction. At the bottom, the screen shows the shortfall in production (the demand\n\nminus the total production) and the profit for this plan. The UI allows the user to\n\nmanipulate the demand, price, and the individual producer’s production and costs to\n\nsee the effect on the production shortfall and profits. Whenever a user changes any\n\nnumber in the display, all the others update immediately.\n\nI’m showing a user interface here, so you can sense how the software is used, but I’m\n\nonly going to concentrate on the business logic part of the software—that is, the classes\n\nthat calculate the profit and the shortfall, not the code that generates the HTML and\n\nhooks up the field changes to the underlying business logic. This chapter is just an\n\nintroduction to the world of self­testing code, so it makes sense for me to start with the\n\neasiest case—which is code that doesn’t involve user interface, persistence, or external\n\nservice interaction. Such separation, however, is a good idea in any case: Once this kind\n\nof business logic gets at all complicated, I will separate it from the UI mechanics so I\n\ncan more easily reason about it and test it.\n\nThis business logic code involves two classes: one that represents a single producer, and\n\nthe other that represents a whole province. The province’s constructor takes a\n\nJavaScript object—one we could imagine being supplied by a JSON document.\n\nHere’s the code that loads the province from the JSON data:\n\nclass Province…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nconstructor(doc) { this._name = doc.name; this._producers = []; this._totalProduction = 0; this._demand = doc.demand; this._price = doc.price; doc.producers.forEach(d => this.addProducer(new Producer(this, d))); } addProducer(arg) { this._producers.push(arg); this._totalProduction += arg.production; }\n\nThis function creates suitable JSON data. I can create a sample province for testing by\n\nconstructing a province object with the result of this function.\n\ntop level…\n\nClick here to view code image\n\nfunction sampleProvinceData() { return { name: \"Asia\", producers: [ {name: \"Byzantium\", cost: 10, production: 9}, {name: \"Attalia\", cost: 12, production: 10}, {name: \"Sinope\", cost: 10, production: 6}, ], demand: 30, price: 20 }; }\n\nThe province class has accessors for the various data values:\n\nclass Province…\n\nClick here to view code image\n\nget name() {return this._name;} get producers() {return this._producers.slice();} get totalProduction() {return this._totalProduction;} set totalProduction(arg) {this._totalProduction = arg;} get demand() {return this._demand;} set demand(arg) {this._demand = parseInt(arg);}\n\nwww.EBooksWorld.ir\n\nget price() {return this._price;} set price(arg) {this._price = parseInt(arg);}\n\nThe setters will be called with strings from the UI that contain the numbers, so I need\n\nto parse the numbers to use them reliably in calculations.\n\nThe producer class is mostly a simple data holder:\n\nclass Producer…\n\nClick here to view code image\n\nconstructor(aProvince, data) { this._province = aProvince; this._cost = data.cost; this._name = data.name; this._production = data.production || 0; } get name() {return this._name;} get cost() {return this._cost;} set cost(arg) {this._cost = parseInt(arg);}\n\nget production() {return this._production;} set production(amountStr) { const amount = parseInt(amountStr); const newProduction = Number.isNaN(amount) ? 0 : amount; this._province.totalProduction += newProduction ­ this._production; this._production = newProduction; }\n\nThe way that set production updates the derived data in the province is ugly, and\n\nwhenever I see that I want to refactor to remove it. But I have to write tests before that I\n\ncan refactor it.\n\nThe calculation for the shortfall is simple.\n\nclass Province…\n\nClick here to view code image\n\nget shortfall() { return this._demand ­ this.totalProduction; }\n\nThat for the profit is a bit more involved.\n\nwww.EBooksWorld.ir\n\nclass Province…\n\nClick here to view code image\n\nget profit() { return this.demandValue ­ this.demandCost; } get demandCost() { let remainingDemand = this.demand; let result = 0; this.producers .sort((a,b) => a.cost ­ b.cost) .forEach(p => { const contribution = Math.min(remainingDemand, p.production); remainingDemand ­= contribution; result += contribution * p.cost; }); return result; } get demandValue() { return this.satisfiedDemand * this.price; } get satisfiedDemand() { return Math.min(this._demand, this.totalProduction); }\n\nA FIRST TEST\n\nTo test this code, I’ll need some sort of testing framework. There are many out there,\n\neven just for JavaScript. The one I’ll use is Mocha [mocha], which is reasonably\n\ncommon and well­regarded. I won’t go into a full explanation of how to use the\n\nframework, just show some example tests with it. You should be able to adapt, easily\n\nenough, a different framework to build similar tests.\n\nHere is a simple test for the shortfall calculation:\n\nClick here to view code image\n\ndescribe('province', function() { it('shortfall', function() { const asia = new Province(sampleProvinceData()); assert.equal(asia.shortfall, 5); }); });\n\nThe Mocha framework divides up the test code into blocks, each grouping together a\n\nwww.EBooksWorld.ir\n\nsuite of tests. Each test appears in an it block. For this simple case, the test has two\n\nsteps. The first step sets up some fixture—data and objects that are needed for the test:\n\nin this case, a loaded province object. The second line verifies some characteristic of\n\nthat fixture—in this case, that the shortfall is the amount that should be expected given\n\nthe initial data.\n\nDifferent developers use the descriptive strings in the describe and it blocks\n\ndifferently. Some would write a sentence that explains what the test is testing, but\n\nothers prefer to leave them empty, arguing that the descriptive sentence is just\n\nduplicating the code in the same way a comment does. I like to put in just enough to\n\nidentify which test is which when I get failures.\n\nIf I run this test in a NodeJS console, the output looks like this:\n\n’’’’’’’’’’’’’’\n\n1 passing (61ms)\n\nNote the simplicity of the feedback—just a summary of how many tests are run and how\n\nmany have passed.\n\nAlways make sure a test will fail when it should.\n\nWhen I write a test against existing code like this, it’s nice to see that all is well—but I’m\n\nnaturally skeptical. Particularly, once I have a lot of tests running, I’m always nervous\n\nthat a test isn’t really exercising the code the way I think it is, and thus won’t catch a\n\nbug when I need it to. So I like to see every test fail at least once when I write it. My\n\nfavorite way of doing that is to temporarily inject a fault into the code, for example:\n\nclass Province…\n\nClick here to view code image\n\nget shortfall() { return this._demand ­ this.totalProduction * 2; }\n\nHere’s what the console now looks like:\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\n!\n\n0 passing (72ms) 1 failing\n\n1) province shortfall: AssertionError: expected ­20 to equal 5 at Context.<anonymous> (src/tester.js:10:12)\n\nThe framework indicates which test failed and gives some information about the nature\n\nof the failure—in this case, what value was expected and what value actually turned up.\n\nI therefore notice at once that something failed—and I can immediately see which tests\n\nfailed, giving me a clue as to what went wrong (and, in this case, confirming the failure\n\nwas where I injected it).\n\nRun tests frequently. Run those exercising the code you’re working on at least\n\nevery few minutes; run all tests at least daily.\n\nIn a real system, I might have thousands of tests. A good test framework allows me to\n\nrun them easily and to quickly see if any have failed. This simple feedback is essential to\n\nself­testing code. When I work, I’ll be running tests very frequently—checking progress\n\nwith new code or checking for mistakes with refactoring.\n\nThe Mocha framework can use different libraries, which it calls assertion libraries, to\n\nverify the fixture for a test. Being JavaScript, there are a quadzillion of them out there,\n\nsome of which may still be current when you’re reading this. The one I’m using at the\n\nmoment is Chai [chai]. Chai allows me to write my validations either using an “assert”\n\nstyle:\n\nClick here to view code image\n\ndescribe('province', function() { it('shortfall', function() { const asia = new Province(sampleProvinceData()); assert.equal(asia.shortfall, 5); }); });\n\nor an “expect” style:\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\ndescribe('province', function() { it('shortfall', function() { const asia = new Province(sampleProvinceData()); expect(asia.shortfall).equal(5); }); });\n\nI usually prefer the assert style, but at the moment I mostly use the expect style while\n\nworking in JavaScript.\n\nDifferent environments provide different ways to run tests. When I’m programming in\n\nJava, I use an IDE that gives me a graphical test runner. Its progress bar is green as\n\nlong as all the tests pass, and turns red should any of them fail. My colleagues often use\n\nthe phrases “green bar” and “red bar” to describe the state of tests. I might say, “Never\n\nrefactor on a red bar,” meaning you shouldn’t be refactoring if your test suite has a\n\nfailing test. Or, I might say, “Revert to green” to say you should undo recent changes\n\nand go back to the last state where you had all­passing test suite (usually by going back\n\nto a recent version­control checkpoint).\n\nGraphical test runners are nice, but not essential. I usually have my tests set to run\n\nfrom a single key in Emacs, and observe the text feedback in my compilation window.\n\nThe key point is that I can quickly see if my tests are all OK.\n\nADD ANOTHER TEST\n\nNow I’ll continue adding more tests. The style I follow is to look at all the things the\n\nclass should do and test each one of them for any conditions that might cause the class\n\nto fail. This is not the same as testing every public method, which is what some\n\nprogrammers advocate. Testing should be risk­driven; remember, I’m trying to find\n\nbugs, now or in the future. Therefore I don’t test accessors that just read and write a\n\nfield: They are so simple that I’m not likely to find a bug there.\n\nThis is important because trying to write too many tests usually leads to not writing\n\nenough. I get many benefits from testing even if I do only a little testing. My focus is to\n\ntest the areas that I’m most worried about going wrong. That way I get the most benefit\n\nfor my testing effort.\n\nIt is better to write and run incomplete tests than not to run complete tests.\n\nSo I’ll start by hitting the other main output for this code—the profit calculation. Again,\n\nwww.EBooksWorld.ir\n\nI’ll just do a basic test for profit on my initial fixture.\n\nClick here to view code image\n\ndescribe('province', function() { it('shortfall', function() { const asia = new Province(sampleProvinceData()); expect(asia.shortfall).equal(5); }); it('profit', function() { const asia = new Province(sampleProvinceData()); expect(asia.profit).equal(230); }); });\n\nThat shows the final result, but the way I got it was by first setting the expected value to\n\na placeholder, then replacing it with whatever the program produced (230). I could\n\nhave calculated it by hand myself, but since the code is supposed to be working\n\ncorrectly, I’ll just trust it for now. Once I have that new test working correctly, I break it\n\nby altering the profit calculation with a spurious * 2. I satisfy myself that the test fails\n\nas it should, then revert my injected fault. This pattern—write with a placeholder for the\n\nexpected value, replace the placeholder with the code’s actual value, inject a fault, revert\n\nthe fault—is a common one I use when adding tests to existing code.\n\nThere is some duplication between these tests—both of them set up the fixture with the\n\nsame first line. Just as I’m suspicious of duplicated code in regular code, I’m suspicious\n\nof it in test code, so will look to remove it by factoring to a common place. One option is\n\nto raise the constant to the outer scope.\n\nClick here to view code image\n\ndescribe('province', function() { const asia = new Province(sampleProvinceData()); // DON'T DO THIS it('shortfall', function() { expect(asia.shortfall).equal(5); }); it('profit', function() { expect(asia.profit).equal(230); }); });\n\nBut as the comment indicates, I never do this. It will work for the moment, but it\n\nintroduces a petri dish that’s primed for one of the nastiest bugs in testing—a shared\n\nfixture which causes tests to interact. The const keyword in JavaScript only means the\n\nwww.EBooksWorld.ir\n\nreference to asia is constant, not the content of that object. Should a future test\n\nchange that common object, I’ll end up with intermittent test failures due to tests\n\ninteracting through the shared fixture, yielding different results depending on what\n\norder the tests are run in. That’s a nondeterminism in the tests that can lead to long and\n\ndifficult debugging at best, and a collapse of confidence in the tests at worst. Instead, I\n\nprefer to do this:\n\nClick here to view code image\n\ndescribe('province', function() { let asia; beforeEach(function() { asia = new Province(sampleProvinceData()); }); it('shortfall', function() { expect(asia.shortfall).equal(5); }); it('profit', function() { expect(asia.profit).equal(230); }); });\n\nThe beforeEach clause is run before each test runs, clearing out asia and setting it to\n\na fresh value each time. This way I build a fresh fixture before each test is run, which\n\nkeeps the tests isolated and prevents the nondeterminism that causes so much trouble.\n\nWhen I give this advice, some people are concerned that building a fresh fixture every\n\ntime will slow down the tests. Most of the time, it won’t be noticeable. If it is a problem,\n\nI’d consider a shared fixture, but then I will need to be really careful that no test ever\n\nchanges it. I can also use a shared fixture if I’m sure it is truly immutable. But my reflex\n\nis to use a fresh fixture because the debugging cost of making a mistake with a shared\n\nfixture has bit me too often in the past.\n\nGiven I run the setup code in beforeEach with every test, why not leave the setup\n\ncode inside the individual it blocks? I like my tests to all operate on a common bit of\n\nfixture, so I can become familiar with that standard fixture and see the various\n\ncharacteristics to test on it. The presence of the beforeEach block signals to the\n\nreader that I’m using a standard fixture. You can then look at all the tests within the\n\nscope of that describe block and know they all take the same base data as a starting\n\npoint.\n\nMODIFYING THE FIXTURE\n\nwww.EBooksWorld.ir\n\nSo far, the tests I’ve written show how I probe the properties of the fixture once I’ve\n\nloaded it. But in use, that fixture will be regularly updated by the users as they change\n\nvalues.\n\nMost of the updates are simple setters, and I don’t usually bother to test those as there’s\n\nlittle chance they will be the source of a bug. But there is some complicated behavior\n\naround Producer’s production setter, so I think that’s worth a test.\n\ndescribe(’province’…\n\nClick here to view code image\n\nit('change production', function() { asia.producers[0].production = 20; expect(asia.shortfall).equal(­6); expect(asia.profit).equal(292); });\n\nThis is a common pattern. I take the initial standard fixture that’s set up by the\n\nbeforeEach block, I exercise that fixture for the test, then I verify the fixture has\n\ndone what I think it should have done. If you read much about testing, you’ll hear these\n\nphases described variously as setup­exercise­verify, given­when­then, or arrange­act­\n\nassert. Sometimes you’ll see all the steps present within the test itself, in other cases the\n\ncommon early phases can be pushed out into standard setup routines such as\n\nbeforeEach.\n\n(There is an implicit fourth phase that’s usually not mentioned: teardown. Teardown\n\nremoves the fixture between tests so that different tests don’t interact with each other.\n\nBy doing all my setup in beforeEach, I allow the test framework to implicitly tear\n\ndown my fixture between tests, so I can take the teardown phase for granted. Most\n\nwriters on tests gloss over teardown—reasonably so, since most of the time we ignore it.\n\nBut occasionally, it can be important to have an explicit teardown operation,\n\nparticularly if we have a fixture that we have to share between tests because it’s slow to\n\ncreate.)\n\nIn this test, I’m verifying two different characteristics in a single it clause. As a general\n\nrule, it’s wise to have only a single verify statement in each it clause. This is because\n\nthe test will fail on the first verification failure—which can often hide useful information\n\nwhen you’re figuring out why a test is broken. In this case, I feel the two are closely\n\nenough connected that I’m happy to have them in the same test. Should I wish to\n\nseparate them into separate it clauses, I can do that later.\n\nwww.EBooksWorld.ir\n\nPROBING THE BOUNDARIES",
      "page_number": 103
    },
    {
      "number": 12,
      "title": "Segment 12 (pages 113-120)",
      "start_page": 113,
      "end_page": 120,
      "detection_method": "topic_boundary",
      "content": "PROBING THE BOUNDARIES\n\nSo far my tests have focused on regular usage, often referred to as “happy path”\n\nconditions where everything is going OK and things are used as expected. But it’s also\n\ngood to throw tests at the boundaries of these conditions—to see what happens when\n\nthings might go wrong.\n\nWhenever I have a collection of something, such as producers in this example, I like to\n\nsee what happens when it’s empty.\n\nClick here to view code image\n\ndescribe('no producers', function() { let noProducers; beforeEach(function() { const data = { name: \"No proudcers\", producers: [], demand: 30, price: 20 }; noProducers = new Province(data); }); it('shortfall', function() { expect(noProducers.shortfall).equal(30); }); it('profit', function() { expect(noProducers.profit).equal(0); });\n\nWith numbers, zeros are good things to probe:\n\ndescribe(’province’…\n\nClick here to view code image\n\nit('zero demand', function() { asia.demand = 0; expect(asia.shortfall).equal(­25); expect(asia.profit).equal(0); });\n\nas are negatives:\n\ndescribe(’province’…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nit('negative demand', function() { asia.demand = ­1; expect(asia.shortfall).equal(­26); expect(asia.profit).equal(­10); });\n\nAt this point, I may start to wonder if a negative demand resulting in a negative profit\n\nreally makes any sense for the domain. Shouldn’t the minimum demand be zero? In\n\nwhich case, perhaps, the setter should react differently to a negative argument—raising\n\nan error or setting the value to zero anyway. These are good questions to ask, and\n\nwriting tests like this helps me think about how the code ought to react to boundary\n\ncases.\n\nThink of the boundary conditions under which things might go wrong and\n\nconcentrate your tests there.\n\nThe setters take a string from the fields in the UI, which are constrained to only accept\n\nnumbers—but they can still be blank, so I should have tests that ensure the code\n\nresponds to the blanks the way I want it to.\n\ndescribe(’province’…\n\nClick here to view code image\n\nit('empty string demand', function() { asia.demand = \"\"; expect(asia.shortfall).NaN; expect(asia.profit).NaN; });\n\nNotice how I’m playing the part of an enemy to my code. I’m actively thinking about\n\nhow I can break it. I find that state of mind to be both productive and fun. It indulges\n\nthe mean­spirited part of my psyche.\n\nThis one is interesting:\n\nClick here to view code image\n\ndescribe('string for producers', function() {\n\nwww.EBooksWorld.ir\n\nit('', function() { const data = { name: \"String producers\", producers: \"\", demand: 30, price: 20 }; const prov = new Province(data); expect(prov.shortfall).equal(0); });\n\nThis doesn’t produce a simple failure reporting that the shortfall isn’t 0. Here’s the\n\nconsole output:\n\nClick here to view code image\n\n’’’’’’’’’!\n\n9 passing (74ms) 1 failing\n\n1) string for producers : TypeError: doc.producers.forEach is not a function at new Province (src/main.js:22:19) at Context.<anonymous> (src/tester.js:86:18)\n\nMocha treats this as a failure—but many testing frameworks distinguish between this\n\nsituation, which they call an error, and a regular failure. A failure indicates a verify step\n\nwhere the actual value is outside the bounds expected by the verify statement. But this\n\nerror is a different animal—it’s an exception raised during an earlier phase (in this\n\ncase, the setup). This looks like an exception that the authors of the code hadn’t\n\nanticipated, so we get an error sadly familiar to JavaScript programmers (“… is not a\n\nfunction”).\n\nHow should the code respond to such a case? One approach is to add some handling\n\nthat would give a better error response—either raising a more meaningful error\n\nmessage, or just setting producers to an empty array (with perhaps a log message).\n\nBut there may also be valid reasons to leave it as it is. Perhaps the input object is\n\nproduced by a trusted source—such as another part of the same code base. Putting in\n\nlots of validation checks between modules in the same code base can result in duplicate\n\nchecks that cause more trouble than they are worth, especially if they duplicate\n\nvalidation done elsewhere. But if that input object is coming in from an external source,\n\nsuch as a JSON­encoded request, then validation checks are needed, and should be\n\ntested. In either case, writing tests like this raises these kinds of questions.\n\nwww.EBooksWorld.ir\n\nIf I’m writing tests like this before refactoring, I would probably discard this test.\n\nRefactoring should preserve observable behavior; an error like this is outside the\n\nbounds of observable, so I need not be concerned if my refactoring changes the code’s\n\nresponse to this condition.\n\nIf this error could lead to bad data running around the program, causing a failure that\n\nwill be hard to debug, I might use Introduce Assertion (302) to fail fast. I don’t add\n\ntests to catch such assertion failures, as they are themselves a form of test.\n\nDon’t let the fear that testing can’t catch all bugs stop you from writing tests\n\nthat catch most bugs.\n\nWhen do you stop? I’m sure you have heard many times that you cannot prove that a\n\nprogram has no bugs by testing. That’s true, but it does not affect the ability of testing\n\nto speed up programming. I’ve seen various proposed rules to ensure you have tested\n\nevery combination of everything. It’s worth taking a look at these—but don’t let them\n\nget to you. There is a law of diminishing returns in testing, and there is the danger that\n\nby trying to write too many tests you become discouraged and end up not writing any.\n\nYou should concentrate on where the risk is. Look at the code and see where it becomes\n\ncomplex. Look at a function and consider the likely areas of error. Your tests will not\n\nfind every bug, but as you refactor, you will understand the program better and thus\n\nfind more bugs. Although I always start refactoring with a test suite, I invariably add to\n\nit as I go along.\n\nMUCH MORE THAN THIS\n\nThat’s as far as I’m going to go with this chapter—after all, this is a book on refactoring,\n\nnot on testing. But testing is an important topic, both because it’s a necessary\n\nfoundation for refactoring and because it’s a valuable tool in its own right. While I’ve\n\nbeen happy to see the growth of refactoring as a programming practice since I wrote\n\nthis book, I’ve been even happier to see the change in attitudes to testing. Previously\n\nseen as the responsibility of a separate (and inferior) group, testing is now increasingly\n\na first­class concern of any decent software developer. Architectures often are, rightly,\n\njudged on their testability.\n\nThe kinds of tests I’ve shown here are unit tests, designed to operate on a small area of\n\nthe code and run fast. They are the backbone of self­testing code; most tests in such a\n\nsystem are unit tests. There are other kinds of tests too, focusing on integration\n\nbetween components, exercising multiple levels of the software together, looking for\n\nwww.EBooksWorld.ir\n\nperformance issues, etc. (And even more varied than the types of tests are the\n\narguments people get into about how to classify tests.)\n\nLike most aspects of programming, testing is an iterative activity. Unless you are either\n\nvery skilled or very lucky, you won’t get your tests right the first time. I find I’m\n\nconstantly working on the test suite—just as much as I work on the main code.\n\nNaturally, this means adding new tests as I add new features, but it also involves\n\nlooking at the existing tests. Are they clear enough? Do I need to refactor them so I can\n\nmore easily understand what they are doing? Have I got the right tests? An important\n\nhabit to get into is to respond to a bug by first writing a test that clearly reveals the bug.\n\nOnly after I have the test do I fix the bug. By having the test, I know the bug will stay\n\ndead. I also think about that bug and its test: Does it give me clues to other gaps in the\n\ntest suite?\n\nWhen you get a bug report, start by writing a unit test that exposes the bug.\n\nA common question is, “How much testing is enough?” There’s no good measurement\n\nfor this. Some people advocate using test coverage [mf­tc] as a measure, but test\n\ncoverage analysis is only good for identifying untested areas of the code, not for\n\nassessing the quality of a test suite.\n\nThe best measure for a good enough test suite is subjective: How confident are you that\n\nif someone introduces a defect into the code, some test will fail? This isn’t something\n\nthat can be objectively analyzed, and it doesn’t account for false confidence, but the aim\n\nof self­testing code is to get that confidence. If I can refactor my code and be pretty sure\n\nthat I’ve not introduced a bug because my tests come back green—then I can be happy\n\nthat I have good enough tests.\n\nIt is possible to write too many tests. One sign of that is when I spend more time\n\nchanging the tests than the code under test—and I feel the tests are slowing me down.\n\nBut while over­testing does happen, it’s vanishingly rare compared to under­testing.\n\nwww.EBooksWorld.ir\n\nChapter 5 Introducing the Catalog\n\nHistory\n\nTopics\n\nThe rest of this book is a catalog of refactorings. This catalog started from my personal\n\nnotes that I made to remind myself how to do refactorings in a safe and efficient way.\n\nTutorials\n\nSince then, I’ve refined the catalog, and there’s more of it that comes from deliberate\n\nexploration of some refactoring moves. It’s still something I use when I do a refactoring\n\nOffers & Deals\n\nI haven’t done in a while.\n\nHighlights\n\nFORMAT OF THE REFACTORINGS\n\nSettings\n\nAs I describe the refactorings in the catalog, I use a standard format. Each refactoring\n\nhas five parts, as follows:\n\nSupport\n\nSign Out\n\nI begin with a name. The name is important to building a vocabulary of\n\nrefactorings. This is the name I use elsewhere in the book. Refactorings often go by\n\ndifferent names now, so I also list any aliases that seem to be common.\n\nI follow the name with a short sketch of the refactoring. This helps you find a\n\nrefactoring more quickly.\n\nThe motivation describes why the refactoring should be done and describes\n\ncircumstances in which it shouldn’t be done.\n\nThe mechanics are a concise, step­by­step description of how to carry out the\n\nrefactoring.\n\nThe examples show a very simple use of the refactoring to illustrate how it works.\n\nThe sketch shows a code example of the transformation of the refactoring. It’s not\n\nmeant to explain what the refactoring is, let alone how to do it, but it should remind you\n\ni\n\nwhat the refactoring is if you’ve come across it before. If not, you’ll probably need to\n\nwork through the example to get a better idea. I also include a small graphic; again, I\n\ndon’t intend it to be explanatory—it’s more of a graphic memory­jogger.\n\nwww.EBooksWorld.ir\n\nThe mechanics come from my own notes to remember how to do the refactoring when I\n\nhaven’t done it for a while. As such, they are somewhat terse, usually without\n\nexplanations of why the steps are done that way. I give a more expansive explanation in\n\nthe example. This way, the mechanics are short notes you can refer to easily when you\n\nknow the refactoring but need to look up the steps (at least this is how I use them).\n\nYou’ll probably need to read the examples when you first do the refactoring.\n\nI’ve written the mechanics in such a way that each step of each refactoring is as small as\n\npossible. I emphasize the safe way of doing the refactoring—which is to take very small\n\nsteps and test after every one. At work, I usually take larger steps than some of the baby\n\nsteps described, but if I run into a bug, I back out the last step and take the smaller\n\nsteps. The steps include a number of references to special cases. The steps thus also\n\nfunction as a checklist; I often forget these things myself.\n\nAlthough I (with few exceptions) only list one set of mechanics, they aren’t the only way\n\nto carry out the refactoring. I selected the mechanics in the book because they work\n\npretty well most of the time. It’s likely you’ll vary them as you get more practice in\n\nrefactoring, and that’s fine. Just remember that the key is to take small steps—and the\n\ntrickier the situation, the smaller the steps.\n\nThe examples are of the laughably simple textbook kind. My aim with the examples is\n\nto help explain the basic refactoring with minimal distractions, so I hope you’ll forgive\n\nthe simplicity. (They are certainly not examples of good business modeling.) I’m sure\n\nyou’ll be able to apply them to your rather more complex situations. Some very simple\n\nrefactorings don’t have examples because I didn’t think an example would add much.\n\nIn particular, remember that the examples are included only to illustrate the one\n\nrefactoring under discussion. In most cases, there are still problems with the code at\n\nthe end—but fixing these problems requires other refactorings. In a few cases in which\n\nrefactorings often go together, I carry examples from one re­factoring to another. In\n\nmost cases, I leave the code as it is after the single refactoring. I do this to make each\n\nrefactoring self­contained, because the primary role of the catalog is to be a reference.\n\nI use color to highlight changed code where it may be difficult to spot among code that\n\nhas not been changed. I do not use highlighting for all changed code, because too much\n\ndefeats the purpose.\n\nTHE CHOICE OF REFACTORINGS\n\nThis is by no means a complete catalog of refactorings. It is, I hope, a collection of those\n\nmost useful to have them written down. By “most useful” I mean those that are both\n\nwww.EBooksWorld.ir\n\ncommonly used and worthwhile to name and describe. I find something worthwhile to\n\ndescribe for a combination of reasons: Some have interesting mechanics which help\n\ngeneral refactoring skills, some have a strong effect on improving the design of code.\n\nSome refactorings are missing because they are so small and straightforward that I\n\ndon’t feel they are worth writing up. An example in the first edition was Slide\n\nStatements (223)—which I use frequently but didn’t recognize as something I should\n\ninclude in the catalog (obviously, I changed my mind for this edition). These may well\n\nget added to the book over time, depending on how much energy I devote to new\n\nrefactorings in the future.\n\nAnother category is refactorings that logically exist, but either aren’t used much by me\n\nor show a simple similarity to other refactorings. Every refactoring in this book has a\n\nlogical inverse refactoring, but I didn’t write all of them up because I don’t find many\n\ninverses interesting. Encapsulate Variable (132) is a common and powerful refactoring\n\nbut its inverse is something I hardly ever do (and it is easy to perform anyway) so I\n\ndidn’t think we need a catalog entry for it.\n\nwww.EBooksWorld.ir",
      "page_number": 113
    },
    {
      "number": 13,
      "title": "Segment 13 (pages 121-131)",
      "start_page": 121,
      "end_page": 131,
      "detection_method": "topic_boundary",
      "content": "Chapter 6 A First Set of Refactorings\n\nHistory\n\nTopics\n\nI’m starting the catalog with a set of refactorings that I consider the most useful to learn\n\nfirst. Tutorials\n\nProbably the most common refactoring I do is extracting code into a function (Extract\n\nOffers & Deals\n\nFunction (106)) or a variable (Extract Variable (119)). Since refactoring is all about\n\nchange, it’s no surprise that I also frequently use the inverses of those two (Inline\n\nHighlights\n\nFunction (115) and Inline Variable (123)).\n\nSettings\n\nExtraction is all about giving names, and I often need to change the names as I learn.\n\nChange Function Declaration (124) changes names of functions; I also use that\n\nSupport\n\nrefactoring to add or remove a function’s arguments. For variables, I use Rename\n\nSign Out\n\nVariable (137), which relies on Encapsulate Variable (132). When changing function\n\narguments, I often find it useful to combine a common clump of arguments into a\n\nsingle object with Introduce Parameter Object (140).\n\nForming and naming functions are essential low­level refactorings—but, once created,\n\nit’s necessary to group functions into higher­level modules. I use Combine Functions\n\ninto Class (144) to group functions, together with the data they operate on, into a class.\n\nAnother path I take is to combine them into a transform (Combine Functions into\n\nTransform (149)), which is particularly handy with read­only data. At a step further in\n\nscale, I can often form these modules into distinct processing phases using Split Phase\n\n(154).\n\nEXTRACT FUNCTION\n\nformerly: Extract Method\n\ninverse\n\nof:\n\nInline\n\nFunction\n\n(115)\n\nwww.EBooksWorld.ir\n\nMotivation\n\nExtract Function is one of the most common refactorings I do. (Here, I use the term\n\n“function” but the same is true for a method in an object­oriented language, or any kind\n\nof procedure or subroutine.) I look at a fragment of code, understand what it is doing,\n\nthen extract it into its own function named after its purpose.\n\nDuring my career, I’ve heard many arguments about when to enclose code in its own\n\nfunction. Some of these guidelines were based on length: Functions should be no larger\n\nthan fit on a screen. Some were based on reuse: Any code used more than once should\n\nbe put in its own function, but code only used once should be left inline. The argument\n\nthat makes most sense to me, however, is the separation between intention and\n\nimplementation. If you have to spend effort looking at a fragment of code and figuring\n\nout what it’s doing, then you should extract it into a function and name the function\n\nafter the “what.” Then, when you read it again, the purpose of the function leaps right\n\nout at you, and most of the time you won’t need to care about how the function fulfills\n\nits purpose (which is the body of the function). www.EBooksWorld.ir\n\nOnce I accepted this principle, I developed a habit of writing very small functions—\n\ntypically, only a few lines long. To me, any function with more than half­a­dozen lines\n\nof code starts to smell, and it’s not unusual for me to have functions that are a single\n\nline of code. The fact that size isn’t important was brought home to me by an example\n\nthat Kent Beck showed me from the original Smalltalk system. Smalltalk in those days\n\nran on black­and­white systems. If you wanted to highlight some text or graphics, you\n\nwould reverse the video. Smalltalk’s graphics class had a method for this called\n\nhighlight, whose implementation was just a call to the method reverse. The name\n\nof the method was longer than its implementation—but that didn’t matter because\n\nthere was a big distance between the intention of the code and its implementation.\n\nSome people are concerned about short functions because they worry about the\n\nperformance cost of a function call. When I was young, that was occasionally a factor,\n\nbut that’s very rare now. Optimizing compilers often work better with shorter functions\n\nwhich can be cached more easily. As always, follow the general guidelines on\n\nperformance optimization.\n\nSmall functions like this only work if the names are good, so you need to pay good\n\nattention to naming. This takes practice—but once you get good at it, this approach can\n\nmake code remarkably self­documenting.\n\nOften, I see fragments of code in a larger function that start with a comment to say what\n\nthey do. The comment is often a good hint for the name of the function when I extract\n\nthat fragment.\n\nMechanics\n\nCreate a new function, and name it after the intent of the function (name it by what\n\nit does, not by how it does it).\n\nIf the code I want to extract is very simple, such as a single function call, I still\n\nextract it if the name of the new function will reveal the intent of the code in a better\n\nway. If I can’t come up with a more meaningful name, that’s a sign that I shouldn’t\n\nextract the code. However, I don’t have to come up with the best name right away;\n\nsometimes a good name only appears as I work with the extraction. It’s OK to\n\nextract a function, try to work with it, realize it isn’t helping, and then inline it back\n\nagain. As long as I’ve learned something, my time wasn’t wasted.\n\nIf the language supports nested functions, nest the extracted function inside the\n\nsource function. That will reduce the amount of out­of­scope variables to deal with\n\nafter the next couple of steps. I can always use Move Function (198) later. www.EBooksWorld.ir\n\nCopy the extracted code from the source function into the new target function.\n\nScan the extracted code for references to any variables that are local in scope to the\n\nsource function and will not be in scope for the extracted function. Pass them as\n\nparameters.\n\nIf I extract into a nested function of the source function, I don’t run into these\n\nproblems.\n\nUsually, these are local variables and parameters to the function. The most general\n\napproach is to pass all such parameters in as arguments. There are usually no\n\ndifficulties for variables that are used but not assigned to.\n\nIf a variable is only used inside the extracted code but is declared outside, move the\n\ndeclaration into the extracted code.\n\nAny variables that are assigned to need more care if they are passed by value. If\n\nthere’s only one of them, I try to treat the extracted code as a query and assign the\n\nresult to the variable concerned.\n\nSometimes, I find that too many local variables are being assigned by the extracted\n\ncode. It’s better to abandon the extraction at this point. When this happens, I\n\nconsider other refactorings such as Split Variable (240) or Replace Temp with\n\nQuery (178) to simplify variable usage and revisit the extraction later.\n\nCompile after all variables are dealt with.\n\nOnce all the variables are dealt with, it can be useful to compile if the language\n\nenvironment does compile­time checks. Often, this will help find any variables that\n\nhaven’t been dealt with properly.\n\nReplace the extracted code in the source function with a call to the target function.\n\nTest.\n\nLook for other code that’s the same or similar to the code just extracted, and\n\nconsider using Replace Inline Code with Function Call (222) to call the new\n\nfunction.\n\nSome refactoring tools support this directly. Otherwise, it can be worth doing some\n\nquick searches to see if duplicate code exists elsewhere.\n\nwww.EBooksWorld.ir\n\nExample: No Variables Out of Scope\n\nExample: No Variables Out of Scope\n\nIn the simplest case, Extract Function is trivially easy.\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nconsole.log(\"***********************\"); console.log(\"**** Customer Owes ****\"); console.log(\"***********************\");\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\n// record due date const today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);\n\n//print details console.log(`name: ${invoice.customer}`); console.log(`amount: ${outstanding}`); console.log(`due: ${invoice.dueDate.toLocaleDateString()}`); }\n\nYou may be wondering what the Clock.today is about. It is a Clock Wrapper [mf­\n\ncw]—an object that wraps calls to the system clock. I avoid putting direct calls to\n\nthings like Date.now() in my code, because it leads to nondeterministic tests and\n\nmakes it difficult to reproduce error conditions when diagnosing failures.\n\nIt’s easy to extract the code that prints the banner. I just cut, paste, and put in a call:\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nprintBanner();\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\nwww.EBooksWorld.ir\n\n// record due date const today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);\n\n//print details console.log(`name: ${invoice.customer}`); console.log(`amount: ${outstanding}`); console.log(`due: ${invoice.dueDate.toLocaleDateString()}`); } function printBanner() { console.log(\"***********************\"); console.log(\"**** Customer Owes ****\"); console.log(\"***********************\"); }\n\nSimilarly, I can take the printing of details and extract that too:\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nprintBanner();\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\n// record due date const today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);\n\nprintDetails();\n\nfunction printDetails() { console.log(`name: ${invoice.customer}`); console.log(`amount: ${outstanding}`); console.log(`due: ${invoice.dueDate.toLocaleDateString()}`); }\n\nThis makes Extract Function seem like a trivially easy refactoring. But in many\n\nsituations, it turns out to be rather more tricky.\n\nIn the case above, I defined printDetails so it was nested inside printOwing. That\n\nway it was able to access all the variables defined in printOwing. But that’s not an\n\noption to me if I’m programming in a language that doesn’t allow nested functions. www.EBooksWorld.ir\n\nThen I’m faced, essentially, with the problem of extracting the function to the top level,\n\nwhich means I have to pay attention to any variables that exist only in the scope of the\n\nsource function. These are the arguments to the original function and the temporary\n\nvariables defined in the function.\n\nExample: Using Local Variables\n\nThe easiest case with local variables is when they are used but not reassigned. In this\n\ncase, I can just pass them in as parameters. So if I have the following function:\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nprintBanner();\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\n// record due date const today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);\n\n//print details console.log(`name: ${invoice.customer}`); console.log(`amount: ${outstanding}`); console.log(`due: ${invoice.dueDate.toLocaleDateString()}`); }\n\nI can extract the printing of details passing two parameters:\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nprintBanner();\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\n// record due date\n\nwww.EBooksWorld.ir\n\nconst today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);\n\nprintDetails(invoice, outstanding); } function printDetails(invoice, outstanding) { console.log(`name: ${invoice.customer}`); console.log(`amount: ${outstanding}`); console.log(`due: ${invoice.dueDate.toLocaleDateString()}`); }\n\nThe same is true if the local variable is a structure (such as an array, record, or object)\n\nand I modify that structure. So, I can similarly extract the setting of the due date:\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nprintBanner();\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\nrecordDueDate(invoice); printDetails(invoice, outstanding); } function recordDueDate(invoice) { const today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30); }\n\nExample: Reassigning a Local Variable\n\nIt’s the assignment to local variables that becomes complicated. In this case, we’re only\n\ntalking about temps. If I see an assignment to a parameter, I immediately use Split\n\nVariable (240), which turns it into a temp.\n\nFor temps that are assigned to, there are two cases. The simpler case is where the\n\nvariable is a temporary variable used only within the extracted code. When that\n\nhappens, the variable just exists within the extracted code. Sometimes, particularly\n\nwhen variables are initialized at some distance before they are used, it’s handy to use\n\nSlide Statements (223) to get all the variable manipulation together.\n\nwww.EBooksWorld.ir\n\nThe more awkward case is where the variable is used outside the extracted function. In\n\nthat case, I need to return the new value. I can illustrate this with the following\n\nfamiliar­looking function:\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nprintBanner();\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\nrecordDueDate(invoice); printDetails(invoice, outstanding); }\n\nI’ve shown the previous refactorings all in one step, since they were straightforward,\n\nbut this time I’ll take it one step at a time from the mechanics.\n\nFirst, I’ll slide the declaration next to its use.\n\nClick here to view code image\n\nfunction printOwing(invoice) { printBanner();\n\n// calculate outstanding let outstanding = 0; for (const o of invoice.orders) { outstanding += o.amount; }\n\nrecordDueDate(invoice); printDetails(invoice, outstanding); }\n\nI then copy the code I want to extract into a target function.\n\nClick here to view code image\n\nfunction printOwing(invoice) { printBanner();\n\nwww.EBooksWorld.ir\n\n// calculate outstanding let outstanding = 0; for (const o of invoice.orders) { outstanding += o.amount; }\n\nrecordDueDate(invoice); printDetails(invoice, outstanding); } function calculateOutstanding(invoice) { let outstanding = 0; for (const o of invoice.orders) { outstanding += o.amount; } return outstanding; }\n\nSince I moved the declaration of outstanding into the extracted code, I don’t need to\n\npass it in as a parameter. The outstanding variable is the only one reassigned in the\n\nextracted code, so I can return it.\n\nMy JavaScript environment doesn’t yield any value by compiling—indeed less than I’m\n\ngetting from the syntax analysis in my editor—so there’s no step to do here. My next\n\nthing to do is to replace the original code with a call to the new function. Since I’m\n\nreturning the value, I need to store it in the original variable.\n\nClick here to view code image\n\nfunction printOwing(invoice) { printBanner(); let outstanding = calculateOutstanding(invoice); recordDueDate(invoice); printDetails(invoice, outstanding); } function calculateOutstanding(invoice) { let outstanding = 0; for (const o of invoice.orders) { outstanding += o.amount; } return outstanding; }\n\nBefore I consider myself done, I rename the return value to follow my usual coding\n\nstyle.\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nfunction printOwing(invoice) { printBanner(); const outstanding = calculateOutstanding(invoice); recordDueDate(invoice); printDetails(invoice, outstanding); } function calculateOutstanding(invoice) { let result = 0; for (const o of invoice.orders) { result += o.amount; } return result; }\n\nI also take the opportunity to change the original outstanding into a const.\n\nAt this point you may be wondering, “What happens if more than one variable needs to\n\nbe returned?”\n\nHere, I have several options. Usually I prefer to pick different code to extract. I like a\n\nfunction to return one value, so I would try to arrange for multiple functions for the\n\ndifferent values. If I really need to extract with multiple values, I can form a record and\n\nreturn that—but usually I find it better to rework the temporary variables instead. Here\n\nI like using Replace Temp with Query (178) and Split Variable (240).\n\nThis raises an interesting question when I’m extracting functions that I expect to then\n\nmove to another context, such as top level. I prefer small steps, so my instinct is to\n\nextract into a nested function first, then move that nested function to its new context.\n\nBut the tricky part of this is dealing with variables and I don’t expose that difficulty\n\nuntil I do the move. This argues that even though I can extract into a nested function, it\n\nmakes sense to extract to at least the sibling level of the source function first, so I can\n\nimmediately tell if the extracted code makes sense.\n\nINLINE FUNCTION\n\nformerly: Inline Method\n\ninverse of: Extract Function (106)\n\nwww.EBooksWorld.ir",
      "page_number": 121
    },
    {
      "number": 14,
      "title": "Segment 14 (pages 132-140)",
      "start_page": 132,
      "end_page": 140,
      "detection_method": "topic_boundary",
      "content": "Motivation\n\nOne of the themes of this book is using short functions named to show their intent,\n\nbecause these functions lead to clearer and easier to read code. But sometimes, I do\n\ncome across a function in which the body is as clear as the name. Or, I refactor the body\n\nof the code into something that is just as clear as the name. When this happens, I get rid\n\nof the function. Indirection can be helpful, but needless indirection is irritating.\n\nI also use Inline Function is when I have a group of functions that seem badly factored.\n\nI can inline them all into one big function and then reextract the functions the way I\n\nprefer.\n\nI commonly use Inline Function when I see code that’s using too much indirection—\n\nwhen it seems that every function does simple delegation to another function, and I get\n\nlost in all the delegation. Some of this indirection may be worthwhile, but not all of it.\n\nBy inlining, I can flush out the useful ones and eliminate the rest.\n\nMechanics\n\nCheck that this isn’t a polymorphic method.\n\nIf this is a method in a class, and has subclasses that override it, then I can’t inline\n\nit.\n\nwww.EBooksWorld.ir\n\nFind all the callers of the function.\n\nReplace each call with the function’s body.\n\nTest after each replacement.\n\nThe entire inlining doesn’t have to be done all at once. If some parts of the inline are\n\ntricky, they can be done gradually as opportunity permits.\n\nRemove the function definition.\n\nWritten this way, Inline Function is simple. In general, it isn’t. I could write pages on\n\nhow to handle recursion, multiple return points, inlining a method into another object\n\nwhen you don’t have accessors, and the like. The reason I don’t is that if you encounter\n\nthese complexities, you shouldn’t do this refactoring.\n\nExample\n\nIn the simplest case, this refactoring is so easy it’s trivial. I start with\n\nClick here to view code image\n\nfunction rating(aDriver) { return moreThanFiveLateDeliveries(aDriver) ? 2 : 1; } function moreThanFiveLateDeliveries(aDriver) { return aDriver.numberOfLateDeliveries > 5; }\n\nI can just take the return expression of the called function and paste it into the caller to\n\nreplace the call.\n\nClick here to view code image\n\nfunction rating(aDriver) { return aDriver.numberOfLateDeliveries > 5 ? 2 : 1; }\n\nBut it can be a little more involved than that, requiring me to do more work to fit the\n\ncode into its new home. Consider the case where I start with this slight variation on the\n\nearlier initial code.\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nfunction rating(aDriver) { return moreThanFiveLateDeliveries(aDriver) ? 2 : 1; } function moreThanFiveLateDeliveries(dvr) { return dvr.numberOfLateDeliveries > 5; }\n\nAlmost the same, but now the declared argument on\n\nmoreThanFiveLateDeliveries is different to the name of the passed­in argument.\n\nSo I have to fit the code a little when I do the inline.\n\nClick here to view code image\n\nfunction rating(aDriver) { return aDriver.numberOfLateDeliveries > 5 ? 2 : 1; }\n\nIt can be even more involved than this. Consider this code:\n\nClick here to view code image\n\nfunction reportLines(aCustomer) { const lines = []; gatherCustomerData(lines, aCustomer); return lines; } function gatherCustomerData(out, aCustomer) { out.push([\"name\", aCustomer.name]); out.push([\"location\", aCustomer.location]); }\n\nInlining gatherCustomerData into reportLines isn’t a simple cut and paste. It’s\n\nnot too complicated, and most times I would still do this in one go, with a bit of fitting.\n\nBut to be cautious, it may make sense to move one line at a time. So I’d start with using\n\nMove Statements to Callers (217) on the first line (I’d do it the simple way with a cut,\n\npaste, and fit).\n\nClick here to view code image\n\nfunction reportLines(aCustomer) { const lines = []; lines.push([\"name\", aCustomer.name]); gatherCustomerData(lines, aCustomer); return lines;\n\nwww.EBooksWorld.ir\n\n} function gatherCustomerData(out, aCustomer) { out.push([\"name\", aCustomer.name]); out.push([\"location\", aCustomer.location]); }\n\nI then continue with the other lines until I’m done.\n\nClick here to view code image\n\nfunction reportLines(aCustomer) { const lines = []; lines.push([\"name\", aCustomer.name]); lines.push([\"location\", aCustomer.location]); return lines; }\n\nThe point here is to always be ready to take smaller steps. Most of the time, with the\n\nsmall functions I normally write, I can do Inline Function in one go, even if there is a bit\n\nof refitting to do. But if I run into complications, I go one line at a time. Even with one\n\nline, things can get a bit awkward; then, I’ll use the more elaborate mechanics for Move\n\nStatements to Callers (217) to break things down even more. And if, feeling confident, I\n\ndo something the quick way and the tests break, I prefer to revert back to my last green\n\ncode and repeat the refactoring with smaller steps and a touch of chagrin.\n\nEXTRACT VARIABLE\n\nformerly: Introduce Explaining Variable\n\ninverse of: Inline Variable (123)\n\nwww.EBooksWorld.ir\n\nMotivation\n\nExpressions can become very complex and hard to read. In such situations, local\n\nvariables may help break the expression down into something more manageable. In\n\nparticular, they give me an ability to name a part of a more complex piece of logic. This\n\nallows me to better understand the purpose of what’s happening.\n\nSuch variables are also handy for debugging, since they provide an easy hook for a\n\ndebugger or print statement to capture.\n\nIf I’m considering Extract Variable, it means I want to add a name to an expression in\n\nmy code. Once I’ve decided I want to do that, I also think about the context of that\n\nname. If it’s only meaningful within the function I’m working on, then Extract Variable\n\nis a good choice—but if it makes sense in a broader context, I’ll consider making the\n\nname available in that broader context, usually as a function. If the name is available\n\nmore widely, then other code can use that expression without having to repeat the\n\nexpression, leading to less duplication and a better statement of my intent.\n\nThe downside of promoting the name to a broader context is extra effort. If it’s\n\nsignificantly more effort, I’m likely to leave it till later when I can use Replace Temp\n\nwith Query (178). But if it’s easy, I like to do it now so the name is immediately\n\navailable in the code. As a good example of this, if I’m working in a class, then Extract\n\nFunction (106) is very easy to do.\n\nMechanics\n\nEnsure that the expression you want to extract does not have side effects. www.EBooksWorld.ir\n\nDeclare an immutable variable. Set it to a copy of the expression you want to name.\n\nReplace the original expression with the new variable.\n\nTest.\n\nIf the expression appears more than once, replace each occurrence with the variable,\n\ntesting after each replacement.\n\nExample\n\nI start with a simple calculation\n\nClick here to view code image\n\nfunction price(order) { //price is base price ­ quantity discount + shipping return order.quantity * order.itemPrice ­ Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100); }\n\nSimple as it may be, I can make it still easier to follow. First, I recognize that the base\n\nprice is the multiple of the quantity and the item price.\n\nClick here to view code image\n\nfunction price(order) { //price is base price ­ quantity discount + shipping return order.quantity * order.itemPrice ­ Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100); }\n\nOnce that understanding is in my head, I put it in the code by creating and naming a\n\nvariable for it.\n\nClick here to view code image\n\nfunction price(order) { //price is base price ­ quantity discount + shipping const basePrice = order.quantity * order.itemPrice; return order.quantity * order.itemPrice ­ Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05 +\n\nwww.EBooksWorld.ir\n\nMath.min(order.quantity * order.itemPrice * 0.1, 100); }\n\nOf course, just declaring and initializing a variable doesn’t do anything; I also have to\n\nuse it, so I replace the expression that I used as its source.\n\nClick here to view code image\n\nfunction price(order) { //price is base price ­ quantity discount + shipping const basePrice = order.quantity * order.itemPrice; return basePrice ­ Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100); }\n\nThat same expression is used later on, so I can replace it with the variable there too.\n\nClick here to view code image\n\nfunction price(order) { //price is base price ­ quantity discount + shipping const basePrice = order.quantity * order.itemPrice; return basePrice ­ Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05 + Math.min(basePrice * 0.1, 100); }\n\nThe next line is the quantity discount, so I can extract that too.\n\nClick here to view code image\n\nfunction price(order) { //price is base price ­ quantity discount + shipping const basePrice = order.quantity * order.itemPrice; const quantityDiscount = Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05; return basePrice ­ quantityDiscount + Math.min(basePrice * 0.1, 100); }\n\nFinally, I finish with the shipping. As I do that, I can remove the comment, too, because\n\nit no longer says anything the code doesn’t say.\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction price(order) { const basePrice = order.quantity * order.itemPrice; const quantityDiscount = Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05; const shipping = Math.min(basePrice * 0.1, 100); return basePrice ­ quantityDiscount + shipping; }\n\nExample: With a Class\n\nHere’s the same code, but this time in the context of a class:\n\nClick here to view code image\n\nclass Order { constructor(aRecord) { this._data = aRecord; } get quantity() {return this._data.quantity;} get itemPrice() {return this._data.itemPrice;}\n\nget price() { return this.quantity * this.itemPrice ­ Math.max(0, this.quantity ­ 500) * this.itemPrice * 0.05 + Math.min(this.quantity * this.itemPrice * 0.1, 100); } }\n\nIn this case, I want to extract the same names, but I realize that the names apply to the\n\nOrder as a whole, not just the calculation of the price. Since they apply to the whole\n\norder, I’m inclined to extract the names as methods rather than variables.\n\nClick here to view code image\n\nclass Order { constructor(aRecord) { this._data = aRecord; } get quantity() {return this._data.quantity;} get itemPrice() {return this._data.itemPrice;}\n\nget price() { return this.basePrice ­ this.quantityDiscount + this.shipping; } get basePrice() {return this.quantity * this.itemPrice;} www.EBooksWorld.ir\n\nget quantityDiscount() {return Math.max(0, this.quantity ­ 500) * this.itemPrice * 0.05;} get shipping() {return Math.min(this.basePrice * 0.1, 100);} }\n\nThis is one of the great benefits of objects—they give you a reasonable amount of\n\ncontext for logic to share other bits of logic and data. For something as simple as this, it\n\ndoesn’t matter so much, but with a larger class it becomes very useful to call out\n\ncommon hunks of behavior as their own abstractions with their own names to refer to\n\nthem whenever I’m working with the object.\n\nINLINE VARIABLE\n\nformerly: Inline Temp\n\ninverse of: Extract Variable (119)\n\nMotivation\n\nVariables provide names for expressions within a function, and as such they are usually\n\na Good Thing. But sometimes, the name doesn’t really communicate more than the\n\nexpression itself. At other times, you may find that a variable gets in the way of\n\nrefactoring the neighboring code. In these cases, it can be useful to inline the variable.\n\nMechanics\n\nCheck that the right­hand side of the assignment is free of side effects.\n\nIf the variable isn’t already declared immutable, do so and test.\n\nThis checks that it’s only assigned to once.\n\nwww.EBooksWorld.ir",
      "page_number": 132
    },
    {
      "number": 15,
      "title": "Segment 15 (pages 141-150)",
      "start_page": 141,
      "end_page": 150,
      "detection_method": "topic_boundary",
      "content": "Find the first reference to the variable and replace it with the right­hand side of the\n\nassignment.\n\nTest.\n\nRepeat replacing references to the variable until you’ve replaced all of them.\n\nRemove the declaration and assignment of the variable.\n\nTest.\n\nCHANGE FUNCTION DECLARATION\n\naka: Rename Function\n\nformerly: Rename Method\n\nformerly: Add Parameter\n\nformerly: Remove Parameter\n\naka: Change Signature\n\nMotivation\n\nFunctions represent the primary way we break a program down into parts. Function\n\ndeclarations represent how these parts fit together—effectively, they represent the\n\nwww.EBooksWorld.ir\n\njoints in our software systems. And, as with any construction, much depends on those\n\njoints. Good joints allow me to add new parts to the system easily, but bad ones are a\n\nconstant source of difficulty, making it harder to figure out what the software does and\n\nhow to modify it as my needs change. Fortunately, software, being soft, allows me to\n\nchange these joints, providing I do it carefully.\n\nThe most important element of such a joint is the name of the function. A good name\n\nallows me to understand what the function does when I see it called, without seeing the\n\ncode that defines its implementation. However, coming up with good names is hard,\n\nand I rarely get my names right the first time. When I find a name that’s confused me,\n\nI’m tempted to leave it—after all, it’s only a name. This is the work of the evil demon\n\nObfuscatis; for the sake of my program’s soul I must never listen to him. If I see a\n\nfunction with the wrong name, it is imperative that I change it as soon as I understand\n\nwhat a better name could be. That way, the next time I’m looking at this code, I don’t\n\nhave to figure out again what’s going on. (Often, a good way to improve a name is to\n\nwrite a comment to describe the function’s purpose, then turn that comment into a\n\nname.)\n\nSimilar logic applies to a function’s parameters. The parameters of a function dictate\n\nhow a function fits in with the rest of its world. Parameters set the context in which I\n\ncan use a function. If I have a function to format a person’s telephone number, and that\n\nfunction takes a person as its argument, then I can’t use it to format a company’s\n\ntelephone number. If I replace the person parameter with the telephone number itself,\n\nthen the formatting code is more widely useful.\n\nApart from increasing a function’s range of applicability, I can also remove some\n\ncoupling, changing what modules need to connect to others. Telephone formatting logic\n\nmay sit in a module that has no knowledge about people. Reducing how much modules\n\nneed to know about each other helps reduce how much I need to put into my brain\n\nwhen I change something—and my brain isn’t as big as it used to be (that doesn’t say\n\nanything about the size of its container, though).\n\nChoosing the right parameters isn’t something that adheres to simple rules. I may have\n\na simple function for determining if a payment is overdue, by looking at if it’s older\n\nthan 30 days. Should the parameter to this function be the payment object, or the due\n\ndate of the payment? Using the payment couples the function to the interface of the\n\npayment object. But if I use the payment, I can easily access other properties of the\n\npayment, should the logic evolve, without having to change every bit of code that calls\n\nthis function—essentially, increasing the encapsulation of the function.\n\nwww.EBooksWorld.ir\n\nThe only right answer to this puzzle is that there is no right answer, especially over\n\ntime. So I find it’s essential to be familiar with Change Function Declaration so the code\n\ncan evolve with my understanding of what the best joints in the code need to be.\n\nUsually, I only use the main name of a refactoring when I refer to it from elsewhere in\n\nthis book. However, since renaming is such a significant use case for Change Function\n\nDeclaration, if I’m just renaming something, I’ll refer to this refactoring as Rename\n\nFunction to make it clearer what I’m doing. Whether I’m merely renaming or\n\nmanipulating the parameters, I use the same mechanics.\n\nMechanics\n\nIn most of the refactorings in this book, I present only a single set of mechanics. This\n\nisn’t because there is only one set that will do the job but because, usually, one set of\n\nmechanics will work reasonably well for most cases. Change Function Declaration,\n\nhowever, is an exception. The simple mechanics are often effective, but there are plenty\n\nof cases when a more gradual migration makes more sense. So, with this refactoring, I\n\nlook at the change and ask myself if I think I can change the declaration and all its\n\ncallers easily in one go. If so, I follow the simple mechanics. The migration­style\n\nmechanics allow me to change the callers more gradually—which is important if I have\n\nlots of them, they are awkward to get to, the function is a polymorphic method, or I\n\nhave a more complicated change to the declaration.\n\nSimple Mechanics\n\nIf you’re removing a parameter, ensure it isn’t referenced in the body of the\n\nfunction.\n\nChange the method declaration to the desired declaration.\n\nFind all references to the old method declaration, update them to the new one.\n\nTest.\n\nIt’s often best to separate changes, so if you want to both change the name and add a\n\nparameter, do these as separate steps. (In any case, if you run into trouble, revert and\n\nuse the migration mechanics instead.)\n\nMigration Mechanics\n\nIf necessary, refactor the body of the function to make it easy to do the following\n\nextraction step.\n\nwww.EBooksWorld.ir\n\nUse Extract Function (106) on the function body to create the new function.\n\nIf the new function will have the same name as the old one, give the new function a\n\ntemporary name that’s easy to search for.\n\nIf the extracted function needs additional parameters, use the simple mechanics to\n\nadd them.\n\nTest.\n\nApply Inline Function (115) to the old function.\n\nIf you used a temporary name, use Change Function Declaration (124) again to\n\nrestore it to the original name.\n\nTest.\n\nIf you’re changing a method on a class with polymorphism, you’ll need to add\n\nindirection for each binding. If the method is polymorphic within a single class\n\nhierarchy, you only need the forwarding method on the superclass. If the\n\npolymorphism has no superclass link, then you’ll need forwarding methods on each\n\nimplementation class.\n\nIf you are refactoring a published API, you can pause the refactoring once you’ve\n\ncreated the new function. During this pause, deprecate the original function and wait\n\nfor clients to change to the new function. The original function declaration can be\n\nremoved when (and if) you’re confident all the clients of the old function have migrated\n\nto the new one.\n\nExample: Renaming a Function (Simple Mechanics)\n\nConsider this function with an overly abbreved name:\n\nClick here to view code image\n\nfunction circum(radius) { return 2 * Math.PI * radius; }\n\nI want to change that to something more sensible. I begin by changing the declaration:\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nfunction circumference(radius) { return 2 * Math.PI * radius; }\n\nI then find all the callers of circum and change the name to circumference.\n\nDifferent language environments have an impact on how easy it is to find all the\n\nreferences to the old function. Static typing and a good IDE provide the best experience,\n\nusually allowing me to rename functions automatically with little chance of error.\n\nWithout static typing, this can be more involved; even good searching tools will then\n\nhave a lot of false positives.\n\nI use the same approach for adding or removing parameters: find all the callers, change\n\nthe declaration, and change the callers. It’s often better to do these as separate steps—\n\nso, if I’m both renaming the function and adding a parameter, I first do the rename,\n\ntest, then add the parameter, and test again.\n\nA disadvantage of this simple way of doing the refactoring is that I have to do all the\n\ncallers and the declaration (or all of them, if polymorphic) at once. If there are only a\n\nfew of them, or if I have decent automated refactoring tools, this is reasonable. But if\n\nthere’s a lot, it can get tricky. Another problem is when the names aren’t unique—e.g., I\n\nwant to rename the a changeAddress method on a person class but the same method,\n\nwhich I don’t want to change, exists on an insurance agreement class. The more\n\ncomplex the change is, the less I want to do it in one go like this. When this kind of\n\nproblem arises, I use the migration mechanics instead. Similarly, if I use simple\n\nmechanics and something goes wrong, I’ll revert the code to the last known good state\n\nand try again using migration mechanics.\n\nExample: Renaming a Function (Migration Mechanics)\n\nAgain, I have this function with its overly abbreved name:\n\nClick here to view code image\n\nfunction circum(radius) { return 2 * Math.PI * radius; }\n\nTo do this refactoring with migration mechanics, I begin by applying Extract Function\n\n(106) to the entire function body.\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction circum(radius) { return circumference(radius); } function circumference(radius) { return 2 * Math.PI * radius; }\n\nI test that, then apply Inline Function (115) to the old functions. I find all the calls of the\n\nold function and replace each one with a call of the new one. I can test after each\n\nchange, which allows me to do them one at a time. Once I’ve got them all, I remove the\n\nold function.\n\nWith most refactorings, I’m changing code that I can modify, but this refactoring can be\n\nhandy with a published API—that is, one used by code that I’m unable to change\n\nmyself. I can pause the refactoring after creating circumference and, if possible,\n\nmark circum as deprecated. I will then wait for callers to change to use\n\ncircumference; once they do, I can delete circum. Even if I’m never able to reach\n\nthe happy point of deleting circum, at least I have a better name for new code.\n\nExample: Adding a Parameter\n\nIn some software, to manage a library of books, I have a book class which has the ability\n\nto take a reservation for a customer.\n\nclass Book…\n\nClick here to view code image\n\naddReservation(customer) { this._reservations.push(customer); }\n\nI need to support a priority queue for reservations. Thus, I need an extra parameter on\n\naddReservation to indicate whether the reservation should go in the usual queue or\n\nthe high­priority queue. If I can easily find and change all the callers, then I can just go\n\nahead with the change—but if not, I can use the migration approach, which I’ll show\n\nhere.\n\nI begin by using Extract Function (106) on the body of addReservation to create the\n\nnew function. Although it will eventually be called addReservation, the new and old\n\nwww.EBooksWorld.ir\n\nfunctions can’t coexist with the same name. So I use a temporary name that will be easy\n\nto search for later.\n\nclass Book…\n\nClick here to view code image\n\naddReservation(customer) { this.zz_addReservation(customer); }\n\nzz_addReservation(customer) { this._reservations.push(customer); }\n\nI then add the parameter to the new declaration and its call (in effect, using the simple\n\nmechanics).\n\nclass Book…\n\nClick here to view code image\n\naddReservation(customer) { this.zz_addReservation(customer, false); }\n\nzz_addReservation(customer, isPriority) { this._reservations.push(customer); }\n\nWhen I use JavaScript, before I change any of the callers, I like to apply Introduce\n\nAssertion (302) to check the new parameter is used by the caller.\n\nclass Book…\n\nClick here to view code image\n\nzz_addReservation(customer, isPriority) { assert(isPriority === true || isPriority === false); this._reservations.push(customer); }\n\nNow, when I change the callers, if I make a mistake and leave off the new parameter,\n\nthis assertion will help me catch the mistake. And I know from long experience there\n\nwww.EBooksWorld.ir\n\nare few more mistake­prone programmers than myself.\n\nNow, I can start changing the callers by using Inline Function (115) on the original\n\nfunction. This allows me to change one caller at a time.\n\nI then rename the new function back to the original. Usually, the simple mechanics\n\nwork fine for this, but I can also use the migration approach if I need to.\n\nExample: Changing a Parameter to One of Its Properties\n\nThe examples so far are simple changes of a name and adding a new parameter, but\n\nwith the migration mechanics, this refactoring can handle more complicated cases quite\n\nneatly. Here’s an example that is a bit more involved.\n\nI have a function which determines if a customer is based in New England.\n\nClick here to view code image\n\nfunction inNewEngland(aCustomer) { return [\"MA\", \"CT\", \"ME\", \"VT\", \"NH\", \"RI\"].includes(aCustomer.address.state); }\n\nHere is one of its callers:\n\ncaller…\n\nClick here to view code image\n\nconst newEnglanders = someCustomers.filter(c => inNewEngland(c));\n\ninNewEngland only uses the customer’s home state to determine if it’s in New\n\nEngland. I’d prefer to refactor inNewEngland so that it takes a state code as a\n\nparameter, making it usable in more contexts by removing the dependency on the\n\ncustomer.\n\nWith Change Function Declaration, my usual first move is to apply Extract Function\n\n(106), but in this case I can make it easier by first refactoring the function body a little. I\n\nuse Extract Variable (119) on my desired new parameter.\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nfunction inNewEngland(aCustomer) { const stateCode = aCustomer.address.state; return [\"MA\", \"CT\", \"ME\", \"VT\", \"NH\", \"RI\"].includes(stateCode); }\n\nNow I use Extract Function (106) to create that new function.\n\nClick here to view code image\n\nfunction inNewEngland(aCustomer) { const stateCode = aCustomer.address.state; return xxNEWinNewEngland(stateCode); }\n\nfunction xxNEWinNewEngland(stateCode) { return [\"MA\", \"CT\", \"ME\", \"VT\", \"NH\", \"RI\"].includes(stateCode); }\n\nI give the function a name that’s easy to automatically replace to turn into the original\n\nname later. (You can tell I don’t have a standard for these temporary names.)\n\nI apply Inline Variable (123) on the input parameter in the original function.\n\nClick here to view code image\n\nfunction inNewEngland(aCustomer) { return xxNEWinNewEngland(aCustomer.address.state); }\n\nI use Inline Function (115) to fold the old function into its callers, effectively replacing\n\nthe call to the old function with a call to the new one. I can do these one at a time.\n\ncaller…\n\nClick here to view code image\n\nconst newEnglanders = someCustomers.filter(c => xxNEWinNewEngland(c.address.state))\n\nOnce I’ve inlined the old function into every caller, I use Change Function Declaration\n\nagain to change the name of the new function to that of the original.\n\ncaller…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nconst newEnglanders = someCustomers.filter(c => inNewEngland(c.address.state));\n\ntop level…\n\nClick here to view code image\n\nfunction inNewEngland(stateCode) { return [\"MA\", \"CT\", \"ME\", \"VT\", \"NH\", \"RI\"].includes(stateCode); }\n\nAutomated refactoring tools make the migration mechanics both less useful and more\n\neffective. They make it less useful because they handle even complicated renames and\n\nparameter changes safer, so I don’t have to use the migration approach as often as I do\n\nwithout that support. However, in cases like this example, where the tools can’t do the\n\nwhole refactoring, they still make it much easier as the key moves of extract and inline\n\ncan be done more quickly and safely with the tool.\n\nENCAPSULATE VARIABLE\n\nformerly: Self­Encapsulate Field\n\nformerly: Encapsulate Field\n\nMotivation\n\nwww.EBooksWorld.ir",
      "page_number": 141
    },
    {
      "number": 16,
      "title": "Segment 16 (pages 151-158)",
      "start_page": 151,
      "end_page": 158,
      "detection_method": "topic_boundary",
      "content": "Refactoring is all about manipulating the elements of our programs. Data is more\n\nawkward to manipulate than functions. Since using a function usually means calling it,\n\nI can easily rename or move a function while keeping the old function intact as a\n\nforwarding function (so my old code calls the old function, which calls the new\n\nfunction). I’ll usually not keep this forwarding function around for long, but it does\n\nsimplify the refactoring.\n\nData is more awkward because I can’t do that. If I move data around, I have to change\n\nall the references to the data in a single cycle to keep the code working. For data with a\n\nvery small scope of access, such as a temporary variable in a small function, this isn’t a\n\nproblem. But as the scope grows, so does the difficulty, which is why global data is such\n\na pain.\n\nSo if I want to move widely accessed data, often the best approach is to first encapsulate\n\nit by routing all its access through functions. That way, I turn the difficult task of\n\nreorganizing data into the simpler task of reorganizing functions.\n\nEncapsulating data is valuable for other things too. It provides a clear point to monitor\n\nchanges and use of the data; I can easily add validation or consequential logic on the\n\nupdates. It is my habit to make all mutable data encapsulated like this and only\n\naccessed through functions if its scope is greater than a single function. The greater the\n\nscope of the data, the more important it is to encapsulate. My approach with legacy\n\ncode is that whenever I need to change or add a new reference to such a variable, I\n\nshould take the opportunity to encapsulate it. That way I prevent the increase of\n\ncoupling to commonly used data.\n\nThis principle is why the object­oriented approach puts so much emphasis on keeping\n\nan object’s data private. Whenever I see a public field, I consider using Encapsulate\n\nVariable (in that case often called Encapsulate Field) to reduce its visibility. Some go\n\nfurther and argue that even internal references to fields within a class should go\n\nthrough accessor functions—an approach known as self­encapsulation. On the whole, I\n\nfind self­encapsulation excessive—if a class is so big that I need to self­encapsulate its\n\nfields, it needs to be broken up anyway. But self­encapsulating a field is a useful step\n\nbefore splitting a class.\n\nKeeping data encapsulated is much less important for immutable data. When the data\n\ndoesn’t change, I don’t need a place to put in validation or other logic hooks before\n\nupdates. I can also freely copy the data rather than move it—so I don’t have to change\n\nreferences from old locations, nor do I worry about sections of code getting stale data.\n\nImmutability is a powerful preservative.\n\nwww.EBooksWorld.ir\n\nMechanics\n\nMechanics\n\nCreate encapsulating functions to access and update the variable.\n\nRun static checks.\n\nFor each reference to the variable, replace with a call to the appropriate\n\nencapsulating function. Test after each replacement.\n\nRestrict the visibility of the variable.\n\nSometimes it’s not possible to prevent access to the variable. If so, it may be useful\n\nto detect any remaining references by renaming the variable and testing.\n\nTest.\n\nIf the value of the variable is a record, consider Encapsulate Record (162).\n\nExample\n\nConsider some useful data held in a global variable.\n\nClick here to view code image\n\nlet defaultOwner = {firstName: \"Martin\", lastName: \"Fowler\"};\n\nLike any data, it’s referenced with code like this:\n\nClick here to view code image\n\nspaceship.owner = defaultOwner;\n\nand updated like this:\n\nClick here to view code image\n\ndefaultOwner = {firstName: \"Rebecca\", lastName: \"Parsons\"};\n\nTo do a basic encapsulation on this, I start by defining functions to read and write the\n\ndata.\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nfunction getDefaultOwner() {return defaultOwner;} function setDefaultOwner(arg) {defaultOwner = arg;}\n\nI then start working on references to defaultOwner. When I see a reference, I replace\n\nit with a call to the getting function.\n\nClick here to view code image\n\nspaceship.owner = getDefaultOwner();\n\nWhen I see an assignment, I replace it with the setting function.\n\nClick here to view code image\n\nsetDefaultOwner({firstName: \"Rebecca\", lastName: \"Parsons\"});\n\nI test after each replacement.\n\nOnce I’m done with all the references, I restrict the visibility of the variable. This both\n\nchecks that there aren’t any references that I’ve missed, and ensures that future\n\nchanges to the code won’t access the variable directly. I can do that in JavaScript by\n\nmoving both the variable and the accessor methods to their own file and only exporting\n\nthe accessor methods.\n\ndefaultOwner.js…\n\nClick here to view code image\n\nlet defaultOwner = {firstName: \"Martin\", lastName: \"Fowler\"}; export function getDefaultOwner() {return defaultOwner;} export function setDefaultOwner(arg) {defaultOwner = arg;}\n\nIf I’m in a situation where I cannot restrict the access to a variable, it may be useful to\n\nrename the variable and retest. That won’t prevent future direct access, but naming the\n\nvariable something meaningful and awkward such as\n\n__privateOnly_defaultOwner may help.\n\nI don’t like the use of get prefixes on getters, so I’ll rename to remove it.\n\ndefaultOwner.js…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nlet defaultOwnerData = {firstName: \"Martin\", lastName: \"Fowler\"}; export function getdefaultOwner() {return defaultOwnerData;} export function setDefaultOwner(arg) {defaultOwnerData = arg;}\n\nA common convention in JavaScript is to name a getting function and setting function\n\nthe same and differentiate them due the presence of an argument. I call this practice\n\nOverloaded Getter Setter [mf­ogs] and strongly dislike it. So, even though I don’t like\n\nthe get prefix, I will keep the set prefix.\n\nEncapsulating the Value\n\nThe basic refactoring I’ve outlined here encapsulates a reference to some data structure,\n\nallowing me to control its access and reassignment. But it doesn’t control changes to\n\nthat structure.\n\nClick here to view code image\n\nconst owner1 = defaultOwner(); assert.equal(\"Fowler\", owner1.lastName, \"when set\"); const owner2 = defaultOwner(); owner2.lastName = \"Parsons\"; assert.equal(\"Parsons\", owner1.lastName, \"after change owner2\"); // is this ok?\n\nThe basic refactoring encapsulates the reference to the data item. In many cases, this is\n\nall I want to do for the moment. But I often want to take the encapsulation deeper to\n\ncontrol not just changes to the variable but also to its contents.\n\nFor this, I have a couple of options. The simplest one is to prevent any changes to the\n\nvalue. My favorite way to handle this is by modifying the getting function to return a\n\ncopy of the data.\n\ndefaultOwner.js…\n\nClick here to view code image\n\nlet defaultOwnerData = {firstName: \"Martin\", lastName: \"Fowler\"}; export function defaultOwner() {return Object.assign({}, defaultOwnerData);} export function setDefaultOwner(arg) {defaultOwnerData = arg;}\n\nwww.EBooksWorld.ir\n\nI use this approach particularly often with lists. If I return a copy of the data, any clients\n\nusing it can change it, but that change isn’t reflected in the shared data. I have to be\n\ncareful with using copies, however: Some code may expect to change shared data. If\n\nthat’s the case, I’m relying on my tests to detect a problem. An alternative is to prevent\n\nchanges—and a good way of doing that is Encapsulate Record (162).\n\nClick here to view code image\n\nlet defaultOwnerData = {firstName: \"Martin\", lastName: \"Fowler\"}; export function defaultOwner() {return new Person(defaultOwnerData);} export function setDefaultOwner(arg) {defaultOwnerData = arg;}\n\nclass Person { constructor(data) { this._lastName = data.lastName; this._firstName = data.firstName } get lastName() {return this._lastName;} get firstName() {return this._firstName;} // and so on for other properties\n\nNow, any attempt to reassign the properties of the default owner will cause an error.\n\nDifferent languages have different techniques to detect or prevent changes like this, so\n\ndepending on the language I’d consider other options.\n\nDetecting and preventing changes like this is often worthwhile as a temporary measure.\n\nI can either remove the changes, or provide suitable mutating functions. Then, once\n\nthey are all dealt with, I can modify the getting method to return a copy.\n\nSo far I’ve talked about copying on getting data, but it may be worthwhile to make a\n\ncopy in the setter too. That will depend on where the data comes from and whether I\n\nneed to maintain a link to reflect any changes in that original data. If I don’t need such\n\na link, a copy prevents accidents due to changes on that source data. Taking a copy may\n\nbe superfluous most of the time, but copies in these cases usually have a negligible\n\neffect on performance; on the other hand, if I don’t do them, there is a risk of a long and\n\ndifficult bout of debugging in the future.\n\nRemember that the copying above, and the class wrapper, both only work one level\n\ndeep in the record structure. Going deeper requires more levels of copies or object\n\nwrapping.\n\nAs you can see, encapsulating data is valuable, but often not straightforward. Exactly\n\nwww.EBooksWorld.ir\n\nwhat to encapsulate—and how to do it—depends on the way the data is being used and\n\nthe changes I have in mind. But the more widely it’s used, the more it’s worth my\n\nattention to encapsulate properly.\n\nRENAME VARIABLE\n\nMotivation\n\nNaming things well is the heart of clear programming. Variables can do a lot to explain\n\nwhat I’m up to—if I name them well. But I frequently get my names wrong—sometimes\n\nbecause I’m not thinking carefully enough, sometimes because my understanding of the\n\nproblem improves as I learn more, and sometimes because the program’s purpose\n\nchanges as my users’ needs change.\n\nEven more than most program elements, the importance of a name depends on how\n\nwidely it’s used. A variable used in a one­line lambda expression is usually easy to\n\nfollow—I often use a single letter in that case since the variable’s purpose is clear from\n\nits context. Parameters for short functions can often be terse for the same reason,\n\nalthough in a dynamically typed language like JavaScript, I do like to put the type into\n\nthe name (hence parameter names like aCustomer).\n\nPersistent fields that last beyond a single function invocation require more careful\n\nnaming. This is where I’m likely to put most of my attention.\n\nMechanics\n\nIf the variable is used widely, consider Encapsulate Variable (132).\n\nFind all references to the variable, and change every one.\n\nIf there are references from another code base, the variable is a published variable,\n\nwww.EBooksWorld.ir\n\nand you cannot do this refactoring.\n\nIf the variable does not change, you can copy it to one with the new name, then\n\nchange gradually, testing after each change.\n\nTest.\n\nExample\n\nThe simplest case for renaming a variable is when it’s local to a single function: a temp\n\nor argument. It’s too trivial for even an example: I just find each reference and change\n\nit. After I’m done, I test to ensure I didn’t mess up.\n\nProblems occur when the variable has a wider scope than just a single function. There\n\nmay be a lot of references all over the code base:\n\nlet tpHd = \"untitled\";\n\nSome references access the variable:\n\nresult += `<h1>${tpHd}</h1>`;\n\nOthers update it:\n\ntpHd = obj['articleTitle'];\n\nMy usual response to this is apply Encapsulate Variable (132).\n\nClick here to view code image\n\nresult += `<h1>${title()}</h1>`;\n\nsetTitle(obj['articleTitle']);\n\nfunction title() {return tpHd;} function setTitle(arg) {tpHd = arg;}\n\nAt this point, I can rename the variable.\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nlet _title = \"untitled\";\n\nfunction title() {return _title;} function setTitle(arg) {_title = arg;}\n\nI could continue by inlining the wrapping functions so all callers are using the variable\n\ndirectly. But I’d rarely want to do this. If the variable is used widely enough that I feel\n\nthe need to encapsulate it in order to change its name, it’s worth keeping it\n\nencapsulated behind functions for the future.\n\nIn cases where I was going to inline, I’d call the getting function getTitle and not use\n\nan underscore for the variable name when I rename it.\n\nRenaming a Constant\n\nIf I’m renaming a constant (or something that acts like a constant to clients) I can avoid\n\nencapsulation, and still do the rename gradually, by copying. If the original declaration\n\nlooks like this:\n\nClick here to view code image\n\nconst cpyNm = \"Acme Gooseberries\";\n\nI can begin the renaming by making a copy:\n\nClick here to view code image\n\nconst companyName = \"Acme Gooseberries\"; const cpyNm = companyName;\n\nWith the copy, I can gradually change references from the old name to the new name.\n\nWhen I’m done, I remove the copy. I prefer to declare the new name and copy to the old\n\nname if it makes it a tad easier to remove the old name and put it back again should a\n\ntest fail.\n\nThis works for constants as well as for variables that are read­only to clients (such as an\n\nexported variable in JavaScript).\n\nINTRODUCE PARAMETER OBJECT\n\nwww.EBooksWorld.ir",
      "page_number": 151
    },
    {
      "number": 17,
      "title": "Segment 17 (pages 159-169)",
      "start_page": 159,
      "end_page": 169,
      "detection_method": "topic_boundary",
      "content": "Motivation\n\nI often see groups of data items that regularly travel together, appearing in function\n\nafter function. Such a group is a data clump, and I like to replace it with a single data\n\nstructure.\n\nGrouping data into a structure is valuable because it makes explicit the relationship\n\nbetween the data items. It reduces the size of parameter lists for any function that uses\n\nthe new structure. It helps consistency since all functions that use the structure will use\n\nthe same names to get at its elements.\n\nBut the real power of this refactoring is how it enables deeper changes to the code.\n\nWhen I identify these new structures, I can reorient the behavior of the program to use\n\nthese structures. I will create functions that capture the common behavior over this\n\ndata—either as a set of common functions or as a class that combines the data structure\n\nwith these functions. This process can change the conceptual picture of the code,\n\nraising these structures as new abstractions that can greatly simplify my understanding\n\nof the domain. When this works, it can have surprisingly powerful effects—but none of\n\nthis is possible unless I use Introduce Parameter Object to begin the process.\n\nMechanics\n\nIf there isn’t a suitable structure already, create one.\n\nI prefer to use a class, as that makes it easier to group behavior later on. I usually\n\nlike to ensure these structures are value objects [mf­vo].\n\nTest.\n\nwww.EBooksWorld.ir\n\nUse Change Function Declaration (124) to add a parameter for the new structure.\n\nTest.\n\nAdjust each caller to pass in the correct instance of the new structure. Test after\n\neach one.\n\nFor each element of the new structure, replace the use of the original parameter\n\nwith the element of the structure. Remove the parameter. Test.\n\nExample\n\nI’ll begin with some code that looks at a set of temperature readings and determines\n\nwhether any of them fall outside of an operating range. Here’s what the data looks like\n\nfor the readings:\n\nClick here to view code image\n\nconst station = { name: \"ZB1\", readings: [ {temp: 47, time: \"2016­11­10 09:10\"}, {temp: 53, time: \"2016­11­10 09:20\"}, {temp: 58, time: \"2016­11­10 09:30\"}, {temp: 53, time: \"2016­11­10 09:40\"}, {temp: 51, time: \"2016­11­10 09:50\"}, ] };\n\nI have a function to find the readings that are outside a temperature range.\n\nClick here to view code image\n\nfunction readingsOutsideRange(station, min, max) { return station.readings .filter(r => r.temp < min || r.temp > max); }\n\nIt might be called from some code like this:\n\ncaller\n\nClick here to view code image\n\nalerts = readingsOutsideRange(station, www.EBooksWorld.ir\n\noperatingPlan.temperatureFloor, operatingPlan.temperatureCeiling);\n\nNotice how the calling code pulls the two data items as a pair from another object and\n\npasses the pair into readingsOutsideRange. The operating plan uses different\n\nnames to indicate the start and end of the range compared to\n\nreadingsOutsideRange. A range like this is a common case where two separate data\n\nitems are better combined into a single object. I’ll begin by declaring a class for the\n\ncombined data.\n\nClick here to view code image\n\nclass NumberRange { constructor(min, max) { this._data = {min: min, max: max}; } get min() {return this._data.min;} get max() {return this._data.max;} }\n\nI declare a class, rather than just using a basic JavaScript object, because I usually find\n\nthis refactoring to be a first step to moving behavior into the newly created object. Since\n\na class makes sense for this, I go right ahead and use one directly. I also don’t provide\n\nany update methods for the new class, as I’ll probably make this a Value Object [mf­vo].\n\nMost times I do this refactoring, I create value objects.\n\nI then use Change Function Declaration (124) to add the new object as a parameter to\n\nreadingsOutsideRange.\n\nClick here to view code image\n\nfunction readingsOutsideRange(station, min, max, range) { return station.readings .filter(r => r.temp < min || r.temp > max); }\n\nIn JavaScript, I can leave the caller as is, but in other languages I’d have to add a null\n\nfor the new parameter which would look something like this:\n\ncaller\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nalerts = readingsOutsideRange(station, operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling, null);\n\nAt this point I haven’t changed any behavior, and tests should still pass. I then go to\n\neach caller and adjust it to pass in the correct date range.\n\ncaller\n\nClick here to view code image\n\nconst range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling); alerts = readingsOutsideRange(station, operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling, range);\n\nI still haven’t altered any behavior yet, as the parameter isn’t used. All tests should still\n\nwork.\n\nNow I can start replacing the usage of the parameters. I’ll start with the maximum.\n\nClick here to view code image\n\nfunction readingsOutsideRange(station, min, max, range) { return station.readings .filter(r => r.temp < min || r.temp > range.max); }\n\ncaller\n\nClick here to view code image\n\nconst range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling); alerts = readingsOutsideRange(station, operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling, range);\n\nI can test at this point, then remove the other parameter.\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction readingsOutsideRange(station, min, range) { return station.readings .filter(r => r.temp < range.min || r.temp > range.max); }\n\ncaller\n\nClick here to view code image\n\nconst range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling); alerts = readingsOutsideRange(station, operatingPlan.temperatureFloor, range);\n\nThat completes this refactoring. However, replacing a clump of parameters with a real\n\nobject is just the setup for the really good stuff. The great benefits of making a class like\n\nthis is that I can then move behavior into the new class. In this case, I’d add a method\n\nfor range that tests if a value falls within the range.\n\nClick here to view code image\n\nfunction readingsOutsideRange(station, range) { return station.readings .filter(r => !range.contains(r.temp)); }\n\nclass NumberRange…\n\nClick here to view code image\n\ncontains(arg) {return (arg >= this.min && arg <= this.max);}\n\nThis is a first step to creating a range [mf­range] that can take on a lot of useful\n\nbehavior. Once I’ve identified the need for a range in my code, I can be constantly on\n\nthe lookout for other cases where I see a max/min pair of numbers and replace them\n\nwith a range. (One immediate possibility is the operating plan, replacing\n\ntemperatureFloor and temperatureCeiling with a temperatureRange.) As I\n\nlook at how these pairs are used, I can move more useful behavior into the range class,\n\nwww.EBooksWorld.ir\n\nsimplifying its usage across the code base. One of the first things I may add is a value­\n\nbased equality method to make it a true value object.\n\nCOMBINE FUNCTIONS INTO CLASS\n\nMotivation\n\nClasses are a fundamental construct in most modern programming languages. They\n\nbind together data and functions into a shared environment, exposing some of that data\n\nand function to other program elements for collaboration. They are the primary\n\nconstruct in object­oriented languages, but are also useful with other approaches too.\n\nWhen I see a group of functions that operate closely together on a common body of data\n\n(usually passed as arguments to the function call), I see an opportunity to form a class.\n\nUsing a class makes the common environment that these functions share more explicit,\n\nallows me to simplify function calls inside the object by removing many of the\n\narguments, and provides a reference to pass such an object to other parts of the system.\n\nIn addition to organizing already formed functions, this refactoring also provides a\n\ngood opportunity to identify other bits of computation and refactor them into methods\n\non the new class.\n\nAnother way of organizing functions together is Combine Functions into Transform\n\n(149). Which one to use depends more on the broader context of the program. One\n\nsignificant advantage of using a class is that it allows clients to mutate the core data of\n\nwww.EBooksWorld.ir\n\nthe object, and the derivations remain consistent.\n\nAs well as a class, functions like this can also be combined into a nested function.\n\nUsually I prefer a class to a nested function, as it can be difficult to test functions nested\n\nwithin another. Classes are also necessary when there is more than one function in the\n\ngroup that I want to expose to collaborators.\n\nLanguages that don’t have classes as a first­class element, but do have first­class\n\nfunctions, often use the Function As Object [mf­fao] to provide this capability.\n\nMechanics\n\nApply Encapsulate Record (162) to the common data record that the functions\n\nshare.\n\nIf the data that is common between the functions isn’t already grouped into a record\n\nstructure, use Introduce Parameter Object (140) to create a record to group it\n\ntogether.\n\nTake each function that uses the common record and use Move Function (198) to\n\nmove it into the new class.\n\nAny arguments to the function call that are members can be removed from the\n\nargument list.\n\nEach bit of logic that manipulates the data can be extracted with Extract Function\n\n(106) and then moved into the new class.\n\nExample\n\nI grew up in England, a country renowned for its love of Tea. (Personally, I don’t like\n\nmost tea they serve in England, but have since acquired a taste for Chinese and\n\nJapanese teas.) So my author’s fantasy conjures up a state utility for providing tea to\n\nthe population. Every month they read the tea meters, to get a record like this:\n\nClick here to view code image\n\nreading = {customer: \"ivan\", quantity: 10, month: 5, year: 2017};\n\nI look through the code that processes these records, and I see lots of places where\n\nsimilar calculations are done on the data. So I find a spot that calculates the base\n\nwww.EBooksWorld.ir\n\ncharge:\n\nclient 1…\n\nClick here to view code image\n\nconst aReading = acquireReading(); const baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity;\n\nBeing England, everything essential must be taxed, so it is with tea. But the rules allow\n\nat least an essential level of tea to be free of taxation.\n\nclient 2…\n\nClick here to view code image\n\nconst aReading = acquireReading(); const base = (baseRate(aReading.month, aReading.year) * aReading.quantity); const taxableCharge = Math.max(0, base ­ taxThreshold(aReading.year));\n\nI’m sure that, like me, you noticed that the formula for the base charge is duplicated\n\nbetween these two fragments. If you’re like me, you’re already reaching for Extract\n\nFunction (106). Interestingly, it seems our work has been done for us elsewhere.\n\nclient 3…\n\nClick here to view code image\n\nconst aReading = acquireReading(); const basicChargeAmount = calculateBaseCharge(aReading);\n\nfunction calculateBaseCharge(aReading) { return baseRate(aReading.month, aReading.year) * aReading.quantity; }\n\nGiven this, I have a natural impulse to change the two earlier bits of client code to use\n\nthis function. But the trouble with top­level functions like this is that they are often easy\n\nto miss. I’d rather change the code to give the function a closer connection to the data it\n\nprocesses. A good way to do this is to turn the data into a class.\n\nTo turn the record into a class, I use Encapsulate Record (162).\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nclass Reading { constructor(data) { this._customer = data.customer; this._quantity = data.quantity; this._month = data.month; this._year = data.year; } get customer() {return this._customer;} get quantity() {return this._quantity;} get month() {return this._month;} get year() {return this._year;} }\n\nTo move the behavior, I’ll start with the function I already have:\n\ncalculateBaseCharge. To use the new class, I need to apply it to the data as soon as\n\nI’ve acquired it.\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const basicChargeAmount = calculateBaseCharge(aReading);\n\nI then use Move Function (198) to move calculateBaseCharge into the new class.\n\nclass Reading…\n\nClick here to view code image\n\nget calculateBaseCharge() { return baseRate(this.month, this.year) * this.quantity; }\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const basicChargeAmount = aReading.calculateBaseCharge;\n\nwww.EBooksWorld.ir\n\nWhile I’m at it, I use Rename Function (124) to make it something more to my liking.\n\nClick here to view code image\n\nget baseCharge() { return baseRate(this.month, this.year) * this.quantity; }\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const basicChargeAmount = aReading.baseCharge;\n\nWith this naming, the client of the reading class can’t tell whether the base charge is a\n\nfield or a derived value. This is a Good Thing—the Uniform Access Principle [mf­ua].\n\nI now alter the first client to call the method rather than repeat the calculation.\n\nclient 1…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const baseCharge = aReading.baseCharge;\n\nThere’s a strong chance I’ll use Inline Variable (123) on the baseCharge variable\n\nbefore the day is out. But more relevant to this refactoring is the client that calculates\n\nthe taxable amount. My first step here is to use the new base charge property.\n\nclient 2…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const taxableCharge = Math.max(0, aReading.baseCharge ­ taxThreshold(aReading.year));\n\nwww.EBooksWorld.ir\n\nI use Extract Function (106) on the calculation for the taxable charge.\n\nClick here to view code image\n\nfunction taxableChargeFn(aReading) { return Math.max(0, aReading.baseCharge ­ taxThreshold(aReading.year)); }\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const taxableCharge = taxableChargeFn(aReading);\n\nThen I apply Move Function (198).\n\nclass Reading…\n\nClick here to view code image\n\nget taxableCharge() { return Math.max(0, this.baseCharge ­ taxThreshold(this.year)); }\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const taxableCharge = aReading.taxableCharge;\n\nSince all the derived data is calculated on demand, I have no problem should I need to\n\nupdate the stored data. In general, I prefer immutable data, but many circumstances\n\nforce us to work with mutable data (such as JavaScript, a language ecosystem that\n\nwasn’t designed with immutability in mind). When there is a reasonable chance the\n\ndata will be updated somewhere in the program, then a class is very helpful.\n\nwww.EBooksWorld.ir\n\nCOMBINE FUNCTIONS INTO TRANSFORM",
      "page_number": 159
    },
    {
      "number": 18,
      "title": "Segment 18 (pages 170-177)",
      "start_page": 170,
      "end_page": 177,
      "detection_method": "topic_boundary",
      "content": "COMBINE FUNCTIONS INTO TRANSFORM\n\nMotivation\n\nSoftware often involves feeding data into programs that calculate various derived\n\ninformation from it. These derived values may be needed in several places, and those\n\ncalculations are often repeated wherever the derived data is used. I prefer to bring all of\n\nthese derivations together, so I have a consistent place to find and update them and\n\navoid any duplicate logic.\n\nOne way to do this is to use a data transformation function that takes the source data as\n\ninput and calculates all the derivations, putting each derived value as a field in the\n\noutput data. Then, to examine the derivations, all I need do is look at the transform\n\nfunction.\n\nAn alternative to Combine Functions into Transform is Combine Functions into Class\n\n(144) that moves the logic into methods on a class formed from the source data. Either\n\nof these refactorings are helpful, and my choice will often depend on the style of\n\nprogramming already in the software. But there is one important difference: Using a\n\nclass is much better if the source data gets updated within the code. Using a transform\n\nstores derived data in the new record, so if the source data changes, I will run into\n\ninconsistencies.\n\nOne of the reasons I like to do combine functions is to avoid duplication of the\n\nwww.EBooksWorld.ir\n\nderivation logic. I can do that just by using Extract Function (106) on the logic, but it’s\n\noften difficult to find the functions unless they are kept close to the data structures they\n\noperate on. Using a transform (or a class) makes it easy to find and use them.\n\nMechanics\n\nCreate a transformation function that takes the record to be transformed and\n\nreturns the same values.\n\nThis will usually involve a deep copy of the record. It is often worthwhile to write a\n\ntest to ensure the transform does not alter the original record.\n\nPick some logic and move its body into the transform to create a new field in the\n\nrecord. Change the client code to access the new field.\n\nIf the logic is complex, use Extract Function (106) first.\n\nTest.\n\nRepeat for the other relevant functions.\n\nExample\n\nWhere I grew up, tea is an important part of life—so much that I can imagine a special\n\nutility that provides tea to the populace that’s regulated like a utility. Every month, the\n\nutility gets a reading of how much tea a customer has acquired.\n\nClick here to view code image\n\nreading = {customer: \"ivan\", quantity: 10, month: 5, year: 2017};\n\nCode in various places calculates various consequences of this tea usage. One such\n\ncalculation is the base monetary amount that’s used to calculate the charge for the\n\ncustomer.\n\nclient 1…\n\nClick here to view code image\n\nconst aReading = acquireReading(); const baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity;\n\nwww.EBooksWorld.ir\n\nAnother is the amount that should be taxed—which is less than the base amount since\n\nthe government wisely considers that every citizen should get some tea tax free.\n\nclient 2…\n\nClick here to view code image\n\nconst aReading = acquireReading(); const base = (baseRate(aReading.month, aReading.year) * aReading.quantity); const taxableCharge = Math.max(0, base ­ taxThreshold(aReading.year));\n\nLooking through this code, I see these calculations repeated in several places. Such\n\nduplication is asking for trouble when they need to change (and I’d bet it’s “when” not\n\n“if”). I can deal with this repetition by using Extract Function (106) on these\n\ncalculations, but such functions often end up scattered around the program making it\n\nhard for future developers to realize they are there. Indeed, looking around I discover\n\nsuch a function, used in another area of the code.\n\nclient 3…\n\nClick here to view code image\n\nconst aReading = acquireReading(); const basicChargeAmount = calculateBaseCharge(aReading);\n\nfunction calculateBaseCharge(aReading) { return baseRate(aReading.month, aReading.year) * aReading.quantity; }\n\nOne way of dealing with this is to move all of these derivations into a transformation\n\nstep that takes the raw reading and emits a reading enriched with all the common\n\nderived results.\n\nI begin by creating a transformation function that merely copies the input object.\n\nClick here to view code image\n\nfunction enrichReading(original) { const result = _.cloneDeep(original); return result; }\n\nwww.EBooksWorld.ir\n\nI’m using the cloneDeep from lodash to create a deep copy.\n\nWhen I’m applying a transformation that produces essentially the same thing but with\n\nadditional information, I like to name it using “enrich”. If it were producing something\n\nI felt was different, I would name it using “transform”.\n\nI then pick one of the calculations I want to change. First, I enrich the reading it uses\n\nwith the current one that does nothing yet.\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = enrichReading(rawReading); const basicChargeAmount = calculateBaseCharge(aReading);\n\nI use Move Function (198) on calculateBaseCharge to move it into the enrichment\n\ncalculation.\n\nClick here to view code image\n\nfunction enrichReading(original) { const result = _.cloneDeep(original); result.baseCharge = calculateBaseCharge(result); return result; }\n\nWithin the transformation function, I’m happy to mutate a result object, instead of\n\ncopying each time. I like immutability, but most common languages make it difficult to\n\nwork with. I’m prepared to go through the extra effort to support it at boundaries, but\n\nwill mutate within smaller scopes. I also pick my names (using aReading as the\n\naccumulating variable) to make it easier to move the code into the transformer\n\nfunction.\n\nI change the client that uses that function to use the enriched field instead.\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading();\n\nwww.EBooksWorld.ir\n\nconst aReading = enrichReading(rawReading); const basicChargeAmount = aReading.baseCharge;\n\nOnce I’ve moved all calls to calculateBaseCharge, I can nest it inside\n\nenrichReading. That would make it clear that clients that need the calculated base\n\ncharge should use the enriched record.\n\nOne trap to beware of here. When I write enrichReading like this, to return the\n\nenriched reading, I’m implying that the original reading record isn’t changed. So it’s\n\nwise for me to add a test.\n\nClick here to view code image\n\nit('check reading unchanged', function() { const baseReading = {customer: \"ivan\", quantity: 15, month: 5, year: 2017}; const oracle = _.cloneDeep(baseReading); enrichReading(baseReading); assert.deepEqual(baseReading, oracle); });\n\nI can then change client 1 to also use the same field.\n\nclient 1…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = enrichReading(rawReading); const baseCharge = aReading.baseCharge;\n\nThere is a good chance I can then use Inline Variable (123) on baseCharge too.\n\nNow I turn to the taxable amount calculation. My first step is to add in the\n\ntransformation function.\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = enrichReading(rawReading); const base = (baseRate(aReading.month, aReading.year) * aReading.quantity); const taxableCharge = Math.max(0, base ­ taxThreshold(aReading.year));\n\nwww.EBooksWorld.ir\n\nI can immediately replace the calculation of the base charge with the new field. If the\n\ncalculation was complex, I could Extract Function (106) first, but here it’s simple\n\nenough to do in one step.\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = enrichReading(rawReading); const base = aReading.baseCharge; const taxableCharge = Math.max(0, base ­ taxThreshold(aReading.year));\n\nOnce I’ve tested that that works, I apply Inline Variable (123):\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = enrichReading(rawReading); const taxableCharge = Math.max(0, aReading.baseCharge ­ taxThreshold(aReading.year));\n\nand move that computation into the transformer:\n\nClick here to view code image\n\nfunction enrichReading(original) { const result = _.cloneDeep(original); result.baseCharge = calculateBaseCharge(result); result.taxableCharge = Math.max(0, result.baseCharge ­ taxThreshold(result.year)); return result; }\n\nI modify the original code to use the new field.\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = enrichReading(rawReading); const taxableCharge = aReading.taxableCharge;\n\nOnce I’ve tested that, it’s likely I would be able to use Inline Variable (123) on\n\ntaxableCharge.\n\nwww.EBooksWorld.ir\n\nOne big problem with an enriched reading like this is: What happens should a client\n\nchange a data value? Changing, say, the quantity field would result in data that’s\n\ninconsistent. To avoid this in JavaScript, my best option is to use Combine Functions\n\ninto Class (144) instead. If I’m in a language with immutable data structures, I don’t\n\nhave this problem, so its more common to see transforms in those languages. But even\n\nin languages without immutability, I can use transforms if the data appears in a read­\n\nonly context, such as deriving data to display on a web page.\n\nSPLIT PHASE\n\nMotivation\n\nWhen I run into code that’s dealing with two different things, I look for a way to split it\n\ninto separate modules. I endeavor to make this split because, if I need to make a\n\nchange, I can deal with each topic separately and not have to hold both in my head\n\ntogether. If I’m lucky, I may only have to change one module without having to\n\nremember the details of the other one at all.\n\nwww.EBooksWorld.ir\n\nOne of the neatest ways to do a split like this is to divide the behavior into two\n\nsequential phases. A good example of this is when you have some processing whose\n\ninputs don’t reflect the model you need to carry out the logic. Before you begin, you can\n\nmassage the input into a convenient form for your main processing. Or, you can take\n\nthe logic you need to do and break it down into sequential steps, where each step is\n\nsignificantly different in what it does.\n\nThe most obvious example of this is a compiler. It’s a basic task is to take some text\n\n(code in a programming language) and turn it into some executable form (e.g., object\n\ncode for a specific hardware). Over time, we’ve found this can be usefully split into a\n\nchain of phases: tokenizing the text, parsing the tokens into a syntax tree, then various\n\nsteps of transforming the syntax tree (e.g., for optimization), and finally generating the\n\nobject code. Each step has a limited scope and I can think of one step without\n\nunderstanding the details of others.\n\nSplitting phases like this is common in large software; the various phases in a compiler\n\ncan each contain many functions and classes. But I can carry out the basic split­phase\n\nrefactoring on any fragment of code—whenever I see an opportunity to usefully\n\nseparate the code into different phases. The best clue is when different stages of the\n\nfragment use different sets of data and functions. By turning them into separate\n\nmodules I can make this difference explicit, revealing the difference in the code.\n\nMechanics\n\nExtract the second phase code into its own function.\n\nTest.\n\nIntroduce an intermediate data structure as an additional argument to the extracted\n\nfunction.\n\nTest.\n\nExamine each parameter of the extracted second phase. If it is used by first phase,\n\nmove it to the intermediate data structure. Test after each move.\n\nSometimes, a parameter should not be used by the second phase. In this case,\n\nextract the results of each usage of the parameter into a field of the intermediate\n\ndata structure and use Move Statements to Callers (217) on the line that populates\n\nit.\n\nwww.EBooksWorld.ir",
      "page_number": 170
    },
    {
      "number": 19,
      "title": "Segment 19 (pages 178-185)",
      "start_page": 178,
      "end_page": 185,
      "detection_method": "topic_boundary",
      "content": "Apply Extract Function (106) on the first­phase code, returning the intermediate\n\ndata structure.\n\nIt’s also reasonable to extract the first phase into a transformer object.\n\nExample\n\nI’ll start with code to price an order for some vague and unimportant kind of goods:\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; const shippingPerCase = (basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = quantity * shippingPerCase; const price = basePrice ­ discount + shippingCost; return price; }\n\nAlthough this is the usual kind of trivial example, there is a sense of two phases going\n\non here. The first couple of lines of code use the product information to calculate the\n\nproduct­oriented price of the order, while the later code uses shipping information to\n\ndetermine the shipping cost. If I have changes coming up that complicate the pricing\n\nand shipping calculations, but they work relatively independently, then splitting this\n\ncode into two phases is valuable.\n\nI begin by applying Extract Function (106) to the shipping calculation.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; const price = applyShipping(basePrice, shippingMethod, quantity, discount); return price; } function applyShipping(basePrice, shippingMethod, quantity, discount) { const shippingPerCase = (basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = quantity * shippingPerCase; const price = basePrice ­ discount + shippingCost;\n\nwww.EBooksWorld.ir\n\nreturn price; }\n\nI pass in all the data that this second phase needs as individual parameters. In a more\n\nrealistic case, there can be a lot of these, but I don’t worry about it as I’ll whittle them\n\ndown later.\n\nNext, I introduce the intermediate data structure that will communicate between the\n\ntwo phases.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; const priceData = {}; const price = applyShipping(priceData, basePrice, shippingMethod, quantity, discount); return price; } function applyShipping(priceData, basePrice, shippingMethod, quantity, discount) { const shippingPerCase = (basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = quantity * shippingPerCase; const price = basePrice ­ discount + shippingCost; return price; }\n\nNow, I look at the various parameters to applyShipping. The first one is basePrice\n\nwhich is created by the first­phase code. So I move this into the intermediate data\n\nstructure, removing it from the parameter list.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; const priceData = {basePrice: basePrice}; const price = applyShipping(priceData, basePrice, shippingMethod, quantity, discount); return price; } function applyShipping(priceData, basePrice, shippingMethod, quantity, discount) { const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase;\n\nwww.EBooksWorld.ir\n\nconst shippingCost = quantity * shippingPerCase; const price = priceData.basePrice ­ discount + shippingCost; return price; }\n\nThe next parameter in the list is shippingMethod. This one I leave as is, since it isn’t\n\nused by the first­phase code.\n\nAfter this, I have quantity. This is used by the first phase but not created by it, so I\n\ncould actually leave this in the parameter list. My usual preference, however, is to move\n\nas much as I can to the intermediate data structure.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; const priceData = {basePrice: basePrice, quantity: quantity}; const price = applyShipping(priceData, shippingMethod, quantity, discount); return price; } function applyShipping(priceData, shippingMethod, quantity, discount) { const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = priceData.quantity * shippingPerCase; const price = priceData.basePrice ­ discount + shippingCost; return price; }\n\nI do the same with discount.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; const priceData = {basePrice: basePrice, quantity: quantity, discount:discount}; const price = applyShipping(priceData, shippingMethod, discount); return price; } function applyShipping(priceData, shippingMethod, discount) { const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = priceData.quantity * shippingPerCase;\n\nwww.EBooksWorld.ir\n\nconst price = priceData.basePrice ­ priceData.discount + shippingCost; return price; }\n\nOnce I’ve gone through all the function parameters, I have the intermediate data\n\nstructure fully formed. So I can extract the first­phase code into its own function,\n\nreturning this data.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const priceData = calculatePricingData(product, quantity); const price = applyShipping(priceData, shippingMethod); return price; } function calculatePricingData(product, quantity) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; return {basePrice: basePrice, quantity: quantity, discount:discount}; } function applyShipping(priceData, shippingMethod) { const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = priceData.quantity * shippingPerCase; const price = priceData.basePrice ­ priceData.discount + shippingCost; return price; }\n\nI can’t resist tidying out those final constants.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const priceData = calculatePricingData(product, quantity); return applyShipping(priceData, shippingMethod); } function calculatePricingData(product, quantity) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; return {basePrice: basePrice, quantity: quantity, discount:discount}; } function applyShipping(priceData, shippingMethod) { const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase;\n\nwww.EBooksWorld.ir\n\nconst shippingCost = priceData.quantity * shippingPerCase; return priceData.basePrice ­ priceData.discount + shippingCost; }\n\nwww.EBooksWorld.ir\n\nChapter 7 Encapsulation\n\nHistory\n\nTopics\n\nPerhaps the most important criteria to be used in decomposing modules is to identify\n\nsecrets that modules should hide from the rest of the system [Parnas]. Data structures\n\nTutorials\n\nare the most common secrets, and I can hide data structures by encapsulating them\n\nwith Encapsulate Record (162) and Encapsulate Collection (170). Even primitive data\n\nOffers & Deals\n\nvalues can be encapsulated with Replace Primitive with Object (174)—the magnitude of\n\nHighlights\n\nsecond­order benefits from doing this often surprises people. Temporary variables\n\noften get in the way of refactoring—I have to ensure they are calculated in the right\n\nSettings\n\norder and their values are available to other parts of the code that need them. Using\n\nReplace Temp with Query (178) is a great help here, particularly when splitting up an\n\nSupport\n\noverly long function.\n\nSign Out\n\nClasses were designed for information hiding. In the previous chapter, I described a\n\nway to form them with Combine Functions into Class (144). The common extract/inline\n\noperations also apply to classes with Extract Class (182) and Inline Class (186).\n\nAs well as hiding the internals of classes, it’s often useful to hide connections between\n\nclasses, which I can do with Hide Delegate (189). But too much hiding leads to bloated\n\ninterfaces, so I also need its reverse: Remove Middle Man (192).\n\nClasses and modules are the largest forms of encapsulation, but functions also\n\nencapsulate their implementation. Sometimes, I may need to make a wholesale change\n\nto an algorithm, which I can do by wrapping it in a function with Extract Function\n\n(106) and applying Substitute Algorithm (195).\n\nENCAPSULATE RECORD\n\nformerly: Replace Record with Data Class\n\nwww.EBooksWorld.ir\n\nMotivation\n\nThis is why I often favor objects over records for mutable data. With objects, I can hide\n\nwhat is stored and provide methods for all three values. The user of the object doesn’t\n\nneed to know or care which is stored and which is calculated. This encapsulation also\n\nhelps with renaming: I can rename the field while providing methods for both the new\n\nand the old names, gradually updating callers until they are all done.\n\nI just said I favor objects for mutable data. If I have an immutable value, I can just have\n\nall three values in my record, using an enrichment step if necessary. Similarly, it’s easy\n\nto copy the field when renaming.\n\nI can have two kinds of record structures: those where I declare the legal field names\n\nand those that allow me to use whatever I like. The latter are often implemented\n\nthrough a library class called something like hash, map, hashmap, dictionary, or\n\nassociative array. Many languages provide convenient syntax for creating hashmaps,\n\nwhich makes them useful in many programming situations. The downside of using\n\nthem is they are aren’t explicit about their fields. The only way I can tell if they use\n\nstart/end or start/length is by looking at where they are created and used. This isn’t a\n\nproblem if they are only used in a small section of a program, but the wider their scope\n\nof usage, the greater problem I get from their implicit structure. I could refactor such\n\nimplicit records into explicit ones—but if I need to do that, I’d rather make them classes\n\nwww.EBooksWorld.ir\n\ninstead.\n\nIt’s common to pass nested structures of lists and hashmaps which are often serialized\n\ninto formats like JSON or XML. Such structures can be encapsulated too, which helps if\n\ntheir formats change later on or if I’m concerned about updates to the data that are\n\nhard to keep track of.\n\nMechanics\n\nUse Encapsulate Variable (132) on the variable holding the record.\n\nGive the functions that encapsulate the record names that are easily searchable.\n\nReplace the content of the variable with a simple class that wraps the record. Define\n\nan accessor inside this class that returns the raw record. Modify the functions that\n\nencapsulate the variable to use this accessor.\n\nTest.\n\nProvide new functions that return the object rather than the raw record.\n\nFor each user of the record, replace its use of a function that returns the record with\n\na function that returns the object. Use an accessor on the object to get at the field\n\ndata, creating that accessor if needed. Test after each change.\n\nIf it’s a complex record, such as one with a nested structure, focus on clients that\n\nupdate the data first. Consider returning a copy or read­only proxy of the data for\n\nclients that only read the data.\n\nRemove the class’s raw data accessor and the easily searchable functions that\n\nreturned the raw record.\n\nTest.\n\nIf the fields of the record are themselves structures, consider using Encapsulate\n\nRecord and Encapsulate Collection (170) recursively.\n\nExample\n\nI’ll start with a constant that is widely used across a program.\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "page_number": 178
    },
    {
      "number": 20,
      "title": "Segment 20 (pages 186-193)",
      "start_page": 186,
      "end_page": 193,
      "detection_method": "topic_boundary",
      "content": "const organization = {name: \"Acme Gooseberries\", country: \"GB\"};\n\nThis is a JavaScript object which is being used as a record structure by various parts of\n\nthe program, with accesses like this:\n\nClick here to view code image\n\nresult += `<h1>${organization.name}</h1>`;\n\nand\n\norganization.name = newName;\n\nThe first step is a simple Encapsulate Variable (132).\n\nClick here to view code image\n\nfunction getRawDataOfOrganization() {return organization;}\n\nexample reader…\n\nClick here to view code image\n\nresult += `<h1>${getRawDataOfOrganization().name}</h1>`;\n\nexample writer…\n\nClick here to view code image\n\ngetRawDataOfOrganization().name = newName;\n\nIt’s not quite a standard Encapsulate Variable (132), since I gave the getter a name\n\ndeliberately chosen to be both ugly and easy to search for. This is because I intend its\n\nlife to be short.\n\nEncapsulating a record means going deeper than just the variable itself; I want to\n\ncontrol how it’s manipulated. I can do this by replacing the record with a class.\n\nwww.EBooksWorld.ir\n\nclass Organization…\n\nclass Organization { constructor(data) { this._data = data; } }\n\ntop level\n\nClick here to view code image\n\nconst organization = new Organization({name: \"Acme Gooseberries\", country: \"GB\"});\n\nfunction getRawDataOfOrganization() {return organization._data;} function getOrganization() {return organization;}\n\nNow that I have an object in place, I start looking at the users of the record. Any one\n\nthat updates the record gets replaced with a setter.\n\nclass Organization…\n\nClick here to view code image\n\nset name(aString) {this._data.name = aString;}\n\nclient…\n\ngetOrganization().name = newName;\n\nSimilarly, I replace any readers with the appropriate getter.\n\nclass Organization…\n\nClick here to view code image\n\nget name() {return this._data.name;}\n\nclient…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nresult += `<h1>${getOrganization().name}</h1>`;\n\nAfter I’ve done that, I can follow through on my threat to give the ugly sounding\n\nfunction a short life.\n\nClick here to view code image\n\nfunction getRawDataOfOrganization() {return organization._data;} function getOrganization() {return organization;}\n\nI’d also be inclined to fold the _data field directly into the object.\n\nClick here to view code image\n\nclass Organization { constructor(data) { this._name = data.name; this._country = data.country; } get name() {return this._name;} set name(aString) {this._name = aString;} get country() {return this._country;} set country(aCountryCode) {this._country = aCountryCode;} }\n\nThis has the advantage of breaking the link to the input data record. This might be\n\nuseful if a reference to it runs around, which would break encapsulation. Should I not\n\nfold the data into individual fields, I would be wise to copy _data when I assign it.\n\nExample: Encapsulating a Nested Record\n\nThe above example looks at a shallow record, but what do I do with data that is deeply\n\nnested, e.g., coming from a JSON document? The core refactoring steps still apply, and\n\nI have to be equally careful with updates, but I do get some options around reads.\n\nAs an example, here is some slightly more nested data: a collection of customers, kept\n\nin a hashmap indexed by their customer ID.\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\n\"1920\": { name: \"martin\", id: \"1920\", usages: { \"2016\": { \"1\": 50, \"2\": 55, // remaining months of the year }, \"2015\": { \"1\": 70, \"2\": 63, // remaining months of the year } } }, \"38673\": { name: \"neal\", id: \"38673\", // more customers in a similar form\n\nWith more nested data, reads and writes can be digging into the data structure.\n\nsample update…\n\nClick here to view code image\n\ncustomerData[customerID].usages[year][month] = amount;\n\nsample read…\n\nClick here to view code image\n\nfunction compareUsage (customerID, laterYear, month) { const later = customerData[customerID].usages[laterYear][month]; const earlier = customerData[customerID].usages[laterYear ­ 1][month]; return {laterAmount: later, change: later ­ earlier}; }\n\nTo encapsulate this data, I also start with Encapsulate Variable (132).\n\nClick here to view code image\n\nfunction getRawDataOfCustomers() {return customerData;} function setRawDataOfCustomers(arg) {customerData = arg;}\n\nwww.EBooksWorld.ir\n\nsample update…\n\nClick here to view code image\n\ngetRawDataOfCustomers()[customerID].usages[year][month] = amount;\n\nsample read…\n\nClick here to view code image\n\nfunction compareUsage (customerID, laterYear, month) { const later = getRawDataOfCustomers()[customerID].usages[laterYear][month]; const earlier = getRawDataOfCustomers()[customerID].usages[laterYear ­ 1][month]; return {laterAmount: later, change: later ­ earlier}; }\n\nI then make a class for the overall data structure.\n\nclass CustomerData { constructor(data) { this._data = data; } }\n\ntop level…\n\nClick here to view code image\n\nfunction getCustomerData() {return customerData;} function getRawDataOfCustomers() {return customerData._data;} function setRawDataOfCustomers(arg) {customerData = new CustomerData(arg);}\n\nThe most important area to deal with is the updates. So, while I look at all the callers of\n\ngetRawDataOfCustomers, I’m focused on those where the data is changed. To\n\nremind you, here’s the update again:\n\nsample update…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\ngetRawDataOfCustomers()[customerID].usages[year][month] = amount;\n\nThe general mechanics now say to return the full customer and use an accessor,\n\ncreating one if needed. I don’t have a setter on the customer for this update, and this\n\none digs into the structure. So, to make one, I begin by using Extract Function (106) on\n\nthe code that digs into the data structure.\n\nsample update…\n\nClick here to view code image\n\nsetUsage(customerID, year, month, amount);\n\ntop level…\n\nClick here to view code image\n\nfunction setUsage(customerID, year, month, amount) { getRawDataOfCustomers()[customerID].usages[year][month] = amount; }\n\nI then use Move Function (198) to move it into the new customer data class.\n\nsample update…\n\nClick here to view code image\n\ngetCustomerData().setUsage(customerID, year, month, amount);\n\nclass CustomerData…\n\nClick here to view code image\n\nsetUsage(customerID, year, month, amount) { this._data[customerID].usages[year][month] = amount; }\n\nWhen working with a big data structure, I like to concentrate on the updates. Getting\n\nthem visible and gathered in a single place is the most important part of the\n\nencapsulation.\n\nwww.EBooksWorld.ir\n\nAt some point, I will think I’ve got them all—but how can I be sure? There’s a couple of\n\nways to check. One is to modify getRawDataOfCustomers to return a deep copy of\n\nthe data; if my test coverage is good, one of the tests should break if I missed a\n\nmodification.\n\ntop level…\n\nClick here to view code image\n\nfunction getCustomerData() {return customerData;} function getRawDataOfCustomers() {return customerData.rawData;} function setRawDataOfCustomers(arg) {customerData = new CustomerData(arg);}\n\nclass CustomerData…\n\nClick here to view code image\n\nget rawData() { return _.cloneDeep(this._data); }\n\nI’m using the lodash library to make a deep copy.\n\nAnother approach is to return a read­only proxy for the data structure. Such a proxy\n\ncould raise an exception if the client code tries to modify the underlying object. Some\n\nlanguages make this easy, but it’s a pain in JavaScript, so I’ll leave it as an exercise for\n\nthe reader. I could also take a copy and recursively freeze it to detect any modifications.\n\nDealing with the updates is valuable, but what about the readers? Here there are a few\n\noptions.\n\nThe first option is to do the same thing as I did for the setters. Extract all the reads into\n\ntheir own functions and move them into the customer data class.\n\nclass CustomerData…\n\nClick here to view code image\n\nusage(customerID, year, month) { return this._data[customerID].usages[year][month]; }\n\nwww.EBooksWorld.ir\n\ntop level…\n\nClick here to view code image\n\nfunction compareUsage (customerID, laterYear, month) { const later = getCustomerData().usage(customerID, laterYear, month); const earlier = getCustomerData().usage(customerID, laterYear ­ 1, month) return {laterAmount: later, change: later ­ earlier}; }\n\nThe great thing about this approach is that it gives customerData an explicit API that\n\ncaptures all the uses made of it. I can look at the class and see all their uses of the data.\n\nBut this can be a lot of code for lots of special cases. Modern languages provide good\n\naffordances for digging into a list­and­hash [mf­lh] data structure, so it’s useful to give\n\nclients just such a data structure to work with.\n\nIf the client wants a data structure, I can just hand out the actual data. But the problem\n\nwith this is that there’s no way to prevent clients from modifying the data directly,\n\nwhich breaks the whole point of encapsulating all the updates inside functions.\n\nConsequently, the simplest thing to do is to provide a copy of the underlying data, using\n\nthe rawData method I wrote earlier.\n\nclass CustomerData…\n\nClick here to view code image\n\nget rawData() { return _.cloneDeep(this._data); }\n\ntop level…\n\nClick here to view code image\n\nfunction compareUsage (customerID, laterYear, month) { const later = getCustomerData().rawData[customerID].usages[laterYear][month]; const earlier = getCustomerData().rawData[customerID].usages[laterYear ­ 1][month]; return {laterAmount: later, change: later ­ earlier}; }\n\nBut although it’s simple, there are downsides. The most obvious problem is the cost of\n\nwww.EBooksWorld.ir",
      "page_number": 186
    },
    {
      "number": 21,
      "title": "Segment 21 (pages 194-204)",
      "start_page": 194,
      "end_page": 204,
      "detection_method": "topic_boundary",
      "content": "copying a large data structure, which may turn out to be a performance problem. As\n\nwith anything like this, however, the performance cost might be acceptable—I would\n\nwant to measure its impact before I start to worry about it. There may also be confusion\n\nif clients expect modifying the copied data to modify the original. In those cases, a read­\n\nonly proxy or freezing the copied data might provide a helpful error should they do this.\n\nAnother option is more work, but offers the most control: Apply Encapsulate Record\n\nrecursively. With this, I turn the customer record into its own class, apply Encapsulate\n\nCollection (170) to the usages, and create a usage class. I can then enforce control of\n\nupdates by using accessors, perhaps applying Change Reference to Value (252) on the\n\nusage objects. But this can be a lot of effort for a large data structure—and not really\n\nneeded if I don’t access that much of the data structure. Sometimes, a judicious mix of\n\ngetters and new classes may work, using a getter to dig deep into the structure but\n\nreturning an object that wraps the structure rather than the unencapsulated data. I\n\nwrote about this kind of thing in an article “Refactoring Code to Load a Document” [mf­\n\nref­doc].\n\nENCAPSULATE COLLECTION\n\nMotivation\n\nI like encapsulating any mutable data in my programs. This makes it easier to see when\n\nand how data structures are modified, which then makes it easier to change those data\n\nstructures when I need to. Encapsulation is often encouraged, particularly by object­\n\noriented developers, but a common mistake occurs when working with collections. www.EBooksWorld.ir\n\nAccess to a collection variable may be encapsulated, but if the getter returns the\n\ncollection itself, then that collection’s membership can be altered without the enclosing\n\nclass being able to intervene.\n\nTo avoid this, I provide collection modifier methods—usually add and remove—on the\n\nclass itself. This way, changes to the collection go through the owning class, giving me\n\nthe opportunity to modify such changes as the program evolves.\n\nIff the team has the habit to not to modify collections outside the original module, just\n\nproviding these methods may be enough. However, it’s usually unwise to rely on such\n\nhabits; a mistake here can lead to bugs that are difficult to track down later. A better\n\napproach is to ensure that the getter for the collection does not return the raw\n\ncollection, so that clients cannot accidentally change it.\n\nOne way to prevent modification of the underlying collection is by never returning a\n\ncollection value. In this approach, any use of a collection field is done with specific\n\nmethods on the owning class, replacing aCustomer.orders.size with\n\naCustomer.numberOfOrders. I don’t agree with this approach. Modern languages\n\nhave rich collection classes with standardized interfaces, which can be combined in\n\nuseful ways such as Collection Pipelines [mf­cp]. Putting in special methods to handle\n\nthis kind of functionality adds a lot of extra code and cripples the easy composability of\n\ncollection operations.\n\nAnother way is to allow some form of read­only access to a collection. Java, for\n\nexample, makes it easy to return a read­only proxy to the collection. Such a proxy\n\nforwards all reads to the underlying collection, but blocks all writes—in Java’s case,\n\nthrowing an exception. A similar route is used by libraries that base their collection\n\ncomposition on some kind of iterator or enumerable object—providing that iterator\n\ncannot modify the underlying collection.\n\nProbably the most common approach is to provide a getting method for the collection,\n\nbut make it return a copy of the underlying collection. That way, any modifications to\n\nthe copy don’t affect the encapsulated collection. This might cause some confusion if\n\nprogrammers expect the returned collection to modify the source field—but in many\n\ncode bases, programmers are used to collection getters providing copies. If the\n\ncollection is huge, this may be a performance issue—but most lists aren’t all that big, so\n\nthe general rules for performance should apply (Refactoring and Performance (64)).\n\nAnother difference between using a proxy and a copy is that a modification of the\n\nsource data will be visible in the proxy but not in a copy. This isn’t an issue most of the\n\nwww.EBooksWorld.ir\n\ntime, because lists accessed in this way are usually only held for a short time.\n\nWhat’s important here is consistency within a code base. Use only one mechanism so\n\neveryone can get used to how it behaves and expect it when calling any collection\n\naccessor function.\n\nMechanics\n\nApply Encapsulate Variable (132) if the reference to the collection isn’t already\n\nencapsulated.\n\nAdd functions to add and remove elements from the collection.\n\nIf there is a setter for the collection, use Remove Setting Method (331) if possible. If\n\nnot, make it take a copy of the provided collection.\n\nRun static checks.\n\nFind all references to the collection. If anyone calls modifiers on the collection,\n\nchange them to use the new add/remove functions. Test after each change.\n\nModify the getter for the collection to return a protected view on it, using a read­\n\nonly proxy or a copy.\n\nTest.\n\nExample\n\nI start with a person class that has a field for a list of courses.\n\nclass Person…\n\nClick here to view code image\n\nconstructor (name) { this._name = name; this._courses = []; } get name() {return this._name;} get courses() {return this._courses;} set courses(aList) {this._courses = aList;}\n\nclass Course…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nconstructor(name, isAdvanced) { this._name = name; this._isAdvanced = isAdvanced; } get name() {return this._name;} get isAdvanced() {return this._isAdvanced;}\n\nClients use the course collection to gather information on courses.\n\nClick here to view code image\n\nnumAdvancedCourses = aPerson.courses .filter(c => c.isAdvanced) .length ;\n\nA naive developer would say this class has proper data encapsulation: After all, each\n\nfield is protected by accessor methods. But I would argue that the list of courses isn’t\n\nproperly encapsulated. Certainly, anyone updating the courses as a single value has\n\nproper control through the setter:\n\nclient code…\n\nClick here to view code image\n\nconst basicCourseNames = readBasicCourseNames(filename); aPerson.courses = basicCourseNames.map(name => new Course(name, false));\n\nBut clients might find it easier to update the course list directly.\n\nclient code…\n\nClick here to view code image\n\nfor(const name of readBasicCourseNames(filename)) { aPerson.courses.push(new Course(name, false)); }\n\nThis violates encapsulating because the person class has no ability to take control when\n\nwww.EBooksWorld.ir\n\nthe list is updated in this way. While the reference to the field is encapsulated, the\n\ncontent of the field is not.\n\nI’ll begin creating proper encapsulation by adding methods to the person class that\n\nallow a client to add and remove individual courses.\n\nclass Person…\n\nClick here to view code image\n\naddCourse(aCourse) { this._courses.push(aCourse); } removeCourse(aCourse, fnIfAbsent = () => {throw new RangeError();}) { const index = this._courses.indexOf(aCourse); if (index === ­1) fnIfAbsent(); else this._courses.splice(index, 1); }\n\nWith a removal, I have to decide what to do if a client asks to remove an element that\n\nisn’t in the collection. I can either shrug, or raise an error. With this code, I default to\n\nraising an error, but give the callers an opportunity to do something else if they wish.\n\nI then change any code that calls modifiers directly on the collection to use new\n\nmethods.\n\nclient code…\n\nClick here to view code image\n\nfor(const name of readBasicCourseNames(filename)) { aPerson.addCourse(new Course(name, false)); }\n\nWith individual add and remove methods, there is usually no need for setCourses, in\n\nwhich case I’ll use Remove Setting Method (331) on it. Should the API need a setting\n\nmethod for some reason, I ensure it puts a copy of the collection in the field.\n\nclass Person…\n\nClick here to view code image\n\nset courses(aList) {this._courses = aList.slice();}\n\nwww.EBooksWorld.ir\n\nAll this enables the clients to use the right kind of modifier methods, but I prefer to\n\nensure nobody modifies the list without using them. I can do this by providing a copy.\n\nclass Person…\n\nClick here to view code image\n\nget courses() {return this._courses.slice();}\n\nIn general, I find it wise to be moderately paranoid about collections and I’d rather copy\n\nthem unnecessarily than debug errors due to unexpected modifications. Modifications\n\naren’t always obvious; for example, sorting an array in JavaScript modifies the original,\n\nwhile many languages default to making a copy for an operation that changes a\n\ncollection. Any class that’s responsible for managing a collection should always give out\n\ncopies—but I also get into the habit of making a copy if I do something that’s liable to\n\nchange a collection.\n\nREPLACE PRIMITIVE WITH OBJECT\n\nformerly: Replace Data Value with Object\n\nformerly: Replace Type Code with Class\n\nMotivation\n\nOften, in early stages of development you make decisions about representing simple\n\nwww.EBooksWorld.ir\n\nfacts as simple data items, such as numbers or strings. As development proceeds, those\n\nsimple items aren’t so simple anymore. A telephone number may be represented as a\n\nstring for a while, but later it will need special behavior for formatting, extracting the\n\narea code, and the like. This kind of logic can quickly end up being duplicated around\n\nthe code base, increasing the effort whenever it needs to be used.\n\nAs soon as I realize I want to do something other than simple printing, I like to create a\n\nnew class for that bit of data. At first, such a class does little more than wrap the\n\nprimitive—but once I have that class, I have a place to put behavior specific to its needs.\n\nThese little values start very humble, but once nurtured they can grow into useful tools.\n\nThey may not look like much, but I find their effects on a code base can be surprisingly\n\nlarge. Indeed many experienced developers consider this to be one of the most valuable\n\nrefactorings in the toolkit—even though it often seems counterintuitive to a new\n\nprogrammer.\n\nMechanics\n\nApply Encapsulate Variable (132) if it isn’t already.\n\nCreate a simple value class for the data value. It should take the existing value in its\n\nconstructor and provide a getter for that value.\n\nRun static checks.\n\nChange the setter to create a new instance of the value class and store that in the\n\nfield, changing the type of the field if present.\n\nChange the getter to return the result of invoking the getter of the new class.\n\nTest.\n\nConsider using Rename Function (124) on the original accessors to better reflect\n\nwhat they do.\n\nConsider clarifying the role of the new object as a value or reference object by\n\napplying Change Reference to Value (252) or Change Value to Reference (256).\n\nExample\n\nI begin with a simple order class that reads its data from a simple record structure. One\n\nof its properties is a priority, which it reads as a simple string.\n\nwww.EBooksWorld.ir\n\nclass Order…\n\nClick here to view code image\n\nconstructor(data) { this.priority = data.priority; // more initialization\n\nSome client codes uses it like this:\n\nclient…\n\nClick here to view code image\n\nhighPriorityCount = orders.filter(o => \"high\" === o.priority || \"rush\" === o.priority) .length;\n\nWhenever I’m fiddling with a data value, the first thing I do is use Encapsulate\n\nVariable (132) on it.\n\nclass Order…\n\nClick here to view code image\n\nget priority() {return this._priority;} set priority(aString) {this._priority = aString;}\n\nThe constructor line that initializes the priority will now use the setter I define here.\n\nThis self­encapsulates the field so I can preserve its current use while I manipulate the\n\ndata itself.\n\nI create a simple value class for the priority. It has a constructor for the value and a\n\nconversion function to return a string.\n\nClick here to view code image\n\nclass Priority { constructor(value) {this._value = value;} toString() {return this._value;} }\n\nwww.EBooksWorld.ir\n\nI prefer using a conversion function (toString) rather than a getter (value) here.\n\nFor clients of the class, asking for the string representation should feel more like a\n\nconversion than getting a property.\n\nI then modify the accessors to use this new class.\n\nclass Order…\n\nClick here to view code image\n\nget priority() {return this._priority.toString();} set priority(aString) {this._priority = new Priority(aString);}\n\nNow that I have a priority class, I find the current getter on the order to be misleading.\n\nIt doesn’t return the priority—but a string that describes the priority. My immediate\n\nmove is to use Rename Function (124).\n\nclass Order…\n\nClick here to view code image\n\nget priorityString() {return this._priority.toString();} set priority(aString) {this._priority = new Priority(aString);}\n\nclient…\n\nClick here to view code image\n\nhighPriorityCount = orders.filter(o => \"high\" === o.priorityString || \"rush\" === o.priorityString) .length;\n\nIn this case, I’m happy to retain the name of the setter. The name of the argument\n\ncommunicates what it expects.\n\nNow I’m done with the formal refactoring. But as I look at who uses the priority, I\n\nconsider whether they should use the priority class themselves. As a result, I provide a\n\ngetter on order that provides the new priority object directly.\n\nclass Order…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nget priority() {return this._priority;} get priorityString() {return this._priority.toString();} set priority(aString) {this._priority = new Priority(aString);}\n\nclient…\n\nClick here to view code image\n\nhighPriorityCount = orders.filter(o => \"high\" === o.priority.toString() || \"rush\" === o.priority.toString()) .length;\n\nAs the priority class becomes useful elsewhere, I would allow clients of the order to use\n\nthe setter with a priority instance, which I do by adjusting the priority constructor.\n\nclass Priority…\n\nClick here to view code image\n\nconstructor(value) { if (value instanceof Priority) return value; this._value = value; }\n\nThe point of all this is that now, my new priority class can be useful as a place for new\n\nbehavior—either new to the code or moved from elsewhere. Here’s some simple code to\n\nadd validation of priority values and comparison logic:\n\nclass Priority…\n\nClick here to view code image\n\nconstructor(value) { if (value instanceof Priority) return value; if (Priority.legalValues().includes(value)) this._value = value; else throw new Error(`<${value}> is invalid for Priority`); } toString() {return this._value;} get _index() {return Priority.legalValues().findIndex(s => s === this._value);}\n\nwww.EBooksWorld.ir\n\nstatic legalValues() {return ['low', 'normal', 'high', 'rush'];}\n\nequals(other) {return this._index === other._index;} higherThan(other) {return this._index > other._index;} lowerThan(other) {return this._index < other._index;}\n\nAs I do this, I decide that a priority should be a value object, so I provide an equals\n\nmethod and ensure that it is immutable.\n\nNow I’ve added that behavior, I can make the client code more meaningful:\n\nclient…\n\nClick here to view code image\n\nhighPriorityCount = orders.filter(o => o.priority.higherThan(new Priority(\"normal\")) .length;\n\nREPLACE TEMP WITH QUERY\n\nwww.EBooksWorld.ir\n\nMotivation",
      "page_number": 194
    },
    {
      "number": 22,
      "title": "Segment 22 (pages 205-212)",
      "start_page": 205,
      "end_page": 212,
      "detection_method": "topic_boundary",
      "content": "Motivation\n\nOne use of temporary variables is to capture the value of some code in order to refer to\n\nit later in a function. Using a temp allows me to refer to the value while explaining its\n\nmeaning and avoiding repeating the code that calculates it. But while using a variable is\n\nhandy, it can often be worthwhile to go a step further and use a function instead.\n\nIf I’m working on breaking up a large function, turning variables into their own\n\nfunctions makes it easier to extract parts of the function, since I no longer need to pass\n\nin variables into the extracted functions. Putting this logic into functions often also sets\n\nup a stronger boundary between the extracted logic and the original function, which\n\nhelps me spot and avoid awkward dependencies and side effects.\n\nUsing functions instead of variables also allows me to avoid duplicating the calculation\n\nlogic in similar functions. Whenever I see variables calculated in the same way in\n\ndifferent places, I look to turn them into a single function.\n\nThis refactoring works best if I’m inside a class, since the class provides a shared\n\ncontext for the methods I’m extracting. Outside of a class, I’m liable to have too many\n\nparameters in a top­level function which negates much of the benefit of using a\n\nfunction. Nested functions can avoid this, but they limit my ability to share the logic\n\nbetween related functions.\n\nOnly some temporary variables are suitable for Replace Temp with Query. The variable\n\nneeds to be calculated once and then only be read afterwards. In the simplest case, this\n\nmeans the variable is assigned to once, but it’s also possible to have several assignments\n\nin a more complicated lump of code—all of which has to be extracted into the query.\n\nFurthermore, the logic used to calculate the variable must yield the same result when\n\nthe variable is used later—which rules out variables used as snapshots with names like\n\noldAddress.\n\nMechanics\n\nCheck that the variable is determined entirely before it’s used, and the code that\n\ncalculates it does not yield a different value whenever it is used.\n\nIf the variable isn’t read­only, and can be made read­only, do so.\n\nTest.\n\nExtract the assignment of the variable into a function.\n\nwww.EBooksWorld.ir\n\nIf the variable and the function cannot share a name, use a temporary name for the\n\nfunction.\n\nEnsure the extracted function is free of side effects. If not, use Separate Query from\n\nModifier (306).\n\nTest.\n\nUse Inline Variable (123) to remove the temp.\n\nExample\n\nHere is a simple class:\n\nclass Order…\n\nClick here to view code image\n\nconstructor(quantity, item) { this._quantity = quantity; this._item = item; }\n\nget price() { var basePrice = this._quantity * this._item.price; var discountFactor = 0.98; if (basePrice > 1000) discountFactor ­= 0.03; return basePrice * discountFactor; } }\n\nI want to replace the temps basePrice and discountFactor with methods.\n\nStarting with basePrice, I make it const and run tests. This is a good way of\n\nchecking that I haven’t missed a reassignment—unlikely in such a short function but\n\ncommon when I’m dealing with something larger.\n\nclass Order…\n\nClick here to view code image\n\nconstructor(quantity, item) { this._quantity = quantity; this._item = item; }\n\nwww.EBooksWorld.ir\n\nget price() { const basePrice = this._quantity * this._item.price; var discountFactor = 0.98; if (basePrice > 1000) discountFactor ­= 0.03; return basePrice * discountFactor; } }\n\nI then extract the right­hand side of the assignment to a getting method.\n\nclass Order…\n\nClick here to view code image\n\nget price() { const basePrice = this.basePrice; var discountFactor = 0.98; if (basePrice > 1000) discountFactor ­= 0.03; return basePrice * discountFactor; }\n\nget basePrice() { return this._quantity * this._item.price; }\n\nI test, and apply Inline Variable (123).\n\nclass Order…\n\nClick here to view code image\n\nget price() { const basePrice = this.basePrice; var discountFactor = 0.98; if (this.basePrice > 1000) discountFactor ­= 0.03; return this.basePrice * discountFactor; }\n\nI then repeat the steps with discountFactor, first using Extract Function (106).\n\nclass Order…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nget price() { const discountFactor = this.discountFactor; return this.basePrice * discountFactor; }\n\nget discountFactor() { var discountFactor = 0.98; if (this.basePrice > 1000) discountFactor ­= 0.03; return discountFactor; }\n\nIn this case I need my extracted function to contain both assignments to\n\ndiscountFactor. I can also set the original variable to be const.\n\nThen, I inline:\n\nClick here to view code image\n\nget price() { return this.basePrice * this.discountFactor; }\n\nEXTRACT CLASS\n\ninverse of: Inline Class (186)\n\nwww.EBooksWorld.ir\n\nMotivation\n\nMotivation\n\nYou’ve probably read guidelines that a class should be a crisp abstraction, only handle a\n\nfew clear responsibilities, and so on. In practice, classes grow. You add some operations\n\nhere, a bit of data there. You add a responsibility to a class feeling that it’s not worth a\n\nseparate class—but as that responsibility grows and breeds, the class becomes too\n\ncomplicated. Soon, your class is as crisp as a microwaved duck.\n\nImagine a class with many methods and quite a lot of data. A class that is too big to\n\nunderstand easily. You need to consider where it can be split—and split it. A good sign\n\nis when a subset of the data and a subset of the methods seem to go together. Other\n\ngood signs are subsets of data that usually change together or are particularly\n\ndependent on each other. A useful test is to ask yourself what would happen if you\n\nremove a piece of data or a method. What other fields and methods would become\n\nnonsense?\n\nOne sign that often crops up later in development is the way the class is sub­typed. You\n\nmay find that subtyping affects only a few features or that some features need to be\n\nsubtyped one way and other features a different way.\n\nMechanics\n\nDecide how to split the responsibilities of the class.\n\nCreate a new child class to express the split­off responsibilities.\n\nIf the responsibilities of the original parent class no longer match its name, rename\n\nthe parent.\n\nCreate an instance of the child class when constructing the parent and add a link\n\nfrom parent to child.\n\nUse Move Field (207) on each field you wish to move. Test after each move.\n\nUse Move Function (198) to move methods to the new child. Start with lower­level\n\nmethods (those being called rather than calling). Test after each move.\n\nReview the interfaces of both classes, remove unneeded methods, change names to\n\nbetter fit the new circumstances.\n\nDecide whether to expose the new child. If so, consider applying Change Reference\n\nto Value (252) to the child class.\n\nwww.EBooksWorld.ir\n\nExample\n\nExample\n\nI start with a simple person class:\n\nclass Person…\n\nClick here to view code image\n\nget name() {return this._name;} set name(arg) {this._name = arg;} get telephoneNumber() {return `(${this.officeAreaCode}) ${this.officeNumber}`;} get officeAreaCode() {return this._officeAreaCode;} set officeAreaCode(arg) {this._officeAreaCode = arg;} get officeNumber() {return this._officeNumber;} set officeNumber(arg) {this._officeNumber = arg;}\n\nHere. I can separate the telephone number behavior into its own class. I start by\n\ndefining an empty telephone number class:\n\nclass TelephoneNumber { }\n\nThat was easy! Next, I create an instance of telephone number when constructing the\n\nperson:\n\nclass Person…\n\nClick here to view code image\n\nconstructor() { this._telephoneNumber = new TelephoneNumber(); }\n\nclass TelephoneNumber…\n\nClick here to view code image\n\nget officeAreaCode() {return this._officeAreaCode;} set officeAreaCode(arg) {this._officeAreaCode = arg;}\n\nI then use Move Field (207) on one of the fields.\n\nwww.EBooksWorld.ir\n\nclass Person…\n\nClick here to view code image\n\nget officeAreaCode() {return this._telephoneNumber.officeAreaCode;} set officeAreaCode(arg) {this._telephoneNumber.officeAreaCode = arg;}\n\nI test, then move the next field.\n\nclass TelephoneNumber…\n\nClick here to view code image\n\nget officeNumber() {return this._officeNumber;} set officeNumber(arg) {this._officeNumber = arg;}\n\nclass Person…\n\nClick here to view code image\n\nget officeNumber() {return this._telephoneNumber.officeNumber;} set officeNumber(arg) {this._telephoneNumber.officeNumber = arg;}\n\nTest again, then move the telephone number method.\n\nclass TelephoneNumber…\n\nClick here to view code image\n\nget telephoneNumber() {return `(${this.officeAreaCode}) ${this.officeNumber}`;}\n\nclass Person…\n\nClick here to view code image\n\nget telephoneNumber() {return this._telephoneNumber.telephoneNumber;}\n\nNow I should tidy things up. Having “office” as part of the telephone number code\n\nmakes no sense, so I rename them.\n\nwww.EBooksWorld.ir\n\nclass TelephoneNumber…\n\nClick here to view code image\n\nget areaCode() {return this._areaCode;} set areaCode(arg) {this._areaCode = arg;}\n\nget number() {return this._number;} set number(arg) {this._number = arg;}\n\nclass Person…\n\nClick here to view code image\n\nget officeAreaCode() {return this._telephoneNumber.areaCode;} set officeAreaCode(arg) {this._telephoneNumber.areaCode = arg;} get officeNumber() {return this._telephoneNumber.number;} set officeNumber(arg) {this._telephoneNumber.number = arg;}\n\nThe telephone number method on the telephone number class also doesn’t make much\n\nsense, so I apply Rename Function (124).\n\nclass TelephoneNumber…\n\nClick here to view code image\n\ntoString() {return `(${this.areaCode}) ${this.number}`;}\n\nclass Person…\n\nClick here to view code image\n\nget telephoneNumber() {return this._telephoneNumber.toString();}\n\nTelephone numbers are generally useful, so I think I’ll expose the new object to clients.\n\nI can replace those “office” methods with accessors for the telephone number. But this\n\nway, the telephone number will work better as a Value Object [mf­vo], so I would apply\n\nChange Reference to Value (252) first (that refactoring’s example shows how I’d do that\n\nfor the telephone number).\n\nINLINE CLASS\n\nwww.EBooksWorld.ir",
      "page_number": 205
    },
    {
      "number": 23,
      "title": "Segment 23 (pages 213-221)",
      "start_page": 213,
      "end_page": 221,
      "detection_method": "topic_boundary",
      "content": "inverse of: Extract Class (182)\n\nMotivation\n\nInline Class is the inverse of Extract Class (182). I use Inline Class if a class is no longer\n\npulling its weight and shouldn’t be around any more. Often, this is the result of\n\nrefactoring that moves other responsibilities out of the class so there is little left. At that\n\npoint, I fold the class into another—one that makes most use of the runt class.\n\nAnother reason to use Inline Class is if I have two classes that I want to refactor into a\n\npair of classes with a different allocation of features. I may find it easier to first use\n\nInline Class to combine them into a single class, then Extract Class (182) to make the\n\nnew separation. This is a general approach when reorganizing things: Sometimes, it’s\n\neasier to move elements one at a time from one context to another, but sometimes it’s\n\nbetter to use an inline refactoring to collapse the contexts together, then use an extract\n\nrefactoring to separate them into different elements.\n\nMechanics\n\nIn the target class, create functions for all the public functions of the source class.\n\nThese functions should just delegate to the source class.\n\nChange all references to source class methods so they use the target class’s\n\ndelegators instead. Test after each change.\n\nwww.EBooksWorld.ir\n\nMove all the functions and data from the source class into the target, testing after\n\neach move, until the source class is empty.\n\nDelete the source class and hold a short, simple funeral service.\n\nExample\n\nHere’s a class that holds a couple of pieces of tracking information for a shipment.\n\nClick here to view code image\n\nclass TrackingInformation { get shippingCompany() {return this._shippingCompany;} set shippingCompany(arg) {this._shippingCompany = arg;} get trackingNumber() {return this._trackingNumber;} set trackingNumber(arg) {this._trackingNumber = arg;} get display() { return `${this.shippingCompany}: ${this.trackingNumber}`; } }\n\nIt’s used as part of a shipment class.\n\nclass Shipment…\n\nClick here to view code image\n\nget trackingInfo() { return this._trackingInformation.display; } get trackingInformation() {return this._trackingInformation;} set trackingInformation(aTrackingInformation) { this._trackingInformation = aTrackingInformation; }\n\nWhile this class may have been worthwhile in the past, I no longer feel it’s pulling its\n\nweight, so I want to inline it into Shipment.\n\nI start by looking at places that are invoking the methods of TrackingInformation.\n\ncaller…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\naShipment.trackingInformation.shippingCompany = request.vendor;\n\nI’m going to move all such functions to Shipment, but I do it slightly differently to how\n\nI usually do Move Function (198). In this case, I start by putting a delegating method\n\ninto the shipment, and adjusting the client to call that.\n\nclass Shipment…\n\nClick here to view code image\n\nset shippingCompany(arg) {this._trackingInformation.shippingCompany = arg;}\n\ncaller…\n\nClick here to view code image\n\naShipment.trackingInformation.shippingCompany = request.vendor;\n\nI do this for all the elements of tracking information that are used by clients. Once I’ve\n\ndone that, I can move all the elements of the tracking information over into the\n\nshipment class.\n\nI start by applying Inline Function (115) to the display method.\n\nclass Shipment…\n\nClick here to view code image\n\nget trackingInfo() { return `${this.shippingCompany}: ${this.trackingNumber}`; }\n\nI move the shipping company field.\n\nClick here to view code image\n\nget shippingCompany() {return this._trackingInformation._shippingCompany;} set shippingCompany(arg) {this._trackingInformation._shippingCompany = arg;}\n\nwww.EBooksWorld.ir\n\nI don’t use the full mechanics for Move Field (207) since in this case I only reference\n\nshippingCompany from Shipment which is the target of the move. I thus don’t need\n\nthe steps that put a reference from the source to the target.\n\nI continue until everything is moved over. Once I’ve done that, I can delete the tracking\n\ninformation class.\n\nclass Shipment…\n\nClick here to view code image\n\nget trackingInfo() { return `${this.shippingCompany}: ${this.trackingNumber}`; } get shippingCompany() {return this._shippingCompany;} set shippingCompany(arg) {this._shippingCompany = arg;} get trackingNumber() {return this._trackingNumber;} set trackingNumber(arg) {this._trackingNumber = arg;}\n\nHIDE DELEGATE\n\ninverse of: Remove Middle Man (192)\n\nMotivation\n\nOne of the keys—if not the key—to good modular design is encapsulation.\n\nwww.EBooksWorld.ir\n\nEncapsulation means that modules need to know less about other parts of the system.\n\nThen, when things change, fewer modules need to be told about the change—which\n\nmakes the change easier to make.\n\nWhen we are first taught about object orientation, we are told that encapsulation means\n\nhiding our fields. As we become more sophisticated, we realize there is more that we\n\ncan encapsulate.\n\nIf I have some client code that calls a method defined on an object in a field of a server\n\nobject, the client needs to know about this delegate object. If the delegate changes its\n\ninterface, changes propagate to all the clients of the server that use the delegate. I can\n\nremove this dependency by placing a simple delegating method on the server that hides\n\nthe delegate. Then any changes I make to the delegate propagate only to the server and\n\nnot to the clients.\n\nMechanics\n\nFor each method on the delegate, create a simple delegating method on the server.\n\nAdjust the client to call the server. Test after each change.\n\nIf no client needs to access the delegate anymore, remove the server’s accessor for\n\nthe delegate.\n\nTest.\n\nExample\n\nI start with a person and a department.\n\nclass Person…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nconstructor(name) { this._name = name; } get name() {return this._name;} get department() {return this._department;} set department(arg) {this._department = arg;}\n\nclass Department…\n\nClick here to view code image\n\nget chargeCode() {return this._chargeCode;} set chargeCode(arg) {this._chargeCode = arg;} get manager() {return this._manager;} set manager(arg) {this._manager = arg;}\n\nSome client code wants to know the manager of a person. To do this, it needs to get the\n\ndepartment first.\n\nclient code…\n\nClick here to view code image\n\nmanager = aPerson.department.manager;\n\nThis reveals to the client how the department class works and that the department is\n\nresponsible for tracking the manager. I can reduce this coupling by hiding the\n\ndepartment class from the client. I do this by creating a simple delegating method on\n\nperson:\n\nclass Person…\n\nClick here to view code image\n\nget manager() {return this._department.manager;}\n\nI now need to change all clients of person to use this new method:\n\nclient code…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nmanager = aPerson.department.manager;\n\nOnce I’ve made the change for all methods of department and for all the clients of\n\nperson, I can remove the department accessor on person.\n\nREMOVE MIDDLE MAN\n\ninverse of: Hide Delegate (189)\n\nMotivation\n\nIn the motivation for Hide Delegate (189), I talked about the advantages of\n\nencapsulating the use of a delegated object. There is a price for this. Every time the\n\nclient wants to use a new feature of the delegate, I have to add a simple delegating\n\nmethod to the server. After adding features for a while, I get irritated with all this\n\nforwarding. The server class is just a middle man (Middle Man (81)), and perhaps it’s\n\ntime for the client to call the delegate directly. (This smell often pops up when people\n\nget overenthusiastic about following the Law of Demeter, which I’d like a lot more if it\n\nwere called the Occasionally Useful Suggestion of Demeter.)\n\nIt’s hard to figure out what the right amount of hiding is. Fortunately, with Hide\n\nDelegate (189) and Remove Middle Man, it doesn’t matter so much. I can adjust my\n\ncode as time goes on. As the system changes, the basis for how much I hide also\n\nchanges. A good encapsulation six months ago may be awkward now. Refactoring www.EBooksWorld.ir\n\nmeans I never have to say I’m sorry—I just fix it.\n\nMechanics\n\nCreate a getter for the delegate.\n\nFor each client use of a delegating method, replace the call to the delegating method\n\nby chaining through the accessor. Test after each replacement.\n\nIf all calls to a delegating method are replaced, you can delete the delegating\n\nmethod.\n\nWith automated refactorings, you can use Encapsulate Variable (132) on the\n\ndelegate field and then Inline Function (115) on all the methods that use it.\n\nExample\n\nI begin with a person class that uses a linked department object to determine a\n\nmanager. (If you’re reading this book sequentially, this example may look eerily\n\nfamiliar.)\n\nclient code…\n\nmanager = aPerson.manager;\n\nclass Person…\n\nClick here to view code image\n\nget manager() {return this._department.manager;}\n\nclass Department…\n\nClick here to view code image\n\nget manager() {return this._manager;}\n\nThis is simple to use and encapsulates the department. However, if lots of methods are\n\ndoing this, I end up with too many of these simple delegations on the person. That’s\n\nwhen it is good to remove the middle man. First, I make an accessor for the delegate:\n\nwww.EBooksWorld.ir\n\nclass Person…\n\nClick here to view code image\n\nget department() {return this._department;}\n\nNow I go to each client at a time and modify them to use the department directly.\n\nclient code…\n\nClick here to view code image\n\nmanager = aPerson.department.manager;\n\nOnce I’ve done this with all the clients, I can remove the manager method from\n\nPerson. I can repeat this process for any other simple delegations on Person.\n\nI can do a mixture here. Some delegations may be so common that I’d like to keep them\n\nto make client code easier to work with. There is no absolute reason why I should either\n\nhide a delegate or remove a middle man—particular circumstances suggest which\n\napproach to take, and reasonable people can differ on what works best.\n\nIf I have automated refactorings, then there’s a useful variation on these steps. First, I\n\nuse Encapsulate Variable (132) on department. This changes the manager getter to\n\nuse the public department getter:\n\nclass Person…\n\nClick here to view code image\n\nget manager() {return this.department.manager;}\n\nThe change is rather too subtle in JavaScript, but by removing the underscore from\n\ndepartment I’m using the new getter rather than accessing the field directly.\n\nThen I apply Inline Function (115) on the manager method to replace all the callers at\n\nonce.\n\nSUBSTITUTE ALGORITHM\n\nwww.EBooksWorld.ir",
      "page_number": 213
    },
    {
      "number": 24,
      "title": "Segment 24 (pages 222-231)",
      "start_page": 222,
      "end_page": 231,
      "detection_method": "topic_boundary",
      "content": "Motivation\n\nI’ve never tried to skin a cat. I’m told there are several ways to do it. I’m sure some are\n\neasier than others. So it is with algorithms. If I find a clearer way to do something, I\n\nreplace the complicated way with the clearer way. Refactoring can break down\n\nsomething complex into simpler pieces, but sometimes I just reach the point at which I\n\nhave to remove the whole algorithm and replace it with something simpler. This occurs\n\nas I learn more about the problem and realize that there’s an easier way to do it. It also\n\nhappens if I start using a library that supplies features that duplicate my code.\n\nSometimes, when I want to change the algorithm to work slightly differently, it’s easier\n\nto start by replacing it with something that would make my change more\n\nstraightforward to make.\n\nWhen I have to take this step, I have to be sure I’ve decomposed the method as much as\n\nI can. Replacing a large, complex algorithm is very difficult; only by making it simple\n\ncan I make the substitution tractable.\n\nwww.EBooksWorld.ir\n\nMechanics\n\nMechanics\n\nArrange the code to be replaced so that it fills a complete function.\n\nPrepare tests using this function only, to capture its behavior.\n\nPrepare your alternative algorithm.\n\nRun static checks.\n\nRun tests to compare the output of the old algorithm to the new one. If they are the\n\nsame, you’re done. Otherwise, use the old algorithm for comparison in testing and\n\ndebugging.\n\nwww.EBooksWorld.ir\n\nChapter 8 Moving Features\n\nHistory\n\nTopics\n\nSo far, the refactorings have been about creating, removing, and renaming program\n\nelements. Another important part of refactoring is moving elements between contexts. I\n\nTutorials\n\nuse Move Function (198) to move functions between classes and other modules. Fields\n\ncan move too, with Move Field (207).\n\nOffers & Deals\n\nI also move individual statements around. I use Move Statements into Function (213)\n\nHighlights\n\nand Move Statements to Callers (217) to move them in or out of functions, as well as\n\nSlide Statements (223) to move them within a function. Sometimes, I can take some\n\nSettings\n\nstatements that match an existing function and use Replace Inline Code with Function\n\nSupport\n\nCall (222) to remove the duplication.\n\nSign Out\n\nTwo refactorings I often do with loops are Split Loop (227), to ensure a loop does only\n\none thing, and Replace Loop with Pipeline (231) to get rid of a loop entirely.\n\nAnd then there’s the favorite refactoring of many a fine programmer: Remove Dead\n\nCode (237). Nothing is as satisfying as applying the digital flamethrower to superfluous\n\nstatements.\n\nMOVE FUNCTION\n\nformerly: Move Method\n\nwww.EBooksWorld.ir\n\nMotivation\n\nThe heart of a good software design is its modularity—which is my ability to make most\n\nmodifications to a program while only having to understand a small part of it. To get\n\nthis modularity, I need to ensure that related software elements are grouped together\n\nand the links between them are easy to find and understand. But my understanding of\n\nhow to do this isn’t static—as I better understand what I’m doing, I learn how to best\n\ngroup together software elements. To reflect that growing understanding, I need to\n\nmove elements around.\n\nAll functions live in some context; it may be global, but usually it’s some form of a\n\nmodule. In an object­oriented program, the core modular context is a class. Nesting a\n\nfunction within another creates another common context. Different languages provide\n\nvaried forms of modularity, each creating a context for a function to live in.\n\nOne of the most straightforward reasons to move a function is when it references\n\nelements in other contexts more than the one it currently resides in. Moving it together\n\nwith those elements often improves encapsulation, allowing other parts of the software\n\nto be less dependent on the details of this module.\n\nSimilarly, I may move a function because of where its callers live, or where I need to call\n\nit from in my next enhancement. A function defined as a helper inside another function\n\nmay have value on its own, so it’s worth moving it to somewhere more accessible. A\n\nmethod on a class may be easier for me to use if shifted to another.\n\nDeciding to move a function is rarely an easy decision. To help me decide, I examine the\n\ncurrent and candidate contexts for that function. I need to look at what functions call\n\nthis one, what functions are called by the moving function, and what data that function\n\nuses. Often, I see that I need a new context for a group of functions and create one with\n\nCombine Functions into Class (144) or Extract Class (182). Although it can be difficult\n\nwww.EBooksWorld.ir\n\nto decide where the best place for a function is, the more difficult this choice, often the\n\nless it matters. I find it valuable to try working with functions in one context, knowing\n\nI’ll learn how well they fit, and if they don’t fit I can always move them later.\n\nMechanics\n\nExamine all the program elements used by the chosen function in its current\n\ncontext. Consider whether they should move too.\n\nIf I find a called function that should also move, I usually move it first. That way,\n\nmoving a clusters of functions begins with the one that has the least dependency on\n\nthe others in the group.\n\nIf a high­level function is the only caller of subfunctions, then you can inline those\n\nfunctions into the high­level method, move, and reextract at the destination.\n\nCheck if the chosen function is a polymorphic method.\n\nIf I’m in an object­oriented language, I have to take account of super­ and subclass\n\ndeclarations.\n\nCopy the function to the target context. Adjust it to fit in its new home.\n\nIf the body uses elements in the source context, I need to either pass those elements\n\nas parameters or pass a reference to that source context.\n\nMoving a function often means I need to come up with a different name that works\n\nbetter in the new context.\n\nPerform static analysis.\n\nFigure out how to reference the target function from the source context.\n\nTurn the source function into a delegating function.\n\nTest.\n\nConsider Inline Function (115) on the source function.\n\nThe source function can stay indefinitely as a delegating function. But if its callers\n\ncan just as easily reach the target directly, then it’s better to remove the middle\n\nman.\n\nwww.EBooksWorld.ir\n\nExample: Moving a Nested Function to Top Level\n\nExample: Moving a Nested Function to Top Level\n\nI’ll begin with a function that calculates the total distance for a GPS track record.\n\nClick here to view code image\n\nfunction trackSummary(points) { const totalTime = calculateTime(); const totalDistance = calculateDistance(); const pace = totalTime / 60 / totalDistance ; return { time: totalTime, distance: totalDistance, pace: pace };\n\nfunction calculateDistance() { let result = 0; for (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result; }\n\nfunction distance(p1,p2) { ... } function radians(degrees) { ... } function calculateTime() { ... }\n\n}\n\nI’d like to move calculateDistance to the top level so I can calculate distances for\n\ntracks without all the other parts of the summary.\n\nI begin by copying the function to the top level.\n\nClick here to view code image\n\nfunction trackSummary(points) { const totalTime = calculateTime(); const totalDistance = calculateDistance(); const pace = totalTime / 60 / totalDistance ; return { time: totalTime, distance: totalDistance, pace: pace };\n\nfunction calculateDistance() { let result = 0;\n\nwww.EBooksWorld.ir\n\nfor (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result; } ...\n\nfunction distance(p1,p2) { ... } function radians(degrees) { ... } function calculateTime() { ... }\n\n}\n\nfunction top_calculateDistance() { let result = 0; for (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result; }\n\nWhen I copy a function like this, I like to change the name so I can distinguish them\n\nboth in the code and in my head. I don’t want to think about what the right name\n\nshould be right now, so I create a temporary name.\n\nThe program still works, but my static analysis is rightly rather upset. The new function\n\nhas two undefined symbols: distance and points. The natural way to deal with\n\npoints is to pass it in as a parameter.\n\nClick here to view code image\n\nfunction top_calculateDistance(points) { let result = 0; for (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result; }\n\nI could do the same with distance, but perhaps it makes sense to move it together\n\nwith calculateDistance. Here’s the relevant code:\n\nfunction trackSummary…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nfunction distance(p1,p2) { // haversine formula see http://www.movable­type.co.uk/scripts/latlong.html const EARTH_RADIUS = 3959; // in miles const dLat = radians(p2.lat) ­ radians(p1.lat); const dLon = radians(p2.lon) ­ radians(p1.lon); const a = Math.pow(Math.sin(dLat / 2),2) + Math.cos(radians(p2.lat)) * Math.cos(radians(p1.lat)) * Math.pow(Math.sin(dLon / 2), 2); const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1­a)); return EARTH_RADIUS * c; } function radians(degrees) { return degrees * Math.PI / 180; }\n\nI can see that distance only uses radians and radians doesn’t use anything inside\n\nits current context. So rather than pass the functions, I might as well move them too. I\n\ncan make a small step in this direction by moving them from their current context to\n\nnest them inside the nested calculateDistance.\n\nClick here to view code image\n\nfunction trackSummary(points) { const totalTime = calculateTime(); const totalDistance = calculateDistance(); const pace = totalTime / 60 / totalDistance ; return { time: totalTime, distance: totalDistance, pace: pace };\n\nfunction calculateDistance() { let result = 0; for (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result;\n\nfunction distance(p1,p2) { ... } function radians(degrees) { ... } }\n\nBy doing this, I can use both static analysis and testing to tell me if there are any\n\ncomplications. In this case all is well, so I can copy them over to\n\ntop_calculateDistance.\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction top_calculateDistance(points) { let result = 0; for (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result;\n\nfunction distance(p1,p2) { ... } function radians(degrees) { ... }\n\n}\n\nAgain, the copy doesn’t change how the program runs, but does give me an opportunity\n\nfor more static analysis. Had I not spotted that distance calls radians, the linter\n\nwould have caught it at this step.\n\nNow that I have prepared the table, it’s time for the major change—the body of the\n\noriginal calculateDistance will now call top_calculateDistance:\n\nClick here to view code image\n\nfunction trackSummary(points) { const totalTime = calculateTime(); const totalDistance = calculateDistance(); const pace = totalTime / 60 / totalDistance ; return { time: totalTime, distance: totalDistance, pace: pace };\n\nfunction calculateDistance() { return top_calculateDistance(points); }\n\nThis is the crucial time to run tests to fully test that the moved function has bedded\n\ndown in its new home.\n\nWith that done, it’s like unpacking the boxes after moving house. The first thing is to\n\ndecide whether to keep the original function that’s just delegating or not. In this case,\n\nthere are few callers and, as usual with nested functions, they are highly localized. So\n\nI’m happy to get rid of it.\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction trackSummary(points) { const totalTime = calculateTime(); const totalDistance = top_calculateDistance(points); const pace = totalTime / 60 / totalDistance ; return { time: totalTime, distance: totalDistance, pace: pace };\n\nNow is also a good time to think about what I want the name to be. Since the top­level\n\nfunction has the highest visibility, I’d like it to have the best name. totalDistance\n\nseems like a good choice. I can’t use that immediately since it will be shadowed by the\n\nvariable inside trackSummary—but I don’t see any reason to keep that anyway, so I\n\nuse Inline Variable (123) on it.\n\nClick here to view code image\n\nfunction trackSummary(points) { const totalTime = calculateTime(); const pace = totalTime / 60 / totalDistance(points) ; return { time: totalTime, distance: totalDistance(points), pace: pace }; function totalDistance(points) { let result = 0; for (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result;\n\nIf I’d had the need to keep the variable, I’d have renamed it to something like\n\ntotalDistanceCache or distance.\n\nSince the functions for distance and radians don’t depend on anything inside\n\ntotalDistance, I prefer to move them to top level too, putting all four functions at\n\nthe top level.\n\nClick here to view code image\n\nfunction trackSummary(points) { ... }\n\nwww.EBooksWorld.ir",
      "page_number": 222
    },
    {
      "number": 25,
      "title": "Segment 25 (pages 232-241)",
      "start_page": 232,
      "end_page": 241,
      "detection_method": "topic_boundary",
      "content": "function totalDistance(points) { ... } function distance(p1,p2) { ... } function radians(degrees) { ... }\n\nSome people would prefer to keep distance and radians inside totalDistance in\n\norder to restrict their visibility. In some languages that may be a consideration, but with\n\nES 2015, JavaScript has an excellent module mechanism that’s the best tool for\n\ncontrolling function visibility. In general, I’m wary of nested functions—they too easily\n\nset up hidden data interrelationships that can get hard to follow.\n\nExample: Moving between Classes\n\nTo illustrate this variety of Move Function, I’ll start here:\n\nclass Account…\n\nClick here to view code image\n\nget bankCharge() { let result = 4.5; if (this._daysOverdrawn > 0) result += this.overdraftCharge; return result; }\n\nget overdraftCharge() { if (this.type.isPremium) { const baseCharge = 10; if (this.daysOverdrawn <= 7) return baseCharge; else return baseCharge + (this.daysOverdrawn ­ 7) * 0.85; } else return this.daysOverdrawn * 1.75; }\n\nComing up are changes that lead to different types of account having different\n\nalgorithms for determining the charge. Thus it seems natural to move\n\noverdraftCharge to the account type class.\n\nThe first step is to look at the features that the overdraftCharge method uses and\n\nconsider whether it is worth moving a batch of methods together. In this case I need the\n\ndaysOverdrawn method to remain on the account class, because that will vary with\n\nindividual accounts.\n\nwww.EBooksWorld.ir\n\nNext, I copy the method body over to the account type and get it to fit.\n\nclass AccountType…\n\nClick here to view code image\n\noverdraftCharge(daysOverdrawn) { if (this.isPremium) { const baseCharge = 10; if (daysOverdrawn <= 7) return baseCharge; else return baseCharge + (daysOverdrawn ­ 7) * 0.85; } else return daysOverdrawn * 1.75; }\n\nIn order to get the method to fit in its new location, I need to deal with two call targets\n\nthat change their scope. isPremium is now a simple call on this. With\n\ndaysOverdrawn I have to decide—do I pass the value or do I pass the account? For the\n\nmoment, I just pass the simple value but I may well change this in the future if I require\n\nmore than just the days overdrawn from the account—especially if what I want from the\n\naccount varies with the account type.\n\nNext, I replace the original method body with a delegating call.\n\nclass Account…\n\nClick here to view code image\n\nget bankCharge() { let result = 4.5; if (this._daysOverdrawn > 0) result += this.overdraftCharge; return result; }\n\nget overdraftCharge() { return this.type.overdraftCharge(this.daysOverdrawn); }\n\nThen comes the decision of whether to leave the delegation in place or to inline\n\noverdraftCharge. Inlining results in:\n\nclass Account…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nget bankCharge() { let result = 4.5; if (this._daysOverdrawn > 0) result += this.type.overdraftCharge(this.daysOverdrawn); return result; }\n\nIn the earlier steps, I passed daysOverdrawn as a parameter—but if there’s a lot of\n\ndata from the account to pass, I might prefer to pass the account itself.\n\nclass Account…\n\nClick here to view code image\n\nget bankCharge() { let result = 4.5; if (this._daysOverdrawn > 0) result += this.overdraftCharge; return result; }\n\nget overdraftCharge() { return this.type.overdraftCharge(this); }\n\nclass AccountType…\n\nClick here to view code image\n\noverdraftCharge(account) { if (this.isPremium) { const baseCharge = 10; if (account.day>sOverdrawn <= 7) return baseCharge; else return baseCharge + (account.daysOverdrawn ­ 7) * 0.85; } else return account.daysOverdrawn * 1.75; }\n\nMOVE FIELD\n\nwww.EBooksWorld.ir\n\nMotivation\n\nProgramming involves writing a lot of code that implements behavior—but the strength\n\nof a program is really founded on its data structures. If I have a good set of data\n\nstructures that match the problem, then my behavior code is simple and\n\nstraightforward. But poor data structures lead to lots of code whose job is merely\n\ndealing with the poor data. And it’s not just messier code that’s harder to understand; it\n\nalso means the data structures obscure what the program is doing.\n\nSo, data structures are important—but like most aspects of programming they are hard\n\nto get right. I do make an initial analysis to figure out the best data structures, and I’ve\n\nfound that experience and techniques like domain­driven design have improved my\n\nability to do that. But despite all my skill and experience, I still find that I frequently\n\nmake mistakes in that initial design. In the process of programming, I learn more about\n\nthe problem domain and my data structures. A design decision that is reasonable and\n\ncorrect one week can become wrong in another.\n\nAs soon as I realize that a data structure isn’t right, it’s vital to change it. If I leave my\n\ndata structures with their blemishes, those blemishes will confuse my thinking and\n\ncomplicate my code far into the future.\n\nI may seek to move data because I find I always need to pass a field from one record\n\nwhenever I pass another record to a function. Pieces of data that are always passed to\n\nfunctions together are usually best put in a single record in order to clarify their\n\nrelationship. Change is also a factor; if a change in one record causes a field in another\n\nrecord to change too, that’s a sign of a field in the wrong place. If I have to update the\n\nsame field in multiple structures, that’s a sign that it should move to another place\n\nwhere it only needs to be updated once.\n\nwww.EBooksWorld.ir\n\nI usually do Move Field in the context of a broader set of changes. Once I’ve moved a\n\nfield, I find that many of the users of the field are better off accessing that data through\n\nthe target object rather than the original source. I then change these with later\n\nrefactorings. Similarly, I may find that I can’t do Move Field at the moment due to the\n\nway the data is used. I need to refactor some usage patterns first, then do the move.\n\nIn my description so far, I’m saying “record,” but all this is true of classes and objects\n\ntoo. A class is a record type with attached functions—and these need to be kept healthy\n\njust as much as any other data. The attached functions do make it easier to move data\n\naround, since the data is encapsulated behind accessor methods. I can move the data,\n\nchange the accessors, and clients of the accessors will still work. So, this is a refactoring\n\nthat’s easier to do if you have classes, and my description below makes that assumption.\n\nIf I’m using bare records that don’t support encapsulation, I can still make a change like\n\nthis, but it is more tricky.\n\nMechanics\n\nEnsure the source field is encapsulated.\n\nTest.\n\nCreate a field (and accessors) in the target.\n\nRun static checks.\n\nEnsure there is a reference from the source object to the target object.\n\nAn existing field or method may give you the target. If not, see if you can easily\n\ncreate a method that will do so. Failing that, you may need to create a new field in\n\nthe source object that can store the target. This may be a permanent change, but you\n\ncan also do it temporarily until you have done enough refactoring in the broader\n\ncontext.\n\nAdjust accessors to use the target field.\n\nIf the target is shared between source objects, consider first updating the setter to\n\nmodify both target and source fields, followed by Introduce Assertion (302) to\n\ndetect inconsistent updates. Once you determine all is well, finish changing the\n\naccessors to use the target field.\n\nTest.\n\nwww.EBooksWorld.ir\n\nRemove the source field.\n\nTest.\n\nExample\n\nI’m starting here with this customer and contract:\n\nclass Customer…\n\nClick here to view code image\n\nconstructor(name, discountRate) { this._name = name; this._discountRate = discountRate; this._contract = new CustomerContract(dateToday()); } get discountRate() {return this._discountRate;} becomePreferred() { this._discountRate += 0.03; // other nice things } applyDiscount(amount) { return amount.subtract(amount.multiply(this._discountRate)); }\n\nclass CustomerContract…\n\nClick here to view code image\n\nconstructor(startDate) { this._startDate = startDate; }\n\nI want to move the discount rate field from the customer to the customer contract.\n\nThe first thing I need to use is Encapsulate Variable (132) to encapsulate access to the\n\ndiscount rate field.\n\nclass Customer…\n\nClick here to view code image\n\nconstructor(name, discountRate) { this._name = name;\n\nwww.EBooksWorld.ir\n\nthis._setDiscountRate(discountRate); this._contract = new CustomerContract(dateToday()); } get discountRate() {return this._discountRate;} _setDiscountRate(aNumber) {this._discountRate = aNumber;} becomePreferred() { this._setDiscountRate(this.discountRate + 0.03); // other nice things } applyDiscount(amount) { return amount.subtract(amount.multiply(this.discountRate)); }\n\nI use a method to update the discount rate, rather than a property setter, as I don’t want\n\nto make a public setter for the discount rate.\n\nI add a field and accessors to the customer contract.\n\nclass CustomerContract…\n\nClick here to view code image\n\nconstructor(startDate, discountRate) { this._startDate = startDate; this._discountRate = discountRate; } get discountRate() {return this._discountRate;} set discountRate(arg) {this._discountRate = arg;}\n\nI now modify the accessors on customer to use the new field. When I did that, I got an\n\nerror: “Cannot set property ’discountRate’ of undefined”. This was because\n\n_setDiscountRate was called before I created the contract object in the constructor.\n\nTo fix that, I first reverted to the previous state, then used Slide Statements (223) to\n\nmove the _setDiscountRate after creating the contract.\n\nclass Customer…\n\nClick here to view code image\n\nconstructor(name, discountRate) { this._name = name; this._setDiscountRate(discountRate); this._contract = new CustomerContract(dateToday()); }\n\nwww.EBooksWorld.ir\n\nI tested that, then changed the accessors again to use the contract.\n\nclass Customer…\n\nClick here to view code image\n\nget discountRate() {return this._contract.discountRate;} _setDiscountRate(aNumber) {this._contract.discountRate = aNumber;}\n\nSince I’m using JavaScript, there is no declared source field, so I don’t need to remove\n\nanything further.\n\nChanging a Bare Record\n\nThis refactoring is generally easier with objects, since encapsulation provides a natural\n\nway to wrap data access in methods. If I have many functions accessing a bare record,\n\nthen, while it’s still a valuable refactoring, it is decidedly more tricky.\n\nI can create accessor functions and modify all the reads and writes to use them. If the\n\nfield that’s being moved is immutable, I can update both the source and the target fields\n\nwhen I set its value and gradually migrate reads. Still, if possible, my first move would\n\nbe to use Encapsulate Record (162) to turn the record into a class so I can make the\n\nchange more easily.\n\nExample: Moving to a Shared Object\n\nNow, let’s consider a different case. Here’s an account with an interest rate:\n\nclass Account…\n\nClick here to view code image\n\nconstructor(number, type, interestRate) { this._number = number; this._type = type; this._interestRate = interestRate; } get interestRate() {return this._interestRate;}\n\nclass AccountType…\n\nconstructor(nameString) { this._name = nameString;\n\nwww.EBooksWorld.ir\n\n}\n\nI want to change things so that an account’s interest rate is determined from its account\n\ntype.\n\nThe access to the interest rate is already nicely encapsulated, so I’ll just create the field\n\nand an appropriate accessor on the account type.\n\nclass AccountType…\n\nClick here to view code image\n\nconstructor(nameString, interestRate) { this._name = nameString; this._interestRate = interestRate; } get interestRate() {return this._interestRate;}\n\nBut there is a potential problem when I update the accesses from account. Before this\n\nrefactoring, each account had its own interest rate. Now, I want all accounts to share\n\nthe interest rates of their account type. If all the accounts of the same type already have\n\nthe same interest rate, then there’s no change in observable behavior, so I’m fine with\n\nthe refactoring. But if there’s an account with a different interest rate, it’s no longer a\n\nrefactoring. If my account data is held in a database, I should check the database to\n\nensure that all my accounts have the rate matching their type. I can also Introduce\n\nAssertion (302) in the account class.\n\nclass Account…\n\nClick here to view code image\n\nconstructor(number, type, interestRate) { this._number = number; this._type = type; assert(interestRate === this._type.interestRate); this._interestRate = interestRate; } get interestRate() {return this._interestRate;}\n\nI might run the system for a while with this assertion in place to see if I get an error. Or,\n\ninstead of adding an assertion, I might log the problem. Once I’m confident that I’m not\n\nintroducing an observable change, I can change the access, removing the update from\n\nwww.EBooksWorld.ir\n\nthe account completely.\n\nclass Account…\n\nClick here to view code image\n\nconstructor(number, type) { this._number = number; this._type = type; } get interestRate() {return this._type.interestRate;}\n\nMOVE STATEMENTS INTO FUNCTION\n\ninverse of: Move Statements to Callers (217)\n\nwww.EBooksWorld.ir\n\nMotivation",
      "page_number": 232
    },
    {
      "number": 26,
      "title": "Segment 26 (pages 242-250)",
      "start_page": 242,
      "end_page": 250,
      "detection_method": "topic_boundary",
      "content": "Motivation\n\nRemoving duplication is one of the best rules of thumb of healthy code. If I see the\n\nsame code executed every time I call a particular function, I look to combine that\n\nrepeating code into the function itself. That way, any future modifications to the\n\nrepeating code can be done in one place and used by all the callers. Should the code\n\nvary in the future, I can easily move it (or some of it) out again with Move Statements\n\nto Callers (217).\n\nI move statements into a function when I can best understand these statements as part\n\nof the called function. If they don’t make sense as part of the called function, but still\n\nshould be called with it, I’ll simply use Extract Function (106) on the statements and\n\nthe called function. That’s essentially the same process as I describe below, but without\n\nthe inline and rename steps. It’s not unusual to do that and then, after later reflection,\n\ncarry out those final steps.\n\nMechanics\n\nIf the repetitive code isn’t adjacent to the call of the target function, use Slide\n\nStatements (223) to get it adjacent.\n\nIf the target function is only called by the source function, just cut the code from the\n\nsource, paste it into the target, test, and ignore the rest of these mechanics.\n\nIf you have more callers, use Extract Function (106) on one of the call sites to\n\nextract both the call to the target function and the statements you wish to move into\n\nit. Give it a name that’s transient, but easy to grep.\n\nConvert every other call to use the new function. Test after each conversion.\n\nWhen all the original calls use the new function, use Inline Function (115) to inline\n\nthe original function completely into the new function, removing the original\n\nfunction.\n\nRename Function (124) to change the name of the new function to the same name\n\nas the original function.\n\nOr to a better name, if there is one.\n\nExample\n\nI’ll start with this code to emit HTML for data about a photo:\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { const result = []; result.push(`<p>${person.name}</p>`); result.push(renderPhoto(person.photo)); result.push(`<p>title: ${person.photo.title}</p>`); result.push(emitPhotoData(person.photo)); return result.join(\"\\n\"); }\n\nfunction photoDiv(p) { return [ \"<div>\", `<p>title: ${p.title}</p>`, emitPhotoData(p), \"</div>\", ].join(\"\\n\"); }\n\nfunction emitPhotoData(aPhoto) { const result = []; result.push(`<p>location: ${aPhoto.location}</p>`); result.push(`<p>date: ${aPhoto.date.toDateString()}</p>`); return result.join(\"\\n\"); }\n\nThis code shows two calls to emitPhotoData, each preceded by a line of code that is\n\nsemantically equivalent. I’d like to remove this duplication by moving the title printing\n\ninto emitPhotoData. If I had just the one caller, I would just cut and paste the code,\n\nbut the more callers I have, the more I’m inclined to use a safer procedure.\n\nI begin by using Extract Function (106) on one of the callers. I’m extracting the\n\nstatements I want to move into emitPhotoData, together with the call to\n\nemitPhotoData itself.\n\nClick here to view code image\n\nfunction photoDiv(p) { return [ \"<div>\", zznew(p), \"</div>\", ].join(\"\\n\"); }\n\nfunction zznew(p) { return [\n\nwww.EBooksWorld.ir\n\n`<p>title: ${p.title}</p>`, emitPhotoData(p), ].join(\"\\n\"); }\n\nI can now look at the other callers of emitPhotoData and, one by one, replace the\n\ncalls and the preceding statements with calls to the new function.\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { const result = []; result.push(`<p>${person.name}</p>`); result.push(renderPhoto(person.photo)); result.push(zznew(person.photo)); return result.join(\"\\n\"); }\n\nNow that I’ve done all the callers, I use Inline Function (115) on emitPhotoData:\n\nClick here to view code image\n\nfunction zznew(p) { return [ `<p>title: ${p.title}</p>`, `<p>location: ${p.location}</p>`, `<p>date: ${p.date.toDateString()}</p>`, ].join(\"\\n\"); }\n\nand finish with Rename Function (124):\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { const result = []; result.push(`<p>${person.name}</p>`); result.push(renderPhoto(person.photo)); result.push(emitPhotoData(person.photo)); return result.join(\"\\n\"); }\n\nfunction photoDiv(aPhoto) { return [ \"<div>\", emitPhotoData(aPhoto),\n\nwww.EBooksWorld.ir\n\n\"</div>\", ].join(\"\\n\"); }\n\nfunction emitPhotoData(aPhoto) { return [ `<p>title: ${aPhoto.title}</p>`, `<p>location: ${aPhoto.location}</p>`, `<p>date: ${aPhoto.date.toDateString()}</p>`, ].join(\"\\n\"); }\n\nI also make the parameter names fit my convention while I’m at it.\n\nMOVE STATEMENTS TO CALLERS\n\ninverse of: Move Statements into Function (213)\n\nMotivation\n\nFunctions are the basic building block of the abstractions we build as programmers.\n\nAnd, as with any abstraction, we don’t always get the boundaries right. As a code base\n\nchanges its capabilities—as most useful software does—we often find our abstraction\n\nwww.EBooksWorld.ir\n\nboundaries shift. For functions, that means that what might once have been a cohesive,\n\natomic unit of behavior becomes a mix of two or more different things.\n\nOne trigger for this is when common behavior used in several places needs to vary in\n\nsome of its calls. Now, we need to move the varying behavior out of the function to its\n\ncallers. In this case, I’ll use Slide Statements (223) to get the varying behavior to the\n\nbeginning or end of the function and then Move Statements to Callers. Once the varying\n\ncode is in the caller, I can change it when necessary.\n\nMove Statements to Callers works well for small changes, but sometimes the\n\nboundaries between caller and callee need complete reworking. In that case, my best\n\nmove is to use Inline Function (115) and then slide and extract new functions to form\n\nbetter boundaries.\n\nMechanics\n\nIn simple circumstances, where you have only one or two callers and a simple\n\nfunction to call from, just cut the first line from the called function and paste (and\n\nperhaps fit) it into the callers. Test and you’re done.\n\nOtherwise, apply Extract Function (106) to all the statements that you don’t wish to\n\nmove; give it a temporary but easily searchable name.\n\nIf the function is a method that is overridden by subclasses, do the extraction on all\n\nof them so that the remaining method is identical in all classes. Then remove the\n\nsubclass methods.\n\nUse Inline Function (115) on the original function.\n\nApply Change Function Declaration (124) on the extracted function to rename it to\n\nthe original name.\n\nOr to a better name, if you can think of one.\n\nExample\n\nHere’s a simple case: a function with two callers.\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { outStream.write(`<p>${person.name}</p>\\n`);\n\nwww.EBooksWorld.ir\n\nrenderPhoto(outStream, person.photo); emitPhotoData(outStream, person.photo); }\n\nfunction listRecentPhotos(outStream, photos) { photos .filter(p => p.date > recentDateCutoff()) .forEach(p => { outStream.write(\"<div>\\n\"); emitPhotoData(outStream, p); outStream.write(\"</div>\\n\"); }); }\n\nfunction emitPhotoData(outStream, photo) { outStream.write(`<p>title: ${photo.title}</p>\\n`); outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`); outStream.write(`<p>location: ${photo.location}</p>\\n`); }\n\nI need to modify the software so that listRecentPhotos renders the location\n\ninformation differently while renderPerson stays the same. To make this change\n\neasier, I’ll use Move Statements to Callers on the final line.\n\nUsually, when faced with something this simple, I’ll just cut the last line from\n\nrenderPerson and paste it below the two calls. But since I’m explaining what to do in\n\nmore tricky cases, I’ll go through the more elaborate but safer procedure.\n\nMy first step is to use Extract Function (106) on the code that will remain in\n\nemitPhotoData.\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { outStream.write(`<p>${person.name}</p>\\n`); renderPhoto(outStream, person.photo); emitPhotoData(outStream, person.photo); }\n\nfunction listRecentPhotos(outStream, photos) { photos .filter(p => p.date > recentDateCutoff()) .forEach(p => { outStream.write(\"<div>\\n\"); emitPhotoData(outStream, p); outStream.write(\"</div>\\n\"); }); }\n\nwww.EBooksWorld.ir\n\nfunction emitPhotoData(outStream, photo) { zztmp(outStream, photo); outStream.write(`<p>location: ${photo.location}</p>\\n`); }\n\nfunction zztmp(outStream, photo) { outStream.write(`<p>title: ${photo.title}</p>\\n`); outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`); }\n\nUsually, the name of the extracted function is only temporary, so I don’t worry about\n\ncoming up with anything meaningful. However, it is helpful to use something that’s\n\neasy to grep. I can test at this point to ensure the code works over the function call\n\nboundary.\n\nNow I use Inline Function (115), one call at a time. I start with renderPerson.\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { outStream.write(`<p>${person.name}</p>\\n`); renderPhoto(outStream, person.photo); zztmp(outStream, person.photo); outStream.write(`<p>location: ${person.photo.location}</p>\\n`); }\n\nfunction listRecentPhotos(outStream, photos) { photos .filter(p => p.date > recentDateCutoff()) .forEach(p => { outStream.write(\"<div>\\n\"); emitPhotoData(outStream, p); outStream.write(\"</div>\\n\"); }); }\n\nfunction emitPhotoData(outStream, photo) { zztmp(outStream, photo); outStream.write(`<p>location: ${photo.location}</p>\\n`); }\n\nfunction zztmp(outStream, photo) { outStream.write(`<p>title: ${photo.title}</p>\\n`); outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`); }\n\nI test again to ensure this call is working properly, then move onto the next.\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { outStream.write(`<p>${person.name}</p>\\n`); renderPhoto(outStream, person.photo); zztmp(outStream, person.photo); outStream.write(`<p>location: ${person.photo.location}</p>\\n`); }\n\nfunction listRecentPhotos(outStream, photos) { photos .filter(p => p.date > recentDateCutoff()) .forEach(p => { outStream.write(\"<div>\\n\"); zztmp(outStream, p); outStream.write(`<p>location: ${p.location}</p>\\n`); outStream.write(\"</div>\\n\"); }); }\n\nfunction emitPhotoData(outStream, photo) { zztmp(outStream, photo); outStream.write(`<p>location: ${photo.location}</p>\\n`); }\n\nfunction zztmp(outStream, photo) { outStream.write(`<p>title: ${photo.title}</p>\\n`); outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`); }\n\nThen I can delete the outer function, completing Inline Function (115).\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { outStream.write(`<p>${person.name}</p>\\n`); renderPhoto(outStream, person.photo); zztmp(outStream, person.photo); outStream.write(`<p>location: ${person.photo.location}</p>\\n`); }\n\nfunction listRecentPhotos(outStream, photos) { photos .filter(p => p.date > recentDateCutoff()) .forEach(p => { outStream.write(\"<div>\\n\"); zztmp(outStream, p); outStream.write(`<p>location: ${p.location}</p>\\n`); outStream.write(\"</div>\\n\"); });\n\nwww.EBooksWorld.ir\n\n}\n\nfunction emitPhotoData(outStream, photo) { zztmp(outStream, photo); outStream.write(`<p>location: ${photo.location}</p>\\n`); }\n\nfunction zztmp(outStream, photo) { outStream.write(`<p>title: ${photo.title}</p>\\n`); outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`); }\n\nI then rename zztmp back to the original name.\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { outStream.write(`<p>${person.name}</p>\\n`); renderPhoto(outStream, person.photo); emitPhotoData(outStream, person.photo); outStream.write(`<p>location: ${person.photo.location}</p>\\n`); }\n\nfunction listRecentPhotos(outStream, photos) { photos .filter(p => p.date > recentDateCutoff()) .forEach(p => { outStream.write(\"<div>\\n\"); emitPhotoData(outStream, p); outStream.write(`<p>location: ${p.location}</p>\\n`); outStream.write(\"</div>\\n\"); }); }\n\nfunction emitPhotoData(outStream, photo) { outStream.write(`<p>title: ${photo.title}</p>\\n`); outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`); }\n\nREPLACE INLINE CODE WITH FUNCTION CALL\n\nwww.EBooksWorld.ir",
      "page_number": 242
    },
    {
      "number": 27,
      "title": "Segment 27 (pages 251-260)",
      "start_page": 251,
      "end_page": 260,
      "detection_method": "topic_boundary",
      "content": "Motivation\n\nFunctions allow me to package up bits of behavior. This is useful for understanding—a\n\nnamed function can explain the purpose of the code rather than its mechanics. It’s also\n\nvaluable to remove duplication: Instead of writing the same code twice, I just call the\n\nfunction. Then, should I need to change the function’s implementation, I don’t have to\n\ntrack down similar­looking code to update all the changes. (I may have to look at the\n\ncallers, to see if they should all use the new code, but that’s both less common and\n\nmuch easier.)\n\nIf I see inline code that’s doing the same thing that I have in an existing function, I’ll\n\nusually want to replace that inline code with a function call. The exception is if I\n\nconsider the similarity to be coincidental—so that, if I change the function body, I don’t\n\nexpect the behavior in this inline code to change. A guide to this is the name of the\n\nfunction. A good name should make sense in place of inline code I have. If the name\n\ndoesn’t make sense, that may be because it’s a poor name (in which case I use Rename\n\nFunction (124) to fix it) or because the function’s purpose is different to what I want in\n\nthis case—so I shouldn’t call it.\n\nI find it particularly satisfying to do this with calls to library functions—that way, I don’t\n\neven have to write the function body.\n\nMechanics\n\nReplace the inline code with a call to the existing function.\n\nTest.\n\nwww.EBooksWorld.ir\n\nSLIDE STATEMENTS\n\nSLIDE STATEMENTS\n\nformerly: Consolidate Duplicate Conditional Fragments\n\nMotivation\n\nCode is easier to understand when things that are related to each other appear together.\n\nIf several lines of code access the same data structure, it’s best for them to be together\n\nrather than intermingled with code accessing other data structures. At its simplest, I\n\nuse Slide Statements to keep such code together. A very common case of this is\n\ndeclaring and using variables. Some people like to declare all their variables at the top\n\nof a function. I prefer to declare the variable just before I first use it.\n\nUsually, I move related code together as a preparatory step for another refactoring,\n\noften an Extract Function (106). Putting related code into a clearly separated function\n\nis a better separation than just moving a set of lines together, but I can’t do the Extract\n\nFunction (106) unless the code is together in the first place.\n\nMechanics\n\nIdentify the target position to move the fragment to. Examine statements between\n\nsource and target to see if there is interference for the candidate fragment. Abandon\n\naction if there is any interference.\n\nA fragment cannot slide backwards earlier than any element it references is\n\ndeclared.\n\nA fragment cannot slide forwards beyond any element that references it. www.EBooksWorld.ir\n\nA fragment cannot slide over any statement that modifies an element it references.\n\nA fragment that modifies an element cannot slide over any other element that\n\nreferences the modified element.\n\nCut the fragment from the source and paste into the target position.\n\nTest.\n\nIf the test fails, try breaking down the slide into smaller steps. Either slide over less\n\ncode or reduce the amount of code in the fragment you’re moving.\n\nExample\n\nWhen sliding code fragments, there are two decisions involved: what slide I’d like to do\n\nand whether I can do it. The first decision is very context­specific. On the simplest level,\n\nI like to declare elements close to where I use them, so I’ll often slide a declaration\n\ndown to its usage. But almost always I slide some code because I want to do another\n\nrefactoring—perhaps to get a clump of code together to Extract Function (106).\n\nOnce I have a sense of where I’d like to move some code, the next part is deciding if I\n\ncan do it. This involves looking at the code I’m sliding and the code I’m sliding over: Do\n\nthey interfere with each other in a way that would change the observable behavior of\n\nthe program?\n\nConsider the following fragment of code:\n\nClick here to view code image\n\n1 const pricingPlan = retrievePricingPlan(); 2 const order = retreiveOrder(); 3 const baseCharge = pricingPlan.base; 4 let charge; 5 const chargePerUnit = pricingPlan.unit; 6 const units = order.units; 7 let discount; 8 charge = baseCharge + units * chargePerUnit; 9 let discountableUnits = Math.max(units ­ pricingPlan.discountThreshold, 0); 10 discount = discountableUnits * pricingPlan.discountFactor; 11 if (order.isRepeat) discount += 20; 12 charge = charge ­ discount; 13 chargeOrder(charge);\n\nwww.EBooksWorld.ir\n\nThe first seven lines are declarations, and it’s relatively easy to move these. For\n\nexample, I may want to move all the code dealing with discounts together, which would\n\ninvolve moving line 7 (`let discount`) to above line 10 (`discount = ...`).\n\nSince a declaration has no side effects and refers to no other variable, I can safely move\n\nthis forwards as far as the first line that references discount itself. This is also a\n\ncommon move—if I want to use Extract Function (106) on the discount logic, I’ll need\n\nto move the declaration down first.\n\nI do similar analysis with any code that doesn’t have side effects. So I can take line 2\n\n(`const order = ...`) and move it down to above line 6 (`const units =\n\n...`) without trouble.\n\nIn this case, I’m also helped by the fact that the code I’m moving over doesn’t have side\n\neffects either. Indeed, I can freely rearrange code that lacks side effects to my heart’s\n\ncontent, which is one of the reasons why wise programmers prefer to use side­effect­\n\nfree code as much as possible.\n\nThere is a wrinkle here, however. How do I know that line 2 is side­effect­free? To be\n\nsure, I’d need to look inside retrieveOrder() to ensure there are no side effects\n\nthere (and inside any functions it calls, and inside any functions its functions call, and\n\nso on). In practice, when working on my own code, I know that I generally follow the\n\nCommand­Query Separation [mf­cqs] principle, so any function that returns a value is\n\nfree of side effects. But I can only be confident of that because I know the code base; if I\n\nwere working in an unknown code base, I’d have to be more cautious. But I do try to\n\nfollow the Command­Query Separation in my own code because it’s so valuable to know\n\nthat code is free of side effects.\n\nWhen sliding code that has a side effect, or sliding over code with side effects, I have to\n\nbe much more careful. What I’m looking for is interference between the two code\n\nfragments. So, let’s say I want to slide line 11 (`if (order.isRepeat) ...`) down\n\nto the end. I’m prevented from doing that by line 12 because it references the variable\n\nwhose state I’m changing in line 11. Similarly, I can’t take line 13\n\n(`chargeOrder(charge)`) and move it up because line 12 modifies some state that\n\nline 13 references. However, I can slide line 8 (`charge = baseCharge + ...`)\n\nover lines 9–11 because there they don’t modify any common state.\n\nThe most straightforward rule to follow is that I can’t slide one fragment of code over\n\nanother if any data that both fragments refer to is modified by either one. But that’s not\n\na comprehensive rule; I can happily slide either of the following two lines over the\n\nother:\n\nwww.EBooksWorld.ir\n\na = a + 10; a = a + 5;\n\nBut judging whether a slide is safe means I have to really understand the operations\n\ninvolved and how they compose.\n\nSince I need to worry so much about updating state, I look to remove as much of it as I\n\ncan. So with this code, I’d be looking to apply Split Variable (240) on charge before I\n\nindulge in any sliding around of that code.\n\nHere, the analysis is relatively simple because I’m mostly just modifying local variables.\n\nWith more complex data structures, it’s much harder to be sure when I get interference.\n\nSo tests play an important role: Slide the fragment, run tests, see if things break. If my\n\ntest coverage is good, I can feel happy with the refactoring. But if tests aren’t reliable, I\n\nneed to be more wary—or, more likely, to improve the tests for the code I’m working on.\n\nThe most important consequence of a test failure after a slide is to use smaller slides:\n\nInstead of sliding over ten lines, I’ll just pick five, or slide up to what I reckon is a\n\ndangerous line. It may also mean that the slide isn’t worth it, and I need to work on\n\nsomething else first.\n\nExample: Sliding with Conditionals\n\nI can also do slides with conditionals. This will either involve removing duplicate logic\n\nwhen I slide out of a conditional, or adding duplicate logic when I slide in.\n\nHere’s a case where I have the same statements in both legs of a conditional:\n\nClick here to view code image\n\nlet result; if (availableResources.length === 0) { result = createResource(); allocatedResources.push(result); } else { result = availableResources.pop(); allocatedResources.push(result); } return result;\n\nI can slide these out of the conditional, in which case they turn into a single statement\n\noutside of the conditional block.\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nlet result; if (availableResources.length === 0) { result = createResource(); } else { result = availableResources.pop(); } allocatedResources.push(result); return result;\n\nIn the reverse case, sliding a fragment into a conditional means repeating it in every leg\n\nof the conditional.\n\nFurther Reading\n\nI’ve seen an almost identical refactoring under the name of Swap Statement [wake­\n\nswap]. Swap Statement moves adjacent fragments, but it only works with single­\n\nstatement fragments. You can think of it as Slide Statements where both the sliding\n\nfragment and the slid­over fragment are single statements. This refactoring appeals to\n\nme; after all, I’m always going on about taking small steps—steps that may seem\n\nridiculously small to those new to refactoring.\n\nBut I ended up writing this refactoring with larger fragments because that is what I do.\n\nI only move one statement at a time if I’m having difficulty with a larger slide, and I\n\nrarely run into problems with larger slides. With more messy code, however, smaller\n\nslides end up being easier.\n\nSPLIT LOOP\n\nwww.EBooksWorld.ir\n\nMotivation\n\nYou often see loops that are doing two different things at once just because they can do\n\nthat with one pass through a loop. But if you’re doing two different things in the same\n\nloop, then whenever you need to modify the loop you have to understand both things.\n\nBy splitting the loop, you ensure you only need to understand the behavior you need to\n\nmodify.\n\nSplitting a loop can also make it easier to use. A loop that calculates a single value can\n\njust return that value. Loops that do many things need to return structures or populate\n\nlocal variables. I frequently follow a sequence of Split Loop followed by Extract\n\nFunction (106).\n\nwww.EBooksWorld.ir\n\nMany programmers are uncomfortable with this refactoring, as it forces you to execute\n\nthe loop twice. My reminder, as usual, is to separate refactoring from optimization\n\n(Refactoring and Performance (64)). Once I have my code clear, I’ll optimize it, and if\n\nthe loop traversal is a bottleneck, it’s easy to slam the loops back together. But the\n\nactual iteration through even a large list is rarely a bottleneck, and splitting the loops\n\noften enables other, more powerful, optimizations.\n\nMechanics\n\nCopy the loop.\n\nIdentify and eliminate duplicate side effects.\n\nTest.\n\nWhen done, consider Extract Function (106) on each loop.\n\nExample\n\nI’ll start with a little bit of code that calculates the total salary and youngest age.\n\nClick here to view code image\n\nlet youngest = people[0] ? people[0].age : Infinity; let totalSalary = 0; for (const p of people) { if (p.age < youngest) youngest = p.age; totalSalary += p.salary; }\n\nreturn `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;\n\nIt’s a very simple loop, but it’s doing two different calculations. To split them, I begin\n\nwith just copying the loop.\n\nClick here to view code image\n\nlet youngest = people[0] ? people[0].age : Infinity; let totalSalary = 0; for (const p of people) { if (p.age < youngest) youngest = p.age; totalSalary += p.salary; }\n\nfor (const p of people) {\n\nwww.EBooksWorld.ir\n\nif (p.age < youngest) youngest = p.age; totalSalary += p.salary; }\n\nreturn `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;\n\nWith the loop copied, I need to remove the duplication that would otherwise produce\n\nwrong results. If something in the loop has no side effects, I can leave it there for now,\n\nbut it’s not the case with this example.\n\nClick here to view code image\n\nlet youngest = people[0] ? people[0].age : Infinity; let totalSalary = 0; for (const p of people) { if (p.age < youngest) youngest = p.age; totalSalary += p.salary; }\n\nfor (const p of people) { if (p.age < youngest) youngest = p.age; totalSalary += p.salary; }\n\nreturn `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;\n\nOfficially, that’s the end of the Split Loop refactoring. But the point of Split Loop isn’t\n\nwhat it does on its own but what it sets up for the next move—and I’m usually looking\n\nto extract the loops into their own functions. I’ll use Slide Statements (223) to\n\nreorganize the code a bit first.\n\nClick here to view code image\n\nlet totalSalary = 0; for (const p of people) { totalSalary += p.salary; }\n\nlet youngest = people[0] ? people[0].age : Infinity; for (const p of people) { if (p.age < youngest) youngest = p.age; }\n\nreturn `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;\n\nThen I do a couple of Extract Function (106).\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nreturn `youngestAge: ${youngestAge()}, totalSalary: ${totalSalary()}`;\n\nfunction totalSalary() { let totalSalary = 0; for (const p of people) { totalSalary += p.salary; } return totalSalary; }\n\nfunction youngestAge() { let youngest = people[0] ? people[0].age : Infinity; for (const p of people) { if (p.age < youngest) youngest = p.age; } return youngest; }\n\nI can rarely resist Replace Loop with Pipeline (231) for the total salary, and there’s an\n\nobvious Substitute Algorithm (195) for the youngest age.\n\nClick here to view code image\n\nreturn `youngestAge: ${youngestAge()}, totalSalary: ${totalSalary()}`;\n\nfunction totalSalary() { return people.reduce((total,p) => total + p.salary, 0); } function youngestAge() { return Math.min(...people.map(p => p.age)); }\n\nREPLACE LOOP WITH PIPELINE\n\nwww.EBooksWorld.ir",
      "page_number": 251
    },
    {
      "number": 28,
      "title": "Segment 28 (pages 261-268)",
      "start_page": 261,
      "end_page": 268,
      "detection_method": "topic_boundary",
      "content": "Motivation\n\nLike most programmers, I was taught to use loops to iterate over a collection of objects.\n\nIncreasingly, however, language environments provide a better construct: the collection\n\npipeline. Collection Pipelines [mf­cp] allow me to describe my processing as a series of\n\noperations, each consuming and emitting a collection. The most common of these\n\noperations are map, which uses a function to transform each element of the input\n\ncollection, and filter which uses a function to select a subset of the input collection for\n\nlater steps in the pipeline. I find logic much easier to follow if it is expressed as a\n\npipeline—I can then read from top to bottom to see how objects flow through the\n\npipeline.\n\nMechanics\n\nCreate a new variable for the loop’s collection.\n\nThis may be a simple copy of an existing variable.\n\nStarting at the top, take each bit of behavior in the loop and replace it with a\n\ncollection pipeline operation in the derivation of the loop collection variable. Test\n\nafter each change.\n\nOnce all behavior is removed from the loop, remove it.\n\nwww.EBooksWorld.ir\n\nIf it assigns to an accumulator, assign the pipeline result to the accumulator.\n\nExample\n\nI’ll begin with some data: a CSV file of data about our offices.\n\nClick here to view code image\n\noffice, country, telephone Chicago, USA, +1 312 373 1000 Beijing, China, +86 4008 900 505 Bangalore, India, +91 80 4064 9570 Porto Alegre, Brazil, +55 51 3079 3550 Chennai, India, +91 44 660 44766\n\n... (more data follows)\n\nThe following function picks out the offices in India and returns their cities and\n\ntelephone numbers:\n\nClick here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); let firstLine = true; const result = []; for (const line of lines) { if (firstLine) { firstLine = false; continue; } if (line.trim() === \"\") continue; const record = line.split(\",\"); if (record[1].trim() === \"India\") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }\n\nI want to replace that loop with a collection pipeline.\n\nMy first step is to create a separate variable for the loop to work over.\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); let firstLine = true; const result = []; const loopItems = lines for (const line of loopItems) { if (firstLine) { firstLine = false; continue; } if (line.trim() === \"\") continue; const record = line.split(\",\"); if (record[1].trim() === \"India\") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }\n\nThe first part of the loop is all about skipping the first line of the CSV file. This calls for\n\na slice, so I remove that first section of the loop and add a slice operation to the\n\nformation of the loop variable.\n\nClick here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); let firstLine = true; const result = []; const loopItems = lines .slice(1); for (const line of loopItems) { if (firstLine) { firstLine = false; continue; } if (line.trim() === \"\") continue; const record = line.split(\",\"); if (record[1].trim() === \"India\") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }\n\nAs a bonus, this lets me delete firstLine—and I particularly enjoy deleting control\n\nvariables.\n\nwww.EBooksWorld.ir\n\nThe next bit of behavior removes any blank lines. I can replace this with a filter\n\noperation.\n\nClick here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); const result = []; const loopItems = lines .slice(1) .filter(line => line.trim() !== \"\") ; for (const line of loopItems) { if (line.trim() === \"\") continue; const record = line.split(\",\"); if (record[1].trim() === \"India\") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }\n\nWhen writing a pipeline, I find it best to put the terminal semicolon on its own line.\n\nI use the map operation to turn lines into an array of strings—misleadingly called\n\nrecord in the original function, but it’s safer to keep the name for now and rename later.\n\nClick here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); const result = []; const loopItems = lines .slice(1) .filter(line => line.trim() !== \"\") .map(line => line.split(\",\")) ; for (const line of loopItems) { const record = line;.split(\",\"); if (record[1].trim() === \"India\") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }\n\nFilter again to just get the India records:\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); const result = []; const loopItems = lines .slice(1) .filter(line => line.trim() !== \"\") .map(line => line.split(\",\")) .filter(record => record[1].trim() === \"India\") ; for (const line of loopItems) { const record = line; if (record[1].trim() === \"India\") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }\n\nMap to the output record form:\n\nClick here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); const result = []; const loopItems = lines .slice(1) .filter(line => line.trim() !== \"\") .map(line => line.split(\",\")) .filter(record => record[1].trim() === \"India\") .map(record => ({city: record[0].trim(), phone: record[2].trim()})) ; for (const line of loopItems) { const record = line; result.push(line); } return result; }\n\nNow, all the loop does is assign values to the accumulator. So I can remove it and assign\n\nthe result of the pipeline to the accumulator:\n\nClick here to view code image\n\nfunction acquireData(input) {www.EBooksWorld.ir\n\nconst lines = input.split(\"\\n\"); const result = lines .slice(1) .filter(line => line.trim() !== \"\") .map(line => line.split(\",\")) .filter(record => record[1].trim() === \"India\") .map(record => ({city: record[0].trim(), phone: record[2].trim()})) ; for (const line of loopItems) { const record = line; result.push(line); } return result; }\n\nThat’s the core of the refactoring. But I do have some cleanup I’d like to do. I inlined\n\nresult, renamed some lambda variables, and made the layout read more like a table.\n\nClick here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); return lines .slice (1) .filter (line => line.trim() !== \"\") .map (line => line.split(\",\")) .filter (fields => fields[1].trim() === \"India\") .map (fields => ({city: fields[0].trim(), phone: fields[2].trim()})) ; }\n\nI thought about inlining lines too, but felt that its presence explains what’s\n\nhappening.\n\nFurther Reading\n\nFor more examples on turning loops into pipelines, see my essay “Refactoring with\n\nLoops and Collection Pipelines” [mf­ref­pipe].\n\nREMOVE DEAD CODE\n\nwww.EBooksWorld.ir\n\nMotivation\n\nWhen we put code into production, even on people’s devices, we aren’t charged by\n\nweight. A few unused lines of code don’t slow down our systems nor take up significant\n\nmemory; indeed, decent compilers will instinctively remove them. But unused code is\n\nstill a significant burden when trying to understand how the software works. It doesn’t\n\ncarry any warning signs telling programmers that they can ignore this function as it’s\n\nnever called any more, so they still have to spend time understanding what it’s doing\n\nand why changing it doesn’t seem to alter the output as they expected.\n\nOnce code isn’t used any more, we should delete it. I don’t worry that I may need it\n\nsometime in the future; should that happen, I have my version control system so I can\n\nalways dig it out again. If it’s something I really think I may need one day, I might put a\n\ncomment into the code that mentions the lost code and which revision it was removed\n\nin—but, honestly, I can’t remember the last time I did that, or regretted that I hadn’t\n\ndone it.\n\nCommenting out dead code was once a common habit. This was useful in the days\n\nbefore version control systems were widely used, or when they were inconvenient. Now,\n\nwhen I can put even the smallest code base under version control, that’s no longer\n\nneeded.\n\nMechanics\n\nIf the dead code can be referenced from outside, e.g., when it’s a full function, do a\n\nsearch to check for callers.\n\nRemove the dead code.\n\nTest.\n\nwww.EBooksWorld.ir\n\nChapter 9 Organizing Data\n\nHistory\n\nTopics\n\nData structures play an important role in our programs, so it’s no great shock that I\n\nhave a clutch of refactorings that focus on them. A value that’s used for different\n\nTutorials\n\npurposes is a breeding ground for confusion and bugs—so, when I see one, I use Split\n\nVariable (240) to separate the usages. As with any program element, getting a\n\nOffers & Deals\n\nvariable’s name right is tricky and important, so Rename Variable (137) is often my\n\nHighlights\n\nfriend. But sometimes the best thing I can do with a variable is to get rid of it\n\ncompletely—with Replace Derived Variable with Query (248).\n\nSettings\n\nI often find problems in a code base due to a confusion between references and values,\n\nSupport\n\nso I use Change Reference to Value (252) and Change Value to Reference (256) to\n\nchange between these styles.\n\nSign Out\n\nSPLIT VARIABLE\n\nformerly: Remove Assignments to Parameters\n\nformerly: Split Temp\n\nwww.EBooksWorld.ir",
      "page_number": 261
    },
    {
      "number": 29,
      "title": "Segment 29 (pages 269-276)",
      "start_page": 269,
      "end_page": 276,
      "detection_method": "topic_boundary",
      "content": "Motivation\n\nVariables have various uses. Some of these uses naturally lead to the variable being\n\nassigned to several times. Loop variables change for each run of a loop (such as the i in\n\nfor (let i=0; i<10; i++)). Collecting variables store a value that is built up\n\nduring the method.\n\nMany other variables are used to hold the result of a long­winded bit of code for easy\n\nreference later. These kinds of variables should be set only once. If they are set more\n\nthan once, it is a sign that they have more than one responsibility within the method.\n\nAny variable with more than one responsibility should be replaced with multiple\n\nvariables, one for each responsibility. Using a variable for two different things is very\n\nconfusing for the reader.\n\nMechanics\n\nChange the name of the variable at its declaration and first assignment.\n\nIf the later assignments are of the form i = i + something, that is a collecting\n\nvariable, so don’t split it. A collecting variable is often used for calculating sums,\n\nstring concatenation, writing to a stream, or adding to a collection.\n\nIf possible, declare the new variable as immutable.\n\nChange all references of the variable up to its second assignment.\n\nwww.EBooksWorld.ir\n\nTest.\n\nRepeat in stages, at each stage renaming the variable at the declaration and\n\nchanging references until the next assignment, until you reach the final assignment.\n\nExample\n\nFor this example, I compute the distance traveled by a haggis. From a standing start, a\n\nhaggis experiences an initial force. After a delay, a secondary force kicks in to further\n\naccelerate the haggis. Using the common laws of motion, I can compute the distance\n\ntraveled as follows:\n\nClick here to view code image\n\nfunction distanceTravelled (scenario, time) { let result; let acc = scenario.primaryForce / scenario.mass; let primaryTime = Math.min(time, scenario.delay); result = 0.5 * acc * primaryTime * primaryTime; let secondaryTime = time ­ scenario.delay; if (secondaryTime > 0) { let primaryVelocity = acc * scenario.delay; acc = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass; result += primaryVelocity * secondaryTime + 0.5 * acc * secondaryTime * secondaryTime; } return result; }\n\nA nice awkward little function. The interesting thing for our example is the way the\n\nvariable acc is set twice. It has two responsibilities: one to hold the initial acceleration\n\nfrom the first force and another later to hold the acceleration from both forces. I want\n\nto split this variable.\n\nWhen trying to understand how a variable is used, it’s handy if my editor can highlight\n\nall occurrences of a symbol within a function or file. Most modern editors can do this\n\npretty easily.\n\nI start at the beginning by changing the name of the variable and declaring the new\n\nname as const. Then, I change all references to the variable from that point up to the\n\nnext assignment. At the next assignment, I declare it:\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nfunction distanceTravelled (scenario, time) { let result; const primaryAcceleration = scenario.primaryForce / scenario.mass; let primaryTime = Math.min(time, scenario.delay); result = 0.5 * primaryAcceleration * primaryTime * primaryTime; let secondaryTime = time ­ scenario.delay; if (secondaryTime > 0) { let primaryVelocity = primaryAcceleration * scenario.delay; let acc = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass; result += primaryVelocity * secondaryTime + 0.5 * acc * secondaryTime * secondaryTime; } return result; }\n\nI choose the new name to represent only the first use of the variable. I make it const to\n\nensure it is only assigned once. I can then declare the original variable at its second\n\nassignment. Now I can compile and test, and all should work.\n\nI continue on the second assignment of the variable. This removes the original variable\n\nname completely, replacing it with a new variable named for the second use.\n\nClick here to view code image\n\nfunction distanceTravelled (scenario, time) { let result; const primaryAcceleration = scenario.primaryForce / scenario.mass; let primaryTime = Math.min(time, scenario.delay); result = 0.5 * primaryAcceleration * primaryTime * primaryTime; let secondaryTime = time ­ scenario.delay; if (secondaryTime > 0) { let primaryVelocity = primaryAcceleration * scenario.delay; const secondaryAcceleration = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass; result += primaryVelocity * secondaryTime + 0.5 * secondaryAcceleration * secondaryTime * secondaryTime; } return result; }\n\nI’m sure you can think of a lot more refactoring to be done here. Enjoy it. (I’m sure it’s\n\nbetter than eating the haggis—do you know what they put in those things?)\n\nExample: Assigning to an Input Parameter\n\nAnother case of splitting a variable is where the variable is declared as an input\n\nparameter. Consider something like\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction discount (inputValue, quantity) { if (inputValue > 50) inputValue = inputValue ­ 2; if (quantity > 100) inputValue = inputValue ­ 1; return inputValue; }\n\nHere inputValue is used both to supply an input to the function and to hold the result\n\nfor the caller. (Since JavaScript has call­by­value parameters, any modification of\n\ninputValue isn’t seen by the caller.)\n\nIn this situation, I would split that variable.\n\nClick here to view code image\n\nfunction discount (originalInputValue, quantity) { let inputValue = originalInputValue; if (inputValue > 50) inputValue = inputValue ­ 2; if (quantity > 100) inputValue = inputValue ­ 1; return inputValue; }\n\nI then perform Rename Variable (137) twice to get better names.\n\nClick here to view code image\n\nfunction discount (inputValue, quantity) { let result = inputValue; if (inputValue > 50) result = result ­ 2; if (quantity > 100) result = result ­ 1; return result; }\n\nYou’ll notice that I changed the second line to use inputValue as its data source.\n\nAlthough the two are the same, I think that line is really about applying the\n\nmodification to the result value based on the original input value, not the\n\n(coincidentally same) value of the result accumulator.\n\nRENAME FIELD\n\nwww.EBooksWorld.ir\n\nMotivation\n\nNames are important, and field names in record structures can be especially important\n\nwhen those record structures are widely used across a program. Data structures play a\n\nparticularly important role in understanding. Many years ago Fred Brooks said, “Show\n\nme your flowcharts and conceal your tables, and I shall continue to be mystified. Show\n\nme your tables, and I won’t usually need your flowcharts; they’ll be obvious.” While I\n\ndon’t see many people drawing flowcharts these days, the adage remains valid. Data\n\nstructures are the key to understanding what’s going on.\n\nSince these data structures are so important, it’s essential to keep them clear. Like\n\nanything else, my understanding of data improves the more I work on the software, so\n\nit’s vital that this improved understanding is embedded into the program.\n\nYou may want to rename a field in a record structure, but the idea also applies to\n\nclasses. Getter and setter methods form an effective field for users of the class.\n\nRenaming them is just as important as with bare record structures.\n\nMechanics\n\nIf the record has limited scope, rename all accesses to the field and test; no need to\n\ndo the rest of the mechanics.\n\nIf the record isn’t already encapsulated, apply Encapsulate Record (162).\n\nRename the private field inside the object, adjust internal methods to fit.\n\nTest.\n\nwww.EBooksWorld.ir\n\nIf the constructor uses the name, apply Change Function Declaration (124) to\n\nrename it.\n\nApply Rename Function (124) to the accessors.\n\nExample: Renaming a Field\n\nI’ll start with a constant.\n\nClick here to view code image\n\nconst organization = {name: \"Acme Gooseberries\", country: \"GB\"};\n\nI want to change “name” to “title”. The object is widely used in the code base, and there\n\nare updates to the title in the code. So my first move is to apply Encapsulate Record\n\n(162).\n\nClick here to view code image\n\nclass Organization { constructor(data) { this._name = data.name; this._country = data.country; } get name() {return this._name;} set name(aString) {this._name = aString;} get country() {return this._country;} set country(aCountryCode) {this._country = aCountryCode;} }\n\nconst organization = new Organization({name: \"Acme Gooseberries\", country: \"GB\"});\n\nNow that I’ve encapsulated the record structure into the class, there are four places I\n\nneed to look at for renaming: the getting function, the setting function, the constructor,\n\nand the internal data structure. While that may sound like I’ve increased my workload,\n\nit actually makes my work easier since I can now change these independently instead of\n\nall at once, taking smaller steps. Smaller steps mean fewer things to go wrong in each\n\nstep—therefore, less work. It wouldn’t be less work if I never made mistakes—but not\n\nmaking mistakes is a fantasy I gave up on a long time ago.\n\nSince I’ve copied the input data structure into the internal data structure, I need to\n\nseparate them so I can work on them independently. I can do this by defining a\n\nwww.EBooksWorld.ir\n\nseparate field and adjusting the constructor and accessors to use it.\n\nclass Organization…\n\nClick here to view code image\n\nclass Organization { constructor(data) { this._title = data.name; this._country = data.country; } get name() {return this._title;} set name(aString) {this._title = aString;} get country() {return this._country;} set country(aCountryCode) {this._country = aCountryCode;} }\n\nNext, I add support for using “title” in the constructor.\n\nclass Organization…\n\nClick here to view code image\n\nclass Organization { constructor(data) { this._title = (data.title !== undefined) ? data.title : data.name; this._country = data.country; } get name() {return this._title;} set name(aString) {this._title = aString;} get country() {return this._country;} set country(aCountryCode) {this._country = aCountryCode;} }\n\nNow, callers of my constructor can use either name or title (with title taking\n\nprecedence). I can now go through all constructor callers and change them one­by­one\n\nto use the new name.\n\nClick here to view code image\n\nconst organization = new Organization({title: \"Acme Gooseberries\", country: \"GB\"});\n\nOnce I’ve done all of them, I can remove the support for the name.\n\nwww.EBooksWorld.ir\n\nclass Organization…\n\nClick here to view code image\n\nclass Organization { constructor(data) { this._title = data.title; this._country = data.country; } get name() {return this._title;} set name(aString) {this._title = aString;} get country() {return this._country;} set country(aCountryCode) {this._country = aCountryCode;} }\n\nNow that the constructor and data use the new name, I can change the accessors, which\n\nis as simple as applying Rename Function (124) to each one.\n\nclass Organization…\n\nClick here to view code image\n\nclass Organization { constructor(data) { this._title = data.title; this._country = data.country; } get title() {return this._title;} set title(aString) {this._title = aString;} get country() {return this._country;} set country(aCountryCode) {this._country = aCountryCode;} }\n\nI’ve shown this process in its most heavyweight form needed for a widely used data\n\nstructure. If it’s being used only locally, as in a single function, I can probably just\n\nrename the various properties in one go without doing encapsulation. It’s a matter of\n\njudgment when to apply to the full mechanics here—but, as usual with refactoring, if\n\nmy tests break, that’s a sign I need to use the more gradual procedure.\n\nSome languages allow me to make a data structure immutable. In this case, rather than\n\nencapsulating it, I can copy the value to the new name, gradually change the users, then\n\nremove the old name. Duplicating data is a recipe for disaster with mutable data\n\nstructures; removing such disasters is why immutable data is so popular.\n\nwww.EBooksWorld.ir\n\nREPLACE DERIVED VARIABLE WITH QUERY",
      "page_number": 269
    },
    {
      "number": 30,
      "title": "Segment 30 (pages 277-284)",
      "start_page": 277,
      "end_page": 284,
      "detection_method": "topic_boundary",
      "content": "REPLACE DERIVED VARIABLE WITH QUERY\n\nMotivation\n\nOne of the biggest sources of problems in software is mutable data. Data changes can\n\noften couple together parts of code in awkward ways, with changes in one part leading\n\nto knock­on effects that are hard to spot. In many situations it’s not realistic to entirely\n\nremove mutable data—but I do advocate minimizing the scope of mutable data at much\n\nas possible.\n\nOne way I can make a big impact is by removing any variables that I could just as easily\n\ncalculate. A calculation often makes it clearer what the meaning of the data is, and it is\n\nprotected from being corrupted when you fail to update the variable as the source data\n\nchanges.\n\nA reasonable exception to this is when the source data for the calculation is immutable\n\nand we can force the result to being immutable too. Transformation operations that\n\ncreate new data structures are thus reasonable to keep even if they could be replaced\n\nwith calculations. Indeed, there is a duality here between objects that wrap a data\n\nstructure with a series of calculated properties and functions that transform one data\n\nstructure into another. The object route is clearly better when the source data changes\n\nand you would have to manage the lifetime of the derived data structures. But if the\n\nsource data is immutable, or the derived data is very transient, then both approaches\n\nare effective.\n\nMechanics\n\nwww.EBooksWorld.ir\n\nIdentify all points of update for the variable. If necessary, use Split Variable (240)\n\nto separate each point of update.\n\nCreate a function that calculates the value of the variable.\n\nUse Introduce Assertion (302) to assert that the variable and the calculation give\n\nthe same result whenever the variable is used.\n\nIf necessary, use Encapsulate Variable (132) to provide a home for the assertion.\n\nTest.\n\nReplace any reader of the variable with a call to the new function.\n\nTest.\n\nApply Remove Dead Code (237) to the declaration and updates to the variable.\n\nExample\n\nHere’s a small but perfectly formed example of ugliness:\n\nclass ProductionPlan…\n\nClick here to view code image\n\nget production() {return this._production;} applyAdjustment(anAdjustment) { this._adjustments.push(anAdjustment); this._production += anAdjustment.amount; }\n\nUgliness is in the eye of beholder; here, I see ugliness in duplication—not the common\n\nduplication of code but duplication of data. When I apply an adjustment, I’m not just\n\nstoring that adjustment but also using it to modify an accumulator. I can just calculate\n\nthat value, without having to update it.\n\nBut I’m a cautious fellow. It is my hypothesis is that I can just calculate it—I can test\n\nthat hypothesis by using Introduce Assertion (302):\n\nclass ProductionPlan…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nget production() { assert(this._production === this.calculatedProduction); return this._production; }\n\nget calculatedProduction() { return this._adjustments .reduce((sum, a) => sum + a.amount, 0); }\n\nWith the assertion in place, I run my tests. If the assertion doesn’t fail, I can replace\n\nreturning the field with returning the calculation:\n\nclass ProductionPlan…\n\nClick here to view code image\n\nget production() { assert(this._production === this.calculatedProduction); return this.calculatedProduction; }\n\nThen Inline Function (115):\n\nclass ProductionPlan…\n\nClick here to view code image\n\nget production() { return this._adjustments .reduce((sum, a) => sum + a.amount, 0); }\n\nI clean up any references to the old variable with Remove Dead Code (237):\n\nclass ProductionPlan…\n\nClick here to view code image\n\napplyAdjustment(anAdjustment) { this._adjustments.push(anAdjustment); this._production += anAdjustment.amount; }\n\nwww.EBooksWorld.ir\n\nExample: More Than One Source\n\nExample: More Than One Source\n\nThe above example is nice and easy because there’s clearly a single source for the value\n\nof production. But sometimes, more than one element can combine in the\n\naccumulator.\n\nclass ProductionPlan…\n\nClick here to view code image\n\nconstructor (production) { this._production = production; this._adjustments = []; } get production() {return this._production;} applyAdjustment(anAdjustment) { this._adjustments.push(anAdjustment); this._production += anAdjustment.amount; }\n\nIf I do the same Introduce Assertion (302) that I did above, it will now fail for any case\n\nwhere the initial value of the production isn’t zero.\n\nBut I can still replace the derived data. The only difference is that I must first apply\n\nSplit Variable (240).\n\nClick here to view code image\n\nconstructor (production) { this._initialProduction = production; this._productionAccumulator = 0; this._adjustments = []; } get production() { return this._initialProduction + this._productionAccumulator; }\n\nNow I can Introduce Assertion (302):\n\nclass ProductionPlan…\n\nClick here to view code image\n\nget production() { assert(this._productionAccumulator === this.calculatedProductionAccumulator);\n\nwww.EBooksWorld.ir\n\nreturn this._initialProduction + this._productionAccumulator; }\n\nget calculatedProductionAccumulator() { return this._adjustments .reduce((sum, a) => sum + a.amount, 0); }\n\nand continue pretty much as before. I’d be inclined, however, to leave\n\ntotalProductionAjustments as its own property, without inlining it.\n\nCHANGE REFERENCE TO VALUE\n\ninverse of: Change Value to Reference (256)\n\nMotivation\n\nWhen I nest an object, or data structure, within another I can treat the inner object as a\n\nreference or as a value. The difference is most obviously visible in how I handle updates\n\nof the inner object’s properties. If I treat it as a reference, I’ll update the inner object’s\n\nproperty keeping the same inner object. If I treat it as a value, I will replace the entire\n\ninner object with a new one that has the desired property.\n\nIf I treat a field as a value, I can change the class of the inner object to make it a Value\n\nObject [mf­vo]. Value objects are generally easier to reason about, particularly because\n\nwww.EBooksWorld.ir\n\nthey are immutable. In general, immutable data structures are easier to deal with. I can\n\npass an immutable data value out to other parts of the program and not worry that it\n\nmight change without the enclosing object being aware of the change. I can replicate\n\nvalues around my program and not worry about maintaining memory links. Value\n\nobjects are especially useful in distributed and concurrent systems.\n\nThis also suggests when I shouldn’t do this refactoring. If I want to share an object\n\nbetween several objects so that any change to the shared object is visible to all its\n\ncollaborators, then I need the shared object to be a reference.\n\nMechanics\n\nCheck that the candidate class is immutable or can become immutable.\n\nFor each setter, apply Remove Setting Method (331).\n\nProvide a value­based equality method that uses the fields of the value object.\n\nMost language environments provide an overridable equality function for this\n\npurpose. Usually you must override a hashcode generator method as well.\n\nExample\n\nImagine we have a person object that holds onto a crude telephone number.\n\nclass Person…\n\nClick here to view code image\n\nconstructor() { this._telephoneNumber = new TelephoneNumber(); }\n\nget officeAreaCode() {return this._telephoneNumber.areaCode;} set officeAreaCode(arg) {this._telephoneNumber.areaCode = arg;} get officeNumber() {return this._telephoneNumber.number;} set officeNumber(arg) {this._telephoneNumber.number = arg;}\n\nclass TelephoneNumber…\n\nClick here to view code image\n\nget areaCode() {return this._areaCode;} set areaCode(arg) {this._areaCode = arg;}\n\nwww.EBooksWorld.ir\n\nget number() {return this._number;} set number(arg) {this._number = arg;}\n\nThis situation is the result of an Extract Class (182) where the old parent still holds\n\nupdate methods for the new object. This is a good time to apply Change Reference to\n\nValue since there is only one reference to the new class.\n\nThe first thing I need to do is to make the telephone number immutable. I do this by\n\napplying Remove Setting Method (331) to the fields. The first step of Remove Setting\n\nMethod (331) is to use Change Function Declaration (124) to add the two fields to the\n\nconstructor and enhance the constructor to call the setters.\n\nclass TelephoneNumber…\n\nClick here to view code image\n\nconstructor(areaCode, number) { this._areaCode = areaCode; this._number = number; }\n\nNow I look at the callers of the setters. For each one, I need to change it to a\n\nreassignment. I start with the area code.\n\nclass Person…\n\nClick here to view code image\n\nget officeAreaCode() {return this._telephoneNumber.areaCode;} set officeAreaCode(arg) { this._telephoneNumber = new TelephoneNumber(arg, this.officeNumber); } get officeNumber() {return this._telephoneNumber.number;} set officeNumber(arg) {this._telephoneNumber.number = arg;}\n\nI then repeat that step with the remaining field.\n\nclass Person…\n\nClick here to view code image\n\nget officeAreaCode() {return this._telephoneNumber.areaCode;} www.EBooksWorld.ir\n\nset officeAreaCode(arg) { this._telephoneNumber = new TelephoneNumber(arg, this.officeNumber); } get officeNumber() {return this._telephoneNumber.number;} set officeNumber(arg) { this._telephoneNumber = new TelephoneNumber(this.officeAreaCode, arg); }\n\nNow the telephone number is immutable, it is ready to become a true value. The\n\ncitizenship test for a value object is that it uses value­based equality. This is an area\n\nwhere JavaScript falls down, as there is nothing in the language and core libraries that\n\nunderstands replacing a reference­based equality with a value­based one. The best I can\n\ndo is to create my own equals method.\n\nclass TelephoneNumber…\n\nClick here to view code image\n\nequals(other) { if (!(other instanceof TelephoneNumber)) return false; return this.areaCode === other.areaCode && this.number === other.number; }\n\nIt’s also important to test it with something like\n\nClick here to view code image\n\nit('telephone equals', function() { assert( new TelephoneNumber(\"312\", \"555­0142\") .equals(new TelephoneNumber(\"312\", \"555­0142\"))); });\n\nThe unusual formatting I use here should make it obvious that they are the same\n\nconstructor call.\n\nThe vital thing I do in the test is create two independent objects and test that they\n\nmatch as equal.\n\nIn most object­oriented languages, there is a built­in equality test that is supposed to be\n\noverridden for value­based equality. In Ruby, I can override the == operator; in Java, I\n\noverride the Object.equals() method. And whenever I override an equality method,\n\nwww.EBooksWorld.ir",
      "page_number": 277
    },
    {
      "number": 31,
      "title": "Segment 31 (pages 285-292)",
      "start_page": 285,
      "end_page": 292,
      "detection_method": "topic_boundary",
      "content": "I usually need to override a hashcode generating method too (e.g.,\n\nObject.hashCode() in Java) to ensure collections that use hashing work properly\n\nwith my new value.\n\nIf the telephone number is used by more than one client, the procedure is still the same.\n\nAs I apply Remove Setting Method (331), I’ll be modifying several clients instead of just\n\none. Tests for non­equal telephone numbers, as well as comparisons to non­telephone­\n\nnumbers and null values, are also worthwhile.\n\nCHANGE VALUE TO REFERENCE\n\ninverse of: Change Reference to Value (252)\n\nMotivation\n\nA data structure may have several records linked to the same logical data structure. I\n\nmight read in a list of orders, some of which are for the same customer. When I have\n\nsharing like this, I can represent it by treating the customer either as a value or as a\n\nreference. With a value, the customer data is copied into each order; with a reference,\n\nthere is only one data structure that multiple orders link to.\n\nIf the customer never needs to be updated, then both approaches are reasonable. It is,\n\nperhaps, a bit confusing to have multiple copies of the same data, but it’s common\n\nenough to not be a problem. In some cases, there may be issues with memory due to\n\nmultiple copies—but, like any performance issue, that’s relatively rare.\n\nThe biggest difficulty in having physical copies of the same logical data occurs when I\n\nwww.EBooksWorld.ir\n\nneed to update the shared data. I then have to find all the copies and update them all. If\n\nI miss one, I’ll get a troubling inconsistency in my data. In this case, it’s often\n\nworthwhile to change the copied data into a single reference. That way, any change is\n\nvisible to all the customer’s orders.\n\nChanging a value to a reference results in only one object being present for an entity,\n\nand it usually means I need some kind of repository where I can access these objects. I\n\nthen only create the object for an entity once, and everywhere else I retrieve it from the\n\nrepository.\n\nMechanics\n\nCreate a repository for instances of the related object (if one isn’t already present).\n\nEnsure the constructor has a way of looking up the correct instance of the related\n\nobject.\n\nChange the constructors for the host object to use the repository to obtain the\n\nrelated object. Test after each change.\n\nExample\n\nI’ll begin with a class that represents orders, which I might create from an incoming\n\nJSON document. Part of the order data is a customer ID from which I’m creating a\n\ncustomer object.\n\nclass Order…\n\nClick here to view code image\n\nconstructor(data) { this._number = data.number; this._customer = new Customer(data.customer); // load other data } get customer() {return this._customer;}\n\nclass Customer…\n\nconstructor(id) { this._id = id; } get id() {return this._id;}\n\nwww.EBooksWorld.ir\n\nThe customer object I create this way is a value. If I have five orders that refer to the\n\ncustomer ID of 123, I’ll have five separate customer objects. Any change I make to one\n\nof them will not be reflected in the others. Should I want to enrich the customer objects,\n\nperhaps by gathering data from a customer service, I’d have to update all five customers\n\nwith the same data. Having duplicate objects like this always makes me nervous—it’s\n\nconfusing to have multiple objects representing the same entity, such as a customer.\n\nThis problem is particularly awkward if the customer object is mutable, which can lead\n\nto inconsistencies between the customer objects.\n\nIf I want to use the same customer object each time, I’ll need a place to store it. Exactly\n\nwhere to store entities like this will vary from application to application, but for a\n\nsimple case I like to use a repository object [mf­repos].\n\nClick here to view code image\n\nlet _repositoryData;\n\nexport function initialize() { _repositoryData = {}; _repositoryData.customers = new Map(); }\n\nexport function registerCustomer(id) { if (! _repositoryData.customers.has(id)) _repositoryData.customers.set(id, new Customer(id)); return findCustomer(id); }\n\nexport function findCustomer(id) { return _repositoryData.customers.get(id); }\n\nThe repository allows me to register customer objects with an ID and ensures I only\n\ncreate one customer object with the same ID. With this in place, I can change the\n\norder’s constructor to use it.\n\nOften, when doing this refactoring, the repository already exists, so I can just use it.\n\nThe next step is to figure out how the constructor for the order can obtain the correct\n\ncustomer object. In this case it’s easy, since the customer’s ID is present in the input\n\ndata stream.\n\nclass Order…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nconstructor(data) { this._number = data.number; this._customer = registerCustomer(data.customer); // load other data } get customer() {return this._customer;}\n\nNow, any changes I make to the customer of one order will be synchronized across all\n\nthe orders sharing the same customer.\n\nFor this example, I created a new customer object with the first order that referenced it.\n\nAnother common approach is to get a list of customers, populate the repository with\n\nthem, and then link to them as I read the orders. In that case, an order that contains a\n\ncustomer ID not in the repository would indicate an error.\n\nOne problem with this code is that the constructor body is coupled to the global\n\nrepository. Globals should be treated with care—like a powerful drug, they can be\n\nbeneficial in small doses but a poison if used too much. If I’m concerned about it, I can\n\npass the repository as a parameter to the constructor.\n\nwww.EBooksWorld.ir\n\ny\n\nChapter 10 Simplifying Conditional Logic\n\nHistory\n\nTopics\n\nMuch of the power of programs comes from their ability to implement conditional logic\n\n—but, sadly, much of the complexity of programs lies in these conditionals. I often use\n\nTutorials\n\nrefactoring to make conditional sections easier to understand. I regularly apply\n\nDecompose Conditional (260) to complicated conditionals, and I use Consolidate\n\nOffers & Deals\n\nConditional Expression (263) to make logical combinations clearer. I use Replace\n\nHighlights\n\nNested Conditional with Guard Clauses (266) to clarify cases where I want to run some\n\npre­checks before my main processing. If I see several conditions using the same\n\nSettings\n\nswitching logic, it’s a good time to pull Replace Conditional with Polymorphism (272)\n\nout the box.\n\nSupport\n\nA lot of conditionals are used to handle special cases, such as nulls; if that logic is\n\nSign Out\n\nmostly the same, then Introduce Special Case (289) (often referred to as Introduce Null\n\nObject (289)) can remove a lot of duplicate code. And, although I like to remove\n\nconditions a lot, if I want to communicate (and check) a program’s state, I find\n\nIntroduce Assertion (302) a worthwhile addition.\n\nDECOMPOSE CONDITIONAL\n\nwww.EBooksWorld.ir\n\nMotivation\n\nOne of the most common sources of complexity in a program is complex conditional\n\nlogic. As I write code to do various things depending on various conditions, I can\n\nquickly end up with a pretty long function. Length of a function is in itself a factor that\n\nmakes it harder to read, but conditions increase the difficulty. The problem usually lies\n\nin the fact that the code, both in the condition checks and in the actions, tells me what\n\nhappens but can easily obscure why it happens.\n\nAs with any large block of code, I can make my intention clearer by decomposing it and\n\nreplacing each chunk of code with a function call named after the intention of that\n\nchunk. With conditions, I particularly like doing this for the conditional part and each\n\nof the alternatives. This way, I highlight the condition and make it clear what I’m\n\nbranching on. I also highlight the reason for the branching.\n\nThis is really just a particular case of applying Extract Function (106) to my code, but I\n\nlike to highlight this case as one where I’ve often found a remarkably good value for the\n\nexercise.\n\nMechanics\n\nApply Extract Function (106) on the condition and each leg of the conditional.\n\nwww.EBooksWorld.ir\n\nExample\n\nExample\n\nSuppose I’m calculating the charge for something that has separate rates for winter and\n\nsummer:\n\nClick here to view code image\n\nif (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd)) charge = quantity * plan.summerRate; else charge = quantity * plan.regularRate + plan.regularServiceCharge;\n\nI extract the condition into its own function.\n\nClick here to view code image\n\nif (summer()) charge = quantity * plan.summerRate; else charge = quantity * plan.regularRate + plan.regularServiceCharge;\n\nfunction summer() { return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd); }\n\nThen I do the then leg:\n\nClick here to view code image\n\nif (summer()) charge = summerCharge(); else charge = quantity * plan.regularRate + plan.regularServiceCharge;\n\nfunction summer() { return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd); } function summerCharge() { return quantity * plan.summerRate; }\n\nFinally, the else leg:\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nif (summer()) charge = summerCharge(); else charge = regularCharge();\n\nfunction summer() { return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd); } function summerCharge() { return quantity * plan.summerRate; } function regularCharge() { return quantity * plan.regularRate + plan.regularServiceCharge; }\n\nWith that done, I like to reformat the conditional using the ternary operator.\n\nClick here to view code image\n\ncharge = summer() ? summerCharge() : regularCharge();\n\nfunction summer() { return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd); } function summerCharge() { return quantity * plan.summerRate; } function regularCharge() { return quantity * plan.regularRate + plan.regularServiceCharge; }\n\nCONSOLIDATE CONDITIONAL EXPRESSION\n\nwww.EBooksWorld.ir",
      "page_number": 285
    },
    {
      "number": 32,
      "title": "Segment 32 (pages 293-301)",
      "start_page": 293,
      "end_page": 301,
      "detection_method": "topic_boundary",
      "content": "Motivation\n\nSometimes, I run into a series of conditional checks where each check is different yet\n\nthe resulting action is the same. When I see this, I use and and or operators to\n\nconsolidate them into a single conditional check with a single result.\n\nConsolidating the conditional code is important for two reasons. First, it makes it\n\nclearer by showing that I’m really making a single check that combines other checks.\n\nThe sequence has the same effect, but it looks like I’m carrying out a sequence of\n\nseparate checks that just happen to be close together. The second reason I like to do\n\nthis is that it often sets me up for Extract Function (106). Extracting a condition is one\n\nof the most useful things I can do to clarify my code. It replaces a statement of what I’m\n\ndoing with why I’m doing it.\n\nThe reasons in favor of consolidating conditionals also point to the reasons against\n\ndoing it. If I consider it to be truly independent checks that shouldn’t be thought of as a\n\nsingle check, I don’t do the refactoring.\n\nMechanics\n\nEnsure that none of the conditionals have any side effects.\n\nIf any do, use Separate Query from Modifier (306) on them first.\n\nwww.EBooksWorld.ir\n\nTake two of the conditional statements and combine their conditions using a logical\n\noperator.\n\nSequences combine with or, nested if statements combine with and.\n\nTest.\n\nRepeat combining conditionals until they are all in a single condition.\n\nConsider using Extract Function (106) on the resulting condition.\n\nExample\n\nPerusing some code, I see the following:\n\nClick here to view code image\n\nfunction disabilityAmount(anEmployee) { if (anEmployee.seniority < 2) return 0; if (anEmployee.monthsDisabled > 12) return 0; if (anEmployee.isPartTime) return 0; // compute the disability amount\n\nIt’s a sequence of conditional checks which all have the same result. Since the result is\n\nthe same, I should combine these conditions into a single expression. For a sequence\n\nlike this, I do it using an or operator.\n\nClick here to view code image\n\nfunction disabilityAmount(anEmployee) { if ((anEmployee.seniority < 2) || (anEmployee.monthsDisabled > 12)) return 0; if (anEmployee.isPartTime) return 0; // compute the disability amount\n\nI test, then fold in the other condition:\n\nClick here to view code image\n\nfunction disabilityAmount(anEmployee) { if ((anEmployee.seniority < 2) || (anEmployee.monthsDisabled > 12) || (anEmployee.isPartTime)) return 0; // compute the disability amount\n\nwww.EBooksWorld.ir\n\nOnce I have them all together, I use Extract Function (106) on the condition.\n\nClick here to view code image\n\nfunction disabilityAmount(anEmployee) { if (isNotEligableForDisability()) return 0; // compute the disability amount\n\nfunction isNotEligableForDisability() { return ((anEmployee.seniority < 2) || (anEmployee.monthsDisabled > 12) || (anEmployee.isPartTime)); }\n\nExample: Using ands\n\nThe example above showed combining statements with an or, but I may run into cases\n\nthat need ands as well. Such a case uses nested if statements:\n\nClick here to view code image\n\nif (anEmployee.onVacation) if (anEmployee.seniority > 10) return 1; return 0.5;\n\nI combine these using and operators.\n\nClick here to view code image\n\nif ((anEmployee.onVacation) && (anEmployee.seniority > 10)) return 1; return 0.5;\n\nIf I have a mix of these, I can combine using and and or operators as needed. When\n\nthis happens, things are likely to get messy, so I use Extract Function (106) liberally to\n\nmake it all understandable.\n\nREPLACE NESTED CONDITIONAL WITH GUARD CLAUSES\n\nwww.EBooksWorld.ir\n\nMotivation\n\nI often find that conditional expressions come in two styles. In the first style, both legs\n\nof the conditional are part of normal behavior, while in the second style, one leg is\n\nnormal and the other indicates an unusual condition.\n\nThese kinds of conditionals have different intentions—and these intentions should\n\ncome through in the code. If both are part of normal behavior, I use a condition with an\n\nif and an else leg. If the condition is an unusual condition, I check the condition and\n\nreturn if it’s true. This kind of check is often called a guard clause.\n\nThe key point of Replace Nested Conditional with Guard Clauses is emphasis. If I’m\n\nusing an if­then­else construct, I’m giving equal weight to the if leg and the else leg.\n\nwww.EBooksWorld.ir\n\nThis communicates to the reader that the legs are equally likely and important. Instead,\n\nthe guard clause says, “This isn’t the core to this function, and if it happens, do\n\nsomething and get out.”\n\nI often find I use Replace Nested Conditional with Guard Clauses when I’m working\n\nwith a programmer who has been taught to have only one entry point and one exit point\n\nfrom a method. One entry point is enforced by modern languages, but one exit point is\n\nreally not a useful rule. Clarity is the key principle: If the method is clearer with one exit\n\npoint, use one exit point; otherwise don’t.\n\nMechanics\n\nSelect outermost condition that needs to be replaced, and change it into a guard\n\nclause.\n\nTest.\n\nRepeat as needed.\n\nIf all the guard clauses return the same result, use Consolidate Conditional\n\nExpression (263).\n\nExample\n\nHere’s some code to calculate a payment amount for an employee. It’s only relevant if\n\nthe employee is still with the company, so it has to check for the two other cases.\n\nClick here to view code image\n\nfunction payAmount(employee) { let result; if(employee.isSeparated) { result = {amount: 0, reasonCode: \"SEP\"}; } else { if (employee.isRetired) { result = {amount: 0, reasonCode: \"RET\"}; } else { // logic to compute amount lorem.ipsum(dolor.sitAmet); consectetur(adipiscing).elit(); sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua); ut.enim.ad(minim.veniam); result = someFinalComputation(); }\n\nwww.EBooksWorld.ir\n\n} return result; }\n\nNesting the conditionals here masks the true meaning of what it going on. The primary\n\npurpose of this code only applies if these conditions aren’t the case. In this situation,\n\nthe intention of the code reads more clearly with guard clauses.\n\nAs with any refactoring change, I like to take small steps, so I begin with the topmost\n\ncondition.\n\nClick here to view code image\n\nfunction payAmount(employee) { let result; if (employee.isSeparated) return {amount: 0, reasonCode: \"SEP\"}; if (employee.isRetired) { result = {amount: 0, reasonCode: \"RET\"}; } else { // logic to compute amount lorem.ipsum(dolor.sitAmet); consectetur(adipiscing).elit(); sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua); ut.enim.ad(minim.veniam); result = someFinalComputation(); } return result; }\n\nI test that change and move on to the next one.\n\nClick here to view code image\n\nfunction payAmount(employee) { let result; if (employee.isSeparated) return {amount: 0, reasonCode: \"SEP\"}; if (employee.isRetired) return {amount: 0, reasonCode: \"RET\"}; // logic to compute amount lorem.ipsum(dolor.sitAmet); consectetur(adipiscing).elit(); sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua); ut.enim.ad(minim.veniam); result = someFinalComputation(); return result; }\n\nwww.EBooksWorld.ir\n\nAt which point the result variable isn’t really doing anything useful, so I remove it.\n\nClick here to view code image\n\nfunction payAmount(employee) { let result; if (employee.isSeparated) return {amount: 0, reasonCode: \"SEP\"}; if (employee.isRetired) return {amount: 0, reasonCode: \"RET\"}; // logic to compute amount lorem.ipsum(dolor.sitAmet); consectetur(adipiscing).elit(); sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua); ut.enim.ad(minim.veniam); return someFinalComputation(); }\n\nThe rule is that you always get an extra strawberry when you remove a mutable\n\nvariable.\n\nExample: Reversing the Conditions\n\nWhen reviewing the manuscript of the first edition of this book, Joshua Kerievsky\n\npointed out that we often do Replace Nested Conditional with Guard Clauses by\n\nreversing the conditional expressions. Even better, he gave me an example so I didn’t\n\nhave to further tax my imagination.\n\nClick here to view code image\n\nfunction adjustedCapital(anInstrument) { let result = 0; if (anInstrument.capital > 0) { if (anInstrument.interestRate > 0 && anInstrument.duration > 0) { result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor; } } return result; }\n\nAgain, I make the replacements one at a time, but this time I reverse the condition as I\n\nput in the guard clause.\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction adjustedCapital(anInstrument) { let result = 0; if (anInstrument.capital <= 0) return result; if (anInstrument.interestRate > 0 && anInstrument.duration > 0) { result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor; } return result; }\n\nThe next conditional is a bit more complicated, so I do it in two steps. First, I simply\n\nadd a not.\n\nClick here to view code image\n\nfunction adjustedCapital(anInstrument) { let result = 0; if (anInstrument.capital <= 0) return result; if (!(anInstrument.interestRate > 0 && anInstrument.duration > 0)) return result; result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor; return result; }\n\nLeaving nots in a conditional like that twists my mind around at a painful angle, so I\n\nsimplify it:\n\nClick here to view code image\n\nfunction adjustedCapital(anInstrument) { let result = 0; if (anInstrument.capital <= 0) return result; if (anInstrument.interestRate <= 0 || anInstrument.duration <= 0) return result; result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor; return result; }\n\nBoth of those lines have conditions with the same result, so I apply Consolidate\n\nConditional Expression (263).\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nfunction adjustedCapital(anInstrument) { let result = 0; if ( anInstrument.capital <= 0 || anInstrument.interestRate <= 0 || anInstrument.duration <= 0) return result; result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor; return result; }\n\nThe result variable is doing two things here. Its first setting to zero indicates what to\n\nreturn when the guard clause triggers; its second value is the final computation. I can\n\nget rid of it, which both eliminates its double usage and gets me a strawberry.\n\nClick here to view code image\n\nfunction adjustedCapital(anInstrument) { if ( anInstrument.capital <= 0 || anInstrument.interestRate <= 0 || anInstrument.duration <= 0) return 0; return (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor; }\n\nREPLACE CONDITIONAL WITH POLYMORPHISM\n\nwww.EBooksWorld.ir",
      "page_number": 293
    },
    {
      "number": 33,
      "title": "Segment 33 (pages 302-320)",
      "start_page": 302,
      "end_page": 320,
      "detection_method": "topic_boundary",
      "content": "Motivation\n\nComplex conditional logic is one of the hardest things to reason about in programming,\n\nso I always look for ways to add structure to conditional logic. Often, I find I can\n\nseparate the logic into different circumstances—high­level cases—to divide the\n\nconditions. Sometimes it’s enough to represent this division within the structure of a\n\nconditional itself, but using classes and polymorphism can make the separation more\n\nexplicit.\n\nA common case for this is where I can form a set of types, each handling the conditional\n\nlogic differently. I might notice that books, music, and food vary in how they are\n\nhandled because of their type. This is made most obvious when there are several\n\nfunctions that have a switch statement on a type code. In that case, I remove the\n\nduplication of the common switch logic by creating classes for each case and using www.EBooksWorld.ir\n\npolymorphism to bring out the type­specific behavior.\n\nAnother situation is where I can think of the logic as a base case with variants. The base\n\ncase may be the most common or most straightforward. I can put this logic into a\n\nsuperclass which allows me to reason about it without having to worry about the\n\nvariants. I then put each variant case into a subclass, which I express with code that\n\nemphasizes its difference from the base case.\n\nPolymorphism is one of the key features of object­oriented programming—and, like any\n\nuseful feature, it’s prone to overuse. I’ve come across people who argue that all\n\nexamples of conditional logic should be replaced with polymorphism. I don’t agree with\n\nthat view. Most of my conditional logic uses basic conditional statements—if/else and\n\nswitch/case. But when I see complex conditional logic that can be improved as\n\ndiscussed above, I find polymorphism a powerful tool.\n\nMechanics\n\nIf classes do not exist for polymorphic behavior, create them together with a factory\n\nfunction to return the correct instance.\n\nUse the factory function in calling code.\n\nMove the conditional function to the superclass.\n\nIf the conditional logic is not a self­contained function, use Extract Function (106)\n\nto make it so.\n\nPick one of the subclasses. Create a subclass method that overrides the conditional\n\nstatement method. Copy the body of that leg of the conditional statement into the\n\nsubclass method and adjust it to fit.\n\nRepeat for each leg of the conditional.\n\nLeave a default case for the superclass method. Or, if superclass should be abstract,\n\ndeclare that method as abstract or throw an error to show it should be the\n\nresponsibility of a subclass.\n\nExample\n\nMy friend has a collection of birds and wants to know how fast they can fly and what\n\nthey have for plumage. So we have a couple of small programs to determine the\n\ninformation.\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction plumages(birds) {\n\nreturn new Map(birds.map(b => [b.name, plumage(b)])); } function speeds(birds) {\n\nreturn new Map(birds.map(b => [b.name, airSpeedVelocity(b)])); }\n\nfunction plumage(bird) {\n\nswitch (bird.type) { case 'EuropeanSwallow': return \"average\"; case 'AfricanSwallow': return (bird.numberOfCoconuts > 2) ? \"tired\" : \"average\"; case 'NorwegianBlueParrot': return (bird.voltage > 100) ? \"scorched\" : \"beautiful\"; default: return \"unknown\"; } }\n\nfunction airSpeedVelocity(bird) {\n\nswitch (bird.type) { case 'EuropeanSwallow': return 35; case 'AfricanSwallow': return 40 ­ 2 * bird.numberOfCoconuts; case 'NorwegianBlueParrot': return (bird.isNailed) ? 0 : 10 + bird.voltage / 10; default: return null; } }\n\nWe have a couple of different operations that vary with the type of bird, so it makes\n\nsense to create classes and use polymorphism for any type­specific behavior.\n\nI begin by using Combine Functions into Class (144) on airSpeedVelocity and\n\nplumage.\n\nClick here to view code image\n\nfunction plumage(bird) { return new Bird(bird).plumage; }\n\nfunction airSpeedVelocity(bird) { return new Bird(bird).airSpeedVelocity;\n\nwww.EBooksWorld.ir\n\n}\n\nclass Bird { constructor(birdObject) { Object.assign(this, birdObject); } get plumage() { switch (this.type) { case 'EuropeanSwallow': return \"average\"; case 'AfricanSwallow': return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\"; case 'NorwegianBlueParrot': return (this.voltage > 100) ? \"scorched\" : \"beautiful\"; default: return \"unknown\"; } } get airSpeedVelocity() { switch (this.type) { case 'EuropeanSwallow': return 35; case 'AfricanSwallow': return 40 ­ 2 * this.numberOfCoconuts; case 'NorwegianBlueParrot': return (this.isNailed) ? 0 : 10 + this.voltage / 10; default: return null; } } }\n\nI now add subclasses for each kind of bird, together with a factory function to\n\ninstantiate the appropriate subclass.\n\nClick here to view code image\n\nfunction plumage(bird) { return createBird(bird).plumage; }\n\nfunction airSpeedVelocity(bird) { return createBird(bird).airSpeedVelocity; }\n\nfunction createBird(bird) { switch (bird.type) { case 'EuropeanSwallow': return new EuropeanSwallow(bird); case 'AfricanSwallow': return new AfricanSwallow(bird); www.EBooksWorld.ir\n\ncase 'NorweigianBlueParrot': return new NorwegianBlueParrot(bird); default: return new Bird(bird); } }\n\nclass EuropeanSwallow extends Bird { }\n\nclass AfricanSwallow extends Bird { }\n\nclass NorwegianBlueParrot extends Bird { }\n\nNow that I’ve created the class structure that I need, I can begin on the two conditional\n\nmethods. I’ll begin with plumage. I take one leg of the switch statement and override it\n\nin the appropriate subclass.\n\nclass EuropeanSwallow…\n\nget plumage() { return \"average\"; }\n\nclass Bird…\n\nClick here to view code image\n\nget plumage() { switch (this.type) { case 'EuropeanSwallow': throw \"oops\"; case 'AfricanSwallow': return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\"; case 'NorwegianBlueParrot': return (this.voltage > 100) ? \"scorched\" : \"beautiful\"; default: return \"unknown\"; } }\n\nI put in the throw because I’m paranoid.\n\nI can compile and test at this point. Then, if all is well, I do the next leg.\n\nwww.EBooksWorld.ir\n\nclass AfricanSwallow…\n\nClick here to view code image\n\nget plumage() { return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\"; }\n\nThen, the Norwegian Blue:\n\nclass NorwegianBlueParrot…\n\nClick here to view code image\n\nget plumage() { return (this.voltage > 100) ? \"scorched\" : \"beautiful\"; }\n\nI leave the superclass method for the default case.\n\nclass Bird…\n\nget plumage() { return \"unknown\"; }\n\nI repeat the same process for airSpeedVelocity. Once I’m done, I end up with the\n\nfollowing code (I also inlined the top­level functions for airSpeedVelocity and\n\nplumage):\n\nClick here to view code image\n\nfunction plumages(birds) {\n\nreturn new Map(birds .map(b => createBird(b)) .map(bird => [bird.name, bird.plumage])); } function speeds(birds) {\n\nreturn new Map(birds .map(b => createBird(b)) .map(bird => [bird.name, bird.airSpeedVelocity])); }\n\nfunction createBird(bird) {\n\nwww.EBooksWorld.ir\n\nswitch (bird.type) { case 'EuropeanSwallow': return new EuropeanSwallow(bird); case 'AfricanSwallow': return new AfricanSwallow(bird); case 'NorwegianBlueParrot': return new NorwegianBlueParrot(bird); default: return new Bird(bird); } }\n\nclass Bird {\n\nconstructor(birdObject) { Object.assign(this, birdObject); } get plumage() {\n\nreturn \"unknown\"; } get airSpeedVelocity() {\n\nreturn null; } } class EuropeanSwallow extends Bird { get plumage() {\n\nreturn \"average\"; } get airSpeedVelocity() {\n\nreturn 35; } } class AfricanSwallow extends Bird { get plumage() {\n\nreturn (this.numberOfCoconuts > 2) ? \"tired\" : \"average\"; } get airSpeedVelocity() {\n\nreturn 40 ­ 2 * this.numberOfCoconuts; } } class NorwegianBlueParrot extends Bird { get plumage() {\n\nreturn (this.voltage > 100) ? \"scorched\" : \"beautiful\"; } get airSpeedVelocity() {\n\nreturn (this.isNailed) ? 0 : 10 + this.voltage / 10; } }\n\nLooking at this final code, I can see that the superclass Bird isn’t strictly needed. In\n\nJavaScript, I don’t need a type hierarchy for polymorphism; as long as my objects\n\nimplement the appropriately named methods, everything works fine. In this situation,\n\nwww.EBooksWorld.ir\n\nhowever, I like to keep the unnecessary superclass as it helps explain the way the\n\nclasses are related in the domain.\n\nExample: Using Polymorphism for Variation\n\nWith the birds example, I’m using a clear generalization hierarchy. That’s how\n\nsubclassing and polymorphism is often discussed in textbooks (including mine)—but\n\nit’s not the only way inheritance is used in practice; indeed, it probably isn’t the most\n\ncommon or best way. Another case for inheritance is when I wish to indicate that one\n\nobject is mostly similar to another, but with some variations.\n\nAs an example of this case, consider some code used by a rating agency to compute an\n\ninvestment rating for the voyages of sailing ships. The rating agency gives out either an\n\n“A” or “B” rating, depending of various factors due to risk and profit potential. The risk\n\ncomes from assessing the nature of the voyage as well as the history of the captain’s\n\nprior voyages.\n\nClick here to view code image\n\nfunction rating(voyage, history) {\n\nconst vpf = voyageProfitFactor(voyage, history); const vr = voyageRisk(voyage); const chr = captainHistoryRisk(voyage, history); if (vpf * 3 > (vr + chr * 2)) return \"A\"; else return \"B\"; } function voyageRisk(voyage) {\n\nlet result = 1; if (voyage.length > 4) result += 2; if (voyage.length > 8) result += voyage.length ­ 8; if ([\"china\", \"east­indies\"].includes(voyage.zone)) result += 4; return Math.max(result, 0); } function captainHistoryRisk(voyage, history) {\n\nlet result = 1; if (history.length < 5) result += 4; result += history.filter(v => v.profit < 0).length; if (voyage.zone === \"china\" && hasChina(history)) result ­= 2; return Math.max(result, 0); } function hasChina(history) {\n\nreturn history.some(v => \"china\" === v.zone); } function voyageProfitFactor(voyage, history) {\n\nlet result = 2; if (voyage.zone === \"china\") result += 1; if (voyage.zone === \"east­indies\") result += 1; if (voyage.zone === \"china\" && hasChina(history)) {\n\nwww.EBooksWorld.ir\n\nresult += 3; if (history.length > 10) result += 1; if (voyage.length > 12) result += 1; if (voyage.length > 18) result ­= 1; } else { if (history.length > 8) result += 1; if (voyage.length > 14) result ­= 1; } return result; }\n\nThe functions voyageRisk and captainHistoryRisk score points for risk,\n\nvoyageProfitFactor scores points for the potential profit, and rating combines\n\nthese to give the overall rating for the voyage.\n\nThe calling code would look something like this:\n\nClick here to view code image\n\nconst voyage = {zone: \"west­indies\", length: 10}; const history = [ {zone: \"east­indies\", profit: 5}, {zone: \"west­indies\", profit: 15}, {zone: \"china\", profit: ­2}, {zone: \"west­africa\", profit: 7}, ];\n\nconst myRating = rating(voyage, history);\n\nWhat I want to focus on here is how a couple of places use conditional logic to handle\n\nthe case of a voyage to China where the captain has been to China before.\n\nClick here to view code image\n\nfunction rating(voyage, history) { const vpf = voyageProfitFactor(voyage, history); const vr = voyageRisk(voyage); const chr = captainHistoryRisk(voyage, history); if (vpf * 3 > (vr + chr * 2)) return \"A\"; else return \"B\"; } function voyageRisk(voyage) { let result = 1; if (voyage.length > 4) result += 2; if (voyage.length > 8) result += voyage.length ­ 8; if ([\"china\", \"east­indies\"].includes(voyage.zone)) result += 4;\n\nwww.EBooksWorld.ir\n\nreturn Math.max(result, 0); } function captainHistoryRisk(voyage, history) { let result = 1; if (history.length < 5) result += 4; result += history.filter(v => v.profit < 0).length; if (voyage.zone === \"china\" && hasChina(history)) result ­= 2; return Math.max(result, 0); } function hasChina(history) { return history.some(v => \"china\" === v.zone); } function voyageProfitFactor(voyage, history) { let result = 2; if (voyage.zone === \"china\") result += 1; if (voyage.zone === \"east­indies\") result += 1; if (voyage.zone === \"china\" && hasChina(history)) { result += 3; if (history.length > 10) result += 1; if (voyage.length > 12) result += 1; if (voyage.length > 18) result ­= 1; } else { if (history.length > 8) result += 1; if (voyage.length > 14) result ­= 1; } return result; }\n\nI will use inheritance and polymorphism to separate out the logic for handling these\n\ncases from the base logic. This is a particularly useful refactoring if I’m about to\n\nintroduce more special logic for this case—and the logic for these repeat China voyages\n\ncan make it harder to understand the base case.\n\nI’m beginning with a set of functions. To introduce polymorphism, I need to create a\n\nclass structure, so I begin by applying Combine Functions into Class (144). This results\n\nin the following code:\n\nClick here to view code image\n\nfunction rating(voyage, history) {\n\nreturn new Rating(voyage, history).value; }\n\nclass Rating {\n\nconstructor(voyage, history) { this.voyage = voyage; this.history = history; }\n\nwww.EBooksWorld.ir\n\nget value() { const vpf = this.voyageProfitFactor; const vr = this.voyageRisk; const chr = this.captainHistoryRisk; if (vpf * 3 > (vr + chr * 2)) return \"A\"; else return \"B\"; } get voyageRisk() { let result = 1; if (this.voyage.length > 4) result += 2; if (this.voyage.length > 8) result += this.voyage.length ­ 8; if ([\"china\", \"east­indies\"].includes(this.voyage.zone)) result += 4; return Math.max(result, 0); } get captainHistoryRisk() { let result = 1; if (this.history.length < 5) result += 4; result += this.history.filter(v => v.profit < 0).length; if (this.voyage.zone === \"china\" && this.hasChinaHistory) result ­= 2; return Math.max(result, 0); } get voyageProfitFactor() { let result = 2;\n\nif (this.voyage.zone === \"china\") result += 1; if (this.voyage.zone === \"east­indies\") result += 1; if (this.voyage.zone === \"china\" && this.hasChinaHistory) { result += 3; if (this.history.length > 10) result += 1; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; } else { if (this.history.length > 8) result += 1; if (this.voyage.length > 14) result ­= 1; } return result; } get hasChinaHistory() { return this.history.some(v => \"china\" === v.zone); } }\n\nThat’s given me the class for the base case. I now need to create an empty subclass to\n\nhouse the variant behavior.\n\nClick here to view code image\n\nclass ExperiencedChinaRating extends Rating { }\n\nwww.EBooksWorld.ir\n\nI then create a factory function to return the variant class when needed.\n\nClick here to view code image\n\nfunction createRating(voyage, history) { if (voyage.zone === \"china\" && history.some(v => \"china\" === v.zone)) return new ExperiencedChinaRating(voyage, history); else return new Rating(voyage, history); }\n\nI need to modify any callers to use the factory function instead of directly invoking the\n\nconstructor, which in this case is just the rating function.\n\nClick here to view code image\n\nfunction rating(voyage, history) { return createRating(voyage, history).value; }\n\nThere are two bits of behavior I need to move into a subclass. I begin with the logic in\n\ncaptainHistoryRisk:\n\nclass Rating…\n\nClick here to view code image\n\nget captainHistoryRisk() { let result = 1; if (this.history.length < 5) result += 4; result += this.history.filter(v => v.profit < 0).length; if (this.voyage.zone === \"china\" && this.hasChinaHistory) result ­= 2; return Math.max(result, 0); }\n\nI write the overriding method in the subclass:\n\nclass ExperiencedChinaRating\n\nClick here to view code image\n\nget captainHistoryRisk() {\n\nwww.EBooksWorld.ir\n\nconst result = super.captainHistoryRisk ­ 2; return Math.max(result, 0); }\n\nclass Rating…\n\nClick here to view code image\n\nget captainHistoryRisk() { let result = 1; if (this.history.length < 5) result += 4; result += this.history.filter(v => v.profit < 0).length; if (this.voyage.zone === \"china\" && this.hasChinaHistory) result ­= 2; return Math.max(result, 0); }\n\nSeparating the variant behavior from voyageProfitFactor is a bit more messy. I\n\ncan’t simply remove the variant behavior and call the superclass method since there is\n\nan alternative path here. I also don’t want to copy the whole superclass method down to\n\nthe subclass.\n\nclass Rating…\n\nClick here to view code image\n\nget voyageProfitFactor() { let result = 2;\n\nif (this.voyage.zone === \"china\") result += 1; if (this.voyage.zone === \"east­indies\") result += 1; if (this.voyage.zone === \"china\" && this.hasChinaHistory) { result += 3; if (this.history.length > 10) result += 1; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; } else { if (this.history.length > 8) result += 1; if (this.voyage.length > 14) result ­= 1; } return result; }\n\nSo my response is to first use Extract Function (106) on the entire conditional block.\n\nwww.EBooksWorld.ir\n\nclass Rating…\n\nClick here to view code image\n\nget voyageProfitFactor() { let result = 2;\n\nif (this.voyage.zone === \"china\") result += 1; if (this.voyage.zone === \"east­indies\") result += 1; result += this.voyageAndHistoryLengthFactor; return result; }\n\nget voyageAndHistoryLengthFactor() { let result = 0; if (this.voyage.zone === \"china\" && this.hasChinaHistory) { result += 3; if (this.history.length > 10) result += 1; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; } else { if (this.history.length > 8) result += 1; if (this.voyage.length > 14) result ­= 1; } return result; }\n\nA function name with an “And” in it is a pretty bad smell, but I’ll let it sit and reek for a\n\nmoment, while I apply the subclassing.\n\nclass Rating…\n\nClick here to view code image\n\nget voyageAndHistoryLengthFactor() { let result = 0; if (this.history.length > 8) result += 1; if (this.voyage.length > 14) result ­= 1; return result; }\n\nclass ExperiencedChinaRating…\n\nClick here to view code image\n\nget voyageAndHistoryLengthFactor() {\n\nwww.EBooksWorld.ir\n\nlet result = 0; result += 3; if (this.history.length > 10) result += 1; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; return result; }\n\nThat’s, formally, the end of the refactoring—I’ve separated the variant behavior out into\n\nthe subclass. The superclass’s logic is simpler to understand and work with, and I only\n\nneed to deal with variant case when I’m working on the subclass code, which is\n\nexpressed in terms of its difference with the superclass.\n\nBut I feel I should at least outline what I’d do with the awkward new method.\n\nIntroducing a method purely for overriding by a subclass is a common thing to do when\n\ndoing this kind of base­and­variation inheritance. But a crude method like this\n\nobscures what’s going on, instead of revealing.\n\nThe “And” gives away that there are really two separate modifications going on here—so\n\nI think it’s wise to separate them. I’ll do this by using Extract Function (106) on the\n\nhistory length modification, both in the superclass and subclass. I start with just the\n\nsuperclass:\n\nclass Rating…\n\nClick here to view code image\n\nget voyageAndHistoryLengthFactor() { let result = 0; result += this.historyLengthFactor; if (this.voyage.length > 14) result ­= 1; return result; } get historyLengthFactor() { return (this.history.length > 8) ? 1 : 0; }\n\nI do the same with the subclass:\n\nclass ExperiencedChinaRating…\n\nClick here to view code image\n\nget voyageAndHistoryLengthFactor() {\n\nwww.EBooksWorld.ir\n\nlet result = 0; result += 3; result += this.historyLengthFactor; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; return result; } get historyLengthFactor() { return (this.history.length > 10) ? 1 : 0; }\n\nI can then use Move Statements to Callers (217) on the superclass case.\n\nclass Rating…\n\nClick here to view code image\n\nget voyageProfitFactor() { let result = 2; if (this.voyage.zone === \"china\") result += 1; if (this.voyage.zone === \"east­indies\") result += 1; result += this.historyLengthFactor; result += this.voyageAndHistoryLengthFactor; return result; } get voyageAndHistoryLengthFactor() { let result = 0; result += this.historyLengthFactor; if (this.voyage.length > 14) result ­= 1; return result; }\n\nclass ExperiencedChinaRating…\n\nClick here to view code image\n\nget voyageAndHistoryLengthFactor() { let result = 0; result += 3; result += this.historyLengthFactor; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; return result; }\n\nI’d then use Rename Function (124).\n\nwww.EBooksWorld.ir\n\nclass Rating…\n\nClick here to view code image\n\nget voyageProfitFactor() { let result = 2; if (this.voyage.zone === \"china\") result += 1; if (this.voyage.zone === \"east­indies\") result += 1; result += this.historyLengthFactor; result += this.voyageLengthFactor; return result; }\n\nget voyageLengthFactor() { return (this.voyage.length > 14) ? ­ 1: 0; }\n\nChanging to a ternary to simplify voyageLengthFactor.\n\nclass ExperiencedChinaRating…\n\nClick here to view code image\n\nget voyageLengthFactor() { let result = 0; result += 3; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; return result; }\n\nOne last thing. I don’t think adding 3 points makes sense as part of the voyage length\n\nfactor—it’s better added to the overall result.\n\nclass ExperiencedChinaRating…\n\nClick here to view code image\n\nget voyageProfitFactor() { return super.voyageProfitFactor + 3; }\n\nget voyageLengthFactor() { let result = 0; result += 3; if (this.voyage.length > 12) result += 1;\n\nwww.EBooksWorld.ir\n\nif (this.voyage.length > 18) result ­= 1; return result; }\n\nAt the end of the refactoring, I have the following code. First, there is the basic rating\n\nclass which can ignore any complications of the experienced China case:\n\nClick here to view code image\n\nclass Rating {\n\nconstructor(voyage, history) { this.voyage = voyage; this.history = history; } get value() {\n\nconst vpf = this.voyageProfitFactor; const vr = this.voyageRisk; const chr = this.captainHistoryRisk; if (vpf * 3 > (vr + chr * 2)) return \"A\"; else return \"B\"; } get voyageRisk() {\n\nlet result = 1; if (this.voyage.length > 4) result += 2; if (this.voyage.length > 8) result += this.voyage.length ­ 8; if ([\"china\", \"east­indies\"].includes(this.voyage.zone)) result += 4; return Math.max(result, 0); } get captainHistoryRisk() {\n\nlet result = 1; if (this.history.length < 5) result += 4; result += this.history.filter(v => v.profit < 0).length; return Math.max(result, 0); } get voyageProfitFactor() {\n\nlet result = 2; if (this.voyage.zone === \"china\") result += 1; if (this.voyage.zone === \"east­indies\") result += 1; result += this.historyLengthFactor; result += this.voyageLengthFactor; return result; } get voyageLengthFactor() {\n\nreturn (this.voyage.length > 14) ? ­ 1: 0; } get historyLengthFactor() {\n\nreturn (this.history.length > 8) ? 1 : 0; } }\n\nwww.EBooksWorld.ir\n\nThe code for the experienced China case reads as a set of variations on the base:\n\nClick here to view code image\n\nclass ExperiencedChinaRating extends Rating { get captainHistoryRisk() {\n\nconst result = super.captainHistoryRisk ­ 2; return Math.max(result, 0); } get voyageLengthFactor() {\n\nlet result = 0; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; return result; } get historyLengthFactor() {\n\nreturn (this.history.length > 10) ? 1 : 0; } get voyageProfitFactor() {\n\nreturn super.voyageProfitFactor + 3; } }\n\nINTRODUCE SPECIAL CASE\n\nformerly: Introduce Null Object\n\nMotivation\n\nA common case of duplicated code is when many users of a data structure check a\n\nspecific value, and then most of them do the same thing. If I find many parts of the code\n\nwww.EBooksWorld.ir",
      "page_number": 302
    },
    {
      "number": 34,
      "title": "Segment 34 (pages 321-338)",
      "start_page": 321,
      "end_page": 338,
      "detection_method": "topic_boundary",
      "content": "base having the same reaction to a particular value, I want to bring that reaction into a\n\nsingle place.\n\nA good mechanism for this is the Special Case pattern where I create a special­case\n\nelement that captures all the common behavior. This allows me to replace most of the\n\nspecial­case checks with simple calls.\n\nA special case can manifest itself in several ways. If all I’m doing with the object is\n\nreading data, I can supply a literal object with all the values I need filled in. If I need\n\nmore behavior than simple values, I can create a special object with methods for all the\n\ncommon behavior. The special­case object can be returned by an encapsulating class, or\n\ninserted into a data structure with a transform.\n\nA common value that needs special­case processing is null, which is why this pattern is\n\noften called the Null Object pattern. But it’s the same approach for any special case—I\n\nlike to say that Null Object is a special case of Special Case.\n\nMechanics\n\nBegin with a container data structure (or class) that contains a property which is the\n\nsubject of the refactoring. Clients of the container compare the subject property of\n\nthe container to a special­case value. We wish to replace the special­case value of the\n\nsubject with a special case class or data structure.\n\nAdd a special­case check property to the subject, returning false.\n\nCreate a special­case object with only the special­case check property, returning\n\ntrue.\n\nApply Extract Function (106) to the special­case comparison code. Ensure that all\n\nclients use the new function instead of directly comparing it.\n\nIntroduce the new special­case subject into the code, either by returning it from a\n\nfunction call or by applying a transform function.\n\nChange the body of the special­case comparison function so that it uses the special­\n\ncase check property.\n\nTest.\n\nUse Combine Functions into Class (144) or Combine Functions into Transform\n\n(149) to move all of the common special­case behavior into the new element.\n\nwww.EBooksWorld.ir\n\nSince the special­case class usually returns fixed values to simple requests, these\n\nmay be handled by making the special case a literal record.\n\nUse Inline Function (115) on the special­case comparison function for the places\n\nwhere it’s still needed.\n\nExample\n\nA utility company installs its services in sites.\n\nclass Site…\n\nClick here to view code image\n\nget customer() {return this._customer;}\n\nThere are various properties of the customer class; I’ll consider three of them.\n\nclass Customer…\n\nget name() {...} get billingPlan() {...} set billingPlan(arg) {...} get paymentHistory() {...}\n\nMost of the time, a site has a customer, but sometimes there isn’t one. Someone may\n\nhave moved out and I don’t yet know who, if anyone, has moved in. When this happens,\n\nthe data record fills the customer field with the string “unknown”. Because this can\n\nhappen, clients of the site need to be able to handle an unknown customer. Here are\n\nsome example fragments:\n\nclient 1…\n\nClick here to view code image\n\nconst aCustomer = site.customer; // ... lots of intervening code ... let customerName; if (aCustomer === \"unknown\") customerName = \"occupant\"; else customerName = aCustomer.name;\n\nclient 2…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nconst plan = (aCustomer === \"unknown\") ? registry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nif (aCustomer !== \"unknown\") aCustomer.billingPlan = newPlan;\n\nclient 4…\n\nClick here to view code image\n\nconst weeksDelinquent = (aCustomer === \"unknown\") ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nLooking through the code base, I see many clients of the site object that have to deal\n\nwith an unknown customer. Most of them do the same thing when they get one: They\n\nuse “occupant” as the name, give them a basic billing plan, and class them as zero­\n\nweeks delinquent. This widespread testing for a special case, plus a common response,\n\nis what tells me it’s time for a Special Case Object.\n\nI begin by adding a method to the customer to indicate it is unknown.\n\nclass Customer…\n\nget isUnknown() {return false;}\n\nI then add an Unknown Customer class.\n\nClick here to view code image\n\nclass UnknownCustomer { get isUnknown() {return true;} }\n\nwww.EBooksWorld.ir\n\nNote that I don’t make UnknownCustomer a subclass of Customer. In other\n\nlanguages, particularly those statically typed, I would, but JavaScript’s rules for\n\nsubclassing, as well as its dynamic typing, make it better to not do that here.\n\nNow comes the tricky bit. I have to return this new special­case object whenever I\n\nexpect \"unknown\" and change each test for an unknown value to use the new\n\nisUnknown method. In general, I always want to arrange things so I can make one\n\nsmall change at a time, then test. But if I change the customer class to return an\n\nunknown customer instead of “unknown”, I have to make every client testing for\n\n“unknown” to call isUnknown—and I have to do it all at once. I find that as appealing\n\nas eating liver (i.e., not at all).\n\nThere is a common technique to use whenever I find myself in this bind. I use Extract\n\nFunction (106) on the code that I’d have to change in lots of places—in this case, the\n\nspecial­case comparison code.\n\nClick here to view code image\n\nfunction isUnknown(arg) { if (!((arg instanceof Customer) || (arg === \"unknown\"))) throw new Error(`investigate bad value: <${arg}>`); return (arg === \"unknown\"); }\n\nI’ve put a trap in here for an unexpected value. This can help me to spot any mistakes or\n\nodd behavior as I’m doing this refactoring.\n\nI can now use this function whenever I’m testing for an unknown customer. I can\n\nchange these calls one at a time, testing after each change.\n\nclient 1…\n\nClick here to view code image\n\nlet customerName; if (isUnknown(aCustomer)) customerName = \"occupant\"; else customerName = aCustomer.name;\n\nAfter a while, I have done them all.\n\nclient 2…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nconst plan = (isUnknown(aCustomer)) ? registry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nif (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan;\n\nclient 4…\n\nClick here to view code image\n\nconst weeksDelinquent = isUnknown(aCustomer) ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nOnce I’ve changed all the callers to use isUnknown, I can change the site class to return\n\nan unknown customer.\n\nclass Site…\n\nClick here to view code image\n\nget customer() { return (this._customer === \"unknown\") ? new UnknownCustomer() : this._customer; }\n\nI can check that I’m no longer using the “unknown” string by changing isUnknown to\n\nuse the unknown value.\n\nclient 1…\n\nClick here to view code image\n\nfunction isUnknown(arg) { if (!(arg instanceof Customer || arg instanceof UnknownCustomer)) throw new Error(`investigate bad value: <${arg}>`);\n\nwww.EBooksWorld.ir\n\nreturn arg.isUnknown; }\n\nI test to ensure that’s all working.\n\nNow the fun begins. I can use Combine Functions into Class (144) to take each client’s\n\nspecial­case check and see if I can replace it with a commonly expected value. At the\n\nmoment, I have various clients using “occupant” for the name of an unknown customer,\n\nlike this:\n\nclient 1…\n\nClick here to view code image\n\nlet customerName; if (isUnknown(aCustomer)) customerName = \"occupant\"; else customerName = aCustomer.name;\n\nI add a suitable method to the unknown customer:\n\nclass UnknownCustomer…\n\nClick here to view code image\n\nget name() {return \"occupant\";}\n\nNow I can make all that conditional code go away.\n\nclient 1…\n\nClick here to view code image\n\nconst customerName = aCustomer.name;\n\nOnce I’ve tested that this works, I’ll probably be able to use Inline Variable (123) on\n\nthat variable too.\n\nNext is the billing plan property.\n\nclient 2…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nconst plan = (isUnknown(aCustomer)) ? registry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nif (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan;\n\nFor read behavior, I do the same thing I did with the name—take the common response\n\nand reply with it. With the write behavior, the current code doesn’t call the setter for an\n\nunknown customer—so for the special case, I let the setter be called, but it does\n\nnothing.\n\nclass UnknownCustomer…\n\nClick here to view code image\n\nget billingPlan() {return registry.billingPlans.basic;} set billingPlan(arg) { /* ignore */ }\n\nclient reader…\n\nClick here to view code image\n\nconst plan = aCustomer.billingPlan;\n\nclient writer…\n\nClick here to view code image\n\naCustomer.billingPlan = newPlan;\n\nSpecial­case objects are value objects, and thus should always be immutable, even if the\n\nobjects they are substituting for are not.\n\nThe last case is a bit more involved because the special case needs to return another\n\nwww.EBooksWorld.ir\n\nobject that has its own properties.\n\nclient…\n\nClick here to view code image\n\nconst weeksDelinquent = isUnknown(aCustomer) ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nThe general rule with a special­case object is that if it needs to return related objects,\n\nthey are usually special cases themselves. So here I need to create a null payment\n\nhistory.\n\nclass UnknownCustomer…\n\nClick here to view code image\n\nget paymentHistory() {return new NullPaymentHistory();}\n\nclass NullPaymentHistory…\n\nClick here to view code image\n\nget weeksDelinquentInLastYear() {return 0;}\n\nclient…\n\nClick here to view code image\n\nconst weeksDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nI carry on, looking at all the clients to see if I can replace them with the polymorphic\n\nbehavior. But there will be exceptions—clients that want to do something different with\n\nthe special case. I may have 23 clients that use “occupant” for the name of an unknown\n\ncustomer, but there’s always one that needs something different.\n\nclient…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nconst name = ! isUnknown(aCustomer) ? aCustomer.name : \"unknown occupant\";\n\nIn that case, I need to retain a special­case check. I will change it to use the method on\n\ncustomer, essentially using Inline Function (115) on isUnknown.\n\nclient…\n\nClick here to view code image\n\nconst name = aCustomer.isUnknown ? \"unknown occupant\" : aCustomer.name;\n\nWhen I’m done with all the clients, I should be able to use Remove Dead Code (237) on\n\nthe global isPresent function, as nobody should be calling it any more.\n\nExample: Using an Object Literal\n\nCreating a class like this is a fair bit of work for what is really a simple value. But for the\n\nexample I gave, I had to make the class since the customer could be updated. If,\n\nhowever, I only read the data structure, I can use a literal object instead.\n\nHere is the opening case again—just the same, except this time there is no client that\n\nupdates the customer:\n\nclass Site…\n\nClick here to view code image\n\nget customer() {return this._customer;}\n\nclass Customer…\n\nget name() {...} get billingPlan() {...} set billingPlan(arg) {...} get paymentHistory() {...}\n\nclient 1…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nconst aCustomer = site.customer; // ... lots of intervening code ... let customerName; if (aCustomer === \"unknown\") customerName = \"occupant\"; else customerName = aCustomer.name;\n\nclient 2…\n\nClick here to view code image\n\nconst plan = (aCustomer === \"unknown\") ? registry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nconst weeksDelinquent = (aCustomer === \"unknown\") ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nAs with the previous case, I start by adding an isUnknown property to the customer\n\nand creating a special­case object with that field. The difference is that this time, the\n\nspecial case is a literal.\n\nclass Customer…\n\nget isUnknown() {return false;}\n\ntop level…\n\nClick here to view code image\n\nfunction createUnknownCustomer() { return { isUnknown: true, }; }\n\nI apply Extract Function (106) to the special case condition test.\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction isUnknown(arg) { return (arg === \"unknown\"); }\n\nclient 1…\n\nClick here to view code image\n\nlet customerName; if (isUnknown(aCustomer)) customerName = \"occupant\"; else customerName = aCustomer.name;\n\nclient 2…\n\nClick here to view code image\n\nconst plan = isUnknown(aCustomer) ? registry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nconst weeksDelinquent = isUnknown(aCustomer) ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nI change the site class and the condition test to work with the special case.\n\nclass Site…\n\nClick here to view code image\n\nget customer() { return (this._customer === \"unknown\") ? createUnknownCustomer() : this._customer; }\n\ntop level…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction isUnknown(arg) { return arg.isUnknown; }\n\nThen I replace each standard response with the appropriate literal value. I start with\n\nthe name:\n\nClick here to view code image\n\nfunction createUnknownCustomer() { return { isUnknown: true, name: \"occupant\", }; }\n\nclient 1…\n\nClick here to view code image\n\nconst customerName = aCustomer.name;\n\nThen, the billing plan:\n\nClick here to view code image\n\nfunction createUnknownCustomer() { return { isUnknown: true, name: \"occupant\", billingPlan: registry.billingPlans.basic, }; }\n\nclient 2…\n\nClick here to view code image\n\nconst plan = aCustomer.billingPlan;\n\nwww.EBooksWorld.ir\n\nSimilarly, I can create a nested null payment history with the literal:\n\nClick here to view code image\n\nfunction createUnknownCustomer() { return { isUnknown: true, name: \"occupant\", billingPlan: registry.billingPlans.basic, paymentHistory: { weeksDelinquentInLastYear: 0, }, }; }\n\nclient 3…\n\nClick here to view code image\n\nconst weeksDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nIf I use a literal like this, I should make it immutable, which I might do with freeze.\n\nUsually, I’d rather use a class.\n\nExample: Using a Transform\n\nBoth previous cases involve a class, but the same idea can be applied to a record by\n\nusing a transform step.\n\nLet’s assume our input is a simple record structure that looks something like this:\n\nClick here to view code image\n\n{ name: \"Acme Boston\", location: \"Malden MA\", // more site details customer: { name: \"Acme Industries\", billingPlan: \"plan­451\", paymentHistory: { weeksDelinquentInLastYear: 7 //more }, // more\n\nwww.EBooksWorld.ir\n\n} }\n\nIn some cases, the customer isn’t known, and such cases are marked in the same way:\n\nClick here to view code image\n\n{ name: \"Warehouse Unit 15\", location: \"Malden MA\", // more site details customer: \"unknown\", }\n\nI have similar client code that checks for the unknown customer:\n\nclient 1…\n\nClick here to view code image\n\nconst site = acquireSiteData(); const aCustomer = site.customer; // ... lots of intervening code ... let customerName; if (aCustomer === \"unknown\") customerName = \"occupant\"; else customerName = aCustomer.name;\n\nclient 2…\n\nClick here to view code image\n\nconst plan = (aCustomer === \"unknown\") ? registry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nconst weeksDelinquent = (aCustomer === \"unknown\") ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nwww.EBooksWorld.ir\n\nMy first step is to run the site data structure through a transform that, currently, does\n\nnothing but a deep copy.\n\nclient 1…\n\nClick here to view code image\n\nconst rawSite = acquireSiteData(); const site = enrichSite(rawSite); const aCustomer = site.customer; // ... lots of intervening code ... let customerName; if (aCustomer === \"unknown\") customerName = \"occupant\"; else customerName = aCustomer.name;\n\nfunction enrichSite(inputSite) { return _.cloneDeep(inputSite); }\n\nI apply Extract Function (106) to the test for an unknown customer.\n\nClick here to view code image\n\nfunction isUnknown(aCustomer) { return aCustomer === \"unknown\"; }\n\nclient 1…\n\nClick here to view code image\n\nconst rawSite = acquireSiteData(); const site = enrichSite(rawSite); const aCustomer = site.customer; // ... lots of intervening code ... let customerName; if (isUnknown(aCustomer)) customerName = \"occupant\"; else customerName = aCustomer.name;\n\nclient 2…\n\nClick here to view code image\n\nconst plan = (isUnknown(aCustomer)) ?\n\nwww.EBooksWorld.ir\n\nregistry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nconst weeksDelinquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nI begin the enrichment by adding an isUnknown property to the customer.\n\nClick here to view code image\n\nfunction enrichSite(aSite) { const result = _.cloneDeep(aSite); const unknownCustomer = { isUnknown: true, };\n\nif (isUnknown(result.customer)) result.customer = unknownCustomer; else result.customer.isUnknown = false; return result; }\n\nI can then modify the special­case condition test to include probing for this new\n\nproperty. I keep the original test as well, so that the test will work on both raw and\n\nenriched sites.\n\nClick here to view code image\n\nfunction isUnknown(aCustomer) { if (aCustomer === \"unknown\") return true; else return aCustomer.isUnknown; }\n\nI test to ensure that’s all OK, then start applying Combine Functions into Transform\n\n(149) on the special case. First, I move the choice of name into the enrichment function.\n\nClick here to view code image\n\nfunction enrichSite(aSite) {\n\nwww.EBooksWorld.ir\n\nconst result = _.cloneDeep(aSite); const unknownCustomer = { isUnknown: true, name: \"occupant\", };\n\nif (isUnknown(result.customer)) result.customer = unknownCustomer; else result.customer.isUnknown = false; return result; }\n\nclient 1…\n\nClick here to view code image\n\nconst rawSite = acquireSiteData(); const site = enrichSite(rawSite); const aCustomer = site.customer; // ... lots of intervening code ... const customerName = aCustomer.name;\n\nI test, then do the billing plan.\n\nClick here to view code image\n\nfunction enrichSite(aSite) { const result = _.cloneDeep(aSite); const unknownCustomer = { isUnknown: true, name: \"occupant\", billingPlan: registry.billingPlans.basic, };\n\nif (isUnknown(result.customer)) result.customer = unknownCustomer; else result.customer.isUnknown = false; return result; }\n\nclient 2…\n\nClick here to view code image\n\nconst plan = aCustomer.billingPlan;\n\nI test again, then do the last client.\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction enrichSite(aSite) { const result = _.cloneDeep(aSite); const unknownCustomer = { isUnknown: true, name: \"occupant\", billingPlan: registry.billingPlans.basic, paymentHistory: { weeksDelinquentInLastYear: 0, } };\n\nif (isUnknown(result.customer)) result.customer = unknownCustomer; else result.customer.isUnknown = false; return result; }\n\nclient 3…\n\nClick here to view code image\n\nconst weeksDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nINTRODUCE ASSERTION\n\nMotivation\n\nOften, sections of code work only if certain conditions are true. This may be as simple\n\nas a square root calculation only working on a positive input value. With an object, it\n\nwww.EBooksWorld.ir",
      "page_number": 321
    },
    {
      "number": 35,
      "title": "Segment 35 (pages 339-346)",
      "start_page": 339,
      "end_page": 346,
      "detection_method": "topic_boundary",
      "content": "may require that at least one of a group of fields has a value in it.\n\nSuch assumptions are often not stated but can only be deduced by looking through an\n\nalgorithm. Sometimes, the assumptions are stated with a comment. A better technique\n\nis to make the assumption explicit by writing an assertion.\n\nAn assertion is a conditional statement that is assumed to be always true. Failure of an\n\nassertion indicates a programmer error. Assertion failures should never be checked by\n\nother parts of the system. Assertions should be written so that the program functions\n\nequally correctly if they are all removed; indeed, some languages provide assertions\n\nthat can be disabled by a compile­time switch.\n\nI often see people encourage using assertions in order to find errors. While this is\n\ncertainly a Good Thing, it’s not the only reason to use them. I find assertions to be a\n\nvaluable form of communication—they tell the reader something about the assumed\n\nstate of the program at this point of execution. I also find them handy for debugging,\n\nand their communication value means I’m inclined to leave them in once I’ve fixed the\n\nerror I’m chasing. Self­testing code reduces their value for debugging, as steadily\n\nnarrowing unit tests often do the job better, but I still like assertions for\n\ncommunication.\n\nMechanics\n\nWhen you see that a condition is assumed to be true, add an assertion to state it.\n\nSince assertions should not affect the running of a system, adding one is always\n\nbehavior­preserving.\n\nExample\n\nHere’s a simple tale of discounts. A customer can be given a discount rate to apply to all\n\ntheir purchases:\n\nclass Customer…\n\nClick here to view code image\n\napplyDiscount(aNumber) { return (this.discountRate) ? aNumber ­ (this.discountRate * aNumber) : aNumber; }\n\nwww.EBooksWorld.ir\n\nThere’s an assumption here that the discount rate is a positive number. I can make that\n\nassumption explicit by using an assertion. But I can’t easily place an assertion into a\n\nternary expression, so first I’ll reformulate it as an if­then statement.\n\nclass Customer…\n\nClick here to view code image\n\napplyDiscount(aNumber) { if (!this.discountRate) return aNumber; else return aNumber ­ (this.discountRate * aNumber); }\n\nNow I can easily add the assertion.\n\nclass Customer…\n\nClick here to view code image\n\napplyDiscount(aNumber) { if (!this.discountRate) return aNumber; else { assert(this.discountRate >= 0); return aNumber ­ (this.discountRate * aNumber); } }\n\nIn this case, I’d rather put this assertion into the setting method. If the assertion fails in\n\napplyDiscount, my first puzzle is how it got into the field in the first place.\n\nclass Customer…\n\nClick here to view code image\n\nset discountRate(aNumber) { assert(null === aNumber || aNumber >= 0); this._discountRate = aNumber; }\n\nAn assertion like this can be particularly valuable if it’s hard to spot the error source—\n\nwhich may be an errant minus sign in some input data or some inversion elsewhere in\n\nthe code.\n\nwww.EBooksWorld.ir\n\nThere is a real danger of overusing assertions. I don’t use assertions to check everything\n\nthat I think is true, but only to check things that need to be true. Duplication is a\n\nparticular problem, as it’s common to tweak these kinds of conditions. So I find it’s\n\nessential to remove any duplication in these conditions, usually by a liberal use of\n\nExtract Function (106).\n\nI only use assertions for things that are programmer errors. If I’m reading data from an\n\nexternal source, any value checking should be a first­class part of the program, not an\n\nassertion—unless I’m really confident in the external source. Assertions are a last resort\n\nto help track bugs—though, ironically, I only use them when I think they should never\n\nfail.\n\nwww.EBooksWorld.ir\n\nChapter 11 Refactoring APIs\n\nHistory\n\nTopics\n\nModules and their functions are the building blocks of our software. APIs are the joints\n\nthat we use to plug them together. Making these APIs easy to understand and use is\n\nTutorials\n\nimportant but also difficult: I need to refactor them as I learn how to improve them.\n\nOffers & Deals\n\nA good API clearly separates any functions that update data from those that only read\n\ndata. If I see them combined, I use Separate Query from Modifier (306) to tease them\n\nHighlights\n\napart. I can unify functions that only vary due to a value with Parameterize Function\n\n(310). Some parameters, however, are really just a signal of an entirely different\n\nSettings\n\nbehavior and are best excised with Remove Flag Argument (314).\n\nSupport\n\nData structures are often unpacked unnecessarily when passed between functions; I\n\nSign Out\n\nprefer to keep them together with Preserve Whole Object (319). Decisions on what\n\nshould be passed as a parameter, and what can be resolved by the called function, are\n\nones I often need to revisit with Replace Parameter with Query (324) and Replace\n\nQuery with Parameter (327).\n\nA class is a common form of module. I prefer my objects to be as immutable as possible,\n\nso I use Remove Setting Method (331) whenever I can. Often, when a caller asks for a\n\nnew object, I need more flexibility than a simple constructor gives, which I can get by\n\nusing Replace Constructor with Factory Function (334).\n\nThe last two refactorings address the difficulty of breaking down a particularly complex\n\nfunction that passes a lot of data around. I can turn that function into an object with\n\nReplace Function with Command (337), which makes it easier to use Extract Function\n\n(106) on the function’s body. If I later simplify the function and no longer need it as a\n\ncommand object, I turn it back into a function with Replace Command with Function\n\n(344).\n\n.\n\nSEPARATE QUERY FROM MODIFIER\n\nwww.EBooksWorld.ir\n\nMotivation\n\nWhen I have a function that gives me a value and has no observable side effects, I have\n\na very valuable thing. I can call this function as often as I like. I can move the call to\n\nother places in a calling function. It’s easier to test. In short, I have a lot less to worry\n\nabout.\n\nIt is a good idea to clearly signal the difference between functions with side effects and\n\nthose without. A good rule to follow is that any function that returns a value should not\n\nhave observable side effects—the command­query separation [mf­cqs]. Some\n\nprogrammers treat this as an absolute rule. I’m not 100 percent pure on this (as on\n\nanything), but I try to follow it most of the time, and it has served me well.\n\nIf I come across a method that returns a value but also has side effects, I always try to\n\nseparate the query from the modifier.\n\nNote that I use the phrase observable side effects. A common optimization is to cache\n\nthe value of a query in a field so that repeated calls go quicker. Although this changes\n\nthe state of the object with the cache, the change is not observable. Any sequence of\n\nqueries will always return the same results for each query.\n\nMechanics\n\nwww.EBooksWorld.ir\n\nCopy the function, name it as a query.\n\nLook into the function to see what is returned. If the query is used to populate a\n\nvariable, the variable’s name should provide a good clue.\n\nRemove any side effects from the new query function.\n\nRun static checks.\n\nFind each call of the original method. If that call uses the return value, replace the\n\noriginal call with a call to the query and insert a call to the original method below it.\n\nTest after each change.\n\nRemove return values from original.\n\nTest.\n\nOften after doing this there will be duplication between the query and the original\n\nmethod that can be tidied up.\n\nExample\n\nHere is a function that scans a list of names for a miscreant. If it finds one, it returns\n\nthe name of the bad guy and sets off the alarms. It only does this for the first miscreant\n\nit finds (I guess one is enough).\n\nClick here to view code image\n\nfunction alertForMiscreant (people) { for (const p of people) { if (p === \"Don\") { setOffAlarms(); return \"Don\"; } if (p === \"John\") { setOffAlarms(); return \"John\"; } } return \"\"; }\n\nI begin by copying the function, naming it after the query aspect of the function.\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nfunction findMiscreant (people) { for (const p of people) { if (p === \"Don\") { setOffAlarms(); return \"Don\"; } if (p === \"John\") { setOffAlarms(); return \"John\"; } } return \"\"; }\n\nI remove the side effects from this new query.\n\nClick here to view code image\n\nfunction findMiscreant (people) { for (const p of people) { if (p === \"Don\") { setOffAlarms(); return \"Don\"; } if (p === \"John\") { setOffAlarms(); return \"John\"; } } return \"\"; }\n\nI now go to each caller and replace it with a call to the query, followed by a call to the\n\nmodifier. So\n\nClick here to view code image\n\nconst found = alertForMiscreant(people);\n\nchanges to\n\nClick here to view code image\n\nconst found = findMiscreant(people); alertForMiscreant(people);\n\nwww.EBooksWorld.ir\n\nI now remove the return values from the modifier.\n\nClick here to view code image\n\nfunction alertForMiscreant (people) { for (const p of people) { if (p === \"Don\") { setOffAlarms(); return; } if (p === \"John\") { setOffAlarms(); return; } } return; }\n\nNow I have a lot of duplication between the original modifier and the new query, so I\n\ncan use Substitute Algorithm (195) so that the modifier uses the query.\n\nClick here to view code image\n\nfunction alertForMiscreant (people) { if (findMiscreant(people) !== \"\") setOffAlarms(); }\n\nPARAMETERIZE FUNCTION\n\nformerly: Parameterize Method\n\nwww.EBooksWorld.ir",
      "page_number": 339
    },
    {
      "number": 36,
      "title": "Segment 36 (pages 347-356)",
      "start_page": 347,
      "end_page": 356,
      "detection_method": "topic_boundary",
      "content": "Motivation\n\nIf I see two functions that carry out very similar logic with different literal values, I can\n\nremove the duplication by using a single function with parameters for the different\n\nvalues. This increases the usefulness of the function, since I can apply it elsewhere with\n\ndifferent values.\n\nMechanics\n\nSelect one of the similar methods.\n\nUse Change Function Declaration (124) to add any literals that need to turn into\n\nparameters.\n\nFor each caller of the function, add the literal value.\n\nTest.\n\nChange the body of the function to use the new parameters. Test after each change.\n\nFor each similar function, replace the call with a call to the parameterized function.\n\nTest after each one.\n\nIf the original parameterized function doesn’t work for a similar function, adjust it\n\nfor the new function before moving on to the next.\n\nExample\n\nwww.EBooksWorld.ir\n\nAn obvious example is something like this:\n\nClick here to view code image\n\nfunction tenPercentRaise(aPerson) { aPerson.salary = aPerson.salary.multiply(1.1); } function fivePercentRaise(aPerson) { aPerson.salary = aPerson.salary.multiply(1.05); }\n\nHopefully it’s obvious that I can replace these with\n\nClick here to view code image\n\nfunction raise(aPerson, factor) { aPerson.salary = aPerson.salary.multiply(1 + factor); }\n\nBut it can be a bit more involved than that. Consider this code:\n\nClick here to view code image\n\nfunction baseCharge(usage) { if (usage < 0) return usd(0); const amount = bottomBand(usage) * 0.03 + middleBand(usage) * 0.05 + topBand(usage) * 0.07; return usd(amount); }\n\nfunction bottomBand(usage) { return Math.min(usage, 100); }\n\nfunction middleBand(usage) { return usage > 100 ? Math.min(usage, 200) ­ 100 : 0; }\n\nfunction topBand(usage) { return usage > 200 ? usage ­ 200 : 0; }\n\nHere the logic is clearly pretty similar—but is it similar enough to support creating a\n\nparameterized method for the bands? It is, but may be a touch less obvious than the\n\nwww.EBooksWorld.ir\n\ntrivial case above.\n\nWhen looking to parameterize some related functions, my approach is to take one of\n\nthe functions and add parameters to it, with an eye to the other cases. With range­\n\noriented things like this, usually the place to start is with the middle range. So I’ll work\n\non middleBand to change it to use parameters, and then adjust other callers to fit.\n\nmiddleBand uses two literal values: 100 and 200. These represent the bottom and top\n\nof this middle band. I begin by using Change Function Declaration (124) to add them\n\nto the call. While I’m at it, I’ll also change the name of the function to something that\n\nmakes sense with the parameterization.\n\nClick here to view code image\n\nfunction withinBand(usage, bottom, top) { return usage > 100 ? Math.min(usage, 200) ­ 100 : 0; }\n\nfunction baseCharge(usage) { if (usage < 0) return usd(0); const amount = bottomBand(usage) * 0.03 + withinBand(usage, 100, 200) * 0.05 + topBand(usage) * 0.07; return usd(amount); }\n\nI replace each literal with a reference to the parameter:\n\nClick here to view code image\n\nfunction withinBand(usage, bottom, top) { return usage > bottom ? Math.min(usage, 200) ­ bottom : 0; }\n\nthen:\n\nClick here to view code image\n\nfunction withinBand(usage, bottom, top) { return usage > bottom ? Math.min(usage, top) ­ bottom : 0; }\n\nwww.EBooksWorld.ir\n\nI replace the call to the bottom band with a call to the newly parameterized function.\n\nClick here to view code image\n\nfunction baseCharge(usage) { if (usage < 0) return usd(0); const amount = withinBand(usage, 0, 100) * 0.03 + withinBand(usage, 100, 200) * 0.05 + topBand(usage) * 0.07; return usd(amount); }\n\nfunction bottomBand(usage) { return Math.min(usage, 100); }\n\nTo replace the call to the top band, I need to make use of infinity.\n\nClick here to view code image\n\nfunction baseCharge(usage) { if (usage < 0) return usd(0); const amount = withinBand(usage, 0, 100) * 0.03 + withinBand(usage, 100, 200) * 0.05 + withinBand(usage, 200, Infinity) * 0.07; return usd(amount); }\n\nfunction topBand(usage) { return usage > 200 ? usage ­ 200 : 0; }\n\nWith the logic working the way it does now, I could remove the initial guard clause. But\n\nalthough it’s logically unnecessary now, I like to keep it as it documents how to handle\n\nthat case.\n\nREMOVE FLAG ARGUMENT\n\nformerly: Replace Parameter with Explicit Methods\n\nwww.EBooksWorld.ir\n\nMotivation\n\nA flag argument is a function argument that the caller uses to indicate which logic the\n\ncalled function should execute. I may call a function that looks like this:\n\nClick here to view code image\n\nfunction bookConcert(aCustomer, isPremium) { if (isPremium) { // logic for premium booking } else { // logic for regular booking } }\n\nTo book a premium concert, I issue the call like so:\n\nbookConcert(aCustomer, true);\n\nFlag arguments can also come as enums:\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nbookConcert(aCustomer, CustomerType.PREMIUM);\n\nor strings (or symbols in languages that use them):\n\nClick here to view code image\n\nbookConcert(aCustomer, \"premium\");\n\nI dislike flag arguments because they complicate the process of understanding what\n\nfunction calls are available and how to call them. My first route into an API is usually\n\nthe list of available functions, and flag arguments hide the differences in the function\n\ncalls that are available. Once I select a function, I have to figure out what values are\n\navailable for the flag arguments. Boolean flags are even worse since they don’t convey\n\ntheir meaning to the reader—in a function call, I can’t figure out what true means. It’s\n\nclearer to provide an explicit function for the task I want to do.\n\npremiumBookConcert(aCustomer);\n\nNot all arguments like this are flag arguments. To be a flag argument, the callers must\n\nbe setting the boolean value to a literal value, not data that’s flowing through the\n\nprogram. Also, the implementation function must be using the argument to influence\n\nits control flow, not as data that it passes to further functions.\n\nRemoving flag arguments doesn’t just make the code clearer—it also helps my tooling.\n\nCode analysis tools can now more easily see the difference between calling the premium\n\nlogic and calling regular logic.\n\nFlag arguments can have a place if there’s more than one of them in the function, since\n\notherwise I would need explicit functions for every combination of their values. But\n\nthat’s also a signal of a function doing too much, and I should look for a way to create\n\nsimpler functions that I can compose for this logic.\n\nMechanics\n\nCreate an explicit function for each value of the parameter.\n\nIf the main function has a clear dispatch conditional, use Decompose Conditional\n\n(260) to create the explicit functions. Otherwise, create wrapping functions. www.EBooksWorld.ir\n\nFor each caller that uses a literal value for the parameter, replace it with a call to the\n\nexplicit function.\n\nExample\n\nLooking through some code, I see calls to calculate a delivery date for a shipment. Some\n\nof the calls look like\n\nClick here to view code image\n\naShipment.deliveryDate = deliveryDate(anOrder, true);\n\nand some look like\n\nClick here to view code image\n\naShipment.deliveryDate = deliveryDate(anOrder, false);\n\nFaced with code like this, I immediately begin to wonder about the meaning of the\n\nboolean value. What is it doing?\n\nThe body of deliveryDate looks like this:\n\nClick here to view code image\n\nfunction deliveryDate(anOrder, isRush) { if (isRush) { let deliveryTime; if ([\"MA\", \"CT\"] .includes(anOrder.deliveryState)) deliveryTime = 1; else if ([\"NY\", \"NH\"].includes(anOrder.deliveryState)) deliveryTime = 2; else deliveryTime = 3; return anOrder.placedOn.plusDays(1 + deliveryTime); } else { let deliveryTime; if ([\"MA\", \"CT\", \"NY\"].includes(anOrder.deliveryState)) deliveryTime = 2; else if ([\"ME\", \"NH\"] .includes(anOrder.deliveryState)) deliveryTime = 3; else deliveryTime = 4; return anOrder.placedOn.plusDays(2 + deliveryTime); } }\n\nHere, the caller is using a literal boolean value to determine which code should run—a\n\nwww.EBooksWorld.ir\n\nclassic flag argument. But the whole point of using a function is to follow the caller’s\n\ninstructions, so it is better to clarify the caller’s intent with explicit functions.\n\nIn this case, I can do this by using Decompose Conditional (260), which gives me this:\n\nClick here to view code image\n\nfunction deliveryDate(anOrder, isRush) { if (isRush) return rushDeliveryDate(anOrder); else return regularDeliveryDate(anOrder); } function rushDeliveryDate(anOrder) { let deliveryTime; if ([\"MA\", \"CT\"] .includes(anOrder.deliveryState)) deliveryTime = 1; else if ([\"NY\", \"NH\"].includes(anOrder.deliveryState)) deliveryTime = 2; else deliveryTime = 3; return anOrder.placedOn.plusDays(1 + deliveryTime); } function regularDeliveryDate(anOrder) { let deliveryTime; if ([\"MA\", \"CT\", \"NY\"].includes(anOrder.deliveryState)) deliveryTime = 2; else if ([\"ME\", \"NH\"] .includes(anOrder.deliveryState)) deliveryTime = 3; else deliveryTime = 4; return anOrder.placedOn.plusDays(2 + deliveryTime); }\n\nThe two new functions capture the intent of the call better, so I can replace each call of\n\nClick here to view code image\n\naShipment.deliveryDate = deliveryDate(anOrder, true);\n\nwith\n\nClick here to view code image\n\naShipment.deliveryDate = rushDeliveryDate(anOrder);\n\nand similarly with the other case.\n\nWhen I’ve replaced all the callers, I remove deliveryDate.\n\nA flag argument isn’t just the presence of a boolean value; it’s that the boolean is set\n\nwww.EBooksWorld.ir\n\nwith a literal rather than data. If all the callers of deliveryDate were like this:\n\nClick here to view code image\n\nconst isRush = determineIfRush(anOrder); aShipment.deliveryDate = deliveryDate(anOrder, isRush);\n\nthen I’d have no problem with deliveryDate’s signature (although I’d still want to\n\napply Decompose Conditional (260)).\n\nIt may be that some callers use the argument as a flag argument by setting it with a\n\nliteral, while others set the argument with data. In this case, I’d still use Remove Flag\n\nArgument, but not change the data callers and not remove deliveryDate at the end.\n\nThat way I support both interfaces for the different uses.\n\nDecomposing the conditional like this is a good way to carry out this refactoring, but it\n\nonly works if the dispatch on the parameter is the outer part of the function (or I can\n\neasily refactor it to make it so). It’s also possible that the parameter is used in a much\n\nmore tangled way, such as this alternative version of deliveryDate:\n\nClick here to view code image\n\nfunction deliveryDate(anOrder, isRush) { let result; let deliveryTime; if (anOrder.deliveryState === \"MA\" || anOrder.deliveryState === \"CT\") deliveryTime = isRush? 1 : 2; else if (anOrder.deliveryState === \"NY\" || anOrder.deliveryState === \"NH\") { deliveryTime = 2; if (anOrder.deliveryState === \"NH\" && !isRush) deliveryTime = 3; } else if (isRush) deliveryTime = 3; else if (anOrder.deliveryState === \"ME\") deliveryTime = 3; else deliveryTime = 4; result = anOrder.placedOn.plusDays(2 + deliveryTime); if (isRush) result = result.minusDays(1); return result; }\n\nIn this case, teasing out isRush into a top­level dispatch conditional is likely more www.EBooksWorld.ir\n\nwork than I fancy. So instead, I can layer functions over the deliveryDate:\n\nClick here to view code image\n\nfunction rushDeliveryDate (anOrder) {return deliveryDate(anOrder, true);} function regularDeliveryDate(anOrder) {return deliveryDate(anOrder, false);}\n\nThese wrapping functions are essentially partial applications of deliveryDate,\n\nalthough they are defined in program text rather than by composition of functions.\n\nI can then do the same replacement of callers that I did with the decomposed\n\nconditional earlier on. If there aren’t any callers using the parameter as data, I like to\n\nrestrict its visibility or rename it to a name that conveys that it shouldn’t be used\n\ndirectly (e.g., deliveryDateHelperOnly).\n\nPRESERVE WHOLE OBJECT\n\nMotivation\n\nIf I see code that derives a couple of values from a record and then passes these values\n\ninto a function, I like to replace those values with the whole record itself, letting the\n\nfunction body derive the values it needs.\n\nPassing the whole record handles change better should the called function need more\n\ndata from the whole in the future—that change would not require me to alter the\n\nparameter list. It also reduces the size of the parameter list, which usually makes the\n\nwww.EBooksWorld.ir",
      "page_number": 347
    },
    {
      "number": 37,
      "title": "Segment 37 (pages 357-365)",
      "start_page": 357,
      "end_page": 365,
      "detection_method": "topic_boundary",
      "content": "function call easier to understand. If many functions are called with the parts, they\n\noften duplicate the logic that manipulates these parts—logic that can often be moved to\n\nthe whole.\n\nThe main reason I wouldn’t do this is if I don’t want the called function to have a\n\ndependency on the whole—which typically occurs when they are in different modules.\n\nPulling several values from an object to do some logic on them alone is a smell (Feature\n\nEnvy (77)), and usually a signal that this logic should be moved into the whole itself.\n\nPreserve Whole Object is particularly common after I’ve done Introduce Parameter\n\nObject (140), as I hunt down any occurrences of the original data clump to replace them\n\nwith the new object.\n\nIf several bits of code only use the same subset of an object’s features, then that may\n\nindicate a good opportunity for Extract Class (182).\n\nOne case that many people miss is when an object calls another object with several of\n\nits own data values. If I see this, I can replace those values with a self­reference (this\n\nin JavaScript).\n\nMechanics\n\nCreate an empty function with the desired parameters.\n\nGive the function an easily searchable name so it can be replaced at the end.\n\nFill the body of the new function with a call to the old function, mapping from the\n\nnew parameters to the old ones.\n\nRun static checks.\n\nAdjust each caller to use the new function, testing after each change.\n\nThis may mean that some code that derives the parameter isn’t needed, so can fall\n\nto Remove Dead Code (237).\n\nOnce all original callers have been changed, use Inline Function (115) on the original\n\nfunction.\n\nChange the name of the new function and all its callers.\n\nExample\n\nwww.EBooksWorld.ir\n\nConsider a room monitoring system. It compares its daily temperature range with a\n\nrange in a predefined heating plan.\n\ncaller…\n\nClick here to view code image\n\nconst low = aRoom.daysTempRange.low; const high = aRoom.daysTempRange.high; if (!aPlan.withinRange(low, high)) alerts.push(\"room temperature went outside range\");\n\nclass HeatingPlan…\n\nClick here to view code image\n\nwithinRange(bottom, top) { return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRange.high); }\n\nInstead of unpacking the range information when I pass it in, I can pass in the whole\n\nrange object.\n\nI begin by stating the interface I want as an empty function.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nxxNEWwithinRange(aNumberRange) { }\n\nSince I intend it to replace the existing withinRange, I name it the same but with an\n\neasily replaceable prefix.\n\nI then add the body of the function, which relies on calling the existing withinRange.\n\nThe body thus consists of a mapping from the new parameter to the existing ones.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nxxNEWwithinRange(aNumberRange) { return this.withinRange(aNumberRange.low, aNumberRange.high); }\n\nNow I can begin the serious work, taking the existing function calls and having them\n\ncall the new function.\n\ncaller…\n\nClick here to view code image\n\nconst low = aRoom.daysTempRange.low; const high = aRoom.daysTempRange.high; if (!aPlan.xxNEWwithinRange(aRoom.daysTempRange)) alerts.push(\"room temperature went outside range\");\n\nWhen I’ve changed the calls, I may see that some of the earlier code isn’t needed\n\nanymore, so I wield Remove Dead Code (237).\n\ncaller…\n\nClick here to view code image\n\nconst low = aRoom.daysTempRange.low; const high = aRoom.daysTempRange.high; if (!aPlan.xxNEWwithinRange(aRoom.daysTempRange)) alerts.push(\"room temperature went outside range\");\n\nI replace these one at a time, testing after each change.\n\nOnce I’ve replaced them all, I can use Inline Function (115) on the original function.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nxxNEWwithinRange(aNumberRange) { return (aNumberRange.low >= this._temperatureRange.low) && (aNumberRange.high <= this._temperatureRange.high); }\n\nAnd I finally remove that ugly prefix from the new function and all its callers. The prefix\n\nwww.EBooksWorld.ir\n\nmakes it a simple global replace, even if I don’t have a robust rename support in my\n\neditor.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nwithinRange(aNumberRange) { return (aNumberRange.low >= this._temperatureRange.low) && (aNumberRange.high <= this._temperatureRange.high); }\n\ncaller…\n\nClick here to view code image\n\nif (!aPlan.withinRange(aRoom.daysTempRange)) alerts.push(\"room temperature went outside range\");\n\nExample: A Variation to Create the New Function\n\nIn the above example, I wrote the code for the new function directly. Most of the time,\n\nthat’s pretty simple and the easiest way to go. But there is a variation on this that’s\n\noccasionally useful—which can allow me to compose the new function entirely from\n\nrefactorings.\n\nI start with a caller of the existing function.\n\ncaller…\n\nClick here to view code image\n\nconst low = aRoom.daysTempRange.low; const high = aRoom.daysTempRange.high; if (!aPlan.withinRange(low, high)) alerts.push(\"room temperature went outside range\");\n\nI want to rearrange the code so I can create the new function by using Extract Function\n\n(106) on some existing code. The caller code isn’t quite there yet, but I can get there by\n\nusing Extract Variable (119) a few times. First, I disentangle the call to the old function\n\nfrom the conditional.\n\nwww.EBooksWorld.ir\n\ncaller…\n\nClick here to view code image\n\nconst low = aRoom.daysTempRange.low; const high = aRoom.daysTempRange.high; const isWithinRange = aPlan.withinRange(low, high); if (!isWithinRange) alerts.push(\"room temperature went outside range\");\n\nI then extract the input parameter.\n\ncaller…\n\nClick here to view code image\n\nconst tempRange = aRoom.daysTempRange; const low = tempRange.low; const high = tempRange.high; const isWithinRange = aPlan.withinRange(low, high); if (!isWithinRange) alerts.push(\"room temperature went outside range\");\n\nWith that done, I can now use Extract Function (106) to create the new function.\n\ncaller…\n\nClick here to view code image\n\nconst tempRange = aRoom.daysTempRange; const isWithinRange = xxNEWwithinRange(aPlan, tempRange); if (!isWithinRange) alerts.push(\"room temperature went outside range\");\n\ntop level…\n\nClick here to view code image\n\nfunction xxNEWwithinRange(aPlan, tempRange) { const low = tempRange.low; const high = tempRange.high; const isWithinRange = aPlan.withinRange(low, high); return isWithinRange; }\n\nwww.EBooksWorld.ir\n\nSince the original function is in a different context (the HeatingPlan class), I need to\n\nuse Move Function (198).\n\ncaller…\n\nClick here to view code image\n\nconst tempRange = aRoom.daysTempRange; const isWithinRange = aPlan.xxNEWwithinRange(tempRange); if (!isWithinRange) alerts.push(\"room temperature went outside range\");\n\nclass HeatingPlan…\n\nClick here to view code image\n\nxxNEWwithinRange(tempRange) { const low = tempRange.low; const high = tempRange.high; const isWithinRange = this.withinRange(low, high); return isWithinRange; }\n\nI then continue as before, replacing other callers and inlining the old function into the\n\nnew one. I would also inline the variables I extracted to provide the clean separation for\n\nextracting the new function.\n\nBecause this variation is entirely composed of refactorings, it’s particularly handy when\n\nI have a refactoring tool with robust extract and inline operations.\n\nREPLACE PARAMETER WITH QUERY\n\nformerly: Replace Parameter with Method\n\ninverse of: Replace Query with Parameter (327)\n\nwww.EBooksWorld.ir\n\nMotivation\n\nThe parameter list to a function should summarize the points of variability of that\n\nfunction, indicating the primary ways in which that function may behave differently. As\n\nwith any statement in code, it’s good to avoid any duplication, and it’s easier to\n\nunderstand if the parameter list is short.\n\nIf a call passes in a value that the function can just as easily determine for itself, that’s a\n\nform of duplication—one that unnecessarily complicates the caller which has to\n\ndetermine the value of a parameter when it could be freed from that work.\n\nThe limit on this is suggested by the phrase “just as easily.” By removing the parameter,\n\nI’m shifting the responsibility for determining the parameter value. When the\n\nparameter is present, determining its value is the caller’s responsibility; otherwise, that\n\nresponsibility shifts to the function body. My usual habit is to simplify life for callers,\n\nwhich implies moving responsibility to the function body—but only if that\n\nresponsibility is appropriate there.\n\nThe most common reason to avoid Replace Parameter with Query is if removing the\n\nparameter adds an unwanted dependency to the function body—forcing it to access a\n\nprogram element that I’d rather it remained ignorant of. This may be a new\n\ndependency, or an existing one that I’d like to remove. Usually this comes up where I’d\n\nneed to add a problematic function call to the function body, or access something\n\nwithin a receiver object that I’d prefer to move out later.\n\nThe safest case for Replace Parameter with Query is when the value of the parameter I\n\nwww.EBooksWorld.ir\n\nwant to remove is determined merely by querying another parameter in the list. There’s\n\nrarely any point in passing two parameters if one can be determined from the other.\n\nOne thing to watch out for is if the function I’m looking at has referential transparency\n\n—that is, if I can be sure that it will behave the same way whenever it’s called with the\n\nsame parameter values. Such functions are much easier to reason about and test, and I\n\ndon’t want to alter them to lose that property. So I wouldn’t replace a parameter with\n\nan access to a mutable global variable.\n\nMechanics\n\nIf necessary, use Extract Function (106) on the calculation of the parameter.\n\nReplace references to the parameter in the function body with references to the\n\nexpression that yields the parameter. Test after each change.\n\nUse Change Function Declaration (124) to remove the parameter.\n\nExample\n\nI most often use Replace Parameter with Query when I’ve done some other refactorings\n\nthat make a parameter no longer needed. Consider this code.\n\nclass Order…\n\nClick here to view code image\n\nget finalPrice() { const basePrice = this.quantity * this.itemPrice; let discountLevel; if (this.quantity > 100) discountLevel = 2; else discountLevel = 1; return this.discountedPrice(basePrice, discountLevel); }\n\ndiscountedPrice(basePrice, discountLevel) { switch (discountLevel) { case 1: return basePrice * 0.95; case 2: return basePrice * 0.9; } }\n\nWhen I’m simplifying a function, I’m keen to apply Replace Temp with Query (178),\n\nwhich would lead me to\n\nwww.EBooksWorld.ir\n\nclass Order…\n\nClick here to view code image\n\nget finalPrice() { const basePrice = this.quantity * this.itemPrice; return this.discountedPrice(basePrice, this.discountLevel); }\n\nget discountLevel() { return (this.quantity > 100) ? 2 : 1; }\n\nOnce I’ve done this, there’s no need to pass the result of discountLevel to\n\ndiscountedPrice—it can just as easily make the call itself.\n\nI replace any reference to the parameter with a call to the method instead.\n\nclass Order…\n\nClick here to view code image\n\ndiscountedPrice(basePrice, discountLevel) { switch (this.discountLevel) { case 1: return basePrice * 0.95; case 2: return basePrice * 0.9; } }\n\nI can then use Change Function Declaration (124) to remove the parameter.\n\nclass Order…\n\nClick here to view code image\n\nget finalPrice() { const basePrice = this.quantity * this.itemPrice; return this.discountedPrice(basePrice, this.discountLevel); }\n\ndiscountedPrice(basePrice, discountLevel) { switch (this.discountLevel) { case 1: return basePrice * 0.95; case 2: return basePrice * 0.9; } }\n\nwww.EBooksWorld.ir",
      "page_number": 357
    },
    {
      "number": 38,
      "title": "Segment 38 (pages 366-373)",
      "start_page": 366,
      "end_page": 373,
      "detection_method": "topic_boundary",
      "content": "REPLACE QUERY WITH PARAMETER\n\ninverse of: Replace Parameter with Query (324)\n\nMotivation\n\nWhen looking through a function’s body, I sometimes see references to something in\n\nthe function’s scope that I’m not happy with. This might be a reference to a global\n\nvariable, or to an element in the same module that I intend to move away. To resolve\n\nthis, I need to replace the internal reference with a parameter, shifting the\n\nresponsibility of resolving the reference to the caller of the function.\n\nMost of these cases are due to my wish to alter the dependency relationships in the code\n\n—to make the target function no longer dependent on the element I want to\n\nparameterize. There’s a tension here between converting everything to parameters,\n\nwhich results in long repetitive parameter lists, and sharing a lot of scope which can\n\nlead to a lot of coupling between functions. Like most tricky decisions, it’s not\n\nsomething I can reliably get right, so it’s important that I can reliably change things so\n\nthe program can take advantage of my increasing understanding.\n\nIt’s easier to reason about a function that will always give the same result when called\n\nwith same parameter values—this is called referential transparency. If a function\n\naccesses some element in its scope that isn’t referentially transparent, then the\n\nwww.EBooksWorld.ir\n\ncontaining function also lacks referential transparency. I can fix that by moving that\n\nelement to a parameter. Although such a move will shift responsibility to the caller,\n\nthere is often a lot to be gained by creating clear modules with referential transparency.\n\nA common pattern is to have modules consisting of pure functions which are wrapped\n\nby logic that handles the I/O and other variable elements of a program. I can use\n\nReplace Query with Parameter to purify parts of a program, making those parts easier\n\nto test and reason about.\n\nBut Replace Query with Parameter isn’t just a bag of benefits. By moving a query to a\n\nparameter, I force my caller to figure out how to provide this value. This complicates\n\nlife for callers of the functions, and my usual bias is to design interfaces that make life\n\neasier for their consumers. In the end, it boils down to allocation of responsibility\n\naround the program, and that’s a decision that’s neither easy nor immutable—which is\n\nwhy this refactoring (and its inverse) is one that I need to be very familiar with.\n\nMechanics\n\nUse Extract Variable (119) on the query code to separate it from the rest of the\n\nfunction body.\n\nApply Extract Function (106) to the body code that isn’t the call to the query.\n\nGive the new function an easily searchable name, for later renaming.\n\nUse Inline Variable (123) to get rid of the variable you just created.\n\nApply Inline Function (115) to the original function.\n\nRename the new function to that of the original.\n\nExample\n\nConsider a simple, yet annoying, control system for temperature. It allows the user to\n\nselect a temperature on a thermostat—but only sets the target temperature within a\n\nrange determined by a heating plan.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nget targetTemperature() { if (thermostat.selectedTemperature > this._max) return this._max;\n\nwww.EBooksWorld.ir\n\nelse if (thermostat.selectedTemperature < this._min) return this._min; else return thermostat.selectedTemperature; }\n\ncaller…\n\nClick here to view code image\n\nif (thePlan.targetTemperature > thermostat.currentTemperature) setToHeat(); else if (thePlan.targetTemperature < thermostat.currentTemperature) setToCool(); else setOff();\n\nAs a user of such a system, I might be annoyed to have my desires overridden by the\n\nheating plan rules, but as a programmer I might be more concerned about how the\n\ntargetTemperature function has a dependency on a global thermostat object. I can\n\nbreak this dependency by moving it to a parameter.\n\nMy first step is to use Extract Variable (119) on the parameter that I want to have in my\n\nfunction.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nget targetTemperature() { const selectedTemperature = thermostat.selectedTemperature; if (selectedTemperature > this._max) return this._max; else if (selectedTemperature < this._min) return this._min; else return selectedTemperature; }\n\nThat makes it easy to apply Extract Function (106) on the entire body of the function\n\nexcept for the bit that figures out the parameter.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nget targetTemperature() { const selectedTemperature = thermostat.selectedTemperature; return this.xxNEWtargetTemperature(selectedTemperature); }\n\nwww.EBooksWorld.ir\n\nxxNEWtargetTemperature(selectedTemperature) { if (selectedTemperature > this._max) return this._max; else if (selectedTemperature < this._min) return this._min; else return selectedTemperature; }\n\nI then inline the variable I just extracted, which leaves the function as a simple call.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nget targetTemperature() { return this.xxNEWtargetTemperature(thermostat.selectedTemperature); }\n\nI can now use Inline Function (115) on this method.\n\ncaller…\n\nClick here to view code image\n\nif (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) > thermostat.currentTemperature) setToHeat(); else if (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) < thermostat.currentTemperature) setToCool(); else setOff();\n\nI take advantage of the easily searchable name of the new function to rename it by\n\nremoving the prefix.\n\ncaller…\n\nClick here to view code image\n\nif (thePlan.targetTemperature(thermostat.selectedTemperature) > thermostat.currentTemperature) setToHeat(); else if (thePlan.targetTemperature(thermostat.selectedTemperature) < thermostat.currentTemperature) www.EBooksWorld.ir\n\nsetToCool(); else setOff();\n\nclass HeatingPlan…\n\nClick here to view code image\n\ntargetTemperature(selectedTemperature) { if (selectedTemperature > this._max) return this._max; else if (selectedTemperature < this._min) return this._min; else return selectedTemperature; }\n\nAs is often the case with this refactoring, the calling code looks more unwieldy than\n\nbefore. Moving a dependency out of a module pushes the responsibility of dealing with\n\nthat dependency back to the caller. That’s the trade­off for the reduced coupling.\n\nBut removing the coupling to the thermostat object isn’t the only gain I’ve made with\n\nthis refactoring. The HeatingPlan class is immutable—its fields are set in the\n\nconstructor with no methods to alter them. (I’ll save you the effort of looking at the\n\nwhole class; just trust me on this.) Given an immutable heating plan, by moving the\n\nthermostat reference out of the function body I’ve also made targetTemperature\n\nreferentially transparent. Every time I call targetTemperature on the same object,\n\nwith the same argument, I will get the same result. If all the methods of the heating\n\nplan have referential transparency, that makes this class much easier to test and reason\n\nabout.\n\nA problem with JavaScript’s class model is that it’s impossible to enforce an immutable\n\nclass—there’s always a way to get at an object’s data. But writing a class to signal and\n\nencourage immutability is often good enough. Creating classes that have this\n\ncharacteristic is often a sound strategy and Replace Query with Parameter is a handy\n\ntool for doing this.\n\nREMOVE SETTING METHOD\n\nwww.EBooksWorld.ir\n\nMotivation\n\nProviding a setting method indicates that a field may be changed. If I don’t want that\n\nfield to change once the object is created, I don’t provide a setting method (and make\n\nthe field immutable). That way, the field is set only in the constructor, my intention to\n\nhave it not change is clear, and I usually remove the very possibility that the field will\n\nchange.\n\nThere’s a couple of common cases where this comes up. One is where people always use\n\naccessor methods to manipulate a field, even within constructors. This leads to the only\n\ncall to a setting method being from the constructor. I prefer to remove the setting\n\nmethod to make it clear that updates make no sense after construction.\n\nAnother case is where the object is created by clients using creation script rather than\n\nby a simple constructor call. Such a creation script starts with the constructor call\n\nfollowed by a sequence of setter method calls to create the new object. Once the script is\n\nfinished, we don’t expect the new object to change some (or even all) of its fields. The\n\nsetters are only expected to be called during this initial creation. In this case, I’d get rid\n\nof them to make my intentions clearer.\n\nMechanics\n\nIf the value that’s being set isn’t provided to the constructor, use Change Function\n\nDeclaration (124) to add it. Add a call to the setting method within the constructor.\n\nIf you wish to remove several setting methods, add all their values to the\n\nconstructor at once. This simplifies the later steps.\n\nwww.EBooksWorld.ir\n\nRemove each call of a setting method outside of the constructor, using the new\n\nconstructor value instead. Test after each one.\n\nIf you can’t replace the call to the setter by creating a new object (because you are\n\nupdating a shared reference object), abandon the refactoring.\n\nUse Inline Function (115) on the setting method. Make the field immutable if\n\npossible.\n\nTest.\n\nExample\n\nI have a simple person class.\n\nclass Person…\n\nClick here to view code image\n\nget name() {return this._name;} set name(arg) {this._name = arg;} get id() {return this._id;} set id(arg) {this._id = arg;}\n\nAt the moment, I create a new object with code like this:\n\nconst martin = new Person(); martin.name = \"martin\"; martin.id = \"1234\";\n\nThe name of a person may change after it’s created, but the ID does not. To make this\n\nclear, I want to remove the setting method for ID.\n\nI still need to set the ID initially, so I’ll use Change Function Declaration (124) to add it\n\nto the constructor.\n\nclass Person…\n\nconstructor(id) { this.id = id; }\n\nwww.EBooksWorld.ir\n\nI then adjust the creation script to set the ID via the constructor.\n\nClick here to view code image\n\nconst martin = new Person(\"1234\"); martin.name = \"martin\"; martin.id = \"1234\";\n\nI do this in each place I create a person, testing after each change.\n\nWhen they are all done, I can apply Inline Function (115) to the setting method.\n\nclass Person…\n\nClick here to view code image\n\nconstructor(id) { this._id = id; } get name() {return this._name;} set name(arg) {this._name = arg;} get id() {return this._id;} set id(arg) {this._id = arg;}\n\nREPLACE CONSTRUCTOR WITH FACTORY FUNCTION\n\nformerly: Replace Constructor with Factory Method\n\nMotivation\n\nMany object­oriented languages have a special constructor function that’s called to www.EBooksWorld.ir",
      "page_number": 366
    },
    {
      "number": 39,
      "title": "Segment 39 (pages 374-388)",
      "start_page": 374,
      "end_page": 388,
      "detection_method": "topic_boundary",
      "content": "initialize an object. Clients typically call this constructor when they want to create a new\n\nobject. But these constructors often come with awkward limitations that aren’t there for\n\nmore general functions. A Java constructor must return an instance of the class it was\n\ncalled with, which means I can’t replace it with a subclass or proxy depending on the\n\nenvironment or parameters. Constructor naming is fixed, which makes it impossible for\n\nme to use a name that is clearer than the default. Constructors often require a special\n\noperator to invoke (“new” in many languages) which makes them difficult to use in\n\ncontexts that expect normal functions.\n\nA factory function suffers from no such limitations. It will likely call the constructor as\n\npart of its implementation, but I can freely substitute something else.\n\nMechanics\n\nCreate a factory function, its body being a call to the constructor.\n\nReplace each call to the constructor with a call to the factory function.\n\nTest after each change.\n\nLimit the constructor’s visibility as much as possible.\n\nExample\n\nA quick but wearisome example uses kinds of employees. Consider an employee class:\n\nclass Employee…\n\nClick here to view code image\n\nconstructor (name, typeCode) { this._name = name; this._typeCode = typeCode; } get name() {return this._name;} get type() { return Employee.legalTypeCodes[this._typeCode]; } static get legalTypeCodes() { return {\"E\": \"Engineer\", \"M\": \"Manager\", \"S\": \"Salesman\"}; }\n\nThis is used from\n\nwww.EBooksWorld.ir\n\ncaller…\n\nClick here to view code image\n\ncandidate = new Employee(document.name, document.empType);\n\nand\n\ncaller…\n\nClick here to view code image\n\nconst leadEngineer = new Employee(document.leadEngineer, 'E');\n\nMy first step is to create the factory function. Its body is a simple delegation to the\n\nconstructor.\n\ntop level…\n\nClick here to view code image\n\nfunction createEmployee(name, typeCode) { return new Employee(name, typeCode); }\n\nI then find the callers of the constructor and change them, one at a time, to use the\n\nfactory function instead.\n\nThe first one is obvious:\n\ncaller…\n\nClick here to view code image\n\ncandidate = createEmployee(document.name, document.empType);\n\nWith the second case, I could use the new factory function like this:\n\ncaller…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nconst leadEngineer = createEmployee(document.leadEngineer, 'E');\n\nBut I don’t like using the type code here—it’s generally a bad smell to pass a code as a\n\nliteral string. So I prefer to create a new factory function that embeds the kind of\n\nemployee I want into its name.\n\ncaller…\n\nClick here to view code image\n\nconst leadEngineer = createEngineer(document.leadEngineer);\n\ntop level…\n\nClick here to view code image\n\nfunction createEngineer(name) { return new Employee(name, 'E'); }\n\nREPLACE FUNCTION WITH COMMAND\n\nformerly: Replace Method with Method Object\n\ninverse of: Replace Command with Function (344)\n\nwww.EBooksWorld.ir\n\nMotivation\n\nFunctions—either freestanding or attached to objects as methods—are one of the\n\nfundamental building blocks of programming. But there are times when it’s useful to\n\nencapsulate a function into its own object, which I refer to as a “command object” or\n\nsimply a command. Such an object is mostly built around a single method, whose\n\nrequest and execution is the purpose of the object.\n\nA command offers a greater flexibility for the control and expression of a function than\n\nthe plain function mechanism. Commands can have complimentary operations, such as\n\nundo. I can provide methods to build up their parameters to support a richer lifecycle. I\n\ncan build in customizations using inheritance and hooks. If I’m working in a language\n\nwith objects but without first­class functions, I can provide much of that capability by\n\nusing commands instead. Similarly, I can use methods and fields to help break down a\n\ncomplex function, even in a language that lacks nested functions, and I can call those\n\nmethods directly while testing and debugging.\n\nAll these are good reasons to use commands, and I need to be ready to refactor\n\nwww.EBooksWorld.ir\n\nfunctions into commands when I need to. But we must not forget that this flexibility, as\n\never, comes at a price paid in complexity. So, given the choice between a first­class\n\nfunction and a command, I’ll pick the function 95% of the time. I only use a command\n\nwhen I specifically need a facility that simpler approaches can’t provide.\n\nLike many words in software development, “command” is rather overloaded. In the\n\ncontext I’m using it here, it is an object that encapsulates a request, following the\n\ncommand pattern in Design Patterns [gof]. When I use “command” in this sense, I use\n\n“command object” to set the context, and “command” afterwards. The word\n\n“command” is also used in the command­query separation principle [mf­cqs], where a\n\ncommand is an object method that changes observable state. I’ve always tried to avoid\n\nusing command in that sense, preferring “modifier” or “mutator.”\n\nMechanics\n\nCreate an empty class for the function. Name it based on the function.\n\nUse Move Function (198) to move the function to the empty class.\n\nKeep the original function as a forwarding function until at least the end of the\n\nrefactoring.\n\nFollow any convention the language has for naming commands. If there is no\n\nconvention, choose a generic name for the command’s execute function, such as\n\n“execute” or “call”.\n\nConsider making a field for each argument, and move these arguments to the\n\nconstructor.\n\nExample\n\nThe JavaScript language has many faults, but one of its great decisions was to make\n\nfunctions first­class entities. I thus don’t have to go through all the hoops of creating\n\ncommands for common tasks that I need to do in languages without this facility. But\n\nthere are still times when a command is the right tool for the job.\n\nOne of these cases is breaking up a complex function so I can better understand and\n\nmodify it. To really show the value of this refactoring, I need a long and complicated\n\nfunction—but that would take too long to write, let alone for you to read. Instead, I’ll go\n\nwith a function that’s short enough not to need it. This one scores points for an\n\ninsurance application:\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction score(candidate, medicalExam, scoringGuide) { let result = 0; let healthLevel = 0; let highMedicalRiskFlag = false;\n\nif (medicalExam.isSmoker) { healthLevel += 10; highMedicalRiskFlag = true; } let certificationGrade = \"regular\"; if (scoringGuide.stateWithLowCertification(candidate.originState)) { certificationGrade = \"low\"; result ­= 5; } // lots more code like this result ­= Math.max(healthLevel ­ 5, 0); return result; }\n\nI begin by creating an empty class and then Move Function (198) to move the function\n\ninto it.\n\nClick here to view code image\n\nfunction score(candidate, medicalExam, scoringGuide) { return new Scorer().execute(candidate, medicalExam, scoringGuide); } class Scorer { execute (candidate, medicalExam, scoringGuide) { let result = 0; let healthLevel = 0; let highMedicalRiskFlag = false;\n\nif (medicalExam.isSmoker) { healthLevel += 10; highMedicalRiskFlag = true; } let certificationGrade = \"regular\"; if (scoringGuide.stateWithLowCertification(candidate.originState)) { certificationGrade = \"low\"; result ­= 5; } // lots more code like this result ­= Math.max(healthLevel ­ 5, 0); return result; } }\n\nwww.EBooksWorld.ir\n\nMost of the time, I prefer to pass arguments to a command on the constructor and have\n\nthe execute method take no parameters. While this matters less for a simple\n\ndecomposition scenario like this, it’s very handy when I want to manipulate the\n\ncommand with a more complicated parameter setting lifecycle or customizations.\n\nDifferent command classes can have different parameters but be mixed together when\n\nqueued for execution.\n\nI can do these parameters one at a time.\n\nClick here to view code image\n\nfunction score(candidate, medicalExam, scoringGuide) { return new Scorer(candidate).execute(candidate, medicalExam, scoringGuide); }\n\nclass Scorer…\n\nClick here to view code image\n\nconstructor(candidate){ this._candidate = candidate; }\n\nexecute (candidate, medicalExam, scoringGuide) { let result = 0; let healthLevel = 0; let highMedicalRiskFlag = false;\n\nif (medicalExam.isSmoker) { healthLevel += 10; highMedicalRiskFlag = true; } let certificationGrade = \"regular\"; if (scoringGuide.stateWithLowCertification(this._candidate.originState)) { certificationGrade = \"low\"; result ­= 5; } // lots more code like this result ­= Math.max(healthLevel ­ 5, 0); return result; }\n\nI continue with the other parameters\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nfunction score(candidate, medicalExam, scoringGuide) { return new Scorer(candidate, medicalExam, scoringGuide).execute(); }\n\nclass Scorer…\n\nClick here to view code image\n\nconstructor(candidate, medicalExam, scoringGuide){ this._candidate = candidate; this._medicalExam = medicalExam; this._scoringGuide = scoringGuide; }\n\nexecute () { let result = 0; let healthLevel = 0; let highMedicalRiskFlag = false;\n\nif (this._medicalExam.isSmoker) { healthLevel += 10; highMedicalRiskFlag = true; } let certificationGrade = \"regular\"; if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) { certificationGrade = \"low\"; result ­= 5; } // lots more code like this result ­= Math.max(healthLevel ­ 5, 0); return result; }\n\nThat completes Replace Function with Command, but the whole point of doing this\n\nrefactoring is to allow me to break down the complicated functions—so let me outline\n\nsome steps to achieve that. My next move here is to change all the local variables into\n\nfields. Again, I do these one at a time.\n\nclass Scorer…\n\nClick here to view code image\n\nconstructor(candidate, medicalExam, scoringGuide){\n\nwww.EBooksWorld.ir\n\nthis._candidate = candidate; this._medicalExam = medicalExam; this._scoringGuide = scoringGuide; }\n\nexecute () { this._result = 0; let healthLevel = 0; let highMedicalRiskFlag = false;\n\nif (this._medicalExam.isSmoker) { healthLevel += 10; highMedicalRiskFlag = true; } let certificationGrade = \"regular\"; if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) { certificationGrade = \"low\"; this._result ­= 5; } // lots more code like this this._result ­= Math.max(healthLevel ­ 5, 0); return this._result; }\n\nI repeat this for all the local variables. (This is one of those refactorings that I felt was\n\nsufficiently simple that I haven’t given it an entry in the catalog. I feel slightly guilty\n\nabout this.)\n\nclass Scorer…\n\nClick here to view code image\n\nconstructor(candidate, medicalExam, scoringGuide){ this._candidate = candidate; this._medicalExam = medicalExam; this._scoringGuide = scoringGuide; }\n\nexecute () { this._result = 0; this._healthLevel = 0; this._highMedicalRiskFlag = false;\n\nif (this._medicalExam.isSmoker) { this._healthLevel += 10; this._highMedicalRiskFlag = true; } this._certificationGrade = \"regular\"; if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {\n\nwww.EBooksWorld.ir\n\nthis._certificationGrade = \"low\"; this._result ­= 5; } // lots more code like this this._result ­= Math.max(this._healthLevel ­ 5, 0); return this._result; }\n\nNow I’ve moved all the function’s state to the command object, I can use refactorings\n\nlike Extract Function (106) without getting tangled up in all the variables and their\n\nscopes.\n\nclass Scorer…\n\nClick here to view code image\n\nexecute () { this._result = 0; this._healthLevel = 0; this._highMedicalRiskFlag = false;\n\nthis.scoreSmoking(); this._certificationGrade = \"regular\"; if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) { this._certificationGrade = \"low\"; this._result ­= 5; } // lots more code like this this._result ­= Math.max(this._healthLevel ­ 5, 0); return this._result; }\n\nscoreSmoking() { if (this._medicalExam.isSmoker) { this._healthLevel += 10; this._highMedicalRiskFlag = true; } }\n\nThis allows me to treat the command similarly to how I’d deal with a nested function.\n\nIndeed, when doing this refactoring in JavaScript, using nested functions would be a\n\nreasonable alternative to using a command. I’d still use a command for this, partly\n\nbecause I’m more familiar with commands and partly because with a command I can\n\nwrite tests and debugging calls against the subfunctions.\n\nwww.EBooksWorld.ir\n\nREPLACE COMMAND WITH FUNCTION\n\nREPLACE COMMAND WITH FUNCTION\n\ninverse of: Replace Function with Command (337)\n\nMotivation\n\nCommand objects provide a powerful mechanism for handling complex computations.\n\nThey can easily be broken down into separate methods sharing common state through\n\nthe fields; they can be invoked via different methods for different effects; they can have\n\ntheir data built up in stages. But that power comes at a cost. Most of the time, I just\n\nwant to invoke a function and have it do its thing. If that’s the case, and the function\n\nisn’t too complex, then a command object is more trouble than its worth and should be\n\nturned into a regular function.\n\nMechanics\n\nApply Extract Function (106) to the creation of the command and the call to the\n\ncommand’s execution method.\n\nThis creates the new function that will replace the command in due course.\n\nFor each method called by the command’s execution method, apply Inline Function\n\n(115).\n\nwww.EBooksWorld.ir\n\nIf the supporting function returns a value, use Extract Variable (119) on the call\n\nfirst and then Inline Function (115).\n\nUse Change Function Declaration (124) to put all the parameters of the constructor\n\ninto the command’s execution method instead.\n\nFor each field, alter the references in the command’s execution method to use the\n\nparameter instead. Test after each change.\n\nInline the constructor call and command’s execution method call into the caller\n\n(which is the replacement function).\n\nTest.\n\nApply Remove Dead Code (237) to the command class.\n\nExample\n\nI’ll begin with this small command object:\n\nClick here to view code image\n\nclass ChargeCalculator { constructor (customer, usage, provider){ this._customer = customer; this._usage = usage; this._provider = provider; } get baseCharge() { return this._customer.baseRate * this._usage; } get charge() { return this.baseCharge + this._provider.connectionCharge; } }\n\nIt is used by code like this:\n\ncaller…\n\nClick here to view code image\n\nmonthCharge = new ChargeCalculator(customer, usage, provider).charge;\n\nwww.EBooksWorld.ir\n\nThe command class is small and simple enough to be better off as a function.\n\nI begin by using Extract Function (106) to wrap the class creation and invocation.\n\ncaller…\n\nClick here to view code image\n\nmonthCharge = charge(customer, usage, provider);\n\ntop level…\n\nClick here to view code image\n\nfunction charge(customer, usage, provider) { return new ChargeCalculator(customer, usage, provider).charge; }\n\nI have to decide how to deal with any supporting functions, in this case baseCharge.\n\nMy usual approach for a function that returns a value is to first Extract Variable (119)\n\non that value.\n\nclass ChargeCalculator…\n\nClick here to view code image\n\nget baseCharge() { return this._customer.baseRate * this._usage; } get charge() { const baseCharge = this.baseCharge; return baseCharge + this._provider.connectionCharge; }\n\nThen, I use Inline Function (115) on the supporting function.\n\nclass ChargeCalculator…\n\nClick here to view code image\n\nget charge() { const baseCharge = this._customer.baseRate * this._usage; return baseCharge + this._provider.connectionCharge;\n\nwww.EBooksWorld.ir\n\n}\n\nI now have all the processing in a single function, so my next step is to move the data\n\npassed to the constructor to the main method. I first use Change Function Declaration\n\n(124) to add all the constructor parameters to the charge method.\n\nclass ChargeCalculator…\n\nClick here to view code image\n\nconstructor (customer, usage, provider){ this._customer = customer; this._usage = usage; this._provider = provider; }\n\ncharge(customer, usage, provider) { const baseCharge = this._customer.baseRate * this._usage; return baseCharge + this._provider.connectionCharge; }\n\ntop level…\n\nClick here to view code image\n\nfunction charge(customer, usage, provider) { return new ChargeCalculator(customer, usage, provider) .charge(customer, usage, provider); }\n\nNow I can alter the body of charge to use the passed parameters instead. I can do this\n\none at a time.\n\nclass ChargeCalculator…\n\nClick here to view code image\n\nconstructor (customer, usage, provider){ this._customer = customer; this._usage = usage; this._provider = provider; }\n\ncharge(customer, usage, provider) { const baseCharge = customer.baseRate * this._usage;\n\nwww.EBooksWorld.ir\n\nreturn baseCharge + this._provider.connectionCharge; }\n\nI don’t have to remove the assignment to this._customer in the constructor, as it\n\nwill just be ignored. But I prefer to do it since that will make a test fail if I miss\n\nchanging a use of field to the parameter. (And if a test doesn’t fail, I should consider\n\nadding a new test.)\n\nI repeat this for the other parameters, ending up with\n\nclass ChargeCalculator…\n\nClick here to view code image\n\ncharge(customer, usage, provider) { const baseCharge = customer.baseRate * usage; return baseCharge + provider.connectionCharge; }\n\nOnce I’ve done all of these, I can inline into the top­level charge function. This is a\n\nspecial kind of Inline Function (115), as it’s inlining both the constructor and method\n\ncall together.\n\ntop level…\n\nClick here to view code image\n\nfunction charge(customer, usage, provider) { const baseCharge = customer.baseRate * usage; return baseCharge + provider.connectionCharge; }\n\nThe command class is now dead code, so I’ll use Remove Dead Code (237) to give it an\n\nhonorable burial.\n\nwww.EBooksWorld.ir",
      "page_number": 374
    },
    {
      "number": 40,
      "title": "Segment 40 (pages 389-397)",
      "start_page": 389,
      "end_page": 397,
      "detection_method": "topic_boundary",
      "content": "Chapter 12 Dealing with Inheritance\n\nHistory\n\nTopics\n\nIn this final chapter, I’ll turn to one of the best known features of object­oriented\n\nprogramming: inheritance. Like any powerful mechanism, it is both very useful and\n\nTutorials\n\neasy to misuse, and it’s often hard to see the misuse until it’s in the rear­view mirror.\n\nOffers & Deals\n\nOften, features need to move up or down the inheritance hierarchy. Several refactorings\n\ndeal with that: Pull Up Method (350), Pull Up Field (353), Pull Up Constructor Body\n\nHighlights\n\n(355), Push Down Method (359), and Push Down Field (361). I can add and remove\n\nclasses from the hierarchy with Extract Superclass (375), Remove Subclass (369), and\n\nSettings\n\nCollapse Hierarchy (380). I may want to add a subclass to replace a field that I’m using\n\nSupport\n\nto trigger different behavior based on its value; I do this with Replace Type Code with\n\nSubclasses (362).\n\nSign Out\n\nInheritance is a powerful tool, but sometimes it gets used in the wrong place—or the\n\nplace it’s used in becomes wrong. In that case, I use Replace Subclass with Delegate\n\n(381) or Replace Superclass with Delegate (399) to turn inheritance into delegation.\n\nPULL UP METHOD\n\ninverse of: Push Down Method (359)\n\nwww.EBooksWorld.ir\n\nMotivation\n\nEliminating duplicate code is important. Two duplicate methods may work fine as they\n\nare, but they are nothing but a breeding ground for bugs in the future. Whenever there\n\nis duplication, there is risk that an alteration to one copy will not be made to the other.\n\nUsually, it is difficult to find the duplicates.\n\nThe easiest case of using Pull Up Method is when the methods have the same body,\n\nimplying there’s been a copy and paste. Of course it’s not always as obvious as that. I\n\ncould just do the refactoring and see if the tests croak—but that puts a lot of reliance on\n\nmy tests. I usually find it valuable to look for the differences—often, they show up\n\nbehavior that I forgot to test for.\n\nOften, Pull Up Method comes after other steps. I see two methods in different classes\n\nthat can be parameterized in such a way that they end up as essentially the same\n\nmethod. In that case, the smallest step is for me to apply Parameterize Function (310)\n\nseparately and then Pull Up Method.\n\nwww.EBooksWorld.ir\n\nThe most awkward complication with Pull Up Method is if the body of the method\n\nrefers to features that are on the subclass but not on the superclass. When that\n\nhappens, I need to use Pull Up Field (353) and Pull Up Method on those elements first.\n\nIf I have two methods with a similar overall flow, but differing in details, I’ll consider\n\nthe Form Template Method [mf­ft].\n\nMechanics\n\nInspect methods to ensure they are identical.\n\nIf they do the same thing, but are not identical, refactor them until they have\n\nidentical bodies.\n\nCheck that all method calls and field references inside the method body refer to\n\nfeatures that can be called from the superclass.\n\nIf the methods have different signatures, use Change Function Declaration (124) to\n\nget them to the one you want to use on the superclass.\n\nCreate a new method in the superclass. Copy the body of one of the methods over to\n\nit.\n\nRun static checks.\n\nDelete one subclass method.\n\nTest.\n\nKeep deleting subclass methods until they are all gone.\n\nExample\n\nI have two subclass methods that do the same thing.\n\nclass Employee extends Party…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nwww.EBooksWorld.ir\n\nclass Department extends Party…\n\nClick here to view code image\n\nget totalAnnualCost() { return this.monthlyCost * 12; }\n\nI look at both classes and see that they refer to the monthlyCost property which isn’t\n\ndefined on the superclass, but is present in both subclasses. Since I’m in a dynamic\n\nlanguage, I’m OK; if I were in a static language, I’d need to define an abstract method\n\non Party.\n\nThe methods have different names, so I Change Function Declaration (124) to make\n\nthem the same.\n\nclass Department…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nI copy the method from one subclass and paste it into the superclass.\n\nclass Party…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nIn a static language, I’d compile to ensure that all the references were OK. That won’t\n\nhelp me here, so I first remove annualCost from Employee, test, and then remove it\n\nfrom Department.\n\nThat completes the refactoring, but does leave a question. annualCost calls\n\nmonthlyCost, but monthlyCost doesn’t appear in the Party class. It all works,\n\nbecause JavaScript is a dynamic language—but there is value in signaling that\n\nwww.EBooksWorld.ir\n\nsubclasses of Party should provide an implementation for monthlyCost, particularly\n\nif more subclasses get added later on. A good way to provide this signal is a trap method\n\nlike this:\n\nclass Party…\n\nClick here to view code image\n\nget monthlyCost() { throw new SubclassResponsibilityError(); }\n\nI call such an error a subclass responsibility error as that was the name used in\n\nSmalltalk.\n\nPULL UP FIELD\n\ninverse of: Push Down Field (361)\n\nwww.EBooksWorld.ir\n\nMotivation\n\nMotivation\n\nIf subclasses are developed independently, or combined through refactoring, I often\n\nfind that they duplicate features. In particular, certain fields can be duplicates. Such\n\nfields sometimes have similar names—but not always. The only way I can tell what is\n\ngoing on is by looking at the fields and examining how they are used. If they are being\n\nused in a similar way, I can pull them up into the superclass.\n\nBy doing this, I reduce duplication in two ways. I remove the duplicate data declaration\n\nand I can then move behavior that uses the field from the subclasses to the superclass.\n\nMany dynamic languages do not define fields as part of their class definition—instead,\n\nfields appear when they are first assigned to. In this case, pulling up a field is essentially\n\na consequence of Pull Up Constructor Body (355).\n\nMechanics\n\nInspect all users of the candidate field to ensure they are used in the same way.\n\nIf the fields have different names, use Rename Field (244) to give them the same\n\nname.\n\nCreate a new field in the superclass.\n\nThe new field will need to be accessible to subclasses (protected in common\n\nlanguages).\n\nDelete the subclass fields.\n\nTest.\n\nPULL UP CONSTRUCTOR BODY\n\nwww.EBooksWorld.ir\n\nMotivation\n\nConstructors are tricky things. They aren’t quite normal methods—so I’m more\n\nrestricted in what I can do with them.\n\nIf I see subclass methods with common behavior, my first thought is to use Extract\n\nFunction (106) followed by Pull Up Method (350), which will move it nicely into the\n\nsuperclass. Constructors tangle that—because they have special rules about what can be\n\ndone in what order, so I need a slightly different approach.\n\nwww.EBooksWorld.ir\n\nIf this refactoring starts getting messy, I reach for Replace Constructor with Factory\n\nFunction (334).\n\nMechanics\n\nDefine a superclass constructor, if one doesn’t already exist. Ensure it’s called by\n\nsubclass constructors.\n\nUse Slide Statements (223) to move any common statements to just after the super\n\ncall.\n\nRemove the common code from each subclass and put it in the superclass. Add to\n\nthe super call any constructor parameters referenced in the common code.\n\nTest.\n\nIf there is any common code that cannot move to the start of the constructor, use\n\nExtract Function (106) followed by Pull Up Method (350).\n\nExample\n\nI start with the following code:\n\nClick here to view code image\n\nclass Party {}\n\nclass Employee extends Party {\n\nconstructor(name, id, monthlyCost) { super(); this._id = id; this._name = name; this._monthlyCost = monthlyCost; } // rest of class...\n\nclass Department extends Party {\n\nconstructor(name, staff){ super(); this._name = name; this._staff = staff; } // rest of class...\n\nThe common code here is the assignment of the name. I use Slide Statements (223) to\n\nwww.EBooksWorld.ir\n\nmove the assignment in Employee next to the call to super():\n\nClick here to view code image\n\nclass Employee extends Party { constructor(name, id, monthlyCost) { super(); this._name = name; this._id = id; this._monthlyCost = monthlyCost; } // rest of class...\n\nWith that tested, I move the common code to the superclass. Since that code contains a\n\nreference to a constructor argument, I pass that in as a parameter.\n\nclass Party…\n\nconstructor(name){ this._name = name; }\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, id, monthlyCost) { super(name); this._id = id; this._monthlyCost = monthlyCost; }\n\nclass Department…\n\nconstructor(name, staff){ super(name); this._staff = staff; }\n\nRun the tests, and I’m done.\n\nMost of the time, constructor behavior will work like this: Do the common elements\n\nfirst (with a super call), then do extra work that the subclass needs. Occasionally, www.EBooksWorld.ir",
      "page_number": 389
    },
    {
      "number": 41,
      "title": "Segment 41 (pages 398-409)",
      "start_page": 398,
      "end_page": 409,
      "detection_method": "topic_boundary",
      "content": "however, there is some common behavior later.\n\nConsider this example:\n\nclass Employee…\n\nconstructor (name) {...}\n\nget isPrivileged() {...}\n\nassignCar() {...}\n\nclass Manager extends Employee…\n\nClick here to view code image\n\nconstructor(name, grade) { super(name); this._grade = grade; if (this.isPrivileged) this.assignCar(); // every subclass does this }\n\nget isPrivileged() { return this._grade > 4; }\n\nThe wrinkle here comes from the fact that the call to isPrivileged can’t be made\n\nuntil after the grade field is assigned, and that can only be done in the subclass.\n\nIn this case, I do Extract Function (106) on the common code:\n\nclass Manager…\n\nClick here to view code image\n\nconstructor(name, grade) { super(name); this._grade = grade; this.finishConstruction(); }\n\nfinishConstruction() { if (this.isPrivileged) this.assignCar(); }\n\nwww.EBooksWorld.ir\n\nThen, I use Pull Up Method (350) to move it to the superclass.\n\nclass Employee…\n\nClick here to view code image\n\nfinishConstruction() { if (this.isPrivileged) this.assignCar(); }\n\nPUSH DOWN METHOD\n\ninverse of: Pull Up Method (350)\n\nMotivation\n\nIf a method is only relevant to one subclass (or a small proportion of subclasses),\n\nremoving it from the superclass and putting it only on the subclass(es) makes that\n\nclearer. I can only do this refactoring if the caller knows it’s working with a particular\n\nsubclass—otherwise, I should use Replace Conditional with Polymorphism (272) with\n\nsome placebo behavior on the superclass.\n\nwww.EBooksWorld.ir\n\nMechanics\n\nMechanics\n\nCopy the method into every subclass that needs it.\n\nRemove the method from the superclass.\n\nTest.\n\nRemove the method from each superclass that doesn’t need it.\n\nTest.\n\nPUSH DOWN FIELD\n\ninverse of: Pull Up Field (353)\n\nMotivation\n\nIf a field is only used by one subclass (or a small proportion of subclasses), I move it to\n\nthose subclasses.\n\nMechanics\n\nwww.EBooksWorld.ir\n\nDeclare field in all subclasses that need it.\n\nRemove the field from the superclass.\n\nTest.\n\nRemove the field from all subclasses that don’t need it.\n\nTest.\n\nREPLACE TYPE CODE WITH SUBCLASSES\n\nsubsumes: Replace Type Code with State/Strategy\n\nsubsumes: Extract Subclass\n\ninverse of: Remove Subclass (369)\n\nMotivation\n\nSoftware systems often need to represent different kinds of a similar thing. I may\n\nclassify employees by their job type (engineer, manager, salesman), or orders by their\n\npriority (rush, regular). My first tool for handling this is some kind of type code field—\n\nwww.EBooksWorld.ir\n\ndepending on the language, that might be an enum, symbol, string, or number. Often,\n\nthis type code will come from an external service that provides me with the data I’m\n\nworking on.\n\nMost of the time, such a type code is all I need. But there are a couple of situations\n\nwhere I could do with something more, and that something more are subclasses. There\n\nare two things that are particularly enticing about subclasses. First, they allow me to\n\nuse polymorphism to handle conditional logic. I find this most helpful when I have\n\nseveral functions that invoke different behavior depending on the value of the type\n\ncode. With subclasses, I can apply Replace Conditional with Polymorphism (272) to\n\nthese functions.\n\nThe second case is where I have fields or methods that are only valid for particular\n\nvalues of a type code, such as a sales quota that’s only applicable to the “salesman” type\n\ncode. I can then create the subclass and apply Push Down Field (361). While I can\n\ninclude validation logic to ensure a field is only used when the type code has the correct\n\nvalue, using a subclass makes the relationship more explicit.\n\nWhen using Replace Type Code with Subclasses, I need to consider whether to apply it\n\ndirectly to the class I’m looking at, or to the type code itself. Do I make engineer a\n\nsubtype of employee, or should I give the employee an employee type property which\n\ncan have subtypes for engineer and manager? Using direct subclassing is simpler, but I\n\ncan’t use it for the job type if I need it for something else. I also can’t use direct\n\nsubclasses if the type is mutable. If I need to move the subclasses to an employee type\n\nproperty, I can do that by using Replace Primitive with Object (174) on the type code to\n\ncreate an employee type class and then using Replace Type Code with Subclasses on\n\nthat new class.\n\nMechanics\n\nSelf­encapsulate the type code field.\n\nPick one type code value. Create a subclass for that type code. Override the type\n\ncode getter to return the literal type code value.\n\nCreate selector logic to map from the type code parameter to the new subclass.\n\nWith direct inheritance, use Replace Constructor with Factory Function (334) and\n\nput the selector logic in the factory. With indirect inheritance, the selector logic may\n\nstay in the constructor.\n\nwww.EBooksWorld.ir\n\nTest.\n\nRepeat creating the subclass and adding to the selector logic for each type code\n\nvalue. Test after each change.\n\nRemove the type code field.\n\nTest.\n\nUse Push Down Method (359) and Replace Conditional with Polymorphism (272)\n\non any methods that use the type code accessors. Once all are replaced, you can\n\nremove the type code accessors.\n\nExample\n\nI’ll start with this overused employee example:\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, type){ this.validateType(type); this._name = name; this._type = type; } validateType(arg) { if (![\"engineer\", \"manager\", \"salesman\"].includes(arg)) throw new Error(`Employee cannot be of type ${arg}`); } toString() {return `${this._name} (${this._type})`;}\n\nMy first step is to use Encapsulate Variable (132) to self­encapsulate the type code.\n\nclass Employee…\n\nClick here to view code image\n\nget type() {return this._type;} toString() {return `${this._name} (${this.type})`;}\n\nNote that toString uses the new getter by removing the underscore.\n\nI pick one type code, the engineer, to start with. I use direct inheritance, subclassing the\n\nwww.EBooksWorld.ir\n\nemployee class itself. The employee subclass is simple—just overriding the type code\n\ngetter with the appropriate literal value.\n\nClick here to view code image\n\nclass Engineer extends Employee { get type() {return \"engineer\";} }\n\nAlthough JavaScript constructors can return other objects, things will get messy if I try\n\nto put selector logic in there, since that logic gets intertwined with field initialization. So\n\nI use Replace Constructor with Factory Function (334) to create a new space for it.\n\nClick here to view code image\n\nfunction createEmployee(name, type) { return new Employee(name, type); }\n\nTo use the new subclass, I add selector logic into the factory.\n\nClick here to view code image\n\nfunction createEmployee(name, type) { switch (type) { case \"engineer\": return new Engineer(name, type); } return new Employee(name, type); }\n\nI test to ensure that worked out correctly. But, because I’m paranoid, I then alter the\n\nreturn value of the engineer’s override and test again to ensure the test fails. That way I\n\nknow the subclass is being used. I correct the return value and continue with the other\n\ncases. I can do them one at a time, testing after each change.\n\nClick here to view code image\n\nclass Salesman extends Employee { get type() {return \"salesman\";} }\n\nclass Manager extends Employee { get type() {return \"manager\";}\n\nwww.EBooksWorld.ir\n\n}\n\nfunction createEmployee(name, type) { switch (type) { case \"engineer\": return new Engineer(name, type); case \"salesman\": return new Salesman(name, type); case \"manager\": return new Manager (name, type); } return new Employee(name, type); }\n\nOnce I’m done with them all, I can remove the type code field and the superclass\n\ngetting method (the ones in the subclasses remain).\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, type){ this.validateType(type); this._name = name; this._type = type; }\n\nget type() {return this._type;} toString() {return `${this._name} (${this.type})`;}\n\nAfter testing to ensure all is still well, I can remove the validation logic, since the switch\n\nis effectively doing the same thing.\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, type){ this.validateType(type); this._name = name; }\n\nfunction createEmployee(name, type) { switch (type) { case \"engineer\": return new Engineer(name, type); case \"salesman\": return new Salesman(name, type); case \"manager\": return new Manager (name, type); default: throw new Error(`Employee cannot be of type ${type}`); } return new Employee(name, type);\n\nwww.EBooksWorld.ir\n\n}\n\nThe type argument to the constructor is now useless, so it falls victim to Change\n\nFunction Declaration (124).\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, type){ this._name = name; }\n\nfunction createEmployee(name, type) { switch (type) { case \"engineer\": return new Engineer(name, type); case \"salesman\": return new Salesman(name, type); case \"manager\": return new Manager (name, type); default: throw new Error(`Employee cannot be of type ${type}`); } }\n\nI still have the type code accessors on the subclasses—get type. I’ll usually want to\n\nremove these too, but that may take a bit of time due to other methods that depend on\n\nthem. I’ll use Replace Conditional with Polymorphism (272) and Push Down Method\n\n(359) to deal with these. At some point, I’ll have no code that uses the type getters, so I\n\nwill subject them to the tender mercies of Remove Dead Code (237).\n\nExample: Using Indirect Inheritance\n\nLet’s go back to the starting case—but this time, I already have existing subclasses for\n\npart­time and full­time employees, so I can’t subclass from Employee for the type\n\ncodes. Another reason to not use direct inheritance is keeping the ability to change the\n\ntype of employee.\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, type){ this.validateType(type); this._name = name; this._type = type; }\n\nwww.EBooksWorld.ir\n\nvalidateType(arg) { if (![\"engineer\", \"manager\", \"salesman\"].includes(arg)) throw new Error(`Employee cannot be of type ${arg}`); } get type() {return this._type;} set type(arg) {this._type = arg;}\n\nget capitalizedType() { return this._type.charAt(0).toUpperCase() + this._type.substr(1).toLowerCase(); } toString() { return `${this._name} (${this.capitalizedType})`; }\n\nThis time toString is a bit more complicated, to allow me to illustrate something\n\nshortly.\n\nMy first step is to use Replace Primitive with Object (174) on the type code.\n\nClick here to view code image\n\nclass EmployeeType { constructor(aString) { this._value = aString; } toString() {return this._value;} }\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, type){ this.validateType(type); this._name = name; this.type = type; } validateType(arg) { if (![\"engineer\", \"manager\", \"salesman\"].includes(arg)) throw new Error(`Employee cannot be of type ${arg}`); } get typeString() {return this._type.toString();} get type() {return this._type;} set type(arg) {this._type = new EmployeeType(arg);}\n\nget capitalizedType() { return this.typeString.charAt(0).toUpperCase()\n\nwww.EBooksWorld.ir\n\n+ this.typeString.substr(1).toLowerCase(); } toString() { return `${this._name} (${this.capitalizedType})`; }\n\nI then apply the usual mechanics of Replace Type Code with Subclasses to the employee\n\ntype.\n\nclass Employee…\n\nClick here to view code image\n\nset type(arg) {this._type = Employee.createEmployeeType(arg);}\n\nstatic createEmployeeType(aString) { switch(aString) { case \"engineer\": return new Engineer(); case \"manager\": return new Manager (); case \"salesman\": return new Salesman(); default: throw new Error(`Employee cannot be of type ${aString}`); } }\n\nclass EmployeeType { } class Engineer extends EmployeeType { toString() {return \"engineer\";} } class Manager extends EmployeeType { toString() {return \"manager\";} } class Salesman extends EmployeeType { toString() {return \"salesman\";} }\n\nIf I were leaving it at that, I could remove the empty EmployeeType. But I prefer to\n\nleave it there as it makes explicit the relationship between the various subclasses. It’s\n\nalso a handy spot for moving other behavior there, such as the capitalization logic I\n\ntossed into the example specifically to illustrate this point.\n\nclass Employee…\n\nClick here to view code image\n\ntoString() {\n\nwww.EBooksWorld.ir\n\nreturn `${this._name} (${this.type.capitalizedName})`; }\n\nclass EmployeeType…\n\nClick here to view code image\n\nget capitalizedName() { return this.toString().charAt(0).toUpperCase() + this.toString().substr(1).toLowerCase(); }\n\nFor those familiar with the first edition of the book, this example essentially supersedes\n\nthe Replace Type Code with State/Strategy. I now think of that refactoring as Replace\n\nType Code with Subclasses using indirect inheritance, so didn’t consider it worth its\n\nown entry in the catalog. (I never liked the name anyway.)\n\nREMOVE SUBCLASS\n\nformerly: Replace Subclass with Fields\n\ninverse of: Replace Type Code with Subclasses (362)\n\nwww.EBooksWorld.ir",
      "page_number": 398
    },
    {
      "number": 42,
      "title": "Segment 42 (pages 410-422)",
      "start_page": 410,
      "end_page": 422,
      "detection_method": "topic_boundary",
      "content": "Motivation\n\nSubclasses are useful. They support variations in data structure and polymorphic\n\nbehavior. They are a good way to program by difference. But as a software system\n\nevolves, subclasses can lose their value as the variations they support are moved to\n\nother places or removed altogether. Sometimes, subclasses are added in anticipation of\n\nfeatures that never end up being built, or end up being built in a way that doesn’t need\n\nthe subclasses.\n\nA subclass that does too little incurs a cost in understanding that is no longer\n\nworthwhile. When that time comes, it’s best to remove the subclass, replacing it with a\n\nfield on its superclass.\n\nMechanics\n\nUse Replace Constructor with Factory Function (334) on the subclass constructor.\n\nIf the clients of the constructors use a data field to decide which subclass to create,\n\nput that decision logic into a superclass factory method.\n\nIf any code tests against the subclass’s types, use Extract Function (106) on the type\n\nwww.EBooksWorld.ir\n\ntest and Move Function (198) to move it to the superclass. Test after each change.\n\nCreate a field to represent the subclass type.\n\nChange the methods that refer to the subclass to use the new type field.\n\nDelete the subclass.\n\nTest.\n\nOften, this refactoring is used on a group of subclasses at once—in which case carry out\n\nthe steps to encapsulate them (add factory function, move type tests) first, then\n\nindividually fold them into the superclass.\n\nExample\n\nI’ll start with this stump of subclasses:\n\nclass Person…\n\nClick here to view code image\n\nconstructor(name) { this._name = name; } get name() {return this._name;} get genderCode() {return \"X\";} // snip\n\nclass Male extends Person { get genderCode() {return \"M\";} }\n\nclass Female extends Person { get genderCode() {return \"F\";} }\n\nIf that’s all that a subclass does, it’s not really worth having. But before I remove these\n\nsubclasses, it’s usually worth checking to see if there’s any subclass­dependent behavior\n\nin the clients that should be moved in there. In this case, I don’t find anything worth\n\nkeeping the subclasses for.\n\nclient…\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nconst numberOfMales = people.filter(p => p instanceof Male).length;\n\nWhenever I want to change how I represent something, I try to first encapsulate the\n\ncurrent representation to minimize the impact on any client code. When it comes to\n\ncreating subclasses, the way to encapsulate is to use Replace Constructor with Factory\n\nFunction (334). In this case, there’s a couple of ways I could make the factory.\n\nThe most direct way is to create a factory method for each constructor.\n\nClick here to view code image\n\nfunction createPerson(name) { return new Person(name); } function createMale(name) { return new Male(name); } function createFemale(name) { return new Female(name); }\n\nBut although that’s the direct choice, objects like this are often loaded from a source\n\nthat uses the gender codes directly.\n\nClick here to view code image\n\nfunction loadFromInput(data) { const result = []; data.forEach(aRecord => { let p; switch (aRecord.gender) { case 'M': p = new Male(aRecord.name); break; case 'F': p = new Female(aRecord.name); break; default: p = new Person(aRecord.name); } result.push(p); }); return result; }\n\nIn that case, I find it better to use Extract Function (106) on the selection logic for\n\nwhich class to create, and make that the factory function.\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nfunction createPerson(aRecord) { let p; switch (aRecord.gender) { case 'M': p = new Male(aRecord.name); break; case 'F': p = new Female(aRecord.name); break; default: p = new Person(aRecord.name); } return p; }\n\nfunction loadFromInput(data) { const result = []; data.forEach(aRecord => { result.push(createPerson(aRecord)); }); return result; }\n\nWhile I’m there, I’ll clean up those two functions. I’ll use Inline Variable (123) on\n\ncreatePerson:\n\nClick here to view code image\n\nfunction createPerson(aRecord) { switch (aRecord.gender) { case 'M': return new Male (aRecord.name); case 'F': return new Female(aRecord.name); default: return new Person(aRecord.name); } }\n\nand Replace Loop with Pipeline (231) on loadFromInput:\n\nClick here to view code image\n\nfunction loadFromInput(data) { return data.map(aRecord => createPerson(aRecord)); }\n\nThe factory encapsulates the creation of the subclasses, but there is also the use of\n\ninstanceof—which never smells good. I use Extract Function (106) on the type\n\ncheck.\n\nclient…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nconst numberOfMales = people.filter(p => isMale(p)).length;\n\nfunction isMale(aPerson) {return aPerson instanceof Male;}\n\nThen I use Move Function (198) to move it into Person.\n\nclass Person…\n\nClick here to view code image\n\nget isMale() {return this instanceof Male;}\n\nclient…\n\nClick here to view code image\n\nconst numberOfMales = people.filter(p => p.isMale).length;\n\nWith that refactoring done, all knowledge of the subclasses is now safely encased within\n\nthe superclass and the factory function. (Usually I’m wary of a superclass referring to a\n\nsubclass, but this code isn’t going to last until my next cup of tea, so I’m not going worry\n\nabout it.)\n\nI now add a field to represent the difference between the subclasses; since I’m using a\n\ncode loaded from elsewhere, I might as well just use that.\n\nclass Person…\n\nClick here to view code image\n\nconstructor(name, genderCode) { this._name = name; this._genderCode = genderCode || \"X\"; }\n\nget genderCode() {return this._genderCode;}\n\nWhen initializing it, I set it to the default case. (As a side note, although most people\n\ncan be classified as male or female, there are people who can’t. It’s a common modeling\n\nwww.EBooksWorld.ir\n\nmistake to forget that.)\n\nI then take the male case and fold its logic into the superclass. This involves modifying\n\nthe factory to return a Person and modifying any instanceof tests to use the gender\n\ncode field.\n\nClick here to view code image\n\nfunction createPerson(aRecord) { switch (aRecord.gender) { case 'M': return new Person(aRecord.name, \"M\"); case 'F': return new Female(aRecord.name); default: return new Person(aRecord.name); } }\n\nclass Person…\n\nClick here to view code image\n\nget isMale() {return \"M\" === this._genderCode;}\n\nI test, remove the male subclass, test again, and repeat for the female subclass.\n\nClick here to view code image\n\nfunction createPerson(aRecord) { switch (aRecord.gender) { case 'M': return new Person(aRecord.name, \"M\"); case 'F': return new Person(aRecord.name, \"F\"); default: return new Person(aRecord.name); } }\n\nI find the lack of symmetry with the gender code to be annoying. A future reader of the\n\ncode will always wonder about this lack of symmetry. So I prefer to change the code to\n\nmake it symmetrical—if I can do it without introducing any other complexity, which is\n\nthe case here.\n\nClick here to view code image\n\nfunction createPerson(aRecord) { switch (aRecord.gender) {\n\nwww.EBooksWorld.ir\n\ncase 'M': return new Person(aRecord.name, \"M\"); case 'F': return new Person(aRecord.name, \"F\"); default: return new Person(aRecord.name, \"X\"); } }\n\nclass Person…\n\nClick here to view code image\n\nconstructor(name, genderCode) { this._name = name; this._genderCode = genderCode || \"X\"; }\n\nEXTRACT SUPERCLASS\n\nwww.EBooksWorld.ir\n\nMotivation\n\nIf I see two classes doing similar things, I can take advantage of the basic mechanism of\n\ninheritance to pull their similarities together into a superclass. I can use Pull Up Field\n\n(353) to move common data into the superclass, and Pull Up Method (350) to move the\n\ncommon behavior.\n\nMany writers on object orientation treat inheritance as something that should be\n\ncarefully planned in advance, based on some kind of classification structure in the “real\n\nworld.” Such classification structures can be a hint towards using inheritance—but just\n\nwww.EBooksWorld.ir\n\nas often inheritance is something I realize during the evolution of a program, as I find\n\ncommon elements that I want to pull together.\n\nAn alternative to Extract Superclass is Extract Class (182). Here you have, essentially, a\n\nchoice between using inheritance or delegation as a way to unify duplicate behavior.\n\nOften Extract Superclass is the simpler approach, so I’ll do this first knowing I can use\n\nReplace Superclass with Delegate (399) should I need to later.\n\nMechanics\n\nCreate an empty superclass. Make the original classes its subclasses.\n\nIf needed, use Change Function Declaration (124) on the constructors.\n\nTest.\n\nOne by one, use Pull Up Constructor Body (355), Pull Up Method (350), and Pull\n\nUp Field (353) to move common elements to the superclass.\n\nExamine remaining methods on the subclasses. See if there are common parts. If so,\n\nuse Extract Function (106) followed by Pull Up Method (350).\n\nCheck clients of the original classes. Consider adjusting them to use the superclass\n\ninterface.\n\nExample\n\nI’m pondering these two classes, they share some common functionality—their name\n\nand the notions of annual and monthly costs:\n\nClick here to view code image\n\nclass Employee {\n\nconstructor(name, id, monthlyCost) { this._id = id; this._name = name; this._monthlyCost = monthlyCost; } get monthlyCost() {return this._monthlyCost;} get name() {return this._name;} get id() {return this._id;}\n\nget annualCost() { return this.monthlyCost * 12; }\n\nwww.EBooksWorld.ir\n\n}\n\nclass Department { constructor(name, staff){ this._name = name; this._staff = staff; } get staff() {return this._staff.slice();} get name() {return this._name;}\n\nget totalMonthlyCost() { return this.staff .map(e => e.monthlyCost) .reduce((sum, cost) => sum + cost); } get headCount() { return this.staff.length; } get totalAnnualCost() { return this.totalMonthlyCost * 12; } }\n\nI can make the common behavior more explicit by extracting a common superclass\n\nfrom them.\n\nI begin by creating an empty superclass and letting them both extend from it.\n\nClick here to view code image\n\nclass Party {}\n\nclass Employee extends Party { constructor(name, id, monthlyCost) { super(); this._id = id; this._name = name; this._monthlyCost = monthlyCost; } // rest of class...\n\nclass Department extends Party { constructor(name, staff){ super(); this._name = name; this._staff = staff; } // rest of class...\n\nwww.EBooksWorld.ir\n\nWhen doing Extract Superclass, I like to start with the data, which in JavaScript\n\ninvolves manipulating the constructor. So I start with Pull Up Field (353) to pull up the\n\nname.\n\nclass Party…\n\nconstructor(name){ this._name = name; }\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, id, monthlyCost) { super(name); this._id = id; this._monthlyCost = monthlyCost; }\n\nclass Department…\n\nconstructor(name, staff){ super(name); this._staff = staff; }\n\nAs I get data up to the superclass, I can also apply Pull Up Method (350) on associated\n\nmethods. First, the name:\n\nclass Party…\n\nClick here to view code image\n\nget name() {return this._name;}\n\nclass Employee…\n\nClick here to view code image\n\nget name() {return this._name;}\n\nwww.EBooksWorld.ir\n\nclass Department…\n\nClick here to view code image\n\nget name() {return this._name;}\n\nI have two methods with similar bodies.\n\nclass Employee…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nclass Department…\n\nClick here to view code image\n\nget totalAnnualCost() { return this.totalMonthlyCost * 12; }\n\nThe methods they use, monthlyCost and totalMonthlyCost, have different names\n\nand different bodies—but do they represent the same intent? If so, I should use Change\n\nFunction Declaration (124) to unify their names.\n\nclass Department…\n\nClick here to view code image\n\nget totalAnnualCost() { return this.monthlyCost * 12; }\n\nget monthlyCost() { … }\n\nI then do a similar renaming to the annual costs:\n\nclass Department…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nI can now apply Pull Up Method (350) to the annual cost methods.\n\nclass Party…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nclass Employee…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nclass Department…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nCOLLAPSE HIERARCHY\n\nwww.EBooksWorld.ir",
      "page_number": 410
    },
    {
      "number": 43,
      "title": "Segment 43 (pages 423-435)",
      "start_page": 423,
      "end_page": 435,
      "detection_method": "topic_boundary",
      "content": "Motivation\n\nWhen I’m refactoring a class hierarchy, I’m often pulling and pushing features around.\n\nAs the hierarchy evolves, I sometimes find that a class and its parent are no longer\n\ndifferent enough to be worth keeping separate. At this point, I’ll merge them together.\n\nMechanics\n\nChoose which one to remove.\n\nI choose based on which name makes most sense in the future. If neither name is\n\nbest, I’ll pick one arbitrarily.\n\nUse Pull Up Field (353), Push Down Field (361), Pull Up Method (350), and Push\n\nDown Method (359) to move all the elements into a single class.\n\nAdjust any references to the victim to change them to the class that will stay.\n\nRemove the empty class.\n\nTest.\n\nREPLACE SUBCLASS WITH DELEGATE\n\nwww.EBooksWorld.ir\n\nMotivation\n\nIf I have some objects whose behavior varies from category to category, the natural\n\nmechanism to express this is inheritance. I put all the common data and behavior in the\n\nsuperclass, and let each subclass add and override features as needed. Object­oriented\n\nlanguages make this simple to implement and thus a familiar mechanism.\n\nBut inheritance has its downsides. Most obviously, it’s a card that can only be played\n\nonce. If I have more than one reason to vary something, I can only use inheritance for a\n\nsingle axis of variation. So, if I want to vary behavior of people by their age category and\n\nby their income level, I can either have subclasses for young and senior, or for well­off\n\nand poor—I can’t have both.\n\nwww.EBooksWorld.ir\n\nA further problem is that inheritance introduces a very close relationship between\n\nclasses. Any change I want to make to the parent can easily break children, so I have to\n\nbe careful and understand how children derive from the superclass. This problem is\n\nmade worse when the logic of the two classes resides in different modules and is looked\n\nafter by different teams.\n\nDelegation handles both of these problems. I can delegate to many different classes for\n\ndifferent reasons. Delegation is a regular relationship between objects—so I can have a\n\nclear interface to work with, which is much less coupling than subclassing. It’s therefore\n\ncommon to run into the problems with subclassing and apply Replace Subclass with\n\nDelegate.\n\nThere is a popular principle: “Favor object composition over class inheritance” (where\n\ncomposition is effectively the same as delegation). Many people take this to mean\n\n“inheritance considered harmful” and claim that we should never use inheritance. I use\n\ninheritance frequently, partly because I always know I can use Replace Subclass with\n\nDelegate should I need to change it later. Inheritance is a valuable mechanism that does\n\nthe job most of the time without problems. So I reach for it first, and move onto\n\ndelegation when it starts to rub badly. This usage is actually consistent with the\n\nprinciple—which comes from the Gang of Four book [gof] that explains how inheritance\n\nand composition work together. The principle was a reaction to the overuse of\n\ninheritance.\n\nThose who are familiar with the Gang of Four book may find it helpful to think of this\n\nrefactoring as replacing subclasses with the State or Strategy patterns. Both of these\n\npatterns are structurally the same, relying on the host delegating to a separate\n\nhierarchy. Not all cases of Replace Subclass with Delegate involve an inheritance\n\nhierarchy for the delegate (as the first example below illustrates), but setting up a\n\nhierarchy for states or strategies is often useful.\n\nMechanics\n\nIf there are many callers for the constructors, apply Replace Constructor with\n\nFactory Function (334).\n\nCreate an empty class for the delegate. Its constructor should take any subclass­\n\nspecific data as well as, usually, a back­reference to the superclass.\n\nAdd a field to the superclass to hold the delegate.\n\nModify the creation of the subclass so that it initializes the delegate field with an\n\nwww.EBooksWorld.ir\n\ninstance of the delegate.\n\nThis can be done in the factory function, or in the constructor if the constructor can\n\nreliably tell whether to create the correct delegate.\n\nChoose a subclass method to move to the delegate class.\n\nUse Move Function (198) to move it to the delegate class. Don’t remove the source’s\n\ndelegating code.\n\nIf the method needs elements that should move to the delegate, move them. If it\n\nneeds elements that should stay in the superclass, add a field to the delegate that\n\nrefers to the superclass.\n\nIf the source method has callers outside the class, move the source’s delegating code\n\nfrom the subclass to the superclass, guarding it with a check for the presence of the\n\ndelegate. If not, apply Remove Dead Code (237).\n\nIf there’s more than one subclass, and you start duplicating code within them, use\n\nExtract Superclass (375). In this case, any delegating methods on the source super­\n\nclass no longer need a guard if the default behavior is moved to the delegate\n\nsuperclass.\n\nTest.\n\nRepeat until all the methods of the subclass are moved.\n\nFind all callers of the subclasses’s constructor and change them to use the\n\nsuperclass constructor.\n\nTest.\n\nUse Remove Dead Code (237) on the subclass.\n\nExample\n\nI have a class that makes a booking for a show.\n\nclass Booking…\n\nconstructor(show, date) { this._show = show; this._date = date;\n\nwww.EBooksWorld.ir\n\n}\n\nThere is a subclass for premium booking that takes into account various extras that are\n\navailable.\n\nclass PremiumBooking extends Booking…\n\nClick here to view code image\n\nconstructor(show, date, extras) { super(show, date); this._extras = extras; }\n\nThere are quite a few changes that the premium booking makes to what it inherits from\n\nthe superclass. As is typical with this kind of programming­by­difference, in some cases\n\nthe subclass overrides methods on the superclass, in others it adds new methods that\n\nare only relevant for the subclass. I won’t go into all of them, but I will pick out a few\n\ninteresting cases.\n\nFirst, there is a simple override. Regular bookings offer a talkback after the show, but\n\nonly on nonpeak days.\n\nclass Booking…\n\nClick here to view code image\n\nget hasTalkback() { return this._show.hasOwnProperty('talkback') && !this.isPeakDay; }\n\nPremium bookings override this to offer talkbacks on all days.\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget hasTalkback() { return this._show.hasOwnProperty('talkback'); }\n\nDetermining the price is a similar override, with a twist that the premium method calls\n\nwww.EBooksWorld.ir\n\nthe superclass method.\n\nclass Booking…\n\nClick here to view code image\n\nget basePrice() { let result = this._show.price; if (this.isPeakDay) result += Math.round(result * 0.15); return result; }\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget basePrice() { return Math.round(super.basePrice + this._extras.premiumFee); }\n\nThe last example is where the premium booking offers a behavior that isn’t present on\n\nthe superclass.\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget hasDinner() { return this._extras.hasOwnProperty('dinner') && !this.isPeakDay; }\n\nInheritance works well for this example. I can understand the base class without having\n\nto understand the subclass. The subclass is defined just by saying how it differs from\n\nthe base case—both reducing duplication and clearly communicating what are the\n\ndifferences it’s introducing.\n\nActually, it isn’t quite as perfect as the previous paragraph implies. There are things in\n\nthe superclass structure that only make sense due to the subclass—such as methods\n\nthat have been factored in such a way as to make it easier to override just the right\n\nkinds of behavior. So although most of the time I can modify the base class without\n\nhaving to understand subclasses, there are occasions where such mindful ignorance of\n\nthe subclasses will lead me to breaking a subclass by modifying the superclass.\n\nwww.EBooksWorld.ir\n\nHowever, if these occasions are not too common, the inheritance pays off—provided I\n\nhave good tests to detect a subclass breakage.\n\nSo why would I want to change such a happy situation by using Replace Subclass with\n\nDelegate? Inheritance is a tool that can only be used once—so if I have another reason\n\nto use inheritance, and I think it will benefit me more than the premium booking\n\nsubclass, I’ll need to handle premium bookings a different way. Also, I may need to\n\nchange from the default booking to the premium booking dynamically—i.e., support a\n\nmethod like aBooking.bePremium(). In some cases, I can avoid this by creating a\n\nwhole new object (a common example is where an HTTP request loads new data from\n\nthe server). But sometimes, I need to modify a data structure and not rebuild it from\n\nscratch, and it is difficult to just replace a single booking that’s referred to from many\n\ndifferent places. In such situations, it can be useful to allow a booking to switch from\n\ndefault to premium and back again.\n\nWhen these needs crop up, I need to apply Replace Subclass with Delegate. I have\n\nclients call the constructors of the two classes to make the bookings:\n\nbooking client\n\nClick here to view code image\n\naBooking = new Booking(show,date);\n\npremium client\n\nClick here to view code image\n\naBooking = new PremiumBooking(show, date, extras);\n\nRemoving subclasses will alter all of this, so I like to encapsulate the constructor calls\n\nwith Replace Constructor with Factory Function (334).\n\ntop level…\n\nClick here to view code image\n\nfunction createBooking(show, date) { return new Booking(show, date); } function createPremiumBooking(show, date, extras) {\n\nwww.EBooksWorld.ir\n\nreturn new PremiumBooking (show, date, extras); }\n\nbooking client\n\nClick here to view code image\n\naBooking = createBooking(show, date);\n\npremium client\n\nClick here to view code image\n\naBooking = createPremiumBooking(show, date, extras);\n\nI now make the new delegate class. Its constructor parameters are those parameters\n\nthat are only used in the subclass, together with a back­reference to the booking object.\n\nI’ll need this because several subclass methods require access to data stored in the\n\nsuperclass. Inheritance makes this easy to do, but with a delegate I need a back­\n\nreference.\n\nclass PremiumBookingDelegate…\n\nClick here to view code image\n\nconstructor(hostBooking, extras) { this._host = hostBooking; this._extras = extras; }\n\nI now connect the new delegate to the booking object. I do this by modifying the factory\n\nfunction for premium bookings.\n\ntop level…\n\nClick here to view code image\n\nfunction createPremiumBooking(show, date, extras) { const result = new PremiumBooking (show, date, extras); result._bePremium(extras); return result; }\n\nwww.EBooksWorld.ir\n\nclass Booking…\n\nClick here to view code image\n\n_bePremium(extras) { this._premiumDelegate = new PremiumBookingDelegate(this, extras); }\n\nI use a leading underscore on _bePremium to indicate that it shouldn’t be part of the\n\npublic interface for Booking. Of course, if the point of doing this refactoring is to allow\n\na booking to mutate to premium, it can be a public method.\n\nAlternatively, I can do all the connections in the constructor for Booking. In order to\n\ndo that, I need some way to signal to the constructor that we have a premium booking.\n\nThat could be an extra parameter, or just the use of extras if I can be sure that it is\n\nalways present when used with a premium booking. Here, I prefer the explicitness of\n\ndoing this through the factory function.\n\nWith the structures set up, it’s time to start moving the behavior. The first case I’ll\n\nconsider is the simple override of hasTalkback. Here’s the existing code:\n\nclass Booking…\n\nClick here to view code image\n\nget hasTalkback() { return this._show.hasOwnProperty('talkback') && !this.isPeakDay; }\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget hasTalkback() { return this._show.hasOwnProperty('talkback'); }\n\nI use Move Function (198) to move the subclass method to the delegate. To make it fit\n\nits home, I route any access to superclass data with a call to _host.\n\nwww.EBooksWorld.ir\n\nclass PremiumBookingDelegate…\n\nClick here to view code image\n\nget hasTalkback() { return this._host._show.hasOwnProperty('talkback'); }\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget hasTalkback() { return this._premiumDelegate.hasTalkback; }\n\nI test to ensure everything is working, then delete the subclass method:\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget hasTalkback() { return this._premiumDelegate.hasTalkback; }\n\nI run the tests at this point, expecting some to fail.\n\nNow I finish the move by adding dispatch logic to the superclass method to use the\n\ndelegate if it is present.\n\nclass Booking…\n\nClick here to view code image\n\nget hasTalkback() { return (this._premiumDelegate) ? this._premiumDelegate.hasTalkback : this._show.hasOwnProperty('talkback') && !this.isPeakDay; }\n\nThe next case I’ll look at is the base price.\n\nwww.EBooksWorld.ir\n\nclass Booking…\n\nClick here to view code image\n\nget basePrice() { let result = this._show.price; if (this.isPeakDay) result += Math.round(result * 0.15); return result; }\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget basePrice() { return Math.round(super.basePrice + this._extras.premiumFee); }\n\nThis is almost the same, but there is a wrinkle in the form of the pesky call on super\n\n(which is pretty common in these kinds of subclass extension cases). When I move the\n\nsubclass code to the delegate, I’ll need to call the parent case—but I can’t just call\n\nthis._host._basePrice without getting into an endless recursion.\n\nI have a couple of options here. One is to apply Extract Function (106) on the base\n\ncalculation to allow me to separate the dispatch logic from price calculation. (The rest\n\nof the move is as before.)\n\nclass Booking…\n\nClick here to view code image\n\nget basePrice() { return (this._premiumDelegate) ? this._premiumDelegate.basePrice : this._privateBasePrice; }\n\nget _privateBasePrice() { let result = this._show.price; if (this.isPeakDay) result += Math.round(result * 0.15); return result; }\n\nclass PremiumBookingDelegate…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nget basePrice() { return Math.round(this._host._privateBasePrice + this._extras.premiumFee); }\n\nAlternatively, I can recast the delegate’s method as an extension of the base method.\n\nclass Booking…\n\nClick here to view code image\n\nget basePrice() { let result = this._show.price; if (this.isPeakDay) result += Math.round(result * 0.15); return (this._premiumDelegate) ? this._premiumDelegate.extendBasePrice(result) : result; }\n\nclass PremiumBookingDelegate…\n\nClick here to view code image\n\nextendBasePrice(base) { return Math.round(base + this._extras.premiumFee); }\n\nBoth work reasonably here; I have a slight preference for the latter as it’s a bit smaller.\n\nThe last case is a method that only exists on the subclass.\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget hasDinner() { return this._extras.hasOwnProperty('dinner') && !this.isPeakDay; }\n\nI move it from the subclass to the delegate:\n\nwww.EBooksWorld.ir\n\nclass PremiumBookingDelegate…\n\nClick here to view code image\n\nget hasDinner() { return this._extras.hasOwnProperty('dinner') && !this._host.isPeakDay; }\n\nI then add dispatch logic to Booking:\n\nclass Booking…\n\nClick here to view code image\n\nget hasDinner() { return (this._premiumDelegate) ? this._premiumDelegate.hasDinner : undefined; }\n\nIn JavaScript, accessing a property on an object where it isn’t defined returns\n\nundefined, so I do that here. (Although my every instinct is to have it raise an error,\n\nwhich would be the case in other object­oriented dynamic languages I’m used to.)\n\nOnce I’ve moved all the behavior out of the subclass, I can change the factory method to\n\nreturn the superclass—and, once I’ve run tests to ensure all is well, delete the subclass.\n\ntop level…\n\nClick here to view code image\n\nfunction createPremiumBooking(show, date, extras) { const result = new PremiumBooking (show, date, extras); result._bePremium(extras); return result; }\n\nclass PremiumBooking extends Booking ...\n\nThis is one of those refactorings where I don’t feel that refactoring alone improves the\n\ncode. Inheritance handles this situation very well, whereas using delegation involves\n\nadding dispatch logic, two­way references, and thus extra complexity. The refactoring\n\nwww.EBooksWorld.ir",
      "page_number": 423
    },
    {
      "number": 44,
      "title": "Segment 44 (pages 436-446)",
      "start_page": 436,
      "end_page": 446,
      "detection_method": "topic_boundary",
      "content": "may still be worthwhile, since the advantage of a mutable premium status, or a need to\n\nuse inheritance for other purposes, may outweigh the disadvantage of losing\n\ninheritance.\n\nExample: Replacing a Hierarchy\n\nThe previous example showed using Replace Subclass with Delegate on a single\n\nsubclass, but I can do the same thing with an entire hierarchy.\n\nClick here to view code image\n\nfunction createBird(data) { switch (data.type) { case 'EuropeanSwallow': return new EuropeanSwallow(data); case 'AfricanSwallow': return new AfricanSwallow(data); case 'NorweigianBlueParrot': return new NorwegianBlueParrot(data); default: return new Bird(data); } }\n\nclass Bird { constructor(data) { this._name = data.name; this._plumage = data.plumage; } get name() {return this._name;}\n\nget plumage() { return this._plumage || \"average\"; } get airSpeedVelocity() {return null;} }\n\nclass EuropeanSwallow extends Bird { get airSpeedVelocity() {return 35;} }\n\nclass AfricanSwallow extends Bird { constructor(data) { super (data); this._numberOfCoconuts = data.numberOfCoconuts; } get airSpeedVelocity() { return 40 ­ 2 * this._numberOfCoconuts; } }\n\nwww.EBooksWorld.ir\n\nclass NorwegianBlueParrot extends Bird { constructor(data) { super (data); this._voltage = data.voltage; this._isNailed = data.isNailed; }\n\nget plumage() { if (this._voltage > 100) return \"scorched\"; else return this._plumage || \"beautiful\"; } get airSpeedVelocity() { return (this._isNailed) ? 0 : 10 + this._voltage / 10; } }\n\nThe system will shortly be making a big difference between birds tagged in the wild and\n\nthose tagged in captivity. That difference could be modeled as two subclasses for Bird:\n\nWildBird and CaptiveBird. However, I can only use inheritance once, so if I want\n\nto use subclasses for wild versus captive, I’ll have to remove them for the species.\n\nWhen several subclasses are involved, I’ll tackle them one at a time, starting with a\n\nsimple one—in this case, EuropeanSwallow. I create an empty delegate class for the\n\ndelegate.\n\nClick here to view code image\n\nclass EuropeanSwallowDelegate { }\n\nI don’t put in any data or back­reference parameters yet. For this example, I’ll introduce\n\nthem as I need them.\n\nI need to decide where to handle the initialization of the delegate field. Here, since I\n\nhave all the information in the single data argument to the constructor, I decide to do it\n\nin the constructor. Since there are several delegates I could add, I make a function to\n\nselect the correct one based on the type code in the document.\n\nclass Bird…\n\nClick here to view code image\n\nconstructor(data) {\n\nwww.EBooksWorld.ir\n\nthis._name = data.name; this._plumage = data.plumage; this._speciesDelegate = this.selectSpeciesDelegate(data); }\n\nselectSpeciesDelegate(data) { switch(data.type) { case 'EuropeanSwallow': return new EuropeanSwallowDelegate(); default: return null; } }\n\nNow I have the structure set up, I can apply Move Function (198) to the European\n\nswallow’s air speed velocity.\n\nclass EuropeanSwallowDelegate…\n\nClick here to view code image\n\nget airSpeedVelocity() {return 35;}\n\nclass EuropeanSwallow…\n\nClick here to view code image\n\nget airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity;}\n\nI change airSpeedVelocity on the superclass to call a delegate, if present.\n\nclass Bird…\n\nClick here to view code image\n\nget airSpeedVelocity() { return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null; }\n\nI remove the subclass.\n\nClick here to view code image\n\nwww.EBooksWorld.ir\n\nclass EuropeanSwallow extends Bird { get airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity;} }\n\ntop level…\n\nClick here to view code image\n\nfunction createBird(data) { switch (data.type) { case 'EuropeanSwallow': return new EuropeanSwallow(data); case 'AfricanSwallow': return new AfricanSwallow(data); case 'NorweigianBlueParrot': return new NorwegianBlueParrot(data); default: return new Bird(data); } }\n\nNext I’ll tackle the African swallow. I create a class; this time, the constructor needs the\n\ndata document.\n\nclass AfricanSwallowDelegate…\n\nClick here to view code image\n\nconstructor(data) { this._numberOfCoconuts = data.numberOfCoconuts; }\n\nclass Bird…\n\nClick here to view code image\n\nselectSpeciesDelegate(data) { switch(data.type) { case 'EuropeanSwallow': return new EuropeanSwallowDelegate(); case 'AfricanSwallow': return new AfricanSwallowDelegate(data); default: return null; }\n\nwww.EBooksWorld.ir\n\n}\n\nI use Move Function (198) on airSpeedVelocity.\n\nclass AfricanSwallowDelegate…\n\nClick here to view code image\n\nget airSpeedVelocity() { return 40 ­ 2 * this._numberOfCoconuts; }\n\nclass AfricanSwallow…\n\nClick here to view code image\n\nget airSpeedVelocity() { return this._speciesDelegate.airSpeedVelocity; }\n\nI can now remove the African swallow subclass.\n\nClick here to view code image\n\nclass AfricanSwallow extends Bird { // all of the body ... }\n\nfunction createBird(data) { switch (data.type) { case 'AfricanSwallow': return new AfricanSwallow(data); case 'NorweigianBlueParrot': return new NorwegianBlueParrot(data); default: return new Bird(data); } }\n\nNow for the Norwegian blue. Creating the class and moving the air speed velocity uses\n\nthe same steps as before, so I’ll just show the result.\n\nclass Bird…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nselectSpeciesDelegate(data) { switch(data.type) { case 'EuropeanSwallow': return new EuropeanSwallowDelegate(); case 'AfricanSwallow': return new AfricanSwallowDelegate(data); case 'NorweigianBlueParrot': return new NorwegianBlueParrotDelegate(data); default: return null; } }\n\nclass NorwegianBlueParrotDelegate…\n\nClick here to view code image\n\nconstructor(data) { this._voltage = data.voltage; this._isNailed = data.isNailed; } get airSpeedVelocity() { return (this._isNailed) ? 0 : 10 + this._voltage / 10; }\n\nAll well and good, but the Norwegian blue overrides the plumage property, which I\n\ndidn’t have to deal with for the other cases. The initial Move Function (198) is simple\n\nenough, albeit with the need to modify the constructor to put in a back­reference to the\n\nbird.\n\nclass NorwegianBlueParrot…\n\nClick here to view code image\n\nget plumage() { return this._speciesDelegate.plumage; }\n\nclass NorwegianBlueParrotDelegate…\n\nClick here to view code image\n\nget plumage() {\n\nwww.EBooksWorld.ir\n\nif (this._voltage > 100) return \"scorched\"; else return this._bird._plumage || \"beautiful\"; }\n\nconstructor(data, bird) { this._bird = bird; this._voltage = data.voltage; this._isNailed = data.isNailed; }\n\nclass Bird…\n\nClick here to view code image\n\nselectSpeciesDelegate(data) { switch(data.type) { case 'EuropeanSwallow': return new EuropeanSwallowDelegate(); case 'AfricanSwallow': return new AfricanSwallowDelegate(data); case 'NorweigianBlueParrot': return new NorwegianBlueParrotDelegate(data, this); default: return null; } }\n\nThe tricky step is how to remove the subclass method for plumage. If I do\n\nclass Bird…\n\nClick here to view code image\n\nget plumage() { if (this._speciesDelegate) return this._speciesDelegate.plumage; else return this._plumage || \"average\"; }\n\nthen I’ll get a bunch of errors because there is no plumage property on the other\n\nspecies’ delegate classes.\n\nI could use a more precise conditional:\n\nclass Bird…\n\nwww.EBooksWorld.ir\n\nClick here to view code image\n\nget plumage() { if (this._speciesDelegate instanceof NorwegianBlueParrotDelegate) return this._speciesDelegate.plumage; else return this._plumage || \"average\"; }\n\nBut I hope that smells as much of decomposing parrot to you as it does to me. It’s\n\nalmost never a good idea to use an explicit class check like this.\n\nAnother option is to implement the default case on the other delegates.\n\nclass Bird…\n\nClick here to view code image\n\nget plumage() { if (this._speciesDelegate) return this._speciesDelegate.plumage; else return this._plumage || \"average\"; }\n\nclass EuropeanSwallowDelegate…\n\nClick here to view code image\n\nget plumage() { return this._bird._plumage || \"average\"; }\n\nclass AfricanSwallowDelegate…\n\nClick here to view code image\n\nget plumage() { return this._bird._plumage || \"average\"; }\n\nBut this duplicates the default method for plumage. And if that’s not bad enough, I also\n\nget some bonus duplication in the constructors to assign the back­reference.\n\nwww.EBooksWorld.ir\n\nThe solution to the duplication is, naturally, inheritance—I apply Extract Superclass\n\n(375) to the species delegates:\n\nClick here to view code image\n\nclass SpeciesDelegate { constructor(data, bird) { this._bird = bird; } get plumage() { return this._bird._plumage || \"average\"; }\n\nclass EuropeanSwallowDelegate extends SpeciesDelegate {\n\nclass AfricanSwallowDelegate extends SpeciesDelegate { constructor(data, bird) { super(data,bird); this._numberOfCoconuts = data.numberOfCoconuts; }\n\nclass NorwegianBlueParrotDelegate extends SpeciesDelegate { constructor(data, bird) { super(data, bird); this._voltage = data.voltage; this._isNailed = data.isNailed; }\n\nIndeed, now I have a superclass, I can move any default behavior from Bird to\n\nSpeciesDelegate by ensuring there’s always something in the speciesDelegate\n\nfield.\n\nclass Bird…\n\nClick here to view code image\n\nselectSpeciesDelegate(data) { switch(data.type) { case 'EuropeanSwallow': return new EuropeanSwallowDelegate(data, this); case 'AfricanSwallow': return new AfricanSwallowDelegate(data, this); case 'NorweigianBlueParrot': return new NorwegianBlueParrotDelegate(data, this); default: return new SpeciesDelegate(data, this); } } // rest of bird's code...\n\nwww.EBooksWorld.ir\n\nget plumage() {return this._speciesDelegate.plumage;}\n\nget airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity;}\n\nclass SpeciesDelegate…\n\nClick here to view code image\n\nget airSpeedVelocity() {return null;}\n\nI like this, as it simplifies the delegating methods on Bird. I can easily see which\n\nbehavior is delegated to the species delegate and which stays behind.\n\nHere’s the final state of these classes:\n\nClick here to view code image\n\nfunction createBird(data) { return new Bird(data); }\n\nclass Bird { constructor(data) { this._name = data.name; this._plumage = data.plumage; this._speciesDelegate = this.selectSpeciesDelegate(data); } get name() {return this._name;} get plumage() {return this._speciesDelegate.plumage;} get airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity;}\n\nselectSpeciesDelegate(data) { switch(data.type) { case 'EuropeanSwallow': return new EuropeanSwallowDelegate(data, this); case 'AfricanSwallow': return new AfricanSwallowDelegate(data, this); case 'NorweigianBlueParrot': return new NorwegianBlueParrotDelegate(data, this); default: return new SpeciesDelegate(data, this); } } // rest of bird's code... }\n\nclass SpeciesDelegate { constructor(data, bird) {\n\nwww.EBooksWorld.ir\n\nthis._bird = bird; } get plumage() { return this._bird._plumage || \"average\"; } get airSpeedVelocity() {return null;} }\n\nclass EuropeanSwallowDelegate extends SpeciesDelegate { get airSpeedVelocity() {return 35;} }\n\nclass AfricanSwallowDelegate extends SpeciesDelegate { constructor(data, bird) { super(data,bird); this._numberOfCoconuts = data.numberOfCoconuts; } get airSpeedVelocity() { return 40 ­ 2 * this._numberOfCoconuts; } }\n\nclass NorwegianBlueParrotDelegate extends SpeciesDelegate { constructor(data, bird) { super(data, bird); this._voltage = data.voltage; this._isNailed = data.isNailed; } get airSpeedVelocity() { return (this._isNailed) ? 0 : 10 + this._voltage / 10; } get plumage() { if (this._voltage > 100) return \"scorched\"; else return this._bird._plumage || \"beautiful\"; } }\n\nThis example replaces the original subclasses with a delegate, but there is still a very\n\nsimilar inheritance structure in SpeciesDelegate. Have I gained anything from this\n\nrefactoring, other than freeing up inheritance on Bird? The species inheritance is now\n\nmore tightly scoped, covering just the data and functions that vary due to the species.\n\nAny code that’s the same for all species remains on Bird and its future subclasses.\n\nI could apply the same idea of creating a superclass delegate to the booking example\n\nearlier. This would allow me to replace those methods on Booking that have dispatch\n\nlogic with simple calls to the delegate and letting its inheritance sort out the dispatch.\n\nHowever, it’s nearly dinner time, so I’ll leave that as an exercise for the reader.\n\nwww.EBooksWorld.ir",
      "page_number": 436
    },
    {
      "number": 45,
      "title": "Segment 45 (pages 447-455)",
      "start_page": 447,
      "end_page": 455,
      "detection_method": "topic_boundary",
      "content": "These examples illustrate that the phrase “Favor object composition over class\n\ninheritance” might better be said as “Favor a judicious mixture of composition and\n\ninheritance over either alone”—but I fear that is not as catchy.\n\nREPLACE SUPERCLASS WITH DELEGATE\n\nformerly: Replace Inheritance with Delegation\n\nMotivation\n\nIn object­oriented programs, inheritance is a powerful and easily available way to reuse\n\nexisting functionality. I inherit from some existing class, then override and add\n\nadditional features. But subclassing can be done in a way that leads to confusion and\n\ncomplication.\n\nOne of the classic examples of mis­inheritance from the early days of objects was\n\nmaking a stack be a subclass of list. The idea that led to this was reusing of list’s data\n\nstorage and operations to manipulate it. While it’s good to reuse, this inheritance had a\n\nproblem: All the operations of the list were present on the interface of the stack,\n\nalthough most of them were not applicable to a stack. A better approach is to make the\n\nlist into a field of the stack and delegate the necessary operations to it.\n\nThis is an example of one reason to use Replace Superclass with Delegate—if functions\n\nwww.EBooksWorld.ir\n\nof the superclass don’t make sense on the subclass, that’s a sign that I shouldn’t be\n\nusing inheritance to use the superclass’s functionality.\n\nAs well as using all the functions of the superclass, it should also be true that every\n\ninstance of the subclass is an instance of the superclass and a valid object in all cases\n\nwhere we’re using the superclass. If I have a car model class, with things like name and\n\nengine size, I might think I could reuse these features to represent a physical car,\n\nadding functions for VIN number and manufacturing date. This is a common, and often\n\nsubtle, modeling mistake which I’ve called the type­instance homonym [mf­tih].\n\nThese are both examples of problems leading to confusion and errors—which can be\n\neasily avoided by replacing inheritance with delegation to a separate object. Using\n\ndelegation makes it clear that it is a separate thing—one where only some of the\n\nfunctions carry over.\n\nEven in cases where the subclass is reasonable modeling, I use Replace Super­class with\n\nDelegate because the relationship between a sub­ and superclass is highly coupled, with\n\nthe subclass easily broken by changes in the superclass. The downside is that I need to\n\nwrite a forwarding function for any function that is the same in the host and in the\n\ndelegate—but, fortunately, even though such forwarding functions are boring to write,\n\nthey are too simple to get wrong.\n\nAs a consequence of all this, some people advise avoiding inheritance entirely—but I\n\ndon’t agree with that. Provided the appropriate semantic conditions apply (every\n\nmethod on the supertype applies to the subtype, every instance of the subtype is an\n\ninstance of the supertype), inheritance is a simple and effective mechanism. I can easily\n\napply Replace Superclass with Delegate should the situation change and inheritance is\n\nno longer the best option. So my advice is to (mostly) use inheritance first, and apply\n\nReplace Superclass with Delegate when (and if) it becomes a problem.\n\nMechanics\n\nCreate a field in the subclass that refers to the superclass object. Initialize this\n\ndelegate reference to a new instance.\n\nFor each element of the superclass, create a forwarding function in the subclass that\n\nforwards to the delegate reference. Test after forwarding each consistent group.\n\nMost of the time you can test after each function that’s forwarded, but, for example,\n\nget/set pairs can only be tested once both have been moved.\n\nwww.EBooksWorld.ir\n\nWhen all superclass elements have been overridden with forwarders, remove the\n\ninheritance link.\n\nExample\n\nI recently was consulting for an old town’s library of ancient scrolls. They keep details\n\nof their scrolls in a catalog. Each scroll has an ID number and records its title and list of\n\ntags.\n\nclass CatalogItem…\n\nClick here to view code image\n\nconstructor(id, title, tags) { this._id = id; this._title = title; this._tags = tags; }\n\nget id() {return this._id;} get title() {return this._title;} hasTag(arg) {return this._tags.includes(arg);}\n\nOne of the things that scrolls need is regular cleaning. The code for that uses the catalog\n\nitem and extends it with the data it needs for cleaning.\n\nclass Scroll extends CatalogItem…\n\nClick here to view code image\n\nconstructor(id, title, tags, dateLastCleaned) { super(id, title, tags); this._lastCleaned = dateLastCleaned; }\n\nneedsCleaning(targetDate) { const threshold = this.hasTag(\"revered\") ? 700 : 1500; return this.daysSinceLastCleaning(targetDate) > threshold ; } daysSinceLastCleaning(targetDate) { return this._lastCleaned.until(targetDate, ChronoUnit.DAYS); }\n\nThis is an example of a common modeling error. There is a difference between the\n\nphysical scroll and the catalog item. The scroll describing the treatment for the\n\nwww.EBooksWorld.ir\n\ngreyscale disease may have several copies, but be just one item in the catalog.\n\nIt many situations, I can get away with an error like this. I can think of the title and tags\n\nas copies of data in the catalog. Should this data never change, I can get away with this\n\nrepresentation. But if I need to update either, I must be careful to ensure that all copies\n\nof the same catalog item are updated correctly.\n\nEven without this issue, I’d still want to change the relationship. Using catalog item as a\n\nsuperclass to scroll is likely to confuse programmers in the future, and is thus a poor\n\nmodel to work with.\n\nI begin by creating a property in Scroll that refers to the catalog item, initializing it\n\nwith a new instance.\n\nclass Scroll extends CatalogItem…\n\nClick here to view code image\n\nconstructor(id, title, tags, dateLastCleaned) { super(id, title, tags); this._catalogItem = new CatalogItem(id, title, tags); this._lastCleaned = dateLastCleaned; }\n\nI create forwarding methods for each element of the superclass that I use on the\n\nsubclass.\n\nclass Scroll…\n\nClick here to view code image\n\nget id() {return this._catalogItem.id;} get title() {return this._catalogItem.title;} hasTag(aString) {return this._catalogItem.hasTag(aString);}\n\nI remove the inheritance link to the catalog item.\n\nClick here to view code image\n\nclass Scroll extends CatalogItem{ constructor(id, title, tags, dateLastCleaned) { super(id, title, tags); this._catalogItem = new CatalogItem(id, title, tags);\n\nwww.EBooksWorld.ir\n\nthis._lastCleaned = dateLastCleaned; }\n\nBreaking the inheritance link finishes the basic Replace Superclass with Delegate\n\nrefactoring, but there is something more I need to do in this case.\n\nThe refactoring shifts the role of the catalog item to that of a component of scroll; each\n\nscroll contains a unique instance of a catalog item. In many cases where I do this\n\nrefactoring, this is enough. However, in this situation a better model is to link the\n\ngreyscale catalog item to the six scrolls in the library that are copies of that writing.\n\nDoing this is, essentially, Change Value to Reference (256).\n\nThere’s a problem that I have to fix, however, before I use Change Value to Reference\n\n(256). In the original inheritance structure, the scroll used the catalog item’s ID field to\n\nstore its ID. But if I treat the catalog item as a reference, it needs to use that ID for the\n\ncatalog item ID rather than the scroll ID. This means I need to create an ID field on\n\nscroll and use that instead of one in catalog item. It’s a sort­of move, sort­of split.\n\nclass Scroll…\n\nClick here to view code image\n\nconstructor(id, title, tags, dateLastCleaned) { this._id = id; this._catalogItem = new CatalogItem(null, title, tags); this._lastCleaned = dateLastCleaned; }\n\nget id() {return this._id;}\n\nCreating a catalog item with a null ID would usually raise red flags and cause alarms to\n\nsound. But that’s just temporary while I get things into shape. Once I’ve done that, the\n\nscrolls will refer to a shared catalog item with its proper ID.\n\nCurrently the scrolls are loaded as part of a load routine.\n\nload routine…\n\nClick here to view code image\n\nconst scrolls = aDocument .map(record => new Scroll(record.id, record.catalogData.title,\n\nwww.EBooksWorld.ir\n\nrecord.catalogData.tags, LocalDate.parse(record.lastCleaned)));\n\nThe first step in Change Value to Reference (256) is finding or creating a repository. I\n\nfind there is a repository that I can easily import into the load routine. The repository\n\nsupplies catalog items indexed by an ID. My next task is to see how to get that ID into\n\nthe constructor of the scroll. Fortunately, it’s present in the input data and was being\n\nignored as it wasn’t useful when using inheritance. With that sorted out, I can now use\n\nChange Function Declaration (124) to add both the catalog and the catalog item’s ID to\n\nthe constructor parameters.\n\nload routine…\n\nClick here to view code image\n\nconst scrolls = aDocument .map(record => new Scroll(record.id, record.catalogData.title, record.catalogData.tags, LocalDate.parse(record.lastCleaned), record.catalogData.id, catalog));\n\nclass Scroll…\n\nClick here to view code image\n\nconstructor(id, title, tags, dateLastCleaned, catalogID, catalog) { this._id = id; this._catalogItem = new CatalogItem(null, title, tags); this._lastCleaned = dateLastCleaned; }\n\nI now modify the constructor to use the catalog ID to look up the catalog item and use it\n\ninstead of creating a new one.\n\nclass Scroll…\n\nClick here to view code image\n\nconstructor(id, title, tags, dateLastCleaned, catalogID, catalog) { this._id = id; this._catalogItem = catalog.get(catalogID);\n\nwww.EBooksWorld.ir\n\nthis._lastCleaned = dateLastCleaned; }\n\nI no longer need the title and tags passed into the constructor, so I use Change\n\nFunction Declaration (124) to remove them.\n\nload routine…\n\nClick here to view code image\n\nconst scrolls = aDocument .map(record => new Scroll(record.id, record.catalogData.title, record.catalogData.tags, LocalDate.parse(record.lastCleaned), record.catalogData.id, catalog));\n\nclass Scroll…\n\nClick here to view code image\n\nconstructor(id, title, tags, dateLastCleaned, catalogID, catalog) { this._id = id; this._catalogItem = catalog.get(catalogID); this._lastCleaned = dateLastCleaned; }\n\nwww.EBooksWorld.ir\n\nwww.EBooksWorld.ir\n\nwww.EBooksWorld.ir",
      "page_number": 447
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "content": "www.EBooksWorld.ir",
      "content_length": 18,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 2,
      "content": "History\n\nRefactoring\n\nTopics\n\nImproving the Design of Existing Code\n\nSecond Edition\n\nTutorials\n\nMartin Fowler\n\nOffers & Deals\n\nwith contributions by\n\nHighlights\n\nKent Beck\n\nSettings\n\nSupport\n\nBoston • Columbus • New York • San Francisco • Amsterdam • Cape Town\n\nDubai • London • Madrid • Milan • Munich • Paris • Montreal • Toronto • Delhi •\n\nSign Out\n\nMexico City\n\nSão Paulo • Sydney • Hong Kong • Seoul • Singapore • Taipei • Tokyo\n\nwww.EBooksWorld.ir",
      "content_length": 453,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 3,
      "content": "Playlists\n\nHistory\n\nMany of the designations used by manufacturers and sellers to distinguish their\n\nproducts are claimed as trademarks. Where those designations appear in this book, and\n\nTopics\n\nthe publisher was aware of a trademark claim, the designations have been printed with\n\ninitial capital letters or in all capitals.\n\nTutorials\n\nThe author and publisher have taken care in the preparation of this book, but make no\n\nOffers & Deals\n\nexpressed or implied warranty of any kind and assume no responsibility for errors or\n\nomissions. No liability is assumed for incidental or consequential damages in\n\nHighlights\n\nconnection with or arising out of the use of the information or programs contained\n\nherein.\n\nSettings\n\nFor information about buying this title in bulk quantities, or for special sales\n\nSupport\n\nopportunities (which may include electronic versions; custom cover designs; and\n\ncontent particular to your business, training goals, marketing focus, or branding\n\nSign Out\n\ninterests), please contact our corporate sales department at corpsales@pearsoned.com\n\nor (800) 382–3419.\n\nFor government sales inquiries, please contact governmentsales@pearsoned.com.\n\nFor questions about sales outside the U.S., please contact intlcs@pearson.com.\n\nVisit us on the Web: informit.com/aw\n\nLibrary of Congress Control Number: 2018950015\n\nCopyright © 2019 Pearson Education, Inc.\n\nCover photo: Waldo­Hancock Bridge & Penobscot Narrows Bridge by Martin Fowler\n\nLightbulb graphic: Irina Adamovich/Shutterstock\n\nAll rights reserved. Printed in the United States of America. This publication is\n\ni\n\nprotected by copyright, and permission must be obtained from the publisher prior to\n\nany prohibited reproduction, storage in a retrieval system, or transmission in any form\n\nor by any means, electronic, mechanical, photocopying, recording, or likewise. For\n\nwww.EBooksWorld.ir",
      "content_length": 1870,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 4,
      "content": "information regarding permissions, request forms and the appropriate contacts within\n\nthe Pearson Education Global Rights & Permissions Department, please visit\n\nwww.pearsoned.com/permissions/.\n\nISBN­13: 978­0­13­475759­9\n\nISBN­10: 0­13­475759­9\n\n1 18\n\nwww.EBooksWorld.ir",
      "content_length": 271,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 5,
      "content": "Chapter 1 Refactoring: A First Example\n\nHistory\n\nTopics\n\nHow do I begin to talk about refactoring? The traditional way is by introducing the\n\nhistory of the subject, broad principles, and the like. When somebody does that at a\n\nTutorials\n\nconference, I get slightly sleepy. My mind starts wandering, with a low­priority\n\nbackground process polling the speaker until they give an example.\n\nOffers & Deals\n\nThe examples wake me up because I can see what is going on. With principles, it is too\n\nHighlights\n\neasy to make broad generalizations—and too hard to figure out how to apply things. An\n\nexample helps make things clear.\n\nSettings\n\nSo I’m going to start this book with an example of refactoring. I’ll talk about how\n\nSupport\n\nrefactoring works and will give you a sense of the refactoring process. I can then do the\n\nSign Out\n\nusual principles­style introduction in the next chapter.\n\nWith any introductory example, however, I run into a problem. If I pick a large\n\nprogram, describing it and how it is refactored is too complicated for a mortal reader to\n\nwork through. (I tried this with the original book—and ended up throwing away two\n\nexamples, which were still pretty small but took over a hundred pages each to describe.)\n\nHowever, if I pick a program that is small enough to be comprehensible, refactoring\n\ndoes not look like it is worthwhile.\n\nI’m thus in the classic bind of anyone who wants to describe techniques that are useful\n\nfor real­world programs. Frankly, it is not worth the effort to do all the refactoring that\n\nI’m going to show you on the small program I will be using. But if the code I’m showing\n\nyou is part of a larger system, then the refactoring becomes important. Just look at my\n\nexample and imagine it in the context of a much larger system.\n\nTHE STARTING POINT\n\nIn the first edition of this book, my starting program printed a bill from a video rental\n\nstore, which may now lead many of you to ask: “What’s a video rental store?” Rather\n\nthan answer that question, I’ve reskinned the example to something that is both older\n\nwww.EBooksWorld.ir",
      "content_length": 2082,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 6,
      "content": "and still current.\n\nImage a company of theatrical players who go out to various events performing plays.\n\nTypically, a customer will request a few plays and the company charges them based on\n\nthe size of the audience and the kind of play they perform. There are currently two\n\nkinds of plays that the company performs: tragedies and comedies. As well as providing\n\na bill for the performance, the company gives its customers “volume credits” which they\n\ncan use for discounts on future performances—think of it as a customer loyalty\n\nmechanism.\n\nThe performers store data about their plays in a simple JSON file that looks something\n\nlike this:\n\nplays.json…\n\nClick here to view code image\n\n{ \"hamlet\": {\"name\": \"Hamlet\", \"type\": \"tragedy\"}, \"as­like\": {\"name\": \"As You Like It\", \"type\": \"comedy\"}, \"othello\": {\"name\": \"Othello\", \"type\": \"tragedy\"} }\n\nThe data for their bills also comes in a JSON file:\n\ninvoices.json…\n\nClick here to view code image\n\n[ { \"customer\": \"BigCo\", \"performances\": [ { \"playID\": \"hamlet\", \"audience\": 55 }, { \"playID\": \"as­like\", \"audience\": 35 }, { \"playID\": \"othello\", \"audience\": 40 }\n\nwww.EBooksWorld.ir",
      "content_length": 1134,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 7,
      "content": "] } ]\n\nThe code that prints the bill is this simple function:\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { const play = plays[perf.playID]; let thisAmount = 0;\n\nswitch (play.type) { case \"tragedy\": thisAmount = 40000; if (perf.audience > 30) { thisAmount += 1000 * (perf.audience ­ 30); } break; case \"comedy\": thisAmount = 30000; if (perf.audience > 20) { thisAmount += 10000 + 500 * (perf.audience ­ 20); } thisAmount += 300 * perf.audience; break; default: throw new Error(`unknown type: ${play.type}`); }\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === play.type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience} seats)\\n`; totalAmount += thisAmount; } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result; }\n\nwww.EBooksWorld.ir",
      "content_length": 1275,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 8,
      "content": "Running that code on the test data files above results in the following output:\n\nClick here to view code image\n\nStatement for BigCo Hamlet: $650.00 (55 seats) As You Like It: $580.00 (35 seats) Othello: $500.00 (40 seats) Amount owed is $1,730.00 You earned 47 credits\n\nCOMMENTS ON THE STARTING PROGRAM\n\nWhat are your thoughts on the design of this program? The first thing I’d say is that it’s\n\ntolerable as it is—a program so short doesn’t require any deep structure to be\n\ncomprehensible. But remember my earlier point that I have to keep examples small.\n\nImagine this program on a larger scale—perhaps hundreds of lines long. At that size, a\n\nsingle inline function is hard to understand.\n\nGiven that the program works, isn’t any statement about its structure merely an\n\naesthetic judgment, a dislike of “ugly” code? After all, the compiler doesn’t care whether\n\nthe code is ugly or clean. But when I change the system, there is a human involved, and\n\nhumans do care. A poorly designed system is hard to change—because it is difficult to\n\nfigure out what to change and how these changes will interact with the existing code to\n\nget the behavior I want. And if it is hard to figure out what to change, there is a good\n\nchance that I will make mistakes and introduce bugs.\n\nThus, if I’m faced with modifying a program with hundreds of lines of code, I’d rather it\n\nbe structured into a set of functions and other program elements that allow me to\n\nunderstand more easily what the program is doing. If the program lacks structure, it’s\n\nusually easier for me to add structure to the program first, and then make the change I\n\nneed.\n\nWhen you have to add a feature to a program but the code is not structured in\n\na convenient way, first refactor the program to make it easy to add the feature, then\n\nadd the feature.\n\nIn this case, I have a couple of changes that the users would like to make. First, they\n\nwant a statement printed in HTML. Consider what impact this change would have. I’m\n\nfaced with adding conditional statements around every statement that adds a string to\n\nwww.EBooksWorld.ir",
      "content_length": 2096,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 9,
      "content": "the result. That will add a host of complexity to the function. Faced with that, most\n\npeople prefer to copy the method and change it to emit HTML. Making a copy may not\n\nseem too onerous a task, but it sets up all sorts of problems for the future. Any changes\n\nto the charging logic would force me to update both methods—and to ensure they are\n\nupdated consistently. If I’m writing a program that will never change again, this kind of\n\ncopy­and­paste is fine. But if it’s a long­lived program, then duplication is a menace.\n\nThis brings me to a second change. The players are looking to perform more kinds of\n\nplays: they hope to add history, pastoral, pastoral­comical, historical­pastoral, tragical­\n\nhistorical, tragical­comical­historical­pastoral, scene individable, and poem unlimited\n\nto their repertoire. They haven’t exactly decided yet what they want to do and when.\n\nThis change will affect both the way their plays are charged for and the way volume\n\ncredits are calculated. As an experienced developer I can be sure that whatever scheme\n\nthey come up with, they will change it again within six months. After all, when feature\n\nrequests come, they come not as single spies but in battalions.\n\nAgain, that statement method is where the changes need to be made to deal with\n\nchanges in classification and charging rules. But if I copy statement to\n\nhtmlStatement, I’d need to ensure that any changes are consistent. Furthermore, as\n\nthe rules grow in complexity, it’s going to be harder to figure out where to make the\n\nchanges and harder to do them without making a mistake.\n\nLet me stress that it’s these changes that drive the need to perform refactoring. If the\n\ncode works and doesn’t ever need to change, it’s perfectly fine to leave it alone. It would\n\nbe nice to improve it, but unless someone needs to understand it, it isn’t causing any\n\nreal harm. Yet as soon as someone does need to understand how that code works, and\n\nstruggles to follow it, then you have to do something about it.\n\nTHE FIRST STEP IN REFACTORING\n\nWhenever I do refactoring, the first step is always the same. I need to ensure I have a\n\nsolid set of tests for that section of code. The tests are essential because even though I\n\nwill follow refactorings structured to avoid most of the opportunities for introducing\n\nbugs, I’m still human and still make mistakes. The larger a program, the more likely it\n\nis that my changes will cause something to break inadvertently—in the digital age,\n\nfrailty’s name is software.\n\nSince the statement returns a string, what I do is create a few invoices, give each\n\ninvoice a few performances of various kinds of plays, and generate the statement\n\nstrings. I then do a string comparison between the new string and some reference\n\nwww.EBooksWorld.ir",
      "content_length": 2777,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 10,
      "content": "strings that I have hand­checked. I set up all of these tests using a testing framework so\n\nI can run them with just a simple keystroke in my development environment. The tests\n\ntake only a few seconds to run, and as you will see, I run them often.\n\nAn important part of the tests is the way they report their results. They either go green,\n\nmeaning that all the strings are identical to the reference strings, or red, showing a list\n\nof failures—the lines that turned out differently. The tests are thus self­checking. It is\n\nvital to make tests self­checking. If I don’t, I’d end up spending time hand­checking\n\nvalues from the test against values on a desk pad, and that would slow me down.\n\nModern testing frameworks provide all the features needed to write and run self­\n\nchecking tests.\n\nBefore you start refactoring, make sure you have a solid suite of tests. These\n\ntests must be self­checking.\n\nAs I do the refactoring, I’ll lean on the tests. I think of them as a bug detector to protect\n\nme against my own mistakes. By writing what I want twice, in the code and in the test, I\n\nhave to make the mistake consistently in both places to fool the detector. By double­\n\nchecking my work, I reduce the chance of doing something wrong. Although it takes\n\ntime to build the tests, I end up saving that time, with considerable interest, by\n\nspending less time debugging. This is such an important part of refactoring that I\n\ndevote a full chapter to it (Building Tests (85)).\n\nDECOMPOSING THE STATEMENT FUNCTION\n\nWhen refactoring a long function like this, I mentally try to identify points that separate\n\ndifferent parts of the overall behavior. The first chunk that leaps to my eye is the switch\n\nstatement in the middle.\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { const play = plays[perf.playID]; let thisAmount = 0;\n\nwww.EBooksWorld.ir",
      "content_length": 2125,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 11,
      "content": "switch (play.type) { case \"tragedy\": thisAmount = 40000; if (perf.audience > 30) { thisAmount += 1000 * (perf.audience ­ 30); } break; case \"comedy\": thisAmount = 30000; if (perf.audience > 20) { thisAmount += 10000 + 500 * (perf.audience ­ 20); } thisAmount += 300 * perf.audience; break; default: throw new Error(`unknown type: ${play.type}`); }\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === play.type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience} seats)\\n`; totalAmount += thisAmount; } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result; }\n\nAs I look at this chunk, I conclude that it’s calculating the charge for one performance.\n\nThat conclusion is a piece of insight about the code. But as Ward Cunningham puts it,\n\nthis understanding is in my head—a notoriously volatile form of storage. I need to\n\npersist it by moving it from my head back into the code itself. That way, should I come\n\nback to it later, the code will tell me what it’s doing—I don’t have to figure it out again.\n\nThe way to put that understanding into code is to turn that chunk of code into its own\n\nfunction, naming it after what it does—something like amountFor(aPerformance).\n\nWhen I want to turn a chunk of code into a function like this, I have a procedure for\n\ndoing it that minimizes my chances of getting it wrong. I wrote down this procedure\n\nand, to make it easy to reference, named it Extract Function (106).\n\nFirst, I need to look in the fragment for any variables that will no longer be in scope\n\nonce I’ve extracted the code into its own function. In this case, I have three: perf,\n\nwww.EBooksWorld.ir",
      "content_length": 1862,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 12,
      "content": "play, and thisAmount. The first two are used by the extracted code, but not modified,\n\nso I can pass them in as parameters. Modified variables need more care. Here, there is\n\nonly one, so I can return it. I can also bring its initialization inside the extracted code.\n\nAll of which yields this:\n\nfunction statement…\n\nClick here to view code image\n\nfunction amountFor(perf, play) { let thisAmount = 0; switch (play.type) { case \"tragedy\": thisAmount = 40000; if (perf.audience > 30) { thisAmount += 1000 * (perf.audience ­ 30); } break; case \"comedy\": thisAmount = 30000; if (perf.audience > 20) { thisAmount += 10000 + 500 * (perf.audience ­ 20); } thisAmount += 300 * perf.audience; break; default: throw new Error(`unknown type: ${play.type}`); } return thisAmount; }\n\nWhen I use a header like “function someName…” in italics for some code, that means\n\nthat the following code is within the scope of the function, file, or class named in the\n\nheader. There is usually other code within that scope that I won’t show, as I’m not\n\ndiscussing it at the moment.\n\nThe original statement code now calls this function to populate thisAmount:\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`;\n\nwww.EBooksWorld.ir",
      "content_length": 1333,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 13,
      "content": "const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { const play = plays[perf.playID]; let thisAmount = amountFor(perf, play);\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === play.type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience} seats)\\n`; totalAmount += thisAmount; } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nOnce I’ve made this change, I immediately compile and test to see if I’ve broken\n\nanything. It’s an important habit to test after every refactoring, however simple.\n\nMistakes are easy to make—at least, I find them easy to make. Testing after each change\n\nmeans that when I make a mistake, I only have a small change to consider in order to\n\nspot the error, which makes it far easier to find and fix. This is the essence of the\n\nrefactoring process: small changes and testing after each change. If I try to do too\n\nmuch, making a mistake will force me into a tricky debugging episode that can take a\n\nlong time. Small changes, enabling a tight feedback loop, are the key to avoiding that\n\nmess.\n\nI use compile here to mean doing whatever is needed to make the JavaScript\n\nexecutable. Since JavaScript is directly executable, that may mean nothing, but in other\n\ncases it may mean moving code to an output directory and/or using a processor such as\n\nBabel [babel].\n\nRefactoring changes the programs in small steps, so if you make a mistake, it\n\nis easy to find where the bug is.\n\nThis being JavaScript, I can extract amountFor into a nested function of statement.\n\nThis is helpful as it means I don’t have to pass data that’s inside the scope of the\n\ncontaining function to the newly extracted function. That doesn’t make a difference in\n\nthis case, but it’s one less issue to deal with.\n\nwww.EBooksWorld.ir",
      "content_length": 2103,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 14,
      "content": "In this case the tests passed, so my next step is to commit the change to my local\n\nversion control system. I use a version control system, such as git or mercurial, that\n\nallows me to make private commits. I commit after each successful refactoring, so I can\n\neasily get back to a working state should I mess up later. I then squash changes into\n\nmore significant commits before I push the changes to a shared repository.\n\nExtract Function (106) is a common refactoring to automate. If I was programming in\n\nJava, I would have instinctively reached for the key sequence for my IDE to perform\n\nthis refactoring. As I write this, there is no such robust support for this refactoring in\n\nJavaScript tools, so I have to do this manually. It’s not hard, although I have to be\n\ncareful with those locally scoped variables.\n\nOnce I’ve used Extract Function (106), I take a look at what I’ve extracted to see if there\n\nare any quick and easy things I can do to clarify the extracted function. The first thing I\n\ndo is rename some of the variables to make them clearer, such as changing\n\nthisAmount to result.\n\nfunction statement…\n\nClick here to view code image\n\nfunction amountFor(perf, play) { let result = 0; switch (play.type) { case \"tragedy\": result = 40000; if (perf.audience > 30) { result += 1000 * (perf.audience ­ 30); } break; case \"comedy\": result = 30000; if (perf.audience > 20) { result += 10000 + 500 * (perf.audience ­ 20); } result += 300 * perf.audience; break; default: throw new Error(`unknown type: ${play.type}`); } return result; }\n\nIt’s my coding standard to always call the return value from a function “result”. That\n\nway I always know its role. Again, I compile, test, and commit. Then I move onto the\n\nwww.EBooksWorld.ir",
      "content_length": 1742,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 15,
      "content": "first argument.\n\nfunction statement…\n\nClick here to view code image\n\nfunction amountFor(aPerformance, play) { let result = 0; switch (play.type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${play.type}`); } return result; }\n\nAgain, this is following my coding style. With a dynamically typed language such as\n\nJavaScript, it’s useful to keep track of types—hence, my default name for a parameter\n\nincludes the type name. I use an indefinite article with it unless there is some specific\n\nrole information to capture in the name. I learned this convention from Kent Beck\n\n[Beck SBPP] and continue to find it helpful.\n\nAny fool can write code that a computer can understand. Good programmers\n\nwrite code that humans can understand.\n\nIs this renaming worth the effort? Absolutely. Good code should clearly communicate\n\nwhat it is doing, and variable names are a key to clear code. Never be afraid to change\n\nnames to improve clarity. With good find­and­replace tools, it is usually not difficult;\n\ntesting, and static typing in a language that supports it, will highlight any occurrences\n\nyou miss. And with automated refactoring tools, it’s trivial to rename even widely used\n\nfunctions.\n\nwww.EBooksWorld.ir",
      "content_length": 1492,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 16,
      "content": "The next item to consider for renaming is the play parameter, but I have a different\n\nfate for that.\n\nRemoving the play Variable\n\nAs I consider the parameters to amountFor, I look to see where they come from.\n\naPerformance comes from the loop variable, so naturally changes with each iteration\n\nthrough the loop. But play is computed from the performance, so there’s no need to\n\npass it in as a parameter at all—I can just recalculate it within amountFor. When I’m\n\nbreaking down a long function, I like to get rid of variables like play, because\n\ntemporary variables create a lot of locally scoped names that complicate extractions.\n\nThe refactoring I will use here is Replace Temp with Query (178).\n\nI begin by extracting the right­hand side of the assignment into a function.\n\nfunction statement…\n\nClick here to view code image\n\nfunction playFor(aPerformance) { return plays[aPerformance.playID]; }\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { const play = playFor(perf); let thisAmount = amountFor(perf, play);\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === play.type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${play.name}: ${format(thisAmount/100)} (${perf.audience} seats)\\n`;\n\nwww.EBooksWorld.ir",
      "content_length": 1639,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 17,
      "content": "totalAmount += thisAmount; } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nI compile­test­commit, and then use Inline Variable (123).\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { const play = playFor(perf); let thisAmount = amountFor(perf, playFor(perf));\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(thisAmount/100)} (${perf.audience} seats)\\n`; totalAmount += thisAmount; } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nI compile­test­commit. With that inlined, I can then apply Change Function\n\nDeclaration (124) to amountFor to remove the play parameter. I do this in two steps.\n\nFirst, I use the new function inside amountFor.\n\nfunction statement…\n\nClick here to view code image\n\nfunction amountFor(aPerformance, play) { let result = 0;\n\nwww.EBooksWorld.ir",
      "content_length": 1449,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 18,
      "content": "switch (playFor(aPerformance).type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${playFor(aPerformance).type}`); } return result; }\n\nI compile­test­commit, and then delete the parameter.\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { let thisAmount = amountFor(perf, playFor(perf));\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(thisAmount/100)} (${perf.audience} seats)\\n`; totalAmount += thisAmount; } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nwww.EBooksWorld.ir",
      "content_length": 1362,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 19,
      "content": "function statement…\n\nClick here to view code image\n\nfunction amountFor(aPerformance, play) { let result = 0; switch (playFor(aPerformance).type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${playFor(aPerformance).type}`); } return result; }\n\nAnd compile­test­commit again.\n\nThis refactoring alarms some programmers. Previously, the code to look up the play\n\nwas executed once in each loop iteration; now, it’s executed thrice. I’ll talk about the\n\ninterplay of refactoring and performance later, but for the moment I’ll just observe that\n\nthis change is unlikely to significantly affect performance, and even if it were, it is much\n\neasier to improve the performance of a well­factored code base.\n\nThe great benefit of removing local variables is that it makes it much easier to do\n\nextractions, since there is less local scope to deal with. Indeed, usually I’ll take out local\n\nvariables before I do any extractions.\n\nNow that I’m done with the arguments to amountFor, I look back at where it’s called.\n\nIt’s being used to set a temporary variable that’s not updated again, so I apply Inline\n\nVariable (123).\n\ntop level…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1459,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 20,
      "content": "function statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) {\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nExtracting Volume Credits\n\nHere’s the current state of the statement function body:\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) {\n\n// add volume credits volumeCredits += Math.max(perf.audience ­ 30, 0); // add extra credit for every ten comedy attendees if (\"comedy\" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } result += `Amount owed is ${format(totalAmount/100)}\\n`;\n\nwww.EBooksWorld.ir",
      "content_length": 1654,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 21,
      "content": "result += `You earned ${volumeCredits} credits\\n`; return result;\n\nNow I get the benefit from removing the play variable as it makes it easier to extract\n\nthe volume credits calculation by removing one of the locally scoped variables.\n\nI still have to deal with the other two. Again, perf is easy to pass in, but\n\nvolumeCredits is a bit more tricky as it is an accumulator updated in each pass of the\n\nloop. So my best bet is to initialize a shadow of it inside the extracted function and\n\nreturn it.\n\nfunction statement…\n\nClick here to view code image\n\nfunction volumeCreditsFor(perf) { let volumeCredits = 0; volumeCredits += Math.max(perf.audience ­ 30, 0); if (\"comedy\" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5); return volumeCredits; }\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { volumeCredits += volumeCreditsFor(perf);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nwww.EBooksWorld.ir",
      "content_length": 1451,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 22,
      "content": "I remove the unnecessary (and, in this case, downright misleading) comment.\n\nI compile­test­commit that, and then rename the variables inside the new function.\n\nfunction statement…\n\nClick here to view code image\n\nfunction volumeCreditsFor(aPerformance) { let result = 0; result += Math.max(aPerformance.audience ­ 30, 0); if (\"comedy\" === playFor(aPerformance).type) result += Math.floor(aPerformance.audience / 5); return result; }\n\nI’ve shown it in one step, but as before I did the renames one at a time, with a compile­\n\ntest­commit after each.\n\nRemoving the format Variable\n\nLet’s look at the main statement method again:\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; const format = new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format; for (let perf of invoice.performances) { volumeCredits += volumeCreditsFor(perf);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nwww.EBooksWorld.ir",
      "content_length": 1308,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 23,
      "content": "As I suggested before, temporary variables can be a problem. They are only useful\n\nwithin their own routine, and therefore they encourage long, complex routines. My next\n\nmove, then, is to replace some of them. The easiest one is format. This is a case of\n\nassigning a function to a temp, which I prefer to replace with a declared function.\n\nfunction statement…\n\nClick here to view code image\n\nfunction format(aNumber) { return new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format(aNumber); }\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { volumeCredits += volumeCreditsFor(perf);\n\n// print line for this order result += ` ${playFor(perf).name}: ${format(amountFor(perf)/100)} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } result += `Amount owed is ${format(totalAmount/100)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nAlthough changing a function variable to a declared function is a refactoring, I haven’t\n\nnamed it and included it in the catalog. There are many refactorings that I didn’t feel\n\nimportant enough for that. This one is both simple to do and relatively rare, so I didn’t\n\nthink it was worthwhile.\n\nI’m not keen on the name—“format” doesn’t really convey enough of what it’s doing.\n\n“formatAsUSD” would be a bit too long­winded since it’s being used in a string\n\ntemplate, particularly within this small scope. I think the fact that it’s formatting a\n\ncurrency amount is the thing to highlight here, so I pick a name that suggests that and\n\nwww.EBooksWorld.ir",
      "content_length": 1743,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 24,
      "content": "apply Change Function Declaration (124).\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { volumeCredits += volumeCreditsFor(perf);\n\n// print line for this order result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } result += `Amount owed is ${usd(totalAmount)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nfunction statement…\n\nClick here to view code image\n\nfunction usd(aNumber) { return new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format(aNumber/100); }\n\nNaming is both important and tricky. Breaking a large function into smaller ones only\n\nadds value if the names are good. With good names, I don’t have to read the body of the\n\nfunction to see what it does. But it’s hard to get names right the first time, so I use the\n\nbest name I can think of for the moment, and don’t hesitate to rename it later. Often, it\n\ntakes a second pass through some code to realize what the best name really is.\n\nAs I’m changing the name, I also move the duplicated division by 100 into the function.\n\nStoring money as integer cents is a common approach—it avoids the dangers of storing\n\nfractional monetary values as floats but allows me to use arithmetic operators.\n\nWhenever I want to display such a penny­integer number, however, I need a decimal,\n\nso my formatting function should take care of the division.\n\nwww.EBooksWorld.ir\n\nRemoving Total Volume Credits",
      "content_length": 1664,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 25,
      "content": "Removing Total Volume Credits\n\nMy next target variable is volumeCredits. This is a trickier case, as it’s built up\n\nduring the iterations of the loop. My first move, then, is to use Split Loop (227) to\n\nseparate the accumulation of volumeCredits.\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let volumeCredits = 0; let result = `Statement for ${invoice.customer}\\n`;\n\nfor (let perf of invoice.performances) {\n\n// print line for this order result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } for (let perf of invoice.performances) { volumeCredits += volumeCreditsFor(perf); }\n\nresult += `Amount owed is ${usd(totalAmount)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nWith that done, I can use Slide Statements (223) to move the declaration of the variable\n\nnext to the loop.\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) {\n\n// print line for this order result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } let volumeCredits = 0; for (let perf of invoice.performances) {\n\nwww.EBooksWorld.ir",
      "content_length": 1360,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 26,
      "content": "volumeCredits += volumeCreditsFor(perf); } result += `Amount owed is ${usd(totalAmount)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nGathering together everything that updates the volumeCredits variable makes it\n\neasier to do Replace Temp with Query (178). As before, the first step is to apply Extract\n\nFunction (106) to the overall calculation of the variable.\n\nfunction statement…\n\nClick here to view code image\n\nfunction totalVolumeCredits() { let volumeCredits = 0; for (let perf of invoice.performances) { volumeCredits += volumeCreditsFor(perf); } return volumeCredits; }\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) {\n\n// print line for this order result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); } let volumeCredits = totalVolumeCredits(); result += `Amount owed is ${usd(totalAmount)}\\n`; result += `You earned ${volumeCredits} credits\\n`; return result;\n\nOnce everything is extracted, I can apply Inline Variable (123):\n\ntop level…\n\nwww.EBooksWorld.ir",
      "content_length": 1209,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 27,
      "content": "Click here to view code image\n\nfunction statement (invoice, plays) { let totalAmount = 0; let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) {\n\n// print line for this order result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; totalAmount += amountFor(perf); }\n\nresult += `Amount owed is ${usd(totalAmount)}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nLet me pause for a bit to talk about what I’ve just done here. Firstly, I know readers will\n\nagain be worrying about performance with this change, as many people are wary of\n\nrepeating a loop. But most of the time, rerunning a loop like this has a negligible effect\n\non performance. If you timed the code before and after this refactoring, you would\n\nprobably not notice any significant change in speed—and that’s usually the case. Most\n\nprogrammers, even experienced ones, are poor judges of how code actually performs.\n\nMany of our intuitions are broken by clever compilers, modern caching techniques, and\n\nthe like. The performance of software usually depends on just a few parts of the code,\n\nand changes anywhere else don’t make an appreciable difference.\n\nBut “mostly” isn’t the same as “alwaysly.” Sometimes a refactoring will have a\n\nsignificant performance implication. Even then, I usually go ahead and do it, because\n\nit’s much easier to tune the performance of well­factored code. If I introduce a\n\nsignificant performance issue during refactoring, I spend time on performance tuning\n\nafterwards. It may be that this leads to reversing some of the refactoring I did earlier—\n\nbut most of the time, due to the refactoring, I can apply a more effective performance­\n\ntuning enhancement instead. I end up with code that’s both clearer and faster.\n\nSo, my overall advice on performance with refactoring is: Most of the time you should\n\nignore it. If your refactoring introduces performance slow­downs, finish refactoring\n\nfirst and do performance tuning afterwards.\n\nThe second aspect I want to call your attention to is how small the steps were to remove\n\nvolumeCredits. Here are the four steps, each followed by compiling, testing, and\n\ncommitting to my local source code repository:\n\nwww.EBooksWorld.ir",
      "content_length": 2273,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 28,
      "content": "Split Loop (227) to isolate the accumulation\n\nSlide Statements (223) to bring the initializing code next to the accumulation\n\nExtract Function (106) to create a function for calculating the total\n\nInline Variable (123) to remove the variable completely\n\nI confess I don’t always take quite as short steps as these—but whenever things get\n\ndifficult, my first reaction is to take shorter steps. In particular, should a test fail during\n\na refactoring, if I can’t immediately see and fix the problem, I’ll revert to my last good\n\ncommit and redo what I just did with smaller steps. That works because I commit so\n\nfrequently and because small steps are the key to moving quickly, particularly when\n\nworking with difficult code.\n\nI then repeat that sequence to remove totalAmount. I start by splitting the loop\n\n(compile­test­commit), then I slide the variable initialization (compile­test­commit),\n\nand then I extract the function. There is a wrinkle here: The best name for the function\n\nis “totalAmount”, but that’s the name of the variable, and I can’t have both at the same\n\ntime. So I give the new function a random name when I extract it (and compile­test­\n\ncommit).\n\nfunction statement…\n\nClick here to view code image\n\nfunction appleSauce() { let totalAmount = 0; for (let perf of invoice.performances) { totalAmount += amountFor(perf); } return totalAmount; }\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; }\n\nwww.EBooksWorld.ir",
      "content_length": 1650,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 29,
      "content": "let totalAmount = appleSauce();\n\nresult += `Amount owed is ${usd(totalAmount)}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nThen I inline the variable (compile­test­commit) and rename the function to something\n\nmore sensible (compile­test­commit).\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction statement…\n\nClick here to view code image\n\nfunction totalAmount() { let totalAmount = 0; for (let perf of invoice.performances) { totalAmount += amountFor(perf); } return totalAmount; }\n\nI also take the opportunity to change the names inside my extracted functions to adhere\n\nto my convention.\n\nfunction statement…\n\nClick here to view code image\n\nfunction totalAmount() { let result = 0;\n\nwww.EBooksWorld.ir",
      "content_length": 1088,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 30,
      "content": "for (let perf of invoice.performances) { result += amountFor(perf); } return result; } function totalVolumeCredits() { let result = 0; for (let perf of invoice.performances) { result += volumeCreditsFor(perf); } return result; }\n\nSTATUS: LOTS OF NESTED FUNCTIONS\n\nNow is a good time to pause and take a look at the overall state of the code:\n\nClick here to view code image\n\nfunction statement (invoice, plays) {\n\nlet result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction totalAmount() {\n\nlet result = 0; for (let perf of invoice.performances) { result += amountFor(perf); } return result; }\n\nfunction totalVolumeCredits() {\n\nlet result = 0; for (let perf of invoice.performances) { result += volumeCreditsFor(perf); } return result; } function usd(aNumber) {\n\nreturn new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format(aNumber/100); } function volumeCreditsFor(aPerformance) {\n\nlet result = 0; result += Math.max(aPerformance.audience ­ 30, 0);\n\nwww.EBooksWorld.ir",
      "content_length": 1276,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 31,
      "content": "if (\"comedy\" === playFor(aPerformance).type) result += Math.floor(aPerformance.audience / 5); return result; } function playFor(aPerformance) {\n\nreturn plays[aPerformance.playID]; } function amountFor(aPerformance) {\n\nlet result = 0; switch (playFor(aPerformance).type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${playFor(aPerformance).type}`); } return result; } }\n\nThe structure of the code is much better now. The top­level statement function is now\n\njust seven lines of code, and all it does is laying out the printing of the statement. All the\n\ncalculation logic has been moved out to a handful of supporting functions. This makes\n\nit easier to understand each individual calculation as well as the overall flow of the\n\nreport.\n\nSPLITTING THE PHASES OF CALCULATION AND FORMATTING\n\nSo far, my refactoring has focused on adding enough structure to the function so that I\n\ncan understand it and see it in terms of its logical parts. This is often the case early in\n\nrefactoring. Breaking down complicated chunks into small pieces is important, as is\n\nnaming things well. Now, I can begin to focus more on the functionality change I want\n\nto make—specifically, providing an HTML version of this statement. In many ways, it’s\n\nnow much easier to do. With all the calculation code split out, all I have to do is write an\n\nHTML version of the seven lines of code at the top. The problem is that these broken­\n\nout functions are nested within the textual statement method, and I don’t want to copy\n\nwww.EBooksWorld.ir",
      "content_length": 1803,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 32,
      "content": "and paste them into a new function, however well organized. I want the same\n\ncalculation functions to be used by the text and HTML versions of the statement.\n\nThere are various ways to do this, but one of my favorite techniques is Split Phase (154).\n\nMy aim here is to divide the logic into two parts: one that calculates the data required\n\nfor the statement, the other that renders it into text or HTML. The first phase creates\n\nan intermediate data structure that it passes to the second.\n\nI start a Split Phase (154) by applying Extract Function (106) to the code that makes up\n\nthe second phase. In this case, that’s the statement printing code, which is in fact the\n\nentire content of statement. This, together with all the nested functions, goes into its\n\nown top­level function which I call renderPlainText.\n\nClick here to view code image\n\nfunction statement (invoice, plays) {\n\nreturn renderPlainText(invoice, plays); }\n\nfunction renderPlainText(invoice, plays) {\n\nlet result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction totalAmount() {...} function totalVolumeCredits() {...} function usd(aNumber) {...} function volumeCreditsFor(aPerformance) {...} function playFor(aPerformance) {...} function amountFor(aPerformance) {...}\n\nI do my usual compile­test­commit, then create an object that will act as my\n\nintermediate data structure between the two phases. I pass this data object in as an\n\nargument to renderPlainText (compile­test­commit).\n\nClick here to view code image\n\nfunction statement (invoice, plays) { const statementData = {}; return renderPlainText(statementData, invoice, plays); }\n\nwww.EBooksWorld.ir",
      "content_length": 1885,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 33,
      "content": "function renderPlainText(data, invoice, plays) { let result = `Statement for ${invoice.customer}\\n`; for (let perf of invoice.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction totalAmount() {...} function totalVolumeCredits() {...} function usd(aNumber) {...} function volumeCreditsFor(aPerformance) {...} function playFor(aPerformance) {...} function amountFor(aPerformance) {...}\n\nI now examine the other arguments used by renderPlainText. I want to move the\n\ndata that comes from them into the intermediate data structure, so that all the\n\ncalculation code moves into the statement function and renderPlainText operates\n\nsolely on data passed to it through the data parameter.\n\nMy first move is to take the customer and add it to the intermediate object (compile­\n\ntest­commit).\n\nClick here to view code image\n\nfunction statement (invoice, plays) { const statementData = {}; statementData.customer = invoice.customer; return renderPlainText(statementData, invoice, plays); }\n\nfunction renderPlainText(data, invoice, plays) { let result = `Statement for ${data.customer}\\n`; for (let perf of invoice.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nSimilarly, I add the performances, which allows me to delete the invoice parameter to\n\nrenderPlainText (compile­test­commit).\n\nwww.EBooksWorld.ir",
      "content_length": 1670,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 34,
      "content": "top level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { const statementData = {}; statementData.customer = invoice.customer; statementData.performances = invoice.performances; return renderPlainText(statementData, invoice, plays); }\n\nfunction renderPlainText(data, plays) { let result = `Statement for ${data.customer}\\n`; for (let perf of data.performances) { result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction renderPlainText…\n\nClick here to view code image\n\nfunction totalAmount() { let result = 0; for (let perf of data.performances) { result += amountFor(perf); } return result; } function totalVolumeCredits() { let result = 0; for (let perf of data.performances) { result += volumeCreditsFor(perf); } return result; }\n\nNow I’d like the play name to come from the intermediate data. To do this, I need to\n\nenrich the performance record with data from the play (compile­test­commit).\n\nClick here to view code image\n\nfunction statement (invoice, plays) { const statementData = {};\n\nwww.EBooksWorld.ir",
      "content_length": 1203,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 35,
      "content": "statementData.customer = invoice.customer; statementData.performances = invoice.performances.map(enrichPerformance); return renderPlainText(statementData, plays);\n\nfunction enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); return result; }\n\nAt the moment, I’m just making a copy of the performance object, but I’ll shortly add\n\ndata to this new record. I take a copy because I don’t want to modify the data passed\n\ninto the function. I prefer to treat data as immutable as much as I can—mutable state\n\nquickly becomes something rotten.\n\nThe idiom result = Object.assign({}, aPerformance) looks very odd to\n\npeople unfamiliar to JavaScript. It performs a shallow copy. I’d prefer to have a\n\nfunction for this, but it’s one of those cases where the idiom is so baked into JavaScript\n\nusage that writing my own function would look out of place for JavaScript\n\nprogrammers.\n\nNow I have a spot for the play, I need to add it. To do that, I need to apply Move\n\nFunction (198) to playFor and statement (compile­test­commit).\n\nfunction statement…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); result.play = playFor(result); return result; }\n\nfunction playFor(aPerformance) { return plays[aPerformance.playID]; }\n\nI then replace all the references to playFor in renderPlainText to use the data\n\ninstead (compile­test­commit).\n\nfunction renderPlainText…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1503,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 36,
      "content": "let result = `Statement for ${data.customer}\\n`; for (let perf of data.performances) { result += ` ${perf.play.name}: ${usd(amountFor(perf))} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction volumeCreditsFor(aPerformance) { let result = 0; result += Math.max(aPerformance.audience ­ 30, 0); if (\"comedy\" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5); return result; }\n\nfunction amountFor(aPerformance) { let result = 0; switch (aPerformance.play.type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${aPerformance.play.type}`); } return result; }\n\nI then move amountFor in a similar way (compile­test­commit).\n\nfunction statement…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); result.play = playFor(result); result.amount = amountFor(result); return result; }\n\nwww.EBooksWorld.ir",
      "content_length": 1287,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 37,
      "content": "function amountFor(aPerformance) {...}\n\nfunction renderPlainText…\n\nClick here to view code image\n\nlet result = `Statement for ${data.customer}\\n`; for (let perf of data.performances) { result += ` ${perf.play.name}: ${usd(perf.amount)} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(totalAmount())}\\n`; result += `You earned ${totalVolumeCredits()} credits\\n`; return result;\n\nfunction totalAmount() { let result = 0; for (let perf of data.performances) { result += perf.amount; } return result; }\n\nNext, I move the volume credits calculation (compile­test­commit).\n\nfunction statement…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); result.play = playFor(result); result.amount = amountFor(result); result.volumeCredits = volumeCreditsFor(result); return result; }\n\nfunction volumeCreditsFor(aPerformance) {...}\n\nfunction renderPlainText…\n\nClick here to view code image\n\nfunction totalVolumeCredits() { let result = 0;\n\nwww.EBooksWorld.ir",
      "content_length": 1031,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 38,
      "content": "for (let perf of data.performances) { result += perf.volumeCredits; } return result; }\n\nFinally, I move the two calculations of the totals.\n\nfunction statement…\n\nClick here to view code image\n\nconst statementData = {}; statementData.customer = invoice.customer; statementData.performances = invoice.performances.map(enrichPerformance); statementData.totalAmount = totalAmount(statementData); statementData.totalVolumeCredits = totalVolumeCredits(statementData); return renderPlainText(statementData, plays);\n\nfunction totalAmount(data) {...} function totalVolumeCredits(data) {...}\n\nfunction renderPlainText…\n\nClick here to view code image\n\nlet result = `Statement for ${data.customer}\\n`; for (let perf of data.performances) { result += ` ${perf.play.name}: ${usd(perf.amount)} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(data.totalAmount)}\\n`; result += `You earned ${data.totalVolumeCredits} credits\\n`; return result;\n\nAlthough I could have modified the bodies of these totals functions to use the\n\nstatementData variable (as it’s within scope), I prefer to pass the explicit parameter.\n\nAnd, once I’m done with compile­test­commit after the move, I can’t resist a couple\n\nquick shots of Replace Loop with Pipeline (231).\n\nfunction renderPlainText…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1322,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 39,
      "content": "function totalAmount(data) { return data.performances .reduce((total, p) => total + p.amount, 0); } function totalVolumeCredits(data) { return data.performances .reduce((total, p) => total + p.volumeCredits, 0); }\n\nI now extract all the first­phase code into its own function (compile­test­commit).\n\ntop level…\n\nClick here to view code image\n\nfunction statement (invoice, plays) { return renderPlainText(createStatementData(invoice, plays)); }\n\nfunction createStatementData(invoice, plays) { const statementData = {}; statementData.customer = invoice.customer; statementData.performances = invoice.performances.map(enrichPerformance); statementData.totalAmount = totalAmount(statementData); statementData.totalVolumeCredits = totalVolumeCredits(statementData); return statementData;\n\nSince it’s clearly separate now, I move it to its own file (and alter the name of the\n\nreturned result to match my usual convention).\n\nstatement.js…\n\nClick here to view code image\n\nimport createStatementData from './createStatementData.js';\n\ncreateStatementData.js…\n\nClick here to view code image\n\nexport default function createStatementData(invoice, plays) { const result = {}; result.customer = invoice.customer; result.performances = invoice.performances.map(enrichPerformance);\n\nwww.EBooksWorld.ir",
      "content_length": 1285,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 40,
      "content": "result.totalAmount = totalAmount(result); result.totalVolumeCredits = totalVolumeCredits(result); return result;\n\nfunction enrichPerformance(aPerformance) {...} function playFor(aPerformance) {...} function amountFor(aPerformance) {...} function volumeCreditsFor(aPerformance) {...} function totalAmount(data) {...} function totalVolumeCredits(data) {...}\n\nOne final swing of compile­test­commit—and now it’s easy to write an HTML version.\n\nstatement.js…\n\nClick here to view code image\n\nfunction htmlStatement (invoice, plays) { return renderHtml(createStatementData(invoice, plays)); } function renderHtml (data) { let result = `<h1>Statement for ${data.customer}</h1>\\n`; result += \"<table>\\n\"; result += \"<tr><th>play</th><th>seats</th><th>cost</th></tr>\"; for (let perf of data.performances) { result += ` <tr><td>${perf.play.name}</td><td>${perf.audience}</td>`; result += `<td>${usd(perf.amount)}</td></tr>\\n`; } result += \"</table>\\n\"; result += `<p>Amount owed is <em>${usd(data.totalAmount)}</em></p>\\n`; result += `<p>You earned <em>${data.totalVolumeCredits}</em> credits</p>\\n`; return result; }\n\nfunction usd(aNumber) {...}\n\n(I moved usd to the top level, so that renderHtml could use it.)\n\nSTATUS: SEPARATED INTO TWO FILES (AND PHASES)\n\nThis is a good moment to take stock again and think about where the code is now. I\n\nhave two files of code.\n\nstatement.js\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1423,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 41,
      "content": "import createStatementData from './createStatementData.js'; function statement (invoice, plays) { return renderPlainText(createStatementData(invoice, plays)); } function renderPlainText(data, plays) { let result = `Statement for ${data.customer}\\n`; for (let perf of data.performances) { result += ` ${perf.play.name}: ${usd(perf.amount)} (${perf.audience} seats)\\n`; } result += `Amount owed is ${usd(data.totalAmount)}\\n`; result += `You earned ${data.totalVolumeCredits} credits\\n`; return result; } function htmlStatement (invoice, plays) { return renderHtml(createStatementData(invoice, plays)); } function renderHtml (data) { let result = `<h1>Statement for ${data.customer}</h1>\\n`; result += \"<table>\\n\"; result += \"<tr><th>play</th><th>seats</th><th>cost</th></tr>\"; for (let perf of data.performances) { result += ` <tr><td>${perf.play.name}</td><td>${perf.audience}</td>`; result += `<td>${usd(perf.amount)}</td></tr>\\n`; } result += \"</table>\\n\"; result += `<p>Amount owed is <em>${usd(data.totalAmount)}</em></p>\\n`; result += `<p>You earned <em>${data.totalVolumeCredits}</em> credits</p>\\n`; return result; } function usd(aNumber) { return new Intl.NumberFormat(\"en­US\", { style: \"currency\", currency: \"USD\", minimumFractionDigits: 2 }).format(aNumber/100); }\n\ncreateStatementData.js\n\nClick here to view code image\n\nexport default function createStatementData(invoice, plays) { const result = {}; result.customer = invoice.customer; result.performances = invoice.performances.map(enrichPerformance); result.totalAmount = totalAmount(result); result.totalVolumeCredits = totalVolumeCredits(result); return result;\n\nfunction enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); result.play = playFor(result);\n\nwww.EBooksWorld.ir",
      "content_length": 1770,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 42,
      "content": "result.amount = amountFor(result); result.volumeCredits = volumeCreditsFor(result); return result; } function playFor(aPerformance) { return plays[aPerformance.playID] } function amountFor(aPerformance) { let result = 0; switch (aPerformance.play.type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${aPerformance.play.type}`); } return result; } function volumeCreditsFor(aPerformance) { let result = 0; result += Math.max(aPerformance.audience ­ 30, 0); if (\"comedy\" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5); return result; } function totalAmount(data) { return data.performances .reduce((total, p) => total + p.amount, 0); } function totalVolumeCredits(data) { return data.performances .reduce((total, p) => total + p.volumeCredits, 0); }\n\nI have more code than I did when I started: 70 lines (not counting htmlStatement) as\n\nopposed to 44, mostly due to the extra wrapping involved in putting things in functions.\n\nIf all else is equal, more code is bad—but rarely is all else equal. The extra code breaks\n\nup the logic into identifiable parts, separating the calculations of the statements from\n\nthe layout. This modularity makes it easier for me to understand the parts of the code\n\nand how they fit together. Brevity is the soul of wit, but clarity is the soul of evolvable\n\nwww.EBooksWorld.ir",
      "content_length": 1620,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 43,
      "content": "software. Adding this modularity allows to me to support the HTML version of the code\n\nwithout any duplication of the calculations.\n\nWhen programming, follow the camping rule: Always leave the code base\n\nhealthier than when you found it.\n\nThere are more things I could do to simplify the printing logic, but this will do for the\n\nmoment. I always have to strike a balance between all the refactorings I could do and\n\nadding new features. At the moment, most people under­prioritize refactoring—but\n\nthere still is a balance. My rule is a variation on the camping rule: Always leave the code\n\nbase healthier than when you found it. It will never be perfect, but it should be better.\n\nREORGANIZING THE CALCULATIONS BY TYPE\n\nNow I’ll turn my attention to the next feature change: supporting more categories of\n\nplays, each with its own charging and volume credits calculations. At the moment, to\n\nmake changes here I have to go into the calculation functions and edit the conditions in\n\nthere. The amountFor function highlights the central role the type of play has in the\n\nchoice of calculations—but conditional logic like this tends to decay as further\n\nmodifications are made unless it’s reinforced by more structural elements of the\n\nprogramming language.\n\nThere are various ways to introduce structure to make this explicit, but in this case a\n\nnatural approach is type polymorphism—a prominent feature of classical object­\n\norientation. Classical OO has long been a controversial feature in the JavaScript world,\n\nbut the ECMAScript 2015 version provides a sound syntax and structure for it. So it\n\nmakes sense to use it in a right situation—like this one.\n\nMy overall plan is to set up an inheritance hierarchy with comedy and tragedy\n\nsubclasses that contain the calculation logic for those cases. Callers call a polymorphic\n\namount function that the language will dispatch to the different calculations for the\n\ncomedies and tragedies. I’ll make a similar structure for the volume credits calculation.\n\nTo do this, I utilize a couple of refactorings. The core refactoring is Replace Conditional\n\nwith Polymorphism (272), which changes a hunk of conditional code with\n\npolymorphism. But before I can do Replace Conditional with Polymorphism (272), I\n\nneed to create an inheritance structure of some kind. I need to create a class to host the\n\namount and volume credit functions.\n\nI begin by reviewing the calculation code. (One of the pleasant consequences of the\n\nwww.EBooksWorld.ir",
      "content_length": 2488,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 44,
      "content": "previous refactoring is that I can now ignore the formatting code, so long as I produce\n\nthe same output data structure. I can further support this by adding tests that probe the\n\nintermediate data structure.)\n\ncreateStatementData.js…\n\nClick here to view code image\n\nexport default function createStatementData(invoice, plays) { const result = {}; result.customer = invoice.customer; result.performances = invoice.performances.map(enrichPerformance); result.totalAmount = totalAmount(result); result.totalVolumeCredits = totalVolumeCredits(result); return result;\n\nfunction enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); result.play = playFor(result); result.amount = amountFor(result); result.volumeCredits = volumeCreditsFor(result); return result; } function playFor(aPerformance) { return plays[aPerformance.playID] } function amountFor(aPerformance) { let result = 0; switch (aPerformance.play.type) { case \"tragedy\": result = 40000; if (aPerformance.audience > 30) { result += 1000 * (aPerformance.audience ­ 30); } break; case \"comedy\": result = 30000; if (aPerformance.audience > 20) { result += 10000 + 500 * (aPerformance.audience ­ 20); } result += 300 * aPerformance.audience; break; default: throw new Error(`unknown type: ${aPerformance.play.type}`); } return result; } function volumeCreditsFor(aPerformance) { let result = 0; result += Math.max(aPerformance.audience ­ 30, 0); if (\"comedy\" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);\n\nwww.EBooksWorld.ir",
      "content_length": 1537,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 45,
      "content": "return result; } function totalAmount(data) { return data.performances .reduce((total, p) => total + p.amount, 0); } function totalVolumeCredits(data) { return data.performances .reduce((total, p) => total + p.volumeCredits, 0); }\n\nCreating a Performance Calculator\n\nThe enrichPerformance function is the key, since it populates the intermediate data\n\nstructure with the data for each performance. Currently, it calls the conditional\n\nfunctions for amount and volume credits. What I need it to do is call those functions on\n\na host class. Since that class hosts functions for calculating data about performances,\n\nI’ll call it a performance calculator.\n\nfunction createStatementData…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const calculator = new PerformanceCalculator(aPerformance); const result = Object.assign({}, aPerformance); result.play = playFor(result); result.amount = amountFor(result); result.volumeCredits = volumeCreditsFor(result); return result; }\n\ntop level…\n\nClick here to view code image\n\nclass PerformanceCalculator { constructor(aPerformance) { this.performance = aPerformance; } }\n\nSo far, this new object isn’t doing anything. I want to move behavior into it—and I’d like\n\nto start with the simplest thing to move, which is the play record. Strictly, I don’t need\n\nwww.EBooksWorld.ir",
      "content_length": 1341,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 46,
      "content": "to do this, as it’s not varying polymorphically, but this way I’ll keep all the data\n\ntransforms in one place, and that consistency will make the code clearer.\n\nTo make this work, I will use Change Function Declaration (124) to pass the\n\nperformance’s play into the calculator.\n\nfunction createStatementData…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance) const result = Object.assign({}, aPerformance); result.play = calculator.play; result.amount = amountFor(result); result.volumeCredits = volumeCreditsFor(result); return result; }\n\nclass PerformanceCalculator…\n\nClick here to view code image\n\nclass PerformanceCalculator { constructor(aPerformance, aPlay) { this.performance = aPerformance; this.play = aPlay; } }\n\n(I’m not saying compile­test­commit all the time any more, as I suspect you’re getting\n\ntired of reading it. But I still do it at every opportunity. I do sometimes get tired of\n\ndoing it—and give mistakes the chance to bite me. Then I learn and get back into the\n\nrhythm.)\n\nMoving Functions into the Calculator\n\nThe next bit of logic I move is rather more substantial for calculating the amount for a\n\nperformance. I’ve moved functions around casually while rearranging nested functions\n\n—but this is a deeper change in the context of the function, so I’ll step through the Move\n\nFunction (198) refactoring. The first part of this refactoring is to copy the logic over to\n\nits new context—the calculator class. Then, I adjust the code to fit into its new home,\n\nwww.EBooksWorld.ir",
      "content_length": 1609,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 47,
      "content": "changing aPerformance to this.performance and playFor(aPerformance) to\n\nthis.play.\n\nclass PerformanceCalculator…\n\nClick here to view code image\n\nget amount() { let result = 0; switch (this.play.type) { case \"tragedy\": result = 40000; if (this.performance.audience > 30) { result += 1000 * (this.performance.audience ­ 30); } break; case \"comedy\": result = 30000; if (this.performance.audience > 20) { result += 10000 + 500 * (this.performance.audience ­ 20); } result += 300 * this.performance.audience; break; default: throw new Error(`unknown type: ${this.play.type}`); } return result; }\n\nI can compile at this point to check for any compile­time errors. “Compiling” in my\n\ndevelopment environment occurs as I execute the code, so what I actually do is run\n\nBabel [babel]. That will be enough to catch any syntax errors in the new function—but\n\nlittle more than that. Even so, that can be a useful step.\n\nOnce the new function fits its home, I take the original function and turn it into a\n\ndelegating function so it calls the new function.\n\nfunction createStatementData…\n\nClick here to view code image\n\nfunction amountFor(aPerformance) { return new PerformanceCalculator(aPerformance, playFor(aPerformance)).amount; }\n\nwww.EBooksWorld.ir",
      "content_length": 1241,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 48,
      "content": "Now I can compile­test­commit to ensure the code is working properly in its new home.\n\nWith that done, I use Inline Function (115) to call the new function directly (compile­\n\ntest­commit).\n\nfunction createStatementData…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance)); const result = Object.assign({}, aPerformance); result.play = calculator.play; result.amount = calculator.amount; result.volumeCredits = volumeCreditsFor(result); return result; }\n\nI repeat the same process to move the volume credits calculation.\n\nfunction createStatementData…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance)); const result = Object.assign({}, aPerformance); result.play = calculator.play; result.amount = calculator.amount; result.volumeCredits = calculator.volumeCredits; return result; }\n\nclass PerformanceCalculator…\n\nClick here to view code image\n\nget volumeCredits() { let result = 0; result += Math.max(this.performance.audience ­ 30, 0); if (\"comedy\" === this.play.type) result += Math.floor(this.performance.audience / 5); return result; }\n\nwww.EBooksWorld.ir\n\nMaking the Performance Calculator Polymorphic",
      "content_length": 1319,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 49,
      "content": "Making the Performance Calculator Polymorphic\n\nNow that I have the logic in a class, it’s time to apply the polymorphism. The first step is\n\nto use Replace Type Code with Subclasses (362) to introduce subclasses instead of the\n\ntype code. For this, I need to create subclasses of the performance calculator and use\n\nthe appropriate subclass in createPerformanceData. In order to get the right\n\nsubclass, I need to replace the constructor call with a function, since JavaScript\n\nconstructors can’t return subclasses. So I use Replace Constructor with Factory\n\nFunction (334).\n\nfunction createStatementData…\n\nClick here to view code image\n\nfunction enrichPerformance(aPerformance) { const calculator = createPerformanceCalculator(aPerformance, playFor(aPerformance)); const result = Object.assign({}, aPerformance); result.play = calculator.play; result.amount = calculator.amount; result.volumeCredits = calculator.volumeCredits; return result; }\n\ntop level…\n\nClick here to view code image\n\nfunction createPerformanceCalculator(aPerformance, aPlay) { return new PerformanceCalculator(aPerformance, aPlay); }\n\nWith that now a function, I can create subclasses of the performance calculator and get\n\nthe creation function to select which one to return.\n\ntop level…\n\nClick here to view code image\n\nfunction createPerformanceCalculator(aPerformance, aPlay) { switch(aPlay.type) { case \"tragedy\": return new TragedyCalculator(aPerformance, aPlay); case \"comedy\" : return new ComedyCalculator(aPerformance, aPlay); default:\n\nwww.EBooksWorld.ir",
      "content_length": 1536,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 50,
      "content": "throw new Error(`unknown type: ${aPlay.type}`); } }\n\nclass TragedyCalculator extends PerformanceCalculator { } class ComedyCalculator extends PerformanceCalculator { }\n\nThis sets up the structure for the polymorphism, so I can now move on to Replace\n\nConditional with Polymorphism (272).\n\nI start with the calculation of the amount for tragedies.\n\nclass TragedyCalculator…\n\nClick here to view code image\n\nget amount() { let result = 40000; if (this.performance.audience > 30) { result += 1000 * (this.performance.audience ­ 30); } return result; }\n\nJust having this method in the subclass is enough to override the superclass\n\nconditional. But if you’re as paranoid as I am, you might do this:\n\nclass PerformanceCalculator…\n\nClick here to view code image\n\nget amount() { let result = 0; switch (this.play.type) { case \"tragedy\": throw 'bad thing'; case \"comedy\": result = 30000; if (this.performance.audience > 20) { result += 10000 + 500 * (this.performance.audience ­ 20); } result += 300 * this.performance.audience; break; default: throw new Error(`unknown type: ${this.play.type}`);\n\nwww.EBooksWorld.ir",
      "content_length": 1107,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 51,
      "content": "} return result; }\n\nI could have removed the case for tragedy and let the default branch throw an error. But\n\nI like the explicit throw—and it will only be there for a couple more minutes (which is\n\nwhy I threw a string, not a better error object).\n\nAfter a compile­test­commit of that, I move the comedy case down too.\n\nclass ComedyCalculator…\n\nClick here to view code image\n\nget amount() { let result = 30000; if (this.performance.audience > 20) { result += 10000 + 500 * (this.performance.audience ­ 20); } result += 300 * this.performance.audience; return result; }\n\nI can now remove the superclass amount method, as it should never be called. But it’s\n\nkinder to my future self to leave a tombstone.\n\nclass PerformanceCalculator…\n\nClick here to view code image\n\nget amount() { throw new Error('subclass responsibility'); }\n\nThe next conditional to replace is the volume credits calculation. Looking at the\n\ndiscussion of future categories of plays, I notice that most plays expect to check if\n\naudience is above 30, with only some categories introducing a variation. So it makes\n\nsense to leave the more common case on the superclass as a default, and let the\n\nvariations override it as necessary. So I just push down the case for comedies:\n\nclass PerformanceCalculator…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1326,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 52,
      "content": "get volumeCredits() { return Math.max(this.performance.audience ­ 30, 0); }\n\nclass ComedyCalculator…\n\nClick here to view code image\n\nget volumeCredits() { return super.volumeCredits + Math.floor(this.performance.audience / 5); }\n\nSTATUS: CREATING THE DATA WITH THE POLYMORPHIC CALCULATOR\n\nTime to reflect on what introducing the polymorphic calculator did to the code.\n\ncreateStatementData.js\n\nClick here to view code image\n\nexport default function createStatementData(invoice, plays) { const result = {}; result.customer = invoice.customer; result.performances = invoice.performances.map(enrichPerformance); result.totalAmount = totalAmount(result); result.totalVolumeCredits = totalVolumeCredits(result); return result;\n\nfunction enrichPerformance(aPerformance) { const calculator = createPerformanceCalculator(aPerformance, playFor(aPerformance)); const result = Object.assign({}, aPerformance); result.play = calculator.play; result.amount = calculator.amount; result.volumeCredits = calculator.volumeCredits; return result; } function playFor(aPerformance) { return plays[aPerformance.playID] } function totalAmount(data) { return data.performances .reduce((total, p) => total + p.amount, 0); } function totalVolumeCredits(data) { return data.performances\n\nwww.EBooksWorld.ir",
      "content_length": 1280,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 53,
      "content": ".reduce((total, p) => total + p.volumeCredits, 0); } }\n\nfunction createPerformanceCalculator(aPerformance, aPlay) { switch(aPlay.type) { case \"tragedy\": return new TragedyCalculator(aPerformance, aPlay); case \"comedy\" : return new ComedyCalculator(aPerformance, aPlay); default: throw new Error(`unknown type: ${aPlay.type}`); } } class PerformanceCalculator { constructor(aPerformance, aPlay) { this.performance = aPerformance; this.play = aPlay; } get amount() { throw new Error('subclass responsibility');} get volumeCredits() { return Math.max(this.performance.audience ­ 30, 0); } } class TragedyCalculator extends PerformanceCalculator { get amount() { let result = 40000; if (this.performance.audience > 30) { result += 1000 * (this.performance.audience ­ 30); } return result; } } class ComedyCalculator extends PerformanceCalculator { get amount() { let result = 30000; if (this.performance.audience > 20) { result += 10000 + 500 * (this.performance.audience ­ 20); } result += 300 * this.performance.audience; return result; } get volumeCredits() { return super.volumeCredits + Math.floor(this.performance.audience / 5); } }\n\nAgain, the code has increased in size as I’ve introduced structure. The benefit here is\n\nthat the calculations for each kind of play are grouped together. If most of the changes\n\nwill be to this code, it will be helpful to have it clearly separated like this. Adding a new\n\nkind of play requires writing a new subclass and adding it to the creation function.\n\nwww.EBooksWorld.ir",
      "content_length": 1514,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 54,
      "content": "The example gives some insight as to when using subclasses like this is useful. Here,\n\nI’ve moved the conditional lookup from two functions (amountFor and\n\nvolumeCreditsFor) to a single constructor function\n\ncreatePerformanceCalculator. The more functions there are that depend on the\n\nsame type of polymorphism, the more useful this approach becomes.\n\nAn alternative to what I’ve done here would be to have createPerformanceData\n\nreturn the calculator itself, instead of the calculator populating the intermediate data\n\nstructure. One of the nice features of JavaScript’s class system is that with it, using\n\ngetters looks like regular data access. My choice on whether to return the instance or\n\ncalculate separate output data depends on who is using the downstream data structure.\n\nIn this case, I preferred to show how to use the intermediate data structure to hide the\n\ndecision to use a polymorphic calculator.\n\nFINAL THOUGHTS\n\nThis is a simple example, but I hope it will give you a feeling for what refactoring is like.\n\nI’ve used several refactorings, including Extract Function (106), Inline Variable (123),\n\nMove Function (198), and Replace Conditional with Polymorphism (272).\n\nThere were three major stages to this refactoring episode: decomposing the original\n\nfunction into a set of nested functions, using Split Phase (154) to separate the\n\ncalculation and printing code, and finally introducing a polymorphic calculator for the\n\ncalculation logic. Each of these added structure to the code, enabling me to better\n\ncommunicate what the code was doing.\n\nAs is often the case with refactoring, the early stages were mostly driven by trying to\n\nunderstand what was going on. A common sequence is: Read the code, gain some\n\ninsight, and use refactoring to move that insight from your head back into the code. The\n\nclearer code then makes it easier to understand it, leading to deeper insights and a\n\nbeneficial positive feedback loop. There are still some improvements I could make, but\n\nI feel I’ve done enough to pass my test of leaving the code significantly better than how\n\nI found it.\n\nThe true test of good code is how easy it is to change it.\n\nI’m talking about improving the code—but programmers love to argue about what good\n\ncode looks like. I know some people object to my preference for small, well­named\n\nfunctions. If we consider this to be a matter of aesthetics, where nothing is either good\n\nwww.EBooksWorld.ir",
      "content_length": 2440,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 55,
      "content": "or bad but thinking makes it so, we lack any guide but personal taste. I believe,\n\nhowever, that we can go beyond taste and say that the true test of good code is how easy\n\nit is to change it. Code should be obvious: When someone needs to make a change, they\n\nshould be able to find the code to be changed easily and to make the change quickly\n\nwithout introducing any errors. A healthy code base maximizes our productivity,\n\nallowing us to build more features for our users both faster and more cheaply. To keep\n\ncode healthy, pay attention to what is getting between the programming team and that\n\nideal, then refactor to get closer to the ideal.\n\nBut the most important thing to learn from this example is the rhythm of refactoring.\n\nWhenever I’ve shown people how I refactor, they are surprised by how small my steps\n\nare, each step leaving the code in a working state that compiles and passes its tests. I\n\nwas just as surprised myself when Kent Beck showed me how to do this in a hotel room\n\nin Detroit two decades ago. The key to effective refactoring is recognizing that you go\n\nfaster when you take tiny steps, the code is never broken, and you can compose those\n\nsmall steps into substantial changes. Remember that—and the rest is silence.\n\nwww.EBooksWorld.ir",
      "content_length": 1269,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 56,
      "content": "Chapter 2 Principles in Refactoring\n\nHistory\n\nTopics\n\nThe example in the previous chapter should have given you a decent feel of what\n\nrefactoring is. Now you have that, it’s a good time to step back and talk about some of\n\nTutorials\n\nthe broader principles in refactoring.\n\nOffers & Deals\n\nDEFINING REFACTORING\n\nHighlights\n\nLike many terms in software development, “refactoring” is often used very loosely by\n\npractitioners. I use the term more precisely, and find it useful to use it in that more\n\nSettings\n\nprecise form. (These definitions are the same as those I gave in the first edition of this\n\nbook.) The term “refactoring” can be used either as a noun or a verb. The noun’s\n\nSupport\n\ndefinition is:\n\nSign Out\n\nRefactoring (noun): a change made to the internal structure of software to make it\n\neasier to understand and cheaper to modify without changing its observable behavior.\n\nThis definition corresponds to the named refactorings I’ve mentioned in the earlier\n\nexamples, such as Extract Function (106) and Replace Conditional with Polymorphism\n\n(272).\n\nThe verb’s definition is:\n\nRefactoring (verb): to restructure software by applying a series of refactorings\n\nwithout changing its observable behavior.\n\nSo I might spend a couple of hours refactoring, during which I would apply a few dozen\n\nindividual refactorings.\n\nOver the years, many people in the industry have taken to use “refactoring” to mean any\n\nkind of code cleanup—but the definitions above point to a particular approach to\n\ncleaning up code. Refactoring is all about applying small behavior­preserving steps and\n\nmaking a big change by stringing together a sequence of these behavior­preserving\n\nwww.EBooksWorld.ir",
      "content_length": 1693,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 57,
      "content": "steps. Each individual refactoring is either pretty small itself or a combination of small\n\nsteps. As a result, when I’m refactoring, my code doesn’t spend much time in a broken\n\nstate, allowing me to stop at any moment even if I haven’t finished.\n\nIf someone says their code was broken for a couple of days while they are\n\nrefactoring, you can be pretty sure they were not refactoring.\n\nI use “restructuring” as a general term to mean any kind of reorganizing or cleaning up\n\nof a code base, and see refactoring as a particular kind of restructuring. Refactoring\n\nmay seem inefficient to people who first come across it and watch me making lots of\n\ntiny steps, when a single bigger step would do. But the tiny steps allow me to go faster\n\nbecause they compose so well—and, crucially, because I don’t spend any time\n\ndebugging.\n\nIn my definitions, I use the phrase “observable behavior.” This is a deliberately loose\n\nterm, indicating that the code should, overall, do just the same things it did before I\n\nstarted. It doesn’t mean it will work exactly the same—for example, Extract Function\n\n(106) will alter the call stack, so performance characteristics might change—but nothing\n\nshould change that the user should care about. In particular, interfaces to modules\n\noften change due to such refactorings as Change Function Declaration (124) and Move\n\nFunction (198). Any bugs that I notice during refactoring should still be present after\n\nrefactoring (though I can fix latent bugs that nobody has observed yet).\n\nRefactoring is very similar to performance optimization, as both involve carrying out\n\ncode manipulations that don’t change the overall functionality of the program. The\n\ndifference is the purpose: Refactoring is always done to make the code “easier to\n\nunderstand and cheaper to modify.” This might speed things up or slow things down.\n\nWith performance optimization, I only care about speeding up the program, and am\n\nprepared to end up with code that is harder to work with if I really need that improved\n\nperformance.\n\nTHE TWO HATS\n\nKent Beck came up with a metaphor of the two hats. When I use refactoring to develop\n\nsoftware, I divide my time between two distinct activities: adding functionality and\n\nrefactoring. When I add functionality, I shouldn’t be changing existing code; I’m just\n\nadding new capabilities. I measure my progress by adding tests and getting the tests to\n\nwork. When I refactor, I make a point of not adding functionality; I only restructure the\n\ncode. I don’t add any tests (unless I find a case I missed earlier); I only change tests www.EBooksWorld.ir",
      "content_length": 2600,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 58,
      "content": "when I have to accommodate a change in an interface.\n\nAs I develop software, I find myself swapping hats frequently. I start by trying to add a\n\nnew capability, then I realize this would be much easier if the code were structured\n\ndifferently. So I swap hats and refactor for a while. Once the code is better structured, I\n\nswap hats back and add the new capability. Once I get the new capability working, I\n\nrealize I coded it in a way that’s awkward to understand, so I swap hats again and\n\nrefactor. All this might take only ten minutes, but during this time I’m always aware of\n\nwhich hat I’m wearing and the subtle difference that makes to how I program.\n\nWHY SHOULD WE REFACTOR?\n\nI don’t want to claim refactoring is the cure for all software ills. It is no “silver bullet.”\n\nYet it is a valuable tool—a pair of silver pliers that helps you keep a good grip on your\n\ncode. Refactoring is a tool that can—and should—be used for several purposes.\n\nRefactoring Improves the Design of Software\n\nWithout refactoring, the internal design—the architecture—of software tends to decay.\n\nAs people change code to achieve short­term goals, often without a full comprehension\n\nof the architecture, the code loses its structure. It becomes harder for me to see the\n\ndesign by reading the code. Loss of the structure of code has a cumulative effect. The\n\nharder it is to see the design in the code, the harder it is for me to preserve it, and the\n\nmore rapidly it decays. Regular refactoring helps keep the code in shape.\n\nPoorly designed code usually takes more code to do the same things, often because the\n\ncode quite literally does the same thing in several places. Thus an important aspect of\n\nimproving design is to eliminate duplicated code. It’s not that reducing the amount of\n\ncode will make the system run any faster—the effect on the footprint of the programs\n\nrarely is significant. Reducing the amount of code does, however, make a big difference\n\nin modification of the code. The more code there is, the harder it is to modify correctly.\n\nThere’s more code for me to understand. I change this bit of code here, but the system\n\ndoesn’t do what I expect because I didn’t change that bit over there that does much the\n\nsame thing in a slightly different context. By eliminating duplication, I ensure that the\n\ncode says everything once and only once, which is the essence of good design.\n\nRefactoring Makes Software Easier to Understand\n\nProgramming is in many ways a conversation with a computer. I write code that tells\n\nthe computer what to do, and it responds by doing exactly what I tell it. In time, I close\n\nthe gap between what I want it to do and what I tell it to do. Programming is all about\n\nwww.EBooksWorld.ir",
      "content_length": 2726,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 59,
      "content": "saying exactly what I want. But there are likely to be other users of my source code. In a\n\nfew months, a human will try to read my code to make some changes. That user, who\n\nwe often forget, is actually the most important. Who cares if the computer takes a few\n\nmore cycles to compile something? Yet it does matter if it takes a programmer a week to\n\nmake a change that would have taken only an hour with proper understanding of my\n\ncode.\n\nThe trouble is that when I’m trying to get the program to work, I’m not thinking about\n\nthat future developer. It takes a change of rhythm to make the code easier to\n\nunderstand. Refactoring helps me make my code more readable. Before refactoring, I\n\nhave code that works but is not ideally structured. A little time spent on refactoring can\n\nmake the code better communicate its purpose—say more clearly what I want.\n\nI’m not necessarily being altruistic about this. Often, this future developer is myself.\n\nThis makes refactoring even more important. I’m a very lazy programmer. One of my\n\nforms of laziness is that I never remember things about the code I write. Indeed, I\n\ndeliberately try not remember anything I can look up, because I’m afraid my brain will\n\nget full. I make a point of trying to put everything I should remember into the code so I\n\ndon’t have to remember it. That way I’m less worried about Maudite [maudite] killing\n\noff my brain cells.\n\nRefactoring Helps Me Find Bugs\n\nHelp in understanding the code also means help in spotting bugs. I admit I’m not\n\nterribly good at finding bugs. Some people can read a lump of code and see bugs; I\n\ncannot. However, I find that if I refactor code, I work deeply on understanding what the\n\ncode does, and I put that new understanding right back into the code. By clarifying the\n\nstructure of the program, I clarify certain assumptions I’ve made—to a point where\n\neven I can’t avoid spotting the bugs.\n\nIt reminds me of a statement Kent Beck often makes about himself: “I’m not a great\n\nprogrammer; I’m just a good programmer with great habits.” Refactoring helps me be\n\nmuch more effective at writing robust code.\n\nRefactoring Helps Me Program Faster\n\nIn the end, all the earlier points come down to this: Refactoring helps me develop code\n\nmore quickly.\n\nThis sounds counterintuitive. When I talk about refactoring, people can easily see that\n\nit improves quality. Better internal design, readability, reducing bugs—all these\n\nwww.EBooksWorld.ir",
      "content_length": 2448,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 60,
      "content": "improve quality. But doesn’t the time I spend on refactoring reduce the speed of\n\ndevelopment?\n\nWhen I talk to software developers who have been working on a system for a while, I\n\noften hear that they were able to make progress rapidly at first, but now it takes much\n\nlonger to add new features. Every new feature requires more and more time to\n\nunderstand how to fit it into the existing code base, and once it’s added, bugs often crop\n\nup that take even longer to fix. The code base starts looking like a series of patches\n\ncovering patches, and it takes an exercise in archaeology to figure out how things work.\n\nThis burden slows down adding new features—to the point that developers wish they\n\ncould start again from a blank slate.\n\nI can visualize this state of affairs with the following pseudograph:\n\nBut some teams report a different experience. They find they can add new features\n\nfaster because they can leverage the existing things by quickly building on what’s\n\nalready there.\n\nwww.EBooksWorld.ir",
      "content_length": 1012,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 61,
      "content": "The difference between these two is the internal quality of the software. Software with a\n\ngood internal design allows me to easily find how and where I need to make changes to\n\nadd a new feature. Good modularity allows me to only have to understand a small\n\nsubset of the code base to make a change. If the code is clear, I’m less likely to introduce\n\na bug, and if I do, the debugging effort is much easier. Done well, my code base turns\n\ninto a platform for building new features for its domain.\n\nI refer to this effect as the Design Stamina Hypothesis [mf­dsh]: By putting our effort\n\ninto a good internal design, we increase the stamina of the software effort, allowing us\n\nto go faster for longer. I can’t prove that this is the case, which is why I refer to it as a\n\nhypothesis. But it explains my experience, together with the experience of hundreds of\n\ngreat programmers that I’ve got to know over my career.\n\nTwenty years ago, the conventional wisdom was that to get this kind of good design, it\n\nhad to be completed before starting to program—because once we wrote the code, we\n\ncould only face decay. Refactoring changes this picture. We now know we can improve\n\nthe design of existing code—so we can form and improve a design over time, even as the\n\nneeds of the program change. Since it is very difficult to do a good design up front,\n\nrefactoring becomes vital to achieving that virtuous path of rapid functionality.\n\nWHEN SHOULD WE REFACTOR?\n\nRefactoring is something I do every hour I program. I have noticed a number of ways it\n\nfits into my workflow.\n\nwww.EBooksWorld.ir",
      "content_length": 1589,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 62,
      "content": "The Rule of Three\n\nHere’s a guideline Don Roberts gave me: The first time you do something,\n\nyou just do it. The second time you do something similar, you wince at the\n\nduplication, but you do the duplicate thing anyway. The third time you do\n\nsomething similar, you refactor.\n\nOr for those who like baseball: Three strikes, then you refactor.\n\nPreparatory Refactoring—Making It Easier to Add a Feature\n\nThe best time to refactor is just before I need to add a new feature to the code base. As I\n\ndo this, I look at the existing code and, often, see that if it were structured a little\n\ndifferently, my work would be much easier. Perhaps there’s function that does almost\n\nall that I need, but has some literal values that conflict with my needs. Without\n\nrefactoring I might copy the function and change those values. But that leads to\n\nduplicated code—if I need to change it in the future, I’ll have to change both spots (and,\n\nworse, find them). And copy­paste won’t help me if I need to make a similar variation\n\nfor a new feature in the future. So with my refactoring hat on, I use Parameterize\n\nFunction (310). Once I’ve done that, all I have to do is call the function with the\n\nparameters I need.\n\n“It’s like I want to go 100 miles east but instead of just traipsing through the woods,\n\nI’m going to drive 20 miles north to the highway and then I’m going to go 100 miles\n\neast at three times the speed I could have if I just went straight there. When people are\n\npushing you to just go straight there, sometimes you need to say, ‘Wait, I need to\n\ncheck the map and find the quickest route.’ The preparatory refactoring does that for\n\nme.”\n\n— Jessica Kerr,\n\nhttps://martinfowler.com/articles/preparatory­refactoring­\n\nexample.html\n\nThe same happens when fixing a bug. Once I’ve found the cause of the problem, I see\n\nthat it would be much easier to fix should I unify the three bits of copied code causing\n\nthe error into one. Or perhaps separating some update logic from queries will make it\n\neasier to avoid the tangling that’s causing the error. By refactoring to improve the\n\nsituation, I also increase the chances that the bug will stay fixed, and reduce the\n\nchances that others will appear in the same crevices of the code.\n\nwww.EBooksWorld.ir Comprehension Refactoring: Making Code Easier to Understand",
      "content_length": 2317,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 63,
      "content": "Comprehension Refactoring: Making Code Easier to Understand\n\nBefore I can change some code, I need to understand what it does. This code may have\n\nbeen written by me or by someone else. Whenever I have to think to understand what\n\nthe code is doing, I ask myself if I can refactor the code to make that understanding\n\nmore immediately apparent. I may be looking at some conditional logic that’s\n\nstructured awkwardly. I may have wanted to use some existing functions but spent\n\nseveral minutes figuring out what they did because they were named badly.\n\nAt that point I have some understanding in my head, but my head isn’t a very good\n\nrecord of such details. As Ward Cunningham puts it, by refactoring I move the\n\nunderstanding from my head into the code itself. I then test that understanding by\n\nrunning the software to see if it still works. If I move my understanding into the code, it\n\nwill be preserved longer and be visible to my colleagues.\n\nThat doesn’t just help me in the future—it often helps me right now. Early on, I do\n\ncomprehension refactoring on little details. I rename a couple variables now that I\n\nunderstand what they are, or I chop a long function into smaller parts. Then, as the\n\ncode gets clearer, I find I can see things about the design that I could not see before.\n\nHad I not changed the code, I probably never would have seen these things, because I’m\n\njust not clever enough to visualize all these changes in my head. Ralph Johnson\n\ndescribes these early refactorings as wiping the dirt off a window so you can see\n\nbeyond. When I’m studying code, refactoring leads me to higher levels of\n\nunderstanding that I would otherwise miss. Those who dismiss comprehension\n\nrefactoring as useless fiddling with the code don’t realize that by foregoing it they never\n\nsee the opportunities hidden behind the confusion.\n\nLitter-Pickup Refactoring\n\nA variation of comprehension refactoring is when I understand what the code is doing,\n\nbut realize that it’s doing it badly. The logic is unnecessarily convoluted, or I see\n\nfunctions that are nearly identical and can be replaced by a single parameterized\n\nfunction. There’s a bit of a tradeoff here. I don’t want to spend a lot of time distracted\n\nfrom the task I’m currently doing, but I also don’t want to leave the trash lying around\n\nand getting in the way of future changes. If it’s easy to change, I’ll do it right away. If it’s\n\na bit more effort to fix, I might make a note of it and fix it when I’m done with my\n\nimmediate task.\n\nSometimes, of course, it’s going to take a few hours to fix, and I have more urgent\n\nthings to do. Even then, however, it’s usually worthwhile to make it a little bit better. As\n\nthe old camping adage says, always leave the camp site cleaner than when you found it.\n\nwww.EBooksWorld.ir",
      "content_length": 2796,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 64,
      "content": "If I make it a little better each time I pass through the code, over time it will get fixed.\n\nThe nice thing about refactoring is that I don’t break the code with each small step—so,\n\nsometimes, it takes months to complete the job but the code is never broken even when\n\nI’m part way through it.\n\nPlanned and Opportunistic Refactoring\n\nThe examples above—preparatory, comprehension, litter­pickup refactoring—are all\n\nopportunistic. I don’t set aside time at the beginning to spend on refactoring—instead, I\n\ndo refactoring as part of adding a feature or fixing a bug. It’s part of my natural flow of\n\nprogramming. Whether I’m adding a feature or fixing a bug, refactoring helps me do\n\nthe immediate task and also sets me up to make future work easier. This is an\n\nimportant point that’s frequently missed. Refactoring isn’t an activity that’s separated\n\nfrom programming—any more than you set aside time to write if statements. I don’t\n\nput time on my plans to do refactoring; most refactoring happens while I’m doing other\n\nthings.\n\nYou have to refactor when you run into ugly code—but excellent code needs\n\nplenty of refactoring too.\n\nIt’s also a common error to see refactoring as something people do to fix past mistakes\n\nor clean up ugly code. Certainly you have to refactor when you run into ugly code, but\n\nexcellent code needs plenty of refactoring too. Whenever I write code, I’m making\n\ntradeoffs—how much do I need to parameterize, where to draw the lines between\n\nfunctions? The tradeoffs I made correctly for yesterday’s feature set may no longer be\n\nthe right ones for the new features I’m adding today. The advantage is that clean code is\n\neasier to refactor when I need to change those tradeoffs to reflect the new reality.\n\n“for each desired change, make the change easy (warning: this may be hard), then\n\nmake the easy change”\n\n— Kent Beck,\n\nhttps://twitter.com/kentbeck/status/250733358307500032\n\nFor a long time, people thought of writing software as a process of accretion: To add\n\nnew features, we should be mostly adding new code. But good developers know that,\n\noften, the fastest way to add a new feature is to change the code to make it easy to add.\n\nSoftware should thus be never thought of as “done.” As new capabilities are needed, the\n\nsoftware changes to reflect that. Those changes can often be greater in the existing code\n\nwww.EBooksWorld.ir",
      "content_length": 2376,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 65,
      "content": "than in the new code.\n\nAll this doesn’t mean that planned refactoring is always wrong. If a team has neglected\n\nrefactoring, it often needs dedicated time to get their code base into a better state for\n\nnew features, and a week spent refactoring now can repay itself over the next couple of\n\nmonths. Sometimes, even with regular refactoring I’ll see a problem area grow to the\n\npoint when it needs some concerted effort to fix. But such planned refactoring episodes\n\nshould be rare. Most refactoring effort should be the unremarkable, opportunistic kind.\n\nOne bit of advice I’ve heard is to separate refactoring work and new feature additions\n\ninto different version­control commits. The big advantage of this is that they can be\n\nreviewed and approved independently. I’m not convinced of this, however. Too often,\n\nthe refactorings are closely interwoven with adding new features, and it’s not worth the\n\ntime to separate them out. This can also remove the context for the refactoring, making\n\nthe refactoring commits hard to justify. Each team should experiment to find what\n\nworks for them; just remember that separating refactoring commits is not a self­evident\n\nprinciple—it’s only worthwhile if it makes life easier.\n\nLong-Term Refactoring\n\nMost refactoring can be completed within a few minutes—hours at most. But there are\n\nsome larger refactoring efforts that can take a team weeks to complete. Perhaps they\n\nneed to replace an existing library with a new one. Or pull some section of code out into\n\na component that they can share with another team. Or fix some nasty mess of\n\ndependencies that they had allowed to build up.\n\nEven in such cases, I’m reluctant to have a team do dedicated refactoring. Often, a\n\nuseful strategy is to agree to gradually work on the problem over the course of the next\n\nfew weeks. Whenever anyone goes near any code that’s in the refactoring zone, they\n\nmove it a little way in the direction they want to improve. This takes advantage of the\n\nfact that refactoring doesn’t break the code—each small change leaves everything in a\n\nstill­working state. To change from one library to another, start by introducing a new\n\nabstraction that can act as an interface to either library. Once the calling code uses this\n\nabstraction, it’s much easier to switch one library for another. (This tactic is called\n\nBranch By Abstraction [mf­bba].)\n\nRefactoring in a Code Review\n\nSome organizations do regular code reviews; those that don’t would do better if they\n\ndid. Code reviews help spread knowledge through a development team. Reviews help\n\nmore experienced developers pass knowledge to those less experienced. They help more\n\nwww.EBooksWorld.ir",
      "content_length": 2677,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 66,
      "content": "people understand more aspects of a large software system. They are also very\n\nimportant in writing clear code. My code may look clear to me but not to my team.\n\nThat’s inevitable—it’s hard for people to put themselves in the shoes of someone\n\nunfamiliar with whatever they are working on. Reviews also give the opportunity for\n\nmore people to suggest useful ideas. I can only think of so many good ideas in a week.\n\nHaving other people contribute makes my life easier, so I always look for reviews.\n\nI’ve found that refactoring helps me review someone else’s code. Before I started using\n\nrefactoring, I could read the code, understand it to some degree, and make suggestions.\n\nNow, when I come up with ideas, I consider whether they can be easily implemented\n\nthen and there with refactoring. If so, I refactor. When I do it a few times, I can see\n\nmore clearly what the code looks like with the suggestions in place. I don’t have to\n\nimagine what it would be like—I can see it. As a result, I can come up with a second\n\nlevel of ideas that I would never have realized had I not refactored.\n\nRefactoring also helps get more concrete results from the code review. Not only are\n\nthere suggestions; many suggestions are implemented there and then. You end up with\n\nmuch more of a sense of accomplishment from the exercise.\n\nHow I’d embed refactoring into a code review depends on the nature of the review. The\n\ncommon pull request model, where a reviewer looks at code without the original\n\nauthor, doesn’t work too well. It’s better to have the original author of the code present\n\nbecause the author can provide context on the code and fully appreciate the reviewers’\n\nintentions for their changes. I’ve had my best experiences with this by sitting one­on­\n\none with the original author, going through the code and refactoring as we go. The\n\nlogical conclusion of this style is pair programming: continuous code review embedded\n\nwithin the process of programming.\n\nWhat Do I Tell My Manager?\n\nOne of the most common questions I’ve been asked is, “How to tell a manager about\n\nrefactoring?” I’ve certainly seen places were refactoring has become a dirty word—with\n\nmanagers (and customers) believing that refactoring is either correcting errors made\n\nearlier, or work that doesn’t yield valuable features. This is exacerbated by teams\n\nscheduling weeks of pure refactoring—especially if what they are really doing is not\n\nrefactoring but less careful restructuring that causes breakages in the code base.\n\nTo a manager who is genuinely savvy about technology and understands the design\n\nstamina hypothesis, refactoring isn’t hard to justify. Such managers should be\n\nencouraging refactoring on a regular basis and be looking for signs that indicate a team\n\nisn’t doing enough. While it does happen that teams do too much refactoring, it’s much\n\nwww.EBooksWorld.ir",
      "content_length": 2863,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 67,
      "content": "rarer than teams not doing enough.\n\nOf course, many managers and customer don’t have the technical awareness to know\n\nhow code base health impacts productivity. In these cases I give my more controversial\n\nadvice: Don’t tell!\n\nSubversive? I don’t think so. Software developers are professionals. Our job is to build\n\neffective software as rapidly as we can. My experience is that refactoring is a big aid to\n\nbuilding software quickly. If I need to add a new function and the design does not suit\n\nthe change, I find it’s quicker to refactor first and then add the function. If I need to fix\n\na bug, I need to understand how the software works—and I find refactoring is the\n\nfastest way to do this. A schedule­driven manager wants me to do things the fastest way\n\nI can; how I do it is my responsibility. I’m being paid for my expertise in programming\n\nnew capabilities fast, and the fastest way is by refactoring—therefore I refactor.\n\nWhen Should I Not Refactor?\n\nIt may sound like I always recommend refactoring—but there are cases when it’s not\n\nworthwhile.\n\nIf I run across code that is a mess, but I don’t need to modify it, then I don’t need to\n\nrefactor it. Some ugly code that I can treat as an API may remain ugly. It’s only when I\n\nneed to understand how it works that refactoring gives me any benefit.\n\nAnother case is when it’s easier to rewrite it than to refactor it. This is a tricky decision.\n\nOften, I can’t tell how easy it is to refactor some code unless I spend some time trying\n\nand thus get a sense of how difficult it is. The decision to refactor or rewrite requires\n\ngood judgment and experience, and I can’t really boil it down into a piece of simple\n\nadvice.\n\nPROBLEMS WITH REFACTORING\n\nWhenever anyone advocates for some technique, tool, or architecture, I always look for\n\nproblems. Few things in life are all sunshine and clear skies. You need to understand\n\nthe tradeoffs to decide when and where to apply something. I do think refactoring is a\n\nvaluable technique—one that should be used more by most teams. But there are\n\nproblems associated with it, and it’s important to understand how they manifest\n\nthemselves and how we can react to them.\n\nSlowing Down New Features\n\nwww.EBooksWorld.ir",
      "content_length": 2223,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 68,
      "content": "If you read the previous section, you should already know my response. Although many\n\npeople see time spent refactoring as slowing down the development of new features, the\n\nwhole purpose of refactoring is to speed things up. But while this is true, it’s also true\n\nthat the perception of refactoring as slowing things down is still common—and perhaps\n\nthe biggest barrier to people doing enough refactoring.\n\nThe whole purpose of refactoring is to make us program faster, producing\n\nmore value with less effort.\n\nThere is a genuine tradeoff here. I do run into situations where I see a (large­scale)\n\nrefactoring that really needs to be done, but the new feature I want to add is so small\n\nthat I prefer to add it and leave the larger refactoring alone. That’s a judgment call—\n\npart of my professional skills as a programmer. I can’t easily describe, let alone\n\nquantify, how I make that tradeoff.\n\nI’m very conscious that preparatory refactoring often makes a change easier, so I\n\ncertainly will do it if I see that it makes my new feature easier to implement. I’m also\n\nmore inclined to refactor if this is a problem I’ve seen before—sometimes it takes me a\n\ncouple of times seeing some particular ugliness before I decide to refactor it away.\n\nConversely, I’m more likely to not refactor if it’s part of the code I rarely touch and the\n\ncost of the inconvenience isn’t something I feel very often. Sometimes, I delay a\n\nrefactoring because I’m not sure what improvement to do, although at other times I’ll\n\ntry something as an experiment to see if it makes things better.\n\nStill, the evidence I hear from my colleagues in the industry is that too little refactoring\n\nis far more prevalent than too much. In other words, most people should try to refactor\n\nmore often. You may have trouble telling the difference in productivity between a\n\nhealthy and a sickly code base because you haven’t had enough experience of a healthy\n\ncode base—of the power that comes from easily combining existing parts into new\n\nconfigurations to quickly enable complicated new features.\n\nAlthough it’s often managers that are criticized for the counter­productive habit of\n\nsquelching refactoring in the name of speed, I’ve often seen developers do it to\n\nthemselves. Sometimes, they think they shouldn’t be refactoring even though their\n\nleadership is actually in favor. If you’re a tech lead in a team, it’s important to show\n\nteam members that you value improving the health of a code base. That judgment I\n\nmentioned earlier on whether to refactor or not is something that takes years of\n\nexperience to build up. Those with less experience in refactoring need lots of mentoring\n\nto accelerate them through the process.\n\nwww.EBooksWorld.ir",
      "content_length": 2726,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 69,
      "content": "But I think the most dangerous way that people get trapped is when they try to justify\n\nrefactoring in terms of “clean code,” “good engineering practice,” or similar moral\n\nreasons. The point of refactoring isn’t to show how sparkly a code base is—it is purely\n\neconomic. We refactor because it makes us faster—faster to add features, faster to fix\n\nbugs. It’s important to keep that in front of your mind and in front of communication\n\nwith others. The economic benefits of refactoring should always be the driving factor,\n\nand the more that is understood by developers, managers, and customers, the more of\n\nthe “good design” curve we’ll see.\n\nCode Ownership\n\nMany refactorings involve making changes that affect not just the internals of a module\n\nbut its relationships with other parts of a system. If I want to rename a function, and I\n\ncan find all the callers to a function, I simply apply Change Function Declaration (124)\n\nand change the declaration and the callers in one change. But sometimes this simple\n\nrefactoring isn’t possible. Perhaps the calling code is owned by a different team and I\n\ndon’t have write access to their repository. Perhaps the function is a declared API used\n\nby my customers—so I can’t even tell if it’s being used, let alone by who and how much.\n\nSuch functions are part of a published interface—an interface that is used by clients\n\nindependent of those who declare the interface.\n\nCode ownership boundaries get in the way of refactoring because I cannot make the\n\nkinds of changes I want without breaking my clients. This doesn’t prevent refactoring—\n\nI can still do a great deal—but it does impose limitations. When renaming a function, I\n\nneed to use Rename Function (124) and to retain the old declaration as a pass­through\n\nto the new one. This complicates the interface—but it is the price I must pay to avoid\n\nbreaking my clients. I may be able to mark the old interface as deprecated and, in time,\n\nretire it, but sometimes I have to retain that interface forever.\n\nDue to these complexities, I recommend against fine­grained strong code ownership.\n\nSome organizations like any piece of code to have a single programmer as an owner,\n\nand only allow that programmer to change it. I’ve seen a team of three people operate\n\nin such a way that each one published interfaces to the other two. This led to all sorts of\n\ngyrations to maintain interfaces when it would have been much easier to go into the\n\ncode base and make the edits. My preference is to allow team ownership of code—so\n\nthat anyone in the same team can modify the team’s code, even if originally written by\n\nsomeone else. Programmers may have individual responsibility for areas of a system,\n\nbut that should imply that they monitor changes to their area of responsibility, not\n\nblock them by default.\n\nwww.EBooksWorld.ir",
      "content_length": 2830,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 70,
      "content": "Such a more permissive ownership scheme can even exist across teams. Some teams\n\nencourage an open­source­like model where people from other teams can change a\n\nbranch of their code and send the commit in to be approved. This allows one team to\n\nchange the clients of their functions—they can delete the old declarations once their\n\ncommits to their clients have been accepted. This can often be a good compromise\n\nbetween strong code ownership and chaotic changes in large systems.\n\nBranches\n\nAs I write this, a common approach in teams is for each team member to work on a\n\nbranch of the code base using a version control system, and do considerable work on\n\nthat branch before integrating with a mainline (often called master or trunk) shared\n\nacross the team. Often, this involves building a whole feature on a branch, not\n\nintegrating into the mainline until the feature is ready to be released into production.\n\nFans of this approach claim that it keeps the mainline clear of any in­process code,\n\nprovides a clear version history of feature additions, and allows features to be reverted\n\neasily should they cause problems.\n\nThere are downsides to feature branches like this. The longer I work on an isolated\n\nbranch, the harder the job of integrating my work with mainline is going to be when I’m\n\ndone. Most people reduce this pain by frequently merging or re­basing from mainline\n\nto my branch. But this doesn’t really solve the problem when several people are\n\nworking on individual feature branches. I distinguish between merging and integration.\n\nIf I merge mainline into my code, this is a oneway movement—my branch changes but\n\nthe mainline doesn’t. I use “integrate” to mean a two­way process that pulls changes\n\nfrom mainline into my branch and then pushes the result back into mainline, changing\n\nboth. If Rachel is working on her branch I don’t see her changes until she integrates\n\nwith mainline; at that point, I have to merge her changes into my feature branch, which\n\nmay mean considerable work. The hard part of this work is dealing with semantic\n\nchanges. Modern version control systems can do wonders with merging complex\n\nchanges to the program text, but they are blind to the semantics of the code. If I’ve\n\nchanged the name of a function, my version control tool may easily integrate my\n\nchanges with Rachel’s. But if, in her branch, she added a call to a function that I’ve\n\nrenamed in mine, the code will fail.\n\nThe problem of complicated merges gets exponentially worse as the length of feature\n\nbranches increases. Integrating branches that are four weeks old is more than twice as\n\nhard as those that are a couple of weeks old. Many people, therefore, argue for keeping\n\nfeature branches short—perhaps just a couple of days. Others, such as me, want them\n\neven shorter than that. This is an approach called Continuous Integration (CI), also\n\nwww.EBooksWorld.ir",
      "content_length": 2893,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 71,
      "content": "known as Trunk­Based Development. With CI, each team member integrates with\n\nmainline at least once per day. This prevents any branches diverting too far from each\n\nother and thus greatly reduces the complexity of merges. CI doesn’t come for free: It\n\nmeans you use practices to ensure the mainline is healthy, learn to break large features\n\ninto smaller chunks, and use feature toggles (aka feature flags) to switch off any in­\n\nprocess features that can’t be broken down.\n\nFans of CI like it partly because it reduces the complexity of merges, but the dominant\n\nreason to favor CI is that it’s far more compatible with refactoring. Refactorings often\n\ninvolve making lots of little changes all over the code base—which are particularly\n\nprone to semantic merge conflicts (such as renaming a widely used function). Many of\n\nus have seen feature­branching teams that find refactorings so exacerbate merge\n\nproblems that they stop refactoring. CI and re­factoring work well together, which is\n\nwhy Kent Beck combined them in Extreme Programming.\n\nI’m not saying that you should never use feature branches. If they are sufficiently short,\n\ntheir problems are much reduced. (Indeed, users of CI usually also use branches, but\n\nintegrate them with mainline each day.) Feature branches may be the right technique\n\nfor open source projects where you have infrequent commits from programmers who\n\nyou don’t know well (and thus don’t trust). But in a full­time development team, the\n\ncost that feature branches impose on refactoring is excessive. Even if you don’t go to full\n\nCI, I certainly urge you to integrate as frequently as possible. You should also consider\n\nthe objective evidence [Forsgren et al.] that teams that use CI are more effective in\n\nsoftware delivery.\n\nTesting\n\nOne of the key characteristics of refactoring is that it doesn’t change the observable\n\nbehavior of the program. If I follow the refactorings carefully, I shouldn’t break\n\nanything—but what if I make a mistake? (Or, knowing me, s/if/when.) Mistakes\n\nhappen, but they aren’t a problem provided I catch them quickly. Since each refactoring\n\nis a small change, if I break anything, I only have a small change to look at to find the\n\nfault—and if I still can’t spot it, I can revert my version control to the last working\n\nversion.\n\nThe key here is being able to catch an error quickly. To do this, realistically, I need to be\n\nable to run a comprehensive test suite on the code—and run it quickly, so that I’m not\n\ndeterred from running it frequently. This means that in most cases, if I want to refactor,\n\nI need to have self­testing code [mf­stc].\n\nwww.EBooksWorld.ir",
      "content_length": 2642,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 72,
      "content": "To some readers, self­testing code sounds like a requirement so steep as to be\n\nunrealizable. But over the last couple of decades, I’ve seen many teams build software\n\nthis way. It takes attention and dedication to testing, but the benefits make it really\n\nworthwhile. Self­testing code not only enables refactoring—it also makes it much safer\n\nto add new features, since I can quickly find and kill any bugs I introduce. The key point\n\nhere is that when a test fails, I can look at the change I’ve made between when the tests\n\nwere last running correctly and the current code. With frequent test runs, that will be\n\nonly a few lines of code. By knowing it was those few lines that caused the failure, I can\n\nmuch more easily find the bug.\n\nThis also answers those who are concerned that refactoring carries too much risk of\n\nintroducing bugs. Without self­testing code, that’s a reasonable worry—which is why I\n\nput so much emphasis on having solid tests.\n\nThere is another way to deal with the testing problem. If I use an environment that has\n\ngood automated refactorings, I can trust those refactorings even without running tests.\n\nI can then refactor, providing I only use those refactorings that are safely automated.\n\nThis removes a lot of nice refactorings from my menu, but still leaves me enough to\n\ndeliver some useful benefits. I’d still rather have self­testing code, but it’s an option that\n\nis useful to have in the toolkit.\n\nThis also inspires a style of refactoring that only uses a limited set of refactorings that\n\ncan be proven safe. Such refactorings require carefully following the steps, and are\n\nlanguage­specific. But teams using them have found they can do useful refactoring on\n\nlarge code bases with poor test coverage. I don’t focus on that in this book, as it’s a\n\nnewer, less described and understood technique that involves detailed, language­\n\nspecific activity. (It is, however, something I hope talk about more on my web site in the\n\nfuture. For a taste of it, see Jay Bazuzi’s description [Bazuzi] of a safer way to do\n\nExtract Method (106) in C++.)\n\nSelf­testing code is, unsurprisingly, closely associated with Continuous Integration—it\n\nis the mechanism that we use to catch semantic integration conflicts. Such testing\n\npractices are another component of Extreme Programming and a key part of\n\nContinuous Delivery.\n\nLegacy Code\n\nMost people would regard a big legacy as a Good Thing—but that’s one of the cases\n\nwhere programmers’ view is different. Legacy code is often complex, frequently comes\n\nwith poor tests, and, above all, is written by Someone Else (shudder).\n\nwww.EBooksWorld.ir",
      "content_length": 2628,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 73,
      "content": "Refactoring can be a fantastic tool to help understand a legacy system. Functions with\n\nmisleading names can be renamed so they make sense, awkward programming\n\nconstructs smoothed out, and the program turned from a rough rock to a polished gem.\n\nBut the dragon guarding this happy tale is the common lack of tests. If you have a big\n\nlegacy system with no tests, you can’t safely refactor it into clarity.\n\nThe obvious answer to this problem is that you add tests. But while this sounds a\n\nsimple, if laborious, procedure, it’s often much more tricky in practice. Usually, a\n\nsystem is only easy to put under test if it was designed with testing in mind—in which\n\ncase it would have the tests and I wouldn’t be worrying about it.\n\nThere’s no simple route to dealing with this. The best advice I can give is to get a copy of\n\nWorking Effectively with Legacy Code [Feathers] and follow its guidance. Don’t be\n\nworried by the age of the book—its advice is just as true more than a decade later. To\n\nsummarize crudely, it advises you to get the system under test by finding seams in the\n\nprogram where you can insert tests. Creating these seams involves refactoring—which\n\nis much more dangerous since it’s done without tests, but is a necessary risk to make\n\nprogress. This is a situation where safe, automated refactorings can be a godsend. If all\n\nthis sounds difficult, that’s because it is. Sadly, there’s no shortcut to getting out of a\n\nhole this deep—which is why I’m such a strong proponent of writing self­testing code\n\nfrom the start.\n\nEven when I do have tests, I don’t advocate trying to refactor a complicated legacy mess\n\ninto beautiful code all at once. What I prefer to do is tackle it in relevant pieces. Each\n\ntime I pass through a section of the code, I try to make it a little bit better—again, like\n\nleaving a camp site cleaner than when I found it. If this is a large system, I’ll do more\n\nrefactoring in areas I visit frequently—which is the right thing to do because, if I need to\n\nvisit code frequently, I’ll get a bigger payoff by making it easier to understand.\n\nDatabases\n\nWhen I wrote the first edition of this book, I said that refactoring databases was a\n\nproblem area. But, within a year of the book’s publication, that was no longer the case.\n\nMy colleague Pramod Sadalage developed an approach to evolutionary database design\n\n[mf­evodb] and database refactoring [Ambler & Sadalage] that is now widely used. The\n\nessence of the technique is to combine the structural changes to a database’s schema\n\nand access code with data migration scripts that can easily compose to handle large\n\nchanges.\n\nConsider a simple example of renaming a field (column). As in Change Function\n\nDeclaration (124), I need to find the original declaration of the structure and all the\n\nwww.EBooksWorld.ir",
      "content_length": 2812,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 74,
      "content": "callers of this structure and change them in a single change. The complication,\n\nhowever, is that I also have to transform any data that uses the old field to use the new\n\none. I write a small hunk of code that carries out this transform and store it in version\n\ncontrol, together with the code that changes any declared structure and access routines.\n\nThen, whenever I need to migrate between two versions of the database, I run all the\n\nmigration scripts that exist between my current copy of the database and my desired\n\nversion.\n\nAs with regular refactoring, the key here is that each individual change is small yet\n\ncaptures a complete change, so the system still runs after applying the migration.\n\nKeeping them small means they are easy to write, but I can string many of them into a\n\nsequence that can make a significant change to the database’s structure and the data\n\nstored in it.\n\nOne difference from regular refactorings is that database changes often are best\n\nseparated over multiple releases to production. This makes it easy to reverse any\n\nchange that causes a problem in production. So, when renaming a field, my first\n\ncommit would add the new database field but not use it. I may then set up the updates\n\nso they update both old and new fields at once. I can then gradually move the readers\n\nover to the new field. Only once they have all moved to the new field, and I’ve given a\n\nlittle time for any bugs to show themselves, would I remove the now­unused old field.\n\nThis approach to database changes is an example of a general approach of parallel\n\nchange [mf­pc] (also called expand­contract).\n\nREFACTORING, ARCHITECTURE, AND YAGNI\n\nRefactoring has profoundly changed how people think about software architecture.\n\nEarly in my career, I was taught that software design and architecture was something to\n\nbe worked on, and mostly completed, before anyone started writing code. Once the\n\ncode was written, its architecture was fixed and could only decay due to carelessness.\n\nRefactoring changes this perspective. It allows me to significantly alter the architecture\n\nof software that’s been running in production for years. Refactoring can improve the\n\ndesign of existing code, as this book’s subtitle implies. But as I indicated earlier,\n\nchanging legacy code is often challenging, especially when it lacks decent tests.\n\nThe real impact of refactoring on architecture is in how it can be used to form a well­\n\ndesigned code base that can respond gracefully to changing needs. The biggest issue\n\nwith finishing architecture before coding is that such an approach assumes the\n\nrequirements for the software can be understood early on. But experience shows that\n\nwww.EBooksWorld.ir",
      "content_length": 2703,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 75,
      "content": "this is often, even usually, an unachievable goal. Repeatedly, I saw people only\n\nunderstand what they really needed from software once they’d had a chance to use it,\n\nand saw the impact it made to their work.\n\nOne way of dealing with future changes is to put flexibility mechanisms into the\n\nsoftware. As I write some function, I can see that it has a general applicability. To\n\nhandle the different circumstances that I anticipate it to be used in, I can see a dozen\n\nparameters I could add to that function. These parameters are flexibility mechanisms—\n\nand, like most mechanisms, they are not a free lunch. Adding all those parameters\n\ncomplicates the function for the one case it’s used right now. If I miss a parameter, all\n\nthe parameterization I have added makes it harder for me to add more. I find I often get\n\nmy flexibility mechanisms wrong—either because the changing needs didn’t work out\n\nthe way I expected or my mechanism design was faulty. Once I take all that into\n\naccount, most of the time my flexibility mechanisms actually slow down my ability to\n\nreact to change.\n\nWith refactoring, I can use a different strategy. Instead of speculating on what\n\nflexibility I will need in the future and what mechanisms will best enable that, I build\n\nsoftware that solves only the currently understood needs, but I make this software\n\nexcellently designed for those needs. As my understanding of the users’ needs changes,\n\nI use refactoring to adapt the architecture to those new demands. I can happily include\n\nmechanisms that don’t increase complexity (such as small, well­named functions) but\n\nany flexibility that complicates the software has to prove itself before I include it. If I\n\ndon’t have different values for a parameter from the callers, I don’t add it to the\n\nparameter list. Should the time come that I need to add it, then Parameterize Function\n\n(310) is an easy refactoring to apply. I often find it useful to estimate how hard it would\n\nbe to use refactoring later to support an anticipated change. Only if I can see that it\n\nwould be substantially harder to refactor later do I consider adding a flexibility\n\nmechanism now.\n\nThis approach to design goes under various names: simple design, incremental design,\n\nor yagni [mf­yagni] (originally an acronym for “you aren’t going to need it”). Yagni\n\ndoesn’t imply that architectural thinking disappears, although it is sometimes naively\n\napplied that way. I think of yagni as a different style of incorporating architecture and\n\ndesign into the development process—a style that isn’t credible without the foundation\n\nof refactoring.\n\nAdopting yagni doesn’t mean I neglect all upfront architectural thinking. There are still\n\ncases where refactoring changes are difficult and some preparatory thinking can save\n\ntime. But the balance has shifted a long way—I’m much more inclined to deal with www.EBooksWorld.ir",
      "content_length": 2887,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 76,
      "content": "issues later when I understand them better. All this has led to a growing discipline of\n\nevolutionary architecture [Ford et al.] where architects explore the patterns and\n\npractices that take advantage of our ability to iterate over architectural decisions.\n\nREFACTORING AND THE WIDER SOFTWARE DEVELOPMENT PROCESS\n\nIf you’ve read the earlier section on problems, one lesson you’ve probably drawn is that\n\nthe effectiveness of refactoring is tied to other software practices that a team uses.\n\nIndeed, refactoring’s early adoption was as part of Extreme Programming [mf­xp] (XP),\n\na process which was notable for putting together a set of relatively unusual and\n\ninterdependent practices—such as continuous integration, self­testing code, and\n\nrefactoring (the latter two woven into test­driven development).\n\nExtreme Programming was one of the first agile software methods [mf­nm] and, for\n\nseveral years, led the rise of agile techniques. Enough projects now use agile methods\n\nthat agile thinking is generally regarded as mainstream—but in reality most “agile”\n\nprojects only use the name. To really operate in an agile way, a team has to be capable\n\nand enthusiastic refactorers—and for that, many aspects of their process have to align\n\nwith making refactoring a regular part of their work.\n\nThe first foundation for refactoring is self­testing code. By this, I mean that there is a\n\nsuite of automated tests that I can run and be confident that, if I made an error in my\n\nprogramming, some test will fail. This is such an important foundation for refactoring\n\nthat I’ll spend a chapter talking more about this.\n\nTo refactor on a team, it’s important that each member can refactor when they need to\n\nwithout interfering with others’ work. This is why I encourage Continuous Integration.\n\nWith CI, each member’s refactoring efforts are quickly shared with their colleagues. No\n\none ends up building new work on interfaces that are being removed, and if the\n\nrefactoring is going to cause a problem with someone else’s work, we know about this\n\nquickly. Self­testing code is also a key element of Continuous Integration, so there is a\n\nstrong synergy between the three practices of self­testing code, continuous integration,\n\nand refactoring.\n\nWith this trio of practices in place, we enable the Yagni design approach that I talked\n\nabout in the previous section. Refactoring and yagni positively reinforce each other:\n\nNot just is refactoring (and its prerequisites) a foundation for yagni—yagni makes it\n\neasier to do refactoring. This is because it’s easier to change a simple system than one\n\nthat has lots of speculative flexibility included. Balance these practices, and you can get\n\nwww.EBooksWorld.ir",
      "content_length": 2710,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 77,
      "content": "into a virtuous circle with a code base that responds rapidly to changing needs and is\n\nreliable.\n\nWith these core practices in place, we have the foundation to take advantage of the\n\nother elements of the agile mindset. Continuous Delivery keeps our software in an\n\nalways­releasable state. This is what allows many web organizations to release updates\n\nmany times a day—but even if we don’t need that, it reduces risk and allows us to\n\nschedule our releases to satisfy business needs rather than technological constraints.\n\nWith a firm technical foundation, we can drastically reduce the time it takes to get a\n\ngood idea into production code, allowing us to better serve our customers.\n\nFurthermore, these practices increase the reliability of our software, with less bugs to\n\nspend time fixing.\n\nStated like this, it all sounds rather simple—but in practice it isn’t. Software\n\ndevelopment, whatever the approach, is a tricky business, with complex interactions\n\nbetween people and machines. The approach I describe here is a proven way to handle\n\nthis complexity, but like any approach, it requires practice and skill.\n\nREFACTORING AND PERFORMANCE\n\nA common concern with refactoring is the effect it has on the performance of a\n\nprogram. To make the software easier to understand, I often make changes that will\n\ncause the program to run slower. This is an important issue. I don’t belong to the school\n\nof thought that ignores performance in favor of design purity or in hopes of faster\n\nhardware. Software has been rejected for being too slow, and faster machines merely\n\nmove the goalposts. Refactoring can certainly make software go more slowly—but it\n\nalso makes the software more amenable to performance tuning. The secret to fast\n\nsoftware, in all but hard real­time contexts, is to write tunable software first and then\n\ntune it for sufficient speed.\n\nI’ve seen three general approaches to writing fast software. The most serious of these is\n\ntime budgeting, often used in hard real­time systems. As you decompose the design,\n\nyou give each component a budget for resources—time and footprint. That component\n\nmust not exceed its budget, although a mechanism for exchanging budgeted resources\n\nis allowed. Time budgeting focuses attention on hard performance times. It is essential\n\nfor systems, such as heart pacemakers, in which late data is always bad data. This\n\ntechnique is inappropriate for other kinds of systems, such as the corporate\n\ninformation systems with which I usually work.\n\nThe second approach is the constant attention approach. Here, every programmer, all\n\nwww.EBooksWorld.ir",
      "content_length": 2609,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 78,
      "content": "the time, does whatever she can to keep performance high. This is a common approach\n\nthat is intuitively attractive—but it does not work very well. Changes that improve\n\nperformance usually make the program harder to work with. This slows development.\n\nThis would be a cost worth paying if the resulting software were quicker—but usually it\n\nis not. The performance improvements are spread all around the program; each\n\nimprovement is made with a narrow perspective of the program’s behavior, and often\n\nwith a misunderstanding of how a compiler, runtime, and hardware behaves.\n\nIt Takes Awhile to Create Nothing\n\nThe Chrysler Comprehensive Compensation pay process was running too\n\nslowly. Although we were still in development, it began to bother us, because\n\nit was slowing down the tests.\n\nKent Beck, Martin Fowler, and I decided we’d fix it up. While I waited for us\n\nto get together, I was speculating, on the basis of my extensive knowledge of\n\nthe system, about what was probably slowing it down. I thought of several\n\npossibilities and chatted with folks about the changes that were probably\n\nnecessary. We came up with some really good ideas about what would make\n\nthe system go faster.\n\nThen we measured performance using Kent’s profiler. None of the\n\npossibilities I had thought of had anything to do with the problem. Instead, we\n\nfound that the system was spending half its time creating instances of date.\n\nEven more interesting was that all the instances had the same couple of\n\nvalues.\n\nWhen we looked at the date­creation logic, we saw some opportunities for\n\noptimizing how these dates were created. They were all going through a\n\nstring conversion even though no external inputs were involved. The code\n\nwas just using string conversion for convenience of typing. Maybe we could\n\noptimize that.\n\nThen we looked at how these dates were being used. It turned out that the\n\nhuge bulk of them were all creating instances of date range, an object with a\n\nfrom date and a to date. Looking around little more, we realized that most of\n\nthese date ranges were empty!\n\nAs we worked with date range, we used the convention that any date range\n\nthat ended before it started was empty. It’s a good convention and fits in well\n\nwith how the class works. Soon after we started using this convention, we\n\nrealized that just creating a date range that starts after it ends wasn’t clear\n\ncode, so we extracted that behavior into a factory method for empty date\n\nwww.EBooksWorld.ir",
      "content_length": 2483,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 79,
      "content": "ranges.\n\nWe had made that change to make the code clearer, but we received an\n\nunexpected payoff. We created a constant empty date range and adjusted\n\nthe factory method to return that object instead of creating it every time. That\n\nchange doubled the speed of the system, enough for the tests to be\n\nbearable. It took us about five minutes.\n\nI had speculated with various members of the team (Kent and Martin deny\n\nparticipating in the speculation) on what was likely wrong with code we knew\n\nvery well. We had even sketched some designs for improvements without\n\nfirst measuring what was going on.\n\nWe were completely wrong. Aside from having a really interesting\n\nconversation, we were doing no good at all.\n\nThe lesson is: Even if you know exactly what is going on in your system,\n\nmeasure performance, don’t speculate. You’ll learn something, and nine\n\ntimes out of ten, it won’t be that you were right!\n\n— Ron Jeffries\n\nThe interesting thing about performance is that in most\n\nprograms, most of their time is spent in a small fraction of the code. If I optimize all the\n\ncode equally, I’ll end up with 90 percent of my work wasted because it’s optimizing\n\ncode that isn’t run much. The time spent making the program fast—the time lost\n\nbecause of lack of clarity—is all wasted time.\n\nThe third approach to performance improvement takes advantage of this 90­percent\n\nstatistic. In this approach, I build my program in a well­factored manner without\n\npaying attention to performance until I begin a deliberate performance optimization\n\nexercise. During this performance optimization, I follow a specific process to tune the\n\nprogram.\n\nI begin by running the program under a profiler that monitors the program and tells me\n\nwhere it is consuming time and space. This way I can find that small part of the\n\nprogram where the performance hot spots lie. I then focus on those performance hot\n\nspots using the same optimizations I would use in the constant­attention approach. But\n\nsince I’m focusing my attention on a hot spot, I’m getting much more effect with less\n\nwork. Even so, I remain cautious. As in refactoring, I make the changes in small steps.\n\nAfter each step I compile, test, and rerun the profiler. If I haven’t improved\n\nperformance, I back out the change. I continue the process of finding and removing hot\n\nspots until I get the performance that satisfies my users.\n\nwww.EBooksWorld.ir",
      "content_length": 2403,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 80,
      "content": "Having a well­factored program helps with this style of optimization in two ways. First,\n\nit gives me time to spend on performance tuning. With well­factored code, I can add\n\nfunctionality more quickly. This gives me more time to focus on performance. (Profiling\n\nensures I spend that time on the right place.) Second, with a well­factored program I\n\nhave finer granularity for my performance analysis. My profiler leads me to smaller\n\nparts of the code, which are easier to tune. With clearer code, I have a better\n\nunderstanding of my options and of what kind of tuning will work.\n\nI’ve found that refactoring helps me write fast software. It slows the software in the\n\nshort term while I’m refactoring, but makes it easier to tune during optimization. I end\n\nup well ahead.\n\nWHERE DID REFACTORING COME FROM?\n\nI’ve not succeeded in pinning down the birth of the term “refactoring.” Good\n\nprogrammers have always spent at least some time cleaning up their code. They do this\n\nbecause they have learned that clean code is easier to change than complex and messy\n\ncode, and good programmers know that they rarely write clean code the first time\n\naround.\n\nRefactoring goes beyond this. In this book, I’m advocating refactoring as a key element\n\nin the whole process of software development. Two of the first people to recognize the\n\nimportance of refactoring were Ward Cunningham and Kent Beck, who worked with\n\nSmalltalk from the 1980s onward. Smalltalk is an environment that even then was\n\nparticularly hospitable to refactoring. It is a very dynamic environment that allows you\n\nto quickly write highly functional software. Smalltalk had a very short compile­link­\n\nexecute cycle for its time, which made it easy to change things quickly at a time where\n\novernight compile cycles were not unknown. It is also object­oriented and thus provides\n\npowerful tools for minimizing the impact of change behind well­defined interfaces.\n\nWard and Kent explored software development approaches geared to this kind of\n\nenvironment, and their work developed into Extreme Programming. They realized that\n\nrefactoring was important in improving their productivity and, ever since, have been\n\nworking with refactoring, applying it to serious software projects and refining it.\n\nWard and Kent’s ideas were a strong influence on the Smalltalk community, and the\n\nnotion of refactoring became an important element in the Smalltalk culture. Another\n\nleading figure in the Smalltalk community is Ralph Johnson, a professor at the\n\nUniversity of Illinois at Urbana­Champaign, who is famous as one of the authors of the\n\n“Gang of Four” [gof] book on design patterns. One of Ralph’s biggest interests is in\n\ndeveloping software frameworks. He explored how refactoring can help develop an\n\nwww.EBooksWorld.ir",
      "content_length": 2785,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 81,
      "content": "efficient and flexible framework.\n\nBill Opdyke was one of Ralph’s doctoral students and was particularly interested in\n\nframeworks. He saw the potential value of refactoring and saw that it could be applied\n\nto much more than Smalltalk. His background was in telephone switch development, in\n\nwhich a great deal of complexity accrues over time and changes are difficult to make.\n\nBill’s doctoral research looked at refactoring from a tool builder’s perspective. Bill was\n\ninterested in refactorings that would be useful for C++ framework development; he\n\nresearched the necessary semantics­preserving refactorings and showed how to prove\n\nthey were semantics­preserving and how a tool could implement these ideas. Bill’s\n\ndoctoral thesis [Opdyke] was the first substantial work on refactoring.\n\nI remember meeting Bill at the OOPSLA conference in 1992. We sat in a café and he\n\ntold me about his research. I remember thinking, “Interesting, but not really that\n\nimportant.” Boy, was I wrong!\n\nJohn Brant and Don Roberts took the refactoring tool ideas much further to produce\n\nthe Refactoring Browser, the first refactoring tool, appropriately for the Smalltalk\n\nenvironment.\n\nAnd me? I’d always been inclined to clean code, but I’d never considered it to be that\n\nimportant. Then, I worked on a project with Kent and saw the way he used refactoring.\n\nI saw the difference it made in productivity and quality. That experience convinced me\n\nthat refactoring was a very important technique. I was frustrated, however, because\n\nthere was no book that I could give to a working programmer, and none of the experts\n\nabove had any plans to write such a book. So, with their help, I did—which led to the\n\nfirst edition of this book.\n\nFortunately, the concept of refactoring caught on in the industry. The book sold well,\n\nand refactoring entered the vocabulary of most programmers. More tools appeared,\n\nespecially for Java. One downside of this popularity has been people using “refactoring”\n\nloosely, to mean any kind of restructuring. Despite this, however, it has become a\n\nmainstream practice.\n\nAUTOMATED REFACTORINGS\n\nPerhaps the biggest change to refactoring in the last decade or so is the availability of\n\ntools that support automated refactoring. If I want to rename a method in Java and I’m\n\nusing IntelliJ IDEA [intellij] or Eclipse [eclipse] (to mention just two), I can do it by\n\npicking an item off the menu. The tool completes the refactoring for me—and I’m\n\nusually sufficiently confident in its work that I don’t bother running the test suite. www.EBooksWorld.ir",
      "content_length": 2573,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 82,
      "content": "The first tool that did this was the Smalltalk Refactoring Browser, written by John\n\nBrandt and Don Roberts. The idea took off in the Java community very rapidly at the\n\nbeginning of the century. When JetBrains launched their IntelliJ IDEA IDE, automated\n\nrefactoring was one of the compelling features. IBM followed suit shortly afterwards\n\nwith refactoring tools in Visual Age for Java. Visual Age didn’t have a big impact, but\n\nmuch of its capabilities were reimplemented in Eclipse, including the refactoring\n\nsupport.\n\nRefactoring also came to C#, initially via JetBrains’s Resharper, a plug­in for Visual\n\nStudio. Later on, the Visual Studio team added some refactoring capabilities.\n\nIt’s now pretty common to find some kind of refactoring support in editors and tools,\n\nalthough the actual capabilities vary a fair bit. Some of this variation is due to the tool,\n\nsome is caused by the limitations of what you can do with automated refactoring in\n\ndifferent languages. I’m not going to analyze the capabilities of different tools here, but\n\nI think it is worth talking a bit about some of the underlying principles.\n\nA crude way to automate a refactoring is to do text manipulation, such as a\n\nsearch/replace to change a name, or some simple reorganizing of code for Extract\n\nVariable (119). This is a very crude approach that certainly can’t be trusted without\n\nrerunning tests. It can, however, be a handy first step. I’ll use such macros in Emacs to\n\nspeed up my refactoring work when I don’t have more sophisticated refactorings\n\navailable to me.\n\nTo do refactoring properly, the tool has to operate on the syntax tree of the code, not on\n\nthe text. Manipulating the syntax tree is much more reliable to preserve what the code\n\nis doing. This is why at the moment, most refactoring capabilities are part of powerful\n\nIDEs—they use the syntax tree not just for refactoring but also for code navigation,\n\nlinting, and the like. This collaboration between text and syntax tree is what takes them\n\nbeyond text editors.\n\nRefactoring isn’t just understanding and updating the syntax tree. The tool also needs\n\nto figure out how to rerender the code into text back in the editor view. All in all,\n\nimplementing decent refactoring is a challenging programming exercise—one that I’m\n\nmostly unaware of as I gaily use the tools.\n\nMany refactorings are made much safer when applied in a language with static typing.\n\nConsider the simple Rename Function (124). I might have addClient methods on my\n\nSalesman class and on my Server class. I want to rename the one on my salesman,\n\nbut it is different in intent from the one on my server, which I don’t want to rename.\n\nwww.EBooksWorld.ir",
      "content_length": 2686,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 83,
      "content": "Without static typing, the tool will find it difficult to tell whether any call to addClient\n\nis intended for the salesman. In the refactoring browser, it would generate a list of call\n\nsites and I would manually decide which ones to change. This makes it a nonsafe\n\nrefactoring that forces me to rerun the tests. Such a tool is still helpful—but the\n\nequivalent operation in Java can be completely safe and automatic. Since the tool can\n\nresolve the method to the correct class with static typing, I can be confident that the\n\ntool changes only the methods it ought to.\n\nTools often go further. If I rename a variable, I can be prompted for changes to\n\ncomments that use that name. If I use Extract Function (106), the tool spots some code\n\nthat duplicates the new function’s body and offers to replace it with a call.\n\nProgramming with powerful refactorings like this is a compelling reason to use an IDE\n\nrather than stick with a familiar text editor. Personally I’m a big user of Emacs, but\n\nwhen working in Java I prefer IntelliJ IDEA or Eclipse—in large part due to the\n\nrefactoring support.\n\nWhile sophisticated refactoring tools are almost magical in their ability to safely\n\nrefactor code, there are some edge cases where they slip up. Less mature tools struggle\n\nwith reflective calls, such as Method.invoke in Java (although more mature tools\n\nhandle this quite well). So even with mostly safe refactorings, it’s wise to run the test\n\nsuite every so often to ensure nothing has gone pear­shaped. Usually I’m refactoring\n\nwith a mix of automated and manual refactorings, so I run my tests often enough.\n\nThe power of using the syntax tree to analyze and refactor programs is a compelling\n\nadvantage for IDEs over simple text editors, but many programmers prefer the\n\nflexibility of their favorite text editor and would like to have both. A technology that’s\n\ncurrently gaining momentum is Language Servers [langserver]: software that will form\n\na syntax tree and present an API to text editors. Such language servers can support\n\nmany text editors and provide commands to do sophisticated code analysis and\n\nrefactoring operations.\n\nGOING FURTHER\n\nIt seems a little strange to be talking about further reading in only the second chapter,\n\nbut this is as good a spot as any to point out there is more material out there on\n\nrefactoring that goes beyond the basics in this book.\n\nThis book has taught refactoring to many people, but I have focused more on a\n\nrefactoring reference than on taking readers through the learning process. If you are\n\nlooking for such a book, I suggest Bill Wake’s Refactoring Workbook [Wake] that\n\nwww.EBooksWorld.ir",
      "content_length": 2653,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 84,
      "content": "contains many exercises to practice refactoring.\n\nMany of those who pioneered refactoring were also active in the software patterns\n\ncommunity. Josh Kerievsky tied these two worlds closely together with Refactoring to\n\nPatterns [Kerievsky], which looks at the most valuable patterns from the hugely\n\ninfluential “Gang of Four” book [gof] and shows how to use refactoring to evolve\n\ntowards them.\n\nThis book concentrates on refactoring in general­purpose programming, but\n\nrefactoring also applies in specialized areas. Two that have got useful attention are\n\nRefactoring Databases [Ambler & Sadalage] (by Scott Ambler and Pramod Sadalage)\n\nand Refactoring HTML [Harold] (by Elliotte Rusty Harold).\n\nAlthough it doesn’t have refactoring in the title, also worth including is Michael\n\nFeathers’s Working Effectively with Legacy Code [Feathers], which is primarily a book\n\nabout how to think about refactoring an older codebase with poor test coverage.\n\nAlthough this book (and its predecessor) are intended for programmers with any\n\nlanguage, there is a place for language­specific refactoring books. Two of my former\n\ncolleagues, Jay Fields and Shane Harvey, did this for the Ruby programming language\n\n[Fields et al.].\n\nFor more up­to­date material, look up the web representation of this book, as well as\n\nthe main refactoring web site: refactoring.com [ref.com].\n\nwww.EBooksWorld.ir",
      "content_length": 1384,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 85,
      "content": "Chapter 3 Bad Smells in Code\n\nHistory\n\nTopics\n\nby Kent Beck and Martin Fowler\n\nTutorials\n\n“If it stinks, change it.”\n\n— Grandma Beck, discussing child­rearing philosophy\n\nOffers & Deals\n\nBy now you have a good idea of how refactoring works. But just because you know how\n\nHighlights\n\ndoesn’t mean you know when. Deciding when to start refactoring—and when to stop—is\n\njust as important to refactoring as knowing how to operate the mechanics of it.\n\nSettings\n\nNow comes the dilemma. It is easy to explain how to delete an instance variable or\n\nSupport\n\ncreate a hierarchy. These are simple matters. Trying to explain when you should do\n\nthese things is not so cut­and­dried. Instead of appealing to some vague notion of\n\nSign Out\n\nprogramming aesthetics (which, frankly, is what we consultants usually do), I wanted\n\nsomething a bit more solid.\n\nWhen I was writing the first edition of this book, I was mulling over this issue as I\n\nvisited Kent Beck in Zurich. Perhaps he was under the influence of the odors of his\n\nnewborn daughter at the time, but he had come up with the notion of describing the\n\n“when” of refactoring in terms of smells.\n\n“Smells,” you say, “and that is supposed to be better than vague aesthetics?” Well, yes.\n\nWe have looked at lots of code, written for projects that span the gamut from wildly\n\nsuccessful to nearly dead. In doing so, we have learned to look for certain structures in\n\nthe code that suggest—sometimes, scream for—the possibility of refactoring. (We are\n\nswitching over to “we” in this chapter to reflect the fact that Kent and I wrote this\n\nchapter jointly. You can tell the difference because the funny jokes are mine and the\n\nothers are his.)\n\nOne thing we won’t try to give you is precise criteria for when a refactoring is overdue.\n\nIn our experience, no set of metrics rivals informed human intuition. What we will do is\n\ngive you indications that there is trouble that can be solved by a refactoring. You will\n\nwww.EBooksWorld.ir",
      "content_length": 1977,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 86,
      "content": "have to develop your own sense of how many instance variables or how many lines of\n\ncode in a method are too many.\n\nUse this chapter and the table on the inside back cover as a way to give you inspiration\n\nwhen you’re not sure what refactorings to do. Read the chapter (or skim the table) and\n\ntry to identify what it is you’re smelling, then go to the refactorings we suggest to see\n\nwhether they will help you. You may not find the exact smell you can detect, but\n\nhopefully it should point you in the right direction.\n\nMYSTERIOUS NAME\n\nPuzzling over some text to understand what’s going on is a great thing if you’re reading\n\na detective novel, but not when you’re reading code. We may fantasize about being\n\nInternational Men of Mystery, but our code needs to be mundane and clear. One of the\n\nmost important parts of clear code is good names, so we put a lot of thought into\n\nnaming functions, modules, variables, classes, so they clearly communicate what they\n\ndo and how to use them.\n\nSadly, however, naming is one of the two hard things [mf­2h] in programming. So,\n\nperhaps the most common refactorings we do are the renames: Change Function\n\nDeclaration (124) (to rename a function), Rename Variable (137), and Rename Field\n\n(244). People are often afraid to rename things, thinking it’s not worth the trouble, but\n\na good name can save hours of puzzled incomprehension in the future.\n\nRenaming is not just an exercise in changing names. When you can’t think of a good\n\nname for something, it’s often a sign of a deeper design malaise. Puzzling over a tricky\n\nname has often led us to significant simplifications to our code.\n\nDUPLICATED CODE\n\nIf you see the same code structure in more than one place, you can be sure that your\n\nprogram will be better if you find a way to unify them. Duplication means that every\n\ntime you read these copies, you need to read them carefully to see if there’s any\n\ndifference. If you need to change the duplicated code, you have to find and catch each\n\nduplication.\n\nThe simplest duplicated code problem is when you have the same expression in two\n\nmethods of the same class. Then all you have to do is Extract Function (106) and invoke\n\nthe code from both places. If you have code that’s similar, but not quite identical, see if\n\nyou can use Slide Statements (223) to arrange the code so the similar items are all\n\ntogether for easy extraction. If the duplicate fragments are in subclasses of a common\n\nwww.EBooksWorld.ir",
      "content_length": 2465,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 87,
      "content": "base class, you can use Pull Up Method (350) to avoid calling one from another.\n\nLONG FUNCTION\n\nIn our experience, the programs that live best and longest are those with short\n\nfunctions. Programmers new to such a code base often feel that no computation ever\n\ntakes place—that the program is an endless sequence of delegation. When you have\n\nlived with such a program for a few years, however, you learn just how valuable all\n\nthose little functions are. All of the payoffs of indirection—explanation, sharing, and\n\nchoosing—are supported by small functions.\n\nSince the early days of programming, people have realized that the longer a function is,\n\nthe more difficult it is to understand. Older languages carried an overhead in\n\nsubroutine calls, which deterred people from small functions. Modern languages have\n\npretty much eliminated that overhead for in­process calls. There is still overhead for the\n\nreader of the code because you have to switch context to see what the function does.\n\nDevelopment environments that allow you to quickly jump between a function call and\n\nits declaration, or to see both functions at once, help eliminate this step, but the real\n\nkey to making it easy to understand small functions is good naming. If you have a good\n\nname for a function, you mostly don’t need to look at its body.\n\nThe net effect is that you should be much more aggressive about decomposing\n\nfunctions. A heuristic we follow is that whenever we feel the need to comment\n\nsomething, we write a function instead. Such a function contains the code that we\n\nwanted to comment but is named after the intention of the code rather than the way it\n\nworks. We may do this on a group of lines or even on a single line of code. We do this\n\neven if the method call is longer than the code it replaces—provided the method name\n\nexplains the purpose of the code. The key here is not function length but the semantic\n\ndistance between what the method does and how it does it.\n\nNinety­nine percent of the time, all you have to do to shorten a function is Extract\n\nFunction (106). Find parts of the function that seem to go nicely together and make a\n\nnew one.\n\nIf you have a function with lots of parameters and temporary variables, they get in the\n\nway of extracting. If you try to use Extract Function (106), you end up passing so many\n\nparameters to the extracted method that the result is scarcely more readable than the\n\noriginal. You can often use Replace Temp with Query (178) to eliminate the temps.\n\nLong lists of parameters can be slimmed down with Introduce Parameter Object (140)\n\nand Preserve Whole Object (319).\n\nwww.EBooksWorld.ir",
      "content_length": 2637,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 88,
      "content": "If you’ve tried that and you still have too many temps and parameters, it’s time to get\n\nout the heavy artillery: Replace Function with Command (337).\n\nHow do you identify the clumps of code to extract? A good technique is to look for\n\ncomments. They often signal this kind of semantic distance. A block of code with a\n\ncomment that tells you what it is doing can be replaced by a method whose name is\n\nbased on the comment. Even a single line is worth extracting if it needs explanation.\n\nConditionals and loops also give signs for extractions. Use Decompose Conditional\n\n(260) to deal with conditional expressions. A big switch statement should have its legs\n\nturned into single function calls with Extract Function (106). If there’s more than one\n\nswitch statement switching on the same condition, you should apply Replace\n\nConditional with Polymorphism (272).\n\nWith loops, extract the loop and the code within the loop into its own method. If you\n\nfind it hard to give an extracted loop a name, that may be because it’s doing two\n\ndifferent things—in which case don’t be afraid to use Split Loop (227) to break out the\n\nseparate tasks.\n\nLONG PARAMETER LIST\n\nIn our early programming days, we were taught to pass in as parameters everything\n\nneeded by a function. This was understandable because the alternative was global data,\n\nand global data quickly becomes evil. But long parameter lists are often confusing in\n\ntheir own right.\n\nIf you can obtain one parameter by asking another parameter for it, you can use\n\nReplace Parameter with Query (324) to remove the second parameter. Rather than\n\npulling lots of data out of an existing data structure, you can use Preserve Whole Object\n\n(319) to pass the original data structure instead. If several parameters always fit\n\ntogether, combine them with Introduce Parameter Object (140). If a parameter is used\n\nas a flag to dispatch different behavior, use Remove Flag Argument (314).\n\nClasses are a great way to reduce parameter list sizes. They are particularly useful when\n\nmultiple functions share several parameter values. Then, you can use Combine\n\nFunctions into Class (144) to capture those common values as fields. If we put on our\n\nfunctional programming hats, we’d say this creates a set of partially applied functions.\n\nGLOBAL DATA\n\nSince our earliest days of writing software, we were warned of the perils of global data—\n\nwww.EBooksWorld.ir",
      "content_length": 2404,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 89,
      "content": "how it was invented by demons from the fourth plane of hell, which is the resting place\n\nof any programmer who dares to use it. And, although we are somewhat skeptical about\n\nfire and brimstone, it’s still one of the most pungent odors we are likely to run into. The\n\nproblem with global data is that it can be modified from anywhere in the code base, and\n\nthere’s no mechanism to discover which bit of code touched it. Time and again, this\n\nleads to bugs that breed from a form of spooky action from a distance—and it’s very\n\nhard to find out where the errant bit of program is. The most obvious form of global\n\ndata is global variables, but we also see this problem with class variables and singletons.\n\nOur key defense here is Encapsulate Variable (132), which is always our first move\n\nwhen confronted with data that is open to contamination by any part of a program. At\n\nleast when you have it wrapped by a function, you can start seeing where it’s modified\n\nand start to control its access. Then, it’s good to limit its scope as much as possible by\n\nmoving it within a class or module where only that module’s code can see it.\n\nGlobal data is especially nasty when it’s mutable. Global data that you can guarantee\n\nnever changes after the program starts is relatively safe—if you have a language that can\n\nenforce that guarantee.\n\nGlobal data illustrates Paracelsus’s maxim: The difference between a poison and\n\nsomething benign is the dose. You can get away with small doses of global data, but it\n\ngets exponentially harder to deal with the more you have. Even with little bits, we like\n\nto keep it encapsulated—that’s the key to coping with changes as the software evolves.\n\nMUTABLE DATA\n\nChanges to data can often lead to unexpected consequences and tricky bugs. I can\n\nupdate some data here, not realizing that another part of the software expects\n\nsomething different and now fails—a failure that’s particularly hard to spot if it only\n\nhappens under rare conditions. For this reason, an entire school of software\n\ndevelopment—functional programming—is based on the notion that data should never\n\nchange and that updating a data structure should always return a new copy of the\n\nstructure with the change, leaving the old data pristine.\n\nThese kinds of languages, however, are still a relatively small part of programming;\n\nmany of us work in languages that allow variables to vary. But this doesn’t mean we\n\nshould ignore the advantages of immutability—there are still many things we can do to\n\nlimit the risks on unrestricted data updates.\n\nYou can use Encapsulate Variable (132) to ensure that all updates occur through\n\nnarrow functions that can be easier to monitor and evolve. If a variable is being updated\n\nwww.EBooksWorld.ir",
      "content_length": 2745,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 90,
      "content": "to store different things, use Split Variable (240) both to keep them separate and avoid\n\nthe risky update. Try as much as possible to move logic out of code that processes the\n\nupdate by using Slide Statements (223) and Extract Function (106) to separate the\n\nside­effect­free code from anything that performs the update. In APIs, use Separate\n\nQuery from Modifier (306) to ensure callers don’t need to call code that has side effects\n\nunless they really need to. We like to use Remove Setting Method (331) as soon as we\n\ncan—sometimes, just trying to find clients of a setter helps spot opportunities to reduce\n\nthe scope of a variable.\n\nMutable data that can be calculated elsewhere is particularly pungent. It’s not just a\n\nrich source of confusion, bugs, and missed dinners at home—it’s also unnecessary. We\n\nspray it with a concentrated solution of vinegar and Replace Derived Variable with\n\nQuery (248).\n\nMutable data isn’t a big problem when it’s a variable whose scope is just a couple of\n\nlines—but its risk increases as its scope grows. Use Combine Functions into Class (144)\n\nor Combine Functions into Transform (149) to limit how much code needs to update a\n\nvariable. If a variable contains some data with internal structure, it’s usually better to\n\nreplace the entire structure rather than modify it in place, using Change Reference to\n\nValue (252).\n\nDIVERGENT CHANGE\n\nWe structure our software to make change easier; after all, software is meant to be soft.\n\nWhen we make a change, we want to be able to jump to a single clear point in the\n\nsystem and make the change. When you can’t do this, you are smelling one of two\n\nclosely related pungencies.\n\nDivergent change occurs when one module is often changed in different ways for\n\ndifferent reasons. If you look at a module and say, “Well, I will have to change these\n\nthree functions every time I get a new database; I have to change these four functions\n\nevery time there is a new financial instrument,” this is an indication of divergent\n\nchange. The database interaction and financial processing problems are separate\n\ncontexts, and we can make our programming life better by moving such contexts into\n\nseparate modules. That way, when we have a change to one context, we only have to\n\nunderstand that one context and ignore the other. We always found this to be\n\nimportant, but now, with our brains shrinking with age, it becomes all the more\n\nimperative. Of course, you often discover this only after you’ve added a few databases\n\nor financial instruments; context boundaries are usually unclear in the early days of a\n\nprogram and continue to shift as a software system’s capabilities change.\n\nwww.EBooksWorld.ir",
      "content_length": 2685,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 91,
      "content": "If the two aspects naturally form a sequence—for example, you get data from the\n\ndatabase and then apply your financial processing on it—then Split Phase (154)\n\nseparates the two with a clear data structure between them. If there’s more back­and­\n\nforth in the calls, then create appropriate modules and use Move Function (198) to\n\ndivide the processing up. If functions mix the two types of processing within\n\nthemselves, use Extract Function (106) to separate them before moving. If the modules\n\nare classes, then Extract Class (182) helps formalize how to do the split.\n\nSHOTGUN SURGERY\n\nShotgun surgery is similar to divergent change but is the opposite. You whiff this when,\n\nevery time you make a change, you have to make a lot of little edits to a lot of different\n\nclasses. When the changes are all over the place, they are hard to find, and it’s easy to\n\nmiss an important change.\n\nIn this case, you want to use Move Function (198) and Move Field (207) to put all the\n\nchanges into a single module. If you have a bunch of functions operating on similar\n\ndata, use Combine Functions into Class (144). If you have functions that are\n\ntransforming or enriching a data structure, use Combine Functions into Transform\n\n(149). Split Phase (154) is often useful here if the common functions can combine their\n\noutput for a consuming phase of logic.\n\nA useful tactic for shotgun surgery is to use inlining refactorings, such as Inline\n\nFunction (115) or Inline Class (186), to pull together poorly separated logic. You’ll end\n\nup with a Long Method or a Large Class, but can then use extractions to break it up into\n\nmore sensible pieces. Even though we are inordinately fond of small functions and\n\nclasses in our code, we aren’t afraid of creating something large as an intermediate step\n\nto reorganization.\n\nFEATURE ENVY\n\nWhen we modularize a program, we are trying to separate the code into zones to\n\nmaximize the interaction inside a zone and minimize interaction between zones. A\n\nclassic case of Feature Envy occurs when a function in one module spends more time\n\ncommunicating with functions or data inside another module than it does within its\n\nown module. We’ve lost count of the times we’ve seen a function invoking half­a­dozen\n\ngetter methods on another object to calculate some value. Fortunately, the cure for that\n\ncase is obvious: The function clearly wants to be with the data, so use Move Function\n\n(198) to get it there. Sometimes, only a part of a function suffers from envy, in which\n\ncase use Extract Function (106) on the jealous bit, and Move Function (198) to give it a\n\nwww.EBooksWorld.ir",
      "content_length": 2617,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 92,
      "content": "dream home.\n\nOf course not all cases are cut­and­dried. Often, a function uses features of several\n\nmodules, so which one should it live with? The heuristic we use is to determine which\n\nmodule has most of the data and put the function with that data. This step is often\n\nmade easier if you use Extract Function (106) to break the function into pieces that go\n\ninto different places.\n\nOf course, there are several sophisticated patterns that break this rule. From the Gang\n\nof Four [gof], Strategy and Visitor immediately leap to mind. Kent Beck’s Self\n\nDelegation [Beck SBPP] is another. Use these to combat the divergent change smell.\n\nThe fundamental rule of thumb is to put things together that change together. Data and\n\nthe behavior that references that data usually change together—but there are\n\nexceptions. When the exceptions occur, we move the behavior to keep changes in one\n\nplace. Strategy and Visitor allow you to change behavior easily because they isolate the\n\nsmall amount of behavior that needs to be overridden, at the cost of further indirection.\n\nDATA CLUMPS\n\nData items tend to be like children: They enjoy hanging around together. Often, you’ll\n\nsee the same three or four data items together in lots of places: as fields in a couple of\n\nclasses, as parameters in many method signatures. Bunches of data that hang around\n\ntogether really ought to find a home together. The first step is to look for where the\n\nclumps appear as fields. Use Extract Class (182) on the fields to turn the clumps into an\n\nobject. Then turn your attention to method signatures using Introduce Parameter\n\nObject (140) or Preserve Whole Object (319) to slim them down. The immediate benefit\n\nis that you can shrink a lot of parameter lists and simplify method calling. Don’t worry\n\nabout data clumps that use only some of the fields of the new object. As long as you are\n\nreplacing two or more fields with the new object, you’ll come out ahead.\n\nA good test is to consider deleting one of the data values. If you did this, would the\n\nothers make any sense? If they don’t, it’s a sure sign that you have an object that’s dying\n\nto be born.\n\nYou’ll notice that we advocate creating a class here, not a simple record structure. We\n\ndo this because using a class gives you the opportunity to make a nice perfume. You can\n\nnow look for cases of feature envy, which will suggest behavior that can be moved into\n\nyour new classes. We’ve often seen this as a powerful dynamic that creates useful\n\nclasses and can remove a lot of duplication and accelerate future development, allowing\n\nthe data to become productive members of society.\n\nwww.EBooksWorld.ir\n\nPRIMITIVE OBSESSION",
      "content_length": 2668,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 93,
      "content": "PRIMITIVE OBSESSION\n\nMost programming environments are built on a widely used set of primitive types:\n\nintegers, floating point numbers, and strings. Libraries may add some additional small\n\nobjects such as dates. We find many programmers are curiously reluctant to create\n\ntheir own fundamental types which are useful for their domain—such as money,\n\ncoordinates, or ranges. We thus see calculations that treat monetary amounts as plain\n\nnumbers, or calculations of physical quantities that ignore units (adding inches to\n\nmillimeters), or lots of code doing if (a < upper && a > lower).\n\nStrings are particularly common petri dishes for this kind of odor: A telephone number\n\nis more than just a collection of characters. If nothing else, a proper type can often\n\ninclude consistent display logic for when it needs to be displayed in a user interface.\n\nRepresenting such types as strings is such a common stench that people call them\n\n“stringly typed” variables.\n\nYou can move out of the primitive cave into the centrally heated world of meaningful\n\ntypes by using Replace Primitive with Object (174). If the primitive is a type code\n\ncontrolling conditional behavior, use Replace Type Code with Subclasses (362)\n\nfollowed by Replace Conditional with Polymorphism (272).\n\nGroups of primitives that commonly appear together are data clumps and should be\n\ncivilized with Extract Class (182) and Introduce Parameter Object (140).\n\nREPEATED SWITCHES\n\nTalk to a true object­oriented evangelist and they’ll soon get onto the evils of switch\n\nstatements. They’ll argue that any switch statement you see is begging for Replace\n\nConditional with Polymorphism (272). We’ve even heard some people argue that all\n\nconditional logic should be replaced with polymorphism, tossing most ifs into the\n\ndustbin of history.\n\nEven in our more wild­eyed youth, we were never unconditionally opposed to the\n\nconditional. Indeed, the first edition of this book had a smell entitled “switch\n\nstatements.” The smell was there because in the late 90’s we found polymorphism sadly\n\nunderappreciated, and saw benefit in getting people to switch over.\n\nThese days there is more polymorphism about, and it isn’t the simple red flag that it\n\noften was fifteen years ago. Furthermore, many languages support more sophisticated\n\nforms of switch statements that use more than some primitive code as their base. So we\n\nnow focus on the repeated switch, where the same conditional switching logic (either in\n\nwww.EBooksWorld.ir",
      "content_length": 2493,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 94,
      "content": "a switch/case statement or in a cascade of if/else statements) pops up in different\n\nplaces. The problem with such duplicate switches is that, whenever you add a clause,\n\nyou have to find all the switches and update them. Against the dark forces of such\n\nrepetition, polymorphism provides an elegant weapon for a more civilized codebase.\n\nLOOPS\n\nLoops have been a core part of programming since the earliest languages. But we feel\n\nthey are no more relevant today than bell­bottoms and flock wallpaper. We disdained\n\nthem at the time of the first edition—but Java, like most other languages at the time,\n\ndidn’t provide a better alternative. These days, however, first­class functions are widely\n\nsupported, so we can use Replace Loop with Pipeline (231) to retire those\n\nanachronisms. We find that pipeline operations, such as filter and map, help us quickly\n\nsee the elements that are included in the processing and what is done with them.\n\nLAZY ELEMENT\n\nWe like using program elements to add structure—providing opportunities for\n\nvariation, reuse, or just having more helpful names. But sometimes the structure isn’t\n\nneeded. It may be a function that’s named the same as its body code reads, or a class\n\nthat is essentially one simple function. Sometimes, this reflects a function that was\n\nexpected to grow and be popular later, but never realized its dreams. Sometimes, it’s a\n\nclass that used to pay its way, but has been downsized with refactoring. Either way,\n\nsuch program elements need to die with dignity. Usually this means using Inline\n\nFunction (115) or Inline Class (186). With inheritance, you can use Collapse Hierarchy\n\n(380).\n\nSPECULATIVE GENERALITY\n\nBrian Foote suggested this name for a smell to which we are very sensitive. You get it\n\nwhen people say, “Oh, I think we’ll need the ability to do this kind of thing someday”\n\nand thus add all sorts of hooks and special cases to handle things that aren’t required.\n\nThe result is often harder to understand and maintain. If all this machinery were being\n\nused, it would be worth it. But if it isn’t, it isn’t. The machinery just gets in the way, so\n\nget rid of it.\n\nIf you have abstract classes that aren’t doing much, use Collapse Hierarchy (380).\n\nUnnecessary delegation can be removed with Inline Function (115) and Inline Class\n\n(186). Functions with unused parameters should be subject to Change Function\n\nDeclaration (124) to remove those parameters. You should also apply Change Function\n\nwww.EBooksWorld.ir",
      "content_length": 2486,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 95,
      "content": "Declaration (124) to remove any unneeded parameters, which often get tossed in for\n\nfuture variations that never come to pass.\n\nSpeculative generality can be spotted when the only users of a function or class are test\n\ncases. If you find such an animal, delete the test case and apply Remove Dead Code\n\n(237).\n\nTEMPORARY FIELD\n\nSometimes you see a class in which a field is set only in certain circumstances. Such\n\ncode is difficult to understand, because you expect an object to need all of its fields.\n\nTrying to understand why a field is there when it doesn’t seem to be used can drive you\n\nnuts.\n\nUse Extract Class (182) to create a home for the poor orphan variables. Use Move\n\nFunction (198) to put all the code that concerns the fields into this new class. You may\n\nalso be able to eliminate conditional code by using Introduce Special Case (289) to\n\ncreate an alternative class for when the variables aren’t valid.\n\nMESSAGE CHAINS\n\nYou see message chains when a client asks one object for another object, which the\n\nclient then asks for yet another object, which the client then asks for yet another\n\nanother object, and so on. You may see these as a long line of getThis methods, or as\n\na sequence of temps. Navigating this way means the client is coupled to the structure of\n\nthe navigation. Any change to the intermediate relationships causes the client to have to\n\nchange.\n\nThe move to use here is Hide Delegate (189). You can do this at various points in the\n\nchain. In principle, you can do this to every object in the chain, but doing this often\n\nturns every intermediate object into a middle man. Often, a better alternative is to see\n\nwhat the resulting object is used for. See whether you can use Extract Function (106) to\n\ntake a piece of the code that uses it and then Move Function (198) to push it down the\n\nchain. If several clients of one of the objects in the chain want to navigate the rest of the\n\nway, add a method to do that.\n\nSome people consider any method chain to be a terrible thing. We are known for our\n\ncalm, reasoned moderation. Well, at least in this case we are.\n\nMIDDLE MAN\n\nwww.EBooksWorld.ir",
      "content_length": 2134,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 96,
      "content": "One of the prime features of objects is encapsulation—hiding internal details from the\n\nrest of the world. Encapsulation often comes with delegation. You ask a director\n\nwhether she is free for a meeting; she delegates the message to her diary and gives you\n\nan answer. All well and good. There is no need to know whether the director uses a\n\ndiary, an electronic gizmo, or a secretary to keep track of her appointments.\n\nc However, this can go too far. You look at a class’s interface and find half the methods\n\nare delegating to this other class. After a while, it is time to use Remove Middle Man\n\n(192) and talk to the object that really knows what’s going on. If only a few methods\n\naren’t doing much, use Inline Function (115) to inline them into the caller. If there is\n\nadditional behavior, you can use Replace Superclass with Delegate (399) or Replace\n\nSubclass with Delegate (381) to fold the middle man into the real object. That allows\n\nyou to extend behavior without chasing all that delegation.\n\nINSIDER TRADING\n\nSoftware people like strong walls between their modules and complain bitterly about\n\nhow trading data around too much increases coupling. To make things work, some\n\ntrade has to occur, but we need to reduce it to a minimum and keep it all above board.\n\nModules that whisper to each other by the coffee machine need to be separated by using\n\nMove Function (198) and Move Field (207) to reduce the need to chat. If modules have\n\ncommon interests, try to create a third module to keep that commonality in a well­\n\nregulated vehicle, or use Hide Delegate (189) to make another module act as an\n\nintermediary.\n\nInheritance can often lead to collusion. Subclasses are always going to know more\n\nabout their parents than their parents would like them to know. If it’s time to leave\n\nhome, apply Replace Subclass with Delegate (381) or Replace Superclass with\n\nDelegate (399).\n\nLARGE CLASS\n\nWhen a class is trying to do too much, it often shows up as too many fields. When a\n\nclass has too many fields, duplicated code cannot be far behind.\n\nYou can Extract Class (182) to bundle a number of the variables. Choose variables to go\n\ntogether in the component that makes sense for each. For example, “depositAmount”\n\nand “depositCurrency” are likely to belong together in a component. More generally,\n\ncommon prefixes or suffixes for some subset of the variables in a class suggest the\n\nopportunity for a component. If the component makes sense with inheritance, you’ll\n\nwww.EBooksWorld.ir",
      "content_length": 2505,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 97,
      "content": "find Extract Superclass (375) or Replace Type Code with Subclasses (362) (which\n\nessentially is extracting a subclass) are often easier.\n\nSometimes a class does not use all of its fields all of the time. If so, you may be able to\n\ndo these extractions many times.\n\nAs with a class with too many instance variables, a class with too much code is a prime\n\nbreeding ground for duplicated code, chaos, and death. The simplest solution (have we\n\nmentioned that we like simple solutions?) is to eliminate redundancy in the class itself.\n\nIf you have five hundred­line methods with lots of code in common, you may be able to\n\nturn them into five ten­line methods with another ten two­line methods extracted from\n\nthe original.\n\nThe clients of such a class are often the best clue for splitting up the class. Look at\n\nwhether clients use a subset of the features of the class. Each subset is a possible\n\nseparate class. Once you’ve identified a useful subset, use Extract Class (182), Extract\n\nSuperclass (375), or Replace Type Code with Subclasses (362) to break it out.\n\nALTERNATIVE CLASSES WITH DIFFERENT INTERFACES\n\nOne of the great benefits of using classes is the support for substitution, allowing one\n\nclass to swap in for another in times of need. But this only works if their interfaces are\n\nthe same. Use Change Function Declaration (124) to make functions match up. Often,\n\nthis doesn’t go far enough; keep using Move Function (198) to move behavior into\n\nclasses until the protocols match. If this leads to duplication, you may be able to use\n\nExtract Superclass (375) to atone.\n\nDATA CLASS\n\nThese are classes that have fields, getting and setting methods for the fields, and\n\nnothing else. Such classes are dumb data holders and are often being manipulated in\n\nfar too much detail by other classes. In some stages, these classes may have public\n\nfields. If so, you should immediately apply Encapsulate Record (162) before anyone\n\nnotices. Use Remove Setting Method (331) on any field that should not be changed.\n\nLook for where these getting and setting methods are used by other classes. Try to use\n\nMove Function (198) to move behavior into the data class. If you can’t move a whole\n\nfunction, use Extract Function (106) to create a function that can be moved.\n\nData classes are often a sign of behavior in the wrong place, which means you can make\n\nbig progress by moving it from the client into the data class itself. But there are\n\nwww.EBooksWorld.ir",
      "content_length": 2461,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 98,
      "content": "exceptions, and one of the best exceptions is a record that’s being used as a result\n\nrecord from a distinct function invocation. A good example of this is the intermediate\n\ndata structure after you’ve applied Split Phase (154). A key characteristic of such a\n\nresult record is that it’s immutable (at least in practice). Immutable fields don’t need to\n\nbe encapsulated and information derived from immutable data can be represented as\n\nfields rather than getting methods.\n\nREFUSED BEQUEST\n\nSubclasses get to inherit the methods and data of their parents. But what if they don’t\n\nwant or need what they are given? They are given all these great gifts and pick just a few\n\nto play with.\n\nThe traditional story is that this means the hierarchy is wrong. You need to create a new\n\nsibling class and use Push Down Method (359) and Push Down Field (361) to push all\n\nthe unused code to the sibling. That way the parent holds only what is common. Often,\n\nyou’ll hear advice that all superclasses should be abstract.\n\nYou’ll guess from our snide use of “traditional” that we aren’t going to advise this—at\n\nleast not all the time. We do subclassing to reuse a bit of behavior all the time, and we\n\nfind it a perfectly good way of doing business. There is a smell—we can’t deny it—but\n\nusually it isn’t a strong smell. So, we say that if the refused bequest is causing confusion\n\nand problems, follow the traditional advice. However, don’t feel you have to do it all the\n\ntime. Nine times out of ten this smell is too faint to be worth cleaning.\n\nThe smell of refused bequest is much stronger if the subclass is reusing behavior but\n\ndoes not want to support the interface of the superclass. We don’t mind refusing\n\nimplementations—but refusing interface gets us on our high horses. In this case,\n\nhowever, don’t fiddle with the hierarchy; you want to gut it by applying Replace\n\nSubclass with Delegate (381) or Replace Superclass with Delegate (399).\n\nCOMMENTS\n\nDon’t worry, we aren’t saying that people shouldn’t write comments. In our olfac­tory\n\nanalogy, comments aren’t a bad smell; indeed they are a sweet smell. The reason we\n\nmention comments here is that comments are often used as a deodorant. It’s surprising\n\nhow often you look at thickly commented code and notice that the comments are there\n\nbecause the code is bad.\n\nComments lead us to bad code that has all the rotten whiffs we’ve discussed in the rest\n\nof this chapter. Our first action is to remove the bad smells by refactoring. When we’re\n\nwww.EBooksWorld.ir",
      "content_length": 2521,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 99,
      "content": "finished, we often find that the comments are superfluous.\n\nIf you need a comment to explain what a block of code does, try Extract Function (106).\n\nIf the method is already extracted but you still need a comment to explain what it does,\n\nuse Change Function Declaration (124) to rename it. If you need to state some rules\n\nabout the required state of the system, use Introduce Assertion (302).\n\nWhen you feel the need to write a comment, first try to refactor the code so\n\nthat any comment becomes superfluous.\n\nA good time to use a comment is when you don’t know what to do. In addition to\n\ndescribing what is going on, comments can indicate areas in which you aren’t sure. A\n\ncomment can also explain why you did something. This kind of information helps\n\nfuture modifiers, especially forgetful ones.\n\nwww.EBooksWorld.ir",
      "content_length": 823,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 100,
      "content": "Chapter 4 Building Tests\n\nHistory\n\nTopics\n\nRefactoring is a valuable tool, but it can’t come alone. To do refactoring properly, I need\n\na solid suite of tests to spot my inevitable mistakes. Even with automated refactoring\n\nTutorials\n\ntools, many of my refactorings will still need checking via a test suite.\n\nOffers & Deals\n\nI don’t find this to be a disadvantage. Even without refactoring, writing good tests\n\nincreases my effectiveness as a programmer. This was a surprise for me and is\n\nHighlights\n\ncounterintuitive for most programmers—so it’s worth explaining why.\n\nSettings\n\nTHE VALUE OF SELF-TESTING CODE\n\nSupport\n\nIf you look at how most programmers spend their time, you’ll find that writing code is\n\nSign Out\n\nactually quite a small fraction. Some time is spent figuring out what ought to be going\n\non, some time is spent designing, but most time is spent debugging. I’m sure every\n\nreader can remember long hours of debugging—often, well into the night. Every\n\nprogrammer can tell a story of a bug that took a whole day (or more) to find. Fixing the\n\nbug is usually pretty quick, but finding it is a nightmare. And then, when you do fix a\n\nbug, there’s always a chance that another one will appear and that you might not even\n\nnotice it till much later. And you’ll spend ages finding that bug.\n\nThe event that started me on the road to self­testing code was a talk at OOPSLA in\n\n1992. Someone (I think it was “Bedarra” Dave Thomas) said offhandedly, “Classes\n\nshould contain their own tests.” So I decided to incorporate tests into the code base\n\ntogether with the production code. As I was also doing iterative development, I tried\n\nadding tests as I completed each iteration. The project on which I was working at that\n\ntime was quite small, so we put out iterations every week or so. Running the tests\n\nbecame fairly straightforward—but although it was easy, it was still pretty boring. This\n\nwas because every test produced output to the console that I had to check. Now I’m a\n\npretty lazy person and am prepared to work quite hard in order to avoid work. I\n\nrealized that, instead of looking at the screen to see if it printed out some information\n\nfrom the model, I could get the computer to make that test. All I had to do was put the\n\nwww.EBooksWorld.ir",
      "content_length": 2273,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 101,
      "content": "output I expected in the test code and do a comparison. Now I could run the tests and\n\nthey would just print “OK” to the screen if all was well. The software was now self­\n\ntesting.\n\nMake sure all tests are fully automatic and that they check their own results.\n\nNow it was easy to run tests—as easy as compiling. So I started to run tests every time I\n\ncompiled. Soon, I began to notice my productivity had shot upward. I realized that I\n\nwasn’t spending so much time debugging. If I added a bug that was caught by a\n\nprevious test, it would show up as soon as I ran that test. The test had worked before, so\n\nI would know that the bug was in the work I had done since I last tested. And I ran the\n\ntests frequently—which means only a few minutes had elapsed. I thus knew that the\n\nsource of the bug was the code I had just written. As it was a small amount of code that\n\nwas still fresh in my mind, the bug was easy to find. Bugs that would have otherwise\n\ntaken an hour or more to find now took a couple of minutes at most. Not only was my\n\nsoftware self­testing, but by running the tests frequently I had a powerful bug detector.\n\nAs I noticed this, I became more aggressive about doing the tests. Instead of waiting for\n\nthe end of an increment, I would add the tests immediately after writing a bit of\n\nfunction. Every day I would add a couple of new features and the tests to test them. I\n\nhardly ever spent more than a few minutes hunting for a regression bug.\n\nA suite of tests is a powerful bug detector that decapitates the time it takes to\n\nfind bugs.\n\nTools for writing and organizing these tests have developed a great deal since my\n\nexperiments. While flying from Switzerland to Atlanta for OOPSLA 1997, Kent Beck\n\npaired with Erich Gamma to port his unit testing framework from Smalltalk to Java.\n\nThe resulting framework, called JUnit, has been enormously influential for program\n\ntesting, inspiring a huge variety of similar tools [mf­xunit] in lots of different languages.\n\nAdmittedly, it is not so easy to persuade others to follow this route. Writing the tests\n\nmeans a lot of extra code to write. Unless you have actually experienced how it speeds\n\nprogramming, self­testing does not seem to make sense. This is not helped by the fact\n\nthat many people have never learned to write tests or even to think about tests. When\n\ntests are manual, they are gut­wrenchingly boring. But when they are automatic, tests\n\ncan actually be quite fun to write.\n\nwww.EBooksWorld.ir",
      "content_length": 2487,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 102,
      "content": "In fact, one of the most useful times to write tests is before I start programming. When\n\nI need to add a feature, I begin by writing the test. This isn’t as backward as it sounds.\n\nBy writing the test, I’m asking myself what needs to be done to add the function.\n\nWriting the test also concentrates me on the interface rather than the implementation\n\n(always a good thing). It also means I have a clear point at which I’m done coding—\n\nwhen the test works.\n\nKent Beck baked this habit of writing the test first into a technique called Test­Driven\n\nDevelopment (TDD) [mf­tdd]. The Test­Driven Development approach to\n\nprogramming relies on short cycles of writing a (failing) test, writing the code to make\n\nthat test work, and refactoring to ensure the result is as clean as possible. This test­\n\ncode­refactor cycle should occur many times per hour, and can be a very productive and\n\ncalming way to write code. I’m not going to discuss it further here, but I do use and\n\nwarmly recommend it.\n\nThat’s enough of the polemic. Although I believe everyone would benefit by writing self­\n\ntesting code, it is not the point of this book. This book is about refactoring. Refactoring\n\nrequires tests. If you want to refactor, you have to write tests. This chapter gives you a\n\nstart in doing this for JavaScript. This is not a testing book, so I’m not going to go into\n\nmuch detail. I’ve found, however, that with testing a remarkably small amount of work\n\ncan have surprisingly big benefits.\n\nAs with everything else in this book, I describe the testing approach using examples.\n\nWhen I develop code, I write the tests as I go. But sometimes, I need to refactor some\n\ncode without tests—then I have to make the code self­testing before I begin.\n\nSAMPLE CODE TO TEST\n\nHere’s some code to look at and test. The code supports a simple application that allows\n\na user to examine and manipulate a production plan. The (crude) UI looks like this:\n\nwww.EBooksWorld.ir",
      "content_length": 1954,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 103,
      "content": "The production plan has a demand and price for each province. Each province has\n\nproducers, each of which can produce a certain number of units at a particular price.\n\nThe UI also shows how much revenue each producer would earn if they sell all their\n\nproduction. At the bottom, the screen shows the shortfall in production (the demand\n\nminus the total production) and the profit for this plan. The UI allows the user to\n\nmanipulate the demand, price, and the individual producer’s production and costs to\n\nsee the effect on the production shortfall and profits. Whenever a user changes any\n\nnumber in the display, all the others update immediately.\n\nI’m showing a user interface here, so you can sense how the software is used, but I’m\n\nonly going to concentrate on the business logic part of the software—that is, the classes\n\nthat calculate the profit and the shortfall, not the code that generates the HTML and\n\nhooks up the field changes to the underlying business logic. This chapter is just an\n\nintroduction to the world of self­testing code, so it makes sense for me to start with the\n\neasiest case—which is code that doesn’t involve user interface, persistence, or external\n\nservice interaction. Such separation, however, is a good idea in any case: Once this kind\n\nof business logic gets at all complicated, I will separate it from the UI mechanics so I\n\ncan more easily reason about it and test it.\n\nThis business logic code involves two classes: one that represents a single producer, and\n\nthe other that represents a whole province. The province’s constructor takes a\n\nJavaScript object—one we could imagine being supplied by a JSON document.\n\nHere’s the code that loads the province from the JSON data:\n\nclass Province…\n\nwww.EBooksWorld.ir",
      "content_length": 1753,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 104,
      "content": "Click here to view code image\n\nconstructor(doc) { this._name = doc.name; this._producers = []; this._totalProduction = 0; this._demand = doc.demand; this._price = doc.price; doc.producers.forEach(d => this.addProducer(new Producer(this, d))); } addProducer(arg) { this._producers.push(arg); this._totalProduction += arg.production; }\n\nThis function creates suitable JSON data. I can create a sample province for testing by\n\nconstructing a province object with the result of this function.\n\ntop level…\n\nClick here to view code image\n\nfunction sampleProvinceData() { return { name: \"Asia\", producers: [ {name: \"Byzantium\", cost: 10, production: 9}, {name: \"Attalia\", cost: 12, production: 10}, {name: \"Sinope\", cost: 10, production: 6}, ], demand: 30, price: 20 }; }\n\nThe province class has accessors for the various data values:\n\nclass Province…\n\nClick here to view code image\n\nget name() {return this._name;} get producers() {return this._producers.slice();} get totalProduction() {return this._totalProduction;} set totalProduction(arg) {this._totalProduction = arg;} get demand() {return this._demand;} set demand(arg) {this._demand = parseInt(arg);}\n\nwww.EBooksWorld.ir",
      "content_length": 1172,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 105,
      "content": "get price() {return this._price;} set price(arg) {this._price = parseInt(arg);}\n\nThe setters will be called with strings from the UI that contain the numbers, so I need\n\nto parse the numbers to use them reliably in calculations.\n\nThe producer class is mostly a simple data holder:\n\nclass Producer…\n\nClick here to view code image\n\nconstructor(aProvince, data) { this._province = aProvince; this._cost = data.cost; this._name = data.name; this._production = data.production || 0; } get name() {return this._name;} get cost() {return this._cost;} set cost(arg) {this._cost = parseInt(arg);}\n\nget production() {return this._production;} set production(amountStr) { const amount = parseInt(amountStr); const newProduction = Number.isNaN(amount) ? 0 : amount; this._province.totalProduction += newProduction ­ this._production; this._production = newProduction; }\n\nThe way that set production updates the derived data in the province is ugly, and\n\nwhenever I see that I want to refactor to remove it. But I have to write tests before that I\n\ncan refactor it.\n\nThe calculation for the shortfall is simple.\n\nclass Province…\n\nClick here to view code image\n\nget shortfall() { return this._demand ­ this.totalProduction; }\n\nThat for the profit is a bit more involved.\n\nwww.EBooksWorld.ir",
      "content_length": 1276,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 106,
      "content": "class Province…\n\nClick here to view code image\n\nget profit() { return this.demandValue ­ this.demandCost; } get demandCost() { let remainingDemand = this.demand; let result = 0; this.producers .sort((a,b) => a.cost ­ b.cost) .forEach(p => { const contribution = Math.min(remainingDemand, p.production); remainingDemand ­= contribution; result += contribution * p.cost; }); return result; } get demandValue() { return this.satisfiedDemand * this.price; } get satisfiedDemand() { return Math.min(this._demand, this.totalProduction); }\n\nA FIRST TEST\n\nTo test this code, I’ll need some sort of testing framework. There are many out there,\n\neven just for JavaScript. The one I’ll use is Mocha [mocha], which is reasonably\n\ncommon and well­regarded. I won’t go into a full explanation of how to use the\n\nframework, just show some example tests with it. You should be able to adapt, easily\n\nenough, a different framework to build similar tests.\n\nHere is a simple test for the shortfall calculation:\n\nClick here to view code image\n\ndescribe('province', function() { it('shortfall', function() { const asia = new Province(sampleProvinceData()); assert.equal(asia.shortfall, 5); }); });\n\nThe Mocha framework divides up the test code into blocks, each grouping together a\n\nwww.EBooksWorld.ir",
      "content_length": 1280,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 107,
      "content": "suite of tests. Each test appears in an it block. For this simple case, the test has two\n\nsteps. The first step sets up some fixture—data and objects that are needed for the test:\n\nin this case, a loaded province object. The second line verifies some characteristic of\n\nthat fixture—in this case, that the shortfall is the amount that should be expected given\n\nthe initial data.\n\nDifferent developers use the descriptive strings in the describe and it blocks\n\ndifferently. Some would write a sentence that explains what the test is testing, but\n\nothers prefer to leave them empty, arguing that the descriptive sentence is just\n\nduplicating the code in the same way a comment does. I like to put in just enough to\n\nidentify which test is which when I get failures.\n\nIf I run this test in a NodeJS console, the output looks like this:\n\n’’’’’’’’’’’’’’\n\n1 passing (61ms)\n\nNote the simplicity of the feedback—just a summary of how many tests are run and how\n\nmany have passed.\n\nAlways make sure a test will fail when it should.\n\nWhen I write a test against existing code like this, it’s nice to see that all is well—but I’m\n\nnaturally skeptical. Particularly, once I have a lot of tests running, I’m always nervous\n\nthat a test isn’t really exercising the code the way I think it is, and thus won’t catch a\n\nbug when I need it to. So I like to see every test fail at least once when I write it. My\n\nfavorite way of doing that is to temporarily inject a fault into the code, for example:\n\nclass Province…\n\nClick here to view code image\n\nget shortfall() { return this._demand ­ this.totalProduction * 2; }\n\nHere’s what the console now looks like:\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1690,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 108,
      "content": "!\n\n0 passing (72ms) 1 failing\n\n1) province shortfall: AssertionError: expected ­20 to equal 5 at Context.<anonymous> (src/tester.js:10:12)\n\nThe framework indicates which test failed and gives some information about the nature\n\nof the failure—in this case, what value was expected and what value actually turned up.\n\nI therefore notice at once that something failed—and I can immediately see which tests\n\nfailed, giving me a clue as to what went wrong (and, in this case, confirming the failure\n\nwas where I injected it).\n\nRun tests frequently. Run those exercising the code you’re working on at least\n\nevery few minutes; run all tests at least daily.\n\nIn a real system, I might have thousands of tests. A good test framework allows me to\n\nrun them easily and to quickly see if any have failed. This simple feedback is essential to\n\nself­testing code. When I work, I’ll be running tests very frequently—checking progress\n\nwith new code or checking for mistakes with refactoring.\n\nThe Mocha framework can use different libraries, which it calls assertion libraries, to\n\nverify the fixture for a test. Being JavaScript, there are a quadzillion of them out there,\n\nsome of which may still be current when you’re reading this. The one I’m using at the\n\nmoment is Chai [chai]. Chai allows me to write my validations either using an “assert”\n\nstyle:\n\nClick here to view code image\n\ndescribe('province', function() { it('shortfall', function() { const asia = new Province(sampleProvinceData()); assert.equal(asia.shortfall, 5); }); });\n\nor an “expect” style:\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1601,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 109,
      "content": "describe('province', function() { it('shortfall', function() { const asia = new Province(sampleProvinceData()); expect(asia.shortfall).equal(5); }); });\n\nI usually prefer the assert style, but at the moment I mostly use the expect style while\n\nworking in JavaScript.\n\nDifferent environments provide different ways to run tests. When I’m programming in\n\nJava, I use an IDE that gives me a graphical test runner. Its progress bar is green as\n\nlong as all the tests pass, and turns red should any of them fail. My colleagues often use\n\nthe phrases “green bar” and “red bar” to describe the state of tests. I might say, “Never\n\nrefactor on a red bar,” meaning you shouldn’t be refactoring if your test suite has a\n\nfailing test. Or, I might say, “Revert to green” to say you should undo recent changes\n\nand go back to the last state where you had all­passing test suite (usually by going back\n\nto a recent version­control checkpoint).\n\nGraphical test runners are nice, but not essential. I usually have my tests set to run\n\nfrom a single key in Emacs, and observe the text feedback in my compilation window.\n\nThe key point is that I can quickly see if my tests are all OK.\n\nADD ANOTHER TEST\n\nNow I’ll continue adding more tests. The style I follow is to look at all the things the\n\nclass should do and test each one of them for any conditions that might cause the class\n\nto fail. This is not the same as testing every public method, which is what some\n\nprogrammers advocate. Testing should be risk­driven; remember, I’m trying to find\n\nbugs, now or in the future. Therefore I don’t test accessors that just read and write a\n\nfield: They are so simple that I’m not likely to find a bug there.\n\nThis is important because trying to write too many tests usually leads to not writing\n\nenough. I get many benefits from testing even if I do only a little testing. My focus is to\n\ntest the areas that I’m most worried about going wrong. That way I get the most benefit\n\nfor my testing effort.\n\nIt is better to write and run incomplete tests than not to run complete tests.\n\nSo I’ll start by hitting the other main output for this code—the profit calculation. Again,\n\nwww.EBooksWorld.ir",
      "content_length": 2173,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 110,
      "content": "I’ll just do a basic test for profit on my initial fixture.\n\nClick here to view code image\n\ndescribe('province', function() { it('shortfall', function() { const asia = new Province(sampleProvinceData()); expect(asia.shortfall).equal(5); }); it('profit', function() { const asia = new Province(sampleProvinceData()); expect(asia.profit).equal(230); }); });\n\nThat shows the final result, but the way I got it was by first setting the expected value to\n\na placeholder, then replacing it with whatever the program produced (230). I could\n\nhave calculated it by hand myself, but since the code is supposed to be working\n\ncorrectly, I’ll just trust it for now. Once I have that new test working correctly, I break it\n\nby altering the profit calculation with a spurious * 2. I satisfy myself that the test fails\n\nas it should, then revert my injected fault. This pattern—write with a placeholder for the\n\nexpected value, replace the placeholder with the code’s actual value, inject a fault, revert\n\nthe fault—is a common one I use when adding tests to existing code.\n\nThere is some duplication between these tests—both of them set up the fixture with the\n\nsame first line. Just as I’m suspicious of duplicated code in regular code, I’m suspicious\n\nof it in test code, so will look to remove it by factoring to a common place. One option is\n\nto raise the constant to the outer scope.\n\nClick here to view code image\n\ndescribe('province', function() { const asia = new Province(sampleProvinceData()); // DON'T DO THIS it('shortfall', function() { expect(asia.shortfall).equal(5); }); it('profit', function() { expect(asia.profit).equal(230); }); });\n\nBut as the comment indicates, I never do this. It will work for the moment, but it\n\nintroduces a petri dish that’s primed for one of the nastiest bugs in testing—a shared\n\nfixture which causes tests to interact. The const keyword in JavaScript only means the\n\nwww.EBooksWorld.ir",
      "content_length": 1919,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 111,
      "content": "reference to asia is constant, not the content of that object. Should a future test\n\nchange that common object, I’ll end up with intermittent test failures due to tests\n\ninteracting through the shared fixture, yielding different results depending on what\n\norder the tests are run in. That’s a nondeterminism in the tests that can lead to long and\n\ndifficult debugging at best, and a collapse of confidence in the tests at worst. Instead, I\n\nprefer to do this:\n\nClick here to view code image\n\ndescribe('province', function() { let asia; beforeEach(function() { asia = new Province(sampleProvinceData()); }); it('shortfall', function() { expect(asia.shortfall).equal(5); }); it('profit', function() { expect(asia.profit).equal(230); }); });\n\nThe beforeEach clause is run before each test runs, clearing out asia and setting it to\n\na fresh value each time. This way I build a fresh fixture before each test is run, which\n\nkeeps the tests isolated and prevents the nondeterminism that causes so much trouble.\n\nWhen I give this advice, some people are concerned that building a fresh fixture every\n\ntime will slow down the tests. Most of the time, it won’t be noticeable. If it is a problem,\n\nI’d consider a shared fixture, but then I will need to be really careful that no test ever\n\nchanges it. I can also use a shared fixture if I’m sure it is truly immutable. But my reflex\n\nis to use a fresh fixture because the debugging cost of making a mistake with a shared\n\nfixture has bit me too often in the past.\n\nGiven I run the setup code in beforeEach with every test, why not leave the setup\n\ncode inside the individual it blocks? I like my tests to all operate on a common bit of\n\nfixture, so I can become familiar with that standard fixture and see the various\n\ncharacteristics to test on it. The presence of the beforeEach block signals to the\n\nreader that I’m using a standard fixture. You can then look at all the tests within the\n\nscope of that describe block and know they all take the same base data as a starting\n\npoint.\n\nMODIFYING THE FIXTURE\n\nwww.EBooksWorld.ir",
      "content_length": 2067,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 112,
      "content": "So far, the tests I’ve written show how I probe the properties of the fixture once I’ve\n\nloaded it. But in use, that fixture will be regularly updated by the users as they change\n\nvalues.\n\nMost of the updates are simple setters, and I don’t usually bother to test those as there’s\n\nlittle chance they will be the source of a bug. But there is some complicated behavior\n\naround Producer’s production setter, so I think that’s worth a test.\n\ndescribe(’province’…\n\nClick here to view code image\n\nit('change production', function() { asia.producers[0].production = 20; expect(asia.shortfall).equal(­6); expect(asia.profit).equal(292); });\n\nThis is a common pattern. I take the initial standard fixture that’s set up by the\n\nbeforeEach block, I exercise that fixture for the test, then I verify the fixture has\n\ndone what I think it should have done. If you read much about testing, you’ll hear these\n\nphases described variously as setup­exercise­verify, given­when­then, or arrange­act­\n\nassert. Sometimes you’ll see all the steps present within the test itself, in other cases the\n\ncommon early phases can be pushed out into standard setup routines such as\n\nbeforeEach.\n\n(There is an implicit fourth phase that’s usually not mentioned: teardown. Teardown\n\nremoves the fixture between tests so that different tests don’t interact with each other.\n\nBy doing all my setup in beforeEach, I allow the test framework to implicitly tear\n\ndown my fixture between tests, so I can take the teardown phase for granted. Most\n\nwriters on tests gloss over teardown—reasonably so, since most of the time we ignore it.\n\nBut occasionally, it can be important to have an explicit teardown operation,\n\nparticularly if we have a fixture that we have to share between tests because it’s slow to\n\ncreate.)\n\nIn this test, I’m verifying two different characteristics in a single it clause. As a general\n\nrule, it’s wise to have only a single verify statement in each it clause. This is because\n\nthe test will fail on the first verification failure—which can often hide useful information\n\nwhen you’re figuring out why a test is broken. In this case, I feel the two are closely\n\nenough connected that I’m happy to have them in the same test. Should I wish to\n\nseparate them into separate it clauses, I can do that later.\n\nwww.EBooksWorld.ir\n\nPROBING THE BOUNDARIES",
      "content_length": 2336,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 113,
      "content": "PROBING THE BOUNDARIES\n\nSo far my tests have focused on regular usage, often referred to as “happy path”\n\nconditions where everything is going OK and things are used as expected. But it’s also\n\ngood to throw tests at the boundaries of these conditions—to see what happens when\n\nthings might go wrong.\n\nWhenever I have a collection of something, such as producers in this example, I like to\n\nsee what happens when it’s empty.\n\nClick here to view code image\n\ndescribe('no producers', function() { let noProducers; beforeEach(function() { const data = { name: \"No proudcers\", producers: [], demand: 30, price: 20 }; noProducers = new Province(data); }); it('shortfall', function() { expect(noProducers.shortfall).equal(30); }); it('profit', function() { expect(noProducers.profit).equal(0); });\n\nWith numbers, zeros are good things to probe:\n\ndescribe(’province’…\n\nClick here to view code image\n\nit('zero demand', function() { asia.demand = 0; expect(asia.shortfall).equal(­25); expect(asia.profit).equal(0); });\n\nas are negatives:\n\ndescribe(’province’…\n\nwww.EBooksWorld.ir",
      "content_length": 1070,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 114,
      "content": "Click here to view code image\n\nit('negative demand', function() { asia.demand = ­1; expect(asia.shortfall).equal(­26); expect(asia.profit).equal(­10); });\n\nAt this point, I may start to wonder if a negative demand resulting in a negative profit\n\nreally makes any sense for the domain. Shouldn’t the minimum demand be zero? In\n\nwhich case, perhaps, the setter should react differently to a negative argument—raising\n\nan error or setting the value to zero anyway. These are good questions to ask, and\n\nwriting tests like this helps me think about how the code ought to react to boundary\n\ncases.\n\nThink of the boundary conditions under which things might go wrong and\n\nconcentrate your tests there.\n\nThe setters take a string from the fields in the UI, which are constrained to only accept\n\nnumbers—but they can still be blank, so I should have tests that ensure the code\n\nresponds to the blanks the way I want it to.\n\ndescribe(’province’…\n\nClick here to view code image\n\nit('empty string demand', function() { asia.demand = \"\"; expect(asia.shortfall).NaN; expect(asia.profit).NaN; });\n\nNotice how I’m playing the part of an enemy to my code. I’m actively thinking about\n\nhow I can break it. I find that state of mind to be both productive and fun. It indulges\n\nthe mean­spirited part of my psyche.\n\nThis one is interesting:\n\nClick here to view code image\n\ndescribe('string for producers', function() {\n\nwww.EBooksWorld.ir",
      "content_length": 1419,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 115,
      "content": "it('', function() { const data = { name: \"String producers\", producers: \"\", demand: 30, price: 20 }; const prov = new Province(data); expect(prov.shortfall).equal(0); });\n\nThis doesn’t produce a simple failure reporting that the shortfall isn’t 0. Here’s the\n\nconsole output:\n\nClick here to view code image\n\n’’’’’’’’’!\n\n9 passing (74ms) 1 failing\n\n1) string for producers : TypeError: doc.producers.forEach is not a function at new Province (src/main.js:22:19) at Context.<anonymous> (src/tester.js:86:18)\n\nMocha treats this as a failure—but many testing frameworks distinguish between this\n\nsituation, which they call an error, and a regular failure. A failure indicates a verify step\n\nwhere the actual value is outside the bounds expected by the verify statement. But this\n\nerror is a different animal—it’s an exception raised during an earlier phase (in this\n\ncase, the setup). This looks like an exception that the authors of the code hadn’t\n\nanticipated, so we get an error sadly familiar to JavaScript programmers (“… is not a\n\nfunction”).\n\nHow should the code respond to such a case? One approach is to add some handling\n\nthat would give a better error response—either raising a more meaningful error\n\nmessage, or just setting producers to an empty array (with perhaps a log message).\n\nBut there may also be valid reasons to leave it as it is. Perhaps the input object is\n\nproduced by a trusted source—such as another part of the same code base. Putting in\n\nlots of validation checks between modules in the same code base can result in duplicate\n\nchecks that cause more trouble than they are worth, especially if they duplicate\n\nvalidation done elsewhere. But if that input object is coming in from an external source,\n\nsuch as a JSON­encoded request, then validation checks are needed, and should be\n\ntested. In either case, writing tests like this raises these kinds of questions.\n\nwww.EBooksWorld.ir",
      "content_length": 1909,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 116,
      "content": "If I’m writing tests like this before refactoring, I would probably discard this test.\n\nRefactoring should preserve observable behavior; an error like this is outside the\n\nbounds of observable, so I need not be concerned if my refactoring changes the code’s\n\nresponse to this condition.\n\nIf this error could lead to bad data running around the program, causing a failure that\n\nwill be hard to debug, I might use Introduce Assertion (302) to fail fast. I don’t add\n\ntests to catch such assertion failures, as they are themselves a form of test.\n\nDon’t let the fear that testing can’t catch all bugs stop you from writing tests\n\nthat catch most bugs.\n\nWhen do you stop? I’m sure you have heard many times that you cannot prove that a\n\nprogram has no bugs by testing. That’s true, but it does not affect the ability of testing\n\nto speed up programming. I’ve seen various proposed rules to ensure you have tested\n\nevery combination of everything. It’s worth taking a look at these—but don’t let them\n\nget to you. There is a law of diminishing returns in testing, and there is the danger that\n\nby trying to write too many tests you become discouraged and end up not writing any.\n\nYou should concentrate on where the risk is. Look at the code and see where it becomes\n\ncomplex. Look at a function and consider the likely areas of error. Your tests will not\n\nfind every bug, but as you refactor, you will understand the program better and thus\n\nfind more bugs. Although I always start refactoring with a test suite, I invariably add to\n\nit as I go along.\n\nMUCH MORE THAN THIS\n\nThat’s as far as I’m going to go with this chapter—after all, this is a book on refactoring,\n\nnot on testing. But testing is an important topic, both because it’s a necessary\n\nfoundation for refactoring and because it’s a valuable tool in its own right. While I’ve\n\nbeen happy to see the growth of refactoring as a programming practice since I wrote\n\nthis book, I’ve been even happier to see the change in attitudes to testing. Previously\n\nseen as the responsibility of a separate (and inferior) group, testing is now increasingly\n\na first­class concern of any decent software developer. Architectures often are, rightly,\n\njudged on their testability.\n\nThe kinds of tests I’ve shown here are unit tests, designed to operate on a small area of\n\nthe code and run fast. They are the backbone of self­testing code; most tests in such a\n\nsystem are unit tests. There are other kinds of tests too, focusing on integration\n\nbetween components, exercising multiple levels of the software together, looking for\n\nwww.EBooksWorld.ir",
      "content_length": 2591,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 117,
      "content": "performance issues, etc. (And even more varied than the types of tests are the\n\narguments people get into about how to classify tests.)\n\nLike most aspects of programming, testing is an iterative activity. Unless you are either\n\nvery skilled or very lucky, you won’t get your tests right the first time. I find I’m\n\nconstantly working on the test suite—just as much as I work on the main code.\n\nNaturally, this means adding new tests as I add new features, but it also involves\n\nlooking at the existing tests. Are they clear enough? Do I need to refactor them so I can\n\nmore easily understand what they are doing? Have I got the right tests? An important\n\nhabit to get into is to respond to a bug by first writing a test that clearly reveals the bug.\n\nOnly after I have the test do I fix the bug. By having the test, I know the bug will stay\n\ndead. I also think about that bug and its test: Does it give me clues to other gaps in the\n\ntest suite?\n\nWhen you get a bug report, start by writing a unit test that exposes the bug.\n\nA common question is, “How much testing is enough?” There’s no good measurement\n\nfor this. Some people advocate using test coverage [mf­tc] as a measure, but test\n\ncoverage analysis is only good for identifying untested areas of the code, not for\n\nassessing the quality of a test suite.\n\nThe best measure for a good enough test suite is subjective: How confident are you that\n\nif someone introduces a defect into the code, some test will fail? This isn’t something\n\nthat can be objectively analyzed, and it doesn’t account for false confidence, but the aim\n\nof self­testing code is to get that confidence. If I can refactor my code and be pretty sure\n\nthat I’ve not introduced a bug because my tests come back green—then I can be happy\n\nthat I have good enough tests.\n\nIt is possible to write too many tests. One sign of that is when I spend more time\n\nchanging the tests than the code under test—and I feel the tests are slowing me down.\n\nBut while over­testing does happen, it’s vanishingly rare compared to under­testing.\n\nwww.EBooksWorld.ir",
      "content_length": 2070,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 118,
      "content": "Chapter 5 Introducing the Catalog\n\nHistory\n\nTopics\n\nThe rest of this book is a catalog of refactorings. This catalog started from my personal\n\nnotes that I made to remind myself how to do refactorings in a safe and efficient way.\n\nTutorials\n\nSince then, I’ve refined the catalog, and there’s more of it that comes from deliberate\n\nexploration of some refactoring moves. It’s still something I use when I do a refactoring\n\nOffers & Deals\n\nI haven’t done in a while.\n\nHighlights\n\nFORMAT OF THE REFACTORINGS\n\nSettings\n\nAs I describe the refactorings in the catalog, I use a standard format. Each refactoring\n\nhas five parts, as follows:\n\nSupport\n\nSign Out\n\nI begin with a name. The name is important to building a vocabulary of\n\nrefactorings. This is the name I use elsewhere in the book. Refactorings often go by\n\ndifferent names now, so I also list any aliases that seem to be common.\n\nI follow the name with a short sketch of the refactoring. This helps you find a\n\nrefactoring more quickly.\n\nThe motivation describes why the refactoring should be done and describes\n\ncircumstances in which it shouldn’t be done.\n\nThe mechanics are a concise, step­by­step description of how to carry out the\n\nrefactoring.\n\nThe examples show a very simple use of the refactoring to illustrate how it works.\n\nThe sketch shows a code example of the transformation of the refactoring. It’s not\n\nmeant to explain what the refactoring is, let alone how to do it, but it should remind you\n\ni\n\nwhat the refactoring is if you’ve come across it before. If not, you’ll probably need to\n\nwork through the example to get a better idea. I also include a small graphic; again, I\n\ndon’t intend it to be explanatory—it’s more of a graphic memory­jogger.\n\nwww.EBooksWorld.ir",
      "content_length": 1740,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 119,
      "content": "The mechanics come from my own notes to remember how to do the refactoring when I\n\nhaven’t done it for a while. As such, they are somewhat terse, usually without\n\nexplanations of why the steps are done that way. I give a more expansive explanation in\n\nthe example. This way, the mechanics are short notes you can refer to easily when you\n\nknow the refactoring but need to look up the steps (at least this is how I use them).\n\nYou’ll probably need to read the examples when you first do the refactoring.\n\nI’ve written the mechanics in such a way that each step of each refactoring is as small as\n\npossible. I emphasize the safe way of doing the refactoring—which is to take very small\n\nsteps and test after every one. At work, I usually take larger steps than some of the baby\n\nsteps described, but if I run into a bug, I back out the last step and take the smaller\n\nsteps. The steps include a number of references to special cases. The steps thus also\n\nfunction as a checklist; I often forget these things myself.\n\nAlthough I (with few exceptions) only list one set of mechanics, they aren’t the only way\n\nto carry out the refactoring. I selected the mechanics in the book because they work\n\npretty well most of the time. It’s likely you’ll vary them as you get more practice in\n\nrefactoring, and that’s fine. Just remember that the key is to take small steps—and the\n\ntrickier the situation, the smaller the steps.\n\nThe examples are of the laughably simple textbook kind. My aim with the examples is\n\nto help explain the basic refactoring with minimal distractions, so I hope you’ll forgive\n\nthe simplicity. (They are certainly not examples of good business modeling.) I’m sure\n\nyou’ll be able to apply them to your rather more complex situations. Some very simple\n\nrefactorings don’t have examples because I didn’t think an example would add much.\n\nIn particular, remember that the examples are included only to illustrate the one\n\nrefactoring under discussion. In most cases, there are still problems with the code at\n\nthe end—but fixing these problems requires other refactorings. In a few cases in which\n\nrefactorings often go together, I carry examples from one re­factoring to another. In\n\nmost cases, I leave the code as it is after the single refactoring. I do this to make each\n\nrefactoring self­contained, because the primary role of the catalog is to be a reference.\n\nI use color to highlight changed code where it may be difficult to spot among code that\n\nhas not been changed. I do not use highlighting for all changed code, because too much\n\ndefeats the purpose.\n\nTHE CHOICE OF REFACTORINGS\n\nThis is by no means a complete catalog of refactorings. It is, I hope, a collection of those\n\nmost useful to have them written down. By “most useful” I mean those that are both\n\nwww.EBooksWorld.ir",
      "content_length": 2803,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 120,
      "content": "commonly used and worthwhile to name and describe. I find something worthwhile to\n\ndescribe for a combination of reasons: Some have interesting mechanics which help\n\ngeneral refactoring skills, some have a strong effect on improving the design of code.\n\nSome refactorings are missing because they are so small and straightforward that I\n\ndon’t feel they are worth writing up. An example in the first edition was Slide\n\nStatements (223)—which I use frequently but didn’t recognize as something I should\n\ninclude in the catalog (obviously, I changed my mind for this edition). These may well\n\nget added to the book over time, depending on how much energy I devote to new\n\nrefactorings in the future.\n\nAnother category is refactorings that logically exist, but either aren’t used much by me\n\nor show a simple similarity to other refactorings. Every refactoring in this book has a\n\nlogical inverse refactoring, but I didn’t write all of them up because I don’t find many\n\ninverses interesting. Encapsulate Variable (132) is a common and powerful refactoring\n\nbut its inverse is something I hardly ever do (and it is easy to perform anyway) so I\n\ndidn’t think we need a catalog entry for it.\n\nwww.EBooksWorld.ir",
      "content_length": 1206,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 121,
      "content": "Chapter 6 A First Set of Refactorings\n\nHistory\n\nTopics\n\nI’m starting the catalog with a set of refactorings that I consider the most useful to learn\n\nfirst. Tutorials\n\nProbably the most common refactoring I do is extracting code into a function (Extract\n\nOffers & Deals\n\nFunction (106)) or a variable (Extract Variable (119)). Since refactoring is all about\n\nchange, it’s no surprise that I also frequently use the inverses of those two (Inline\n\nHighlights\n\nFunction (115) and Inline Variable (123)).\n\nSettings\n\nExtraction is all about giving names, and I often need to change the names as I learn.\n\nChange Function Declaration (124) changes names of functions; I also use that\n\nSupport\n\nrefactoring to add or remove a function’s arguments. For variables, I use Rename\n\nSign Out\n\nVariable (137), which relies on Encapsulate Variable (132). When changing function\n\narguments, I often find it useful to combine a common clump of arguments into a\n\nsingle object with Introduce Parameter Object (140).\n\nForming and naming functions are essential low­level refactorings—but, once created,\n\nit’s necessary to group functions into higher­level modules. I use Combine Functions\n\ninto Class (144) to group functions, together with the data they operate on, into a class.\n\nAnother path I take is to combine them into a transform (Combine Functions into\n\nTransform (149)), which is particularly handy with read­only data. At a step further in\n\nscale, I can often form these modules into distinct processing phases using Split Phase\n\n(154).\n\nEXTRACT FUNCTION\n\nformerly: Extract Method\n\ninverse\n\nof:\n\nInline\n\nFunction\n\n(115)\n\nwww.EBooksWorld.ir",
      "content_length": 1631,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 122,
      "content": "Motivation\n\nExtract Function is one of the most common refactorings I do. (Here, I use the term\n\n“function” but the same is true for a method in an object­oriented language, or any kind\n\nof procedure or subroutine.) I look at a fragment of code, understand what it is doing,\n\nthen extract it into its own function named after its purpose.\n\nDuring my career, I’ve heard many arguments about when to enclose code in its own\n\nfunction. Some of these guidelines were based on length: Functions should be no larger\n\nthan fit on a screen. Some were based on reuse: Any code used more than once should\n\nbe put in its own function, but code only used once should be left inline. The argument\n\nthat makes most sense to me, however, is the separation between intention and\n\nimplementation. If you have to spend effort looking at a fragment of code and figuring\n\nout what it’s doing, then you should extract it into a function and name the function\n\nafter the “what.” Then, when you read it again, the purpose of the function leaps right\n\nout at you, and most of the time you won’t need to care about how the function fulfills\n\nits purpose (which is the body of the function). www.EBooksWorld.ir",
      "content_length": 1184,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 123,
      "content": "Once I accepted this principle, I developed a habit of writing very small functions—\n\ntypically, only a few lines long. To me, any function with more than half­a­dozen lines\n\nof code starts to smell, and it’s not unusual for me to have functions that are a single\n\nline of code. The fact that size isn’t important was brought home to me by an example\n\nthat Kent Beck showed me from the original Smalltalk system. Smalltalk in those days\n\nran on black­and­white systems. If you wanted to highlight some text or graphics, you\n\nwould reverse the video. Smalltalk’s graphics class had a method for this called\n\nhighlight, whose implementation was just a call to the method reverse. The name\n\nof the method was longer than its implementation—but that didn’t matter because\n\nthere was a big distance between the intention of the code and its implementation.\n\nSome people are concerned about short functions because they worry about the\n\nperformance cost of a function call. When I was young, that was occasionally a factor,\n\nbut that’s very rare now. Optimizing compilers often work better with shorter functions\n\nwhich can be cached more easily. As always, follow the general guidelines on\n\nperformance optimization.\n\nSmall functions like this only work if the names are good, so you need to pay good\n\nattention to naming. This takes practice—but once you get good at it, this approach can\n\nmake code remarkably self­documenting.\n\nOften, I see fragments of code in a larger function that start with a comment to say what\n\nthey do. The comment is often a good hint for the name of the function when I extract\n\nthat fragment.\n\nMechanics\n\nCreate a new function, and name it after the intent of the function (name it by what\n\nit does, not by how it does it).\n\nIf the code I want to extract is very simple, such as a single function call, I still\n\nextract it if the name of the new function will reveal the intent of the code in a better\n\nway. If I can’t come up with a more meaningful name, that’s a sign that I shouldn’t\n\nextract the code. However, I don’t have to come up with the best name right away;\n\nsometimes a good name only appears as I work with the extraction. It’s OK to\n\nextract a function, try to work with it, realize it isn’t helping, and then inline it back\n\nagain. As long as I’ve learned something, my time wasn’t wasted.\n\nIf the language supports nested functions, nest the extracted function inside the\n\nsource function. That will reduce the amount of out­of­scope variables to deal with\n\nafter the next couple of steps. I can always use Move Function (198) later. www.EBooksWorld.ir",
      "content_length": 2595,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 124,
      "content": "Copy the extracted code from the source function into the new target function.\n\nScan the extracted code for references to any variables that are local in scope to the\n\nsource function and will not be in scope for the extracted function. Pass them as\n\nparameters.\n\nIf I extract into a nested function of the source function, I don’t run into these\n\nproblems.\n\nUsually, these are local variables and parameters to the function. The most general\n\napproach is to pass all such parameters in as arguments. There are usually no\n\ndifficulties for variables that are used but not assigned to.\n\nIf a variable is only used inside the extracted code but is declared outside, move the\n\ndeclaration into the extracted code.\n\nAny variables that are assigned to need more care if they are passed by value. If\n\nthere’s only one of them, I try to treat the extracted code as a query and assign the\n\nresult to the variable concerned.\n\nSometimes, I find that too many local variables are being assigned by the extracted\n\ncode. It’s better to abandon the extraction at this point. When this happens, I\n\nconsider other refactorings such as Split Variable (240) or Replace Temp with\n\nQuery (178) to simplify variable usage and revisit the extraction later.\n\nCompile after all variables are dealt with.\n\nOnce all the variables are dealt with, it can be useful to compile if the language\n\nenvironment does compile­time checks. Often, this will help find any variables that\n\nhaven’t been dealt with properly.\n\nReplace the extracted code in the source function with a call to the target function.\n\nTest.\n\nLook for other code that’s the same or similar to the code just extracted, and\n\nconsider using Replace Inline Code with Function Call (222) to call the new\n\nfunction.\n\nSome refactoring tools support this directly. Otherwise, it can be worth doing some\n\nquick searches to see if duplicate code exists elsewhere.\n\nwww.EBooksWorld.ir\n\nExample: No Variables Out of Scope",
      "content_length": 1945,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 125,
      "content": "Example: No Variables Out of Scope\n\nIn the simplest case, Extract Function is trivially easy.\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nconsole.log(\"***********************\"); console.log(\"**** Customer Owes ****\"); console.log(\"***********************\");\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\n// record due date const today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);\n\n//print details console.log(`name: ${invoice.customer}`); console.log(`amount: ${outstanding}`); console.log(`due: ${invoice.dueDate.toLocaleDateString()}`); }\n\nYou may be wondering what the Clock.today is about. It is a Clock Wrapper [mf­\n\ncw]—an object that wraps calls to the system clock. I avoid putting direct calls to\n\nthings like Date.now() in my code, because it leads to nondeterministic tests and\n\nmakes it difficult to reproduce error conditions when diagnosing failures.\n\nIt’s easy to extract the code that prints the banner. I just cut, paste, and put in a call:\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nprintBanner();\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\nwww.EBooksWorld.ir",
      "content_length": 1306,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 126,
      "content": "// record due date const today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);\n\n//print details console.log(`name: ${invoice.customer}`); console.log(`amount: ${outstanding}`); console.log(`due: ${invoice.dueDate.toLocaleDateString()}`); } function printBanner() { console.log(\"***********************\"); console.log(\"**** Customer Owes ****\"); console.log(\"***********************\"); }\n\nSimilarly, I can take the printing of details and extract that too:\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nprintBanner();\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\n// record due date const today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);\n\nprintDetails();\n\nfunction printDetails() { console.log(`name: ${invoice.customer}`); console.log(`amount: ${outstanding}`); console.log(`due: ${invoice.dueDate.toLocaleDateString()}`); }\n\nThis makes Extract Function seem like a trivially easy refactoring. But in many\n\nsituations, it turns out to be rather more tricky.\n\nIn the case above, I defined printDetails so it was nested inside printOwing. That\n\nway it was able to access all the variables defined in printOwing. But that’s not an\n\noption to me if I’m programming in a language that doesn’t allow nested functions. www.EBooksWorld.ir",
      "content_length": 1428,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 127,
      "content": "Then I’m faced, essentially, with the problem of extracting the function to the top level,\n\nwhich means I have to pay attention to any variables that exist only in the scope of the\n\nsource function. These are the arguments to the original function and the temporary\n\nvariables defined in the function.\n\nExample: Using Local Variables\n\nThe easiest case with local variables is when they are used but not reassigned. In this\n\ncase, I can just pass them in as parameters. So if I have the following function:\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nprintBanner();\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\n// record due date const today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);\n\n//print details console.log(`name: ${invoice.customer}`); console.log(`amount: ${outstanding}`); console.log(`due: ${invoice.dueDate.toLocaleDateString()}`); }\n\nI can extract the printing of details passing two parameters:\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nprintBanner();\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\n// record due date\n\nwww.EBooksWorld.ir",
      "content_length": 1279,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 128,
      "content": "const today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);\n\nprintDetails(invoice, outstanding); } function printDetails(invoice, outstanding) { console.log(`name: ${invoice.customer}`); console.log(`amount: ${outstanding}`); console.log(`due: ${invoice.dueDate.toLocaleDateString()}`); }\n\nThe same is true if the local variable is a structure (such as an array, record, or object)\n\nand I modify that structure. So, I can similarly extract the setting of the due date:\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nprintBanner();\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\nrecordDueDate(invoice); printDetails(invoice, outstanding); } function recordDueDate(invoice) { const today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30); }\n\nExample: Reassigning a Local Variable\n\nIt’s the assignment to local variables that becomes complicated. In this case, we’re only\n\ntalking about temps. If I see an assignment to a parameter, I immediately use Split\n\nVariable (240), which turns it into a temp.\n\nFor temps that are assigned to, there are two cases. The simpler case is where the\n\nvariable is a temporary variable used only within the extracted code. When that\n\nhappens, the variable just exists within the extracted code. Sometimes, particularly\n\nwhen variables are initialized at some distance before they are used, it’s handy to use\n\nSlide Statements (223) to get all the variable manipulation together.\n\nwww.EBooksWorld.ir",
      "content_length": 1617,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 129,
      "content": "The more awkward case is where the variable is used outside the extracted function. In\n\nthat case, I need to return the new value. I can illustrate this with the following\n\nfamiliar­looking function:\n\nClick here to view code image\n\nfunction printOwing(invoice) { let outstanding = 0;\n\nprintBanner();\n\n// calculate outstanding for (const o of invoice.orders) { outstanding += o.amount; }\n\nrecordDueDate(invoice); printDetails(invoice, outstanding); }\n\nI’ve shown the previous refactorings all in one step, since they were straightforward,\n\nbut this time I’ll take it one step at a time from the mechanics.\n\nFirst, I’ll slide the declaration next to its use.\n\nClick here to view code image\n\nfunction printOwing(invoice) { printBanner();\n\n// calculate outstanding let outstanding = 0; for (const o of invoice.orders) { outstanding += o.amount; }\n\nrecordDueDate(invoice); printDetails(invoice, outstanding); }\n\nI then copy the code I want to extract into a target function.\n\nClick here to view code image\n\nfunction printOwing(invoice) { printBanner();\n\nwww.EBooksWorld.ir",
      "content_length": 1067,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 130,
      "content": "// calculate outstanding let outstanding = 0; for (const o of invoice.orders) { outstanding += o.amount; }\n\nrecordDueDate(invoice); printDetails(invoice, outstanding); } function calculateOutstanding(invoice) { let outstanding = 0; for (const o of invoice.orders) { outstanding += o.amount; } return outstanding; }\n\nSince I moved the declaration of outstanding into the extracted code, I don’t need to\n\npass it in as a parameter. The outstanding variable is the only one reassigned in the\n\nextracted code, so I can return it.\n\nMy JavaScript environment doesn’t yield any value by compiling—indeed less than I’m\n\ngetting from the syntax analysis in my editor—so there’s no step to do here. My next\n\nthing to do is to replace the original code with a call to the new function. Since I’m\n\nreturning the value, I need to store it in the original variable.\n\nClick here to view code image\n\nfunction printOwing(invoice) { printBanner(); let outstanding = calculateOutstanding(invoice); recordDueDate(invoice); printDetails(invoice, outstanding); } function calculateOutstanding(invoice) { let outstanding = 0; for (const o of invoice.orders) { outstanding += o.amount; } return outstanding; }\n\nBefore I consider myself done, I rename the return value to follow my usual coding\n\nstyle.\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1328,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 131,
      "content": "function printOwing(invoice) { printBanner(); const outstanding = calculateOutstanding(invoice); recordDueDate(invoice); printDetails(invoice, outstanding); } function calculateOutstanding(invoice) { let result = 0; for (const o of invoice.orders) { result += o.amount; } return result; }\n\nI also take the opportunity to change the original outstanding into a const.\n\nAt this point you may be wondering, “What happens if more than one variable needs to\n\nbe returned?”\n\nHere, I have several options. Usually I prefer to pick different code to extract. I like a\n\nfunction to return one value, so I would try to arrange for multiple functions for the\n\ndifferent values. If I really need to extract with multiple values, I can form a record and\n\nreturn that—but usually I find it better to rework the temporary variables instead. Here\n\nI like using Replace Temp with Query (178) and Split Variable (240).\n\nThis raises an interesting question when I’m extracting functions that I expect to then\n\nmove to another context, such as top level. I prefer small steps, so my instinct is to\n\nextract into a nested function first, then move that nested function to its new context.\n\nBut the tricky part of this is dealing with variables and I don’t expose that difficulty\n\nuntil I do the move. This argues that even though I can extract into a nested function, it\n\nmakes sense to extract to at least the sibling level of the source function first, so I can\n\nimmediately tell if the extracted code makes sense.\n\nINLINE FUNCTION\n\nformerly: Inline Method\n\ninverse of: Extract Function (106)\n\nwww.EBooksWorld.ir",
      "content_length": 1593,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 132,
      "content": "Motivation\n\nOne of the themes of this book is using short functions named to show their intent,\n\nbecause these functions lead to clearer and easier to read code. But sometimes, I do\n\ncome across a function in which the body is as clear as the name. Or, I refactor the body\n\nof the code into something that is just as clear as the name. When this happens, I get rid\n\nof the function. Indirection can be helpful, but needless indirection is irritating.\n\nI also use Inline Function is when I have a group of functions that seem badly factored.\n\nI can inline them all into one big function and then reextract the functions the way I\n\nprefer.\n\nI commonly use Inline Function when I see code that’s using too much indirection—\n\nwhen it seems that every function does simple delegation to another function, and I get\n\nlost in all the delegation. Some of this indirection may be worthwhile, but not all of it.\n\nBy inlining, I can flush out the useful ones and eliminate the rest.\n\nMechanics\n\nCheck that this isn’t a polymorphic method.\n\nIf this is a method in a class, and has subclasses that override it, then I can’t inline\n\nit.\n\nwww.EBooksWorld.ir",
      "content_length": 1142,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 133,
      "content": "Find all the callers of the function.\n\nReplace each call with the function’s body.\n\nTest after each replacement.\n\nThe entire inlining doesn’t have to be done all at once. If some parts of the inline are\n\ntricky, they can be done gradually as opportunity permits.\n\nRemove the function definition.\n\nWritten this way, Inline Function is simple. In general, it isn’t. I could write pages on\n\nhow to handle recursion, multiple return points, inlining a method into another object\n\nwhen you don’t have accessors, and the like. The reason I don’t is that if you encounter\n\nthese complexities, you shouldn’t do this refactoring.\n\nExample\n\nIn the simplest case, this refactoring is so easy it’s trivial. I start with\n\nClick here to view code image\n\nfunction rating(aDriver) { return moreThanFiveLateDeliveries(aDriver) ? 2 : 1; } function moreThanFiveLateDeliveries(aDriver) { return aDriver.numberOfLateDeliveries > 5; }\n\nI can just take the return expression of the called function and paste it into the caller to\n\nreplace the call.\n\nClick here to view code image\n\nfunction rating(aDriver) { return aDriver.numberOfLateDeliveries > 5 ? 2 : 1; }\n\nBut it can be a little more involved than that, requiring me to do more work to fit the\n\ncode into its new home. Consider the case where I start with this slight variation on the\n\nearlier initial code.\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1391,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 134,
      "content": "function rating(aDriver) { return moreThanFiveLateDeliveries(aDriver) ? 2 : 1; } function moreThanFiveLateDeliveries(dvr) { return dvr.numberOfLateDeliveries > 5; }\n\nAlmost the same, but now the declared argument on\n\nmoreThanFiveLateDeliveries is different to the name of the passed­in argument.\n\nSo I have to fit the code a little when I do the inline.\n\nClick here to view code image\n\nfunction rating(aDriver) { return aDriver.numberOfLateDeliveries > 5 ? 2 : 1; }\n\nIt can be even more involved than this. Consider this code:\n\nClick here to view code image\n\nfunction reportLines(aCustomer) { const lines = []; gatherCustomerData(lines, aCustomer); return lines; } function gatherCustomerData(out, aCustomer) { out.push([\"name\", aCustomer.name]); out.push([\"location\", aCustomer.location]); }\n\nInlining gatherCustomerData into reportLines isn’t a simple cut and paste. It’s\n\nnot too complicated, and most times I would still do this in one go, with a bit of fitting.\n\nBut to be cautious, it may make sense to move one line at a time. So I’d start with using\n\nMove Statements to Callers (217) on the first line (I’d do it the simple way with a cut,\n\npaste, and fit).\n\nClick here to view code image\n\nfunction reportLines(aCustomer) { const lines = []; lines.push([\"name\", aCustomer.name]); gatherCustomerData(lines, aCustomer); return lines;\n\nwww.EBooksWorld.ir",
      "content_length": 1359,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 135,
      "content": "} function gatherCustomerData(out, aCustomer) { out.push([\"name\", aCustomer.name]); out.push([\"location\", aCustomer.location]); }\n\nI then continue with the other lines until I’m done.\n\nClick here to view code image\n\nfunction reportLines(aCustomer) { const lines = []; lines.push([\"name\", aCustomer.name]); lines.push([\"location\", aCustomer.location]); return lines; }\n\nThe point here is to always be ready to take smaller steps. Most of the time, with the\n\nsmall functions I normally write, I can do Inline Function in one go, even if there is a bit\n\nof refitting to do. But if I run into complications, I go one line at a time. Even with one\n\nline, things can get a bit awkward; then, I’ll use the more elaborate mechanics for Move\n\nStatements to Callers (217) to break things down even more. And if, feeling confident, I\n\ndo something the quick way and the tests break, I prefer to revert back to my last green\n\ncode and repeat the refactoring with smaller steps and a touch of chagrin.\n\nEXTRACT VARIABLE\n\nformerly: Introduce Explaining Variable\n\ninverse of: Inline Variable (123)\n\nwww.EBooksWorld.ir",
      "content_length": 1102,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 136,
      "content": "Motivation\n\nExpressions can become very complex and hard to read. In such situations, local\n\nvariables may help break the expression down into something more manageable. In\n\nparticular, they give me an ability to name a part of a more complex piece of logic. This\n\nallows me to better understand the purpose of what’s happening.\n\nSuch variables are also handy for debugging, since they provide an easy hook for a\n\ndebugger or print statement to capture.\n\nIf I’m considering Extract Variable, it means I want to add a name to an expression in\n\nmy code. Once I’ve decided I want to do that, I also think about the context of that\n\nname. If it’s only meaningful within the function I’m working on, then Extract Variable\n\nis a good choice—but if it makes sense in a broader context, I’ll consider making the\n\nname available in that broader context, usually as a function. If the name is available\n\nmore widely, then other code can use that expression without having to repeat the\n\nexpression, leading to less duplication and a better statement of my intent.\n\nThe downside of promoting the name to a broader context is extra effort. If it’s\n\nsignificantly more effort, I’m likely to leave it till later when I can use Replace Temp\n\nwith Query (178). But if it’s easy, I like to do it now so the name is immediately\n\navailable in the code. As a good example of this, if I’m working in a class, then Extract\n\nFunction (106) is very easy to do.\n\nMechanics\n\nEnsure that the expression you want to extract does not have side effects. www.EBooksWorld.ir",
      "content_length": 1542,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 137,
      "content": "Declare an immutable variable. Set it to a copy of the expression you want to name.\n\nReplace the original expression with the new variable.\n\nTest.\n\nIf the expression appears more than once, replace each occurrence with the variable,\n\ntesting after each replacement.\n\nExample\n\nI start with a simple calculation\n\nClick here to view code image\n\nfunction price(order) { //price is base price ­ quantity discount + shipping return order.quantity * order.itemPrice ­ Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100); }\n\nSimple as it may be, I can make it still easier to follow. First, I recognize that the base\n\nprice is the multiple of the quantity and the item price.\n\nClick here to view code image\n\nfunction price(order) { //price is base price ­ quantity discount + shipping return order.quantity * order.itemPrice ­ Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100); }\n\nOnce that understanding is in my head, I put it in the code by creating and naming a\n\nvariable for it.\n\nClick here to view code image\n\nfunction price(order) { //price is base price ­ quantity discount + shipping const basePrice = order.quantity * order.itemPrice; return order.quantity * order.itemPrice ­ Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05 +\n\nwww.EBooksWorld.ir",
      "content_length": 1387,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 138,
      "content": "Math.min(order.quantity * order.itemPrice * 0.1, 100); }\n\nOf course, just declaring and initializing a variable doesn’t do anything; I also have to\n\nuse it, so I replace the expression that I used as its source.\n\nClick here to view code image\n\nfunction price(order) { //price is base price ­ quantity discount + shipping const basePrice = order.quantity * order.itemPrice; return basePrice ­ Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100); }\n\nThat same expression is used later on, so I can replace it with the variable there too.\n\nClick here to view code image\n\nfunction price(order) { //price is base price ­ quantity discount + shipping const basePrice = order.quantity * order.itemPrice; return basePrice ­ Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05 + Math.min(basePrice * 0.1, 100); }\n\nThe next line is the quantity discount, so I can extract that too.\n\nClick here to view code image\n\nfunction price(order) { //price is base price ­ quantity discount + shipping const basePrice = order.quantity * order.itemPrice; const quantityDiscount = Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05; return basePrice ­ quantityDiscount + Math.min(basePrice * 0.1, 100); }\n\nFinally, I finish with the shipping. As I do that, I can remove the comment, too, because\n\nit no longer says anything the code doesn’t say.\n\nwww.EBooksWorld.ir",
      "content_length": 1420,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 139,
      "content": "Click here to view code image\n\nfunction price(order) { const basePrice = order.quantity * order.itemPrice; const quantityDiscount = Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05; const shipping = Math.min(basePrice * 0.1, 100); return basePrice ­ quantityDiscount + shipping; }\n\nExample: With a Class\n\nHere’s the same code, but this time in the context of a class:\n\nClick here to view code image\n\nclass Order { constructor(aRecord) { this._data = aRecord; } get quantity() {return this._data.quantity;} get itemPrice() {return this._data.itemPrice;}\n\nget price() { return this.quantity * this.itemPrice ­ Math.max(0, this.quantity ­ 500) * this.itemPrice * 0.05 + Math.min(this.quantity * this.itemPrice * 0.1, 100); } }\n\nIn this case, I want to extract the same names, but I realize that the names apply to the\n\nOrder as a whole, not just the calculation of the price. Since they apply to the whole\n\norder, I’m inclined to extract the names as methods rather than variables.\n\nClick here to view code image\n\nclass Order { constructor(aRecord) { this._data = aRecord; } get quantity() {return this._data.quantity;} get itemPrice() {return this._data.itemPrice;}\n\nget price() { return this.basePrice ­ this.quantityDiscount + this.shipping; } get basePrice() {return this.quantity * this.itemPrice;} www.EBooksWorld.ir",
      "content_length": 1329,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 140,
      "content": "get quantityDiscount() {return Math.max(0, this.quantity ­ 500) * this.itemPrice * 0.05;} get shipping() {return Math.min(this.basePrice * 0.1, 100);} }\n\nThis is one of the great benefits of objects—they give you a reasonable amount of\n\ncontext for logic to share other bits of logic and data. For something as simple as this, it\n\ndoesn’t matter so much, but with a larger class it becomes very useful to call out\n\ncommon hunks of behavior as their own abstractions with their own names to refer to\n\nthem whenever I’m working with the object.\n\nINLINE VARIABLE\n\nformerly: Inline Temp\n\ninverse of: Extract Variable (119)\n\nMotivation\n\nVariables provide names for expressions within a function, and as such they are usually\n\na Good Thing. But sometimes, the name doesn’t really communicate more than the\n\nexpression itself. At other times, you may find that a variable gets in the way of\n\nrefactoring the neighboring code. In these cases, it can be useful to inline the variable.\n\nMechanics\n\nCheck that the right­hand side of the assignment is free of side effects.\n\nIf the variable isn’t already declared immutable, do so and test.\n\nThis checks that it’s only assigned to once.\n\nwww.EBooksWorld.ir",
      "content_length": 1194,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 141,
      "content": "Find the first reference to the variable and replace it with the right­hand side of the\n\nassignment.\n\nTest.\n\nRepeat replacing references to the variable until you’ve replaced all of them.\n\nRemove the declaration and assignment of the variable.\n\nTest.\n\nCHANGE FUNCTION DECLARATION\n\naka: Rename Function\n\nformerly: Rename Method\n\nformerly: Add Parameter\n\nformerly: Remove Parameter\n\naka: Change Signature\n\nMotivation\n\nFunctions represent the primary way we break a program down into parts. Function\n\ndeclarations represent how these parts fit together—effectively, they represent the\n\nwww.EBooksWorld.ir",
      "content_length": 601,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 142,
      "content": "joints in our software systems. And, as with any construction, much depends on those\n\njoints. Good joints allow me to add new parts to the system easily, but bad ones are a\n\nconstant source of difficulty, making it harder to figure out what the software does and\n\nhow to modify it as my needs change. Fortunately, software, being soft, allows me to\n\nchange these joints, providing I do it carefully.\n\nThe most important element of such a joint is the name of the function. A good name\n\nallows me to understand what the function does when I see it called, without seeing the\n\ncode that defines its implementation. However, coming up with good names is hard,\n\nand I rarely get my names right the first time. When I find a name that’s confused me,\n\nI’m tempted to leave it—after all, it’s only a name. This is the work of the evil demon\n\nObfuscatis; for the sake of my program’s soul I must never listen to him. If I see a\n\nfunction with the wrong name, it is imperative that I change it as soon as I understand\n\nwhat a better name could be. That way, the next time I’m looking at this code, I don’t\n\nhave to figure out again what’s going on. (Often, a good way to improve a name is to\n\nwrite a comment to describe the function’s purpose, then turn that comment into a\n\nname.)\n\nSimilar logic applies to a function’s parameters. The parameters of a function dictate\n\nhow a function fits in with the rest of its world. Parameters set the context in which I\n\ncan use a function. If I have a function to format a person’s telephone number, and that\n\nfunction takes a person as its argument, then I can’t use it to format a company’s\n\ntelephone number. If I replace the person parameter with the telephone number itself,\n\nthen the formatting code is more widely useful.\n\nApart from increasing a function’s range of applicability, I can also remove some\n\ncoupling, changing what modules need to connect to others. Telephone formatting logic\n\nmay sit in a module that has no knowledge about people. Reducing how much modules\n\nneed to know about each other helps reduce how much I need to put into my brain\n\nwhen I change something—and my brain isn’t as big as it used to be (that doesn’t say\n\nanything about the size of its container, though).\n\nChoosing the right parameters isn’t something that adheres to simple rules. I may have\n\na simple function for determining if a payment is overdue, by looking at if it’s older\n\nthan 30 days. Should the parameter to this function be the payment object, or the due\n\ndate of the payment? Using the payment couples the function to the interface of the\n\npayment object. But if I use the payment, I can easily access other properties of the\n\npayment, should the logic evolve, without having to change every bit of code that calls\n\nthis function—essentially, increasing the encapsulation of the function.\n\nwww.EBooksWorld.ir",
      "content_length": 2851,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 143,
      "content": "The only right answer to this puzzle is that there is no right answer, especially over\n\ntime. So I find it’s essential to be familiar with Change Function Declaration so the code\n\ncan evolve with my understanding of what the best joints in the code need to be.\n\nUsually, I only use the main name of a refactoring when I refer to it from elsewhere in\n\nthis book. However, since renaming is such a significant use case for Change Function\n\nDeclaration, if I’m just renaming something, I’ll refer to this refactoring as Rename\n\nFunction to make it clearer what I’m doing. Whether I’m merely renaming or\n\nmanipulating the parameters, I use the same mechanics.\n\nMechanics\n\nIn most of the refactorings in this book, I present only a single set of mechanics. This\n\nisn’t because there is only one set that will do the job but because, usually, one set of\n\nmechanics will work reasonably well for most cases. Change Function Declaration,\n\nhowever, is an exception. The simple mechanics are often effective, but there are plenty\n\nof cases when a more gradual migration makes more sense. So, with this refactoring, I\n\nlook at the change and ask myself if I think I can change the declaration and all its\n\ncallers easily in one go. If so, I follow the simple mechanics. The migration­style\n\nmechanics allow me to change the callers more gradually—which is important if I have\n\nlots of them, they are awkward to get to, the function is a polymorphic method, or I\n\nhave a more complicated change to the declaration.\n\nSimple Mechanics\n\nIf you’re removing a parameter, ensure it isn’t referenced in the body of the\n\nfunction.\n\nChange the method declaration to the desired declaration.\n\nFind all references to the old method declaration, update them to the new one.\n\nTest.\n\nIt’s often best to separate changes, so if you want to both change the name and add a\n\nparameter, do these as separate steps. (In any case, if you run into trouble, revert and\n\nuse the migration mechanics instead.)\n\nMigration Mechanics\n\nIf necessary, refactor the body of the function to make it easy to do the following\n\nextraction step.\n\nwww.EBooksWorld.ir",
      "content_length": 2116,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 144,
      "content": "Use Extract Function (106) on the function body to create the new function.\n\nIf the new function will have the same name as the old one, give the new function a\n\ntemporary name that’s easy to search for.\n\nIf the extracted function needs additional parameters, use the simple mechanics to\n\nadd them.\n\nTest.\n\nApply Inline Function (115) to the old function.\n\nIf you used a temporary name, use Change Function Declaration (124) again to\n\nrestore it to the original name.\n\nTest.\n\nIf you’re changing a method on a class with polymorphism, you’ll need to add\n\nindirection for each binding. If the method is polymorphic within a single class\n\nhierarchy, you only need the forwarding method on the superclass. If the\n\npolymorphism has no superclass link, then you’ll need forwarding methods on each\n\nimplementation class.\n\nIf you are refactoring a published API, you can pause the refactoring once you’ve\n\ncreated the new function. During this pause, deprecate the original function and wait\n\nfor clients to change to the new function. The original function declaration can be\n\nremoved when (and if) you’re confident all the clients of the old function have migrated\n\nto the new one.\n\nExample: Renaming a Function (Simple Mechanics)\n\nConsider this function with an overly abbreved name:\n\nClick here to view code image\n\nfunction circum(radius) { return 2 * Math.PI * radius; }\n\nI want to change that to something more sensible. I begin by changing the declaration:\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1506,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 145,
      "content": "function circumference(radius) { return 2 * Math.PI * radius; }\n\nI then find all the callers of circum and change the name to circumference.\n\nDifferent language environments have an impact on how easy it is to find all the\n\nreferences to the old function. Static typing and a good IDE provide the best experience,\n\nusually allowing me to rename functions automatically with little chance of error.\n\nWithout static typing, this can be more involved; even good searching tools will then\n\nhave a lot of false positives.\n\nI use the same approach for adding or removing parameters: find all the callers, change\n\nthe declaration, and change the callers. It’s often better to do these as separate steps—\n\nso, if I’m both renaming the function and adding a parameter, I first do the rename,\n\ntest, then add the parameter, and test again.\n\nA disadvantage of this simple way of doing the refactoring is that I have to do all the\n\ncallers and the declaration (or all of them, if polymorphic) at once. If there are only a\n\nfew of them, or if I have decent automated refactoring tools, this is reasonable. But if\n\nthere’s a lot, it can get tricky. Another problem is when the names aren’t unique—e.g., I\n\nwant to rename the a changeAddress method on a person class but the same method,\n\nwhich I don’t want to change, exists on an insurance agreement class. The more\n\ncomplex the change is, the less I want to do it in one go like this. When this kind of\n\nproblem arises, I use the migration mechanics instead. Similarly, if I use simple\n\nmechanics and something goes wrong, I’ll revert the code to the last known good state\n\nand try again using migration mechanics.\n\nExample: Renaming a Function (Migration Mechanics)\n\nAgain, I have this function with its overly abbreved name:\n\nClick here to view code image\n\nfunction circum(radius) { return 2 * Math.PI * radius; }\n\nTo do this refactoring with migration mechanics, I begin by applying Extract Function\n\n(106) to the entire function body.\n\nwww.EBooksWorld.ir",
      "content_length": 1996,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 146,
      "content": "Click here to view code image\n\nfunction circum(radius) { return circumference(radius); } function circumference(radius) { return 2 * Math.PI * radius; }\n\nI test that, then apply Inline Function (115) to the old functions. I find all the calls of the\n\nold function and replace each one with a call of the new one. I can test after each\n\nchange, which allows me to do them one at a time. Once I’ve got them all, I remove the\n\nold function.\n\nWith most refactorings, I’m changing code that I can modify, but this refactoring can be\n\nhandy with a published API—that is, one used by code that I’m unable to change\n\nmyself. I can pause the refactoring after creating circumference and, if possible,\n\nmark circum as deprecated. I will then wait for callers to change to use\n\ncircumference; once they do, I can delete circum. Even if I’m never able to reach\n\nthe happy point of deleting circum, at least I have a better name for new code.\n\nExample: Adding a Parameter\n\nIn some software, to manage a library of books, I have a book class which has the ability\n\nto take a reservation for a customer.\n\nclass Book…\n\nClick here to view code image\n\naddReservation(customer) { this._reservations.push(customer); }\n\nI need to support a priority queue for reservations. Thus, I need an extra parameter on\n\naddReservation to indicate whether the reservation should go in the usual queue or\n\nthe high­priority queue. If I can easily find and change all the callers, then I can just go\n\nahead with the change—but if not, I can use the migration approach, which I’ll show\n\nhere.\n\nI begin by using Extract Function (106) on the body of addReservation to create the\n\nnew function. Although it will eventually be called addReservation, the new and old\n\nwww.EBooksWorld.ir",
      "content_length": 1746,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 147,
      "content": "functions can’t coexist with the same name. So I use a temporary name that will be easy\n\nto search for later.\n\nclass Book…\n\nClick here to view code image\n\naddReservation(customer) { this.zz_addReservation(customer); }\n\nzz_addReservation(customer) { this._reservations.push(customer); }\n\nI then add the parameter to the new declaration and its call (in effect, using the simple\n\nmechanics).\n\nclass Book…\n\nClick here to view code image\n\naddReservation(customer) { this.zz_addReservation(customer, false); }\n\nzz_addReservation(customer, isPriority) { this._reservations.push(customer); }\n\nWhen I use JavaScript, before I change any of the callers, I like to apply Introduce\n\nAssertion (302) to check the new parameter is used by the caller.\n\nclass Book…\n\nClick here to view code image\n\nzz_addReservation(customer, isPriority) { assert(isPriority === true || isPriority === false); this._reservations.push(customer); }\n\nNow, when I change the callers, if I make a mistake and leave off the new parameter,\n\nthis assertion will help me catch the mistake. And I know from long experience there\n\nwww.EBooksWorld.ir",
      "content_length": 1106,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 148,
      "content": "are few more mistake­prone programmers than myself.\n\nNow, I can start changing the callers by using Inline Function (115) on the original\n\nfunction. This allows me to change one caller at a time.\n\nI then rename the new function back to the original. Usually, the simple mechanics\n\nwork fine for this, but I can also use the migration approach if I need to.\n\nExample: Changing a Parameter to One of Its Properties\n\nThe examples so far are simple changes of a name and adding a new parameter, but\n\nwith the migration mechanics, this refactoring can handle more complicated cases quite\n\nneatly. Here’s an example that is a bit more involved.\n\nI have a function which determines if a customer is based in New England.\n\nClick here to view code image\n\nfunction inNewEngland(aCustomer) { return [\"MA\", \"CT\", \"ME\", \"VT\", \"NH\", \"RI\"].includes(aCustomer.address.state); }\n\nHere is one of its callers:\n\ncaller…\n\nClick here to view code image\n\nconst newEnglanders = someCustomers.filter(c => inNewEngland(c));\n\ninNewEngland only uses the customer’s home state to determine if it’s in New\n\nEngland. I’d prefer to refactor inNewEngland so that it takes a state code as a\n\nparameter, making it usable in more contexts by removing the dependency on the\n\ncustomer.\n\nWith Change Function Declaration, my usual first move is to apply Extract Function\n\n(106), but in this case I can make it easier by first refactoring the function body a little. I\n\nuse Extract Variable (119) on my desired new parameter.\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1536,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 149,
      "content": "function inNewEngland(aCustomer) { const stateCode = aCustomer.address.state; return [\"MA\", \"CT\", \"ME\", \"VT\", \"NH\", \"RI\"].includes(stateCode); }\n\nNow I use Extract Function (106) to create that new function.\n\nClick here to view code image\n\nfunction inNewEngland(aCustomer) { const stateCode = aCustomer.address.state; return xxNEWinNewEngland(stateCode); }\n\nfunction xxNEWinNewEngland(stateCode) { return [\"MA\", \"CT\", \"ME\", \"VT\", \"NH\", \"RI\"].includes(stateCode); }\n\nI give the function a name that’s easy to automatically replace to turn into the original\n\nname later. (You can tell I don’t have a standard for these temporary names.)\n\nI apply Inline Variable (123) on the input parameter in the original function.\n\nClick here to view code image\n\nfunction inNewEngland(aCustomer) { return xxNEWinNewEngland(aCustomer.address.state); }\n\nI use Inline Function (115) to fold the old function into its callers, effectively replacing\n\nthe call to the old function with a call to the new one. I can do these one at a time.\n\ncaller…\n\nClick here to view code image\n\nconst newEnglanders = someCustomers.filter(c => xxNEWinNewEngland(c.address.state))\n\nOnce I’ve inlined the old function into every caller, I use Change Function Declaration\n\nagain to change the name of the new function to that of the original.\n\ncaller…\n\nwww.EBooksWorld.ir",
      "content_length": 1330,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 150,
      "content": "Click here to view code image\n\nconst newEnglanders = someCustomers.filter(c => inNewEngland(c.address.state));\n\ntop level…\n\nClick here to view code image\n\nfunction inNewEngland(stateCode) { return [\"MA\", \"CT\", \"ME\", \"VT\", \"NH\", \"RI\"].includes(stateCode); }\n\nAutomated refactoring tools make the migration mechanics both less useful and more\n\neffective. They make it less useful because they handle even complicated renames and\n\nparameter changes safer, so I don’t have to use the migration approach as often as I do\n\nwithout that support. However, in cases like this example, where the tools can’t do the\n\nwhole refactoring, they still make it much easier as the key moves of extract and inline\n\ncan be done more quickly and safely with the tool.\n\nENCAPSULATE VARIABLE\n\nformerly: Self­Encapsulate Field\n\nformerly: Encapsulate Field\n\nMotivation\n\nwww.EBooksWorld.ir",
      "content_length": 863,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 151,
      "content": "Refactoring is all about manipulating the elements of our programs. Data is more\n\nawkward to manipulate than functions. Since using a function usually means calling it,\n\nI can easily rename or move a function while keeping the old function intact as a\n\nforwarding function (so my old code calls the old function, which calls the new\n\nfunction). I’ll usually not keep this forwarding function around for long, but it does\n\nsimplify the refactoring.\n\nData is more awkward because I can’t do that. If I move data around, I have to change\n\nall the references to the data in a single cycle to keep the code working. For data with a\n\nvery small scope of access, such as a temporary variable in a small function, this isn’t a\n\nproblem. But as the scope grows, so does the difficulty, which is why global data is such\n\na pain.\n\nSo if I want to move widely accessed data, often the best approach is to first encapsulate\n\nit by routing all its access through functions. That way, I turn the difficult task of\n\nreorganizing data into the simpler task of reorganizing functions.\n\nEncapsulating data is valuable for other things too. It provides a clear point to monitor\n\nchanges and use of the data; I can easily add validation or consequential logic on the\n\nupdates. It is my habit to make all mutable data encapsulated like this and only\n\naccessed through functions if its scope is greater than a single function. The greater the\n\nscope of the data, the more important it is to encapsulate. My approach with legacy\n\ncode is that whenever I need to change or add a new reference to such a variable, I\n\nshould take the opportunity to encapsulate it. That way I prevent the increase of\n\ncoupling to commonly used data.\n\nThis principle is why the object­oriented approach puts so much emphasis on keeping\n\nan object’s data private. Whenever I see a public field, I consider using Encapsulate\n\nVariable (in that case often called Encapsulate Field) to reduce its visibility. Some go\n\nfurther and argue that even internal references to fields within a class should go\n\nthrough accessor functions—an approach known as self­encapsulation. On the whole, I\n\nfind self­encapsulation excessive—if a class is so big that I need to self­encapsulate its\n\nfields, it needs to be broken up anyway. But self­encapsulating a field is a useful step\n\nbefore splitting a class.\n\nKeeping data encapsulated is much less important for immutable data. When the data\n\ndoesn’t change, I don’t need a place to put in validation or other logic hooks before\n\nupdates. I can also freely copy the data rather than move it—so I don’t have to change\n\nreferences from old locations, nor do I worry about sections of code getting stale data.\n\nImmutability is a powerful preservative.\n\nwww.EBooksWorld.ir\n\nMechanics",
      "content_length": 2767,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 152,
      "content": "Mechanics\n\nCreate encapsulating functions to access and update the variable.\n\nRun static checks.\n\nFor each reference to the variable, replace with a call to the appropriate\n\nencapsulating function. Test after each replacement.\n\nRestrict the visibility of the variable.\n\nSometimes it’s not possible to prevent access to the variable. If so, it may be useful\n\nto detect any remaining references by renaming the variable and testing.\n\nTest.\n\nIf the value of the variable is a record, consider Encapsulate Record (162).\n\nExample\n\nConsider some useful data held in a global variable.\n\nClick here to view code image\n\nlet defaultOwner = {firstName: \"Martin\", lastName: \"Fowler\"};\n\nLike any data, it’s referenced with code like this:\n\nClick here to view code image\n\nspaceship.owner = defaultOwner;\n\nand updated like this:\n\nClick here to view code image\n\ndefaultOwner = {firstName: \"Rebecca\", lastName: \"Parsons\"};\n\nTo do a basic encapsulation on this, I start by defining functions to read and write the\n\ndata.\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1053,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 153,
      "content": "function getDefaultOwner() {return defaultOwner;} function setDefaultOwner(arg) {defaultOwner = arg;}\n\nI then start working on references to defaultOwner. When I see a reference, I replace\n\nit with a call to the getting function.\n\nClick here to view code image\n\nspaceship.owner = getDefaultOwner();\n\nWhen I see an assignment, I replace it with the setting function.\n\nClick here to view code image\n\nsetDefaultOwner({firstName: \"Rebecca\", lastName: \"Parsons\"});\n\nI test after each replacement.\n\nOnce I’m done with all the references, I restrict the visibility of the variable. This both\n\nchecks that there aren’t any references that I’ve missed, and ensures that future\n\nchanges to the code won’t access the variable directly. I can do that in JavaScript by\n\nmoving both the variable and the accessor methods to their own file and only exporting\n\nthe accessor methods.\n\ndefaultOwner.js…\n\nClick here to view code image\n\nlet defaultOwner = {firstName: \"Martin\", lastName: \"Fowler\"}; export function getDefaultOwner() {return defaultOwner;} export function setDefaultOwner(arg) {defaultOwner = arg;}\n\nIf I’m in a situation where I cannot restrict the access to a variable, it may be useful to\n\nrename the variable and retest. That won’t prevent future direct access, but naming the\n\nvariable something meaningful and awkward such as\n\n__privateOnly_defaultOwner may help.\n\nI don’t like the use of get prefixes on getters, so I’ll rename to remove it.\n\ndefaultOwner.js…\n\nwww.EBooksWorld.ir",
      "content_length": 1482,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 154,
      "content": "Click here to view code image\n\nlet defaultOwnerData = {firstName: \"Martin\", lastName: \"Fowler\"}; export function getdefaultOwner() {return defaultOwnerData;} export function setDefaultOwner(arg) {defaultOwnerData = arg;}\n\nA common convention in JavaScript is to name a getting function and setting function\n\nthe same and differentiate them due the presence of an argument. I call this practice\n\nOverloaded Getter Setter [mf­ogs] and strongly dislike it. So, even though I don’t like\n\nthe get prefix, I will keep the set prefix.\n\nEncapsulating the Value\n\nThe basic refactoring I’ve outlined here encapsulates a reference to some data structure,\n\nallowing me to control its access and reassignment. But it doesn’t control changes to\n\nthat structure.\n\nClick here to view code image\n\nconst owner1 = defaultOwner(); assert.equal(\"Fowler\", owner1.lastName, \"when set\"); const owner2 = defaultOwner(); owner2.lastName = \"Parsons\"; assert.equal(\"Parsons\", owner1.lastName, \"after change owner2\"); // is this ok?\n\nThe basic refactoring encapsulates the reference to the data item. In many cases, this is\n\nall I want to do for the moment. But I often want to take the encapsulation deeper to\n\ncontrol not just changes to the variable but also to its contents.\n\nFor this, I have a couple of options. The simplest one is to prevent any changes to the\n\nvalue. My favorite way to handle this is by modifying the getting function to return a\n\ncopy of the data.\n\ndefaultOwner.js…\n\nClick here to view code image\n\nlet defaultOwnerData = {firstName: \"Martin\", lastName: \"Fowler\"}; export function defaultOwner() {return Object.assign({}, defaultOwnerData);} export function setDefaultOwner(arg) {defaultOwnerData = arg;}\n\nwww.EBooksWorld.ir",
      "content_length": 1721,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 155,
      "content": "I use this approach particularly often with lists. If I return a copy of the data, any clients\n\nusing it can change it, but that change isn’t reflected in the shared data. I have to be\n\ncareful with using copies, however: Some code may expect to change shared data. If\n\nthat’s the case, I’m relying on my tests to detect a problem. An alternative is to prevent\n\nchanges—and a good way of doing that is Encapsulate Record (162).\n\nClick here to view code image\n\nlet defaultOwnerData = {firstName: \"Martin\", lastName: \"Fowler\"}; export function defaultOwner() {return new Person(defaultOwnerData);} export function setDefaultOwner(arg) {defaultOwnerData = arg;}\n\nclass Person { constructor(data) { this._lastName = data.lastName; this._firstName = data.firstName } get lastName() {return this._lastName;} get firstName() {return this._firstName;} // and so on for other properties\n\nNow, any attempt to reassign the properties of the default owner will cause an error.\n\nDifferent languages have different techniques to detect or prevent changes like this, so\n\ndepending on the language I’d consider other options.\n\nDetecting and preventing changes like this is often worthwhile as a temporary measure.\n\nI can either remove the changes, or provide suitable mutating functions. Then, once\n\nthey are all dealt with, I can modify the getting method to return a copy.\n\nSo far I’ve talked about copying on getting data, but it may be worthwhile to make a\n\ncopy in the setter too. That will depend on where the data comes from and whether I\n\nneed to maintain a link to reflect any changes in that original data. If I don’t need such\n\na link, a copy prevents accidents due to changes on that source data. Taking a copy may\n\nbe superfluous most of the time, but copies in these cases usually have a negligible\n\neffect on performance; on the other hand, if I don’t do them, there is a risk of a long and\n\ndifficult bout of debugging in the future.\n\nRemember that the copying above, and the class wrapper, both only work one level\n\ndeep in the record structure. Going deeper requires more levels of copies or object\n\nwrapping.\n\nAs you can see, encapsulating data is valuable, but often not straightforward. Exactly\n\nwww.EBooksWorld.ir",
      "content_length": 2219,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 156,
      "content": "what to encapsulate—and how to do it—depends on the way the data is being used and\n\nthe changes I have in mind. But the more widely it’s used, the more it’s worth my\n\nattention to encapsulate properly.\n\nRENAME VARIABLE\n\nMotivation\n\nNaming things well is the heart of clear programming. Variables can do a lot to explain\n\nwhat I’m up to—if I name them well. But I frequently get my names wrong—sometimes\n\nbecause I’m not thinking carefully enough, sometimes because my understanding of the\n\nproblem improves as I learn more, and sometimes because the program’s purpose\n\nchanges as my users’ needs change.\n\nEven more than most program elements, the importance of a name depends on how\n\nwidely it’s used. A variable used in a one­line lambda expression is usually easy to\n\nfollow—I often use a single letter in that case since the variable’s purpose is clear from\n\nits context. Parameters for short functions can often be terse for the same reason,\n\nalthough in a dynamically typed language like JavaScript, I do like to put the type into\n\nthe name (hence parameter names like aCustomer).\n\nPersistent fields that last beyond a single function invocation require more careful\n\nnaming. This is where I’m likely to put most of my attention.\n\nMechanics\n\nIf the variable is used widely, consider Encapsulate Variable (132).\n\nFind all references to the variable, and change every one.\n\nIf there are references from another code base, the variable is a published variable,\n\nwww.EBooksWorld.ir",
      "content_length": 1482,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 157,
      "content": "and you cannot do this refactoring.\n\nIf the variable does not change, you can copy it to one with the new name, then\n\nchange gradually, testing after each change.\n\nTest.\n\nExample\n\nThe simplest case for renaming a variable is when it’s local to a single function: a temp\n\nor argument. It’s too trivial for even an example: I just find each reference and change\n\nit. After I’m done, I test to ensure I didn’t mess up.\n\nProblems occur when the variable has a wider scope than just a single function. There\n\nmay be a lot of references all over the code base:\n\nlet tpHd = \"untitled\";\n\nSome references access the variable:\n\nresult += `<h1>${tpHd}</h1>`;\n\nOthers update it:\n\ntpHd = obj['articleTitle'];\n\nMy usual response to this is apply Encapsulate Variable (132).\n\nClick here to view code image\n\nresult += `<h1>${title()}</h1>`;\n\nsetTitle(obj['articleTitle']);\n\nfunction title() {return tpHd;} function setTitle(arg) {tpHd = arg;}\n\nAt this point, I can rename the variable.\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1020,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 158,
      "content": "let _title = \"untitled\";\n\nfunction title() {return _title;} function setTitle(arg) {_title = arg;}\n\nI could continue by inlining the wrapping functions so all callers are using the variable\n\ndirectly. But I’d rarely want to do this. If the variable is used widely enough that I feel\n\nthe need to encapsulate it in order to change its name, it’s worth keeping it\n\nencapsulated behind functions for the future.\n\nIn cases where I was going to inline, I’d call the getting function getTitle and not use\n\nan underscore for the variable name when I rename it.\n\nRenaming a Constant\n\nIf I’m renaming a constant (or something that acts like a constant to clients) I can avoid\n\nencapsulation, and still do the rename gradually, by copying. If the original declaration\n\nlooks like this:\n\nClick here to view code image\n\nconst cpyNm = \"Acme Gooseberries\";\n\nI can begin the renaming by making a copy:\n\nClick here to view code image\n\nconst companyName = \"Acme Gooseberries\"; const cpyNm = companyName;\n\nWith the copy, I can gradually change references from the old name to the new name.\n\nWhen I’m done, I remove the copy. I prefer to declare the new name and copy to the old\n\nname if it makes it a tad easier to remove the old name and put it back again should a\n\ntest fail.\n\nThis works for constants as well as for variables that are read­only to clients (such as an\n\nexported variable in JavaScript).\n\nINTRODUCE PARAMETER OBJECT\n\nwww.EBooksWorld.ir",
      "content_length": 1435,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 159,
      "content": "Motivation\n\nI often see groups of data items that regularly travel together, appearing in function\n\nafter function. Such a group is a data clump, and I like to replace it with a single data\n\nstructure.\n\nGrouping data into a structure is valuable because it makes explicit the relationship\n\nbetween the data items. It reduces the size of parameter lists for any function that uses\n\nthe new structure. It helps consistency since all functions that use the structure will use\n\nthe same names to get at its elements.\n\nBut the real power of this refactoring is how it enables deeper changes to the code.\n\nWhen I identify these new structures, I can reorient the behavior of the program to use\n\nthese structures. I will create functions that capture the common behavior over this\n\ndata—either as a set of common functions or as a class that combines the data structure\n\nwith these functions. This process can change the conceptual picture of the code,\n\nraising these structures as new abstractions that can greatly simplify my understanding\n\nof the domain. When this works, it can have surprisingly powerful effects—but none of\n\nthis is possible unless I use Introduce Parameter Object to begin the process.\n\nMechanics\n\nIf there isn’t a suitable structure already, create one.\n\nI prefer to use a class, as that makes it easier to group behavior later on. I usually\n\nlike to ensure these structures are value objects [mf­vo].\n\nTest.\n\nwww.EBooksWorld.ir",
      "content_length": 1445,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 160,
      "content": "Use Change Function Declaration (124) to add a parameter for the new structure.\n\nTest.\n\nAdjust each caller to pass in the correct instance of the new structure. Test after\n\neach one.\n\nFor each element of the new structure, replace the use of the original parameter\n\nwith the element of the structure. Remove the parameter. Test.\n\nExample\n\nI’ll begin with some code that looks at a set of temperature readings and determines\n\nwhether any of them fall outside of an operating range. Here’s what the data looks like\n\nfor the readings:\n\nClick here to view code image\n\nconst station = { name: \"ZB1\", readings: [ {temp: 47, time: \"2016­11­10 09:10\"}, {temp: 53, time: \"2016­11­10 09:20\"}, {temp: 58, time: \"2016­11­10 09:30\"}, {temp: 53, time: \"2016­11­10 09:40\"}, {temp: 51, time: \"2016­11­10 09:50\"}, ] };\n\nI have a function to find the readings that are outside a temperature range.\n\nClick here to view code image\n\nfunction readingsOutsideRange(station, min, max) { return station.readings .filter(r => r.temp < min || r.temp > max); }\n\nIt might be called from some code like this:\n\ncaller\n\nClick here to view code image\n\nalerts = readingsOutsideRange(station, www.EBooksWorld.ir",
      "content_length": 1176,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 161,
      "content": "operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling);\n\nNotice how the calling code pulls the two data items as a pair from another object and\n\npasses the pair into readingsOutsideRange. The operating plan uses different\n\nnames to indicate the start and end of the range compared to\n\nreadingsOutsideRange. A range like this is a common case where two separate data\n\nitems are better combined into a single object. I’ll begin by declaring a class for the\n\ncombined data.\n\nClick here to view code image\n\nclass NumberRange { constructor(min, max) { this._data = {min: min, max: max}; } get min() {return this._data.min;} get max() {return this._data.max;} }\n\nI declare a class, rather than just using a basic JavaScript object, because I usually find\n\nthis refactoring to be a first step to moving behavior into the newly created object. Since\n\na class makes sense for this, I go right ahead and use one directly. I also don’t provide\n\nany update methods for the new class, as I’ll probably make this a Value Object [mf­vo].\n\nMost times I do this refactoring, I create value objects.\n\nI then use Change Function Declaration (124) to add the new object as a parameter to\n\nreadingsOutsideRange.\n\nClick here to view code image\n\nfunction readingsOutsideRange(station, min, max, range) { return station.readings .filter(r => r.temp < min || r.temp > max); }\n\nIn JavaScript, I can leave the caller as is, but in other languages I’d have to add a null\n\nfor the new parameter which would look something like this:\n\ncaller\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1573,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 162,
      "content": "alerts = readingsOutsideRange(station, operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling, null);\n\nAt this point I haven’t changed any behavior, and tests should still pass. I then go to\n\neach caller and adjust it to pass in the correct date range.\n\ncaller\n\nClick here to view code image\n\nconst range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling); alerts = readingsOutsideRange(station, operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling, range);\n\nI still haven’t altered any behavior yet, as the parameter isn’t used. All tests should still\n\nwork.\n\nNow I can start replacing the usage of the parameters. I’ll start with the maximum.\n\nClick here to view code image\n\nfunction readingsOutsideRange(station, min, max, range) { return station.readings .filter(r => r.temp < min || r.temp > range.max); }\n\ncaller\n\nClick here to view code image\n\nconst range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling); alerts = readingsOutsideRange(station, operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling, range);\n\nI can test at this point, then remove the other parameter.\n\nwww.EBooksWorld.ir",
      "content_length": 1195,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 163,
      "content": "Click here to view code image\n\nfunction readingsOutsideRange(station, min, range) { return station.readings .filter(r => r.temp < range.min || r.temp > range.max); }\n\ncaller\n\nClick here to view code image\n\nconst range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling); alerts = readingsOutsideRange(station, operatingPlan.temperatureFloor, range);\n\nThat completes this refactoring. However, replacing a clump of parameters with a real\n\nobject is just the setup for the really good stuff. The great benefits of making a class like\n\nthis is that I can then move behavior into the new class. In this case, I’d add a method\n\nfor range that tests if a value falls within the range.\n\nClick here to view code image\n\nfunction readingsOutsideRange(station, range) { return station.readings .filter(r => !range.contains(r.temp)); }\n\nclass NumberRange…\n\nClick here to view code image\n\ncontains(arg) {return (arg >= this.min && arg <= this.max);}\n\nThis is a first step to creating a range [mf­range] that can take on a lot of useful\n\nbehavior. Once I’ve identified the need for a range in my code, I can be constantly on\n\nthe lookout for other cases where I see a max/min pair of numbers and replace them\n\nwith a range. (One immediate possibility is the operating plan, replacing\n\ntemperatureFloor and temperatureCeiling with a temperatureRange.) As I\n\nlook at how these pairs are used, I can move more useful behavior into the range class,\n\nwww.EBooksWorld.ir",
      "content_length": 1482,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 164,
      "content": "simplifying its usage across the code base. One of the first things I may add is a value­\n\nbased equality method to make it a true value object.\n\nCOMBINE FUNCTIONS INTO CLASS\n\nMotivation\n\nClasses are a fundamental construct in most modern programming languages. They\n\nbind together data and functions into a shared environment, exposing some of that data\n\nand function to other program elements for collaboration. They are the primary\n\nconstruct in object­oriented languages, but are also useful with other approaches too.\n\nWhen I see a group of functions that operate closely together on a common body of data\n\n(usually passed as arguments to the function call), I see an opportunity to form a class.\n\nUsing a class makes the common environment that these functions share more explicit,\n\nallows me to simplify function calls inside the object by removing many of the\n\narguments, and provides a reference to pass such an object to other parts of the system.\n\nIn addition to organizing already formed functions, this refactoring also provides a\n\ngood opportunity to identify other bits of computation and refactor them into methods\n\non the new class.\n\nAnother way of organizing functions together is Combine Functions into Transform\n\n(149). Which one to use depends more on the broader context of the program. One\n\nsignificant advantage of using a class is that it allows clients to mutate the core data of\n\nwww.EBooksWorld.ir",
      "content_length": 1425,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 165,
      "content": "the object, and the derivations remain consistent.\n\nAs well as a class, functions like this can also be combined into a nested function.\n\nUsually I prefer a class to a nested function, as it can be difficult to test functions nested\n\nwithin another. Classes are also necessary when there is more than one function in the\n\ngroup that I want to expose to collaborators.\n\nLanguages that don’t have classes as a first­class element, but do have first­class\n\nfunctions, often use the Function As Object [mf­fao] to provide this capability.\n\nMechanics\n\nApply Encapsulate Record (162) to the common data record that the functions\n\nshare.\n\nIf the data that is common between the functions isn’t already grouped into a record\n\nstructure, use Introduce Parameter Object (140) to create a record to group it\n\ntogether.\n\nTake each function that uses the common record and use Move Function (198) to\n\nmove it into the new class.\n\nAny arguments to the function call that are members can be removed from the\n\nargument list.\n\nEach bit of logic that manipulates the data can be extracted with Extract Function\n\n(106) and then moved into the new class.\n\nExample\n\nI grew up in England, a country renowned for its love of Tea. (Personally, I don’t like\n\nmost tea they serve in England, but have since acquired a taste for Chinese and\n\nJapanese teas.) So my author’s fantasy conjures up a state utility for providing tea to\n\nthe population. Every month they read the tea meters, to get a record like this:\n\nClick here to view code image\n\nreading = {customer: \"ivan\", quantity: 10, month: 5, year: 2017};\n\nI look through the code that processes these records, and I see lots of places where\n\nsimilar calculations are done on the data. So I find a spot that calculates the base\n\nwww.EBooksWorld.ir",
      "content_length": 1774,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 166,
      "content": "charge:\n\nclient 1…\n\nClick here to view code image\n\nconst aReading = acquireReading(); const baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity;\n\nBeing England, everything essential must be taxed, so it is with tea. But the rules allow\n\nat least an essential level of tea to be free of taxation.\n\nclient 2…\n\nClick here to view code image\n\nconst aReading = acquireReading(); const base = (baseRate(aReading.month, aReading.year) * aReading.quantity); const taxableCharge = Math.max(0, base ­ taxThreshold(aReading.year));\n\nI’m sure that, like me, you noticed that the formula for the base charge is duplicated\n\nbetween these two fragments. If you’re like me, you’re already reaching for Extract\n\nFunction (106). Interestingly, it seems our work has been done for us elsewhere.\n\nclient 3…\n\nClick here to view code image\n\nconst aReading = acquireReading(); const basicChargeAmount = calculateBaseCharge(aReading);\n\nfunction calculateBaseCharge(aReading) { return baseRate(aReading.month, aReading.year) * aReading.quantity; }\n\nGiven this, I have a natural impulse to change the two earlier bits of client code to use\n\nthis function. But the trouble with top­level functions like this is that they are often easy\n\nto miss. I’d rather change the code to give the function a closer connection to the data it\n\nprocesses. A good way to do this is to turn the data into a class.\n\nTo turn the record into a class, I use Encapsulate Record (162).\n\nwww.EBooksWorld.ir",
      "content_length": 1476,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 167,
      "content": "Click here to view code image\n\nclass Reading { constructor(data) { this._customer = data.customer; this._quantity = data.quantity; this._month = data.month; this._year = data.year; } get customer() {return this._customer;} get quantity() {return this._quantity;} get month() {return this._month;} get year() {return this._year;} }\n\nTo move the behavior, I’ll start with the function I already have:\n\ncalculateBaseCharge. To use the new class, I need to apply it to the data as soon as\n\nI’ve acquired it.\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const basicChargeAmount = calculateBaseCharge(aReading);\n\nI then use Move Function (198) to move calculateBaseCharge into the new class.\n\nclass Reading…\n\nClick here to view code image\n\nget calculateBaseCharge() { return baseRate(this.month, this.year) * this.quantity; }\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const basicChargeAmount = aReading.calculateBaseCharge;\n\nwww.EBooksWorld.ir",
      "content_length": 1094,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 168,
      "content": "While I’m at it, I use Rename Function (124) to make it something more to my liking.\n\nClick here to view code image\n\nget baseCharge() { return baseRate(this.month, this.year) * this.quantity; }\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const basicChargeAmount = aReading.baseCharge;\n\nWith this naming, the client of the reading class can’t tell whether the base charge is a\n\nfield or a derived value. This is a Good Thing—the Uniform Access Principle [mf­ua].\n\nI now alter the first client to call the method rather than repeat the calculation.\n\nclient 1…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const baseCharge = aReading.baseCharge;\n\nThere’s a strong chance I’ll use Inline Variable (123) on the baseCharge variable\n\nbefore the day is out. But more relevant to this refactoring is the client that calculates\n\nthe taxable amount. My first step here is to use the new base charge property.\n\nclient 2…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const taxableCharge = Math.max(0, aReading.baseCharge ­ taxThreshold(aReading.year));\n\nwww.EBooksWorld.ir",
      "content_length": 1269,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 169,
      "content": "I use Extract Function (106) on the calculation for the taxable charge.\n\nClick here to view code image\n\nfunction taxableChargeFn(aReading) { return Math.max(0, aReading.baseCharge ­ taxThreshold(aReading.year)); }\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const taxableCharge = taxableChargeFn(aReading);\n\nThen I apply Move Function (198).\n\nclass Reading…\n\nClick here to view code image\n\nget taxableCharge() { return Math.max(0, this.baseCharge ­ taxThreshold(this.year)); }\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = new Reading(rawReading); const taxableCharge = aReading.taxableCharge;\n\nSince all the derived data is calculated on demand, I have no problem should I need to\n\nupdate the stored data. In general, I prefer immutable data, but many circumstances\n\nforce us to work with mutable data (such as JavaScript, a language ecosystem that\n\nwasn’t designed with immutability in mind). When there is a reasonable chance the\n\ndata will be updated somewhere in the program, then a class is very helpful.\n\nwww.EBooksWorld.ir\n\nCOMBINE FUNCTIONS INTO TRANSFORM",
      "content_length": 1193,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 170,
      "content": "COMBINE FUNCTIONS INTO TRANSFORM\n\nMotivation\n\nSoftware often involves feeding data into programs that calculate various derived\n\ninformation from it. These derived values may be needed in several places, and those\n\ncalculations are often repeated wherever the derived data is used. I prefer to bring all of\n\nthese derivations together, so I have a consistent place to find and update them and\n\navoid any duplicate logic.\n\nOne way to do this is to use a data transformation function that takes the source data as\n\ninput and calculates all the derivations, putting each derived value as a field in the\n\noutput data. Then, to examine the derivations, all I need do is look at the transform\n\nfunction.\n\nAn alternative to Combine Functions into Transform is Combine Functions into Class\n\n(144) that moves the logic into methods on a class formed from the source data. Either\n\nof these refactorings are helpful, and my choice will often depend on the style of\n\nprogramming already in the software. But there is one important difference: Using a\n\nclass is much better if the source data gets updated within the code. Using a transform\n\nstores derived data in the new record, so if the source data changes, I will run into\n\ninconsistencies.\n\nOne of the reasons I like to do combine functions is to avoid duplication of the\n\nwww.EBooksWorld.ir",
      "content_length": 1334,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 171,
      "content": "derivation logic. I can do that just by using Extract Function (106) on the logic, but it’s\n\noften difficult to find the functions unless they are kept close to the data structures they\n\noperate on. Using a transform (or a class) makes it easy to find and use them.\n\nMechanics\n\nCreate a transformation function that takes the record to be transformed and\n\nreturns the same values.\n\nThis will usually involve a deep copy of the record. It is often worthwhile to write a\n\ntest to ensure the transform does not alter the original record.\n\nPick some logic and move its body into the transform to create a new field in the\n\nrecord. Change the client code to access the new field.\n\nIf the logic is complex, use Extract Function (106) first.\n\nTest.\n\nRepeat for the other relevant functions.\n\nExample\n\nWhere I grew up, tea is an important part of life—so much that I can imagine a special\n\nutility that provides tea to the populace that’s regulated like a utility. Every month, the\n\nutility gets a reading of how much tea a customer has acquired.\n\nClick here to view code image\n\nreading = {customer: \"ivan\", quantity: 10, month: 5, year: 2017};\n\nCode in various places calculates various consequences of this tea usage. One such\n\ncalculation is the base monetary amount that’s used to calculate the charge for the\n\ncustomer.\n\nclient 1…\n\nClick here to view code image\n\nconst aReading = acquireReading(); const baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity;\n\nwww.EBooksWorld.ir",
      "content_length": 1494,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 172,
      "content": "Another is the amount that should be taxed—which is less than the base amount since\n\nthe government wisely considers that every citizen should get some tea tax free.\n\nclient 2…\n\nClick here to view code image\n\nconst aReading = acquireReading(); const base = (baseRate(aReading.month, aReading.year) * aReading.quantity); const taxableCharge = Math.max(0, base ­ taxThreshold(aReading.year));\n\nLooking through this code, I see these calculations repeated in several places. Such\n\nduplication is asking for trouble when they need to change (and I’d bet it’s “when” not\n\n“if”). I can deal with this repetition by using Extract Function (106) on these\n\ncalculations, but such functions often end up scattered around the program making it\n\nhard for future developers to realize they are there. Indeed, looking around I discover\n\nsuch a function, used in another area of the code.\n\nclient 3…\n\nClick here to view code image\n\nconst aReading = acquireReading(); const basicChargeAmount = calculateBaseCharge(aReading);\n\nfunction calculateBaseCharge(aReading) { return baseRate(aReading.month, aReading.year) * aReading.quantity; }\n\nOne way of dealing with this is to move all of these derivations into a transformation\n\nstep that takes the raw reading and emits a reading enriched with all the common\n\nderived results.\n\nI begin by creating a transformation function that merely copies the input object.\n\nClick here to view code image\n\nfunction enrichReading(original) { const result = _.cloneDeep(original); return result; }\n\nwww.EBooksWorld.ir",
      "content_length": 1534,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 173,
      "content": "I’m using the cloneDeep from lodash to create a deep copy.\n\nWhen I’m applying a transformation that produces essentially the same thing but with\n\nadditional information, I like to name it using “enrich”. If it were producing something\n\nI felt was different, I would name it using “transform”.\n\nI then pick one of the calculations I want to change. First, I enrich the reading it uses\n\nwith the current one that does nothing yet.\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = enrichReading(rawReading); const basicChargeAmount = calculateBaseCharge(aReading);\n\nI use Move Function (198) on calculateBaseCharge to move it into the enrichment\n\ncalculation.\n\nClick here to view code image\n\nfunction enrichReading(original) { const result = _.cloneDeep(original); result.baseCharge = calculateBaseCharge(result); return result; }\n\nWithin the transformation function, I’m happy to mutate a result object, instead of\n\ncopying each time. I like immutability, but most common languages make it difficult to\n\nwork with. I’m prepared to go through the extra effort to support it at boundaries, but\n\nwill mutate within smaller scopes. I also pick my names (using aReading as the\n\naccumulating variable) to make it easier to move the code into the transformer\n\nfunction.\n\nI change the client that uses that function to use the enriched field instead.\n\nclient 3…\n\nClick here to view code image\n\nconst rawReading = acquireReading();\n\nwww.EBooksWorld.ir",
      "content_length": 1488,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 174,
      "content": "const aReading = enrichReading(rawReading); const basicChargeAmount = aReading.baseCharge;\n\nOnce I’ve moved all calls to calculateBaseCharge, I can nest it inside\n\nenrichReading. That would make it clear that clients that need the calculated base\n\ncharge should use the enriched record.\n\nOne trap to beware of here. When I write enrichReading like this, to return the\n\nenriched reading, I’m implying that the original reading record isn’t changed. So it’s\n\nwise for me to add a test.\n\nClick here to view code image\n\nit('check reading unchanged', function() { const baseReading = {customer: \"ivan\", quantity: 15, month: 5, year: 2017}; const oracle = _.cloneDeep(baseReading); enrichReading(baseReading); assert.deepEqual(baseReading, oracle); });\n\nI can then change client 1 to also use the same field.\n\nclient 1…\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = enrichReading(rawReading); const baseCharge = aReading.baseCharge;\n\nThere is a good chance I can then use Inline Variable (123) on baseCharge too.\n\nNow I turn to the taxable amount calculation. My first step is to add in the\n\ntransformation function.\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = enrichReading(rawReading); const base = (baseRate(aReading.month, aReading.year) * aReading.quantity); const taxableCharge = Math.max(0, base ­ taxThreshold(aReading.year));\n\nwww.EBooksWorld.ir",
      "content_length": 1430,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 175,
      "content": "I can immediately replace the calculation of the base charge with the new field. If the\n\ncalculation was complex, I could Extract Function (106) first, but here it’s simple\n\nenough to do in one step.\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = enrichReading(rawReading); const base = aReading.baseCharge; const taxableCharge = Math.max(0, base ­ taxThreshold(aReading.year));\n\nOnce I’ve tested that that works, I apply Inline Variable (123):\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = enrichReading(rawReading); const taxableCharge = Math.max(0, aReading.baseCharge ­ taxThreshold(aReading.year));\n\nand move that computation into the transformer:\n\nClick here to view code image\n\nfunction enrichReading(original) { const result = _.cloneDeep(original); result.baseCharge = calculateBaseCharge(result); result.taxableCharge = Math.max(0, result.baseCharge ­ taxThreshold(result.year)); return result; }\n\nI modify the original code to use the new field.\n\nClick here to view code image\n\nconst rawReading = acquireReading(); const aReading = enrichReading(rawReading); const taxableCharge = aReading.taxableCharge;\n\nOnce I’ve tested that, it’s likely I would be able to use Inline Variable (123) on\n\ntaxableCharge.\n\nwww.EBooksWorld.ir",
      "content_length": 1314,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 176,
      "content": "One big problem with an enriched reading like this is: What happens should a client\n\nchange a data value? Changing, say, the quantity field would result in data that’s\n\ninconsistent. To avoid this in JavaScript, my best option is to use Combine Functions\n\ninto Class (144) instead. If I’m in a language with immutable data structures, I don’t\n\nhave this problem, so its more common to see transforms in those languages. But even\n\nin languages without immutability, I can use transforms if the data appears in a read­\n\nonly context, such as deriving data to display on a web page.\n\nSPLIT PHASE\n\nMotivation\n\nWhen I run into code that’s dealing with two different things, I look for a way to split it\n\ninto separate modules. I endeavor to make this split because, if I need to make a\n\nchange, I can deal with each topic separately and not have to hold both in my head\n\ntogether. If I’m lucky, I may only have to change one module without having to\n\nremember the details of the other one at all.\n\nwww.EBooksWorld.ir",
      "content_length": 1011,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 177,
      "content": "One of the neatest ways to do a split like this is to divide the behavior into two\n\nsequential phases. A good example of this is when you have some processing whose\n\ninputs don’t reflect the model you need to carry out the logic. Before you begin, you can\n\nmassage the input into a convenient form for your main processing. Or, you can take\n\nthe logic you need to do and break it down into sequential steps, where each step is\n\nsignificantly different in what it does.\n\nThe most obvious example of this is a compiler. It’s a basic task is to take some text\n\n(code in a programming language) and turn it into some executable form (e.g., object\n\ncode for a specific hardware). Over time, we’ve found this can be usefully split into a\n\nchain of phases: tokenizing the text, parsing the tokens into a syntax tree, then various\n\nsteps of transforming the syntax tree (e.g., for optimization), and finally generating the\n\nobject code. Each step has a limited scope and I can think of one step without\n\nunderstanding the details of others.\n\nSplitting phases like this is common in large software; the various phases in a compiler\n\ncan each contain many functions and classes. But I can carry out the basic split­phase\n\nrefactoring on any fragment of code—whenever I see an opportunity to usefully\n\nseparate the code into different phases. The best clue is when different stages of the\n\nfragment use different sets of data and functions. By turning them into separate\n\nmodules I can make this difference explicit, revealing the difference in the code.\n\nMechanics\n\nExtract the second phase code into its own function.\n\nTest.\n\nIntroduce an intermediate data structure as an additional argument to the extracted\n\nfunction.\n\nTest.\n\nExamine each parameter of the extracted second phase. If it is used by first phase,\n\nmove it to the intermediate data structure. Test after each move.\n\nSometimes, a parameter should not be used by the second phase. In this case,\n\nextract the results of each usage of the parameter into a field of the intermediate\n\ndata structure and use Move Statements to Callers (217) on the line that populates\n\nit.\n\nwww.EBooksWorld.ir",
      "content_length": 2142,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 178,
      "content": "Apply Extract Function (106) on the first­phase code, returning the intermediate\n\ndata structure.\n\nIt’s also reasonable to extract the first phase into a transformer object.\n\nExample\n\nI’ll start with code to price an order for some vague and unimportant kind of goods:\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; const shippingPerCase = (basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = quantity * shippingPerCase; const price = basePrice ­ discount + shippingCost; return price; }\n\nAlthough this is the usual kind of trivial example, there is a sense of two phases going\n\non here. The first couple of lines of code use the product information to calculate the\n\nproduct­oriented price of the order, while the later code uses shipping information to\n\ndetermine the shipping cost. If I have changes coming up that complicate the pricing\n\nand shipping calculations, but they work relatively independently, then splitting this\n\ncode into two phases is valuable.\n\nI begin by applying Extract Function (106) to the shipping calculation.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; const price = applyShipping(basePrice, shippingMethod, quantity, discount); return price; } function applyShipping(basePrice, shippingMethod, quantity, discount) { const shippingPerCase = (basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = quantity * shippingPerCase; const price = basePrice ­ discount + shippingCost;\n\nwww.EBooksWorld.ir",
      "content_length": 1975,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 179,
      "content": "return price; }\n\nI pass in all the data that this second phase needs as individual parameters. In a more\n\nrealistic case, there can be a lot of these, but I don’t worry about it as I’ll whittle them\n\ndown later.\n\nNext, I introduce the intermediate data structure that will communicate between the\n\ntwo phases.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; const priceData = {}; const price = applyShipping(priceData, basePrice, shippingMethod, quantity, discount); return price; } function applyShipping(priceData, basePrice, shippingMethod, quantity, discount) { const shippingPerCase = (basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = quantity * shippingPerCase; const price = basePrice ­ discount + shippingCost; return price; }\n\nNow, I look at the various parameters to applyShipping. The first one is basePrice\n\nwhich is created by the first­phase code. So I move this into the intermediate data\n\nstructure, removing it from the parameter list.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; const priceData = {basePrice: basePrice}; const price = applyShipping(priceData, basePrice, shippingMethod, quantity, discount); return price; } function applyShipping(priceData, basePrice, shippingMethod, quantity, discount) { const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase;\n\nwww.EBooksWorld.ir",
      "content_length": 1867,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 180,
      "content": "const shippingCost = quantity * shippingPerCase; const price = priceData.basePrice ­ discount + shippingCost; return price; }\n\nThe next parameter in the list is shippingMethod. This one I leave as is, since it isn’t\n\nused by the first­phase code.\n\nAfter this, I have quantity. This is used by the first phase but not created by it, so I\n\ncould actually leave this in the parameter list. My usual preference, however, is to move\n\nas much as I can to the intermediate data structure.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; const priceData = {basePrice: basePrice, quantity: quantity}; const price = applyShipping(priceData, shippingMethod, quantity, discount); return price; } function applyShipping(priceData, shippingMethod, quantity, discount) { const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = priceData.quantity * shippingPerCase; const price = priceData.basePrice ­ discount + shippingCost; return price; }\n\nI do the same with discount.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; const priceData = {basePrice: basePrice, quantity: quantity, discount:discount}; const price = applyShipping(priceData, shippingMethod, discount); return price; } function applyShipping(priceData, shippingMethod, discount) { const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = priceData.quantity * shippingPerCase;\n\nwww.EBooksWorld.ir",
      "content_length": 1955,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 181,
      "content": "const price = priceData.basePrice ­ priceData.discount + shippingCost; return price; }\n\nOnce I’ve gone through all the function parameters, I have the intermediate data\n\nstructure fully formed. So I can extract the first­phase code into its own function,\n\nreturning this data.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const priceData = calculatePricingData(product, quantity); const price = applyShipping(priceData, shippingMethod); return price; } function calculatePricingData(product, quantity) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; return {basePrice: basePrice, quantity: quantity, discount:discount}; } function applyShipping(priceData, shippingMethod) { const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = priceData.quantity * shippingPerCase; const price = priceData.basePrice ­ priceData.discount + shippingCost; return price; }\n\nI can’t resist tidying out those final constants.\n\nClick here to view code image\n\nfunction priceOrder(product, quantity, shippingMethod) { const priceData = calculatePricingData(product, quantity); return applyShipping(priceData, shippingMethod); } function calculatePricingData(product, quantity) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity ­ product.discountThreshold, 0) * product.basePrice * product.discountRate; return {basePrice: basePrice, quantity: quantity, discount:discount}; } function applyShipping(priceData, shippingMethod) { const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase;\n\nwww.EBooksWorld.ir",
      "content_length": 1862,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 182,
      "content": "const shippingCost = priceData.quantity * shippingPerCase; return priceData.basePrice ­ priceData.discount + shippingCost; }\n\nwww.EBooksWorld.ir",
      "content_length": 144,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 183,
      "content": "Chapter 7 Encapsulation\n\nHistory\n\nTopics\n\nPerhaps the most important criteria to be used in decomposing modules is to identify\n\nsecrets that modules should hide from the rest of the system [Parnas]. Data structures\n\nTutorials\n\nare the most common secrets, and I can hide data structures by encapsulating them\n\nwith Encapsulate Record (162) and Encapsulate Collection (170). Even primitive data\n\nOffers & Deals\n\nvalues can be encapsulated with Replace Primitive with Object (174)—the magnitude of\n\nHighlights\n\nsecond­order benefits from doing this often surprises people. Temporary variables\n\noften get in the way of refactoring—I have to ensure they are calculated in the right\n\nSettings\n\norder and their values are available to other parts of the code that need them. Using\n\nReplace Temp with Query (178) is a great help here, particularly when splitting up an\n\nSupport\n\noverly long function.\n\nSign Out\n\nClasses were designed for information hiding. In the previous chapter, I described a\n\nway to form them with Combine Functions into Class (144). The common extract/inline\n\noperations also apply to classes with Extract Class (182) and Inline Class (186).\n\nAs well as hiding the internals of classes, it’s often useful to hide connections between\n\nclasses, which I can do with Hide Delegate (189). But too much hiding leads to bloated\n\ninterfaces, so I also need its reverse: Remove Middle Man (192).\n\nClasses and modules are the largest forms of encapsulation, but functions also\n\nencapsulate their implementation. Sometimes, I may need to make a wholesale change\n\nto an algorithm, which I can do by wrapping it in a function with Extract Function\n\n(106) and applying Substitute Algorithm (195).\n\nENCAPSULATE RECORD\n\nformerly: Replace Record with Data Class\n\nwww.EBooksWorld.ir",
      "content_length": 1780,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 184,
      "content": "Motivation\n\nThis is why I often favor objects over records for mutable data. With objects, I can hide\n\nwhat is stored and provide methods for all three values. The user of the object doesn’t\n\nneed to know or care which is stored and which is calculated. This encapsulation also\n\nhelps with renaming: I can rename the field while providing methods for both the new\n\nand the old names, gradually updating callers until they are all done.\n\nI just said I favor objects for mutable data. If I have an immutable value, I can just have\n\nall three values in my record, using an enrichment step if necessary. Similarly, it’s easy\n\nto copy the field when renaming.\n\nI can have two kinds of record structures: those where I declare the legal field names\n\nand those that allow me to use whatever I like. The latter are often implemented\n\nthrough a library class called something like hash, map, hashmap, dictionary, or\n\nassociative array. Many languages provide convenient syntax for creating hashmaps,\n\nwhich makes them useful in many programming situations. The downside of using\n\nthem is they are aren’t explicit about their fields. The only way I can tell if they use\n\nstart/end or start/length is by looking at where they are created and used. This isn’t a\n\nproblem if they are only used in a small section of a program, but the wider their scope\n\nof usage, the greater problem I get from their implicit structure. I could refactor such\n\nimplicit records into explicit ones—but if I need to do that, I’d rather make them classes\n\nwww.EBooksWorld.ir",
      "content_length": 1541,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 185,
      "content": "instead.\n\nIt’s common to pass nested structures of lists and hashmaps which are often serialized\n\ninto formats like JSON or XML. Such structures can be encapsulated too, which helps if\n\ntheir formats change later on or if I’m concerned about updates to the data that are\n\nhard to keep track of.\n\nMechanics\n\nUse Encapsulate Variable (132) on the variable holding the record.\n\nGive the functions that encapsulate the record names that are easily searchable.\n\nReplace the content of the variable with a simple class that wraps the record. Define\n\nan accessor inside this class that returns the raw record. Modify the functions that\n\nencapsulate the variable to use this accessor.\n\nTest.\n\nProvide new functions that return the object rather than the raw record.\n\nFor each user of the record, replace its use of a function that returns the record with\n\na function that returns the object. Use an accessor on the object to get at the field\n\ndata, creating that accessor if needed. Test after each change.\n\nIf it’s a complex record, such as one with a nested structure, focus on clients that\n\nupdate the data first. Consider returning a copy or read­only proxy of the data for\n\nclients that only read the data.\n\nRemove the class’s raw data accessor and the easily searchable functions that\n\nreturned the raw record.\n\nTest.\n\nIf the fields of the record are themselves structures, consider using Encapsulate\n\nRecord and Encapsulate Collection (170) recursively.\n\nExample\n\nI’ll start with a constant that is widely used across a program.\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1578,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 186,
      "content": "const organization = {name: \"Acme Gooseberries\", country: \"GB\"};\n\nThis is a JavaScript object which is being used as a record structure by various parts of\n\nthe program, with accesses like this:\n\nClick here to view code image\n\nresult += `<h1>${organization.name}</h1>`;\n\nand\n\norganization.name = newName;\n\nThe first step is a simple Encapsulate Variable (132).\n\nClick here to view code image\n\nfunction getRawDataOfOrganization() {return organization;}\n\nexample reader…\n\nClick here to view code image\n\nresult += `<h1>${getRawDataOfOrganization().name}</h1>`;\n\nexample writer…\n\nClick here to view code image\n\ngetRawDataOfOrganization().name = newName;\n\nIt’s not quite a standard Encapsulate Variable (132), since I gave the getter a name\n\ndeliberately chosen to be both ugly and easy to search for. This is because I intend its\n\nlife to be short.\n\nEncapsulating a record means going deeper than just the variable itself; I want to\n\ncontrol how it’s manipulated. I can do this by replacing the record with a class.\n\nwww.EBooksWorld.ir",
      "content_length": 1031,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 187,
      "content": "class Organization…\n\nclass Organization { constructor(data) { this._data = data; } }\n\ntop level\n\nClick here to view code image\n\nconst organization = new Organization({name: \"Acme Gooseberries\", country: \"GB\"});\n\nfunction getRawDataOfOrganization() {return organization._data;} function getOrganization() {return organization;}\n\nNow that I have an object in place, I start looking at the users of the record. Any one\n\nthat updates the record gets replaced with a setter.\n\nclass Organization…\n\nClick here to view code image\n\nset name(aString) {this._data.name = aString;}\n\nclient…\n\ngetOrganization().name = newName;\n\nSimilarly, I replace any readers with the appropriate getter.\n\nclass Organization…\n\nClick here to view code image\n\nget name() {return this._data.name;}\n\nclient…\n\nwww.EBooksWorld.ir",
      "content_length": 795,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 188,
      "content": "Click here to view code image\n\nresult += `<h1>${getOrganization().name}</h1>`;\n\nAfter I’ve done that, I can follow through on my threat to give the ugly sounding\n\nfunction a short life.\n\nClick here to view code image\n\nfunction getRawDataOfOrganization() {return organization._data;} function getOrganization() {return organization;}\n\nI’d also be inclined to fold the _data field directly into the object.\n\nClick here to view code image\n\nclass Organization { constructor(data) { this._name = data.name; this._country = data.country; } get name() {return this._name;} set name(aString) {this._name = aString;} get country() {return this._country;} set country(aCountryCode) {this._country = aCountryCode;} }\n\nThis has the advantage of breaking the link to the input data record. This might be\n\nuseful if a reference to it runs around, which would break encapsulation. Should I not\n\nfold the data into individual fields, I would be wise to copy _data when I assign it.\n\nExample: Encapsulating a Nested Record\n\nThe above example looks at a shallow record, but what do I do with data that is deeply\n\nnested, e.g., coming from a JSON document? The core refactoring steps still apply, and\n\nI have to be equally careful with updates, but I do get some options around reads.\n\nAs an example, here is some slightly more nested data: a collection of customers, kept\n\nin a hashmap indexed by their customer ID.\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1448,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 189,
      "content": "\"1920\": { name: \"martin\", id: \"1920\", usages: { \"2016\": { \"1\": 50, \"2\": 55, // remaining months of the year }, \"2015\": { \"1\": 70, \"2\": 63, // remaining months of the year } } }, \"38673\": { name: \"neal\", id: \"38673\", // more customers in a similar form\n\nWith more nested data, reads and writes can be digging into the data structure.\n\nsample update…\n\nClick here to view code image\n\ncustomerData[customerID].usages[year][month] = amount;\n\nsample read…\n\nClick here to view code image\n\nfunction compareUsage (customerID, laterYear, month) { const later = customerData[customerID].usages[laterYear][month]; const earlier = customerData[customerID].usages[laterYear ­ 1][month]; return {laterAmount: later, change: later ­ earlier}; }\n\nTo encapsulate this data, I also start with Encapsulate Variable (132).\n\nClick here to view code image\n\nfunction getRawDataOfCustomers() {return customerData;} function setRawDataOfCustomers(arg) {customerData = arg;}\n\nwww.EBooksWorld.ir",
      "content_length": 967,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 190,
      "content": "sample update…\n\nClick here to view code image\n\ngetRawDataOfCustomers()[customerID].usages[year][month] = amount;\n\nsample read…\n\nClick here to view code image\n\nfunction compareUsage (customerID, laterYear, month) { const later = getRawDataOfCustomers()[customerID].usages[laterYear][month]; const earlier = getRawDataOfCustomers()[customerID].usages[laterYear ­ 1][month]; return {laterAmount: later, change: later ­ earlier}; }\n\nI then make a class for the overall data structure.\n\nclass CustomerData { constructor(data) { this._data = data; } }\n\ntop level…\n\nClick here to view code image\n\nfunction getCustomerData() {return customerData;} function getRawDataOfCustomers() {return customerData._data;} function setRawDataOfCustomers(arg) {customerData = new CustomerData(arg);}\n\nThe most important area to deal with is the updates. So, while I look at all the callers of\n\ngetRawDataOfCustomers, I’m focused on those where the data is changed. To\n\nremind you, here’s the update again:\n\nsample update…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1050,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 191,
      "content": "getRawDataOfCustomers()[customerID].usages[year][month] = amount;\n\nThe general mechanics now say to return the full customer and use an accessor,\n\ncreating one if needed. I don’t have a setter on the customer for this update, and this\n\none digs into the structure. So, to make one, I begin by using Extract Function (106) on\n\nthe code that digs into the data structure.\n\nsample update…\n\nClick here to view code image\n\nsetUsage(customerID, year, month, amount);\n\ntop level…\n\nClick here to view code image\n\nfunction setUsage(customerID, year, month, amount) { getRawDataOfCustomers()[customerID].usages[year][month] = amount; }\n\nI then use Move Function (198) to move it into the new customer data class.\n\nsample update…\n\nClick here to view code image\n\ngetCustomerData().setUsage(customerID, year, month, amount);\n\nclass CustomerData…\n\nClick here to view code image\n\nsetUsage(customerID, year, month, amount) { this._data[customerID].usages[year][month] = amount; }\n\nWhen working with a big data structure, I like to concentrate on the updates. Getting\n\nthem visible and gathered in a single place is the most important part of the\n\nencapsulation.\n\nwww.EBooksWorld.ir",
      "content_length": 1165,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 192,
      "content": "At some point, I will think I’ve got them all—but how can I be sure? There’s a couple of\n\nways to check. One is to modify getRawDataOfCustomers to return a deep copy of\n\nthe data; if my test coverage is good, one of the tests should break if I missed a\n\nmodification.\n\ntop level…\n\nClick here to view code image\n\nfunction getCustomerData() {return customerData;} function getRawDataOfCustomers() {return customerData.rawData;} function setRawDataOfCustomers(arg) {customerData = new CustomerData(arg);}\n\nclass CustomerData…\n\nClick here to view code image\n\nget rawData() { return _.cloneDeep(this._data); }\n\nI’m using the lodash library to make a deep copy.\n\nAnother approach is to return a read­only proxy for the data structure. Such a proxy\n\ncould raise an exception if the client code tries to modify the underlying object. Some\n\nlanguages make this easy, but it’s a pain in JavaScript, so I’ll leave it as an exercise for\n\nthe reader. I could also take a copy and recursively freeze it to detect any modifications.\n\nDealing with the updates is valuable, but what about the readers? Here there are a few\n\noptions.\n\nThe first option is to do the same thing as I did for the setters. Extract all the reads into\n\ntheir own functions and move them into the customer data class.\n\nclass CustomerData…\n\nClick here to view code image\n\nusage(customerID, year, month) { return this._data[customerID].usages[year][month]; }\n\nwww.EBooksWorld.ir",
      "content_length": 1434,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 193,
      "content": "top level…\n\nClick here to view code image\n\nfunction compareUsage (customerID, laterYear, month) { const later = getCustomerData().usage(customerID, laterYear, month); const earlier = getCustomerData().usage(customerID, laterYear ­ 1, month) return {laterAmount: later, change: later ­ earlier}; }\n\nThe great thing about this approach is that it gives customerData an explicit API that\n\ncaptures all the uses made of it. I can look at the class and see all their uses of the data.\n\nBut this can be a lot of code for lots of special cases. Modern languages provide good\n\naffordances for digging into a list­and­hash [mf­lh] data structure, so it’s useful to give\n\nclients just such a data structure to work with.\n\nIf the client wants a data structure, I can just hand out the actual data. But the problem\n\nwith this is that there’s no way to prevent clients from modifying the data directly,\n\nwhich breaks the whole point of encapsulating all the updates inside functions.\n\nConsequently, the simplest thing to do is to provide a copy of the underlying data, using\n\nthe rawData method I wrote earlier.\n\nclass CustomerData…\n\nClick here to view code image\n\nget rawData() { return _.cloneDeep(this._data); }\n\ntop level…\n\nClick here to view code image\n\nfunction compareUsage (customerID, laterYear, month) { const later = getCustomerData().rawData[customerID].usages[laterYear][month]; const earlier = getCustomerData().rawData[customerID].usages[laterYear ­ 1][month]; return {laterAmount: later, change: later ­ earlier}; }\n\nBut although it’s simple, there are downsides. The most obvious problem is the cost of\n\nwww.EBooksWorld.ir",
      "content_length": 1626,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 194,
      "content": "copying a large data structure, which may turn out to be a performance problem. As\n\nwith anything like this, however, the performance cost might be acceptable—I would\n\nwant to measure its impact before I start to worry about it. There may also be confusion\n\nif clients expect modifying the copied data to modify the original. In those cases, a read­\n\nonly proxy or freezing the copied data might provide a helpful error should they do this.\n\nAnother option is more work, but offers the most control: Apply Encapsulate Record\n\nrecursively. With this, I turn the customer record into its own class, apply Encapsulate\n\nCollection (170) to the usages, and create a usage class. I can then enforce control of\n\nupdates by using accessors, perhaps applying Change Reference to Value (252) on the\n\nusage objects. But this can be a lot of effort for a large data structure—and not really\n\nneeded if I don’t access that much of the data structure. Sometimes, a judicious mix of\n\ngetters and new classes may work, using a getter to dig deep into the structure but\n\nreturning an object that wraps the structure rather than the unencapsulated data. I\n\nwrote about this kind of thing in an article “Refactoring Code to Load a Document” [mf­\n\nref­doc].\n\nENCAPSULATE COLLECTION\n\nMotivation\n\nI like encapsulating any mutable data in my programs. This makes it easier to see when\n\nand how data structures are modified, which then makes it easier to change those data\n\nstructures when I need to. Encapsulation is often encouraged, particularly by object­\n\noriented developers, but a common mistake occurs when working with collections. www.EBooksWorld.ir",
      "content_length": 1635,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 195,
      "content": "Access to a collection variable may be encapsulated, but if the getter returns the\n\ncollection itself, then that collection’s membership can be altered without the enclosing\n\nclass being able to intervene.\n\nTo avoid this, I provide collection modifier methods—usually add and remove—on the\n\nclass itself. This way, changes to the collection go through the owning class, giving me\n\nthe opportunity to modify such changes as the program evolves.\n\nIff the team has the habit to not to modify collections outside the original module, just\n\nproviding these methods may be enough. However, it’s usually unwise to rely on such\n\nhabits; a mistake here can lead to bugs that are difficult to track down later. A better\n\napproach is to ensure that the getter for the collection does not return the raw\n\ncollection, so that clients cannot accidentally change it.\n\nOne way to prevent modification of the underlying collection is by never returning a\n\ncollection value. In this approach, any use of a collection field is done with specific\n\nmethods on the owning class, replacing aCustomer.orders.size with\n\naCustomer.numberOfOrders. I don’t agree with this approach. Modern languages\n\nhave rich collection classes with standardized interfaces, which can be combined in\n\nuseful ways such as Collection Pipelines [mf­cp]. Putting in special methods to handle\n\nthis kind of functionality adds a lot of extra code and cripples the easy composability of\n\ncollection operations.\n\nAnother way is to allow some form of read­only access to a collection. Java, for\n\nexample, makes it easy to return a read­only proxy to the collection. Such a proxy\n\nforwards all reads to the underlying collection, but blocks all writes—in Java’s case,\n\nthrowing an exception. A similar route is used by libraries that base their collection\n\ncomposition on some kind of iterator or enumerable object—providing that iterator\n\ncannot modify the underlying collection.\n\nProbably the most common approach is to provide a getting method for the collection,\n\nbut make it return a copy of the underlying collection. That way, any modifications to\n\nthe copy don’t affect the encapsulated collection. This might cause some confusion if\n\nprogrammers expect the returned collection to modify the source field—but in many\n\ncode bases, programmers are used to collection getters providing copies. If the\n\ncollection is huge, this may be a performance issue—but most lists aren’t all that big, so\n\nthe general rules for performance should apply (Refactoring and Performance (64)).\n\nAnother difference between using a proxy and a copy is that a modification of the\n\nsource data will be visible in the proxy but not in a copy. This isn’t an issue most of the\n\nwww.EBooksWorld.ir",
      "content_length": 2724,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 196,
      "content": "time, because lists accessed in this way are usually only held for a short time.\n\nWhat’s important here is consistency within a code base. Use only one mechanism so\n\neveryone can get used to how it behaves and expect it when calling any collection\n\naccessor function.\n\nMechanics\n\nApply Encapsulate Variable (132) if the reference to the collection isn’t already\n\nencapsulated.\n\nAdd functions to add and remove elements from the collection.\n\nIf there is a setter for the collection, use Remove Setting Method (331) if possible. If\n\nnot, make it take a copy of the provided collection.\n\nRun static checks.\n\nFind all references to the collection. If anyone calls modifiers on the collection,\n\nchange them to use the new add/remove functions. Test after each change.\n\nModify the getter for the collection to return a protected view on it, using a read­\n\nonly proxy or a copy.\n\nTest.\n\nExample\n\nI start with a person class that has a field for a list of courses.\n\nclass Person…\n\nClick here to view code image\n\nconstructor (name) { this._name = name; this._courses = []; } get name() {return this._name;} get courses() {return this._courses;} set courses(aList) {this._courses = aList;}\n\nclass Course…\n\nwww.EBooksWorld.ir",
      "content_length": 1214,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 197,
      "content": "Click here to view code image\n\nconstructor(name, isAdvanced) { this._name = name; this._isAdvanced = isAdvanced; } get name() {return this._name;} get isAdvanced() {return this._isAdvanced;}\n\nClients use the course collection to gather information on courses.\n\nClick here to view code image\n\nnumAdvancedCourses = aPerson.courses .filter(c => c.isAdvanced) .length ;\n\nA naive developer would say this class has proper data encapsulation: After all, each\n\nfield is protected by accessor methods. But I would argue that the list of courses isn’t\n\nproperly encapsulated. Certainly, anyone updating the courses as a single value has\n\nproper control through the setter:\n\nclient code…\n\nClick here to view code image\n\nconst basicCourseNames = readBasicCourseNames(filename); aPerson.courses = basicCourseNames.map(name => new Course(name, false));\n\nBut clients might find it easier to update the course list directly.\n\nclient code…\n\nClick here to view code image\n\nfor(const name of readBasicCourseNames(filename)) { aPerson.courses.push(new Course(name, false)); }\n\nThis violates encapsulating because the person class has no ability to take control when\n\nwww.EBooksWorld.ir",
      "content_length": 1166,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 198,
      "content": "the list is updated in this way. While the reference to the field is encapsulated, the\n\ncontent of the field is not.\n\nI’ll begin creating proper encapsulation by adding methods to the person class that\n\nallow a client to add and remove individual courses.\n\nclass Person…\n\nClick here to view code image\n\naddCourse(aCourse) { this._courses.push(aCourse); } removeCourse(aCourse, fnIfAbsent = () => {throw new RangeError();}) { const index = this._courses.indexOf(aCourse); if (index === ­1) fnIfAbsent(); else this._courses.splice(index, 1); }\n\nWith a removal, I have to decide what to do if a client asks to remove an element that\n\nisn’t in the collection. I can either shrug, or raise an error. With this code, I default to\n\nraising an error, but give the callers an opportunity to do something else if they wish.\n\nI then change any code that calls modifiers directly on the collection to use new\n\nmethods.\n\nclient code…\n\nClick here to view code image\n\nfor(const name of readBasicCourseNames(filename)) { aPerson.addCourse(new Course(name, false)); }\n\nWith individual add and remove methods, there is usually no need for setCourses, in\n\nwhich case I’ll use Remove Setting Method (331) on it. Should the API need a setting\n\nmethod for some reason, I ensure it puts a copy of the collection in the field.\n\nclass Person…\n\nClick here to view code image\n\nset courses(aList) {this._courses = aList.slice();}\n\nwww.EBooksWorld.ir",
      "content_length": 1421,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 199,
      "content": "All this enables the clients to use the right kind of modifier methods, but I prefer to\n\nensure nobody modifies the list without using them. I can do this by providing a copy.\n\nclass Person…\n\nClick here to view code image\n\nget courses() {return this._courses.slice();}\n\nIn general, I find it wise to be moderately paranoid about collections and I’d rather copy\n\nthem unnecessarily than debug errors due to unexpected modifications. Modifications\n\naren’t always obvious; for example, sorting an array in JavaScript modifies the original,\n\nwhile many languages default to making a copy for an operation that changes a\n\ncollection. Any class that’s responsible for managing a collection should always give out\n\ncopies—but I also get into the habit of making a copy if I do something that’s liable to\n\nchange a collection.\n\nREPLACE PRIMITIVE WITH OBJECT\n\nformerly: Replace Data Value with Object\n\nformerly: Replace Type Code with Class\n\nMotivation\n\nOften, in early stages of development you make decisions about representing simple\n\nwww.EBooksWorld.ir",
      "content_length": 1047,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 200,
      "content": "facts as simple data items, such as numbers or strings. As development proceeds, those\n\nsimple items aren’t so simple anymore. A telephone number may be represented as a\n\nstring for a while, but later it will need special behavior for formatting, extracting the\n\narea code, and the like. This kind of logic can quickly end up being duplicated around\n\nthe code base, increasing the effort whenever it needs to be used.\n\nAs soon as I realize I want to do something other than simple printing, I like to create a\n\nnew class for that bit of data. At first, such a class does little more than wrap the\n\nprimitive—but once I have that class, I have a place to put behavior specific to its needs.\n\nThese little values start very humble, but once nurtured they can grow into useful tools.\n\nThey may not look like much, but I find their effects on a code base can be surprisingly\n\nlarge. Indeed many experienced developers consider this to be one of the most valuable\n\nrefactorings in the toolkit—even though it often seems counterintuitive to a new\n\nprogrammer.\n\nMechanics\n\nApply Encapsulate Variable (132) if it isn’t already.\n\nCreate a simple value class for the data value. It should take the existing value in its\n\nconstructor and provide a getter for that value.\n\nRun static checks.\n\nChange the setter to create a new instance of the value class and store that in the\n\nfield, changing the type of the field if present.\n\nChange the getter to return the result of invoking the getter of the new class.\n\nTest.\n\nConsider using Rename Function (124) on the original accessors to better reflect\n\nwhat they do.\n\nConsider clarifying the role of the new object as a value or reference object by\n\napplying Change Reference to Value (252) or Change Value to Reference (256).\n\nExample\n\nI begin with a simple order class that reads its data from a simple record structure. One\n\nof its properties is a priority, which it reads as a simple string.\n\nwww.EBooksWorld.ir",
      "content_length": 1949,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 201,
      "content": "class Order…\n\nClick here to view code image\n\nconstructor(data) { this.priority = data.priority; // more initialization\n\nSome client codes uses it like this:\n\nclient…\n\nClick here to view code image\n\nhighPriorityCount = orders.filter(o => \"high\" === o.priority || \"rush\" === o.priority) .length;\n\nWhenever I’m fiddling with a data value, the first thing I do is use Encapsulate\n\nVariable (132) on it.\n\nclass Order…\n\nClick here to view code image\n\nget priority() {return this._priority;} set priority(aString) {this._priority = aString;}\n\nThe constructor line that initializes the priority will now use the setter I define here.\n\nThis self­encapsulates the field so I can preserve its current use while I manipulate the\n\ndata itself.\n\nI create a simple value class for the priority. It has a constructor for the value and a\n\nconversion function to return a string.\n\nClick here to view code image\n\nclass Priority { constructor(value) {this._value = value;} toString() {return this._value;} }\n\nwww.EBooksWorld.ir",
      "content_length": 1007,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 202,
      "content": "I prefer using a conversion function (toString) rather than a getter (value) here.\n\nFor clients of the class, asking for the string representation should feel more like a\n\nconversion than getting a property.\n\nI then modify the accessors to use this new class.\n\nclass Order…\n\nClick here to view code image\n\nget priority() {return this._priority.toString();} set priority(aString) {this._priority = new Priority(aString);}\n\nNow that I have a priority class, I find the current getter on the order to be misleading.\n\nIt doesn’t return the priority—but a string that describes the priority. My immediate\n\nmove is to use Rename Function (124).\n\nclass Order…\n\nClick here to view code image\n\nget priorityString() {return this._priority.toString();} set priority(aString) {this._priority = new Priority(aString);}\n\nclient…\n\nClick here to view code image\n\nhighPriorityCount = orders.filter(o => \"high\" === o.priorityString || \"rush\" === o.priorityString) .length;\n\nIn this case, I’m happy to retain the name of the setter. The name of the argument\n\ncommunicates what it expects.\n\nNow I’m done with the formal refactoring. But as I look at who uses the priority, I\n\nconsider whether they should use the priority class themselves. As a result, I provide a\n\ngetter on order that provides the new priority object directly.\n\nclass Order…\n\nwww.EBooksWorld.ir",
      "content_length": 1343,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 203,
      "content": "Click here to view code image\n\nget priority() {return this._priority;} get priorityString() {return this._priority.toString();} set priority(aString) {this._priority = new Priority(aString);}\n\nclient…\n\nClick here to view code image\n\nhighPriorityCount = orders.filter(o => \"high\" === o.priority.toString() || \"rush\" === o.priority.toString()) .length;\n\nAs the priority class becomes useful elsewhere, I would allow clients of the order to use\n\nthe setter with a priority instance, which I do by adjusting the priority constructor.\n\nclass Priority…\n\nClick here to view code image\n\nconstructor(value) { if (value instanceof Priority) return value; this._value = value; }\n\nThe point of all this is that now, my new priority class can be useful as a place for new\n\nbehavior—either new to the code or moved from elsewhere. Here’s some simple code to\n\nadd validation of priority values and comparison logic:\n\nclass Priority…\n\nClick here to view code image\n\nconstructor(value) { if (value instanceof Priority) return value; if (Priority.legalValues().includes(value)) this._value = value; else throw new Error(`<${value}> is invalid for Priority`); } toString() {return this._value;} get _index() {return Priority.legalValues().findIndex(s => s === this._value);}\n\nwww.EBooksWorld.ir",
      "content_length": 1275,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 204,
      "content": "static legalValues() {return ['low', 'normal', 'high', 'rush'];}\n\nequals(other) {return this._index === other._index;} higherThan(other) {return this._index > other._index;} lowerThan(other) {return this._index < other._index;}\n\nAs I do this, I decide that a priority should be a value object, so I provide an equals\n\nmethod and ensure that it is immutable.\n\nNow I’ve added that behavior, I can make the client code more meaningful:\n\nclient…\n\nClick here to view code image\n\nhighPriorityCount = orders.filter(o => o.priority.higherThan(new Priority(\"normal\")) .length;\n\nREPLACE TEMP WITH QUERY\n\nwww.EBooksWorld.ir\n\nMotivation",
      "content_length": 624,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 205,
      "content": "Motivation\n\nOne use of temporary variables is to capture the value of some code in order to refer to\n\nit later in a function. Using a temp allows me to refer to the value while explaining its\n\nmeaning and avoiding repeating the code that calculates it. But while using a variable is\n\nhandy, it can often be worthwhile to go a step further and use a function instead.\n\nIf I’m working on breaking up a large function, turning variables into their own\n\nfunctions makes it easier to extract parts of the function, since I no longer need to pass\n\nin variables into the extracted functions. Putting this logic into functions often also sets\n\nup a stronger boundary between the extracted logic and the original function, which\n\nhelps me spot and avoid awkward dependencies and side effects.\n\nUsing functions instead of variables also allows me to avoid duplicating the calculation\n\nlogic in similar functions. Whenever I see variables calculated in the same way in\n\ndifferent places, I look to turn them into a single function.\n\nThis refactoring works best if I’m inside a class, since the class provides a shared\n\ncontext for the methods I’m extracting. Outside of a class, I’m liable to have too many\n\nparameters in a top­level function which negates much of the benefit of using a\n\nfunction. Nested functions can avoid this, but they limit my ability to share the logic\n\nbetween related functions.\n\nOnly some temporary variables are suitable for Replace Temp with Query. The variable\n\nneeds to be calculated once and then only be read afterwards. In the simplest case, this\n\nmeans the variable is assigned to once, but it’s also possible to have several assignments\n\nin a more complicated lump of code—all of which has to be extracted into the query.\n\nFurthermore, the logic used to calculate the variable must yield the same result when\n\nthe variable is used later—which rules out variables used as snapshots with names like\n\noldAddress.\n\nMechanics\n\nCheck that the variable is determined entirely before it’s used, and the code that\n\ncalculates it does not yield a different value whenever it is used.\n\nIf the variable isn’t read­only, and can be made read­only, do so.\n\nTest.\n\nExtract the assignment of the variable into a function.\n\nwww.EBooksWorld.ir",
      "content_length": 2250,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 206,
      "content": "If the variable and the function cannot share a name, use a temporary name for the\n\nfunction.\n\nEnsure the extracted function is free of side effects. If not, use Separate Query from\n\nModifier (306).\n\nTest.\n\nUse Inline Variable (123) to remove the temp.\n\nExample\n\nHere is a simple class:\n\nclass Order…\n\nClick here to view code image\n\nconstructor(quantity, item) { this._quantity = quantity; this._item = item; }\n\nget price() { var basePrice = this._quantity * this._item.price; var discountFactor = 0.98; if (basePrice > 1000) discountFactor ­= 0.03; return basePrice * discountFactor; } }\n\nI want to replace the temps basePrice and discountFactor with methods.\n\nStarting with basePrice, I make it const and run tests. This is a good way of\n\nchecking that I haven’t missed a reassignment—unlikely in such a short function but\n\ncommon when I’m dealing with something larger.\n\nclass Order…\n\nClick here to view code image\n\nconstructor(quantity, item) { this._quantity = quantity; this._item = item; }\n\nwww.EBooksWorld.ir",
      "content_length": 1016,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 207,
      "content": "get price() { const basePrice = this._quantity * this._item.price; var discountFactor = 0.98; if (basePrice > 1000) discountFactor ­= 0.03; return basePrice * discountFactor; } }\n\nI then extract the right­hand side of the assignment to a getting method.\n\nclass Order…\n\nClick here to view code image\n\nget price() { const basePrice = this.basePrice; var discountFactor = 0.98; if (basePrice > 1000) discountFactor ­= 0.03; return basePrice * discountFactor; }\n\nget basePrice() { return this._quantity * this._item.price; }\n\nI test, and apply Inline Variable (123).\n\nclass Order…\n\nClick here to view code image\n\nget price() { const basePrice = this.basePrice; var discountFactor = 0.98; if (this.basePrice > 1000) discountFactor ­= 0.03; return this.basePrice * discountFactor; }\n\nI then repeat the steps with discountFactor, first using Extract Function (106).\n\nclass Order…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 923,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 208,
      "content": "get price() { const discountFactor = this.discountFactor; return this.basePrice * discountFactor; }\n\nget discountFactor() { var discountFactor = 0.98; if (this.basePrice > 1000) discountFactor ­= 0.03; return discountFactor; }\n\nIn this case I need my extracted function to contain both assignments to\n\ndiscountFactor. I can also set the original variable to be const.\n\nThen, I inline:\n\nClick here to view code image\n\nget price() { return this.basePrice * this.discountFactor; }\n\nEXTRACT CLASS\n\ninverse of: Inline Class (186)\n\nwww.EBooksWorld.ir\n\nMotivation",
      "content_length": 556,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 209,
      "content": "Motivation\n\nYou’ve probably read guidelines that a class should be a crisp abstraction, only handle a\n\nfew clear responsibilities, and so on. In practice, classes grow. You add some operations\n\nhere, a bit of data there. You add a responsibility to a class feeling that it’s not worth a\n\nseparate class—but as that responsibility grows and breeds, the class becomes too\n\ncomplicated. Soon, your class is as crisp as a microwaved duck.\n\nImagine a class with many methods and quite a lot of data. A class that is too big to\n\nunderstand easily. You need to consider where it can be split—and split it. A good sign\n\nis when a subset of the data and a subset of the methods seem to go together. Other\n\ngood signs are subsets of data that usually change together or are particularly\n\ndependent on each other. A useful test is to ask yourself what would happen if you\n\nremove a piece of data or a method. What other fields and methods would become\n\nnonsense?\n\nOne sign that often crops up later in development is the way the class is sub­typed. You\n\nmay find that subtyping affects only a few features or that some features need to be\n\nsubtyped one way and other features a different way.\n\nMechanics\n\nDecide how to split the responsibilities of the class.\n\nCreate a new child class to express the split­off responsibilities.\n\nIf the responsibilities of the original parent class no longer match its name, rename\n\nthe parent.\n\nCreate an instance of the child class when constructing the parent and add a link\n\nfrom parent to child.\n\nUse Move Field (207) on each field you wish to move. Test after each move.\n\nUse Move Function (198) to move methods to the new child. Start with lower­level\n\nmethods (those being called rather than calling). Test after each move.\n\nReview the interfaces of both classes, remove unneeded methods, change names to\n\nbetter fit the new circumstances.\n\nDecide whether to expose the new child. If so, consider applying Change Reference\n\nto Value (252) to the child class.\n\nwww.EBooksWorld.ir\n\nExample",
      "content_length": 2018,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 210,
      "content": "Example\n\nI start with a simple person class:\n\nclass Person…\n\nClick here to view code image\n\nget name() {return this._name;} set name(arg) {this._name = arg;} get telephoneNumber() {return `(${this.officeAreaCode}) ${this.officeNumber}`;} get officeAreaCode() {return this._officeAreaCode;} set officeAreaCode(arg) {this._officeAreaCode = arg;} get officeNumber() {return this._officeNumber;} set officeNumber(arg) {this._officeNumber = arg;}\n\nHere. I can separate the telephone number behavior into its own class. I start by\n\ndefining an empty telephone number class:\n\nclass TelephoneNumber { }\n\nThat was easy! Next, I create an instance of telephone number when constructing the\n\nperson:\n\nclass Person…\n\nClick here to view code image\n\nconstructor() { this._telephoneNumber = new TelephoneNumber(); }\n\nclass TelephoneNumber…\n\nClick here to view code image\n\nget officeAreaCode() {return this._officeAreaCode;} set officeAreaCode(arg) {this._officeAreaCode = arg;}\n\nI then use Move Field (207) on one of the fields.\n\nwww.EBooksWorld.ir",
      "content_length": 1033,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 211,
      "content": "class Person…\n\nClick here to view code image\n\nget officeAreaCode() {return this._telephoneNumber.officeAreaCode;} set officeAreaCode(arg) {this._telephoneNumber.officeAreaCode = arg;}\n\nI test, then move the next field.\n\nclass TelephoneNumber…\n\nClick here to view code image\n\nget officeNumber() {return this._officeNumber;} set officeNumber(arg) {this._officeNumber = arg;}\n\nclass Person…\n\nClick here to view code image\n\nget officeNumber() {return this._telephoneNumber.officeNumber;} set officeNumber(arg) {this._telephoneNumber.officeNumber = arg;}\n\nTest again, then move the telephone number method.\n\nclass TelephoneNumber…\n\nClick here to view code image\n\nget telephoneNumber() {return `(${this.officeAreaCode}) ${this.officeNumber}`;}\n\nclass Person…\n\nClick here to view code image\n\nget telephoneNumber() {return this._telephoneNumber.telephoneNumber;}\n\nNow I should tidy things up. Having “office” as part of the telephone number code\n\nmakes no sense, so I rename them.\n\nwww.EBooksWorld.ir",
      "content_length": 992,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 212,
      "content": "class TelephoneNumber…\n\nClick here to view code image\n\nget areaCode() {return this._areaCode;} set areaCode(arg) {this._areaCode = arg;}\n\nget number() {return this._number;} set number(arg) {this._number = arg;}\n\nclass Person…\n\nClick here to view code image\n\nget officeAreaCode() {return this._telephoneNumber.areaCode;} set officeAreaCode(arg) {this._telephoneNumber.areaCode = arg;} get officeNumber() {return this._telephoneNumber.number;} set officeNumber(arg) {this._telephoneNumber.number = arg;}\n\nThe telephone number method on the telephone number class also doesn’t make much\n\nsense, so I apply Rename Function (124).\n\nclass TelephoneNumber…\n\nClick here to view code image\n\ntoString() {return `(${this.areaCode}) ${this.number}`;}\n\nclass Person…\n\nClick here to view code image\n\nget telephoneNumber() {return this._telephoneNumber.toString();}\n\nTelephone numbers are generally useful, so I think I’ll expose the new object to clients.\n\nI can replace those “office” methods with accessors for the telephone number. But this\n\nway, the telephone number will work better as a Value Object [mf­vo], so I would apply\n\nChange Reference to Value (252) first (that refactoring’s example shows how I’d do that\n\nfor the telephone number).\n\nINLINE CLASS\n\nwww.EBooksWorld.ir",
      "content_length": 1269,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 213,
      "content": "inverse of: Extract Class (182)\n\nMotivation\n\nInline Class is the inverse of Extract Class (182). I use Inline Class if a class is no longer\n\npulling its weight and shouldn’t be around any more. Often, this is the result of\n\nrefactoring that moves other responsibilities out of the class so there is little left. At that\n\npoint, I fold the class into another—one that makes most use of the runt class.\n\nAnother reason to use Inline Class is if I have two classes that I want to refactor into a\n\npair of classes with a different allocation of features. I may find it easier to first use\n\nInline Class to combine them into a single class, then Extract Class (182) to make the\n\nnew separation. This is a general approach when reorganizing things: Sometimes, it’s\n\neasier to move elements one at a time from one context to another, but sometimes it’s\n\nbetter to use an inline refactoring to collapse the contexts together, then use an extract\n\nrefactoring to separate them into different elements.\n\nMechanics\n\nIn the target class, create functions for all the public functions of the source class.\n\nThese functions should just delegate to the source class.\n\nChange all references to source class methods so they use the target class’s\n\ndelegators instead. Test after each change.\n\nwww.EBooksWorld.ir",
      "content_length": 1294,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 214,
      "content": "Move all the functions and data from the source class into the target, testing after\n\neach move, until the source class is empty.\n\nDelete the source class and hold a short, simple funeral service.\n\nExample\n\nHere’s a class that holds a couple of pieces of tracking information for a shipment.\n\nClick here to view code image\n\nclass TrackingInformation { get shippingCompany() {return this._shippingCompany;} set shippingCompany(arg) {this._shippingCompany = arg;} get trackingNumber() {return this._trackingNumber;} set trackingNumber(arg) {this._trackingNumber = arg;} get display() { return `${this.shippingCompany}: ${this.trackingNumber}`; } }\n\nIt’s used as part of a shipment class.\n\nclass Shipment…\n\nClick here to view code image\n\nget trackingInfo() { return this._trackingInformation.display; } get trackingInformation() {return this._trackingInformation;} set trackingInformation(aTrackingInformation) { this._trackingInformation = aTrackingInformation; }\n\nWhile this class may have been worthwhile in the past, I no longer feel it’s pulling its\n\nweight, so I want to inline it into Shipment.\n\nI start by looking at places that are invoking the methods of TrackingInformation.\n\ncaller…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1242,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 215,
      "content": "aShipment.trackingInformation.shippingCompany = request.vendor;\n\nI’m going to move all such functions to Shipment, but I do it slightly differently to how\n\nI usually do Move Function (198). In this case, I start by putting a delegating method\n\ninto the shipment, and adjusting the client to call that.\n\nclass Shipment…\n\nClick here to view code image\n\nset shippingCompany(arg) {this._trackingInformation.shippingCompany = arg;}\n\ncaller…\n\nClick here to view code image\n\naShipment.trackingInformation.shippingCompany = request.vendor;\n\nI do this for all the elements of tracking information that are used by clients. Once I’ve\n\ndone that, I can move all the elements of the tracking information over into the\n\nshipment class.\n\nI start by applying Inline Function (115) to the display method.\n\nclass Shipment…\n\nClick here to view code image\n\nget trackingInfo() { return `${this.shippingCompany}: ${this.trackingNumber}`; }\n\nI move the shipping company field.\n\nClick here to view code image\n\nget shippingCompany() {return this._trackingInformation._shippingCompany;} set shippingCompany(arg) {this._trackingInformation._shippingCompany = arg;}\n\nwww.EBooksWorld.ir",
      "content_length": 1158,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 216,
      "content": "I don’t use the full mechanics for Move Field (207) since in this case I only reference\n\nshippingCompany from Shipment which is the target of the move. I thus don’t need\n\nthe steps that put a reference from the source to the target.\n\nI continue until everything is moved over. Once I’ve done that, I can delete the tracking\n\ninformation class.\n\nclass Shipment…\n\nClick here to view code image\n\nget trackingInfo() { return `${this.shippingCompany}: ${this.trackingNumber}`; } get shippingCompany() {return this._shippingCompany;} set shippingCompany(arg) {this._shippingCompany = arg;} get trackingNumber() {return this._trackingNumber;} set trackingNumber(arg) {this._trackingNumber = arg;}\n\nHIDE DELEGATE\n\ninverse of: Remove Middle Man (192)\n\nMotivation\n\nOne of the keys—if not the key—to good modular design is encapsulation.\n\nwww.EBooksWorld.ir",
      "content_length": 846,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 217,
      "content": "Encapsulation means that modules need to know less about other parts of the system.\n\nThen, when things change, fewer modules need to be told about the change—which\n\nmakes the change easier to make.\n\nWhen we are first taught about object orientation, we are told that encapsulation means\n\nhiding our fields. As we become more sophisticated, we realize there is more that we\n\ncan encapsulate.\n\nIf I have some client code that calls a method defined on an object in a field of a server\n\nobject, the client needs to know about this delegate object. If the delegate changes its\n\ninterface, changes propagate to all the clients of the server that use the delegate. I can\n\nremove this dependency by placing a simple delegating method on the server that hides\n\nthe delegate. Then any changes I make to the delegate propagate only to the server and\n\nnot to the clients.\n\nMechanics\n\nFor each method on the delegate, create a simple delegating method on the server.\n\nAdjust the client to call the server. Test after each change.\n\nIf no client needs to access the delegate anymore, remove the server’s accessor for\n\nthe delegate.\n\nTest.\n\nExample\n\nI start with a person and a department.\n\nclass Person…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1240,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 218,
      "content": "constructor(name) { this._name = name; } get name() {return this._name;} get department() {return this._department;} set department(arg) {this._department = arg;}\n\nclass Department…\n\nClick here to view code image\n\nget chargeCode() {return this._chargeCode;} set chargeCode(arg) {this._chargeCode = arg;} get manager() {return this._manager;} set manager(arg) {this._manager = arg;}\n\nSome client code wants to know the manager of a person. To do this, it needs to get the\n\ndepartment first.\n\nclient code…\n\nClick here to view code image\n\nmanager = aPerson.department.manager;\n\nThis reveals to the client how the department class works and that the department is\n\nresponsible for tracking the manager. I can reduce this coupling by hiding the\n\ndepartment class from the client. I do this by creating a simple delegating method on\n\nperson:\n\nclass Person…\n\nClick here to view code image\n\nget manager() {return this._department.manager;}\n\nI now need to change all clients of person to use this new method:\n\nclient code…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1064,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 219,
      "content": "manager = aPerson.department.manager;\n\nOnce I’ve made the change for all methods of department and for all the clients of\n\nperson, I can remove the department accessor on person.\n\nREMOVE MIDDLE MAN\n\ninverse of: Hide Delegate (189)\n\nMotivation\n\nIn the motivation for Hide Delegate (189), I talked about the advantages of\n\nencapsulating the use of a delegated object. There is a price for this. Every time the\n\nclient wants to use a new feature of the delegate, I have to add a simple delegating\n\nmethod to the server. After adding features for a while, I get irritated with all this\n\nforwarding. The server class is just a middle man (Middle Man (81)), and perhaps it’s\n\ntime for the client to call the delegate directly. (This smell often pops up when people\n\nget overenthusiastic about following the Law of Demeter, which I’d like a lot more if it\n\nwere called the Occasionally Useful Suggestion of Demeter.)\n\nIt’s hard to figure out what the right amount of hiding is. Fortunately, with Hide\n\nDelegate (189) and Remove Middle Man, it doesn’t matter so much. I can adjust my\n\ncode as time goes on. As the system changes, the basis for how much I hide also\n\nchanges. A good encapsulation six months ago may be awkward now. Refactoring www.EBooksWorld.ir",
      "content_length": 1253,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 220,
      "content": "means I never have to say I’m sorry—I just fix it.\n\nMechanics\n\nCreate a getter for the delegate.\n\nFor each client use of a delegating method, replace the call to the delegating method\n\nby chaining through the accessor. Test after each replacement.\n\nIf all calls to a delegating method are replaced, you can delete the delegating\n\nmethod.\n\nWith automated refactorings, you can use Encapsulate Variable (132) on the\n\ndelegate field and then Inline Function (115) on all the methods that use it.\n\nExample\n\nI begin with a person class that uses a linked department object to determine a\n\nmanager. (If you’re reading this book sequentially, this example may look eerily\n\nfamiliar.)\n\nclient code…\n\nmanager = aPerson.manager;\n\nclass Person…\n\nClick here to view code image\n\nget manager() {return this._department.manager;}\n\nclass Department…\n\nClick here to view code image\n\nget manager() {return this._manager;}\n\nThis is simple to use and encapsulates the department. However, if lots of methods are\n\ndoing this, I end up with too many of these simple delegations on the person. That’s\n\nwhen it is good to remove the middle man. First, I make an accessor for the delegate:\n\nwww.EBooksWorld.ir",
      "content_length": 1184,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 221,
      "content": "class Person…\n\nClick here to view code image\n\nget department() {return this._department;}\n\nNow I go to each client at a time and modify them to use the department directly.\n\nclient code…\n\nClick here to view code image\n\nmanager = aPerson.department.manager;\n\nOnce I’ve done this with all the clients, I can remove the manager method from\n\nPerson. I can repeat this process for any other simple delegations on Person.\n\nI can do a mixture here. Some delegations may be so common that I’d like to keep them\n\nto make client code easier to work with. There is no absolute reason why I should either\n\nhide a delegate or remove a middle man—particular circumstances suggest which\n\napproach to take, and reasonable people can differ on what works best.\n\nIf I have automated refactorings, then there’s a useful variation on these steps. First, I\n\nuse Encapsulate Variable (132) on department. This changes the manager getter to\n\nuse the public department getter:\n\nclass Person…\n\nClick here to view code image\n\nget manager() {return this.department.manager;}\n\nThe change is rather too subtle in JavaScript, but by removing the underscore from\n\ndepartment I’m using the new getter rather than accessing the field directly.\n\nThen I apply Inline Function (115) on the manager method to replace all the callers at\n\nonce.\n\nSUBSTITUTE ALGORITHM\n\nwww.EBooksWorld.ir",
      "content_length": 1347,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 222,
      "content": "Motivation\n\nI’ve never tried to skin a cat. I’m told there are several ways to do it. I’m sure some are\n\neasier than others. So it is with algorithms. If I find a clearer way to do something, I\n\nreplace the complicated way with the clearer way. Refactoring can break down\n\nsomething complex into simpler pieces, but sometimes I just reach the point at which I\n\nhave to remove the whole algorithm and replace it with something simpler. This occurs\n\nas I learn more about the problem and realize that there’s an easier way to do it. It also\n\nhappens if I start using a library that supplies features that duplicate my code.\n\nSometimes, when I want to change the algorithm to work slightly differently, it’s easier\n\nto start by replacing it with something that would make my change more\n\nstraightforward to make.\n\nWhen I have to take this step, I have to be sure I’ve decomposed the method as much as\n\nI can. Replacing a large, complex algorithm is very difficult; only by making it simple\n\ncan I make the substitution tractable.\n\nwww.EBooksWorld.ir\n\nMechanics",
      "content_length": 1057,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 223,
      "content": "Mechanics\n\nArrange the code to be replaced so that it fills a complete function.\n\nPrepare tests using this function only, to capture its behavior.\n\nPrepare your alternative algorithm.\n\nRun static checks.\n\nRun tests to compare the output of the old algorithm to the new one. If they are the\n\nsame, you’re done. Otherwise, use the old algorithm for comparison in testing and\n\ndebugging.\n\nwww.EBooksWorld.ir",
      "content_length": 404,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 224,
      "content": "Chapter 8 Moving Features\n\nHistory\n\nTopics\n\nSo far, the refactorings have been about creating, removing, and renaming program\n\nelements. Another important part of refactoring is moving elements between contexts. I\n\nTutorials\n\nuse Move Function (198) to move functions between classes and other modules. Fields\n\ncan move too, with Move Field (207).\n\nOffers & Deals\n\nI also move individual statements around. I use Move Statements into Function (213)\n\nHighlights\n\nand Move Statements to Callers (217) to move them in or out of functions, as well as\n\nSlide Statements (223) to move them within a function. Sometimes, I can take some\n\nSettings\n\nstatements that match an existing function and use Replace Inline Code with Function\n\nSupport\n\nCall (222) to remove the duplication.\n\nSign Out\n\nTwo refactorings I often do with loops are Split Loop (227), to ensure a loop does only\n\none thing, and Replace Loop with Pipeline (231) to get rid of a loop entirely.\n\nAnd then there’s the favorite refactoring of many a fine programmer: Remove Dead\n\nCode (237). Nothing is as satisfying as applying the digital flamethrower to superfluous\n\nstatements.\n\nMOVE FUNCTION\n\nformerly: Move Method\n\nwww.EBooksWorld.ir",
      "content_length": 1195,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 225,
      "content": "Motivation\n\nThe heart of a good software design is its modularity—which is my ability to make most\n\nmodifications to a program while only having to understand a small part of it. To get\n\nthis modularity, I need to ensure that related software elements are grouped together\n\nand the links between them are easy to find and understand. But my understanding of\n\nhow to do this isn’t static—as I better understand what I’m doing, I learn how to best\n\ngroup together software elements. To reflect that growing understanding, I need to\n\nmove elements around.\n\nAll functions live in some context; it may be global, but usually it’s some form of a\n\nmodule. In an object­oriented program, the core modular context is a class. Nesting a\n\nfunction within another creates another common context. Different languages provide\n\nvaried forms of modularity, each creating a context for a function to live in.\n\nOne of the most straightforward reasons to move a function is when it references\n\nelements in other contexts more than the one it currently resides in. Moving it together\n\nwith those elements often improves encapsulation, allowing other parts of the software\n\nto be less dependent on the details of this module.\n\nSimilarly, I may move a function because of where its callers live, or where I need to call\n\nit from in my next enhancement. A function defined as a helper inside another function\n\nmay have value on its own, so it’s worth moving it to somewhere more accessible. A\n\nmethod on a class may be easier for me to use if shifted to another.\n\nDeciding to move a function is rarely an easy decision. To help me decide, I examine the\n\ncurrent and candidate contexts for that function. I need to look at what functions call\n\nthis one, what functions are called by the moving function, and what data that function\n\nuses. Often, I see that I need a new context for a group of functions and create one with\n\nCombine Functions into Class (144) or Extract Class (182). Although it can be difficult\n\nwww.EBooksWorld.ir",
      "content_length": 2007,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 226,
      "content": "to decide where the best place for a function is, the more difficult this choice, often the\n\nless it matters. I find it valuable to try working with functions in one context, knowing\n\nI’ll learn how well they fit, and if they don’t fit I can always move them later.\n\nMechanics\n\nExamine all the program elements used by the chosen function in its current\n\ncontext. Consider whether they should move too.\n\nIf I find a called function that should also move, I usually move it first. That way,\n\nmoving a clusters of functions begins with the one that has the least dependency on\n\nthe others in the group.\n\nIf a high­level function is the only caller of subfunctions, then you can inline those\n\nfunctions into the high­level method, move, and reextract at the destination.\n\nCheck if the chosen function is a polymorphic method.\n\nIf I’m in an object­oriented language, I have to take account of super­ and subclass\n\ndeclarations.\n\nCopy the function to the target context. Adjust it to fit in its new home.\n\nIf the body uses elements in the source context, I need to either pass those elements\n\nas parameters or pass a reference to that source context.\n\nMoving a function often means I need to come up with a different name that works\n\nbetter in the new context.\n\nPerform static analysis.\n\nFigure out how to reference the target function from the source context.\n\nTurn the source function into a delegating function.\n\nTest.\n\nConsider Inline Function (115) on the source function.\n\nThe source function can stay indefinitely as a delegating function. But if its callers\n\ncan just as easily reach the target directly, then it’s better to remove the middle\n\nman.\n\nwww.EBooksWorld.ir\n\nExample: Moving a Nested Function to Top Level",
      "content_length": 1719,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 227,
      "content": "Example: Moving a Nested Function to Top Level\n\nI’ll begin with a function that calculates the total distance for a GPS track record.\n\nClick here to view code image\n\nfunction trackSummary(points) { const totalTime = calculateTime(); const totalDistance = calculateDistance(); const pace = totalTime / 60 / totalDistance ; return { time: totalTime, distance: totalDistance, pace: pace };\n\nfunction calculateDistance() { let result = 0; for (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result; }\n\nfunction distance(p1,p2) { ... } function radians(degrees) { ... } function calculateTime() { ... }\n\n}\n\nI’d like to move calculateDistance to the top level so I can calculate distances for\n\ntracks without all the other parts of the summary.\n\nI begin by copying the function to the top level.\n\nClick here to view code image\n\nfunction trackSummary(points) { const totalTime = calculateTime(); const totalDistance = calculateDistance(); const pace = totalTime / 60 / totalDistance ; return { time: totalTime, distance: totalDistance, pace: pace };\n\nfunction calculateDistance() { let result = 0;\n\nwww.EBooksWorld.ir",
      "content_length": 1153,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 228,
      "content": "for (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result; } ...\n\nfunction distance(p1,p2) { ... } function radians(degrees) { ... } function calculateTime() { ... }\n\n}\n\nfunction top_calculateDistance() { let result = 0; for (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result; }\n\nWhen I copy a function like this, I like to change the name so I can distinguish them\n\nboth in the code and in my head. I don’t want to think about what the right name\n\nshould be right now, so I create a temporary name.\n\nThe program still works, but my static analysis is rightly rather upset. The new function\n\nhas two undefined symbols: distance and points. The natural way to deal with\n\npoints is to pass it in as a parameter.\n\nClick here to view code image\n\nfunction top_calculateDistance(points) { let result = 0; for (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result; }\n\nI could do the same with distance, but perhaps it makes sense to move it together\n\nwith calculateDistance. Here’s the relevant code:\n\nfunction trackSummary…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1203,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 229,
      "content": "function distance(p1,p2) { // haversine formula see http://www.movable­type.co.uk/scripts/latlong.html const EARTH_RADIUS = 3959; // in miles const dLat = radians(p2.lat) ­ radians(p1.lat); const dLon = radians(p2.lon) ­ radians(p1.lon); const a = Math.pow(Math.sin(dLat / 2),2) + Math.cos(radians(p2.lat)) * Math.cos(radians(p1.lat)) * Math.pow(Math.sin(dLon / 2), 2); const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1­a)); return EARTH_RADIUS * c; } function radians(degrees) { return degrees * Math.PI / 180; }\n\nI can see that distance only uses radians and radians doesn’t use anything inside\n\nits current context. So rather than pass the functions, I might as well move them too. I\n\ncan make a small step in this direction by moving them from their current context to\n\nnest them inside the nested calculateDistance.\n\nClick here to view code image\n\nfunction trackSummary(points) { const totalTime = calculateTime(); const totalDistance = calculateDistance(); const pace = totalTime / 60 / totalDistance ; return { time: totalTime, distance: totalDistance, pace: pace };\n\nfunction calculateDistance() { let result = 0; for (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result;\n\nfunction distance(p1,p2) { ... } function radians(degrees) { ... } }\n\nBy doing this, I can use both static analysis and testing to tell me if there are any\n\ncomplications. In this case all is well, so I can copy them over to\n\ntop_calculateDistance.\n\nwww.EBooksWorld.ir",
      "content_length": 1495,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 230,
      "content": "Click here to view code image\n\nfunction top_calculateDistance(points) { let result = 0; for (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result;\n\nfunction distance(p1,p2) { ... } function radians(degrees) { ... }\n\n}\n\nAgain, the copy doesn’t change how the program runs, but does give me an opportunity\n\nfor more static analysis. Had I not spotted that distance calls radians, the linter\n\nwould have caught it at this step.\n\nNow that I have prepared the table, it’s time for the major change—the body of the\n\noriginal calculateDistance will now call top_calculateDistance:\n\nClick here to view code image\n\nfunction trackSummary(points) { const totalTime = calculateTime(); const totalDistance = calculateDistance(); const pace = totalTime / 60 / totalDistance ; return { time: totalTime, distance: totalDistance, pace: pace };\n\nfunction calculateDistance() { return top_calculateDistance(points); }\n\nThis is the crucial time to run tests to fully test that the moved function has bedded\n\ndown in its new home.\n\nWith that done, it’s like unpacking the boxes after moving house. The first thing is to\n\ndecide whether to keep the original function that’s just delegating or not. In this case,\n\nthere are few callers and, as usual with nested functions, they are highly localized. So\n\nI’m happy to get rid of it.\n\nwww.EBooksWorld.ir",
      "content_length": 1372,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 231,
      "content": "Click here to view code image\n\nfunction trackSummary(points) { const totalTime = calculateTime(); const totalDistance = top_calculateDistance(points); const pace = totalTime / 60 / totalDistance ; return { time: totalTime, distance: totalDistance, pace: pace };\n\nNow is also a good time to think about what I want the name to be. Since the top­level\n\nfunction has the highest visibility, I’d like it to have the best name. totalDistance\n\nseems like a good choice. I can’t use that immediately since it will be shadowed by the\n\nvariable inside trackSummary—but I don’t see any reason to keep that anyway, so I\n\nuse Inline Variable (123) on it.\n\nClick here to view code image\n\nfunction trackSummary(points) { const totalTime = calculateTime(); const pace = totalTime / 60 / totalDistance(points) ; return { time: totalTime, distance: totalDistance(points), pace: pace }; function totalDistance(points) { let result = 0; for (let i = 1; i < points.length; i++) { result += distance(points[i­1], points[i]); } return result;\n\nIf I’d had the need to keep the variable, I’d have renamed it to something like\n\ntotalDistanceCache or distance.\n\nSince the functions for distance and radians don’t depend on anything inside\n\ntotalDistance, I prefer to move them to top level too, putting all four functions at\n\nthe top level.\n\nClick here to view code image\n\nfunction trackSummary(points) { ... }\n\nwww.EBooksWorld.ir",
      "content_length": 1404,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 232,
      "content": "function totalDistance(points) { ... } function distance(p1,p2) { ... } function radians(degrees) { ... }\n\nSome people would prefer to keep distance and radians inside totalDistance in\n\norder to restrict their visibility. In some languages that may be a consideration, but with\n\nES 2015, JavaScript has an excellent module mechanism that’s the best tool for\n\ncontrolling function visibility. In general, I’m wary of nested functions—they too easily\n\nset up hidden data interrelationships that can get hard to follow.\n\nExample: Moving between Classes\n\nTo illustrate this variety of Move Function, I’ll start here:\n\nclass Account…\n\nClick here to view code image\n\nget bankCharge() { let result = 4.5; if (this._daysOverdrawn > 0) result += this.overdraftCharge; return result; }\n\nget overdraftCharge() { if (this.type.isPremium) { const baseCharge = 10; if (this.daysOverdrawn <= 7) return baseCharge; else return baseCharge + (this.daysOverdrawn ­ 7) * 0.85; } else return this.daysOverdrawn * 1.75; }\n\nComing up are changes that lead to different types of account having different\n\nalgorithms for determining the charge. Thus it seems natural to move\n\noverdraftCharge to the account type class.\n\nThe first step is to look at the features that the overdraftCharge method uses and\n\nconsider whether it is worth moving a batch of methods together. In this case I need the\n\ndaysOverdrawn method to remain on the account class, because that will vary with\n\nindividual accounts.\n\nwww.EBooksWorld.ir",
      "content_length": 1491,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 233,
      "content": "Next, I copy the method body over to the account type and get it to fit.\n\nclass AccountType…\n\nClick here to view code image\n\noverdraftCharge(daysOverdrawn) { if (this.isPremium) { const baseCharge = 10; if (daysOverdrawn <= 7) return baseCharge; else return baseCharge + (daysOverdrawn ­ 7) * 0.85; } else return daysOverdrawn * 1.75; }\n\nIn order to get the method to fit in its new location, I need to deal with two call targets\n\nthat change their scope. isPremium is now a simple call on this. With\n\ndaysOverdrawn I have to decide—do I pass the value or do I pass the account? For the\n\nmoment, I just pass the simple value but I may well change this in the future if I require\n\nmore than just the days overdrawn from the account—especially if what I want from the\n\naccount varies with the account type.\n\nNext, I replace the original method body with a delegating call.\n\nclass Account…\n\nClick here to view code image\n\nget bankCharge() { let result = 4.5; if (this._daysOverdrawn > 0) result += this.overdraftCharge; return result; }\n\nget overdraftCharge() { return this.type.overdraftCharge(this.daysOverdrawn); }\n\nThen comes the decision of whether to leave the delegation in place or to inline\n\noverdraftCharge. Inlining results in:\n\nclass Account…\n\nwww.EBooksWorld.ir",
      "content_length": 1271,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 234,
      "content": "Click here to view code image\n\nget bankCharge() { let result = 4.5; if (this._daysOverdrawn > 0) result += this.type.overdraftCharge(this.daysOverdrawn); return result; }\n\nIn the earlier steps, I passed daysOverdrawn as a parameter—but if there’s a lot of\n\ndata from the account to pass, I might prefer to pass the account itself.\n\nclass Account…\n\nClick here to view code image\n\nget bankCharge() { let result = 4.5; if (this._daysOverdrawn > 0) result += this.overdraftCharge; return result; }\n\nget overdraftCharge() { return this.type.overdraftCharge(this); }\n\nclass AccountType…\n\nClick here to view code image\n\noverdraftCharge(account) { if (this.isPremium) { const baseCharge = 10; if (account.day>sOverdrawn <= 7) return baseCharge; else return baseCharge + (account.daysOverdrawn ­ 7) * 0.85; } else return account.daysOverdrawn * 1.75; }\n\nMOVE FIELD\n\nwww.EBooksWorld.ir",
      "content_length": 875,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 235,
      "content": "Motivation\n\nProgramming involves writing a lot of code that implements behavior—but the strength\n\nof a program is really founded on its data structures. If I have a good set of data\n\nstructures that match the problem, then my behavior code is simple and\n\nstraightforward. But poor data structures lead to lots of code whose job is merely\n\ndealing with the poor data. And it’s not just messier code that’s harder to understand; it\n\nalso means the data structures obscure what the program is doing.\n\nSo, data structures are important—but like most aspects of programming they are hard\n\nto get right. I do make an initial analysis to figure out the best data structures, and I’ve\n\nfound that experience and techniques like domain­driven design have improved my\n\nability to do that. But despite all my skill and experience, I still find that I frequently\n\nmake mistakes in that initial design. In the process of programming, I learn more about\n\nthe problem domain and my data structures. A design decision that is reasonable and\n\ncorrect one week can become wrong in another.\n\nAs soon as I realize that a data structure isn’t right, it’s vital to change it. If I leave my\n\ndata structures with their blemishes, those blemishes will confuse my thinking and\n\ncomplicate my code far into the future.\n\nI may seek to move data because I find I always need to pass a field from one record\n\nwhenever I pass another record to a function. Pieces of data that are always passed to\n\nfunctions together are usually best put in a single record in order to clarify their\n\nrelationship. Change is also a factor; if a change in one record causes a field in another\n\nrecord to change too, that’s a sign of a field in the wrong place. If I have to update the\n\nsame field in multiple structures, that’s a sign that it should move to another place\n\nwhere it only needs to be updated once.\n\nwww.EBooksWorld.ir",
      "content_length": 1884,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 236,
      "content": "I usually do Move Field in the context of a broader set of changes. Once I’ve moved a\n\nfield, I find that many of the users of the field are better off accessing that data through\n\nthe target object rather than the original source. I then change these with later\n\nrefactorings. Similarly, I may find that I can’t do Move Field at the moment due to the\n\nway the data is used. I need to refactor some usage patterns first, then do the move.\n\nIn my description so far, I’m saying “record,” but all this is true of classes and objects\n\ntoo. A class is a record type with attached functions—and these need to be kept healthy\n\njust as much as any other data. The attached functions do make it easier to move data\n\naround, since the data is encapsulated behind accessor methods. I can move the data,\n\nchange the accessors, and clients of the accessors will still work. So, this is a refactoring\n\nthat’s easier to do if you have classes, and my description below makes that assumption.\n\nIf I’m using bare records that don’t support encapsulation, I can still make a change like\n\nthis, but it is more tricky.\n\nMechanics\n\nEnsure the source field is encapsulated.\n\nTest.\n\nCreate a field (and accessors) in the target.\n\nRun static checks.\n\nEnsure there is a reference from the source object to the target object.\n\nAn existing field or method may give you the target. If not, see if you can easily\n\ncreate a method that will do so. Failing that, you may need to create a new field in\n\nthe source object that can store the target. This may be a permanent change, but you\n\ncan also do it temporarily until you have done enough refactoring in the broader\n\ncontext.\n\nAdjust accessors to use the target field.\n\nIf the target is shared between source objects, consider first updating the setter to\n\nmodify both target and source fields, followed by Introduce Assertion (302) to\n\ndetect inconsistent updates. Once you determine all is well, finish changing the\n\naccessors to use the target field.\n\nTest.\n\nwww.EBooksWorld.ir",
      "content_length": 2003,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 237,
      "content": "Remove the source field.\n\nTest.\n\nExample\n\nI’m starting here with this customer and contract:\n\nclass Customer…\n\nClick here to view code image\n\nconstructor(name, discountRate) { this._name = name; this._discountRate = discountRate; this._contract = new CustomerContract(dateToday()); } get discountRate() {return this._discountRate;} becomePreferred() { this._discountRate += 0.03; // other nice things } applyDiscount(amount) { return amount.subtract(amount.multiply(this._discountRate)); }\n\nclass CustomerContract…\n\nClick here to view code image\n\nconstructor(startDate) { this._startDate = startDate; }\n\nI want to move the discount rate field from the customer to the customer contract.\n\nThe first thing I need to use is Encapsulate Variable (132) to encapsulate access to the\n\ndiscount rate field.\n\nclass Customer…\n\nClick here to view code image\n\nconstructor(name, discountRate) { this._name = name;\n\nwww.EBooksWorld.ir",
      "content_length": 920,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 238,
      "content": "this._setDiscountRate(discountRate); this._contract = new CustomerContract(dateToday()); } get discountRate() {return this._discountRate;} _setDiscountRate(aNumber) {this._discountRate = aNumber;} becomePreferred() { this._setDiscountRate(this.discountRate + 0.03); // other nice things } applyDiscount(amount) { return amount.subtract(amount.multiply(this.discountRate)); }\n\nI use a method to update the discount rate, rather than a property setter, as I don’t want\n\nto make a public setter for the discount rate.\n\nI add a field and accessors to the customer contract.\n\nclass CustomerContract…\n\nClick here to view code image\n\nconstructor(startDate, discountRate) { this._startDate = startDate; this._discountRate = discountRate; } get discountRate() {return this._discountRate;} set discountRate(arg) {this._discountRate = arg;}\n\nI now modify the accessors on customer to use the new field. When I did that, I got an\n\nerror: “Cannot set property ’discountRate’ of undefined”. This was because\n\n_setDiscountRate was called before I created the contract object in the constructor.\n\nTo fix that, I first reverted to the previous state, then used Slide Statements (223) to\n\nmove the _setDiscountRate after creating the contract.\n\nclass Customer…\n\nClick here to view code image\n\nconstructor(name, discountRate) { this._name = name; this._setDiscountRate(discountRate); this._contract = new CustomerContract(dateToday()); }\n\nwww.EBooksWorld.ir",
      "content_length": 1438,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 239,
      "content": "I tested that, then changed the accessors again to use the contract.\n\nclass Customer…\n\nClick here to view code image\n\nget discountRate() {return this._contract.discountRate;} _setDiscountRate(aNumber) {this._contract.discountRate = aNumber;}\n\nSince I’m using JavaScript, there is no declared source field, so I don’t need to remove\n\nanything further.\n\nChanging a Bare Record\n\nThis refactoring is generally easier with objects, since encapsulation provides a natural\n\nway to wrap data access in methods. If I have many functions accessing a bare record,\n\nthen, while it’s still a valuable refactoring, it is decidedly more tricky.\n\nI can create accessor functions and modify all the reads and writes to use them. If the\n\nfield that’s being moved is immutable, I can update both the source and the target fields\n\nwhen I set its value and gradually migrate reads. Still, if possible, my first move would\n\nbe to use Encapsulate Record (162) to turn the record into a class so I can make the\n\nchange more easily.\n\nExample: Moving to a Shared Object\n\nNow, let’s consider a different case. Here’s an account with an interest rate:\n\nclass Account…\n\nClick here to view code image\n\nconstructor(number, type, interestRate) { this._number = number; this._type = type; this._interestRate = interestRate; } get interestRate() {return this._interestRate;}\n\nclass AccountType…\n\nconstructor(nameString) { this._name = nameString;\n\nwww.EBooksWorld.ir",
      "content_length": 1432,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 240,
      "content": "}\n\nI want to change things so that an account’s interest rate is determined from its account\n\ntype.\n\nThe access to the interest rate is already nicely encapsulated, so I’ll just create the field\n\nand an appropriate accessor on the account type.\n\nclass AccountType…\n\nClick here to view code image\n\nconstructor(nameString, interestRate) { this._name = nameString; this._interestRate = interestRate; } get interestRate() {return this._interestRate;}\n\nBut there is a potential problem when I update the accesses from account. Before this\n\nrefactoring, each account had its own interest rate. Now, I want all accounts to share\n\nthe interest rates of their account type. If all the accounts of the same type already have\n\nthe same interest rate, then there’s no change in observable behavior, so I’m fine with\n\nthe refactoring. But if there’s an account with a different interest rate, it’s no longer a\n\nrefactoring. If my account data is held in a database, I should check the database to\n\nensure that all my accounts have the rate matching their type. I can also Introduce\n\nAssertion (302) in the account class.\n\nclass Account…\n\nClick here to view code image\n\nconstructor(number, type, interestRate) { this._number = number; this._type = type; assert(interestRate === this._type.interestRate); this._interestRate = interestRate; } get interestRate() {return this._interestRate;}\n\nI might run the system for a while with this assertion in place to see if I get an error. Or,\n\ninstead of adding an assertion, I might log the problem. Once I’m confident that I’m not\n\nintroducing an observable change, I can change the access, removing the update from\n\nwww.EBooksWorld.ir",
      "content_length": 1664,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 241,
      "content": "the account completely.\n\nclass Account…\n\nClick here to view code image\n\nconstructor(number, type) { this._number = number; this._type = type; } get interestRate() {return this._type.interestRate;}\n\nMOVE STATEMENTS INTO FUNCTION\n\ninverse of: Move Statements to Callers (217)\n\nwww.EBooksWorld.ir\n\nMotivation",
      "content_length": 305,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 242,
      "content": "Motivation\n\nRemoving duplication is one of the best rules of thumb of healthy code. If I see the\n\nsame code executed every time I call a particular function, I look to combine that\n\nrepeating code into the function itself. That way, any future modifications to the\n\nrepeating code can be done in one place and used by all the callers. Should the code\n\nvary in the future, I can easily move it (or some of it) out again with Move Statements\n\nto Callers (217).\n\nI move statements into a function when I can best understand these statements as part\n\nof the called function. If they don’t make sense as part of the called function, but still\n\nshould be called with it, I’ll simply use Extract Function (106) on the statements and\n\nthe called function. That’s essentially the same process as I describe below, but without\n\nthe inline and rename steps. It’s not unusual to do that and then, after later reflection,\n\ncarry out those final steps.\n\nMechanics\n\nIf the repetitive code isn’t adjacent to the call of the target function, use Slide\n\nStatements (223) to get it adjacent.\n\nIf the target function is only called by the source function, just cut the code from the\n\nsource, paste it into the target, test, and ignore the rest of these mechanics.\n\nIf you have more callers, use Extract Function (106) on one of the call sites to\n\nextract both the call to the target function and the statements you wish to move into\n\nit. Give it a name that’s transient, but easy to grep.\n\nConvert every other call to use the new function. Test after each conversion.\n\nWhen all the original calls use the new function, use Inline Function (115) to inline\n\nthe original function completely into the new function, removing the original\n\nfunction.\n\nRename Function (124) to change the name of the new function to the same name\n\nas the original function.\n\nOr to a better name, if there is one.\n\nExample\n\nI’ll start with this code to emit HTML for data about a photo:\n\nwww.EBooksWorld.ir",
      "content_length": 1962,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 243,
      "content": "Click here to view code image\n\nfunction renderPerson(outStream, person) { const result = []; result.push(`<p>${person.name}</p>`); result.push(renderPhoto(person.photo)); result.push(`<p>title: ${person.photo.title}</p>`); result.push(emitPhotoData(person.photo)); return result.join(\"\\n\"); }\n\nfunction photoDiv(p) { return [ \"<div>\", `<p>title: ${p.title}</p>`, emitPhotoData(p), \"</div>\", ].join(\"\\n\"); }\n\nfunction emitPhotoData(aPhoto) { const result = []; result.push(`<p>location: ${aPhoto.location}</p>`); result.push(`<p>date: ${aPhoto.date.toDateString()}</p>`); return result.join(\"\\n\"); }\n\nThis code shows two calls to emitPhotoData, each preceded by a line of code that is\n\nsemantically equivalent. I’d like to remove this duplication by moving the title printing\n\ninto emitPhotoData. If I had just the one caller, I would just cut and paste the code,\n\nbut the more callers I have, the more I’m inclined to use a safer procedure.\n\nI begin by using Extract Function (106) on one of the callers. I’m extracting the\n\nstatements I want to move into emitPhotoData, together with the call to\n\nemitPhotoData itself.\n\nClick here to view code image\n\nfunction photoDiv(p) { return [ \"<div>\", zznew(p), \"</div>\", ].join(\"\\n\"); }\n\nfunction zznew(p) { return [\n\nwww.EBooksWorld.ir",
      "content_length": 1278,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 244,
      "content": "`<p>title: ${p.title}</p>`, emitPhotoData(p), ].join(\"\\n\"); }\n\nI can now look at the other callers of emitPhotoData and, one by one, replace the\n\ncalls and the preceding statements with calls to the new function.\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { const result = []; result.push(`<p>${person.name}</p>`); result.push(renderPhoto(person.photo)); result.push(zznew(person.photo)); return result.join(\"\\n\"); }\n\nNow that I’ve done all the callers, I use Inline Function (115) on emitPhotoData:\n\nClick here to view code image\n\nfunction zznew(p) { return [ `<p>title: ${p.title}</p>`, `<p>location: ${p.location}</p>`, `<p>date: ${p.date.toDateString()}</p>`, ].join(\"\\n\"); }\n\nand finish with Rename Function (124):\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { const result = []; result.push(`<p>${person.name}</p>`); result.push(renderPhoto(person.photo)); result.push(emitPhotoData(person.photo)); return result.join(\"\\n\"); }\n\nfunction photoDiv(aPhoto) { return [ \"<div>\", emitPhotoData(aPhoto),\n\nwww.EBooksWorld.ir",
      "content_length": 1081,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 245,
      "content": "\"</div>\", ].join(\"\\n\"); }\n\nfunction emitPhotoData(aPhoto) { return [ `<p>title: ${aPhoto.title}</p>`, `<p>location: ${aPhoto.location}</p>`, `<p>date: ${aPhoto.date.toDateString()}</p>`, ].join(\"\\n\"); }\n\nI also make the parameter names fit my convention while I’m at it.\n\nMOVE STATEMENTS TO CALLERS\n\ninverse of: Move Statements into Function (213)\n\nMotivation\n\nFunctions are the basic building block of the abstractions we build as programmers.\n\nAnd, as with any abstraction, we don’t always get the boundaries right. As a code base\n\nchanges its capabilities—as most useful software does—we often find our abstraction\n\nwww.EBooksWorld.ir",
      "content_length": 637,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 246,
      "content": "boundaries shift. For functions, that means that what might once have been a cohesive,\n\natomic unit of behavior becomes a mix of two or more different things.\n\nOne trigger for this is when common behavior used in several places needs to vary in\n\nsome of its calls. Now, we need to move the varying behavior out of the function to its\n\ncallers. In this case, I’ll use Slide Statements (223) to get the varying behavior to the\n\nbeginning or end of the function and then Move Statements to Callers. Once the varying\n\ncode is in the caller, I can change it when necessary.\n\nMove Statements to Callers works well for small changes, but sometimes the\n\nboundaries between caller and callee need complete reworking. In that case, my best\n\nmove is to use Inline Function (115) and then slide and extract new functions to form\n\nbetter boundaries.\n\nMechanics\n\nIn simple circumstances, where you have only one or two callers and a simple\n\nfunction to call from, just cut the first line from the called function and paste (and\n\nperhaps fit) it into the callers. Test and you’re done.\n\nOtherwise, apply Extract Function (106) to all the statements that you don’t wish to\n\nmove; give it a temporary but easily searchable name.\n\nIf the function is a method that is overridden by subclasses, do the extraction on all\n\nof them so that the remaining method is identical in all classes. Then remove the\n\nsubclass methods.\n\nUse Inline Function (115) on the original function.\n\nApply Change Function Declaration (124) on the extracted function to rename it to\n\nthe original name.\n\nOr to a better name, if you can think of one.\n\nExample\n\nHere’s a simple case: a function with two callers.\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { outStream.write(`<p>${person.name}</p>\\n`);\n\nwww.EBooksWorld.ir",
      "content_length": 1804,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 247,
      "content": "renderPhoto(outStream, person.photo); emitPhotoData(outStream, person.photo); }\n\nfunction listRecentPhotos(outStream, photos) { photos .filter(p => p.date > recentDateCutoff()) .forEach(p => { outStream.write(\"<div>\\n\"); emitPhotoData(outStream, p); outStream.write(\"</div>\\n\"); }); }\n\nfunction emitPhotoData(outStream, photo) { outStream.write(`<p>title: ${photo.title}</p>\\n`); outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`); outStream.write(`<p>location: ${photo.location}</p>\\n`); }\n\nI need to modify the software so that listRecentPhotos renders the location\n\ninformation differently while renderPerson stays the same. To make this change\n\neasier, I’ll use Move Statements to Callers on the final line.\n\nUsually, when faced with something this simple, I’ll just cut the last line from\n\nrenderPerson and paste it below the two calls. But since I’m explaining what to do in\n\nmore tricky cases, I’ll go through the more elaborate but safer procedure.\n\nMy first step is to use Extract Function (106) on the code that will remain in\n\nemitPhotoData.\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { outStream.write(`<p>${person.name}</p>\\n`); renderPhoto(outStream, person.photo); emitPhotoData(outStream, person.photo); }\n\nfunction listRecentPhotos(outStream, photos) { photos .filter(p => p.date > recentDateCutoff()) .forEach(p => { outStream.write(\"<div>\\n\"); emitPhotoData(outStream, p); outStream.write(\"</div>\\n\"); }); }\n\nwww.EBooksWorld.ir",
      "content_length": 1488,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 248,
      "content": "function emitPhotoData(outStream, photo) { zztmp(outStream, photo); outStream.write(`<p>location: ${photo.location}</p>\\n`); }\n\nfunction zztmp(outStream, photo) { outStream.write(`<p>title: ${photo.title}</p>\\n`); outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`); }\n\nUsually, the name of the extracted function is only temporary, so I don’t worry about\n\ncoming up with anything meaningful. However, it is helpful to use something that’s\n\neasy to grep. I can test at this point to ensure the code works over the function call\n\nboundary.\n\nNow I use Inline Function (115), one call at a time. I start with renderPerson.\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { outStream.write(`<p>${person.name}</p>\\n`); renderPhoto(outStream, person.photo); zztmp(outStream, person.photo); outStream.write(`<p>location: ${person.photo.location}</p>\\n`); }\n\nfunction listRecentPhotos(outStream, photos) { photos .filter(p => p.date > recentDateCutoff()) .forEach(p => { outStream.write(\"<div>\\n\"); emitPhotoData(outStream, p); outStream.write(\"</div>\\n\"); }); }\n\nfunction emitPhotoData(outStream, photo) { zztmp(outStream, photo); outStream.write(`<p>location: ${photo.location}</p>\\n`); }\n\nfunction zztmp(outStream, photo) { outStream.write(`<p>title: ${photo.title}</p>\\n`); outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`); }\n\nI test again to ensure this call is working properly, then move onto the next.\n\nwww.EBooksWorld.ir",
      "content_length": 1471,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 249,
      "content": "Click here to view code image\n\nfunction renderPerson(outStream, person) { outStream.write(`<p>${person.name}</p>\\n`); renderPhoto(outStream, person.photo); zztmp(outStream, person.photo); outStream.write(`<p>location: ${person.photo.location}</p>\\n`); }\n\nfunction listRecentPhotos(outStream, photos) { photos .filter(p => p.date > recentDateCutoff()) .forEach(p => { outStream.write(\"<div>\\n\"); zztmp(outStream, p); outStream.write(`<p>location: ${p.location}</p>\\n`); outStream.write(\"</div>\\n\"); }); }\n\nfunction emitPhotoData(outStream, photo) { zztmp(outStream, photo); outStream.write(`<p>location: ${photo.location}</p>\\n`); }\n\nfunction zztmp(outStream, photo) { outStream.write(`<p>title: ${photo.title}</p>\\n`); outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`); }\n\nThen I can delete the outer function, completing Inline Function (115).\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { outStream.write(`<p>${person.name}</p>\\n`); renderPhoto(outStream, person.photo); zztmp(outStream, person.photo); outStream.write(`<p>location: ${person.photo.location}</p>\\n`); }\n\nfunction listRecentPhotos(outStream, photos) { photos .filter(p => p.date > recentDateCutoff()) .forEach(p => { outStream.write(\"<div>\\n\"); zztmp(outStream, p); outStream.write(`<p>location: ${p.location}</p>\\n`); outStream.write(\"</div>\\n\"); });\n\nwww.EBooksWorld.ir",
      "content_length": 1380,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 250,
      "content": "}\n\nfunction emitPhotoData(outStream, photo) { zztmp(outStream, photo); outStream.write(`<p>location: ${photo.location}</p>\\n`); }\n\nfunction zztmp(outStream, photo) { outStream.write(`<p>title: ${photo.title}</p>\\n`); outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`); }\n\nI then rename zztmp back to the original name.\n\nClick here to view code image\n\nfunction renderPerson(outStream, person) { outStream.write(`<p>${person.name}</p>\\n`); renderPhoto(outStream, person.photo); emitPhotoData(outStream, person.photo); outStream.write(`<p>location: ${person.photo.location}</p>\\n`); }\n\nfunction listRecentPhotos(outStream, photos) { photos .filter(p => p.date > recentDateCutoff()) .forEach(p => { outStream.write(\"<div>\\n\"); emitPhotoData(outStream, p); outStream.write(`<p>location: ${p.location}</p>\\n`); outStream.write(\"</div>\\n\"); }); }\n\nfunction emitPhotoData(outStream, photo) { outStream.write(`<p>title: ${photo.title}</p>\\n`); outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`); }\n\nREPLACE INLINE CODE WITH FUNCTION CALL\n\nwww.EBooksWorld.ir",
      "content_length": 1072,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 251,
      "content": "Motivation\n\nFunctions allow me to package up bits of behavior. This is useful for understanding—a\n\nnamed function can explain the purpose of the code rather than its mechanics. It’s also\n\nvaluable to remove duplication: Instead of writing the same code twice, I just call the\n\nfunction. Then, should I need to change the function’s implementation, I don’t have to\n\ntrack down similar­looking code to update all the changes. (I may have to look at the\n\ncallers, to see if they should all use the new code, but that’s both less common and\n\nmuch easier.)\n\nIf I see inline code that’s doing the same thing that I have in an existing function, I’ll\n\nusually want to replace that inline code with a function call. The exception is if I\n\nconsider the similarity to be coincidental—so that, if I change the function body, I don’t\n\nexpect the behavior in this inline code to change. A guide to this is the name of the\n\nfunction. A good name should make sense in place of inline code I have. If the name\n\ndoesn’t make sense, that may be because it’s a poor name (in which case I use Rename\n\nFunction (124) to fix it) or because the function’s purpose is different to what I want in\n\nthis case—so I shouldn’t call it.\n\nI find it particularly satisfying to do this with calls to library functions—that way, I don’t\n\neven have to write the function body.\n\nMechanics\n\nReplace the inline code with a call to the existing function.\n\nTest.\n\nwww.EBooksWorld.ir\n\nSLIDE STATEMENTS",
      "content_length": 1460,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 252,
      "content": "SLIDE STATEMENTS\n\nformerly: Consolidate Duplicate Conditional Fragments\n\nMotivation\n\nCode is easier to understand when things that are related to each other appear together.\n\nIf several lines of code access the same data structure, it’s best for them to be together\n\nrather than intermingled with code accessing other data structures. At its simplest, I\n\nuse Slide Statements to keep such code together. A very common case of this is\n\ndeclaring and using variables. Some people like to declare all their variables at the top\n\nof a function. I prefer to declare the variable just before I first use it.\n\nUsually, I move related code together as a preparatory step for another refactoring,\n\noften an Extract Function (106). Putting related code into a clearly separated function\n\nis a better separation than just moving a set of lines together, but I can’t do the Extract\n\nFunction (106) unless the code is together in the first place.\n\nMechanics\n\nIdentify the target position to move the fragment to. Examine statements between\n\nsource and target to see if there is interference for the candidate fragment. Abandon\n\naction if there is any interference.\n\nA fragment cannot slide backwards earlier than any element it references is\n\ndeclared.\n\nA fragment cannot slide forwards beyond any element that references it. www.EBooksWorld.ir",
      "content_length": 1331,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 253,
      "content": "A fragment cannot slide over any statement that modifies an element it references.\n\nA fragment that modifies an element cannot slide over any other element that\n\nreferences the modified element.\n\nCut the fragment from the source and paste into the target position.\n\nTest.\n\nIf the test fails, try breaking down the slide into smaller steps. Either slide over less\n\ncode or reduce the amount of code in the fragment you’re moving.\n\nExample\n\nWhen sliding code fragments, there are two decisions involved: what slide I’d like to do\n\nand whether I can do it. The first decision is very context­specific. On the simplest level,\n\nI like to declare elements close to where I use them, so I’ll often slide a declaration\n\ndown to its usage. But almost always I slide some code because I want to do another\n\nrefactoring—perhaps to get a clump of code together to Extract Function (106).\n\nOnce I have a sense of where I’d like to move some code, the next part is deciding if I\n\ncan do it. This involves looking at the code I’m sliding and the code I’m sliding over: Do\n\nthey interfere with each other in a way that would change the observable behavior of\n\nthe program?\n\nConsider the following fragment of code:\n\nClick here to view code image\n\n1 const pricingPlan = retrievePricingPlan(); 2 const order = retreiveOrder(); 3 const baseCharge = pricingPlan.base; 4 let charge; 5 const chargePerUnit = pricingPlan.unit; 6 const units = order.units; 7 let discount; 8 charge = baseCharge + units * chargePerUnit; 9 let discountableUnits = Math.max(units ­ pricingPlan.discountThreshold, 0); 10 discount = discountableUnits * pricingPlan.discountFactor; 11 if (order.isRepeat) discount += 20; 12 charge = charge ­ discount; 13 chargeOrder(charge);\n\nwww.EBooksWorld.ir",
      "content_length": 1749,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 254,
      "content": "The first seven lines are declarations, and it’s relatively easy to move these. For\n\nexample, I may want to move all the code dealing with discounts together, which would\n\ninvolve moving line 7 (`let discount`) to above line 10 (`discount = ...`).\n\nSince a declaration has no side effects and refers to no other variable, I can safely move\n\nthis forwards as far as the first line that references discount itself. This is also a\n\ncommon move—if I want to use Extract Function (106) on the discount logic, I’ll need\n\nto move the declaration down first.\n\nI do similar analysis with any code that doesn’t have side effects. So I can take line 2\n\n(`const order = ...`) and move it down to above line 6 (`const units =\n\n...`) without trouble.\n\nIn this case, I’m also helped by the fact that the code I’m moving over doesn’t have side\n\neffects either. Indeed, I can freely rearrange code that lacks side effects to my heart’s\n\ncontent, which is one of the reasons why wise programmers prefer to use side­effect­\n\nfree code as much as possible.\n\nThere is a wrinkle here, however. How do I know that line 2 is side­effect­free? To be\n\nsure, I’d need to look inside retrieveOrder() to ensure there are no side effects\n\nthere (and inside any functions it calls, and inside any functions its functions call, and\n\nso on). In practice, when working on my own code, I know that I generally follow the\n\nCommand­Query Separation [mf­cqs] principle, so any function that returns a value is\n\nfree of side effects. But I can only be confident of that because I know the code base; if I\n\nwere working in an unknown code base, I’d have to be more cautious. But I do try to\n\nfollow the Command­Query Separation in my own code because it’s so valuable to know\n\nthat code is free of side effects.\n\nWhen sliding code that has a side effect, or sliding over code with side effects, I have to\n\nbe much more careful. What I’m looking for is interference between the two code\n\nfragments. So, let’s say I want to slide line 11 (`if (order.isRepeat) ...`) down\n\nto the end. I’m prevented from doing that by line 12 because it references the variable\n\nwhose state I’m changing in line 11. Similarly, I can’t take line 13\n\n(`chargeOrder(charge)`) and move it up because line 12 modifies some state that\n\nline 13 references. However, I can slide line 8 (`charge = baseCharge + ...`)\n\nover lines 9–11 because there they don’t modify any common state.\n\nThe most straightforward rule to follow is that I can’t slide one fragment of code over\n\nanother if any data that both fragments refer to is modified by either one. But that’s not\n\na comprehensive rule; I can happily slide either of the following two lines over the\n\nother:\n\nwww.EBooksWorld.ir",
      "content_length": 2709,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 255,
      "content": "a = a + 10; a = a + 5;\n\nBut judging whether a slide is safe means I have to really understand the operations\n\ninvolved and how they compose.\n\nSince I need to worry so much about updating state, I look to remove as much of it as I\n\ncan. So with this code, I’d be looking to apply Split Variable (240) on charge before I\n\nindulge in any sliding around of that code.\n\nHere, the analysis is relatively simple because I’m mostly just modifying local variables.\n\nWith more complex data structures, it’s much harder to be sure when I get interference.\n\nSo tests play an important role: Slide the fragment, run tests, see if things break. If my\n\ntest coverage is good, I can feel happy with the refactoring. But if tests aren’t reliable, I\n\nneed to be more wary—or, more likely, to improve the tests for the code I’m working on.\n\nThe most important consequence of a test failure after a slide is to use smaller slides:\n\nInstead of sliding over ten lines, I’ll just pick five, or slide up to what I reckon is a\n\ndangerous line. It may also mean that the slide isn’t worth it, and I need to work on\n\nsomething else first.\n\nExample: Sliding with Conditionals\n\nI can also do slides with conditionals. This will either involve removing duplicate logic\n\nwhen I slide out of a conditional, or adding duplicate logic when I slide in.\n\nHere’s a case where I have the same statements in both legs of a conditional:\n\nClick here to view code image\n\nlet result; if (availableResources.length === 0) { result = createResource(); allocatedResources.push(result); } else { result = availableResources.pop(); allocatedResources.push(result); } return result;\n\nI can slide these out of the conditional, in which case they turn into a single statement\n\noutside of the conditional block.\n\nwww.EBooksWorld.ir",
      "content_length": 1779,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 256,
      "content": "Click here to view code image\n\nlet result; if (availableResources.length === 0) { result = createResource(); } else { result = availableResources.pop(); } allocatedResources.push(result); return result;\n\nIn the reverse case, sliding a fragment into a conditional means repeating it in every leg\n\nof the conditional.\n\nFurther Reading\n\nI’ve seen an almost identical refactoring under the name of Swap Statement [wake­\n\nswap]. Swap Statement moves adjacent fragments, but it only works with single­\n\nstatement fragments. You can think of it as Slide Statements where both the sliding\n\nfragment and the slid­over fragment are single statements. This refactoring appeals to\n\nme; after all, I’m always going on about taking small steps—steps that may seem\n\nridiculously small to those new to refactoring.\n\nBut I ended up writing this refactoring with larger fragments because that is what I do.\n\nI only move one statement at a time if I’m having difficulty with a larger slide, and I\n\nrarely run into problems with larger slides. With more messy code, however, smaller\n\nslides end up being easier.\n\nSPLIT LOOP\n\nwww.EBooksWorld.ir",
      "content_length": 1123,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 257,
      "content": "Motivation\n\nYou often see loops that are doing two different things at once just because they can do\n\nthat with one pass through a loop. But if you’re doing two different things in the same\n\nloop, then whenever you need to modify the loop you have to understand both things.\n\nBy splitting the loop, you ensure you only need to understand the behavior you need to\n\nmodify.\n\nSplitting a loop can also make it easier to use. A loop that calculates a single value can\n\njust return that value. Loops that do many things need to return structures or populate\n\nlocal variables. I frequently follow a sequence of Split Loop followed by Extract\n\nFunction (106).\n\nwww.EBooksWorld.ir",
      "content_length": 672,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 258,
      "content": "Many programmers are uncomfortable with this refactoring, as it forces you to execute\n\nthe loop twice. My reminder, as usual, is to separate refactoring from optimization\n\n(Refactoring and Performance (64)). Once I have my code clear, I’ll optimize it, and if\n\nthe loop traversal is a bottleneck, it’s easy to slam the loops back together. But the\n\nactual iteration through even a large list is rarely a bottleneck, and splitting the loops\n\noften enables other, more powerful, optimizations.\n\nMechanics\n\nCopy the loop.\n\nIdentify and eliminate duplicate side effects.\n\nTest.\n\nWhen done, consider Extract Function (106) on each loop.\n\nExample\n\nI’ll start with a little bit of code that calculates the total salary and youngest age.\n\nClick here to view code image\n\nlet youngest = people[0] ? people[0].age : Infinity; let totalSalary = 0; for (const p of people) { if (p.age < youngest) youngest = p.age; totalSalary += p.salary; }\n\nreturn `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;\n\nIt’s a very simple loop, but it’s doing two different calculations. To split them, I begin\n\nwith just copying the loop.\n\nClick here to view code image\n\nlet youngest = people[0] ? people[0].age : Infinity; let totalSalary = 0; for (const p of people) { if (p.age < youngest) youngest = p.age; totalSalary += p.salary; }\n\nfor (const p of people) {\n\nwww.EBooksWorld.ir",
      "content_length": 1360,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 259,
      "content": "if (p.age < youngest) youngest = p.age; totalSalary += p.salary; }\n\nreturn `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;\n\nWith the loop copied, I need to remove the duplication that would otherwise produce\n\nwrong results. If something in the loop has no side effects, I can leave it there for now,\n\nbut it’s not the case with this example.\n\nClick here to view code image\n\nlet youngest = people[0] ? people[0].age : Infinity; let totalSalary = 0; for (const p of people) { if (p.age < youngest) youngest = p.age; totalSalary += p.salary; }\n\nfor (const p of people) { if (p.age < youngest) youngest = p.age; totalSalary += p.salary; }\n\nreturn `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;\n\nOfficially, that’s the end of the Split Loop refactoring. But the point of Split Loop isn’t\n\nwhat it does on its own but what it sets up for the next move—and I’m usually looking\n\nto extract the loops into their own functions. I’ll use Slide Statements (223) to\n\nreorganize the code a bit first.\n\nClick here to view code image\n\nlet totalSalary = 0; for (const p of people) { totalSalary += p.salary; }\n\nlet youngest = people[0] ? people[0].age : Infinity; for (const p of people) { if (p.age < youngest) youngest = p.age; }\n\nreturn `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;\n\nThen I do a couple of Extract Function (106).\n\nwww.EBooksWorld.ir",
      "content_length": 1365,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 260,
      "content": "Click here to view code image\n\nreturn `youngestAge: ${youngestAge()}, totalSalary: ${totalSalary()}`;\n\nfunction totalSalary() { let totalSalary = 0; for (const p of people) { totalSalary += p.salary; } return totalSalary; }\n\nfunction youngestAge() { let youngest = people[0] ? people[0].age : Infinity; for (const p of people) { if (p.age < youngest) youngest = p.age; } return youngest; }\n\nI can rarely resist Replace Loop with Pipeline (231) for the total salary, and there’s an\n\nobvious Substitute Algorithm (195) for the youngest age.\n\nClick here to view code image\n\nreturn `youngestAge: ${youngestAge()}, totalSalary: ${totalSalary()}`;\n\nfunction totalSalary() { return people.reduce((total,p) => total + p.salary, 0); } function youngestAge() { return Math.min(...people.map(p => p.age)); }\n\nREPLACE LOOP WITH PIPELINE\n\nwww.EBooksWorld.ir",
      "content_length": 844,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 261,
      "content": "Motivation\n\nLike most programmers, I was taught to use loops to iterate over a collection of objects.\n\nIncreasingly, however, language environments provide a better construct: the collection\n\npipeline. Collection Pipelines [mf­cp] allow me to describe my processing as a series of\n\noperations, each consuming and emitting a collection. The most common of these\n\noperations are map, which uses a function to transform each element of the input\n\ncollection, and filter which uses a function to select a subset of the input collection for\n\nlater steps in the pipeline. I find logic much easier to follow if it is expressed as a\n\npipeline—I can then read from top to bottom to see how objects flow through the\n\npipeline.\n\nMechanics\n\nCreate a new variable for the loop’s collection.\n\nThis may be a simple copy of an existing variable.\n\nStarting at the top, take each bit of behavior in the loop and replace it with a\n\ncollection pipeline operation in the derivation of the loop collection variable. Test\n\nafter each change.\n\nOnce all behavior is removed from the loop, remove it.\n\nwww.EBooksWorld.ir",
      "content_length": 1094,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 262,
      "content": "If it assigns to an accumulator, assign the pipeline result to the accumulator.\n\nExample\n\nI’ll begin with some data: a CSV file of data about our offices.\n\nClick here to view code image\n\noffice, country, telephone Chicago, USA, +1 312 373 1000 Beijing, China, +86 4008 900 505 Bangalore, India, +91 80 4064 9570 Porto Alegre, Brazil, +55 51 3079 3550 Chennai, India, +91 44 660 44766\n\n... (more data follows)\n\nThe following function picks out the offices in India and returns their cities and\n\ntelephone numbers:\n\nClick here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); let firstLine = true; const result = []; for (const line of lines) { if (firstLine) { firstLine = false; continue; } if (line.trim() === \"\") continue; const record = line.split(\",\"); if (record[1].trim() === \"India\") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }\n\nI want to replace that loop with a collection pipeline.\n\nMy first step is to create a separate variable for the loop to work over.\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1094,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 263,
      "content": "function acquireData(input) { const lines = input.split(\"\\n\"); let firstLine = true; const result = []; const loopItems = lines for (const line of loopItems) { if (firstLine) { firstLine = false; continue; } if (line.trim() === \"\") continue; const record = line.split(\",\"); if (record[1].trim() === \"India\") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }\n\nThe first part of the loop is all about skipping the first line of the CSV file. This calls for\n\na slice, so I remove that first section of the loop and add a slice operation to the\n\nformation of the loop variable.\n\nClick here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); let firstLine = true; const result = []; const loopItems = lines .slice(1); for (const line of loopItems) { if (firstLine) { firstLine = false; continue; } if (line.trim() === \"\") continue; const record = line.split(\",\"); if (record[1].trim() === \"India\") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }\n\nAs a bonus, this lets me delete firstLine—and I particularly enjoy deleting control\n\nvariables.\n\nwww.EBooksWorld.ir",
      "content_length": 1165,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 264,
      "content": "The next bit of behavior removes any blank lines. I can replace this with a filter\n\noperation.\n\nClick here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); const result = []; const loopItems = lines .slice(1) .filter(line => line.trim() !== \"\") ; for (const line of loopItems) { if (line.trim() === \"\") continue; const record = line.split(\",\"); if (record[1].trim() === \"India\") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }\n\nWhen writing a pipeline, I find it best to put the terminal semicolon on its own line.\n\nI use the map operation to turn lines into an array of strings—misleadingly called\n\nrecord in the original function, but it’s safer to keep the name for now and rename later.\n\nClick here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); const result = []; const loopItems = lines .slice(1) .filter(line => line.trim() !== \"\") .map(line => line.split(\",\")) ; for (const line of loopItems) { const record = line;.split(\",\"); if (record[1].trim() === \"India\") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }\n\nFilter again to just get the India records:\n\nwww.EBooksWorld.ir",
      "content_length": 1230,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 265,
      "content": "Click here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); const result = []; const loopItems = lines .slice(1) .filter(line => line.trim() !== \"\") .map(line => line.split(\",\")) .filter(record => record[1].trim() === \"India\") ; for (const line of loopItems) { const record = line; if (record[1].trim() === \"India\") { result.push({city: record[0].trim(), phone: record[2].trim()}); } } return result; }\n\nMap to the output record form:\n\nClick here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); const result = []; const loopItems = lines .slice(1) .filter(line => line.trim() !== \"\") .map(line => line.split(\",\")) .filter(record => record[1].trim() === \"India\") .map(record => ({city: record[0].trim(), phone: record[2].trim()})) ; for (const line of loopItems) { const record = line; result.push(line); } return result; }\n\nNow, all the loop does is assign values to the accumulator. So I can remove it and assign\n\nthe result of the pipeline to the accumulator:\n\nClick here to view code image\n\nfunction acquireData(input) {www.EBooksWorld.ir",
      "content_length": 1110,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 266,
      "content": "const lines = input.split(\"\\n\"); const result = lines .slice(1) .filter(line => line.trim() !== \"\") .map(line => line.split(\",\")) .filter(record => record[1].trim() === \"India\") .map(record => ({city: record[0].trim(), phone: record[2].trim()})) ; for (const line of loopItems) { const record = line; result.push(line); } return result; }\n\nThat’s the core of the refactoring. But I do have some cleanup I’d like to do. I inlined\n\nresult, renamed some lambda variables, and made the layout read more like a table.\n\nClick here to view code image\n\nfunction acquireData(input) { const lines = input.split(\"\\n\"); return lines .slice (1) .filter (line => line.trim() !== \"\") .map (line => line.split(\",\")) .filter (fields => fields[1].trim() === \"India\") .map (fields => ({city: fields[0].trim(), phone: fields[2].trim()})) ; }\n\nI thought about inlining lines too, but felt that its presence explains what’s\n\nhappening.\n\nFurther Reading\n\nFor more examples on turning loops into pipelines, see my essay “Refactoring with\n\nLoops and Collection Pipelines” [mf­ref­pipe].\n\nREMOVE DEAD CODE\n\nwww.EBooksWorld.ir",
      "content_length": 1099,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 267,
      "content": "Motivation\n\nWhen we put code into production, even on people’s devices, we aren’t charged by\n\nweight. A few unused lines of code don’t slow down our systems nor take up significant\n\nmemory; indeed, decent compilers will instinctively remove them. But unused code is\n\nstill a significant burden when trying to understand how the software works. It doesn’t\n\ncarry any warning signs telling programmers that they can ignore this function as it’s\n\nnever called any more, so they still have to spend time understanding what it’s doing\n\nand why changing it doesn’t seem to alter the output as they expected.\n\nOnce code isn’t used any more, we should delete it. I don’t worry that I may need it\n\nsometime in the future; should that happen, I have my version control system so I can\n\nalways dig it out again. If it’s something I really think I may need one day, I might put a\n\ncomment into the code that mentions the lost code and which revision it was removed\n\nin—but, honestly, I can’t remember the last time I did that, or regretted that I hadn’t\n\ndone it.\n\nCommenting out dead code was once a common habit. This was useful in the days\n\nbefore version control systems were widely used, or when they were inconvenient. Now,\n\nwhen I can put even the smallest code base under version control, that’s no longer\n\nneeded.\n\nMechanics\n\nIf the dead code can be referenced from outside, e.g., when it’s a full function, do a\n\nsearch to check for callers.\n\nRemove the dead code.\n\nTest.\n\nwww.EBooksWorld.ir",
      "content_length": 1489,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 268,
      "content": "Chapter 9 Organizing Data\n\nHistory\n\nTopics\n\nData structures play an important role in our programs, so it’s no great shock that I\n\nhave a clutch of refactorings that focus on them. A value that’s used for different\n\nTutorials\n\npurposes is a breeding ground for confusion and bugs—so, when I see one, I use Split\n\nVariable (240) to separate the usages. As with any program element, getting a\n\nOffers & Deals\n\nvariable’s name right is tricky and important, so Rename Variable (137) is often my\n\nHighlights\n\nfriend. But sometimes the best thing I can do with a variable is to get rid of it\n\ncompletely—with Replace Derived Variable with Query (248).\n\nSettings\n\nI often find problems in a code base due to a confusion between references and values,\n\nSupport\n\nso I use Change Reference to Value (252) and Change Value to Reference (256) to\n\nchange between these styles.\n\nSign Out\n\nSPLIT VARIABLE\n\nformerly: Remove Assignments to Parameters\n\nformerly: Split Temp\n\nwww.EBooksWorld.ir",
      "content_length": 976,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 269,
      "content": "Motivation\n\nVariables have various uses. Some of these uses naturally lead to the variable being\n\nassigned to several times. Loop variables change for each run of a loop (such as the i in\n\nfor (let i=0; i<10; i++)). Collecting variables store a value that is built up\n\nduring the method.\n\nMany other variables are used to hold the result of a long­winded bit of code for easy\n\nreference later. These kinds of variables should be set only once. If they are set more\n\nthan once, it is a sign that they have more than one responsibility within the method.\n\nAny variable with more than one responsibility should be replaced with multiple\n\nvariables, one for each responsibility. Using a variable for two different things is very\n\nconfusing for the reader.\n\nMechanics\n\nChange the name of the variable at its declaration and first assignment.\n\nIf the later assignments are of the form i = i + something, that is a collecting\n\nvariable, so don’t split it. A collecting variable is often used for calculating sums,\n\nstring concatenation, writing to a stream, or adding to a collection.\n\nIf possible, declare the new variable as immutable.\n\nChange all references of the variable up to its second assignment.\n\nwww.EBooksWorld.ir",
      "content_length": 1218,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 270,
      "content": "Test.\n\nRepeat in stages, at each stage renaming the variable at the declaration and\n\nchanging references until the next assignment, until you reach the final assignment.\n\nExample\n\nFor this example, I compute the distance traveled by a haggis. From a standing start, a\n\nhaggis experiences an initial force. After a delay, a secondary force kicks in to further\n\naccelerate the haggis. Using the common laws of motion, I can compute the distance\n\ntraveled as follows:\n\nClick here to view code image\n\nfunction distanceTravelled (scenario, time) { let result; let acc = scenario.primaryForce / scenario.mass; let primaryTime = Math.min(time, scenario.delay); result = 0.5 * acc * primaryTime * primaryTime; let secondaryTime = time ­ scenario.delay; if (secondaryTime > 0) { let primaryVelocity = acc * scenario.delay; acc = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass; result += primaryVelocity * secondaryTime + 0.5 * acc * secondaryTime * secondaryTime; } return result; }\n\nA nice awkward little function. The interesting thing for our example is the way the\n\nvariable acc is set twice. It has two responsibilities: one to hold the initial acceleration\n\nfrom the first force and another later to hold the acceleration from both forces. I want\n\nto split this variable.\n\nWhen trying to understand how a variable is used, it’s handy if my editor can highlight\n\nall occurrences of a symbol within a function or file. Most modern editors can do this\n\npretty easily.\n\nI start at the beginning by changing the name of the variable and declaring the new\n\nname as const. Then, I change all references to the variable from that point up to the\n\nnext assignment. At the next assignment, I declare it:\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1760,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 271,
      "content": "function distanceTravelled (scenario, time) { let result; const primaryAcceleration = scenario.primaryForce / scenario.mass; let primaryTime = Math.min(time, scenario.delay); result = 0.5 * primaryAcceleration * primaryTime * primaryTime; let secondaryTime = time ­ scenario.delay; if (secondaryTime > 0) { let primaryVelocity = primaryAcceleration * scenario.delay; let acc = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass; result += primaryVelocity * secondaryTime + 0.5 * acc * secondaryTime * secondaryTime; } return result; }\n\nI choose the new name to represent only the first use of the variable. I make it const to\n\nensure it is only assigned once. I can then declare the original variable at its second\n\nassignment. Now I can compile and test, and all should work.\n\nI continue on the second assignment of the variable. This removes the original variable\n\nname completely, replacing it with a new variable named for the second use.\n\nClick here to view code image\n\nfunction distanceTravelled (scenario, time) { let result; const primaryAcceleration = scenario.primaryForce / scenario.mass; let primaryTime = Math.min(time, scenario.delay); result = 0.5 * primaryAcceleration * primaryTime * primaryTime; let secondaryTime = time ­ scenario.delay; if (secondaryTime > 0) { let primaryVelocity = primaryAcceleration * scenario.delay; const secondaryAcceleration = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass; result += primaryVelocity * secondaryTime + 0.5 * secondaryAcceleration * secondaryTime * secondaryTime; } return result; }\n\nI’m sure you can think of a lot more refactoring to be done here. Enjoy it. (I’m sure it’s\n\nbetter than eating the haggis—do you know what they put in those things?)\n\nExample: Assigning to an Input Parameter\n\nAnother case of splitting a variable is where the variable is declared as an input\n\nparameter. Consider something like\n\nwww.EBooksWorld.ir",
      "content_length": 1926,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 272,
      "content": "Click here to view code image\n\nfunction discount (inputValue, quantity) { if (inputValue > 50) inputValue = inputValue ­ 2; if (quantity > 100) inputValue = inputValue ­ 1; return inputValue; }\n\nHere inputValue is used both to supply an input to the function and to hold the result\n\nfor the caller. (Since JavaScript has call­by­value parameters, any modification of\n\ninputValue isn’t seen by the caller.)\n\nIn this situation, I would split that variable.\n\nClick here to view code image\n\nfunction discount (originalInputValue, quantity) { let inputValue = originalInputValue; if (inputValue > 50) inputValue = inputValue ­ 2; if (quantity > 100) inputValue = inputValue ­ 1; return inputValue; }\n\nI then perform Rename Variable (137) twice to get better names.\n\nClick here to view code image\n\nfunction discount (inputValue, quantity) { let result = inputValue; if (inputValue > 50) result = result ­ 2; if (quantity > 100) result = result ­ 1; return result; }\n\nYou’ll notice that I changed the second line to use inputValue as its data source.\n\nAlthough the two are the same, I think that line is really about applying the\n\nmodification to the result value based on the original input value, not the\n\n(coincidentally same) value of the result accumulator.\n\nRENAME FIELD\n\nwww.EBooksWorld.ir",
      "content_length": 1289,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 273,
      "content": "Motivation\n\nNames are important, and field names in record structures can be especially important\n\nwhen those record structures are widely used across a program. Data structures play a\n\nparticularly important role in understanding. Many years ago Fred Brooks said, “Show\n\nme your flowcharts and conceal your tables, and I shall continue to be mystified. Show\n\nme your tables, and I won’t usually need your flowcharts; they’ll be obvious.” While I\n\ndon’t see many people drawing flowcharts these days, the adage remains valid. Data\n\nstructures are the key to understanding what’s going on.\n\nSince these data structures are so important, it’s essential to keep them clear. Like\n\nanything else, my understanding of data improves the more I work on the software, so\n\nit’s vital that this improved understanding is embedded into the program.\n\nYou may want to rename a field in a record structure, but the idea also applies to\n\nclasses. Getter and setter methods form an effective field for users of the class.\n\nRenaming them is just as important as with bare record structures.\n\nMechanics\n\nIf the record has limited scope, rename all accesses to the field and test; no need to\n\ndo the rest of the mechanics.\n\nIf the record isn’t already encapsulated, apply Encapsulate Record (162).\n\nRename the private field inside the object, adjust internal methods to fit.\n\nTest.\n\nwww.EBooksWorld.ir",
      "content_length": 1381,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 274,
      "content": "If the constructor uses the name, apply Change Function Declaration (124) to\n\nrename it.\n\nApply Rename Function (124) to the accessors.\n\nExample: Renaming a Field\n\nI’ll start with a constant.\n\nClick here to view code image\n\nconst organization = {name: \"Acme Gooseberries\", country: \"GB\"};\n\nI want to change “name” to “title”. The object is widely used in the code base, and there\n\nare updates to the title in the code. So my first move is to apply Encapsulate Record\n\n(162).\n\nClick here to view code image\n\nclass Organization { constructor(data) { this._name = data.name; this._country = data.country; } get name() {return this._name;} set name(aString) {this._name = aString;} get country() {return this._country;} set country(aCountryCode) {this._country = aCountryCode;} }\n\nconst organization = new Organization({name: \"Acme Gooseberries\", country: \"GB\"});\n\nNow that I’ve encapsulated the record structure into the class, there are four places I\n\nneed to look at for renaming: the getting function, the setting function, the constructor,\n\nand the internal data structure. While that may sound like I’ve increased my workload,\n\nit actually makes my work easier since I can now change these independently instead of\n\nall at once, taking smaller steps. Smaller steps mean fewer things to go wrong in each\n\nstep—therefore, less work. It wouldn’t be less work if I never made mistakes—but not\n\nmaking mistakes is a fantasy I gave up on a long time ago.\n\nSince I’ve copied the input data structure into the internal data structure, I need to\n\nseparate them so I can work on them independently. I can do this by defining a\n\nwww.EBooksWorld.ir",
      "content_length": 1638,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 275,
      "content": "separate field and adjusting the constructor and accessors to use it.\n\nclass Organization…\n\nClick here to view code image\n\nclass Organization { constructor(data) { this._title = data.name; this._country = data.country; } get name() {return this._title;} set name(aString) {this._title = aString;} get country() {return this._country;} set country(aCountryCode) {this._country = aCountryCode;} }\n\nNext, I add support for using “title” in the constructor.\n\nclass Organization…\n\nClick here to view code image\n\nclass Organization { constructor(data) { this._title = (data.title !== undefined) ? data.title : data.name; this._country = data.country; } get name() {return this._title;} set name(aString) {this._title = aString;} get country() {return this._country;} set country(aCountryCode) {this._country = aCountryCode;} }\n\nNow, callers of my constructor can use either name or title (with title taking\n\nprecedence). I can now go through all constructor callers and change them one­by­one\n\nto use the new name.\n\nClick here to view code image\n\nconst organization = new Organization({title: \"Acme Gooseberries\", country: \"GB\"});\n\nOnce I’ve done all of them, I can remove the support for the name.\n\nwww.EBooksWorld.ir",
      "content_length": 1212,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 276,
      "content": "class Organization…\n\nClick here to view code image\n\nclass Organization { constructor(data) { this._title = data.title; this._country = data.country; } get name() {return this._title;} set name(aString) {this._title = aString;} get country() {return this._country;} set country(aCountryCode) {this._country = aCountryCode;} }\n\nNow that the constructor and data use the new name, I can change the accessors, which\n\nis as simple as applying Rename Function (124) to each one.\n\nclass Organization…\n\nClick here to view code image\n\nclass Organization { constructor(data) { this._title = data.title; this._country = data.country; } get title() {return this._title;} set title(aString) {this._title = aString;} get country() {return this._country;} set country(aCountryCode) {this._country = aCountryCode;} }\n\nI’ve shown this process in its most heavyweight form needed for a widely used data\n\nstructure. If it’s being used only locally, as in a single function, I can probably just\n\nrename the various properties in one go without doing encapsulation. It’s a matter of\n\njudgment when to apply to the full mechanics here—but, as usual with refactoring, if\n\nmy tests break, that’s a sign I need to use the more gradual procedure.\n\nSome languages allow me to make a data structure immutable. In this case, rather than\n\nencapsulating it, I can copy the value to the new name, gradually change the users, then\n\nremove the old name. Duplicating data is a recipe for disaster with mutable data\n\nstructures; removing such disasters is why immutable data is so popular.\n\nwww.EBooksWorld.ir\n\nREPLACE DERIVED VARIABLE WITH QUERY",
      "content_length": 1610,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 277,
      "content": "REPLACE DERIVED VARIABLE WITH QUERY\n\nMotivation\n\nOne of the biggest sources of problems in software is mutable data. Data changes can\n\noften couple together parts of code in awkward ways, with changes in one part leading\n\nto knock­on effects that are hard to spot. In many situations it’s not realistic to entirely\n\nremove mutable data—but I do advocate minimizing the scope of mutable data at much\n\nas possible.\n\nOne way I can make a big impact is by removing any variables that I could just as easily\n\ncalculate. A calculation often makes it clearer what the meaning of the data is, and it is\n\nprotected from being corrupted when you fail to update the variable as the source data\n\nchanges.\n\nA reasonable exception to this is when the source data for the calculation is immutable\n\nand we can force the result to being immutable too. Transformation operations that\n\ncreate new data structures are thus reasonable to keep even if they could be replaced\n\nwith calculations. Indeed, there is a duality here between objects that wrap a data\n\nstructure with a series of calculated properties and functions that transform one data\n\nstructure into another. The object route is clearly better when the source data changes\n\nand you would have to manage the lifetime of the derived data structures. But if the\n\nsource data is immutable, or the derived data is very transient, then both approaches\n\nare effective.\n\nMechanics\n\nwww.EBooksWorld.ir",
      "content_length": 1434,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 278,
      "content": "Identify all points of update for the variable. If necessary, use Split Variable (240)\n\nto separate each point of update.\n\nCreate a function that calculates the value of the variable.\n\nUse Introduce Assertion (302) to assert that the variable and the calculation give\n\nthe same result whenever the variable is used.\n\nIf necessary, use Encapsulate Variable (132) to provide a home for the assertion.\n\nTest.\n\nReplace any reader of the variable with a call to the new function.\n\nTest.\n\nApply Remove Dead Code (237) to the declaration and updates to the variable.\n\nExample\n\nHere’s a small but perfectly formed example of ugliness:\n\nclass ProductionPlan…\n\nClick here to view code image\n\nget production() {return this._production;} applyAdjustment(anAdjustment) { this._adjustments.push(anAdjustment); this._production += anAdjustment.amount; }\n\nUgliness is in the eye of beholder; here, I see ugliness in duplication—not the common\n\nduplication of code but duplication of data. When I apply an adjustment, I’m not just\n\nstoring that adjustment but also using it to modify an accumulator. I can just calculate\n\nthat value, without having to update it.\n\nBut I’m a cautious fellow. It is my hypothesis is that I can just calculate it—I can test\n\nthat hypothesis by using Introduce Assertion (302):\n\nclass ProductionPlan…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1363,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 279,
      "content": "get production() { assert(this._production === this.calculatedProduction); return this._production; }\n\nget calculatedProduction() { return this._adjustments .reduce((sum, a) => sum + a.amount, 0); }\n\nWith the assertion in place, I run my tests. If the assertion doesn’t fail, I can replace\n\nreturning the field with returning the calculation:\n\nclass ProductionPlan…\n\nClick here to view code image\n\nget production() { assert(this._production === this.calculatedProduction); return this.calculatedProduction; }\n\nThen Inline Function (115):\n\nclass ProductionPlan…\n\nClick here to view code image\n\nget production() { return this._adjustments .reduce((sum, a) => sum + a.amount, 0); }\n\nI clean up any references to the old variable with Remove Dead Code (237):\n\nclass ProductionPlan…\n\nClick here to view code image\n\napplyAdjustment(anAdjustment) { this._adjustments.push(anAdjustment); this._production += anAdjustment.amount; }\n\nwww.EBooksWorld.ir\n\nExample: More Than One Source",
      "content_length": 973,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 280,
      "content": "Example: More Than One Source\n\nThe above example is nice and easy because there’s clearly a single source for the value\n\nof production. But sometimes, more than one element can combine in the\n\naccumulator.\n\nclass ProductionPlan…\n\nClick here to view code image\n\nconstructor (production) { this._production = production; this._adjustments = []; } get production() {return this._production;} applyAdjustment(anAdjustment) { this._adjustments.push(anAdjustment); this._production += anAdjustment.amount; }\n\nIf I do the same Introduce Assertion (302) that I did above, it will now fail for any case\n\nwhere the initial value of the production isn’t zero.\n\nBut I can still replace the derived data. The only difference is that I must first apply\n\nSplit Variable (240).\n\nClick here to view code image\n\nconstructor (production) { this._initialProduction = production; this._productionAccumulator = 0; this._adjustments = []; } get production() { return this._initialProduction + this._productionAccumulator; }\n\nNow I can Introduce Assertion (302):\n\nclass ProductionPlan…\n\nClick here to view code image\n\nget production() { assert(this._productionAccumulator === this.calculatedProductionAccumulator);\n\nwww.EBooksWorld.ir",
      "content_length": 1210,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 281,
      "content": "return this._initialProduction + this._productionAccumulator; }\n\nget calculatedProductionAccumulator() { return this._adjustments .reduce((sum, a) => sum + a.amount, 0); }\n\nand continue pretty much as before. I’d be inclined, however, to leave\n\ntotalProductionAjustments as its own property, without inlining it.\n\nCHANGE REFERENCE TO VALUE\n\ninverse of: Change Value to Reference (256)\n\nMotivation\n\nWhen I nest an object, or data structure, within another I can treat the inner object as a\n\nreference or as a value. The difference is most obviously visible in how I handle updates\n\nof the inner object’s properties. If I treat it as a reference, I’ll update the inner object’s\n\nproperty keeping the same inner object. If I treat it as a value, I will replace the entire\n\ninner object with a new one that has the desired property.\n\nIf I treat a field as a value, I can change the class of the inner object to make it a Value\n\nObject [mf­vo]. Value objects are generally easier to reason about, particularly because\n\nwww.EBooksWorld.ir",
      "content_length": 1032,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 282,
      "content": "they are immutable. In general, immutable data structures are easier to deal with. I can\n\npass an immutable data value out to other parts of the program and not worry that it\n\nmight change without the enclosing object being aware of the change. I can replicate\n\nvalues around my program and not worry about maintaining memory links. Value\n\nobjects are especially useful in distributed and concurrent systems.\n\nThis also suggests when I shouldn’t do this refactoring. If I want to share an object\n\nbetween several objects so that any change to the shared object is visible to all its\n\ncollaborators, then I need the shared object to be a reference.\n\nMechanics\n\nCheck that the candidate class is immutable or can become immutable.\n\nFor each setter, apply Remove Setting Method (331).\n\nProvide a value­based equality method that uses the fields of the value object.\n\nMost language environments provide an overridable equality function for this\n\npurpose. Usually you must override a hashcode generator method as well.\n\nExample\n\nImagine we have a person object that holds onto a crude telephone number.\n\nclass Person…\n\nClick here to view code image\n\nconstructor() { this._telephoneNumber = new TelephoneNumber(); }\n\nget officeAreaCode() {return this._telephoneNumber.areaCode;} set officeAreaCode(arg) {this._telephoneNumber.areaCode = arg;} get officeNumber() {return this._telephoneNumber.number;} set officeNumber(arg) {this._telephoneNumber.number = arg;}\n\nclass TelephoneNumber…\n\nClick here to view code image\n\nget areaCode() {return this._areaCode;} set areaCode(arg) {this._areaCode = arg;}\n\nwww.EBooksWorld.ir",
      "content_length": 1612,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 283,
      "content": "get number() {return this._number;} set number(arg) {this._number = arg;}\n\nThis situation is the result of an Extract Class (182) where the old parent still holds\n\nupdate methods for the new object. This is a good time to apply Change Reference to\n\nValue since there is only one reference to the new class.\n\nThe first thing I need to do is to make the telephone number immutable. I do this by\n\napplying Remove Setting Method (331) to the fields. The first step of Remove Setting\n\nMethod (331) is to use Change Function Declaration (124) to add the two fields to the\n\nconstructor and enhance the constructor to call the setters.\n\nclass TelephoneNumber…\n\nClick here to view code image\n\nconstructor(areaCode, number) { this._areaCode = areaCode; this._number = number; }\n\nNow I look at the callers of the setters. For each one, I need to change it to a\n\nreassignment. I start with the area code.\n\nclass Person…\n\nClick here to view code image\n\nget officeAreaCode() {return this._telephoneNumber.areaCode;} set officeAreaCode(arg) { this._telephoneNumber = new TelephoneNumber(arg, this.officeNumber); } get officeNumber() {return this._telephoneNumber.number;} set officeNumber(arg) {this._telephoneNumber.number = arg;}\n\nI then repeat that step with the remaining field.\n\nclass Person…\n\nClick here to view code image\n\nget officeAreaCode() {return this._telephoneNumber.areaCode;} www.EBooksWorld.ir",
      "content_length": 1395,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 284,
      "content": "set officeAreaCode(arg) { this._telephoneNumber = new TelephoneNumber(arg, this.officeNumber); } get officeNumber() {return this._telephoneNumber.number;} set officeNumber(arg) { this._telephoneNumber = new TelephoneNumber(this.officeAreaCode, arg); }\n\nNow the telephone number is immutable, it is ready to become a true value. The\n\ncitizenship test for a value object is that it uses value­based equality. This is an area\n\nwhere JavaScript falls down, as there is nothing in the language and core libraries that\n\nunderstands replacing a reference­based equality with a value­based one. The best I can\n\ndo is to create my own equals method.\n\nclass TelephoneNumber…\n\nClick here to view code image\n\nequals(other) { if (!(other instanceof TelephoneNumber)) return false; return this.areaCode === other.areaCode && this.number === other.number; }\n\nIt’s also important to test it with something like\n\nClick here to view code image\n\nit('telephone equals', function() { assert( new TelephoneNumber(\"312\", \"555­0142\") .equals(new TelephoneNumber(\"312\", \"555­0142\"))); });\n\nThe unusual formatting I use here should make it obvious that they are the same\n\nconstructor call.\n\nThe vital thing I do in the test is create two independent objects and test that they\n\nmatch as equal.\n\nIn most object­oriented languages, there is a built­in equality test that is supposed to be\n\noverridden for value­based equality. In Ruby, I can override the == operator; in Java, I\n\noverride the Object.equals() method. And whenever I override an equality method,\n\nwww.EBooksWorld.ir",
      "content_length": 1552,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 285,
      "content": "I usually need to override a hashcode generating method too (e.g.,\n\nObject.hashCode() in Java) to ensure collections that use hashing work properly\n\nwith my new value.\n\nIf the telephone number is used by more than one client, the procedure is still the same.\n\nAs I apply Remove Setting Method (331), I’ll be modifying several clients instead of just\n\none. Tests for non­equal telephone numbers, as well as comparisons to non­telephone­\n\nnumbers and null values, are also worthwhile.\n\nCHANGE VALUE TO REFERENCE\n\ninverse of: Change Reference to Value (252)\n\nMotivation\n\nA data structure may have several records linked to the same logical data structure. I\n\nmight read in a list of orders, some of which are for the same customer. When I have\n\nsharing like this, I can represent it by treating the customer either as a value or as a\n\nreference. With a value, the customer data is copied into each order; with a reference,\n\nthere is only one data structure that multiple orders link to.\n\nIf the customer never needs to be updated, then both approaches are reasonable. It is,\n\nperhaps, a bit confusing to have multiple copies of the same data, but it’s common\n\nenough to not be a problem. In some cases, there may be issues with memory due to\n\nmultiple copies—but, like any performance issue, that’s relatively rare.\n\nThe biggest difficulty in having physical copies of the same logical data occurs when I\n\nwww.EBooksWorld.ir",
      "content_length": 1421,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 286,
      "content": "need to update the shared data. I then have to find all the copies and update them all. If\n\nI miss one, I’ll get a troubling inconsistency in my data. In this case, it’s often\n\nworthwhile to change the copied data into a single reference. That way, any change is\n\nvisible to all the customer’s orders.\n\nChanging a value to a reference results in only one object being present for an entity,\n\nand it usually means I need some kind of repository where I can access these objects. I\n\nthen only create the object for an entity once, and everywhere else I retrieve it from the\n\nrepository.\n\nMechanics\n\nCreate a repository for instances of the related object (if one isn’t already present).\n\nEnsure the constructor has a way of looking up the correct instance of the related\n\nobject.\n\nChange the constructors for the host object to use the repository to obtain the\n\nrelated object. Test after each change.\n\nExample\n\nI’ll begin with a class that represents orders, which I might create from an incoming\n\nJSON document. Part of the order data is a customer ID from which I’m creating a\n\ncustomer object.\n\nclass Order…\n\nClick here to view code image\n\nconstructor(data) { this._number = data.number; this._customer = new Customer(data.customer); // load other data } get customer() {return this._customer;}\n\nclass Customer…\n\nconstructor(id) { this._id = id; } get id() {return this._id;}\n\nwww.EBooksWorld.ir",
      "content_length": 1397,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 287,
      "content": "The customer object I create this way is a value. If I have five orders that refer to the\n\ncustomer ID of 123, I’ll have five separate customer objects. Any change I make to one\n\nof them will not be reflected in the others. Should I want to enrich the customer objects,\n\nperhaps by gathering data from a customer service, I’d have to update all five customers\n\nwith the same data. Having duplicate objects like this always makes me nervous—it’s\n\nconfusing to have multiple objects representing the same entity, such as a customer.\n\nThis problem is particularly awkward if the customer object is mutable, which can lead\n\nto inconsistencies between the customer objects.\n\nIf I want to use the same customer object each time, I’ll need a place to store it. Exactly\n\nwhere to store entities like this will vary from application to application, but for a\n\nsimple case I like to use a repository object [mf­repos].\n\nClick here to view code image\n\nlet _repositoryData;\n\nexport function initialize() { _repositoryData = {}; _repositoryData.customers = new Map(); }\n\nexport function registerCustomer(id) { if (! _repositoryData.customers.has(id)) _repositoryData.customers.set(id, new Customer(id)); return findCustomer(id); }\n\nexport function findCustomer(id) { return _repositoryData.customers.get(id); }\n\nThe repository allows me to register customer objects with an ID and ensures I only\n\ncreate one customer object with the same ID. With this in place, I can change the\n\norder’s constructor to use it.\n\nOften, when doing this refactoring, the repository already exists, so I can just use it.\n\nThe next step is to figure out how the constructor for the order can obtain the correct\n\ncustomer object. In this case it’s easy, since the customer’s ID is present in the input\n\ndata stream.\n\nclass Order…\n\nwww.EBooksWorld.ir",
      "content_length": 1814,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 288,
      "content": "Click here to view code image\n\nconstructor(data) { this._number = data.number; this._customer = registerCustomer(data.customer); // load other data } get customer() {return this._customer;}\n\nNow, any changes I make to the customer of one order will be synchronized across all\n\nthe orders sharing the same customer.\n\nFor this example, I created a new customer object with the first order that referenced it.\n\nAnother common approach is to get a list of customers, populate the repository with\n\nthem, and then link to them as I read the orders. In that case, an order that contains a\n\ncustomer ID not in the repository would indicate an error.\n\nOne problem with this code is that the constructor body is coupled to the global\n\nrepository. Globals should be treated with care—like a powerful drug, they can be\n\nbeneficial in small doses but a poison if used too much. If I’m concerned about it, I can\n\npass the repository as a parameter to the constructor.\n\nwww.EBooksWorld.ir",
      "content_length": 973,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 289,
      "content": "y\n\nChapter 10 Simplifying Conditional Logic\n\nHistory\n\nTopics\n\nMuch of the power of programs comes from their ability to implement conditional logic\n\n—but, sadly, much of the complexity of programs lies in these conditionals. I often use\n\nTutorials\n\nrefactoring to make conditional sections easier to understand. I regularly apply\n\nDecompose Conditional (260) to complicated conditionals, and I use Consolidate\n\nOffers & Deals\n\nConditional Expression (263) to make logical combinations clearer. I use Replace\n\nHighlights\n\nNested Conditional with Guard Clauses (266) to clarify cases where I want to run some\n\npre­checks before my main processing. If I see several conditions using the same\n\nSettings\n\nswitching logic, it’s a good time to pull Replace Conditional with Polymorphism (272)\n\nout the box.\n\nSupport\n\nA lot of conditionals are used to handle special cases, such as nulls; if that logic is\n\nSign Out\n\nmostly the same, then Introduce Special Case (289) (often referred to as Introduce Null\n\nObject (289)) can remove a lot of duplicate code. And, although I like to remove\n\nconditions a lot, if I want to communicate (and check) a program’s state, I find\n\nIntroduce Assertion (302) a worthwhile addition.\n\nDECOMPOSE CONDITIONAL\n\nwww.EBooksWorld.ir",
      "content_length": 1253,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 290,
      "content": "Motivation\n\nOne of the most common sources of complexity in a program is complex conditional\n\nlogic. As I write code to do various things depending on various conditions, I can\n\nquickly end up with a pretty long function. Length of a function is in itself a factor that\n\nmakes it harder to read, but conditions increase the difficulty. The problem usually lies\n\nin the fact that the code, both in the condition checks and in the actions, tells me what\n\nhappens but can easily obscure why it happens.\n\nAs with any large block of code, I can make my intention clearer by decomposing it and\n\nreplacing each chunk of code with a function call named after the intention of that\n\nchunk. With conditions, I particularly like doing this for the conditional part and each\n\nof the alternatives. This way, I highlight the condition and make it clear what I’m\n\nbranching on. I also highlight the reason for the branching.\n\nThis is really just a particular case of applying Extract Function (106) to my code, but I\n\nlike to highlight this case as one where I’ve often found a remarkably good value for the\n\nexercise.\n\nMechanics\n\nApply Extract Function (106) on the condition and each leg of the conditional.\n\nwww.EBooksWorld.ir\n\nExample",
      "content_length": 1223,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 291,
      "content": "Example\n\nSuppose I’m calculating the charge for something that has separate rates for winter and\n\nsummer:\n\nClick here to view code image\n\nif (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd)) charge = quantity * plan.summerRate; else charge = quantity * plan.regularRate + plan.regularServiceCharge;\n\nI extract the condition into its own function.\n\nClick here to view code image\n\nif (summer()) charge = quantity * plan.summerRate; else charge = quantity * plan.regularRate + plan.regularServiceCharge;\n\nfunction summer() { return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd); }\n\nThen I do the then leg:\n\nClick here to view code image\n\nif (summer()) charge = summerCharge(); else charge = quantity * plan.regularRate + plan.regularServiceCharge;\n\nfunction summer() { return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd); } function summerCharge() { return quantity * plan.summerRate; }\n\nFinally, the else leg:\n\nwww.EBooksWorld.ir",
      "content_length": 992,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 292,
      "content": "Click here to view code image\n\nif (summer()) charge = summerCharge(); else charge = regularCharge();\n\nfunction summer() { return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd); } function summerCharge() { return quantity * plan.summerRate; } function regularCharge() { return quantity * plan.regularRate + plan.regularServiceCharge; }\n\nWith that done, I like to reformat the conditional using the ternary operator.\n\nClick here to view code image\n\ncharge = summer() ? summerCharge() : regularCharge();\n\nfunction summer() { return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd); } function summerCharge() { return quantity * plan.summerRate; } function regularCharge() { return quantity * plan.regularRate + plan.regularServiceCharge; }\n\nCONSOLIDATE CONDITIONAL EXPRESSION\n\nwww.EBooksWorld.ir",
      "content_length": 832,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 293,
      "content": "Motivation\n\nSometimes, I run into a series of conditional checks where each check is different yet\n\nthe resulting action is the same. When I see this, I use and and or operators to\n\nconsolidate them into a single conditional check with a single result.\n\nConsolidating the conditional code is important for two reasons. First, it makes it\n\nclearer by showing that I’m really making a single check that combines other checks.\n\nThe sequence has the same effect, but it looks like I’m carrying out a sequence of\n\nseparate checks that just happen to be close together. The second reason I like to do\n\nthis is that it often sets me up for Extract Function (106). Extracting a condition is one\n\nof the most useful things I can do to clarify my code. It replaces a statement of what I’m\n\ndoing with why I’m doing it.\n\nThe reasons in favor of consolidating conditionals also point to the reasons against\n\ndoing it. If I consider it to be truly independent checks that shouldn’t be thought of as a\n\nsingle check, I don’t do the refactoring.\n\nMechanics\n\nEnsure that none of the conditionals have any side effects.\n\nIf any do, use Separate Query from Modifier (306) on them first.\n\nwww.EBooksWorld.ir",
      "content_length": 1188,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 294,
      "content": "Take two of the conditional statements and combine their conditions using a logical\n\noperator.\n\nSequences combine with or, nested if statements combine with and.\n\nTest.\n\nRepeat combining conditionals until they are all in a single condition.\n\nConsider using Extract Function (106) on the resulting condition.\n\nExample\n\nPerusing some code, I see the following:\n\nClick here to view code image\n\nfunction disabilityAmount(anEmployee) { if (anEmployee.seniority < 2) return 0; if (anEmployee.monthsDisabled > 12) return 0; if (anEmployee.isPartTime) return 0; // compute the disability amount\n\nIt’s a sequence of conditional checks which all have the same result. Since the result is\n\nthe same, I should combine these conditions into a single expression. For a sequence\n\nlike this, I do it using an or operator.\n\nClick here to view code image\n\nfunction disabilityAmount(anEmployee) { if ((anEmployee.seniority < 2) || (anEmployee.monthsDisabled > 12)) return 0; if (anEmployee.isPartTime) return 0; // compute the disability amount\n\nI test, then fold in the other condition:\n\nClick here to view code image\n\nfunction disabilityAmount(anEmployee) { if ((anEmployee.seniority < 2) || (anEmployee.monthsDisabled > 12) || (anEmployee.isPartTime)) return 0; // compute the disability amount\n\nwww.EBooksWorld.ir",
      "content_length": 1299,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 295,
      "content": "Once I have them all together, I use Extract Function (106) on the condition.\n\nClick here to view code image\n\nfunction disabilityAmount(anEmployee) { if (isNotEligableForDisability()) return 0; // compute the disability amount\n\nfunction isNotEligableForDisability() { return ((anEmployee.seniority < 2) || (anEmployee.monthsDisabled > 12) || (anEmployee.isPartTime)); }\n\nExample: Using ands\n\nThe example above showed combining statements with an or, but I may run into cases\n\nthat need ands as well. Such a case uses nested if statements:\n\nClick here to view code image\n\nif (anEmployee.onVacation) if (anEmployee.seniority > 10) return 1; return 0.5;\n\nI combine these using and operators.\n\nClick here to view code image\n\nif ((anEmployee.onVacation) && (anEmployee.seniority > 10)) return 1; return 0.5;\n\nIf I have a mix of these, I can combine using and and or operators as needed. When\n\nthis happens, things are likely to get messy, so I use Extract Function (106) liberally to\n\nmake it all understandable.\n\nREPLACE NESTED CONDITIONAL WITH GUARD CLAUSES\n\nwww.EBooksWorld.ir",
      "content_length": 1074,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 296,
      "content": "Motivation\n\nI often find that conditional expressions come in two styles. In the first style, both legs\n\nof the conditional are part of normal behavior, while in the second style, one leg is\n\nnormal and the other indicates an unusual condition.\n\nThese kinds of conditionals have different intentions—and these intentions should\n\ncome through in the code. If both are part of normal behavior, I use a condition with an\n\nif and an else leg. If the condition is an unusual condition, I check the condition and\n\nreturn if it’s true. This kind of check is often called a guard clause.\n\nThe key point of Replace Nested Conditional with Guard Clauses is emphasis. If I’m\n\nusing an if­then­else construct, I’m giving equal weight to the if leg and the else leg.\n\nwww.EBooksWorld.ir",
      "content_length": 773,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 297,
      "content": "This communicates to the reader that the legs are equally likely and important. Instead,\n\nthe guard clause says, “This isn’t the core to this function, and if it happens, do\n\nsomething and get out.”\n\nI often find I use Replace Nested Conditional with Guard Clauses when I’m working\n\nwith a programmer who has been taught to have only one entry point and one exit point\n\nfrom a method. One entry point is enforced by modern languages, but one exit point is\n\nreally not a useful rule. Clarity is the key principle: If the method is clearer with one exit\n\npoint, use one exit point; otherwise don’t.\n\nMechanics\n\nSelect outermost condition that needs to be replaced, and change it into a guard\n\nclause.\n\nTest.\n\nRepeat as needed.\n\nIf all the guard clauses return the same result, use Consolidate Conditional\n\nExpression (263).\n\nExample\n\nHere’s some code to calculate a payment amount for an employee. It’s only relevant if\n\nthe employee is still with the company, so it has to check for the two other cases.\n\nClick here to view code image\n\nfunction payAmount(employee) { let result; if(employee.isSeparated) { result = {amount: 0, reasonCode: \"SEP\"}; } else { if (employee.isRetired) { result = {amount: 0, reasonCode: \"RET\"}; } else { // logic to compute amount lorem.ipsum(dolor.sitAmet); consectetur(adipiscing).elit(); sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua); ut.enim.ad(minim.veniam); result = someFinalComputation(); }\n\nwww.EBooksWorld.ir",
      "content_length": 1469,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 298,
      "content": "} return result; }\n\nNesting the conditionals here masks the true meaning of what it going on. The primary\n\npurpose of this code only applies if these conditions aren’t the case. In this situation,\n\nthe intention of the code reads more clearly with guard clauses.\n\nAs with any refactoring change, I like to take small steps, so I begin with the topmost\n\ncondition.\n\nClick here to view code image\n\nfunction payAmount(employee) { let result; if (employee.isSeparated) return {amount: 0, reasonCode: \"SEP\"}; if (employee.isRetired) { result = {amount: 0, reasonCode: \"RET\"}; } else { // logic to compute amount lorem.ipsum(dolor.sitAmet); consectetur(adipiscing).elit(); sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua); ut.enim.ad(minim.veniam); result = someFinalComputation(); } return result; }\n\nI test that change and move on to the next one.\n\nClick here to view code image\n\nfunction payAmount(employee) { let result; if (employee.isSeparated) return {amount: 0, reasonCode: \"SEP\"}; if (employee.isRetired) return {amount: 0, reasonCode: \"RET\"}; // logic to compute amount lorem.ipsum(dolor.sitAmet); consectetur(adipiscing).elit(); sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua); ut.enim.ad(minim.veniam); result = someFinalComputation(); return result; }\n\nwww.EBooksWorld.ir",
      "content_length": 1321,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 299,
      "content": "At which point the result variable isn’t really doing anything useful, so I remove it.\n\nClick here to view code image\n\nfunction payAmount(employee) { let result; if (employee.isSeparated) return {amount: 0, reasonCode: \"SEP\"}; if (employee.isRetired) return {amount: 0, reasonCode: \"RET\"}; // logic to compute amount lorem.ipsum(dolor.sitAmet); consectetur(adipiscing).elit(); sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua); ut.enim.ad(minim.veniam); return someFinalComputation(); }\n\nThe rule is that you always get an extra strawberry when you remove a mutable\n\nvariable.\n\nExample: Reversing the Conditions\n\nWhen reviewing the manuscript of the first edition of this book, Joshua Kerievsky\n\npointed out that we often do Replace Nested Conditional with Guard Clauses by\n\nreversing the conditional expressions. Even better, he gave me an example so I didn’t\n\nhave to further tax my imagination.\n\nClick here to view code image\n\nfunction adjustedCapital(anInstrument) { let result = 0; if (anInstrument.capital > 0) { if (anInstrument.interestRate > 0 && anInstrument.duration > 0) { result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor; } } return result; }\n\nAgain, I make the replacements one at a time, but this time I reverse the condition as I\n\nput in the guard clause.\n\nwww.EBooksWorld.ir",
      "content_length": 1349,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 300,
      "content": "Click here to view code image\n\nfunction adjustedCapital(anInstrument) { let result = 0; if (anInstrument.capital <= 0) return result; if (anInstrument.interestRate > 0 && anInstrument.duration > 0) { result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor; } return result; }\n\nThe next conditional is a bit more complicated, so I do it in two steps. First, I simply\n\nadd a not.\n\nClick here to view code image\n\nfunction adjustedCapital(anInstrument) { let result = 0; if (anInstrument.capital <= 0) return result; if (!(anInstrument.interestRate > 0 && anInstrument.duration > 0)) return result; result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor; return result; }\n\nLeaving nots in a conditional like that twists my mind around at a painful angle, so I\n\nsimplify it:\n\nClick here to view code image\n\nfunction adjustedCapital(anInstrument) { let result = 0; if (anInstrument.capital <= 0) return result; if (anInstrument.interestRate <= 0 || anInstrument.duration <= 0) return result; result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor; return result; }\n\nBoth of those lines have conditions with the same result, so I apply Consolidate\n\nConditional Expression (263).\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1317,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 301,
      "content": "function adjustedCapital(anInstrument) { let result = 0; if ( anInstrument.capital <= 0 || anInstrument.interestRate <= 0 || anInstrument.duration <= 0) return result; result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor; return result; }\n\nThe result variable is doing two things here. Its first setting to zero indicates what to\n\nreturn when the guard clause triggers; its second value is the final computation. I can\n\nget rid of it, which both eliminates its double usage and gets me a strawberry.\n\nClick here to view code image\n\nfunction adjustedCapital(anInstrument) { if ( anInstrument.capital <= 0 || anInstrument.interestRate <= 0 || anInstrument.duration <= 0) return 0; return (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor; }\n\nREPLACE CONDITIONAL WITH POLYMORPHISM\n\nwww.EBooksWorld.ir",
      "content_length": 859,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 302,
      "content": "Motivation\n\nComplex conditional logic is one of the hardest things to reason about in programming,\n\nso I always look for ways to add structure to conditional logic. Often, I find I can\n\nseparate the logic into different circumstances—high­level cases—to divide the\n\nconditions. Sometimes it’s enough to represent this division within the structure of a\n\nconditional itself, but using classes and polymorphism can make the separation more\n\nexplicit.\n\nA common case for this is where I can form a set of types, each handling the conditional\n\nlogic differently. I might notice that books, music, and food vary in how they are\n\nhandled because of their type. This is made most obvious when there are several\n\nfunctions that have a switch statement on a type code. In that case, I remove the\n\nduplication of the common switch logic by creating classes for each case and using www.EBooksWorld.ir",
      "content_length": 889,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 303,
      "content": "polymorphism to bring out the type­specific behavior.\n\nAnother situation is where I can think of the logic as a base case with variants. The base\n\ncase may be the most common or most straightforward. I can put this logic into a\n\nsuperclass which allows me to reason about it without having to worry about the\n\nvariants. I then put each variant case into a subclass, which I express with code that\n\nemphasizes its difference from the base case.\n\nPolymorphism is one of the key features of object­oriented programming—and, like any\n\nuseful feature, it’s prone to overuse. I’ve come across people who argue that all\n\nexamples of conditional logic should be replaced with polymorphism. I don’t agree with\n\nthat view. Most of my conditional logic uses basic conditional statements—if/else and\n\nswitch/case. But when I see complex conditional logic that can be improved as\n\ndiscussed above, I find polymorphism a powerful tool.\n\nMechanics\n\nIf classes do not exist for polymorphic behavior, create them together with a factory\n\nfunction to return the correct instance.\n\nUse the factory function in calling code.\n\nMove the conditional function to the superclass.\n\nIf the conditional logic is not a self­contained function, use Extract Function (106)\n\nto make it so.\n\nPick one of the subclasses. Create a subclass method that overrides the conditional\n\nstatement method. Copy the body of that leg of the conditional statement into the\n\nsubclass method and adjust it to fit.\n\nRepeat for each leg of the conditional.\n\nLeave a default case for the superclass method. Or, if superclass should be abstract,\n\ndeclare that method as abstract or throw an error to show it should be the\n\nresponsibility of a subclass.\n\nExample\n\nMy friend has a collection of birds and wants to know how fast they can fly and what\n\nthey have for plumage. So we have a couple of small programs to determine the\n\ninformation.\n\nwww.EBooksWorld.ir",
      "content_length": 1907,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 304,
      "content": "Click here to view code image\n\nfunction plumages(birds) {\n\nreturn new Map(birds.map(b => [b.name, plumage(b)])); } function speeds(birds) {\n\nreturn new Map(birds.map(b => [b.name, airSpeedVelocity(b)])); }\n\nfunction plumage(bird) {\n\nswitch (bird.type) { case 'EuropeanSwallow': return \"average\"; case 'AfricanSwallow': return (bird.numberOfCoconuts > 2) ? \"tired\" : \"average\"; case 'NorwegianBlueParrot': return (bird.voltage > 100) ? \"scorched\" : \"beautiful\"; default: return \"unknown\"; } }\n\nfunction airSpeedVelocity(bird) {\n\nswitch (bird.type) { case 'EuropeanSwallow': return 35; case 'AfricanSwallow': return 40 ­ 2 * bird.numberOfCoconuts; case 'NorwegianBlueParrot': return (bird.isNailed) ? 0 : 10 + bird.voltage / 10; default: return null; } }\n\nWe have a couple of different operations that vary with the type of bird, so it makes\n\nsense to create classes and use polymorphism for any type­specific behavior.\n\nI begin by using Combine Functions into Class (144) on airSpeedVelocity and\n\nplumage.\n\nClick here to view code image\n\nfunction plumage(bird) { return new Bird(bird).plumage; }\n\nfunction airSpeedVelocity(bird) { return new Bird(bird).airSpeedVelocity;\n\nwww.EBooksWorld.ir",
      "content_length": 1189,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 305,
      "content": "}\n\nclass Bird { constructor(birdObject) { Object.assign(this, birdObject); } get plumage() { switch (this.type) { case 'EuropeanSwallow': return \"average\"; case 'AfricanSwallow': return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\"; case 'NorwegianBlueParrot': return (this.voltage > 100) ? \"scorched\" : \"beautiful\"; default: return \"unknown\"; } } get airSpeedVelocity() { switch (this.type) { case 'EuropeanSwallow': return 35; case 'AfricanSwallow': return 40 ­ 2 * this.numberOfCoconuts; case 'NorwegianBlueParrot': return (this.isNailed) ? 0 : 10 + this.voltage / 10; default: return null; } } }\n\nI now add subclasses for each kind of bird, together with a factory function to\n\ninstantiate the appropriate subclass.\n\nClick here to view code image\n\nfunction plumage(bird) { return createBird(bird).plumage; }\n\nfunction airSpeedVelocity(bird) { return createBird(bird).airSpeedVelocity; }\n\nfunction createBird(bird) { switch (bird.type) { case 'EuropeanSwallow': return new EuropeanSwallow(bird); case 'AfricanSwallow': return new AfricanSwallow(bird); www.EBooksWorld.ir",
      "content_length": 1077,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 306,
      "content": "case 'NorweigianBlueParrot': return new NorwegianBlueParrot(bird); default: return new Bird(bird); } }\n\nclass EuropeanSwallow extends Bird { }\n\nclass AfricanSwallow extends Bird { }\n\nclass NorwegianBlueParrot extends Bird { }\n\nNow that I’ve created the class structure that I need, I can begin on the two conditional\n\nmethods. I’ll begin with plumage. I take one leg of the switch statement and override it\n\nin the appropriate subclass.\n\nclass EuropeanSwallow…\n\nget plumage() { return \"average\"; }\n\nclass Bird…\n\nClick here to view code image\n\nget plumage() { switch (this.type) { case 'EuropeanSwallow': throw \"oops\"; case 'AfricanSwallow': return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\"; case 'NorwegianBlueParrot': return (this.voltage > 100) ? \"scorched\" : \"beautiful\"; default: return \"unknown\"; } }\n\nI put in the throw because I’m paranoid.\n\nI can compile and test at this point. Then, if all is well, I do the next leg.\n\nwww.EBooksWorld.ir",
      "content_length": 955,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 307,
      "content": "class AfricanSwallow…\n\nClick here to view code image\n\nget plumage() { return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\"; }\n\nThen, the Norwegian Blue:\n\nclass NorwegianBlueParrot…\n\nClick here to view code image\n\nget plumage() { return (this.voltage > 100) ? \"scorched\" : \"beautiful\"; }\n\nI leave the superclass method for the default case.\n\nclass Bird…\n\nget plumage() { return \"unknown\"; }\n\nI repeat the same process for airSpeedVelocity. Once I’m done, I end up with the\n\nfollowing code (I also inlined the top­level functions for airSpeedVelocity and\n\nplumage):\n\nClick here to view code image\n\nfunction plumages(birds) {\n\nreturn new Map(birds .map(b => createBird(b)) .map(bird => [bird.name, bird.plumage])); } function speeds(birds) {\n\nreturn new Map(birds .map(b => createBird(b)) .map(bird => [bird.name, bird.airSpeedVelocity])); }\n\nfunction createBird(bird) {\n\nwww.EBooksWorld.ir",
      "content_length": 891,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 308,
      "content": "switch (bird.type) { case 'EuropeanSwallow': return new EuropeanSwallow(bird); case 'AfricanSwallow': return new AfricanSwallow(bird); case 'NorwegianBlueParrot': return new NorwegianBlueParrot(bird); default: return new Bird(bird); } }\n\nclass Bird {\n\nconstructor(birdObject) { Object.assign(this, birdObject); } get plumage() {\n\nreturn \"unknown\"; } get airSpeedVelocity() {\n\nreturn null; } } class EuropeanSwallow extends Bird { get plumage() {\n\nreturn \"average\"; } get airSpeedVelocity() {\n\nreturn 35; } } class AfricanSwallow extends Bird { get plumage() {\n\nreturn (this.numberOfCoconuts > 2) ? \"tired\" : \"average\"; } get airSpeedVelocity() {\n\nreturn 40 ­ 2 * this.numberOfCoconuts; } } class NorwegianBlueParrot extends Bird { get plumage() {\n\nreturn (this.voltage > 100) ? \"scorched\" : \"beautiful\"; } get airSpeedVelocity() {\n\nreturn (this.isNailed) ? 0 : 10 + this.voltage / 10; } }\n\nLooking at this final code, I can see that the superclass Bird isn’t strictly needed. In\n\nJavaScript, I don’t need a type hierarchy for polymorphism; as long as my objects\n\nimplement the appropriately named methods, everything works fine. In this situation,\n\nwww.EBooksWorld.ir",
      "content_length": 1167,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 309,
      "content": "however, I like to keep the unnecessary superclass as it helps explain the way the\n\nclasses are related in the domain.\n\nExample: Using Polymorphism for Variation\n\nWith the birds example, I’m using a clear generalization hierarchy. That’s how\n\nsubclassing and polymorphism is often discussed in textbooks (including mine)—but\n\nit’s not the only way inheritance is used in practice; indeed, it probably isn’t the most\n\ncommon or best way. Another case for inheritance is when I wish to indicate that one\n\nobject is mostly similar to another, but with some variations.\n\nAs an example of this case, consider some code used by a rating agency to compute an\n\ninvestment rating for the voyages of sailing ships. The rating agency gives out either an\n\n“A” or “B” rating, depending of various factors due to risk and profit potential. The risk\n\ncomes from assessing the nature of the voyage as well as the history of the captain’s\n\nprior voyages.\n\nClick here to view code image\n\nfunction rating(voyage, history) {\n\nconst vpf = voyageProfitFactor(voyage, history); const vr = voyageRisk(voyage); const chr = captainHistoryRisk(voyage, history); if (vpf * 3 > (vr + chr * 2)) return \"A\"; else return \"B\"; } function voyageRisk(voyage) {\n\nlet result = 1; if (voyage.length > 4) result += 2; if (voyage.length > 8) result += voyage.length ­ 8; if ([\"china\", \"east­indies\"].includes(voyage.zone)) result += 4; return Math.max(result, 0); } function captainHistoryRisk(voyage, history) {\n\nlet result = 1; if (history.length < 5) result += 4; result += history.filter(v => v.profit < 0).length; if (voyage.zone === \"china\" && hasChina(history)) result ­= 2; return Math.max(result, 0); } function hasChina(history) {\n\nreturn history.some(v => \"china\" === v.zone); } function voyageProfitFactor(voyage, history) {\n\nlet result = 2; if (voyage.zone === \"china\") result += 1; if (voyage.zone === \"east­indies\") result += 1; if (voyage.zone === \"china\" && hasChina(history)) {\n\nwww.EBooksWorld.ir",
      "content_length": 1975,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 310,
      "content": "result += 3; if (history.length > 10) result += 1; if (voyage.length > 12) result += 1; if (voyage.length > 18) result ­= 1; } else { if (history.length > 8) result += 1; if (voyage.length > 14) result ­= 1; } return result; }\n\nThe functions voyageRisk and captainHistoryRisk score points for risk,\n\nvoyageProfitFactor scores points for the potential profit, and rating combines\n\nthese to give the overall rating for the voyage.\n\nThe calling code would look something like this:\n\nClick here to view code image\n\nconst voyage = {zone: \"west­indies\", length: 10}; const history = [ {zone: \"east­indies\", profit: 5}, {zone: \"west­indies\", profit: 15}, {zone: \"china\", profit: ­2}, {zone: \"west­africa\", profit: 7}, ];\n\nconst myRating = rating(voyage, history);\n\nWhat I want to focus on here is how a couple of places use conditional logic to handle\n\nthe case of a voyage to China where the captain has been to China before.\n\nClick here to view code image\n\nfunction rating(voyage, history) { const vpf = voyageProfitFactor(voyage, history); const vr = voyageRisk(voyage); const chr = captainHistoryRisk(voyage, history); if (vpf * 3 > (vr + chr * 2)) return \"A\"; else return \"B\"; } function voyageRisk(voyage) { let result = 1; if (voyage.length > 4) result += 2; if (voyage.length > 8) result += voyage.length ­ 8; if ([\"china\", \"east­indies\"].includes(voyage.zone)) result += 4;\n\nwww.EBooksWorld.ir",
      "content_length": 1395,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 311,
      "content": "return Math.max(result, 0); } function captainHistoryRisk(voyage, history) { let result = 1; if (history.length < 5) result += 4; result += history.filter(v => v.profit < 0).length; if (voyage.zone === \"china\" && hasChina(history)) result ­= 2; return Math.max(result, 0); } function hasChina(history) { return history.some(v => \"china\" === v.zone); } function voyageProfitFactor(voyage, history) { let result = 2; if (voyage.zone === \"china\") result += 1; if (voyage.zone === \"east­indies\") result += 1; if (voyage.zone === \"china\" && hasChina(history)) { result += 3; if (history.length > 10) result += 1; if (voyage.length > 12) result += 1; if (voyage.length > 18) result ­= 1; } else { if (history.length > 8) result += 1; if (voyage.length > 14) result ­= 1; } return result; }\n\nI will use inheritance and polymorphism to separate out the logic for handling these\n\ncases from the base logic. This is a particularly useful refactoring if I’m about to\n\nintroduce more special logic for this case—and the logic for these repeat China voyages\n\ncan make it harder to understand the base case.\n\nI’m beginning with a set of functions. To introduce polymorphism, I need to create a\n\nclass structure, so I begin by applying Combine Functions into Class (144). This results\n\nin the following code:\n\nClick here to view code image\n\nfunction rating(voyage, history) {\n\nreturn new Rating(voyage, history).value; }\n\nclass Rating {\n\nconstructor(voyage, history) { this.voyage = voyage; this.history = history; }\n\nwww.EBooksWorld.ir",
      "content_length": 1521,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 312,
      "content": "get value() { const vpf = this.voyageProfitFactor; const vr = this.voyageRisk; const chr = this.captainHistoryRisk; if (vpf * 3 > (vr + chr * 2)) return \"A\"; else return \"B\"; } get voyageRisk() { let result = 1; if (this.voyage.length > 4) result += 2; if (this.voyage.length > 8) result += this.voyage.length ­ 8; if ([\"china\", \"east­indies\"].includes(this.voyage.zone)) result += 4; return Math.max(result, 0); } get captainHistoryRisk() { let result = 1; if (this.history.length < 5) result += 4; result += this.history.filter(v => v.profit < 0).length; if (this.voyage.zone === \"china\" && this.hasChinaHistory) result ­= 2; return Math.max(result, 0); } get voyageProfitFactor() { let result = 2;\n\nif (this.voyage.zone === \"china\") result += 1; if (this.voyage.zone === \"east­indies\") result += 1; if (this.voyage.zone === \"china\" && this.hasChinaHistory) { result += 3; if (this.history.length > 10) result += 1; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; } else { if (this.history.length > 8) result += 1; if (this.voyage.length > 14) result ­= 1; } return result; } get hasChinaHistory() { return this.history.some(v => \"china\" === v.zone); } }\n\nThat’s given me the class for the base case. I now need to create an empty subclass to\n\nhouse the variant behavior.\n\nClick here to view code image\n\nclass ExperiencedChinaRating extends Rating { }\n\nwww.EBooksWorld.ir",
      "content_length": 1409,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 313,
      "content": "I then create a factory function to return the variant class when needed.\n\nClick here to view code image\n\nfunction createRating(voyage, history) { if (voyage.zone === \"china\" && history.some(v => \"china\" === v.zone)) return new ExperiencedChinaRating(voyage, history); else return new Rating(voyage, history); }\n\nI need to modify any callers to use the factory function instead of directly invoking the\n\nconstructor, which in this case is just the rating function.\n\nClick here to view code image\n\nfunction rating(voyage, history) { return createRating(voyage, history).value; }\n\nThere are two bits of behavior I need to move into a subclass. I begin with the logic in\n\ncaptainHistoryRisk:\n\nclass Rating…\n\nClick here to view code image\n\nget captainHistoryRisk() { let result = 1; if (this.history.length < 5) result += 4; result += this.history.filter(v => v.profit < 0).length; if (this.voyage.zone === \"china\" && this.hasChinaHistory) result ­= 2; return Math.max(result, 0); }\n\nI write the overriding method in the subclass:\n\nclass ExperiencedChinaRating\n\nClick here to view code image\n\nget captainHistoryRisk() {\n\nwww.EBooksWorld.ir",
      "content_length": 1135,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 314,
      "content": "const result = super.captainHistoryRisk ­ 2; return Math.max(result, 0); }\n\nclass Rating…\n\nClick here to view code image\n\nget captainHistoryRisk() { let result = 1; if (this.history.length < 5) result += 4; result += this.history.filter(v => v.profit < 0).length; if (this.voyage.zone === \"china\" && this.hasChinaHistory) result ­= 2; return Math.max(result, 0); }\n\nSeparating the variant behavior from voyageProfitFactor is a bit more messy. I\n\ncan’t simply remove the variant behavior and call the superclass method since there is\n\nan alternative path here. I also don’t want to copy the whole superclass method down to\n\nthe subclass.\n\nclass Rating…\n\nClick here to view code image\n\nget voyageProfitFactor() { let result = 2;\n\nif (this.voyage.zone === \"china\") result += 1; if (this.voyage.zone === \"east­indies\") result += 1; if (this.voyage.zone === \"china\" && this.hasChinaHistory) { result += 3; if (this.history.length > 10) result += 1; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; } else { if (this.history.length > 8) result += 1; if (this.voyage.length > 14) result ­= 1; } return result; }\n\nSo my response is to first use Extract Function (106) on the entire conditional block.\n\nwww.EBooksWorld.ir",
      "content_length": 1247,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 315,
      "content": "class Rating…\n\nClick here to view code image\n\nget voyageProfitFactor() { let result = 2;\n\nif (this.voyage.zone === \"china\") result += 1; if (this.voyage.zone === \"east­indies\") result += 1; result += this.voyageAndHistoryLengthFactor; return result; }\n\nget voyageAndHistoryLengthFactor() { let result = 0; if (this.voyage.zone === \"china\" && this.hasChinaHistory) { result += 3; if (this.history.length > 10) result += 1; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; } else { if (this.history.length > 8) result += 1; if (this.voyage.length > 14) result ­= 1; } return result; }\n\nA function name with an “And” in it is a pretty bad smell, but I’ll let it sit and reek for a\n\nmoment, while I apply the subclassing.\n\nclass Rating…\n\nClick here to view code image\n\nget voyageAndHistoryLengthFactor() { let result = 0; if (this.history.length > 8) result += 1; if (this.voyage.length > 14) result ­= 1; return result; }\n\nclass ExperiencedChinaRating…\n\nClick here to view code image\n\nget voyageAndHistoryLengthFactor() {\n\nwww.EBooksWorld.ir",
      "content_length": 1073,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 316,
      "content": "let result = 0; result += 3; if (this.history.length > 10) result += 1; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; return result; }\n\nThat’s, formally, the end of the refactoring—I’ve separated the variant behavior out into\n\nthe subclass. The superclass’s logic is simpler to understand and work with, and I only\n\nneed to deal with variant case when I’m working on the subclass code, which is\n\nexpressed in terms of its difference with the superclass.\n\nBut I feel I should at least outline what I’d do with the awkward new method.\n\nIntroducing a method purely for overriding by a subclass is a common thing to do when\n\ndoing this kind of base­and­variation inheritance. But a crude method like this\n\nobscures what’s going on, instead of revealing.\n\nThe “And” gives away that there are really two separate modifications going on here—so\n\nI think it’s wise to separate them. I’ll do this by using Extract Function (106) on the\n\nhistory length modification, both in the superclass and subclass. I start with just the\n\nsuperclass:\n\nclass Rating…\n\nClick here to view code image\n\nget voyageAndHistoryLengthFactor() { let result = 0; result += this.historyLengthFactor; if (this.voyage.length > 14) result ­= 1; return result; } get historyLengthFactor() { return (this.history.length > 8) ? 1 : 0; }\n\nI do the same with the subclass:\n\nclass ExperiencedChinaRating…\n\nClick here to view code image\n\nget voyageAndHistoryLengthFactor() {\n\nwww.EBooksWorld.ir",
      "content_length": 1487,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 317,
      "content": "let result = 0; result += 3; result += this.historyLengthFactor; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; return result; } get historyLengthFactor() { return (this.history.length > 10) ? 1 : 0; }\n\nI can then use Move Statements to Callers (217) on the superclass case.\n\nclass Rating…\n\nClick here to view code image\n\nget voyageProfitFactor() { let result = 2; if (this.voyage.zone === \"china\") result += 1; if (this.voyage.zone === \"east­indies\") result += 1; result += this.historyLengthFactor; result += this.voyageAndHistoryLengthFactor; return result; } get voyageAndHistoryLengthFactor() { let result = 0; result += this.historyLengthFactor; if (this.voyage.length > 14) result ­= 1; return result; }\n\nclass ExperiencedChinaRating…\n\nClick here to view code image\n\nget voyageAndHistoryLengthFactor() { let result = 0; result += 3; result += this.historyLengthFactor; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; return result; }\n\nI’d then use Rename Function (124).\n\nwww.EBooksWorld.ir",
      "content_length": 1070,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 318,
      "content": "class Rating…\n\nClick here to view code image\n\nget voyageProfitFactor() { let result = 2; if (this.voyage.zone === \"china\") result += 1; if (this.voyage.zone === \"east­indies\") result += 1; result += this.historyLengthFactor; result += this.voyageLengthFactor; return result; }\n\nget voyageLengthFactor() { return (this.voyage.length > 14) ? ­ 1: 0; }\n\nChanging to a ternary to simplify voyageLengthFactor.\n\nclass ExperiencedChinaRating…\n\nClick here to view code image\n\nget voyageLengthFactor() { let result = 0; result += 3; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; return result; }\n\nOne last thing. I don’t think adding 3 points makes sense as part of the voyage length\n\nfactor—it’s better added to the overall result.\n\nclass ExperiencedChinaRating…\n\nClick here to view code image\n\nget voyageProfitFactor() { return super.voyageProfitFactor + 3; }\n\nget voyageLengthFactor() { let result = 0; result += 3; if (this.voyage.length > 12) result += 1;\n\nwww.EBooksWorld.ir",
      "content_length": 1009,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 319,
      "content": "if (this.voyage.length > 18) result ­= 1; return result; }\n\nAt the end of the refactoring, I have the following code. First, there is the basic rating\n\nclass which can ignore any complications of the experienced China case:\n\nClick here to view code image\n\nclass Rating {\n\nconstructor(voyage, history) { this.voyage = voyage; this.history = history; } get value() {\n\nconst vpf = this.voyageProfitFactor; const vr = this.voyageRisk; const chr = this.captainHistoryRisk; if (vpf * 3 > (vr + chr * 2)) return \"A\"; else return \"B\"; } get voyageRisk() {\n\nlet result = 1; if (this.voyage.length > 4) result += 2; if (this.voyage.length > 8) result += this.voyage.length ­ 8; if ([\"china\", \"east­indies\"].includes(this.voyage.zone)) result += 4; return Math.max(result, 0); } get captainHistoryRisk() {\n\nlet result = 1; if (this.history.length < 5) result += 4; result += this.history.filter(v => v.profit < 0).length; return Math.max(result, 0); } get voyageProfitFactor() {\n\nlet result = 2; if (this.voyage.zone === \"china\") result += 1; if (this.voyage.zone === \"east­indies\") result += 1; result += this.historyLengthFactor; result += this.voyageLengthFactor; return result; } get voyageLengthFactor() {\n\nreturn (this.voyage.length > 14) ? ­ 1: 0; } get historyLengthFactor() {\n\nreturn (this.history.length > 8) ? 1 : 0; } }\n\nwww.EBooksWorld.ir",
      "content_length": 1340,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 320,
      "content": "The code for the experienced China case reads as a set of variations on the base:\n\nClick here to view code image\n\nclass ExperiencedChinaRating extends Rating { get captainHistoryRisk() {\n\nconst result = super.captainHistoryRisk ­ 2; return Math.max(result, 0); } get voyageLengthFactor() {\n\nlet result = 0; if (this.voyage.length > 12) result += 1; if (this.voyage.length > 18) result ­= 1; return result; } get historyLengthFactor() {\n\nreturn (this.history.length > 10) ? 1 : 0; } get voyageProfitFactor() {\n\nreturn super.voyageProfitFactor + 3; } }\n\nINTRODUCE SPECIAL CASE\n\nformerly: Introduce Null Object\n\nMotivation\n\nA common case of duplicated code is when many users of a data structure check a\n\nspecific value, and then most of them do the same thing. If I find many parts of the code\n\nwww.EBooksWorld.ir",
      "content_length": 811,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 321,
      "content": "base having the same reaction to a particular value, I want to bring that reaction into a\n\nsingle place.\n\nA good mechanism for this is the Special Case pattern where I create a special­case\n\nelement that captures all the common behavior. This allows me to replace most of the\n\nspecial­case checks with simple calls.\n\nA special case can manifest itself in several ways. If all I’m doing with the object is\n\nreading data, I can supply a literal object with all the values I need filled in. If I need\n\nmore behavior than simple values, I can create a special object with methods for all the\n\ncommon behavior. The special­case object can be returned by an encapsulating class, or\n\ninserted into a data structure with a transform.\n\nA common value that needs special­case processing is null, which is why this pattern is\n\noften called the Null Object pattern. But it’s the same approach for any special case—I\n\nlike to say that Null Object is a special case of Special Case.\n\nMechanics\n\nBegin with a container data structure (or class) that contains a property which is the\n\nsubject of the refactoring. Clients of the container compare the subject property of\n\nthe container to a special­case value. We wish to replace the special­case value of the\n\nsubject with a special case class or data structure.\n\nAdd a special­case check property to the subject, returning false.\n\nCreate a special­case object with only the special­case check property, returning\n\ntrue.\n\nApply Extract Function (106) to the special­case comparison code. Ensure that all\n\nclients use the new function instead of directly comparing it.\n\nIntroduce the new special­case subject into the code, either by returning it from a\n\nfunction call or by applying a transform function.\n\nChange the body of the special­case comparison function so that it uses the special­\n\ncase check property.\n\nTest.\n\nUse Combine Functions into Class (144) or Combine Functions into Transform\n\n(149) to move all of the common special­case behavior into the new element.\n\nwww.EBooksWorld.ir",
      "content_length": 2026,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 322,
      "content": "Since the special­case class usually returns fixed values to simple requests, these\n\nmay be handled by making the special case a literal record.\n\nUse Inline Function (115) on the special­case comparison function for the places\n\nwhere it’s still needed.\n\nExample\n\nA utility company installs its services in sites.\n\nclass Site…\n\nClick here to view code image\n\nget customer() {return this._customer;}\n\nThere are various properties of the customer class; I’ll consider three of them.\n\nclass Customer…\n\nget name() {...} get billingPlan() {...} set billingPlan(arg) {...} get paymentHistory() {...}\n\nMost of the time, a site has a customer, but sometimes there isn’t one. Someone may\n\nhave moved out and I don’t yet know who, if anyone, has moved in. When this happens,\n\nthe data record fills the customer field with the string “unknown”. Because this can\n\nhappen, clients of the site need to be able to handle an unknown customer. Here are\n\nsome example fragments:\n\nclient 1…\n\nClick here to view code image\n\nconst aCustomer = site.customer; // ... lots of intervening code ... let customerName; if (aCustomer === \"unknown\") customerName = \"occupant\"; else customerName = aCustomer.name;\n\nclient 2…\n\nwww.EBooksWorld.ir",
      "content_length": 1212,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 323,
      "content": "Click here to view code image\n\nconst plan = (aCustomer === \"unknown\") ? registry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nif (aCustomer !== \"unknown\") aCustomer.billingPlan = newPlan;\n\nclient 4…\n\nClick here to view code image\n\nconst weeksDelinquent = (aCustomer === \"unknown\") ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nLooking through the code base, I see many clients of the site object that have to deal\n\nwith an unknown customer. Most of them do the same thing when they get one: They\n\nuse “occupant” as the name, give them a basic billing plan, and class them as zero­\n\nweeks delinquent. This widespread testing for a special case, plus a common response,\n\nis what tells me it’s time for a Special Case Object.\n\nI begin by adding a method to the customer to indicate it is unknown.\n\nclass Customer…\n\nget isUnknown() {return false;}\n\nI then add an Unknown Customer class.\n\nClick here to view code image\n\nclass UnknownCustomer { get isUnknown() {return true;} }\n\nwww.EBooksWorld.ir",
      "content_length": 1046,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 324,
      "content": "Note that I don’t make UnknownCustomer a subclass of Customer. In other\n\nlanguages, particularly those statically typed, I would, but JavaScript’s rules for\n\nsubclassing, as well as its dynamic typing, make it better to not do that here.\n\nNow comes the tricky bit. I have to return this new special­case object whenever I\n\nexpect \"unknown\" and change each test for an unknown value to use the new\n\nisUnknown method. In general, I always want to arrange things so I can make one\n\nsmall change at a time, then test. But if I change the customer class to return an\n\nunknown customer instead of “unknown”, I have to make every client testing for\n\n“unknown” to call isUnknown—and I have to do it all at once. I find that as appealing\n\nas eating liver (i.e., not at all).\n\nThere is a common technique to use whenever I find myself in this bind. I use Extract\n\nFunction (106) on the code that I’d have to change in lots of places—in this case, the\n\nspecial­case comparison code.\n\nClick here to view code image\n\nfunction isUnknown(arg) { if (!((arg instanceof Customer) || (arg === \"unknown\"))) throw new Error(`investigate bad value: <${arg}>`); return (arg === \"unknown\"); }\n\nI’ve put a trap in here for an unexpected value. This can help me to spot any mistakes or\n\nodd behavior as I’m doing this refactoring.\n\nI can now use this function whenever I’m testing for an unknown customer. I can\n\nchange these calls one at a time, testing after each change.\n\nclient 1…\n\nClick here to view code image\n\nlet customerName; if (isUnknown(aCustomer)) customerName = \"occupant\"; else customerName = aCustomer.name;\n\nAfter a while, I have done them all.\n\nclient 2…\n\nwww.EBooksWorld.ir",
      "content_length": 1666,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 325,
      "content": "Click here to view code image\n\nconst plan = (isUnknown(aCustomer)) ? registry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nif (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan;\n\nclient 4…\n\nClick here to view code image\n\nconst weeksDelinquent = isUnknown(aCustomer) ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nOnce I’ve changed all the callers to use isUnknown, I can change the site class to return\n\nan unknown customer.\n\nclass Site…\n\nClick here to view code image\n\nget customer() { return (this._customer === \"unknown\") ? new UnknownCustomer() : this._customer; }\n\nI can check that I’m no longer using the “unknown” string by changing isUnknown to\n\nuse the unknown value.\n\nclient 1…\n\nClick here to view code image\n\nfunction isUnknown(arg) { if (!(arg instanceof Customer || arg instanceof UnknownCustomer)) throw new Error(`investigate bad value: <${arg}>`);\n\nwww.EBooksWorld.ir",
      "content_length": 942,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 326,
      "content": "return arg.isUnknown; }\n\nI test to ensure that’s all working.\n\nNow the fun begins. I can use Combine Functions into Class (144) to take each client’s\n\nspecial­case check and see if I can replace it with a commonly expected value. At the\n\nmoment, I have various clients using “occupant” for the name of an unknown customer,\n\nlike this:\n\nclient 1…\n\nClick here to view code image\n\nlet customerName; if (isUnknown(aCustomer)) customerName = \"occupant\"; else customerName = aCustomer.name;\n\nI add a suitable method to the unknown customer:\n\nclass UnknownCustomer…\n\nClick here to view code image\n\nget name() {return \"occupant\";}\n\nNow I can make all that conditional code go away.\n\nclient 1…\n\nClick here to view code image\n\nconst customerName = aCustomer.name;\n\nOnce I’ve tested that this works, I’ll probably be able to use Inline Variable (123) on\n\nthat variable too.\n\nNext is the billing plan property.\n\nclient 2…\n\nwww.EBooksWorld.ir",
      "content_length": 929,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 327,
      "content": "Click here to view code image\n\nconst plan = (isUnknown(aCustomer)) ? registry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nif (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan;\n\nFor read behavior, I do the same thing I did with the name—take the common response\n\nand reply with it. With the write behavior, the current code doesn’t call the setter for an\n\nunknown customer—so for the special case, I let the setter be called, but it does\n\nnothing.\n\nclass UnknownCustomer…\n\nClick here to view code image\n\nget billingPlan() {return registry.billingPlans.basic;} set billingPlan(arg) { /* ignore */ }\n\nclient reader…\n\nClick here to view code image\n\nconst plan = aCustomer.billingPlan;\n\nclient writer…\n\nClick here to view code image\n\naCustomer.billingPlan = newPlan;\n\nSpecial­case objects are value objects, and thus should always be immutable, even if the\n\nobjects they are substituting for are not.\n\nThe last case is a bit more involved because the special case needs to return another\n\nwww.EBooksWorld.ir",
      "content_length": 1051,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 328,
      "content": "object that has its own properties.\n\nclient…\n\nClick here to view code image\n\nconst weeksDelinquent = isUnknown(aCustomer) ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nThe general rule with a special­case object is that if it needs to return related objects,\n\nthey are usually special cases themselves. So here I need to create a null payment\n\nhistory.\n\nclass UnknownCustomer…\n\nClick here to view code image\n\nget paymentHistory() {return new NullPaymentHistory();}\n\nclass NullPaymentHistory…\n\nClick here to view code image\n\nget weeksDelinquentInLastYear() {return 0;}\n\nclient…\n\nClick here to view code image\n\nconst weeksDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nI carry on, looking at all the clients to see if I can replace them with the polymorphic\n\nbehavior. But there will be exceptions—clients that want to do something different with\n\nthe special case. I may have 23 clients that use “occupant” for the name of an unknown\n\ncustomer, but there’s always one that needs something different.\n\nclient…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1090,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 329,
      "content": "const name = ! isUnknown(aCustomer) ? aCustomer.name : \"unknown occupant\";\n\nIn that case, I need to retain a special­case check. I will change it to use the method on\n\ncustomer, essentially using Inline Function (115) on isUnknown.\n\nclient…\n\nClick here to view code image\n\nconst name = aCustomer.isUnknown ? \"unknown occupant\" : aCustomer.name;\n\nWhen I’m done with all the clients, I should be able to use Remove Dead Code (237) on\n\nthe global isPresent function, as nobody should be calling it any more.\n\nExample: Using an Object Literal\n\nCreating a class like this is a fair bit of work for what is really a simple value. But for the\n\nexample I gave, I had to make the class since the customer could be updated. If,\n\nhowever, I only read the data structure, I can use a literal object instead.\n\nHere is the opening case again—just the same, except this time there is no client that\n\nupdates the customer:\n\nclass Site…\n\nClick here to view code image\n\nget customer() {return this._customer;}\n\nclass Customer…\n\nget name() {...} get billingPlan() {...} set billingPlan(arg) {...} get paymentHistory() {...}\n\nclient 1…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1166,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 330,
      "content": "const aCustomer = site.customer; // ... lots of intervening code ... let customerName; if (aCustomer === \"unknown\") customerName = \"occupant\"; else customerName = aCustomer.name;\n\nclient 2…\n\nClick here to view code image\n\nconst plan = (aCustomer === \"unknown\") ? registry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nconst weeksDelinquent = (aCustomer === \"unknown\") ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nAs with the previous case, I start by adding an isUnknown property to the customer\n\nand creating a special­case object with that field. The difference is that this time, the\n\nspecial case is a literal.\n\nclass Customer…\n\nget isUnknown() {return false;}\n\ntop level…\n\nClick here to view code image\n\nfunction createUnknownCustomer() { return { isUnknown: true, }; }\n\nI apply Extract Function (106) to the special case condition test.\n\nwww.EBooksWorld.ir",
      "content_length": 917,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 331,
      "content": "Click here to view code image\n\nfunction isUnknown(arg) { return (arg === \"unknown\"); }\n\nclient 1…\n\nClick here to view code image\n\nlet customerName; if (isUnknown(aCustomer)) customerName = \"occupant\"; else customerName = aCustomer.name;\n\nclient 2…\n\nClick here to view code image\n\nconst plan = isUnknown(aCustomer) ? registry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nconst weeksDelinquent = isUnknown(aCustomer) ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nI change the site class and the condition test to work with the special case.\n\nclass Site…\n\nClick here to view code image\n\nget customer() { return (this._customer === \"unknown\") ? createUnknownCustomer() : this._customer; }\n\ntop level…\n\nwww.EBooksWorld.ir",
      "content_length": 771,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 332,
      "content": "Click here to view code image\n\nfunction isUnknown(arg) { return arg.isUnknown; }\n\nThen I replace each standard response with the appropriate literal value. I start with\n\nthe name:\n\nClick here to view code image\n\nfunction createUnknownCustomer() { return { isUnknown: true, name: \"occupant\", }; }\n\nclient 1…\n\nClick here to view code image\n\nconst customerName = aCustomer.name;\n\nThen, the billing plan:\n\nClick here to view code image\n\nfunction createUnknownCustomer() { return { isUnknown: true, name: \"occupant\", billingPlan: registry.billingPlans.basic, }; }\n\nclient 2…\n\nClick here to view code image\n\nconst plan = aCustomer.billingPlan;\n\nwww.EBooksWorld.ir",
      "content_length": 657,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 333,
      "content": "Similarly, I can create a nested null payment history with the literal:\n\nClick here to view code image\n\nfunction createUnknownCustomer() { return { isUnknown: true, name: \"occupant\", billingPlan: registry.billingPlans.basic, paymentHistory: { weeksDelinquentInLastYear: 0, }, }; }\n\nclient 3…\n\nClick here to view code image\n\nconst weeksDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nIf I use a literal like this, I should make it immutable, which I might do with freeze.\n\nUsually, I’d rather use a class.\n\nExample: Using a Transform\n\nBoth previous cases involve a class, but the same idea can be applied to a record by\n\nusing a transform step.\n\nLet’s assume our input is a simple record structure that looks something like this:\n\nClick here to view code image\n\n{ name: \"Acme Boston\", location: \"Malden MA\", // more site details customer: { name: \"Acme Industries\", billingPlan: \"plan­451\", paymentHistory: { weeksDelinquentInLastYear: 7 //more }, // more\n\nwww.EBooksWorld.ir",
      "content_length": 992,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 334,
      "content": "} }\n\nIn some cases, the customer isn’t known, and such cases are marked in the same way:\n\nClick here to view code image\n\n{ name: \"Warehouse Unit 15\", location: \"Malden MA\", // more site details customer: \"unknown\", }\n\nI have similar client code that checks for the unknown customer:\n\nclient 1…\n\nClick here to view code image\n\nconst site = acquireSiteData(); const aCustomer = site.customer; // ... lots of intervening code ... let customerName; if (aCustomer === \"unknown\") customerName = \"occupant\"; else customerName = aCustomer.name;\n\nclient 2…\n\nClick here to view code image\n\nconst plan = (aCustomer === \"unknown\") ? registry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nconst weeksDelinquent = (aCustomer === \"unknown\") ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nwww.EBooksWorld.ir",
      "content_length": 844,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 335,
      "content": "My first step is to run the site data structure through a transform that, currently, does\n\nnothing but a deep copy.\n\nclient 1…\n\nClick here to view code image\n\nconst rawSite = acquireSiteData(); const site = enrichSite(rawSite); const aCustomer = site.customer; // ... lots of intervening code ... let customerName; if (aCustomer === \"unknown\") customerName = \"occupant\"; else customerName = aCustomer.name;\n\nfunction enrichSite(inputSite) { return _.cloneDeep(inputSite); }\n\nI apply Extract Function (106) to the test for an unknown customer.\n\nClick here to view code image\n\nfunction isUnknown(aCustomer) { return aCustomer === \"unknown\"; }\n\nclient 1…\n\nClick here to view code image\n\nconst rawSite = acquireSiteData(); const site = enrichSite(rawSite); const aCustomer = site.customer; // ... lots of intervening code ... let customerName; if (isUnknown(aCustomer)) customerName = \"occupant\"; else customerName = aCustomer.name;\n\nclient 2…\n\nClick here to view code image\n\nconst plan = (isUnknown(aCustomer)) ?\n\nwww.EBooksWorld.ir",
      "content_length": 1029,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 336,
      "content": "registry.billingPlans.basic : aCustomer.billingPlan;\n\nclient 3…\n\nClick here to view code image\n\nconst weeksDelinquent = (isUnknown(aCustomer)) ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nI begin the enrichment by adding an isUnknown property to the customer.\n\nClick here to view code image\n\nfunction enrichSite(aSite) { const result = _.cloneDeep(aSite); const unknownCustomer = { isUnknown: true, };\n\nif (isUnknown(result.customer)) result.customer = unknownCustomer; else result.customer.isUnknown = false; return result; }\n\nI can then modify the special­case condition test to include probing for this new\n\nproperty. I keep the original test as well, so that the test will work on both raw and\n\nenriched sites.\n\nClick here to view code image\n\nfunction isUnknown(aCustomer) { if (aCustomer === \"unknown\") return true; else return aCustomer.isUnknown; }\n\nI test to ensure that’s all OK, then start applying Combine Functions into Transform\n\n(149) on the special case. First, I move the choice of name into the enrichment function.\n\nClick here to view code image\n\nfunction enrichSite(aSite) {\n\nwww.EBooksWorld.ir",
      "content_length": 1127,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 337,
      "content": "const result = _.cloneDeep(aSite); const unknownCustomer = { isUnknown: true, name: \"occupant\", };\n\nif (isUnknown(result.customer)) result.customer = unknownCustomer; else result.customer.isUnknown = false; return result; }\n\nclient 1…\n\nClick here to view code image\n\nconst rawSite = acquireSiteData(); const site = enrichSite(rawSite); const aCustomer = site.customer; // ... lots of intervening code ... const customerName = aCustomer.name;\n\nI test, then do the billing plan.\n\nClick here to view code image\n\nfunction enrichSite(aSite) { const result = _.cloneDeep(aSite); const unknownCustomer = { isUnknown: true, name: \"occupant\", billingPlan: registry.billingPlans.basic, };\n\nif (isUnknown(result.customer)) result.customer = unknownCustomer; else result.customer.isUnknown = false; return result; }\n\nclient 2…\n\nClick here to view code image\n\nconst plan = aCustomer.billingPlan;\n\nI test again, then do the last client.\n\nwww.EBooksWorld.ir",
      "content_length": 942,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 338,
      "content": "Click here to view code image\n\nfunction enrichSite(aSite) { const result = _.cloneDeep(aSite); const unknownCustomer = { isUnknown: true, name: \"occupant\", billingPlan: registry.billingPlans.basic, paymentHistory: { weeksDelinquentInLastYear: 0, } };\n\nif (isUnknown(result.customer)) result.customer = unknownCustomer; else result.customer.isUnknown = false; return result; }\n\nclient 3…\n\nClick here to view code image\n\nconst weeksDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear;\n\nINTRODUCE ASSERTION\n\nMotivation\n\nOften, sections of code work only if certain conditions are true. This may be as simple\n\nas a square root calculation only working on a positive input value. With an object, it\n\nwww.EBooksWorld.ir",
      "content_length": 725,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 339,
      "content": "may require that at least one of a group of fields has a value in it.\n\nSuch assumptions are often not stated but can only be deduced by looking through an\n\nalgorithm. Sometimes, the assumptions are stated with a comment. A better technique\n\nis to make the assumption explicit by writing an assertion.\n\nAn assertion is a conditional statement that is assumed to be always true. Failure of an\n\nassertion indicates a programmer error. Assertion failures should never be checked by\n\nother parts of the system. Assertions should be written so that the program functions\n\nequally correctly if they are all removed; indeed, some languages provide assertions\n\nthat can be disabled by a compile­time switch.\n\nI often see people encourage using assertions in order to find errors. While this is\n\ncertainly a Good Thing, it’s not the only reason to use them. I find assertions to be a\n\nvaluable form of communication—they tell the reader something about the assumed\n\nstate of the program at this point of execution. I also find them handy for debugging,\n\nand their communication value means I’m inclined to leave them in once I’ve fixed the\n\nerror I’m chasing. Self­testing code reduces their value for debugging, as steadily\n\nnarrowing unit tests often do the job better, but I still like assertions for\n\ncommunication.\n\nMechanics\n\nWhen you see that a condition is assumed to be true, add an assertion to state it.\n\nSince assertions should not affect the running of a system, adding one is always\n\nbehavior­preserving.\n\nExample\n\nHere’s a simple tale of discounts. A customer can be given a discount rate to apply to all\n\ntheir purchases:\n\nclass Customer…\n\nClick here to view code image\n\napplyDiscount(aNumber) { return (this.discountRate) ? aNumber ­ (this.discountRate * aNumber) : aNumber; }\n\nwww.EBooksWorld.ir",
      "content_length": 1803,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 340,
      "content": "There’s an assumption here that the discount rate is a positive number. I can make that\n\nassumption explicit by using an assertion. But I can’t easily place an assertion into a\n\nternary expression, so first I’ll reformulate it as an if­then statement.\n\nclass Customer…\n\nClick here to view code image\n\napplyDiscount(aNumber) { if (!this.discountRate) return aNumber; else return aNumber ­ (this.discountRate * aNumber); }\n\nNow I can easily add the assertion.\n\nclass Customer…\n\nClick here to view code image\n\napplyDiscount(aNumber) { if (!this.discountRate) return aNumber; else { assert(this.discountRate >= 0); return aNumber ­ (this.discountRate * aNumber); } }\n\nIn this case, I’d rather put this assertion into the setting method. If the assertion fails in\n\napplyDiscount, my first puzzle is how it got into the field in the first place.\n\nclass Customer…\n\nClick here to view code image\n\nset discountRate(aNumber) { assert(null === aNumber || aNumber >= 0); this._discountRate = aNumber; }\n\nAn assertion like this can be particularly valuable if it’s hard to spot the error source—\n\nwhich may be an errant minus sign in some input data or some inversion elsewhere in\n\nthe code.\n\nwww.EBooksWorld.ir",
      "content_length": 1198,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 341,
      "content": "There is a real danger of overusing assertions. I don’t use assertions to check everything\n\nthat I think is true, but only to check things that need to be true. Duplication is a\n\nparticular problem, as it’s common to tweak these kinds of conditions. So I find it’s\n\nessential to remove any duplication in these conditions, usually by a liberal use of\n\nExtract Function (106).\n\nI only use assertions for things that are programmer errors. If I’m reading data from an\n\nexternal source, any value checking should be a first­class part of the program, not an\n\nassertion—unless I’m really confident in the external source. Assertions are a last resort\n\nto help track bugs—though, ironically, I only use them when I think they should never\n\nfail.\n\nwww.EBooksWorld.ir",
      "content_length": 760,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 342,
      "content": "Chapter 11 Refactoring APIs\n\nHistory\n\nTopics\n\nModules and their functions are the building blocks of our software. APIs are the joints\n\nthat we use to plug them together. Making these APIs easy to understand and use is\n\nTutorials\n\nimportant but also difficult: I need to refactor them as I learn how to improve them.\n\nOffers & Deals\n\nA good API clearly separates any functions that update data from those that only read\n\ndata. If I see them combined, I use Separate Query from Modifier (306) to tease them\n\nHighlights\n\napart. I can unify functions that only vary due to a value with Parameterize Function\n\n(310). Some parameters, however, are really just a signal of an entirely different\n\nSettings\n\nbehavior and are best excised with Remove Flag Argument (314).\n\nSupport\n\nData structures are often unpacked unnecessarily when passed between functions; I\n\nSign Out\n\nprefer to keep them together with Preserve Whole Object (319). Decisions on what\n\nshould be passed as a parameter, and what can be resolved by the called function, are\n\nones I often need to revisit with Replace Parameter with Query (324) and Replace\n\nQuery with Parameter (327).\n\nA class is a common form of module. I prefer my objects to be as immutable as possible,\n\nso I use Remove Setting Method (331) whenever I can. Often, when a caller asks for a\n\nnew object, I need more flexibility than a simple constructor gives, which I can get by\n\nusing Replace Constructor with Factory Function (334).\n\nThe last two refactorings address the difficulty of breaking down a particularly complex\n\nfunction that passes a lot of data around. I can turn that function into an object with\n\nReplace Function with Command (337), which makes it easier to use Extract Function\n\n(106) on the function’s body. If I later simplify the function and no longer need it as a\n\ncommand object, I turn it back into a function with Replace Command with Function\n\n(344).\n\n.\n\nSEPARATE QUERY FROM MODIFIER\n\nwww.EBooksWorld.ir",
      "content_length": 1962,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 343,
      "content": "Motivation\n\nWhen I have a function that gives me a value and has no observable side effects, I have\n\na very valuable thing. I can call this function as often as I like. I can move the call to\n\nother places in a calling function. It’s easier to test. In short, I have a lot less to worry\n\nabout.\n\nIt is a good idea to clearly signal the difference between functions with side effects and\n\nthose without. A good rule to follow is that any function that returns a value should not\n\nhave observable side effects—the command­query separation [mf­cqs]. Some\n\nprogrammers treat this as an absolute rule. I’m not 100 percent pure on this (as on\n\nanything), but I try to follow it most of the time, and it has served me well.\n\nIf I come across a method that returns a value but also has side effects, I always try to\n\nseparate the query from the modifier.\n\nNote that I use the phrase observable side effects. A common optimization is to cache\n\nthe value of a query in a field so that repeated calls go quicker. Although this changes\n\nthe state of the object with the cache, the change is not observable. Any sequence of\n\nqueries will always return the same results for each query.\n\nMechanics\n\nwww.EBooksWorld.ir",
      "content_length": 1202,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 344,
      "content": "Copy the function, name it as a query.\n\nLook into the function to see what is returned. If the query is used to populate a\n\nvariable, the variable’s name should provide a good clue.\n\nRemove any side effects from the new query function.\n\nRun static checks.\n\nFind each call of the original method. If that call uses the return value, replace the\n\noriginal call with a call to the query and insert a call to the original method below it.\n\nTest after each change.\n\nRemove return values from original.\n\nTest.\n\nOften after doing this there will be duplication between the query and the original\n\nmethod that can be tidied up.\n\nExample\n\nHere is a function that scans a list of names for a miscreant. If it finds one, it returns\n\nthe name of the bad guy and sets off the alarms. It only does this for the first miscreant\n\nit finds (I guess one is enough).\n\nClick here to view code image\n\nfunction alertForMiscreant (people) { for (const p of people) { if (p === \"Don\") { setOffAlarms(); return \"Don\"; } if (p === \"John\") { setOffAlarms(); return \"John\"; } } return \"\"; }\n\nI begin by copying the function, naming it after the query aspect of the function.\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1197,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 345,
      "content": "function findMiscreant (people) { for (const p of people) { if (p === \"Don\") { setOffAlarms(); return \"Don\"; } if (p === \"John\") { setOffAlarms(); return \"John\"; } } return \"\"; }\n\nI remove the side effects from this new query.\n\nClick here to view code image\n\nfunction findMiscreant (people) { for (const p of people) { if (p === \"Don\") { setOffAlarms(); return \"Don\"; } if (p === \"John\") { setOffAlarms(); return \"John\"; } } return \"\"; }\n\nI now go to each caller and replace it with a call to the query, followed by a call to the\n\nmodifier. So\n\nClick here to view code image\n\nconst found = alertForMiscreant(people);\n\nchanges to\n\nClick here to view code image\n\nconst found = findMiscreant(people); alertForMiscreant(people);\n\nwww.EBooksWorld.ir",
      "content_length": 744,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 346,
      "content": "I now remove the return values from the modifier.\n\nClick here to view code image\n\nfunction alertForMiscreant (people) { for (const p of people) { if (p === \"Don\") { setOffAlarms(); return; } if (p === \"John\") { setOffAlarms(); return; } } return; }\n\nNow I have a lot of duplication between the original modifier and the new query, so I\n\ncan use Substitute Algorithm (195) so that the modifier uses the query.\n\nClick here to view code image\n\nfunction alertForMiscreant (people) { if (findMiscreant(people) !== \"\") setOffAlarms(); }\n\nPARAMETERIZE FUNCTION\n\nformerly: Parameterize Method\n\nwww.EBooksWorld.ir",
      "content_length": 604,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 347,
      "content": "Motivation\n\nIf I see two functions that carry out very similar logic with different literal values, I can\n\nremove the duplication by using a single function with parameters for the different\n\nvalues. This increases the usefulness of the function, since I can apply it elsewhere with\n\ndifferent values.\n\nMechanics\n\nSelect one of the similar methods.\n\nUse Change Function Declaration (124) to add any literals that need to turn into\n\nparameters.\n\nFor each caller of the function, add the literal value.\n\nTest.\n\nChange the body of the function to use the new parameters. Test after each change.\n\nFor each similar function, replace the call with a call to the parameterized function.\n\nTest after each one.\n\nIf the original parameterized function doesn’t work for a similar function, adjust it\n\nfor the new function before moving on to the next.\n\nExample\n\nwww.EBooksWorld.ir",
      "content_length": 869,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 348,
      "content": "An obvious example is something like this:\n\nClick here to view code image\n\nfunction tenPercentRaise(aPerson) { aPerson.salary = aPerson.salary.multiply(1.1); } function fivePercentRaise(aPerson) { aPerson.salary = aPerson.salary.multiply(1.05); }\n\nHopefully it’s obvious that I can replace these with\n\nClick here to view code image\n\nfunction raise(aPerson, factor) { aPerson.salary = aPerson.salary.multiply(1 + factor); }\n\nBut it can be a bit more involved than that. Consider this code:\n\nClick here to view code image\n\nfunction baseCharge(usage) { if (usage < 0) return usd(0); const amount = bottomBand(usage) * 0.03 + middleBand(usage) * 0.05 + topBand(usage) * 0.07; return usd(amount); }\n\nfunction bottomBand(usage) { return Math.min(usage, 100); }\n\nfunction middleBand(usage) { return usage > 100 ? Math.min(usage, 200) ­ 100 : 0; }\n\nfunction topBand(usage) { return usage > 200 ? usage ­ 200 : 0; }\n\nHere the logic is clearly pretty similar—but is it similar enough to support creating a\n\nparameterized method for the bands? It is, but may be a touch less obvious than the\n\nwww.EBooksWorld.ir",
      "content_length": 1100,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 349,
      "content": "trivial case above.\n\nWhen looking to parameterize some related functions, my approach is to take one of\n\nthe functions and add parameters to it, with an eye to the other cases. With range­\n\noriented things like this, usually the place to start is with the middle range. So I’ll work\n\non middleBand to change it to use parameters, and then adjust other callers to fit.\n\nmiddleBand uses two literal values: 100 and 200. These represent the bottom and top\n\nof this middle band. I begin by using Change Function Declaration (124) to add them\n\nto the call. While I’m at it, I’ll also change the name of the function to something that\n\nmakes sense with the parameterization.\n\nClick here to view code image\n\nfunction withinBand(usage, bottom, top) { return usage > 100 ? Math.min(usage, 200) ­ 100 : 0; }\n\nfunction baseCharge(usage) { if (usage < 0) return usd(0); const amount = bottomBand(usage) * 0.03 + withinBand(usage, 100, 200) * 0.05 + topBand(usage) * 0.07; return usd(amount); }\n\nI replace each literal with a reference to the parameter:\n\nClick here to view code image\n\nfunction withinBand(usage, bottom, top) { return usage > bottom ? Math.min(usage, 200) ­ bottom : 0; }\n\nthen:\n\nClick here to view code image\n\nfunction withinBand(usage, bottom, top) { return usage > bottom ? Math.min(usage, top) ­ bottom : 0; }\n\nwww.EBooksWorld.ir",
      "content_length": 1337,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 350,
      "content": "I replace the call to the bottom band with a call to the newly parameterized function.\n\nClick here to view code image\n\nfunction baseCharge(usage) { if (usage < 0) return usd(0); const amount = withinBand(usage, 0, 100) * 0.03 + withinBand(usage, 100, 200) * 0.05 + topBand(usage) * 0.07; return usd(amount); }\n\nfunction bottomBand(usage) { return Math.min(usage, 100); }\n\nTo replace the call to the top band, I need to make use of infinity.\n\nClick here to view code image\n\nfunction baseCharge(usage) { if (usage < 0) return usd(0); const amount = withinBand(usage, 0, 100) * 0.03 + withinBand(usage, 100, 200) * 0.05 + withinBand(usage, 200, Infinity) * 0.07; return usd(amount); }\n\nfunction topBand(usage) { return usage > 200 ? usage ­ 200 : 0; }\n\nWith the logic working the way it does now, I could remove the initial guard clause. But\n\nalthough it’s logically unnecessary now, I like to keep it as it documents how to handle\n\nthat case.\n\nREMOVE FLAG ARGUMENT\n\nformerly: Replace Parameter with Explicit Methods\n\nwww.EBooksWorld.ir",
      "content_length": 1033,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 351,
      "content": "Motivation\n\nA flag argument is a function argument that the caller uses to indicate which logic the\n\ncalled function should execute. I may call a function that looks like this:\n\nClick here to view code image\n\nfunction bookConcert(aCustomer, isPremium) { if (isPremium) { // logic for premium booking } else { // logic for regular booking } }\n\nTo book a premium concert, I issue the call like so:\n\nbookConcert(aCustomer, true);\n\nFlag arguments can also come as enums:\n\nwww.EBooksWorld.ir",
      "content_length": 486,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 352,
      "content": "Click here to view code image\n\nbookConcert(aCustomer, CustomerType.PREMIUM);\n\nor strings (or symbols in languages that use them):\n\nClick here to view code image\n\nbookConcert(aCustomer, \"premium\");\n\nI dislike flag arguments because they complicate the process of understanding what\n\nfunction calls are available and how to call them. My first route into an API is usually\n\nthe list of available functions, and flag arguments hide the differences in the function\n\ncalls that are available. Once I select a function, I have to figure out what values are\n\navailable for the flag arguments. Boolean flags are even worse since they don’t convey\n\ntheir meaning to the reader—in a function call, I can’t figure out what true means. It’s\n\nclearer to provide an explicit function for the task I want to do.\n\npremiumBookConcert(aCustomer);\n\nNot all arguments like this are flag arguments. To be a flag argument, the callers must\n\nbe setting the boolean value to a literal value, not data that’s flowing through the\n\nprogram. Also, the implementation function must be using the argument to influence\n\nits control flow, not as data that it passes to further functions.\n\nRemoving flag arguments doesn’t just make the code clearer—it also helps my tooling.\n\nCode analysis tools can now more easily see the difference between calling the premium\n\nlogic and calling regular logic.\n\nFlag arguments can have a place if there’s more than one of them in the function, since\n\notherwise I would need explicit functions for every combination of their values. But\n\nthat’s also a signal of a function doing too much, and I should look for a way to create\n\nsimpler functions that I can compose for this logic.\n\nMechanics\n\nCreate an explicit function for each value of the parameter.\n\nIf the main function has a clear dispatch conditional, use Decompose Conditional\n\n(260) to create the explicit functions. Otherwise, create wrapping functions. www.EBooksWorld.ir",
      "content_length": 1935,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 353,
      "content": "For each caller that uses a literal value for the parameter, replace it with a call to the\n\nexplicit function.\n\nExample\n\nLooking through some code, I see calls to calculate a delivery date for a shipment. Some\n\nof the calls look like\n\nClick here to view code image\n\naShipment.deliveryDate = deliveryDate(anOrder, true);\n\nand some look like\n\nClick here to view code image\n\naShipment.deliveryDate = deliveryDate(anOrder, false);\n\nFaced with code like this, I immediately begin to wonder about the meaning of the\n\nboolean value. What is it doing?\n\nThe body of deliveryDate looks like this:\n\nClick here to view code image\n\nfunction deliveryDate(anOrder, isRush) { if (isRush) { let deliveryTime; if ([\"MA\", \"CT\"] .includes(anOrder.deliveryState)) deliveryTime = 1; else if ([\"NY\", \"NH\"].includes(anOrder.deliveryState)) deliveryTime = 2; else deliveryTime = 3; return anOrder.placedOn.plusDays(1 + deliveryTime); } else { let deliveryTime; if ([\"MA\", \"CT\", \"NY\"].includes(anOrder.deliveryState)) deliveryTime = 2; else if ([\"ME\", \"NH\"] .includes(anOrder.deliveryState)) deliveryTime = 3; else deliveryTime = 4; return anOrder.placedOn.plusDays(2 + deliveryTime); } }\n\nHere, the caller is using a literal boolean value to determine which code should run—a\n\nwww.EBooksWorld.ir",
      "content_length": 1270,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 354,
      "content": "classic flag argument. But the whole point of using a function is to follow the caller’s\n\ninstructions, so it is better to clarify the caller’s intent with explicit functions.\n\nIn this case, I can do this by using Decompose Conditional (260), which gives me this:\n\nClick here to view code image\n\nfunction deliveryDate(anOrder, isRush) { if (isRush) return rushDeliveryDate(anOrder); else return regularDeliveryDate(anOrder); } function rushDeliveryDate(anOrder) { let deliveryTime; if ([\"MA\", \"CT\"] .includes(anOrder.deliveryState)) deliveryTime = 1; else if ([\"NY\", \"NH\"].includes(anOrder.deliveryState)) deliveryTime = 2; else deliveryTime = 3; return anOrder.placedOn.plusDays(1 + deliveryTime); } function regularDeliveryDate(anOrder) { let deliveryTime; if ([\"MA\", \"CT\", \"NY\"].includes(anOrder.deliveryState)) deliveryTime = 2; else if ([\"ME\", \"NH\"] .includes(anOrder.deliveryState)) deliveryTime = 3; else deliveryTime = 4; return anOrder.placedOn.plusDays(2 + deliveryTime); }\n\nThe two new functions capture the intent of the call better, so I can replace each call of\n\nClick here to view code image\n\naShipment.deliveryDate = deliveryDate(anOrder, true);\n\nwith\n\nClick here to view code image\n\naShipment.deliveryDate = rushDeliveryDate(anOrder);\n\nand similarly with the other case.\n\nWhen I’ve replaced all the callers, I remove deliveryDate.\n\nA flag argument isn’t just the presence of a boolean value; it’s that the boolean is set\n\nwww.EBooksWorld.ir",
      "content_length": 1457,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 355,
      "content": "with a literal rather than data. If all the callers of deliveryDate were like this:\n\nClick here to view code image\n\nconst isRush = determineIfRush(anOrder); aShipment.deliveryDate = deliveryDate(anOrder, isRush);\n\nthen I’d have no problem with deliveryDate’s signature (although I’d still want to\n\napply Decompose Conditional (260)).\n\nIt may be that some callers use the argument as a flag argument by setting it with a\n\nliteral, while others set the argument with data. In this case, I’d still use Remove Flag\n\nArgument, but not change the data callers and not remove deliveryDate at the end.\n\nThat way I support both interfaces for the different uses.\n\nDecomposing the conditional like this is a good way to carry out this refactoring, but it\n\nonly works if the dispatch on the parameter is the outer part of the function (or I can\n\neasily refactor it to make it so). It’s also possible that the parameter is used in a much\n\nmore tangled way, such as this alternative version of deliveryDate:\n\nClick here to view code image\n\nfunction deliveryDate(anOrder, isRush) { let result; let deliveryTime; if (anOrder.deliveryState === \"MA\" || anOrder.deliveryState === \"CT\") deliveryTime = isRush? 1 : 2; else if (anOrder.deliveryState === \"NY\" || anOrder.deliveryState === \"NH\") { deliveryTime = 2; if (anOrder.deliveryState === \"NH\" && !isRush) deliveryTime = 3; } else if (isRush) deliveryTime = 3; else if (anOrder.deliveryState === \"ME\") deliveryTime = 3; else deliveryTime = 4; result = anOrder.placedOn.plusDays(2 + deliveryTime); if (isRush) result = result.minusDays(1); return result; }\n\nIn this case, teasing out isRush into a top­level dispatch conditional is likely more www.EBooksWorld.ir",
      "content_length": 1695,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 356,
      "content": "work than I fancy. So instead, I can layer functions over the deliveryDate:\n\nClick here to view code image\n\nfunction rushDeliveryDate (anOrder) {return deliveryDate(anOrder, true);} function regularDeliveryDate(anOrder) {return deliveryDate(anOrder, false);}\n\nThese wrapping functions are essentially partial applications of deliveryDate,\n\nalthough they are defined in program text rather than by composition of functions.\n\nI can then do the same replacement of callers that I did with the decomposed\n\nconditional earlier on. If there aren’t any callers using the parameter as data, I like to\n\nrestrict its visibility or rename it to a name that conveys that it shouldn’t be used\n\ndirectly (e.g., deliveryDateHelperOnly).\n\nPRESERVE WHOLE OBJECT\n\nMotivation\n\nIf I see code that derives a couple of values from a record and then passes these values\n\ninto a function, I like to replace those values with the whole record itself, letting the\n\nfunction body derive the values it needs.\n\nPassing the whole record handles change better should the called function need more\n\ndata from the whole in the future—that change would not require me to alter the\n\nparameter list. It also reduces the size of the parameter list, which usually makes the\n\nwww.EBooksWorld.ir",
      "content_length": 1255,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 357,
      "content": "function call easier to understand. If many functions are called with the parts, they\n\noften duplicate the logic that manipulates these parts—logic that can often be moved to\n\nthe whole.\n\nThe main reason I wouldn’t do this is if I don’t want the called function to have a\n\ndependency on the whole—which typically occurs when they are in different modules.\n\nPulling several values from an object to do some logic on them alone is a smell (Feature\n\nEnvy (77)), and usually a signal that this logic should be moved into the whole itself.\n\nPreserve Whole Object is particularly common after I’ve done Introduce Parameter\n\nObject (140), as I hunt down any occurrences of the original data clump to replace them\n\nwith the new object.\n\nIf several bits of code only use the same subset of an object’s features, then that may\n\nindicate a good opportunity for Extract Class (182).\n\nOne case that many people miss is when an object calls another object with several of\n\nits own data values. If I see this, I can replace those values with a self­reference (this\n\nin JavaScript).\n\nMechanics\n\nCreate an empty function with the desired parameters.\n\nGive the function an easily searchable name so it can be replaced at the end.\n\nFill the body of the new function with a call to the old function, mapping from the\n\nnew parameters to the old ones.\n\nRun static checks.\n\nAdjust each caller to use the new function, testing after each change.\n\nThis may mean that some code that derives the parameter isn’t needed, so can fall\n\nto Remove Dead Code (237).\n\nOnce all original callers have been changed, use Inline Function (115) on the original\n\nfunction.\n\nChange the name of the new function and all its callers.\n\nExample\n\nwww.EBooksWorld.ir",
      "content_length": 1718,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 358,
      "content": "Consider a room monitoring system. It compares its daily temperature range with a\n\nrange in a predefined heating plan.\n\ncaller…\n\nClick here to view code image\n\nconst low = aRoom.daysTempRange.low; const high = aRoom.daysTempRange.high; if (!aPlan.withinRange(low, high)) alerts.push(\"room temperature went outside range\");\n\nclass HeatingPlan…\n\nClick here to view code image\n\nwithinRange(bottom, top) { return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRange.high); }\n\nInstead of unpacking the range information when I pass it in, I can pass in the whole\n\nrange object.\n\nI begin by stating the interface I want as an empty function.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nxxNEWwithinRange(aNumberRange) { }\n\nSince I intend it to replace the existing withinRange, I name it the same but with an\n\neasily replaceable prefix.\n\nI then add the body of the function, which relies on calling the existing withinRange.\n\nThe body thus consists of a mapping from the new parameter to the existing ones.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1098,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 359,
      "content": "xxNEWwithinRange(aNumberRange) { return this.withinRange(aNumberRange.low, aNumberRange.high); }\n\nNow I can begin the serious work, taking the existing function calls and having them\n\ncall the new function.\n\ncaller…\n\nClick here to view code image\n\nconst low = aRoom.daysTempRange.low; const high = aRoom.daysTempRange.high; if (!aPlan.xxNEWwithinRange(aRoom.daysTempRange)) alerts.push(\"room temperature went outside range\");\n\nWhen I’ve changed the calls, I may see that some of the earlier code isn’t needed\n\nanymore, so I wield Remove Dead Code (237).\n\ncaller…\n\nClick here to view code image\n\nconst low = aRoom.daysTempRange.low; const high = aRoom.daysTempRange.high; if (!aPlan.xxNEWwithinRange(aRoom.daysTempRange)) alerts.push(\"room temperature went outside range\");\n\nI replace these one at a time, testing after each change.\n\nOnce I’ve replaced them all, I can use Inline Function (115) on the original function.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nxxNEWwithinRange(aNumberRange) { return (aNumberRange.low >= this._temperatureRange.low) && (aNumberRange.high <= this._temperatureRange.high); }\n\nAnd I finally remove that ugly prefix from the new function and all its callers. The prefix\n\nwww.EBooksWorld.ir",
      "content_length": 1230,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 360,
      "content": "makes it a simple global replace, even if I don’t have a robust rename support in my\n\neditor.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nwithinRange(aNumberRange) { return (aNumberRange.low >= this._temperatureRange.low) && (aNumberRange.high <= this._temperatureRange.high); }\n\ncaller…\n\nClick here to view code image\n\nif (!aPlan.withinRange(aRoom.daysTempRange)) alerts.push(\"room temperature went outside range\");\n\nExample: A Variation to Create the New Function\n\nIn the above example, I wrote the code for the new function directly. Most of the time,\n\nthat’s pretty simple and the easiest way to go. But there is a variation on this that’s\n\noccasionally useful—which can allow me to compose the new function entirely from\n\nrefactorings.\n\nI start with a caller of the existing function.\n\ncaller…\n\nClick here to view code image\n\nconst low = aRoom.daysTempRange.low; const high = aRoom.daysTempRange.high; if (!aPlan.withinRange(low, high)) alerts.push(\"room temperature went outside range\");\n\nI want to rearrange the code so I can create the new function by using Extract Function\n\n(106) on some existing code. The caller code isn’t quite there yet, but I can get there by\n\nusing Extract Variable (119) a few times. First, I disentangle the call to the old function\n\nfrom the conditional.\n\nwww.EBooksWorld.ir",
      "content_length": 1318,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 361,
      "content": "caller…\n\nClick here to view code image\n\nconst low = aRoom.daysTempRange.low; const high = aRoom.daysTempRange.high; const isWithinRange = aPlan.withinRange(low, high); if (!isWithinRange) alerts.push(\"room temperature went outside range\");\n\nI then extract the input parameter.\n\ncaller…\n\nClick here to view code image\n\nconst tempRange = aRoom.daysTempRange; const low = tempRange.low; const high = tempRange.high; const isWithinRange = aPlan.withinRange(low, high); if (!isWithinRange) alerts.push(\"room temperature went outside range\");\n\nWith that done, I can now use Extract Function (106) to create the new function.\n\ncaller…\n\nClick here to view code image\n\nconst tempRange = aRoom.daysTempRange; const isWithinRange = xxNEWwithinRange(aPlan, tempRange); if (!isWithinRange) alerts.push(\"room temperature went outside range\");\n\ntop level…\n\nClick here to view code image\n\nfunction xxNEWwithinRange(aPlan, tempRange) { const low = tempRange.low; const high = tempRange.high; const isWithinRange = aPlan.withinRange(low, high); return isWithinRange; }\n\nwww.EBooksWorld.ir",
      "content_length": 1070,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 362,
      "content": "Since the original function is in a different context (the HeatingPlan class), I need to\n\nuse Move Function (198).\n\ncaller…\n\nClick here to view code image\n\nconst tempRange = aRoom.daysTempRange; const isWithinRange = aPlan.xxNEWwithinRange(tempRange); if (!isWithinRange) alerts.push(\"room temperature went outside range\");\n\nclass HeatingPlan…\n\nClick here to view code image\n\nxxNEWwithinRange(tempRange) { const low = tempRange.low; const high = tempRange.high; const isWithinRange = this.withinRange(low, high); return isWithinRange; }\n\nI then continue as before, replacing other callers and inlining the old function into the\n\nnew one. I would also inline the variables I extracted to provide the clean separation for\n\nextracting the new function.\n\nBecause this variation is entirely composed of refactorings, it’s particularly handy when\n\nI have a refactoring tool with robust extract and inline operations.\n\nREPLACE PARAMETER WITH QUERY\n\nformerly: Replace Parameter with Method\n\ninverse of: Replace Query with Parameter (327)\n\nwww.EBooksWorld.ir",
      "content_length": 1049,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 363,
      "content": "Motivation\n\nThe parameter list to a function should summarize the points of variability of that\n\nfunction, indicating the primary ways in which that function may behave differently. As\n\nwith any statement in code, it’s good to avoid any duplication, and it’s easier to\n\nunderstand if the parameter list is short.\n\nIf a call passes in a value that the function can just as easily determine for itself, that’s a\n\nform of duplication—one that unnecessarily complicates the caller which has to\n\ndetermine the value of a parameter when it could be freed from that work.\n\nThe limit on this is suggested by the phrase “just as easily.” By removing the parameter,\n\nI’m shifting the responsibility for determining the parameter value. When the\n\nparameter is present, determining its value is the caller’s responsibility; otherwise, that\n\nresponsibility shifts to the function body. My usual habit is to simplify life for callers,\n\nwhich implies moving responsibility to the function body—but only if that\n\nresponsibility is appropriate there.\n\nThe most common reason to avoid Replace Parameter with Query is if removing the\n\nparameter adds an unwanted dependency to the function body—forcing it to access a\n\nprogram element that I’d rather it remained ignorant of. This may be a new\n\ndependency, or an existing one that I’d like to remove. Usually this comes up where I’d\n\nneed to add a problematic function call to the function body, or access something\n\nwithin a receiver object that I’d prefer to move out later.\n\nThe safest case for Replace Parameter with Query is when the value of the parameter I\n\nwww.EBooksWorld.ir",
      "content_length": 1613,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 364,
      "content": "want to remove is determined merely by querying another parameter in the list. There’s\n\nrarely any point in passing two parameters if one can be determined from the other.\n\nOne thing to watch out for is if the function I’m looking at has referential transparency\n\n—that is, if I can be sure that it will behave the same way whenever it’s called with the\n\nsame parameter values. Such functions are much easier to reason about and test, and I\n\ndon’t want to alter them to lose that property. So I wouldn’t replace a parameter with\n\nan access to a mutable global variable.\n\nMechanics\n\nIf necessary, use Extract Function (106) on the calculation of the parameter.\n\nReplace references to the parameter in the function body with references to the\n\nexpression that yields the parameter. Test after each change.\n\nUse Change Function Declaration (124) to remove the parameter.\n\nExample\n\nI most often use Replace Parameter with Query when I’ve done some other refactorings\n\nthat make a parameter no longer needed. Consider this code.\n\nclass Order…\n\nClick here to view code image\n\nget finalPrice() { const basePrice = this.quantity * this.itemPrice; let discountLevel; if (this.quantity > 100) discountLevel = 2; else discountLevel = 1; return this.discountedPrice(basePrice, discountLevel); }\n\ndiscountedPrice(basePrice, discountLevel) { switch (discountLevel) { case 1: return basePrice * 0.95; case 2: return basePrice * 0.9; } }\n\nWhen I’m simplifying a function, I’m keen to apply Replace Temp with Query (178),\n\nwhich would lead me to\n\nwww.EBooksWorld.ir",
      "content_length": 1548,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 365,
      "content": "class Order…\n\nClick here to view code image\n\nget finalPrice() { const basePrice = this.quantity * this.itemPrice; return this.discountedPrice(basePrice, this.discountLevel); }\n\nget discountLevel() { return (this.quantity > 100) ? 2 : 1; }\n\nOnce I’ve done this, there’s no need to pass the result of discountLevel to\n\ndiscountedPrice—it can just as easily make the call itself.\n\nI replace any reference to the parameter with a call to the method instead.\n\nclass Order…\n\nClick here to view code image\n\ndiscountedPrice(basePrice, discountLevel) { switch (this.discountLevel) { case 1: return basePrice * 0.95; case 2: return basePrice * 0.9; } }\n\nI can then use Change Function Declaration (124) to remove the parameter.\n\nclass Order…\n\nClick here to view code image\n\nget finalPrice() { const basePrice = this.quantity * this.itemPrice; return this.discountedPrice(basePrice, this.discountLevel); }\n\ndiscountedPrice(basePrice, discountLevel) { switch (this.discountLevel) { case 1: return basePrice * 0.95; case 2: return basePrice * 0.9; } }\n\nwww.EBooksWorld.ir",
      "content_length": 1058,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 366,
      "content": "REPLACE QUERY WITH PARAMETER\n\ninverse of: Replace Parameter with Query (324)\n\nMotivation\n\nWhen looking through a function’s body, I sometimes see references to something in\n\nthe function’s scope that I’m not happy with. This might be a reference to a global\n\nvariable, or to an element in the same module that I intend to move away. To resolve\n\nthis, I need to replace the internal reference with a parameter, shifting the\n\nresponsibility of resolving the reference to the caller of the function.\n\nMost of these cases are due to my wish to alter the dependency relationships in the code\n\n—to make the target function no longer dependent on the element I want to\n\nparameterize. There’s a tension here between converting everything to parameters,\n\nwhich results in long repetitive parameter lists, and sharing a lot of scope which can\n\nlead to a lot of coupling between functions. Like most tricky decisions, it’s not\n\nsomething I can reliably get right, so it’s important that I can reliably change things so\n\nthe program can take advantage of my increasing understanding.\n\nIt’s easier to reason about a function that will always give the same result when called\n\nwith same parameter values—this is called referential transparency. If a function\n\naccesses some element in its scope that isn’t referentially transparent, then the\n\nwww.EBooksWorld.ir",
      "content_length": 1347,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 367,
      "content": "containing function also lacks referential transparency. I can fix that by moving that\n\nelement to a parameter. Although such a move will shift responsibility to the caller,\n\nthere is often a lot to be gained by creating clear modules with referential transparency.\n\nA common pattern is to have modules consisting of pure functions which are wrapped\n\nby logic that handles the I/O and other variable elements of a program. I can use\n\nReplace Query with Parameter to purify parts of a program, making those parts easier\n\nto test and reason about.\n\nBut Replace Query with Parameter isn’t just a bag of benefits. By moving a query to a\n\nparameter, I force my caller to figure out how to provide this value. This complicates\n\nlife for callers of the functions, and my usual bias is to design interfaces that make life\n\neasier for their consumers. In the end, it boils down to allocation of responsibility\n\naround the program, and that’s a decision that’s neither easy nor immutable—which is\n\nwhy this refactoring (and its inverse) is one that I need to be very familiar with.\n\nMechanics\n\nUse Extract Variable (119) on the query code to separate it from the rest of the\n\nfunction body.\n\nApply Extract Function (106) to the body code that isn’t the call to the query.\n\nGive the new function an easily searchable name, for later renaming.\n\nUse Inline Variable (123) to get rid of the variable you just created.\n\nApply Inline Function (115) to the original function.\n\nRename the new function to that of the original.\n\nExample\n\nConsider a simple, yet annoying, control system for temperature. It allows the user to\n\nselect a temperature on a thermostat—but only sets the target temperature within a\n\nrange determined by a heating plan.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nget targetTemperature() { if (thermostat.selectedTemperature > this._max) return this._max;\n\nwww.EBooksWorld.ir",
      "content_length": 1890,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 368,
      "content": "else if (thermostat.selectedTemperature < this._min) return this._min; else return thermostat.selectedTemperature; }\n\ncaller…\n\nClick here to view code image\n\nif (thePlan.targetTemperature > thermostat.currentTemperature) setToHeat(); else if (thePlan.targetTemperature < thermostat.currentTemperature) setToCool(); else setOff();\n\nAs a user of such a system, I might be annoyed to have my desires overridden by the\n\nheating plan rules, but as a programmer I might be more concerned about how the\n\ntargetTemperature function has a dependency on a global thermostat object. I can\n\nbreak this dependency by moving it to a parameter.\n\nMy first step is to use Extract Variable (119) on the parameter that I want to have in my\n\nfunction.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nget targetTemperature() { const selectedTemperature = thermostat.selectedTemperature; if (selectedTemperature > this._max) return this._max; else if (selectedTemperature < this._min) return this._min; else return selectedTemperature; }\n\nThat makes it easy to apply Extract Function (106) on the entire body of the function\n\nexcept for the bit that figures out the parameter.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nget targetTemperature() { const selectedTemperature = thermostat.selectedTemperature; return this.xxNEWtargetTemperature(selectedTemperature); }\n\nwww.EBooksWorld.ir",
      "content_length": 1375,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 369,
      "content": "xxNEWtargetTemperature(selectedTemperature) { if (selectedTemperature > this._max) return this._max; else if (selectedTemperature < this._min) return this._min; else return selectedTemperature; }\n\nI then inline the variable I just extracted, which leaves the function as a simple call.\n\nclass HeatingPlan…\n\nClick here to view code image\n\nget targetTemperature() { return this.xxNEWtargetTemperature(thermostat.selectedTemperature); }\n\nI can now use Inline Function (115) on this method.\n\ncaller…\n\nClick here to view code image\n\nif (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) > thermostat.currentTemperature) setToHeat(); else if (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) < thermostat.currentTemperature) setToCool(); else setOff();\n\nI take advantage of the easily searchable name of the new function to rename it by\n\nremoving the prefix.\n\ncaller…\n\nClick here to view code image\n\nif (thePlan.targetTemperature(thermostat.selectedTemperature) > thermostat.currentTemperature) setToHeat(); else if (thePlan.targetTemperature(thermostat.selectedTemperature) < thermostat.currentTemperature) www.EBooksWorld.ir",
      "content_length": 1147,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 370,
      "content": "setToCool(); else setOff();\n\nclass HeatingPlan…\n\nClick here to view code image\n\ntargetTemperature(selectedTemperature) { if (selectedTemperature > this._max) return this._max; else if (selectedTemperature < this._min) return this._min; else return selectedTemperature; }\n\nAs is often the case with this refactoring, the calling code looks more unwieldy than\n\nbefore. Moving a dependency out of a module pushes the responsibility of dealing with\n\nthat dependency back to the caller. That’s the trade­off for the reduced coupling.\n\nBut removing the coupling to the thermostat object isn’t the only gain I’ve made with\n\nthis refactoring. The HeatingPlan class is immutable—its fields are set in the\n\nconstructor with no methods to alter them. (I’ll save you the effort of looking at the\n\nwhole class; just trust me on this.) Given an immutable heating plan, by moving the\n\nthermostat reference out of the function body I’ve also made targetTemperature\n\nreferentially transparent. Every time I call targetTemperature on the same object,\n\nwith the same argument, I will get the same result. If all the methods of the heating\n\nplan have referential transparency, that makes this class much easier to test and reason\n\nabout.\n\nA problem with JavaScript’s class model is that it’s impossible to enforce an immutable\n\nclass—there’s always a way to get at an object’s data. But writing a class to signal and\n\nencourage immutability is often good enough. Creating classes that have this\n\ncharacteristic is often a sound strategy and Replace Query with Parameter is a handy\n\ntool for doing this.\n\nREMOVE SETTING METHOD\n\nwww.EBooksWorld.ir",
      "content_length": 1625,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 371,
      "content": "Motivation\n\nProviding a setting method indicates that a field may be changed. If I don’t want that\n\nfield to change once the object is created, I don’t provide a setting method (and make\n\nthe field immutable). That way, the field is set only in the constructor, my intention to\n\nhave it not change is clear, and I usually remove the very possibility that the field will\n\nchange.\n\nThere’s a couple of common cases where this comes up. One is where people always use\n\naccessor methods to manipulate a field, even within constructors. This leads to the only\n\ncall to a setting method being from the constructor. I prefer to remove the setting\n\nmethod to make it clear that updates make no sense after construction.\n\nAnother case is where the object is created by clients using creation script rather than\n\nby a simple constructor call. Such a creation script starts with the constructor call\n\nfollowed by a sequence of setter method calls to create the new object. Once the script is\n\nfinished, we don’t expect the new object to change some (or even all) of its fields. The\n\nsetters are only expected to be called during this initial creation. In this case, I’d get rid\n\nof them to make my intentions clearer.\n\nMechanics\n\nIf the value that’s being set isn’t provided to the constructor, use Change Function\n\nDeclaration (124) to add it. Add a call to the setting method within the constructor.\n\nIf you wish to remove several setting methods, add all their values to the\n\nconstructor at once. This simplifies the later steps.\n\nwww.EBooksWorld.ir",
      "content_length": 1541,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 372,
      "content": "Remove each call of a setting method outside of the constructor, using the new\n\nconstructor value instead. Test after each one.\n\nIf you can’t replace the call to the setter by creating a new object (because you are\n\nupdating a shared reference object), abandon the refactoring.\n\nUse Inline Function (115) on the setting method. Make the field immutable if\n\npossible.\n\nTest.\n\nExample\n\nI have a simple person class.\n\nclass Person…\n\nClick here to view code image\n\nget name() {return this._name;} set name(arg) {this._name = arg;} get id() {return this._id;} set id(arg) {this._id = arg;}\n\nAt the moment, I create a new object with code like this:\n\nconst martin = new Person(); martin.name = \"martin\"; martin.id = \"1234\";\n\nThe name of a person may change after it’s created, but the ID does not. To make this\n\nclear, I want to remove the setting method for ID.\n\nI still need to set the ID initially, so I’ll use Change Function Declaration (124) to add it\n\nto the constructor.\n\nclass Person…\n\nconstructor(id) { this.id = id; }\n\nwww.EBooksWorld.ir",
      "content_length": 1042,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 373,
      "content": "I then adjust the creation script to set the ID via the constructor.\n\nClick here to view code image\n\nconst martin = new Person(\"1234\"); martin.name = \"martin\"; martin.id = \"1234\";\n\nI do this in each place I create a person, testing after each change.\n\nWhen they are all done, I can apply Inline Function (115) to the setting method.\n\nclass Person…\n\nClick here to view code image\n\nconstructor(id) { this._id = id; } get name() {return this._name;} set name(arg) {this._name = arg;} get id() {return this._id;} set id(arg) {this._id = arg;}\n\nREPLACE CONSTRUCTOR WITH FACTORY FUNCTION\n\nformerly: Replace Constructor with Factory Method\n\nMotivation\n\nMany object­oriented languages have a special constructor function that’s called to www.EBooksWorld.ir",
      "content_length": 748,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 374,
      "content": "initialize an object. Clients typically call this constructor when they want to create a new\n\nobject. But these constructors often come with awkward limitations that aren’t there for\n\nmore general functions. A Java constructor must return an instance of the class it was\n\ncalled with, which means I can’t replace it with a subclass or proxy depending on the\n\nenvironment or parameters. Constructor naming is fixed, which makes it impossible for\n\nme to use a name that is clearer than the default. Constructors often require a special\n\noperator to invoke (“new” in many languages) which makes them difficult to use in\n\ncontexts that expect normal functions.\n\nA factory function suffers from no such limitations. It will likely call the constructor as\n\npart of its implementation, but I can freely substitute something else.\n\nMechanics\n\nCreate a factory function, its body being a call to the constructor.\n\nReplace each call to the constructor with a call to the factory function.\n\nTest after each change.\n\nLimit the constructor’s visibility as much as possible.\n\nExample\n\nA quick but wearisome example uses kinds of employees. Consider an employee class:\n\nclass Employee…\n\nClick here to view code image\n\nconstructor (name, typeCode) { this._name = name; this._typeCode = typeCode; } get name() {return this._name;} get type() { return Employee.legalTypeCodes[this._typeCode]; } static get legalTypeCodes() { return {\"E\": \"Engineer\", \"M\": \"Manager\", \"S\": \"Salesman\"}; }\n\nThis is used from\n\nwww.EBooksWorld.ir",
      "content_length": 1506,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 375,
      "content": "caller…\n\nClick here to view code image\n\ncandidate = new Employee(document.name, document.empType);\n\nand\n\ncaller…\n\nClick here to view code image\n\nconst leadEngineer = new Employee(document.leadEngineer, 'E');\n\nMy first step is to create the factory function. Its body is a simple delegation to the\n\nconstructor.\n\ntop level…\n\nClick here to view code image\n\nfunction createEmployee(name, typeCode) { return new Employee(name, typeCode); }\n\nI then find the callers of the constructor and change them, one at a time, to use the\n\nfactory function instead.\n\nThe first one is obvious:\n\ncaller…\n\nClick here to view code image\n\ncandidate = createEmployee(document.name, document.empType);\n\nWith the second case, I could use the new factory function like this:\n\ncaller…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 809,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 376,
      "content": "const leadEngineer = createEmployee(document.leadEngineer, 'E');\n\nBut I don’t like using the type code here—it’s generally a bad smell to pass a code as a\n\nliteral string. So I prefer to create a new factory function that embeds the kind of\n\nemployee I want into its name.\n\ncaller…\n\nClick here to view code image\n\nconst leadEngineer = createEngineer(document.leadEngineer);\n\ntop level…\n\nClick here to view code image\n\nfunction createEngineer(name) { return new Employee(name, 'E'); }\n\nREPLACE FUNCTION WITH COMMAND\n\nformerly: Replace Method with Method Object\n\ninverse of: Replace Command with Function (344)\n\nwww.EBooksWorld.ir",
      "content_length": 628,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 377,
      "content": "Motivation\n\nFunctions—either freestanding or attached to objects as methods—are one of the\n\nfundamental building blocks of programming. But there are times when it’s useful to\n\nencapsulate a function into its own object, which I refer to as a “command object” or\n\nsimply a command. Such an object is mostly built around a single method, whose\n\nrequest and execution is the purpose of the object.\n\nA command offers a greater flexibility for the control and expression of a function than\n\nthe plain function mechanism. Commands can have complimentary operations, such as\n\nundo. I can provide methods to build up their parameters to support a richer lifecycle. I\n\ncan build in customizations using inheritance and hooks. If I’m working in a language\n\nwith objects but without first­class functions, I can provide much of that capability by\n\nusing commands instead. Similarly, I can use methods and fields to help break down a\n\ncomplex function, even in a language that lacks nested functions, and I can call those\n\nmethods directly while testing and debugging.\n\nAll these are good reasons to use commands, and I need to be ready to refactor\n\nwww.EBooksWorld.ir",
      "content_length": 1157,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 378,
      "content": "functions into commands when I need to. But we must not forget that this flexibility, as\n\never, comes at a price paid in complexity. So, given the choice between a first­class\n\nfunction and a command, I’ll pick the function 95% of the time. I only use a command\n\nwhen I specifically need a facility that simpler approaches can’t provide.\n\nLike many words in software development, “command” is rather overloaded. In the\n\ncontext I’m using it here, it is an object that encapsulates a request, following the\n\ncommand pattern in Design Patterns [gof]. When I use “command” in this sense, I use\n\n“command object” to set the context, and “command” afterwards. The word\n\n“command” is also used in the command­query separation principle [mf­cqs], where a\n\ncommand is an object method that changes observable state. I’ve always tried to avoid\n\nusing command in that sense, preferring “modifier” or “mutator.”\n\nMechanics\n\nCreate an empty class for the function. Name it based on the function.\n\nUse Move Function (198) to move the function to the empty class.\n\nKeep the original function as a forwarding function until at least the end of the\n\nrefactoring.\n\nFollow any convention the language has for naming commands. If there is no\n\nconvention, choose a generic name for the command’s execute function, such as\n\n“execute” or “call”.\n\nConsider making a field for each argument, and move these arguments to the\n\nconstructor.\n\nExample\n\nThe JavaScript language has many faults, but one of its great decisions was to make\n\nfunctions first­class entities. I thus don’t have to go through all the hoops of creating\n\ncommands for common tasks that I need to do in languages without this facility. But\n\nthere are still times when a command is the right tool for the job.\n\nOne of these cases is breaking up a complex function so I can better understand and\n\nmodify it. To really show the value of this refactoring, I need a long and complicated\n\nfunction—but that would take too long to write, let alone for you to read. Instead, I’ll go\n\nwith a function that’s short enough not to need it. This one scores points for an\n\ninsurance application:\n\nwww.EBooksWorld.ir",
      "content_length": 2145,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 379,
      "content": "Click here to view code image\n\nfunction score(candidate, medicalExam, scoringGuide) { let result = 0; let healthLevel = 0; let highMedicalRiskFlag = false;\n\nif (medicalExam.isSmoker) { healthLevel += 10; highMedicalRiskFlag = true; } let certificationGrade = \"regular\"; if (scoringGuide.stateWithLowCertification(candidate.originState)) { certificationGrade = \"low\"; result ­= 5; } // lots more code like this result ­= Math.max(healthLevel ­ 5, 0); return result; }\n\nI begin by creating an empty class and then Move Function (198) to move the function\n\ninto it.\n\nClick here to view code image\n\nfunction score(candidate, medicalExam, scoringGuide) { return new Scorer().execute(candidate, medicalExam, scoringGuide); } class Scorer { execute (candidate, medicalExam, scoringGuide) { let result = 0; let healthLevel = 0; let highMedicalRiskFlag = false;\n\nif (medicalExam.isSmoker) { healthLevel += 10; highMedicalRiskFlag = true; } let certificationGrade = \"regular\"; if (scoringGuide.stateWithLowCertification(candidate.originState)) { certificationGrade = \"low\"; result ­= 5; } // lots more code like this result ­= Math.max(healthLevel ­ 5, 0); return result; } }\n\nwww.EBooksWorld.ir",
      "content_length": 1185,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 380,
      "content": "Most of the time, I prefer to pass arguments to a command on the constructor and have\n\nthe execute method take no parameters. While this matters less for a simple\n\ndecomposition scenario like this, it’s very handy when I want to manipulate the\n\ncommand with a more complicated parameter setting lifecycle or customizations.\n\nDifferent command classes can have different parameters but be mixed together when\n\nqueued for execution.\n\nI can do these parameters one at a time.\n\nClick here to view code image\n\nfunction score(candidate, medicalExam, scoringGuide) { return new Scorer(candidate).execute(candidate, medicalExam, scoringGuide); }\n\nclass Scorer…\n\nClick here to view code image\n\nconstructor(candidate){ this._candidate = candidate; }\n\nexecute (candidate, medicalExam, scoringGuide) { let result = 0; let healthLevel = 0; let highMedicalRiskFlag = false;\n\nif (medicalExam.isSmoker) { healthLevel += 10; highMedicalRiskFlag = true; } let certificationGrade = \"regular\"; if (scoringGuide.stateWithLowCertification(this._candidate.originState)) { certificationGrade = \"low\"; result ­= 5; } // lots more code like this result ­= Math.max(healthLevel ­ 5, 0); return result; }\n\nI continue with the other parameters\n\nwww.EBooksWorld.ir",
      "content_length": 1234,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 381,
      "content": "Click here to view code image\n\nfunction score(candidate, medicalExam, scoringGuide) { return new Scorer(candidate, medicalExam, scoringGuide).execute(); }\n\nclass Scorer…\n\nClick here to view code image\n\nconstructor(candidate, medicalExam, scoringGuide){ this._candidate = candidate; this._medicalExam = medicalExam; this._scoringGuide = scoringGuide; }\n\nexecute () { let result = 0; let healthLevel = 0; let highMedicalRiskFlag = false;\n\nif (this._medicalExam.isSmoker) { healthLevel += 10; highMedicalRiskFlag = true; } let certificationGrade = \"regular\"; if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) { certificationGrade = \"low\"; result ­= 5; } // lots more code like this result ­= Math.max(healthLevel ­ 5, 0); return result; }\n\nThat completes Replace Function with Command, but the whole point of doing this\n\nrefactoring is to allow me to break down the complicated functions—so let me outline\n\nsome steps to achieve that. My next move here is to change all the local variables into\n\nfields. Again, I do these one at a time.\n\nclass Scorer…\n\nClick here to view code image\n\nconstructor(candidate, medicalExam, scoringGuide){\n\nwww.EBooksWorld.ir",
      "content_length": 1180,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 382,
      "content": "this._candidate = candidate; this._medicalExam = medicalExam; this._scoringGuide = scoringGuide; }\n\nexecute () { this._result = 0; let healthLevel = 0; let highMedicalRiskFlag = false;\n\nif (this._medicalExam.isSmoker) { healthLevel += 10; highMedicalRiskFlag = true; } let certificationGrade = \"regular\"; if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) { certificationGrade = \"low\"; this._result ­= 5; } // lots more code like this this._result ­= Math.max(healthLevel ­ 5, 0); return this._result; }\n\nI repeat this for all the local variables. (This is one of those refactorings that I felt was\n\nsufficiently simple that I haven’t given it an entry in the catalog. I feel slightly guilty\n\nabout this.)\n\nclass Scorer…\n\nClick here to view code image\n\nconstructor(candidate, medicalExam, scoringGuide){ this._candidate = candidate; this._medicalExam = medicalExam; this._scoringGuide = scoringGuide; }\n\nexecute () { this._result = 0; this._healthLevel = 0; this._highMedicalRiskFlag = false;\n\nif (this._medicalExam.isSmoker) { this._healthLevel += 10; this._highMedicalRiskFlag = true; } this._certificationGrade = \"regular\"; if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {\n\nwww.EBooksWorld.ir",
      "content_length": 1255,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 383,
      "content": "this._certificationGrade = \"low\"; this._result ­= 5; } // lots more code like this this._result ­= Math.max(this._healthLevel ­ 5, 0); return this._result; }\n\nNow I’ve moved all the function’s state to the command object, I can use refactorings\n\nlike Extract Function (106) without getting tangled up in all the variables and their\n\nscopes.\n\nclass Scorer…\n\nClick here to view code image\n\nexecute () { this._result = 0; this._healthLevel = 0; this._highMedicalRiskFlag = false;\n\nthis.scoreSmoking(); this._certificationGrade = \"regular\"; if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) { this._certificationGrade = \"low\"; this._result ­= 5; } // lots more code like this this._result ­= Math.max(this._healthLevel ­ 5, 0); return this._result; }\n\nscoreSmoking() { if (this._medicalExam.isSmoker) { this._healthLevel += 10; this._highMedicalRiskFlag = true; } }\n\nThis allows me to treat the command similarly to how I’d deal with a nested function.\n\nIndeed, when doing this refactoring in JavaScript, using nested functions would be a\n\nreasonable alternative to using a command. I’d still use a command for this, partly\n\nbecause I’m more familiar with commands and partly because with a command I can\n\nwrite tests and debugging calls against the subfunctions.\n\nwww.EBooksWorld.ir\n\nREPLACE COMMAND WITH FUNCTION",
      "content_length": 1339,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 384,
      "content": "REPLACE COMMAND WITH FUNCTION\n\ninverse of: Replace Function with Command (337)\n\nMotivation\n\nCommand objects provide a powerful mechanism for handling complex computations.\n\nThey can easily be broken down into separate methods sharing common state through\n\nthe fields; they can be invoked via different methods for different effects; they can have\n\ntheir data built up in stages. But that power comes at a cost. Most of the time, I just\n\nwant to invoke a function and have it do its thing. If that’s the case, and the function\n\nisn’t too complex, then a command object is more trouble than its worth and should be\n\nturned into a regular function.\n\nMechanics\n\nApply Extract Function (106) to the creation of the command and the call to the\n\ncommand’s execution method.\n\nThis creates the new function that will replace the command in due course.\n\nFor each method called by the command’s execution method, apply Inline Function\n\n(115).\n\nwww.EBooksWorld.ir",
      "content_length": 951,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 385,
      "content": "If the supporting function returns a value, use Extract Variable (119) on the call\n\nfirst and then Inline Function (115).\n\nUse Change Function Declaration (124) to put all the parameters of the constructor\n\ninto the command’s execution method instead.\n\nFor each field, alter the references in the command’s execution method to use the\n\nparameter instead. Test after each change.\n\nInline the constructor call and command’s execution method call into the caller\n\n(which is the replacement function).\n\nTest.\n\nApply Remove Dead Code (237) to the command class.\n\nExample\n\nI’ll begin with this small command object:\n\nClick here to view code image\n\nclass ChargeCalculator { constructor (customer, usage, provider){ this._customer = customer; this._usage = usage; this._provider = provider; } get baseCharge() { return this._customer.baseRate * this._usage; } get charge() { return this.baseCharge + this._provider.connectionCharge; } }\n\nIt is used by code like this:\n\ncaller…\n\nClick here to view code image\n\nmonthCharge = new ChargeCalculator(customer, usage, provider).charge;\n\nwww.EBooksWorld.ir",
      "content_length": 1090,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 386,
      "content": "The command class is small and simple enough to be better off as a function.\n\nI begin by using Extract Function (106) to wrap the class creation and invocation.\n\ncaller…\n\nClick here to view code image\n\nmonthCharge = charge(customer, usage, provider);\n\ntop level…\n\nClick here to view code image\n\nfunction charge(customer, usage, provider) { return new ChargeCalculator(customer, usage, provider).charge; }\n\nI have to decide how to deal with any supporting functions, in this case baseCharge.\n\nMy usual approach for a function that returns a value is to first Extract Variable (119)\n\non that value.\n\nclass ChargeCalculator…\n\nClick here to view code image\n\nget baseCharge() { return this._customer.baseRate * this._usage; } get charge() { const baseCharge = this.baseCharge; return baseCharge + this._provider.connectionCharge; }\n\nThen, I use Inline Function (115) on the supporting function.\n\nclass ChargeCalculator…\n\nClick here to view code image\n\nget charge() { const baseCharge = this._customer.baseRate * this._usage; return baseCharge + this._provider.connectionCharge;\n\nwww.EBooksWorld.ir",
      "content_length": 1092,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 387,
      "content": "}\n\nI now have all the processing in a single function, so my next step is to move the data\n\npassed to the constructor to the main method. I first use Change Function Declaration\n\n(124) to add all the constructor parameters to the charge method.\n\nclass ChargeCalculator…\n\nClick here to view code image\n\nconstructor (customer, usage, provider){ this._customer = customer; this._usage = usage; this._provider = provider; }\n\ncharge(customer, usage, provider) { const baseCharge = this._customer.baseRate * this._usage; return baseCharge + this._provider.connectionCharge; }\n\ntop level…\n\nClick here to view code image\n\nfunction charge(customer, usage, provider) { return new ChargeCalculator(customer, usage, provider) .charge(customer, usage, provider); }\n\nNow I can alter the body of charge to use the passed parameters instead. I can do this\n\none at a time.\n\nclass ChargeCalculator…\n\nClick here to view code image\n\nconstructor (customer, usage, provider){ this._customer = customer; this._usage = usage; this._provider = provider; }\n\ncharge(customer, usage, provider) { const baseCharge = customer.baseRate * this._usage;\n\nwww.EBooksWorld.ir",
      "content_length": 1139,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 388,
      "content": "return baseCharge + this._provider.connectionCharge; }\n\nI don’t have to remove the assignment to this._customer in the constructor, as it\n\nwill just be ignored. But I prefer to do it since that will make a test fail if I miss\n\nchanging a use of field to the parameter. (And if a test doesn’t fail, I should consider\n\nadding a new test.)\n\nI repeat this for the other parameters, ending up with\n\nclass ChargeCalculator…\n\nClick here to view code image\n\ncharge(customer, usage, provider) { const baseCharge = customer.baseRate * usage; return baseCharge + provider.connectionCharge; }\n\nOnce I’ve done all of these, I can inline into the top­level charge function. This is a\n\nspecial kind of Inline Function (115), as it’s inlining both the constructor and method\n\ncall together.\n\ntop level…\n\nClick here to view code image\n\nfunction charge(customer, usage, provider) { const baseCharge = customer.baseRate * usage; return baseCharge + provider.connectionCharge; }\n\nThe command class is now dead code, so I’ll use Remove Dead Code (237) to give it an\n\nhonorable burial.\n\nwww.EBooksWorld.ir",
      "content_length": 1083,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 389,
      "content": "Chapter 12 Dealing with Inheritance\n\nHistory\n\nTopics\n\nIn this final chapter, I’ll turn to one of the best known features of object­oriented\n\nprogramming: inheritance. Like any powerful mechanism, it is both very useful and\n\nTutorials\n\neasy to misuse, and it’s often hard to see the misuse until it’s in the rear­view mirror.\n\nOffers & Deals\n\nOften, features need to move up or down the inheritance hierarchy. Several refactorings\n\ndeal with that: Pull Up Method (350), Pull Up Field (353), Pull Up Constructor Body\n\nHighlights\n\n(355), Push Down Method (359), and Push Down Field (361). I can add and remove\n\nclasses from the hierarchy with Extract Superclass (375), Remove Subclass (369), and\n\nSettings\n\nCollapse Hierarchy (380). I may want to add a subclass to replace a field that I’m using\n\nSupport\n\nto trigger different behavior based on its value; I do this with Replace Type Code with\n\nSubclasses (362).\n\nSign Out\n\nInheritance is a powerful tool, but sometimes it gets used in the wrong place—or the\n\nplace it’s used in becomes wrong. In that case, I use Replace Subclass with Delegate\n\n(381) or Replace Superclass with Delegate (399) to turn inheritance into delegation.\n\nPULL UP METHOD\n\ninverse of: Push Down Method (359)\n\nwww.EBooksWorld.ir",
      "content_length": 1249,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 390,
      "content": "Motivation\n\nEliminating duplicate code is important. Two duplicate methods may work fine as they\n\nare, but they are nothing but a breeding ground for bugs in the future. Whenever there\n\nis duplication, there is risk that an alteration to one copy will not be made to the other.\n\nUsually, it is difficult to find the duplicates.\n\nThe easiest case of using Pull Up Method is when the methods have the same body,\n\nimplying there’s been a copy and paste. Of course it’s not always as obvious as that. I\n\ncould just do the refactoring and see if the tests croak—but that puts a lot of reliance on\n\nmy tests. I usually find it valuable to look for the differences—often, they show up\n\nbehavior that I forgot to test for.\n\nOften, Pull Up Method comes after other steps. I see two methods in different classes\n\nthat can be parameterized in such a way that they end up as essentially the same\n\nmethod. In that case, the smallest step is for me to apply Parameterize Function (310)\n\nseparately and then Pull Up Method.\n\nwww.EBooksWorld.ir",
      "content_length": 1028,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 391,
      "content": "The most awkward complication with Pull Up Method is if the body of the method\n\nrefers to features that are on the subclass but not on the superclass. When that\n\nhappens, I need to use Pull Up Field (353) and Pull Up Method on those elements first.\n\nIf I have two methods with a similar overall flow, but differing in details, I’ll consider\n\nthe Form Template Method [mf­ft].\n\nMechanics\n\nInspect methods to ensure they are identical.\n\nIf they do the same thing, but are not identical, refactor them until they have\n\nidentical bodies.\n\nCheck that all method calls and field references inside the method body refer to\n\nfeatures that can be called from the superclass.\n\nIf the methods have different signatures, use Change Function Declaration (124) to\n\nget them to the one you want to use on the superclass.\n\nCreate a new method in the superclass. Copy the body of one of the methods over to\n\nit.\n\nRun static checks.\n\nDelete one subclass method.\n\nTest.\n\nKeep deleting subclass methods until they are all gone.\n\nExample\n\nI have two subclass methods that do the same thing.\n\nclass Employee extends Party…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nwww.EBooksWorld.ir",
      "content_length": 1203,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 392,
      "content": "class Department extends Party…\n\nClick here to view code image\n\nget totalAnnualCost() { return this.monthlyCost * 12; }\n\nI look at both classes and see that they refer to the monthlyCost property which isn’t\n\ndefined on the superclass, but is present in both subclasses. Since I’m in a dynamic\n\nlanguage, I’m OK; if I were in a static language, I’d need to define an abstract method\n\non Party.\n\nThe methods have different names, so I Change Function Declaration (124) to make\n\nthem the same.\n\nclass Department…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nI copy the method from one subclass and paste it into the superclass.\n\nclass Party…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nIn a static language, I’d compile to ensure that all the references were OK. That won’t\n\nhelp me here, so I first remove annualCost from Employee, test, and then remove it\n\nfrom Department.\n\nThat completes the refactoring, but does leave a question. annualCost calls\n\nmonthlyCost, but monthlyCost doesn’t appear in the Party class. It all works,\n\nbecause JavaScript is a dynamic language—but there is value in signaling that\n\nwww.EBooksWorld.ir",
      "content_length": 1207,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 393,
      "content": "subclasses of Party should provide an implementation for monthlyCost, particularly\n\nif more subclasses get added later on. A good way to provide this signal is a trap method\n\nlike this:\n\nclass Party…\n\nClick here to view code image\n\nget monthlyCost() { throw new SubclassResponsibilityError(); }\n\nI call such an error a subclass responsibility error as that was the name used in\n\nSmalltalk.\n\nPULL UP FIELD\n\ninverse of: Push Down Field (361)\n\nwww.EBooksWorld.ir\n\nMotivation",
      "content_length": 471,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 394,
      "content": "Motivation\n\nIf subclasses are developed independently, or combined through refactoring, I often\n\nfind that they duplicate features. In particular, certain fields can be duplicates. Such\n\nfields sometimes have similar names—but not always. The only way I can tell what is\n\ngoing on is by looking at the fields and examining how they are used. If they are being\n\nused in a similar way, I can pull them up into the superclass.\n\nBy doing this, I reduce duplication in two ways. I remove the duplicate data declaration\n\nand I can then move behavior that uses the field from the subclasses to the superclass.\n\nMany dynamic languages do not define fields as part of their class definition—instead,\n\nfields appear when they are first assigned to. In this case, pulling up a field is essentially\n\na consequence of Pull Up Constructor Body (355).\n\nMechanics\n\nInspect all users of the candidate field to ensure they are used in the same way.\n\nIf the fields have different names, use Rename Field (244) to give them the same\n\nname.\n\nCreate a new field in the superclass.\n\nThe new field will need to be accessible to subclasses (protected in common\n\nlanguages).\n\nDelete the subclass fields.\n\nTest.\n\nPULL UP CONSTRUCTOR BODY\n\nwww.EBooksWorld.ir",
      "content_length": 1230,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 395,
      "content": "Motivation\n\nConstructors are tricky things. They aren’t quite normal methods—so I’m more\n\nrestricted in what I can do with them.\n\nIf I see subclass methods with common behavior, my first thought is to use Extract\n\nFunction (106) followed by Pull Up Method (350), which will move it nicely into the\n\nsuperclass. Constructors tangle that—because they have special rules about what can be\n\ndone in what order, so I need a slightly different approach.\n\nwww.EBooksWorld.ir",
      "content_length": 467,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 396,
      "content": "If this refactoring starts getting messy, I reach for Replace Constructor with Factory\n\nFunction (334).\n\nMechanics\n\nDefine a superclass constructor, if one doesn’t already exist. Ensure it’s called by\n\nsubclass constructors.\n\nUse Slide Statements (223) to move any common statements to just after the super\n\ncall.\n\nRemove the common code from each subclass and put it in the superclass. Add to\n\nthe super call any constructor parameters referenced in the common code.\n\nTest.\n\nIf there is any common code that cannot move to the start of the constructor, use\n\nExtract Function (106) followed by Pull Up Method (350).\n\nExample\n\nI start with the following code:\n\nClick here to view code image\n\nclass Party {}\n\nclass Employee extends Party {\n\nconstructor(name, id, monthlyCost) { super(); this._id = id; this._name = name; this._monthlyCost = monthlyCost; } // rest of class...\n\nclass Department extends Party {\n\nconstructor(name, staff){ super(); this._name = name; this._staff = staff; } // rest of class...\n\nThe common code here is the assignment of the name. I use Slide Statements (223) to\n\nwww.EBooksWorld.ir",
      "content_length": 1110,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 397,
      "content": "move the assignment in Employee next to the call to super():\n\nClick here to view code image\n\nclass Employee extends Party { constructor(name, id, monthlyCost) { super(); this._name = name; this._id = id; this._monthlyCost = monthlyCost; } // rest of class...\n\nWith that tested, I move the common code to the superclass. Since that code contains a\n\nreference to a constructor argument, I pass that in as a parameter.\n\nclass Party…\n\nconstructor(name){ this._name = name; }\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, id, monthlyCost) { super(name); this._id = id; this._monthlyCost = monthlyCost; }\n\nclass Department…\n\nconstructor(name, staff){ super(name); this._staff = staff; }\n\nRun the tests, and I’m done.\n\nMost of the time, constructor behavior will work like this: Do the common elements\n\nfirst (with a super call), then do extra work that the subclass needs. Occasionally, www.EBooksWorld.ir",
      "content_length": 920,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 398,
      "content": "however, there is some common behavior later.\n\nConsider this example:\n\nclass Employee…\n\nconstructor (name) {...}\n\nget isPrivileged() {...}\n\nassignCar() {...}\n\nclass Manager extends Employee…\n\nClick here to view code image\n\nconstructor(name, grade) { super(name); this._grade = grade; if (this.isPrivileged) this.assignCar(); // every subclass does this }\n\nget isPrivileged() { return this._grade > 4; }\n\nThe wrinkle here comes from the fact that the call to isPrivileged can’t be made\n\nuntil after the grade field is assigned, and that can only be done in the subclass.\n\nIn this case, I do Extract Function (106) on the common code:\n\nclass Manager…\n\nClick here to view code image\n\nconstructor(name, grade) { super(name); this._grade = grade; this.finishConstruction(); }\n\nfinishConstruction() { if (this.isPrivileged) this.assignCar(); }\n\nwww.EBooksWorld.ir",
      "content_length": 857,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 399,
      "content": "Then, I use Pull Up Method (350) to move it to the superclass.\n\nclass Employee…\n\nClick here to view code image\n\nfinishConstruction() { if (this.isPrivileged) this.assignCar(); }\n\nPUSH DOWN METHOD\n\ninverse of: Pull Up Method (350)\n\nMotivation\n\nIf a method is only relevant to one subclass (or a small proportion of subclasses),\n\nremoving it from the superclass and putting it only on the subclass(es) makes that\n\nclearer. I can only do this refactoring if the caller knows it’s working with a particular\n\nsubclass—otherwise, I should use Replace Conditional with Polymorphism (272) with\n\nsome placebo behavior on the superclass.\n\nwww.EBooksWorld.ir\n\nMechanics",
      "content_length": 658,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 400,
      "content": "Mechanics\n\nCopy the method into every subclass that needs it.\n\nRemove the method from the superclass.\n\nTest.\n\nRemove the method from each superclass that doesn’t need it.\n\nTest.\n\nPUSH DOWN FIELD\n\ninverse of: Pull Up Field (353)\n\nMotivation\n\nIf a field is only used by one subclass (or a small proportion of subclasses), I move it to\n\nthose subclasses.\n\nMechanics\n\nwww.EBooksWorld.ir",
      "content_length": 382,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 401,
      "content": "Declare field in all subclasses that need it.\n\nRemove the field from the superclass.\n\nTest.\n\nRemove the field from all subclasses that don’t need it.\n\nTest.\n\nREPLACE TYPE CODE WITH SUBCLASSES\n\nsubsumes: Replace Type Code with State/Strategy\n\nsubsumes: Extract Subclass\n\ninverse of: Remove Subclass (369)\n\nMotivation\n\nSoftware systems often need to represent different kinds of a similar thing. I may\n\nclassify employees by their job type (engineer, manager, salesman), or orders by their\n\npriority (rush, regular). My first tool for handling this is some kind of type code field—\n\nwww.EBooksWorld.ir",
      "content_length": 599,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 402,
      "content": "depending on the language, that might be an enum, symbol, string, or number. Often,\n\nthis type code will come from an external service that provides me with the data I’m\n\nworking on.\n\nMost of the time, such a type code is all I need. But there are a couple of situations\n\nwhere I could do with something more, and that something more are subclasses. There\n\nare two things that are particularly enticing about subclasses. First, they allow me to\n\nuse polymorphism to handle conditional logic. I find this most helpful when I have\n\nseveral functions that invoke different behavior depending on the value of the type\n\ncode. With subclasses, I can apply Replace Conditional with Polymorphism (272) to\n\nthese functions.\n\nThe second case is where I have fields or methods that are only valid for particular\n\nvalues of a type code, such as a sales quota that’s only applicable to the “salesman” type\n\ncode. I can then create the subclass and apply Push Down Field (361). While I can\n\ninclude validation logic to ensure a field is only used when the type code has the correct\n\nvalue, using a subclass makes the relationship more explicit.\n\nWhen using Replace Type Code with Subclasses, I need to consider whether to apply it\n\ndirectly to the class I’m looking at, or to the type code itself. Do I make engineer a\n\nsubtype of employee, or should I give the employee an employee type property which\n\ncan have subtypes for engineer and manager? Using direct subclassing is simpler, but I\n\ncan’t use it for the job type if I need it for something else. I also can’t use direct\n\nsubclasses if the type is mutable. If I need to move the subclasses to an employee type\n\nproperty, I can do that by using Replace Primitive with Object (174) on the type code to\n\ncreate an employee type class and then using Replace Type Code with Subclasses on\n\nthat new class.\n\nMechanics\n\nSelf­encapsulate the type code field.\n\nPick one type code value. Create a subclass for that type code. Override the type\n\ncode getter to return the literal type code value.\n\nCreate selector logic to map from the type code parameter to the new subclass.\n\nWith direct inheritance, use Replace Constructor with Factory Function (334) and\n\nput the selector logic in the factory. With indirect inheritance, the selector logic may\n\nstay in the constructor.\n\nwww.EBooksWorld.ir",
      "content_length": 2326,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 403,
      "content": "Test.\n\nRepeat creating the subclass and adding to the selector logic for each type code\n\nvalue. Test after each change.\n\nRemove the type code field.\n\nTest.\n\nUse Push Down Method (359) and Replace Conditional with Polymorphism (272)\n\non any methods that use the type code accessors. Once all are replaced, you can\n\nremove the type code accessors.\n\nExample\n\nI’ll start with this overused employee example:\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, type){ this.validateType(type); this._name = name; this._type = type; } validateType(arg) { if (![\"engineer\", \"manager\", \"salesman\"].includes(arg)) throw new Error(`Employee cannot be of type ${arg}`); } toString() {return `${this._name} (${this._type})`;}\n\nMy first step is to use Encapsulate Variable (132) to self­encapsulate the type code.\n\nclass Employee…\n\nClick here to view code image\n\nget type() {return this._type;} toString() {return `${this._name} (${this.type})`;}\n\nNote that toString uses the new getter by removing the underscore.\n\nI pick one type code, the engineer, to start with. I use direct inheritance, subclassing the\n\nwww.EBooksWorld.ir",
      "content_length": 1129,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 404,
      "content": "employee class itself. The employee subclass is simple—just overriding the type code\n\ngetter with the appropriate literal value.\n\nClick here to view code image\n\nclass Engineer extends Employee { get type() {return \"engineer\";} }\n\nAlthough JavaScript constructors can return other objects, things will get messy if I try\n\nto put selector logic in there, since that logic gets intertwined with field initialization. So\n\nI use Replace Constructor with Factory Function (334) to create a new space for it.\n\nClick here to view code image\n\nfunction createEmployee(name, type) { return new Employee(name, type); }\n\nTo use the new subclass, I add selector logic into the factory.\n\nClick here to view code image\n\nfunction createEmployee(name, type) { switch (type) { case \"engineer\": return new Engineer(name, type); } return new Employee(name, type); }\n\nI test to ensure that worked out correctly. But, because I’m paranoid, I then alter the\n\nreturn value of the engineer’s override and test again to ensure the test fails. That way I\n\nknow the subclass is being used. I correct the return value and continue with the other\n\ncases. I can do them one at a time, testing after each change.\n\nClick here to view code image\n\nclass Salesman extends Employee { get type() {return \"salesman\";} }\n\nclass Manager extends Employee { get type() {return \"manager\";}\n\nwww.EBooksWorld.ir",
      "content_length": 1364,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 405,
      "content": "}\n\nfunction createEmployee(name, type) { switch (type) { case \"engineer\": return new Engineer(name, type); case \"salesman\": return new Salesman(name, type); case \"manager\": return new Manager (name, type); } return new Employee(name, type); }\n\nOnce I’m done with them all, I can remove the type code field and the superclass\n\ngetting method (the ones in the subclasses remain).\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, type){ this.validateType(type); this._name = name; this._type = type; }\n\nget type() {return this._type;} toString() {return `${this._name} (${this.type})`;}\n\nAfter testing to ensure all is still well, I can remove the validation logic, since the switch\n\nis effectively doing the same thing.\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, type){ this.validateType(type); this._name = name; }\n\nfunction createEmployee(name, type) { switch (type) { case \"engineer\": return new Engineer(name, type); case \"salesman\": return new Salesman(name, type); case \"manager\": return new Manager (name, type); default: throw new Error(`Employee cannot be of type ${type}`); } return new Employee(name, type);\n\nwww.EBooksWorld.ir",
      "content_length": 1178,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 406,
      "content": "}\n\nThe type argument to the constructor is now useless, so it falls victim to Change\n\nFunction Declaration (124).\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, type){ this._name = name; }\n\nfunction createEmployee(name, type) { switch (type) { case \"engineer\": return new Engineer(name, type); case \"salesman\": return new Salesman(name, type); case \"manager\": return new Manager (name, type); default: throw new Error(`Employee cannot be of type ${type}`); } }\n\nI still have the type code accessors on the subclasses—get type. I’ll usually want to\n\nremove these too, but that may take a bit of time due to other methods that depend on\n\nthem. I’ll use Replace Conditional with Polymorphism (272) and Push Down Method\n\n(359) to deal with these. At some point, I’ll have no code that uses the type getters, so I\n\nwill subject them to the tender mercies of Remove Dead Code (237).\n\nExample: Using Indirect Inheritance\n\nLet’s go back to the starting case—but this time, I already have existing subclasses for\n\npart­time and full­time employees, so I can’t subclass from Employee for the type\n\ncodes. Another reason to not use direct inheritance is keeping the ability to change the\n\ntype of employee.\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, type){ this.validateType(type); this._name = name; this._type = type; }\n\nwww.EBooksWorld.ir",
      "content_length": 1374,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 407,
      "content": "validateType(arg) { if (![\"engineer\", \"manager\", \"salesman\"].includes(arg)) throw new Error(`Employee cannot be of type ${arg}`); } get type() {return this._type;} set type(arg) {this._type = arg;}\n\nget capitalizedType() { return this._type.charAt(0).toUpperCase() + this._type.substr(1).toLowerCase(); } toString() { return `${this._name} (${this.capitalizedType})`; }\n\nThis time toString is a bit more complicated, to allow me to illustrate something\n\nshortly.\n\nMy first step is to use Replace Primitive with Object (174) on the type code.\n\nClick here to view code image\n\nclass EmployeeType { constructor(aString) { this._value = aString; } toString() {return this._value;} }\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, type){ this.validateType(type); this._name = name; this.type = type; } validateType(arg) { if (![\"engineer\", \"manager\", \"salesman\"].includes(arg)) throw new Error(`Employee cannot be of type ${arg}`); } get typeString() {return this._type.toString();} get type() {return this._type;} set type(arg) {this._type = new EmployeeType(arg);}\n\nget capitalizedType() { return this.typeString.charAt(0).toUpperCase()\n\nwww.EBooksWorld.ir",
      "content_length": 1172,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 408,
      "content": "+ this.typeString.substr(1).toLowerCase(); } toString() { return `${this._name} (${this.capitalizedType})`; }\n\nI then apply the usual mechanics of Replace Type Code with Subclasses to the employee\n\ntype.\n\nclass Employee…\n\nClick here to view code image\n\nset type(arg) {this._type = Employee.createEmployeeType(arg);}\n\nstatic createEmployeeType(aString) { switch(aString) { case \"engineer\": return new Engineer(); case \"manager\": return new Manager (); case \"salesman\": return new Salesman(); default: throw new Error(`Employee cannot be of type ${aString}`); } }\n\nclass EmployeeType { } class Engineer extends EmployeeType { toString() {return \"engineer\";} } class Manager extends EmployeeType { toString() {return \"manager\";} } class Salesman extends EmployeeType { toString() {return \"salesman\";} }\n\nIf I were leaving it at that, I could remove the empty EmployeeType. But I prefer to\n\nleave it there as it makes explicit the relationship between the various subclasses. It’s\n\nalso a handy spot for moving other behavior there, such as the capitalization logic I\n\ntossed into the example specifically to illustrate this point.\n\nclass Employee…\n\nClick here to view code image\n\ntoString() {\n\nwww.EBooksWorld.ir",
      "content_length": 1209,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 409,
      "content": "return `${this._name} (${this.type.capitalizedName})`; }\n\nclass EmployeeType…\n\nClick here to view code image\n\nget capitalizedName() { return this.toString().charAt(0).toUpperCase() + this.toString().substr(1).toLowerCase(); }\n\nFor those familiar with the first edition of the book, this example essentially supersedes\n\nthe Replace Type Code with State/Strategy. I now think of that refactoring as Replace\n\nType Code with Subclasses using indirect inheritance, so didn’t consider it worth its\n\nown entry in the catalog. (I never liked the name anyway.)\n\nREMOVE SUBCLASS\n\nformerly: Replace Subclass with Fields\n\ninverse of: Replace Type Code with Subclasses (362)\n\nwww.EBooksWorld.ir",
      "content_length": 681,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 410,
      "content": "Motivation\n\nSubclasses are useful. They support variations in data structure and polymorphic\n\nbehavior. They are a good way to program by difference. But as a software system\n\nevolves, subclasses can lose their value as the variations they support are moved to\n\nother places or removed altogether. Sometimes, subclasses are added in anticipation of\n\nfeatures that never end up being built, or end up being built in a way that doesn’t need\n\nthe subclasses.\n\nA subclass that does too little incurs a cost in understanding that is no longer\n\nworthwhile. When that time comes, it’s best to remove the subclass, replacing it with a\n\nfield on its superclass.\n\nMechanics\n\nUse Replace Constructor with Factory Function (334) on the subclass constructor.\n\nIf the clients of the constructors use a data field to decide which subclass to create,\n\nput that decision logic into a superclass factory method.\n\nIf any code tests against the subclass’s types, use Extract Function (106) on the type\n\nwww.EBooksWorld.ir",
      "content_length": 1001,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 411,
      "content": "test and Move Function (198) to move it to the superclass. Test after each change.\n\nCreate a field to represent the subclass type.\n\nChange the methods that refer to the subclass to use the new type field.\n\nDelete the subclass.\n\nTest.\n\nOften, this refactoring is used on a group of subclasses at once—in which case carry out\n\nthe steps to encapsulate them (add factory function, move type tests) first, then\n\nindividually fold them into the superclass.\n\nExample\n\nI’ll start with this stump of subclasses:\n\nclass Person…\n\nClick here to view code image\n\nconstructor(name) { this._name = name; } get name() {return this._name;} get genderCode() {return \"X\";} // snip\n\nclass Male extends Person { get genderCode() {return \"M\";} }\n\nclass Female extends Person { get genderCode() {return \"F\";} }\n\nIf that’s all that a subclass does, it’s not really worth having. But before I remove these\n\nsubclasses, it’s usually worth checking to see if there’s any subclass­dependent behavior\n\nin the clients that should be moved in there. In this case, I don’t find anything worth\n\nkeeping the subclasses for.\n\nclient…\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1150,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 412,
      "content": "const numberOfMales = people.filter(p => p instanceof Male).length;\n\nWhenever I want to change how I represent something, I try to first encapsulate the\n\ncurrent representation to minimize the impact on any client code. When it comes to\n\ncreating subclasses, the way to encapsulate is to use Replace Constructor with Factory\n\nFunction (334). In this case, there’s a couple of ways I could make the factory.\n\nThe most direct way is to create a factory method for each constructor.\n\nClick here to view code image\n\nfunction createPerson(name) { return new Person(name); } function createMale(name) { return new Male(name); } function createFemale(name) { return new Female(name); }\n\nBut although that’s the direct choice, objects like this are often loaded from a source\n\nthat uses the gender codes directly.\n\nClick here to view code image\n\nfunction loadFromInput(data) { const result = []; data.forEach(aRecord => { let p; switch (aRecord.gender) { case 'M': p = new Male(aRecord.name); break; case 'F': p = new Female(aRecord.name); break; default: p = new Person(aRecord.name); } result.push(p); }); return result; }\n\nIn that case, I find it better to use Extract Function (106) on the selection logic for\n\nwhich class to create, and make that the factory function.\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 1316,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 413,
      "content": "function createPerson(aRecord) { let p; switch (aRecord.gender) { case 'M': p = new Male(aRecord.name); break; case 'F': p = new Female(aRecord.name); break; default: p = new Person(aRecord.name); } return p; }\n\nfunction loadFromInput(data) { const result = []; data.forEach(aRecord => { result.push(createPerson(aRecord)); }); return result; }\n\nWhile I’m there, I’ll clean up those two functions. I’ll use Inline Variable (123) on\n\ncreatePerson:\n\nClick here to view code image\n\nfunction createPerson(aRecord) { switch (aRecord.gender) { case 'M': return new Male (aRecord.name); case 'F': return new Female(aRecord.name); default: return new Person(aRecord.name); } }\n\nand Replace Loop with Pipeline (231) on loadFromInput:\n\nClick here to view code image\n\nfunction loadFromInput(data) { return data.map(aRecord => createPerson(aRecord)); }\n\nThe factory encapsulates the creation of the subclasses, but there is also the use of\n\ninstanceof—which never smells good. I use Extract Function (106) on the type\n\ncheck.\n\nclient…\n\nwww.EBooksWorld.ir",
      "content_length": 1042,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 414,
      "content": "Click here to view code image\n\nconst numberOfMales = people.filter(p => isMale(p)).length;\n\nfunction isMale(aPerson) {return aPerson instanceof Male;}\n\nThen I use Move Function (198) to move it into Person.\n\nclass Person…\n\nClick here to view code image\n\nget isMale() {return this instanceof Male;}\n\nclient…\n\nClick here to view code image\n\nconst numberOfMales = people.filter(p => p.isMale).length;\n\nWith that refactoring done, all knowledge of the subclasses is now safely encased within\n\nthe superclass and the factory function. (Usually I’m wary of a superclass referring to a\n\nsubclass, but this code isn’t going to last until my next cup of tea, so I’m not going worry\n\nabout it.)\n\nI now add a field to represent the difference between the subclasses; since I’m using a\n\ncode loaded from elsewhere, I might as well just use that.\n\nclass Person…\n\nClick here to view code image\n\nconstructor(name, genderCode) { this._name = name; this._genderCode = genderCode || \"X\"; }\n\nget genderCode() {return this._genderCode;}\n\nWhen initializing it, I set it to the default case. (As a side note, although most people\n\ncan be classified as male or female, there are people who can’t. It’s a common modeling\n\nwww.EBooksWorld.ir",
      "content_length": 1216,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 415,
      "content": "mistake to forget that.)\n\nI then take the male case and fold its logic into the superclass. This involves modifying\n\nthe factory to return a Person and modifying any instanceof tests to use the gender\n\ncode field.\n\nClick here to view code image\n\nfunction createPerson(aRecord) { switch (aRecord.gender) { case 'M': return new Person(aRecord.name, \"M\"); case 'F': return new Female(aRecord.name); default: return new Person(aRecord.name); } }\n\nclass Person…\n\nClick here to view code image\n\nget isMale() {return \"M\" === this._genderCode;}\n\nI test, remove the male subclass, test again, and repeat for the female subclass.\n\nClick here to view code image\n\nfunction createPerson(aRecord) { switch (aRecord.gender) { case 'M': return new Person(aRecord.name, \"M\"); case 'F': return new Person(aRecord.name, \"F\"); default: return new Person(aRecord.name); } }\n\nI find the lack of symmetry with the gender code to be annoying. A future reader of the\n\ncode will always wonder about this lack of symmetry. So I prefer to change the code to\n\nmake it symmetrical—if I can do it without introducing any other complexity, which is\n\nthe case here.\n\nClick here to view code image\n\nfunction createPerson(aRecord) { switch (aRecord.gender) {\n\nwww.EBooksWorld.ir",
      "content_length": 1243,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 416,
      "content": "case 'M': return new Person(aRecord.name, \"M\"); case 'F': return new Person(aRecord.name, \"F\"); default: return new Person(aRecord.name, \"X\"); } }\n\nclass Person…\n\nClick here to view code image\n\nconstructor(name, genderCode) { this._name = name; this._genderCode = genderCode || \"X\"; }\n\nEXTRACT SUPERCLASS\n\nwww.EBooksWorld.ir",
      "content_length": 324,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 417,
      "content": "Motivation\n\nIf I see two classes doing similar things, I can take advantage of the basic mechanism of\n\ninheritance to pull their similarities together into a superclass. I can use Pull Up Field\n\n(353) to move common data into the superclass, and Pull Up Method (350) to move the\n\ncommon behavior.\n\nMany writers on object orientation treat inheritance as something that should be\n\ncarefully planned in advance, based on some kind of classification structure in the “real\n\nworld.” Such classification structures can be a hint towards using inheritance—but just\n\nwww.EBooksWorld.ir",
      "content_length": 578,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 418,
      "content": "as often inheritance is something I realize during the evolution of a program, as I find\n\ncommon elements that I want to pull together.\n\nAn alternative to Extract Superclass is Extract Class (182). Here you have, essentially, a\n\nchoice between using inheritance or delegation as a way to unify duplicate behavior.\n\nOften Extract Superclass is the simpler approach, so I’ll do this first knowing I can use\n\nReplace Superclass with Delegate (399) should I need to later.\n\nMechanics\n\nCreate an empty superclass. Make the original classes its subclasses.\n\nIf needed, use Change Function Declaration (124) on the constructors.\n\nTest.\n\nOne by one, use Pull Up Constructor Body (355), Pull Up Method (350), and Pull\n\nUp Field (353) to move common elements to the superclass.\n\nExamine remaining methods on the subclasses. See if there are common parts. If so,\n\nuse Extract Function (106) followed by Pull Up Method (350).\n\nCheck clients of the original classes. Consider adjusting them to use the superclass\n\ninterface.\n\nExample\n\nI’m pondering these two classes, they share some common functionality—their name\n\nand the notions of annual and monthly costs:\n\nClick here to view code image\n\nclass Employee {\n\nconstructor(name, id, monthlyCost) { this._id = id; this._name = name; this._monthlyCost = monthlyCost; } get monthlyCost() {return this._monthlyCost;} get name() {return this._name;} get id() {return this._id;}\n\nget annualCost() { return this.monthlyCost * 12; }\n\nwww.EBooksWorld.ir",
      "content_length": 1482,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 419,
      "content": "}\n\nclass Department { constructor(name, staff){ this._name = name; this._staff = staff; } get staff() {return this._staff.slice();} get name() {return this._name;}\n\nget totalMonthlyCost() { return this.staff .map(e => e.monthlyCost) .reduce((sum, cost) => sum + cost); } get headCount() { return this.staff.length; } get totalAnnualCost() { return this.totalMonthlyCost * 12; } }\n\nI can make the common behavior more explicit by extracting a common superclass\n\nfrom them.\n\nI begin by creating an empty superclass and letting them both extend from it.\n\nClick here to view code image\n\nclass Party {}\n\nclass Employee extends Party { constructor(name, id, monthlyCost) { super(); this._id = id; this._name = name; this._monthlyCost = monthlyCost; } // rest of class...\n\nclass Department extends Party { constructor(name, staff){ super(); this._name = name; this._staff = staff; } // rest of class...\n\nwww.EBooksWorld.ir",
      "content_length": 915,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 420,
      "content": "When doing Extract Superclass, I like to start with the data, which in JavaScript\n\ninvolves manipulating the constructor. So I start with Pull Up Field (353) to pull up the\n\nname.\n\nclass Party…\n\nconstructor(name){ this._name = name; }\n\nclass Employee…\n\nClick here to view code image\n\nconstructor(name, id, monthlyCost) { super(name); this._id = id; this._monthlyCost = monthlyCost; }\n\nclass Department…\n\nconstructor(name, staff){ super(name); this._staff = staff; }\n\nAs I get data up to the superclass, I can also apply Pull Up Method (350) on associated\n\nmethods. First, the name:\n\nclass Party…\n\nClick here to view code image\n\nget name() {return this._name;}\n\nclass Employee…\n\nClick here to view code image\n\nget name() {return this._name;}\n\nwww.EBooksWorld.ir",
      "content_length": 760,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 421,
      "content": "class Department…\n\nClick here to view code image\n\nget name() {return this._name;}\n\nI have two methods with similar bodies.\n\nclass Employee…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nclass Department…\n\nClick here to view code image\n\nget totalAnnualCost() { return this.totalMonthlyCost * 12; }\n\nThe methods they use, monthlyCost and totalMonthlyCost, have different names\n\nand different bodies—but do they represent the same intent? If so, I should use Change\n\nFunction Declaration (124) to unify their names.\n\nclass Department…\n\nClick here to view code image\n\nget totalAnnualCost() { return this.monthlyCost * 12; }\n\nget monthlyCost() { … }\n\nI then do a similar renaming to the annual costs:\n\nclass Department…\n\nwww.EBooksWorld.ir",
      "content_length": 772,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 422,
      "content": "Click here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nI can now apply Pull Up Method (350) to the annual cost methods.\n\nclass Party…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nclass Employee…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nclass Department…\n\nClick here to view code image\n\nget annualCost() { return this.monthlyCost * 12; }\n\nCOLLAPSE HIERARCHY\n\nwww.EBooksWorld.ir",
      "content_length": 486,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 423,
      "content": "Motivation\n\nWhen I’m refactoring a class hierarchy, I’m often pulling and pushing features around.\n\nAs the hierarchy evolves, I sometimes find that a class and its parent are no longer\n\ndifferent enough to be worth keeping separate. At this point, I’ll merge them together.\n\nMechanics\n\nChoose which one to remove.\n\nI choose based on which name makes most sense in the future. If neither name is\n\nbest, I’ll pick one arbitrarily.\n\nUse Pull Up Field (353), Push Down Field (361), Pull Up Method (350), and Push\n\nDown Method (359) to move all the elements into a single class.\n\nAdjust any references to the victim to change them to the class that will stay.\n\nRemove the empty class.\n\nTest.\n\nREPLACE SUBCLASS WITH DELEGATE\n\nwww.EBooksWorld.ir",
      "content_length": 738,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 424,
      "content": "Motivation\n\nIf I have some objects whose behavior varies from category to category, the natural\n\nmechanism to express this is inheritance. I put all the common data and behavior in the\n\nsuperclass, and let each subclass add and override features as needed. Object­oriented\n\nlanguages make this simple to implement and thus a familiar mechanism.\n\nBut inheritance has its downsides. Most obviously, it’s a card that can only be played\n\nonce. If I have more than one reason to vary something, I can only use inheritance for a\n\nsingle axis of variation. So, if I want to vary behavior of people by their age category and\n\nby their income level, I can either have subclasses for young and senior, or for well­off\n\nand poor—I can’t have both.\n\nwww.EBooksWorld.ir",
      "content_length": 756,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 425,
      "content": "A further problem is that inheritance introduces a very close relationship between\n\nclasses. Any change I want to make to the parent can easily break children, so I have to\n\nbe careful and understand how children derive from the superclass. This problem is\n\nmade worse when the logic of the two classes resides in different modules and is looked\n\nafter by different teams.\n\nDelegation handles both of these problems. I can delegate to many different classes for\n\ndifferent reasons. Delegation is a regular relationship between objects—so I can have a\n\nclear interface to work with, which is much less coupling than subclassing. It’s therefore\n\ncommon to run into the problems with subclassing and apply Replace Subclass with\n\nDelegate.\n\nThere is a popular principle: “Favor object composition over class inheritance” (where\n\ncomposition is effectively the same as delegation). Many people take this to mean\n\n“inheritance considered harmful” and claim that we should never use inheritance. I use\n\ninheritance frequently, partly because I always know I can use Replace Subclass with\n\nDelegate should I need to change it later. Inheritance is a valuable mechanism that does\n\nthe job most of the time without problems. So I reach for it first, and move onto\n\ndelegation when it starts to rub badly. This usage is actually consistent with the\n\nprinciple—which comes from the Gang of Four book [gof] that explains how inheritance\n\nand composition work together. The principle was a reaction to the overuse of\n\ninheritance.\n\nThose who are familiar with the Gang of Four book may find it helpful to think of this\n\nrefactoring as replacing subclasses with the State or Strategy patterns. Both of these\n\npatterns are structurally the same, relying on the host delegating to a separate\n\nhierarchy. Not all cases of Replace Subclass with Delegate involve an inheritance\n\nhierarchy for the delegate (as the first example below illustrates), but setting up a\n\nhierarchy for states or strategies is often useful.\n\nMechanics\n\nIf there are many callers for the constructors, apply Replace Constructor with\n\nFactory Function (334).\n\nCreate an empty class for the delegate. Its constructor should take any subclass­\n\nspecific data as well as, usually, a back­reference to the superclass.\n\nAdd a field to the superclass to hold the delegate.\n\nModify the creation of the subclass so that it initializes the delegate field with an\n\nwww.EBooksWorld.ir",
      "content_length": 2428,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 426,
      "content": "instance of the delegate.\n\nThis can be done in the factory function, or in the constructor if the constructor can\n\nreliably tell whether to create the correct delegate.\n\nChoose a subclass method to move to the delegate class.\n\nUse Move Function (198) to move it to the delegate class. Don’t remove the source’s\n\ndelegating code.\n\nIf the method needs elements that should move to the delegate, move them. If it\n\nneeds elements that should stay in the superclass, add a field to the delegate that\n\nrefers to the superclass.\n\nIf the source method has callers outside the class, move the source’s delegating code\n\nfrom the subclass to the superclass, guarding it with a check for the presence of the\n\ndelegate. If not, apply Remove Dead Code (237).\n\nIf there’s more than one subclass, and you start duplicating code within them, use\n\nExtract Superclass (375). In this case, any delegating methods on the source super­\n\nclass no longer need a guard if the default behavior is moved to the delegate\n\nsuperclass.\n\nTest.\n\nRepeat until all the methods of the subclass are moved.\n\nFind all callers of the subclasses’s constructor and change them to use the\n\nsuperclass constructor.\n\nTest.\n\nUse Remove Dead Code (237) on the subclass.\n\nExample\n\nI have a class that makes a booking for a show.\n\nclass Booking…\n\nconstructor(show, date) { this._show = show; this._date = date;\n\nwww.EBooksWorld.ir",
      "content_length": 1382,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 427,
      "content": "}\n\nThere is a subclass for premium booking that takes into account various extras that are\n\navailable.\n\nclass PremiumBooking extends Booking…\n\nClick here to view code image\n\nconstructor(show, date, extras) { super(show, date); this._extras = extras; }\n\nThere are quite a few changes that the premium booking makes to what it inherits from\n\nthe superclass. As is typical with this kind of programming­by­difference, in some cases\n\nthe subclass overrides methods on the superclass, in others it adds new methods that\n\nare only relevant for the subclass. I won’t go into all of them, but I will pick out a few\n\ninteresting cases.\n\nFirst, there is a simple override. Regular bookings offer a talkback after the show, but\n\nonly on nonpeak days.\n\nclass Booking…\n\nClick here to view code image\n\nget hasTalkback() { return this._show.hasOwnProperty('talkback') && !this.isPeakDay; }\n\nPremium bookings override this to offer talkbacks on all days.\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget hasTalkback() { return this._show.hasOwnProperty('talkback'); }\n\nDetermining the price is a similar override, with a twist that the premium method calls\n\nwww.EBooksWorld.ir",
      "content_length": 1170,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 428,
      "content": "the superclass method.\n\nclass Booking…\n\nClick here to view code image\n\nget basePrice() { let result = this._show.price; if (this.isPeakDay) result += Math.round(result * 0.15); return result; }\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget basePrice() { return Math.round(super.basePrice + this._extras.premiumFee); }\n\nThe last example is where the premium booking offers a behavior that isn’t present on\n\nthe superclass.\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget hasDinner() { return this._extras.hasOwnProperty('dinner') && !this.isPeakDay; }\n\nInheritance works well for this example. I can understand the base class without having\n\nto understand the subclass. The subclass is defined just by saying how it differs from\n\nthe base case—both reducing duplication and clearly communicating what are the\n\ndifferences it’s introducing.\n\nActually, it isn’t quite as perfect as the previous paragraph implies. There are things in\n\nthe superclass structure that only make sense due to the subclass—such as methods\n\nthat have been factored in such a way as to make it easier to override just the right\n\nkinds of behavior. So although most of the time I can modify the base class without\n\nhaving to understand subclasses, there are occasions where such mindful ignorance of\n\nthe subclasses will lead me to breaking a subclass by modifying the superclass.\n\nwww.EBooksWorld.ir",
      "content_length": 1396,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 429,
      "content": "However, if these occasions are not too common, the inheritance pays off—provided I\n\nhave good tests to detect a subclass breakage.\n\nSo why would I want to change such a happy situation by using Replace Subclass with\n\nDelegate? Inheritance is a tool that can only be used once—so if I have another reason\n\nto use inheritance, and I think it will benefit me more than the premium booking\n\nsubclass, I’ll need to handle premium bookings a different way. Also, I may need to\n\nchange from the default booking to the premium booking dynamically—i.e., support a\n\nmethod like aBooking.bePremium(). In some cases, I can avoid this by creating a\n\nwhole new object (a common example is where an HTTP request loads new data from\n\nthe server). But sometimes, I need to modify a data structure and not rebuild it from\n\nscratch, and it is difficult to just replace a single booking that’s referred to from many\n\ndifferent places. In such situations, it can be useful to allow a booking to switch from\n\ndefault to premium and back again.\n\nWhen these needs crop up, I need to apply Replace Subclass with Delegate. I have\n\nclients call the constructors of the two classes to make the bookings:\n\nbooking client\n\nClick here to view code image\n\naBooking = new Booking(show,date);\n\npremium client\n\nClick here to view code image\n\naBooking = new PremiumBooking(show, date, extras);\n\nRemoving subclasses will alter all of this, so I like to encapsulate the constructor calls\n\nwith Replace Constructor with Factory Function (334).\n\ntop level…\n\nClick here to view code image\n\nfunction createBooking(show, date) { return new Booking(show, date); } function createPremiumBooking(show, date, extras) {\n\nwww.EBooksWorld.ir",
      "content_length": 1692,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 430,
      "content": "return new PremiumBooking (show, date, extras); }\n\nbooking client\n\nClick here to view code image\n\naBooking = createBooking(show, date);\n\npremium client\n\nClick here to view code image\n\naBooking = createPremiumBooking(show, date, extras);\n\nI now make the new delegate class. Its constructor parameters are those parameters\n\nthat are only used in the subclass, together with a back­reference to the booking object.\n\nI’ll need this because several subclass methods require access to data stored in the\n\nsuperclass. Inheritance makes this easy to do, but with a delegate I need a back­\n\nreference.\n\nclass PremiumBookingDelegate…\n\nClick here to view code image\n\nconstructor(hostBooking, extras) { this._host = hostBooking; this._extras = extras; }\n\nI now connect the new delegate to the booking object. I do this by modifying the factory\n\nfunction for premium bookings.\n\ntop level…\n\nClick here to view code image\n\nfunction createPremiumBooking(show, date, extras) { const result = new PremiumBooking (show, date, extras); result._bePremium(extras); return result; }\n\nwww.EBooksWorld.ir",
      "content_length": 1079,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 431,
      "content": "class Booking…\n\nClick here to view code image\n\n_bePremium(extras) { this._premiumDelegate = new PremiumBookingDelegate(this, extras); }\n\nI use a leading underscore on _bePremium to indicate that it shouldn’t be part of the\n\npublic interface for Booking. Of course, if the point of doing this refactoring is to allow\n\na booking to mutate to premium, it can be a public method.\n\nAlternatively, I can do all the connections in the constructor for Booking. In order to\n\ndo that, I need some way to signal to the constructor that we have a premium booking.\n\nThat could be an extra parameter, or just the use of extras if I can be sure that it is\n\nalways present when used with a premium booking. Here, I prefer the explicitness of\n\ndoing this through the factory function.\n\nWith the structures set up, it’s time to start moving the behavior. The first case I’ll\n\nconsider is the simple override of hasTalkback. Here’s the existing code:\n\nclass Booking…\n\nClick here to view code image\n\nget hasTalkback() { return this._show.hasOwnProperty('talkback') && !this.isPeakDay; }\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget hasTalkback() { return this._show.hasOwnProperty('talkback'); }\n\nI use Move Function (198) to move the subclass method to the delegate. To make it fit\n\nits home, I route any access to superclass data with a call to _host.\n\nwww.EBooksWorld.ir",
      "content_length": 1367,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 432,
      "content": "class PremiumBookingDelegate…\n\nClick here to view code image\n\nget hasTalkback() { return this._host._show.hasOwnProperty('talkback'); }\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget hasTalkback() { return this._premiumDelegate.hasTalkback; }\n\nI test to ensure everything is working, then delete the subclass method:\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget hasTalkback() { return this._premiumDelegate.hasTalkback; }\n\nI run the tests at this point, expecting some to fail.\n\nNow I finish the move by adding dispatch logic to the superclass method to use the\n\ndelegate if it is present.\n\nclass Booking…\n\nClick here to view code image\n\nget hasTalkback() { return (this._premiumDelegate) ? this._premiumDelegate.hasTalkback : this._show.hasOwnProperty('talkback') && !this.isPeakDay; }\n\nThe next case I’ll look at is the base price.\n\nwww.EBooksWorld.ir",
      "content_length": 879,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 433,
      "content": "class Booking…\n\nClick here to view code image\n\nget basePrice() { let result = this._show.price; if (this.isPeakDay) result += Math.round(result * 0.15); return result; }\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget basePrice() { return Math.round(super.basePrice + this._extras.premiumFee); }\n\nThis is almost the same, but there is a wrinkle in the form of the pesky call on super\n\n(which is pretty common in these kinds of subclass extension cases). When I move the\n\nsubclass code to the delegate, I’ll need to call the parent case—but I can’t just call\n\nthis._host._basePrice without getting into an endless recursion.\n\nI have a couple of options here. One is to apply Extract Function (106) on the base\n\ncalculation to allow me to separate the dispatch logic from price calculation. (The rest\n\nof the move is as before.)\n\nclass Booking…\n\nClick here to view code image\n\nget basePrice() { return (this._premiumDelegate) ? this._premiumDelegate.basePrice : this._privateBasePrice; }\n\nget _privateBasePrice() { let result = this._show.price; if (this.isPeakDay) result += Math.round(result * 0.15); return result; }\n\nclass PremiumBookingDelegate…\n\nwww.EBooksWorld.ir",
      "content_length": 1179,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 434,
      "content": "Click here to view code image\n\nget basePrice() { return Math.round(this._host._privateBasePrice + this._extras.premiumFee); }\n\nAlternatively, I can recast the delegate’s method as an extension of the base method.\n\nclass Booking…\n\nClick here to view code image\n\nget basePrice() { let result = this._show.price; if (this.isPeakDay) result += Math.round(result * 0.15); return (this._premiumDelegate) ? this._premiumDelegate.extendBasePrice(result) : result; }\n\nclass PremiumBookingDelegate…\n\nClick here to view code image\n\nextendBasePrice(base) { return Math.round(base + this._extras.premiumFee); }\n\nBoth work reasonably here; I have a slight preference for the latter as it’s a bit smaller.\n\nThe last case is a method that only exists on the subclass.\n\nclass PremiumBooking…\n\nClick here to view code image\n\nget hasDinner() { return this._extras.hasOwnProperty('dinner') && !this.isPeakDay; }\n\nI move it from the subclass to the delegate:\n\nwww.EBooksWorld.ir",
      "content_length": 957,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 435,
      "content": "class PremiumBookingDelegate…\n\nClick here to view code image\n\nget hasDinner() { return this._extras.hasOwnProperty('dinner') && !this._host.isPeakDay; }\n\nI then add dispatch logic to Booking:\n\nclass Booking…\n\nClick here to view code image\n\nget hasDinner() { return (this._premiumDelegate) ? this._premiumDelegate.hasDinner : undefined; }\n\nIn JavaScript, accessing a property on an object where it isn’t defined returns\n\nundefined, so I do that here. (Although my every instinct is to have it raise an error,\n\nwhich would be the case in other object­oriented dynamic languages I’m used to.)\n\nOnce I’ve moved all the behavior out of the subclass, I can change the factory method to\n\nreturn the superclass—and, once I’ve run tests to ensure all is well, delete the subclass.\n\ntop level…\n\nClick here to view code image\n\nfunction createPremiumBooking(show, date, extras) { const result = new PremiumBooking (show, date, extras); result._bePremium(extras); return result; }\n\nclass PremiumBooking extends Booking ...\n\nThis is one of those refactorings where I don’t feel that refactoring alone improves the\n\ncode. Inheritance handles this situation very well, whereas using delegation involves\n\nadding dispatch logic, two­way references, and thus extra complexity. The refactoring\n\nwww.EBooksWorld.ir",
      "content_length": 1293,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 436,
      "content": "may still be worthwhile, since the advantage of a mutable premium status, or a need to\n\nuse inheritance for other purposes, may outweigh the disadvantage of losing\n\ninheritance.\n\nExample: Replacing a Hierarchy\n\nThe previous example showed using Replace Subclass with Delegate on a single\n\nsubclass, but I can do the same thing with an entire hierarchy.\n\nClick here to view code image\n\nfunction createBird(data) { switch (data.type) { case 'EuropeanSwallow': return new EuropeanSwallow(data); case 'AfricanSwallow': return new AfricanSwallow(data); case 'NorweigianBlueParrot': return new NorwegianBlueParrot(data); default: return new Bird(data); } }\n\nclass Bird { constructor(data) { this._name = data.name; this._plumage = data.plumage; } get name() {return this._name;}\n\nget plumage() { return this._plumage || \"average\"; } get airSpeedVelocity() {return null;} }\n\nclass EuropeanSwallow extends Bird { get airSpeedVelocity() {return 35;} }\n\nclass AfricanSwallow extends Bird { constructor(data) { super (data); this._numberOfCoconuts = data.numberOfCoconuts; } get airSpeedVelocity() { return 40 ­ 2 * this._numberOfCoconuts; } }\n\nwww.EBooksWorld.ir",
      "content_length": 1152,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 437,
      "content": "class NorwegianBlueParrot extends Bird { constructor(data) { super (data); this._voltage = data.voltage; this._isNailed = data.isNailed; }\n\nget plumage() { if (this._voltage > 100) return \"scorched\"; else return this._plumage || \"beautiful\"; } get airSpeedVelocity() { return (this._isNailed) ? 0 : 10 + this._voltage / 10; } }\n\nThe system will shortly be making a big difference between birds tagged in the wild and\n\nthose tagged in captivity. That difference could be modeled as two subclasses for Bird:\n\nWildBird and CaptiveBird. However, I can only use inheritance once, so if I want\n\nto use subclasses for wild versus captive, I’ll have to remove them for the species.\n\nWhen several subclasses are involved, I’ll tackle them one at a time, starting with a\n\nsimple one—in this case, EuropeanSwallow. I create an empty delegate class for the\n\ndelegate.\n\nClick here to view code image\n\nclass EuropeanSwallowDelegate { }\n\nI don’t put in any data or back­reference parameters yet. For this example, I’ll introduce\n\nthem as I need them.\n\nI need to decide where to handle the initialization of the delegate field. Here, since I\n\nhave all the information in the single data argument to the constructor, I decide to do it\n\nin the constructor. Since there are several delegates I could add, I make a function to\n\nselect the correct one based on the type code in the document.\n\nclass Bird…\n\nClick here to view code image\n\nconstructor(data) {\n\nwww.EBooksWorld.ir",
      "content_length": 1455,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 438,
      "content": "this._name = data.name; this._plumage = data.plumage; this._speciesDelegate = this.selectSpeciesDelegate(data); }\n\nselectSpeciesDelegate(data) { switch(data.type) { case 'EuropeanSwallow': return new EuropeanSwallowDelegate(); default: return null; } }\n\nNow I have the structure set up, I can apply Move Function (198) to the European\n\nswallow’s air speed velocity.\n\nclass EuropeanSwallowDelegate…\n\nClick here to view code image\n\nget airSpeedVelocity() {return 35;}\n\nclass EuropeanSwallow…\n\nClick here to view code image\n\nget airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity;}\n\nI change airSpeedVelocity on the superclass to call a delegate, if present.\n\nclass Bird…\n\nClick here to view code image\n\nget airSpeedVelocity() { return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null; }\n\nI remove the subclass.\n\nClick here to view code image\n\nwww.EBooksWorld.ir",
      "content_length": 895,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 439,
      "content": "class EuropeanSwallow extends Bird { get airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity;} }\n\ntop level…\n\nClick here to view code image\n\nfunction createBird(data) { switch (data.type) { case 'EuropeanSwallow': return new EuropeanSwallow(data); case 'AfricanSwallow': return new AfricanSwallow(data); case 'NorweigianBlueParrot': return new NorwegianBlueParrot(data); default: return new Bird(data); } }\n\nNext I’ll tackle the African swallow. I create a class; this time, the constructor needs the\n\ndata document.\n\nclass AfricanSwallowDelegate…\n\nClick here to view code image\n\nconstructor(data) { this._numberOfCoconuts = data.numberOfCoconuts; }\n\nclass Bird…\n\nClick here to view code image\n\nselectSpeciesDelegate(data) { switch(data.type) { case 'EuropeanSwallow': return new EuropeanSwallowDelegate(); case 'AfricanSwallow': return new AfricanSwallowDelegate(data); default: return null; }\n\nwww.EBooksWorld.ir",
      "content_length": 928,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 440,
      "content": "}\n\nI use Move Function (198) on airSpeedVelocity.\n\nclass AfricanSwallowDelegate…\n\nClick here to view code image\n\nget airSpeedVelocity() { return 40 ­ 2 * this._numberOfCoconuts; }\n\nclass AfricanSwallow…\n\nClick here to view code image\n\nget airSpeedVelocity() { return this._speciesDelegate.airSpeedVelocity; }\n\nI can now remove the African swallow subclass.\n\nClick here to view code image\n\nclass AfricanSwallow extends Bird { // all of the body ... }\n\nfunction createBird(data) { switch (data.type) { case 'AfricanSwallow': return new AfricanSwallow(data); case 'NorweigianBlueParrot': return new NorwegianBlueParrot(data); default: return new Bird(data); } }\n\nNow for the Norwegian blue. Creating the class and moving the air speed velocity uses\n\nthe same steps as before, so I’ll just show the result.\n\nclass Bird…\n\nwww.EBooksWorld.ir",
      "content_length": 835,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 441,
      "content": "Click here to view code image\n\nselectSpeciesDelegate(data) { switch(data.type) { case 'EuropeanSwallow': return new EuropeanSwallowDelegate(); case 'AfricanSwallow': return new AfricanSwallowDelegate(data); case 'NorweigianBlueParrot': return new NorwegianBlueParrotDelegate(data); default: return null; } }\n\nclass NorwegianBlueParrotDelegate…\n\nClick here to view code image\n\nconstructor(data) { this._voltage = data.voltage; this._isNailed = data.isNailed; } get airSpeedVelocity() { return (this._isNailed) ? 0 : 10 + this._voltage / 10; }\n\nAll well and good, but the Norwegian blue overrides the plumage property, which I\n\ndidn’t have to deal with for the other cases. The initial Move Function (198) is simple\n\nenough, albeit with the need to modify the constructor to put in a back­reference to the\n\nbird.\n\nclass NorwegianBlueParrot…\n\nClick here to view code image\n\nget plumage() { return this._speciesDelegate.plumage; }\n\nclass NorwegianBlueParrotDelegate…\n\nClick here to view code image\n\nget plumage() {\n\nwww.EBooksWorld.ir",
      "content_length": 1030,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 442,
      "content": "if (this._voltage > 100) return \"scorched\"; else return this._bird._plumage || \"beautiful\"; }\n\nconstructor(data, bird) { this._bird = bird; this._voltage = data.voltage; this._isNailed = data.isNailed; }\n\nclass Bird…\n\nClick here to view code image\n\nselectSpeciesDelegate(data) { switch(data.type) { case 'EuropeanSwallow': return new EuropeanSwallowDelegate(); case 'AfricanSwallow': return new AfricanSwallowDelegate(data); case 'NorweigianBlueParrot': return new NorwegianBlueParrotDelegate(data, this); default: return null; } }\n\nThe tricky step is how to remove the subclass method for plumage. If I do\n\nclass Bird…\n\nClick here to view code image\n\nget plumage() { if (this._speciesDelegate) return this._speciesDelegate.plumage; else return this._plumage || \"average\"; }\n\nthen I’ll get a bunch of errors because there is no plumage property on the other\n\nspecies’ delegate classes.\n\nI could use a more precise conditional:\n\nclass Bird…\n\nwww.EBooksWorld.ir",
      "content_length": 959,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 443,
      "content": "Click here to view code image\n\nget plumage() { if (this._speciesDelegate instanceof NorwegianBlueParrotDelegate) return this._speciesDelegate.plumage; else return this._plumage || \"average\"; }\n\nBut I hope that smells as much of decomposing parrot to you as it does to me. It’s\n\nalmost never a good idea to use an explicit class check like this.\n\nAnother option is to implement the default case on the other delegates.\n\nclass Bird…\n\nClick here to view code image\n\nget plumage() { if (this._speciesDelegate) return this._speciesDelegate.plumage; else return this._plumage || \"average\"; }\n\nclass EuropeanSwallowDelegate…\n\nClick here to view code image\n\nget plumage() { return this._bird._plumage || \"average\"; }\n\nclass AfricanSwallowDelegate…\n\nClick here to view code image\n\nget plumage() { return this._bird._plumage || \"average\"; }\n\nBut this duplicates the default method for plumage. And if that’s not bad enough, I also\n\nget some bonus duplication in the constructors to assign the back­reference.\n\nwww.EBooksWorld.ir",
      "content_length": 1018,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 444,
      "content": "The solution to the duplication is, naturally, inheritance—I apply Extract Superclass\n\n(375) to the species delegates:\n\nClick here to view code image\n\nclass SpeciesDelegate { constructor(data, bird) { this._bird = bird; } get plumage() { return this._bird._plumage || \"average\"; }\n\nclass EuropeanSwallowDelegate extends SpeciesDelegate {\n\nclass AfricanSwallowDelegate extends SpeciesDelegate { constructor(data, bird) { super(data,bird); this._numberOfCoconuts = data.numberOfCoconuts; }\n\nclass NorwegianBlueParrotDelegate extends SpeciesDelegate { constructor(data, bird) { super(data, bird); this._voltage = data.voltage; this._isNailed = data.isNailed; }\n\nIndeed, now I have a superclass, I can move any default behavior from Bird to\n\nSpeciesDelegate by ensuring there’s always something in the speciesDelegate\n\nfield.\n\nclass Bird…\n\nClick here to view code image\n\nselectSpeciesDelegate(data) { switch(data.type) { case 'EuropeanSwallow': return new EuropeanSwallowDelegate(data, this); case 'AfricanSwallow': return new AfricanSwallowDelegate(data, this); case 'NorweigianBlueParrot': return new NorwegianBlueParrotDelegate(data, this); default: return new SpeciesDelegate(data, this); } } // rest of bird's code...\n\nwww.EBooksWorld.ir",
      "content_length": 1238,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 445,
      "content": "get plumage() {return this._speciesDelegate.plumage;}\n\nget airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity;}\n\nclass SpeciesDelegate…\n\nClick here to view code image\n\nget airSpeedVelocity() {return null;}\n\nI like this, as it simplifies the delegating methods on Bird. I can easily see which\n\nbehavior is delegated to the species delegate and which stays behind.\n\nHere’s the final state of these classes:\n\nClick here to view code image\n\nfunction createBird(data) { return new Bird(data); }\n\nclass Bird { constructor(data) { this._name = data.name; this._plumage = data.plumage; this._speciesDelegate = this.selectSpeciesDelegate(data); } get name() {return this._name;} get plumage() {return this._speciesDelegate.plumage;} get airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity;}\n\nselectSpeciesDelegate(data) { switch(data.type) { case 'EuropeanSwallow': return new EuropeanSwallowDelegate(data, this); case 'AfricanSwallow': return new AfricanSwallowDelegate(data, this); case 'NorweigianBlueParrot': return new NorwegianBlueParrotDelegate(data, this); default: return new SpeciesDelegate(data, this); } } // rest of bird's code... }\n\nclass SpeciesDelegate { constructor(data, bird) {\n\nwww.EBooksWorld.ir",
      "content_length": 1236,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 446,
      "content": "this._bird = bird; } get plumage() { return this._bird._plumage || \"average\"; } get airSpeedVelocity() {return null;} }\n\nclass EuropeanSwallowDelegate extends SpeciesDelegate { get airSpeedVelocity() {return 35;} }\n\nclass AfricanSwallowDelegate extends SpeciesDelegate { constructor(data, bird) { super(data,bird); this._numberOfCoconuts = data.numberOfCoconuts; } get airSpeedVelocity() { return 40 ­ 2 * this._numberOfCoconuts; } }\n\nclass NorwegianBlueParrotDelegate extends SpeciesDelegate { constructor(data, bird) { super(data, bird); this._voltage = data.voltage; this._isNailed = data.isNailed; } get airSpeedVelocity() { return (this._isNailed) ? 0 : 10 + this._voltage / 10; } get plumage() { if (this._voltage > 100) return \"scorched\"; else return this._bird._plumage || \"beautiful\"; } }\n\nThis example replaces the original subclasses with a delegate, but there is still a very\n\nsimilar inheritance structure in SpeciesDelegate. Have I gained anything from this\n\nrefactoring, other than freeing up inheritance on Bird? The species inheritance is now\n\nmore tightly scoped, covering just the data and functions that vary due to the species.\n\nAny code that’s the same for all species remains on Bird and its future subclasses.\n\nI could apply the same idea of creating a superclass delegate to the booking example\n\nearlier. This would allow me to replace those methods on Booking that have dispatch\n\nlogic with simple calls to the delegate and letting its inheritance sort out the dispatch.\n\nHowever, it’s nearly dinner time, so I’ll leave that as an exercise for the reader.\n\nwww.EBooksWorld.ir",
      "content_length": 1601,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 447,
      "content": "These examples illustrate that the phrase “Favor object composition over class\n\ninheritance” might better be said as “Favor a judicious mixture of composition and\n\ninheritance over either alone”—but I fear that is not as catchy.\n\nREPLACE SUPERCLASS WITH DELEGATE\n\nformerly: Replace Inheritance with Delegation\n\nMotivation\n\nIn object­oriented programs, inheritance is a powerful and easily available way to reuse\n\nexisting functionality. I inherit from some existing class, then override and add\n\nadditional features. But subclassing can be done in a way that leads to confusion and\n\ncomplication.\n\nOne of the classic examples of mis­inheritance from the early days of objects was\n\nmaking a stack be a subclass of list. The idea that led to this was reusing of list’s data\n\nstorage and operations to manipulate it. While it’s good to reuse, this inheritance had a\n\nproblem: All the operations of the list were present on the interface of the stack,\n\nalthough most of them were not applicable to a stack. A better approach is to make the\n\nlist into a field of the stack and delegate the necessary operations to it.\n\nThis is an example of one reason to use Replace Superclass with Delegate—if functions\n\nwww.EBooksWorld.ir",
      "content_length": 1219,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 448,
      "content": "of the superclass don’t make sense on the subclass, that’s a sign that I shouldn’t be\n\nusing inheritance to use the superclass’s functionality.\n\nAs well as using all the functions of the superclass, it should also be true that every\n\ninstance of the subclass is an instance of the superclass and a valid object in all cases\n\nwhere we’re using the superclass. If I have a car model class, with things like name and\n\nengine size, I might think I could reuse these features to represent a physical car,\n\nadding functions for VIN number and manufacturing date. This is a common, and often\n\nsubtle, modeling mistake which I’ve called the type­instance homonym [mf­tih].\n\nThese are both examples of problems leading to confusion and errors—which can be\n\neasily avoided by replacing inheritance with delegation to a separate object. Using\n\ndelegation makes it clear that it is a separate thing—one where only some of the\n\nfunctions carry over.\n\nEven in cases where the subclass is reasonable modeling, I use Replace Super­class with\n\nDelegate because the relationship between a sub­ and superclass is highly coupled, with\n\nthe subclass easily broken by changes in the superclass. The downside is that I need to\n\nwrite a forwarding function for any function that is the same in the host and in the\n\ndelegate—but, fortunately, even though such forwarding functions are boring to write,\n\nthey are too simple to get wrong.\n\nAs a consequence of all this, some people advise avoiding inheritance entirely—but I\n\ndon’t agree with that. Provided the appropriate semantic conditions apply (every\n\nmethod on the supertype applies to the subtype, every instance of the subtype is an\n\ninstance of the supertype), inheritance is a simple and effective mechanism. I can easily\n\napply Replace Superclass with Delegate should the situation change and inheritance is\n\nno longer the best option. So my advice is to (mostly) use inheritance first, and apply\n\nReplace Superclass with Delegate when (and if) it becomes a problem.\n\nMechanics\n\nCreate a field in the subclass that refers to the superclass object. Initialize this\n\ndelegate reference to a new instance.\n\nFor each element of the superclass, create a forwarding function in the subclass that\n\nforwards to the delegate reference. Test after forwarding each consistent group.\n\nMost of the time you can test after each function that’s forwarded, but, for example,\n\nget/set pairs can only be tested once both have been moved.\n\nwww.EBooksWorld.ir",
      "content_length": 2474,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 449,
      "content": "When all superclass elements have been overridden with forwarders, remove the\n\ninheritance link.\n\nExample\n\nI recently was consulting for an old town’s library of ancient scrolls. They keep details\n\nof their scrolls in a catalog. Each scroll has an ID number and records its title and list of\n\ntags.\n\nclass CatalogItem…\n\nClick here to view code image\n\nconstructor(id, title, tags) { this._id = id; this._title = title; this._tags = tags; }\n\nget id() {return this._id;} get title() {return this._title;} hasTag(arg) {return this._tags.includes(arg);}\n\nOne of the things that scrolls need is regular cleaning. The code for that uses the catalog\n\nitem and extends it with the data it needs for cleaning.\n\nclass Scroll extends CatalogItem…\n\nClick here to view code image\n\nconstructor(id, title, tags, dateLastCleaned) { super(id, title, tags); this._lastCleaned = dateLastCleaned; }\n\nneedsCleaning(targetDate) { const threshold = this.hasTag(\"revered\") ? 700 : 1500; return this.daysSinceLastCleaning(targetDate) > threshold ; } daysSinceLastCleaning(targetDate) { return this._lastCleaned.until(targetDate, ChronoUnit.DAYS); }\n\nThis is an example of a common modeling error. There is a difference between the\n\nphysical scroll and the catalog item. The scroll describing the treatment for the\n\nwww.EBooksWorld.ir",
      "content_length": 1307,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 450,
      "content": "greyscale disease may have several copies, but be just one item in the catalog.\n\nIt many situations, I can get away with an error like this. I can think of the title and tags\n\nas copies of data in the catalog. Should this data never change, I can get away with this\n\nrepresentation. But if I need to update either, I must be careful to ensure that all copies\n\nof the same catalog item are updated correctly.\n\nEven without this issue, I’d still want to change the relationship. Using catalog item as a\n\nsuperclass to scroll is likely to confuse programmers in the future, and is thus a poor\n\nmodel to work with.\n\nI begin by creating a property in Scroll that refers to the catalog item, initializing it\n\nwith a new instance.\n\nclass Scroll extends CatalogItem…\n\nClick here to view code image\n\nconstructor(id, title, tags, dateLastCleaned) { super(id, title, tags); this._catalogItem = new CatalogItem(id, title, tags); this._lastCleaned = dateLastCleaned; }\n\nI create forwarding methods for each element of the superclass that I use on the\n\nsubclass.\n\nclass Scroll…\n\nClick here to view code image\n\nget id() {return this._catalogItem.id;} get title() {return this._catalogItem.title;} hasTag(aString) {return this._catalogItem.hasTag(aString);}\n\nI remove the inheritance link to the catalog item.\n\nClick here to view code image\n\nclass Scroll extends CatalogItem{ constructor(id, title, tags, dateLastCleaned) { super(id, title, tags); this._catalogItem = new CatalogItem(id, title, tags);\n\nwww.EBooksWorld.ir",
      "content_length": 1505,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 451,
      "content": "this._lastCleaned = dateLastCleaned; }\n\nBreaking the inheritance link finishes the basic Replace Superclass with Delegate\n\nrefactoring, but there is something more I need to do in this case.\n\nThe refactoring shifts the role of the catalog item to that of a component of scroll; each\n\nscroll contains a unique instance of a catalog item. In many cases where I do this\n\nrefactoring, this is enough. However, in this situation a better model is to link the\n\ngreyscale catalog item to the six scrolls in the library that are copies of that writing.\n\nDoing this is, essentially, Change Value to Reference (256).\n\nThere’s a problem that I have to fix, however, before I use Change Value to Reference\n\n(256). In the original inheritance structure, the scroll used the catalog item’s ID field to\n\nstore its ID. But if I treat the catalog item as a reference, it needs to use that ID for the\n\ncatalog item ID rather than the scroll ID. This means I need to create an ID field on\n\nscroll and use that instead of one in catalog item. It’s a sort­of move, sort­of split.\n\nclass Scroll…\n\nClick here to view code image\n\nconstructor(id, title, tags, dateLastCleaned) { this._id = id; this._catalogItem = new CatalogItem(null, title, tags); this._lastCleaned = dateLastCleaned; }\n\nget id() {return this._id;}\n\nCreating a catalog item with a null ID would usually raise red flags and cause alarms to\n\nsound. But that’s just temporary while I get things into shape. Once I’ve done that, the\n\nscrolls will refer to a shared catalog item with its proper ID.\n\nCurrently the scrolls are loaded as part of a load routine.\n\nload routine…\n\nClick here to view code image\n\nconst scrolls = aDocument .map(record => new Scroll(record.id, record.catalogData.title,\n\nwww.EBooksWorld.ir",
      "content_length": 1754,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 452,
      "content": "record.catalogData.tags, LocalDate.parse(record.lastCleaned)));\n\nThe first step in Change Value to Reference (256) is finding or creating a repository. I\n\nfind there is a repository that I can easily import into the load routine. The repository\n\nsupplies catalog items indexed by an ID. My next task is to see how to get that ID into\n\nthe constructor of the scroll. Fortunately, it’s present in the input data and was being\n\nignored as it wasn’t useful when using inheritance. With that sorted out, I can now use\n\nChange Function Declaration (124) to add both the catalog and the catalog item’s ID to\n\nthe constructor parameters.\n\nload routine…\n\nClick here to view code image\n\nconst scrolls = aDocument .map(record => new Scroll(record.id, record.catalogData.title, record.catalogData.tags, LocalDate.parse(record.lastCleaned), record.catalogData.id, catalog));\n\nclass Scroll…\n\nClick here to view code image\n\nconstructor(id, title, tags, dateLastCleaned, catalogID, catalog) { this._id = id; this._catalogItem = new CatalogItem(null, title, tags); this._lastCleaned = dateLastCleaned; }\n\nI now modify the constructor to use the catalog ID to look up the catalog item and use it\n\ninstead of creating a new one.\n\nclass Scroll…\n\nClick here to view code image\n\nconstructor(id, title, tags, dateLastCleaned, catalogID, catalog) { this._id = id; this._catalogItem = catalog.get(catalogID);\n\nwww.EBooksWorld.ir",
      "content_length": 1403,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 453,
      "content": "this._lastCleaned = dateLastCleaned; }\n\nI no longer need the title and tags passed into the constructor, so I use Change\n\nFunction Declaration (124) to remove them.\n\nload routine…\n\nClick here to view code image\n\nconst scrolls = aDocument .map(record => new Scroll(record.id, record.catalogData.title, record.catalogData.tags, LocalDate.parse(record.lastCleaned), record.catalogData.id, catalog));\n\nclass Scroll…\n\nClick here to view code image\n\nconstructor(id, title, tags, dateLastCleaned, catalogID, catalog) { this._id = id; this._catalogItem = catalog.get(catalogID); this._lastCleaned = dateLastCleaned; }\n\nwww.EBooksWorld.ir",
      "content_length": 629,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 454,
      "content": "www.EBooksWorld.ir",
      "content_length": 18,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 455,
      "content": "www.EBooksWorld.ir",
      "content_length": 18,
      "extraction_method": "Unstructured"
    }
  ]
}